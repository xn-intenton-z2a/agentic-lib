.github/FUNDING.yml
==== Content of .github/FUNDING.yml ====
github: Antony-at-Polycode
# paypal: https://www.paypal.com/donate/?hosted_button_id=Y8PK8XP3EJLWG
.github/workflows/wfr-generate-issue.yml
==== Content of .github/workflows/wfr-generate-issue.yml ====
# .github/workflows/wfr-generate-issue.yml

#
# agentic-lib
# Copyright (C) 2025 Polycode Limited
#
# This file is part of agentic-lib.
#
# agentic-lib is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License v3.0 (GPL‑3).
# along with this program. If not, see <https://www.gnu.org/licenses/>.
#
# IMPORTANT: Any derived work must include the following attribution:
# "This work is derived from https://github.com/xn-intenton-z2a/agentic-lib"
#

name: ∞ generate-issue

on:
  workflow_call:
    inputs:
      prompt:
        description: 'The prompt to guide the issue creation. e.g. "Make an improvement to tests."'
        type: string
        required: true
      target:
        description: 'The target file to create the issue to change. e.g. "src/lib/main.js"'
        type: string
        required: false
        default: 'src/lib/main.js'
      testFile:
        description: 'The test file. e.g. "tests/unit/main.test.js"'
        type: string
        required: false
        default: 'tests/unit/main.test.js'
      readmeFile:
        description: 'The README file. e.g. "README.md"'
        type: string
        required: false
        default: 'README.md'
      missionFile:
        description: 'The MISSION statement file. e.g. "MISSION.md"'
        type: string
        required: false
        default: 'MISSION.md'
      contributingFile:
        description: 'The CONTRIBUTING file. e.g. "CONTRIBUTING.md"'
        type: string
        required: false
        default: 'CONTRIBUTING.md'
      dependenciesFile:
        description: 'The dependencies file. e.g. "package.json"'
        type: string
        required: false
        default: 'package.json'
      buildScript:
        description: 'The script must be runnable as: `npm ci ; <script>` and succeed with a zero exit code. e.g. `npm run build`'
        type: string
        required: false
        default: 'echo "No build script specified."'
      testScript:
        description: 'The script must be runnable as: `npm ci ; <script>` and succeed with a zero exit code. e.g. `npm test`'
        type: string
        required: false
        default: 'npm test'
      mainScript:
        description: 'The script must be runnable as: `npm ci ; <script>` and succeed with a zero exit code. e.g. `npm run start`'
        type: string
        required: false
        default: 'npm run start'
      model:
        description: 'The OpenAI model to use. e.g. "o3-mini"'
        type: string
        required: false
        default: ${{ vars.CHATGPT_API_MODEL || 'o3-mini' }}
      npmAuthOrganisation:
        description: 'The GitHub organisation to authenticate with for npm. e.g. "xn-intenton-z2a"'
        type: string
        required: false
        default: ''
    secrets:
      PERSONAL_ACCESS_TOKEN:
        required: false
      CHATGPT_API_SECRET_KEY:
        required: true
    outputs:
      issueTitle:
        value: ${{ jobs.generate-issue.outputs.issueTitle }}
      issueDescription:
        value: ${{ jobs.generate-issue.outputs.issueDescription }}

jobs:
  generate-issue:
    runs-on: ubuntu-latest

    env:
      prompt: ${{ inputs.prompt || '' }}
      target: ${{ inputs.target || 'src/lib/main.js' }}
      testFile: ${{ inputs.testFile || 'tests/unit/main.test.js' }}
      readmeFile: ${{ inputs.readmeFile || 'README.md' }}
      missionFile: ${{ inputs.missionFile || 'MISSION.md' }}
      contributingFile: ${{ inputs.contributingFile || 'CONTRIBUTING.md' }}
      dependenciesFile: ${{ inputs.dependenciesFile || 'package.json' }}
      buildScript: ${{ inputs.buildScript || 'npm run build' }}
      testScript: ${{ inputs.testScript || 'npm test' }}
      mainScript: ${{ inputs.mainScript || 'npm run start' }}
      mainScriptTimeout: '5m'
      model: ${{ inputs.model || vars.CHATGPT_API_MODEL || 'o3-mini' }}
      npmAuthOrganisation: ${{ inputs.npmAuthOrganisation || '' }}
      chatgptApiSecretKey: ${{ secrets.CHATGPT_API_SECRET_KEY }}

    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Check GitHub authentication
        if: ${{ env.npmAuthOrganisation != '' }}
        shell: bash
        run: |
          curl --include --header "Authorization: token ${{ secrets.PERSONAL_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}" https://api.github.com/user

      - name: Set up .npmrc
        if: ${{ env.npmAuthOrganisation != '' }}
        shell: bash
        run: |
          echo "${{ env.npmAuthOrganisation }}:registry=https://npm.pkg.github.com" >> .npmrc
          echo "//npm.pkg.github.com/:_authToken=${{ secrets.PERSONAL_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}" >> .npmrc
          echo "always-auth=true" >> .npmrc

      - run: npm ci

      - name: List dependencies
        id: list
        shell: bash
        run: |
          output=$(npm list 2>&1)
          echo "output<<EOF" >> "$GITHUB_OUTPUT"
          echo "$output" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          echo "output=${output}"

      - name: Build project
        id: build
        shell: bash
        run: |
          output=$(${{ env.buildScript }} 2>&1)
          echo "output<<EOF" >> "$GITHUB_OUTPUT"
          echo "$output" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          echo "output=${output}"

      - name: Tear down .npmrc
        if: ${{ env.npmAuthOrganisation != '' }}
        shell: bash
        run: rm -f .npmrc

      - name: Run tests
        id: test
        shell: bash
        run: |
          output=$(${{ env.testScript }} 2>&1)
          echo "output<<EOF" >> "$GITHUB_OUTPUT"
          echo "$output" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          echo "output=${output}"

      - name: Run main
        id: main
        shell: bash
        run: |
          output=$(timeout ${{ env.mainScriptTimeout }} ${{ env.mainScript }} 2>&1)
          echo "output<<EOF" >> "$GITHUB_OUTPUT"
          echo "$output" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          echo "output=${output}"

      - name: generate-issue
        id: generate-issue
        uses: actions/github-script@v7
        env:
          dependenciesListOutput: ${{ steps.list.outputs.output }}
          buildOutput: ${{ steps.build.outputs.output }}
          testOutput: ${{ steps.test.outputs.output }}
          mainOutput: ${{ steps.main.outputs.output }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const target = process.env.target;
            const testFile = process.env.testFile;
            const readmeFile = process.env.readmeFile;
            const missionFile = process.env.missionFile;
            const contributingFile = process.env.contributingFile;
            const dependenciesFile = process.env.dependenciesFile;
            const model = process.env.model;
            const apiKey = process.env.chatgptApiSecretKey;
            const prompt = parseInt(process.env.prompt);
            const dependenciesListOutput = process.env.dependenciesListOutput;
            const buildScript = process.env.buildScript;
            const buildOutput = process.env.buildOutput;
            const testScript = process.env.testScript;
            const testOutput = process.env.testOutput;
            const mainScript = process.env.mainScript;
            const mainOutput = process.env.mainOutput;

            const fs = require('fs');
            const OpenAI = require('openai').default;
            const { z } = require('zod');
            require('dotenv').config();

            // Gather the titles of all open issues
            const openIssues = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open'
            });
            core.info(`Open issues: ${JSON.stringify(openIssues)}`);
            const openIssueTitles = openIssues.data.map(issue => issue.title).join(', ');
            core.info(`Open issue titles: ${openIssueTitles}`);
  
            if (!apiKey) { 
              core.setFailed("Missing CHATGPT_API_SECRET_KEY"); 
            }
            const openai = new OpenAI({ apiKey });

            core.info(`target: "${target}"`);
            core.info(`testFile: "${testFile}"`);
            core.info(`readmeFile: "${readmeFile}"`);
            core.info(`missionFile: "${missionFile}"`);
            core.info(`contributingFile: "${contributingFile}"`);
            core.info(`dependenciesFile: "${dependenciesFile}"`);
            const sourceFileContent = fs.readFileSync(target, 'utf8');
            const testFileContent = fs.readFileSync(testFile, 'utf8');
            const readmeFileContent = fs.readFileSync(readmeFile, 'utf8');
            const missionFileContent = fs.readFileSync(missionFile, 'utf8');
            const contributingFileContent = fs.readFileSync(contributingFile, 'utf8');
            const dependenciesFileContent = fs.readFileSync(dependenciesFile, 'utf8');
            core.info(`Target file '${target}' has been loaded (length ${sourceFileContent.length}).`);
            core.info(`Test file '${testFile}' has been loaded (length ${testFileContent.length}).`);
            core.info(`Readme file '${readmeFile}' has been loaded (length ${readmeFileContent.length}).`);
            core.info(`Dependencies file '${dependenciesFile}' has been loaded (length ${dependenciesFileContent.length}).`);
            
            const chatGptPrompt = `
            Please generate the title and description of a GitHub issue to which will be used to action the supplied prompt.
            The issue will be resolved by an LLM which can process over 100,000 tokens of context and it will provide completed source files in the response.
            Do not include steps that would need to be taken manually by a human and expect to "dry-run" without an execution environment.
            Ensure that the issue is distinct from any existing open issues in the repository so tha the new issue remains valid when the other open issues are closed.
            Consider the following when refining your response:
            * Prompt details
            * Source file content
            * Test file content
            * README file content issue
            * MISSION file content
            * Contributing file content
            * Dependencies file content
            * Dependency list
            * Build output
            * Test output
            * Main execution output
            * Open issue titles
            
            Source file: ${target}
            SOURCE_FILE_START
            ${sourceFileContent}
            SOURCE_FILE_END
            
            Test file: ${testFile}
            TEST_FILE_START
            ${testFileContent}
            TEST_FILE_END

            README file: ${readmeFile}
            README_FILE_START
            ${readmeFileContent}
            README_FILE_END
            
            MISSION file: ${missionFile}
            MISSION_FILE_START
            ${missionFileContent}
            MISSION_FILE_END

            Contributing file: ${contributingFile}
            CONTRIBUTING_FILE_START
            ${contributingFileContent}
            CONTRIBUTING_FILE_END
            
            Dependencies file: ${dependenciesFile}
            DEPENDENCIES_FILE_START
            ${dependenciesFileContent}
            DEPENDENCIES_FILE_END
            
            Prompt:
            PROMPT_START
            ${prompt}
            PROMPT_END            

            Dependencies list from command: npm list
            DEPENDENCIES_LIST_START
            ${dependenciesListOutput}
            DEPENDENCIES_LIST_END    
            
            Build output from command: ${buildScript}
            TEST_OUTPUT_START
            ${buildOutput}
            TEST_OUTPUT_END      
            
            Test output from command: ${testScript}
            TEST_OUTPUT_START
            ${testOutput}
            TEST_OUTPUT_END            

            Main output from command: ${mainScript}
            MAIN_OUTPUT_START
            ${mainOutput}
            MAIN_OUTPUT_END    
            
            Open issue titles:
            OPEN_ISSUE_TITLES_START
            ${openIssueTitles}
            OPEN_ISSUE_TITLES_END
            
            Answer strictly with a JSON object following this schema:
            {
              "issueTitle": "The Title", // A summary of the change to make as a title.
              "issueDescription": "The description.", // Detail about the change, how to apply and verify it.
            }
            Ensure valid JSON.
            `;
            
            const ResponseSchema = z.object({ issueTitle: z.string(), issueDescription: z.string() });
            
            // Define the function schema for function calling
            const tools = [{
              type: "function",
              function: {
                name: "generate_issue",
                description: "Elaborate on the supplied prompt and project files to create the issueTitle and issueDescription of a GitHub Issue. Return an object with issueTitle (string), and issueDescription (string).",
                parameters: {
                  type: "object",
                  properties: {
                    issueTitle: { type: "string", description: "A summary of the change to make as a title." },
                    issueDescription: { type: "string", description: "Detail about the change, how to apply and verify it." }
                  },
                  required: ["issueTitle", "issueDescription"],
                  additionalProperties: false
                },
                strict: true
              }
            }];

            // Call OpenAI using function calling format
            const response = await openai.chat.completions.create({
              model,
              messages: [
                { role: "system", content: "You are evaluating whether an issue has been resolved in the supplied source code. Answer strictly with a JSON object following the provided function schema." },
                { role: "user", content: chatGptPrompt }
              ],
              tools: tools
            });
            
            let result;
            if (response.choices[0].message.tool_calls && response.choices[0].message.tool_calls.length > 0) {
              try {
                result = JSON.parse(response.choices[0].message.tool_calls[0].function.arguments);
              } catch (e) {
                core.setFailed(`Failed to parse function call arguments: ${e.message}`);
              }
            } else if (response.choices[0].message.content) {
              try {
                result = JSON.parse(response.choices[0].message.content);
              } catch (e) {
                core.setFailed(`Failed to parse response content: ${e.message}`);
              }
            } else {
              core.setFailed("No valid response received from OpenAI.");
            }
            
            try {
              const parsed = ResponseSchema.parse(result);
              core.setOutput("issueTitle", parsed.issueTitle);
              core.setOutput("issueDescription", parsed.issueDescription);
              core.info(`issueTitle: "${parsed.issueTitle}"`);
              core.info(`issueDescription: "${parsed.issueDescription}"`);
            
            } catch (e) {
              core.setFailed(`Failed to parse ChatGPT response: ${e.message}`);
            }
            
            core.setOutput("response", JSON.stringify(response));
            core.setOutput("usage", JSON.stringify(response.usage));
            core.info(`response: "${JSON.stringify(response)}"`);
            core.info(`usage: "${JSON.stringify(response.usage)}"`);
    outputs:
      issueTitle: ${{ steps.generate-issue.outputs.issueTitle }}
      issueDescription: ${{ steps.generate-issue.outputs.issueDescription }}
.github/workflows/wfr-review-issue.yml
==== Content of .github/workflows/wfr-review-issue.yml ====
# .github/workflows/wfr-review-issue.yml

#
# agentic-lib
# Copyright (C) 2025 Polycode Limited
#
# This file is part of agentic-lib.
#
# agentic-lib is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License v3.0 (GPL‑3).
# along with this program. If not, see <https://www.gnu.org/licenses/>.
#
# IMPORTANT: Any derived work must include the following attribution:
# "This work is derived from https://github.com/xn-intenton-z2a/agentic-lib"
#

name: ∞ review-issue

on:
  workflow_call:
    inputs:
      issueNumber:
        description: 'The issue number to review. e.g. "123"'
        type: string
        required: true
      target:
        description: 'The target file to review. e.g. "src/lib/main.js"'
        type: string
        required: false
        default: 'src/lib/main.js'
      testFile:
        description: 'The test file to review. e.g. "tests/unit/main.test.js"'
        type: string
        required: false
        default: 'tests/unit/main.test.js'
      readmeFile:
        description: 'The README file to review. e.g. "README.md"'
        type: string
        required: false
        default: 'README.md'
      missionFile:
        description: 'The MISSION statement file. e.g. "MISSION.md"'
        type: string
        required: false
        default: 'MISSION.md'
      contributingFile:
        description: 'The CONTRIBUTING file to review. e.g. "CONTRIBUTING.md"'
        type: string
        required: false
        default: 'CONTRIBUTING.md'
      dependenciesFile:
        description: 'The dependencies file to review. e.g. "package.json"'
        type: string
        required: false
        default: 'package.json'
      buildScript:
        description: 'The script must be runnable as: `npm ci ; <script>` and succeed with a zero exit code. e.g. `npm run build`'
        type: string
        required: false
        default: 'echo "No build script specified."'
      testScript:
        description: 'The script must be runnable as: `npm ci ; <script>` and succeed with a zero exit code. e.g. `npm test`'
        type: string
        required: false
        default: 'npm test'
      mainScript:
        description: 'The script must be runnable as: `npm ci ; <script>` and succeed with a zero exit code. e.g. `npm run start`'
        type: string
        required: false
        default: 'npm run start'
      model:
        description: 'The OpenAI model to use. e.g. "o3-mini"'
        type: string
        required: false
        default: ${{ vars.CHATGPT_API_MODEL || 'o3-mini' }}
    secrets:
      PERSONAL_ACCESS_TOKEN:
        required: false
      CHATGPT_API_SECRET_KEY:
        required: true
    outputs:
      fixed:
        value: ${{ jobs.review-issue.outputs.fixed }}

jobs:
  review-issue:
    runs-on: ubuntu-latest

    env:
      issueNumber: ${{ inputs.issueNumber }}
      target: ${{ inputs.target || 'src/lib/main.js' }}
      testFile: ${{ inputs.testFile || 'tests/unit/main.test.js' }}
      readmeFile: ${{ inputs.readmeFile || 'README.md' }}
      missionFile: ${{ inputs.missionFile || 'MISSION.md' }}
      contributingFile: ${{ inputs.contributingFile || 'CONTRIBUTING.md' }}
      dependenciesFile: ${{ inputs.dependenciesFile || 'package.json' }}
      buildScript: ${{ inputs.buildScript || 'npm run build' }}
      testScript: ${{ inputs.testScript || 'npm test' }}
      mainScript: ${{ inputs.mainScript || 'npm run start' }}
      mainScriptTimeout: '5m'
      model: ${{ inputs.model || vars.CHATGPT_API_MODEL || 'o3-mini' }}
      chatgptApiSecretKey: ${{ secrets.CHATGPT_API_SECRET_KEY }}

    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Check GitHub authentication
        if: ${{ env.npmAuthOrganisation != '' }}
        shell: bash
        run: |
          curl --include --header "Authorization: token ${{ secrets.PERSONAL_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}" https://api.github.com/user

      - name: Set up .npmrc
        if: ${{ env.npmAuthOrganisation != '' }}
        shell: bash
        run: |
          echo "${{ env.npmAuthOrganisation }}:registry=https://npm.pkg.github.com" >> .npmrc
          echo "//npm.pkg.github.com/:_authToken=${{ secrets.PERSONAL_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}" >> .npmrc
          echo "always-auth=true" >> .npmrc

      - run: npm ci

      - name: List dependencies
        id: list
        shell: bash
        run: |
          output=$(npm list 2>&1)
          echo "output<<EOF" >> "$GITHUB_OUTPUT"
          echo "$output" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          echo "output=${output}"

      - name: Build project
        id: build
        shell: bash
        run: |
          output=$(${{ env.buildScript }} 2>&1)
          echo "output<<EOF" >> "$GITHUB_OUTPUT"
          echo "$output" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          echo "output=${output}"

      - name: Tear down .npmrc
        if: ${{ env.npmAuthOrganisation != '' }}
        shell: bash
        run: rm -f .npmrc

      - name: Run tests
        id: test
        shell: bash
        run: |
          output=$(${{ env.testScript }} 2>&1)
          echo "output<<EOF" >> "$GITHUB_OUTPUT"
          echo "$output" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          echo "output=${output}"

      - name: Run main
        id: main
        shell: bash
        run: |
          output=$(timeout ${{ env.mainScriptTimeout }} ${{ env.mainScript }} 2>&1)
          echo "output<<EOF" >> "$GITHUB_OUTPUT"
          echo "$output" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          echo "output=${output}"

      - name: verify
        id: verify
        uses: actions/github-script@v7
        env:
          dependenciesListOutput: ${{ steps.list.outputs.output }}
          buildOutput: ${{ steps.build.outputs.output }}
          testOutput: ${{ steps.test.outputs.output }}
          mainOutput: ${{ steps.main.outputs.output }}
        with:
          github-token: ${{ secrets.PERSONAL_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}
          script: |
            const target = process.env.target;
            const testFile = process.env.testFile;
            const readmeFile = process.env.readmeFile;
            const missionFile = process.env.missionFile;
            const contributingFile = process.env.contributingFile;
            const dependenciesFile = process.env.dependenciesFile;
            const model = process.env.model;
            const apiKey = process.env.chatgptApiSecretKey;
            const issueNumber = parseInt(process.env.issueNumber);
            const dependenciesListOutput = process.env.dependenciesListOutput;
            const buildScript = process.env.buildScript;
            const buildOutput = process.env.buildOutput;
            const testScript = process.env.testScript;
            const testOutput = process.env.testOutput;
            const mainScript = process.env.mainScript;
            const mainOutput = process.env.mainOutput;

            const fs = require('fs');
            const OpenAI = require('openai').default;
            const { z } = require('zod');
            require('dotenv').config();

            if (!apiKey) { 
              core.setFailed("Missing CHATGPT_API_SECRET_KEY"); 
            }
            const openai = new OpenAI({ apiKey });

            core.info(`target: "${target}"`);
            core.info(`testFile: "${testFile}"`);
            core.info(`readmeFile: "${readmeFile}"`);
            core.info(`missionFile: "${missionFile}"`);
            core.info(`contributingFile: "${contributingFile}"`);
            core.info(`dependenciesFile: "${dependenciesFile}"`);
            const sourceFileContent = fs.readFileSync(target, 'utf8');
            const testFileContent = fs.readFileSync(testFile, 'utf8');
            const readmeFileContent = fs.readFileSync(readmeFile, 'utf8');
            const missionFileContent = fs.readFileSync(missionFile, 'utf8');
            const contributingFileContent = fs.readFileSync(contributingFile, 'utf8');
            const dependenciesFileContent = fs.readFileSync(dependenciesFile, 'utf8');
            core.info(`Target file '${target}' has been loaded (length ${sourceFileContent.length}).`);
            core.info(`Test file '${testFile}' has been loaded (length ${testFileContent.length}).`);
            core.info(`Readme file '${readmeFile}' has been loaded (length ${readmeFileContent.length}).`);
            core.info(`Dependencies file '${dependenciesFile}' has been loaded (length ${dependenciesFileContent.length}).`);
            
            const issue = await github.rest.issues.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber
            });
            const issueTitle = issue.data.title;
            const issueDescription = issue.data.body;
            const issueComments = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber
            });
            const issueCommentsText = issueComments.data
              .map(comment => `Author:${comment.user.login}, Created:${comment.created_at}, Comment: ${comment.body}`)
              .join('\n');
            
            const prompt = `
            Does the combination source file, test file, README file and dependencies file show a solution with a reasonable likelihood of including a resolution to the following issue?
            Consider the following when refining your response:
            * Source file content
            * Test file content
            * README file content issue
            * MISSION file content
            * Contributing file content
            * Dependencies file content
            * Issue details
            * Dependency list
            * Build output
            * Test output
            * Main execution output
            
            Source file: ${target}
            SOURCE_FILE_START
            ${sourceFileContent}
            SOURCE_FILE_END
            
            Test file: ${testFile}
            TEST_FILE_START
            ${testFileContent}
            TEST_FILE_END

            README file: ${readmeFile}
            README_FILE_START
            ${readmeFileContent}
            README_FILE_END
            
            MISSION file: ${missionFile}
            MISSION_FILE_START
            ${missionFileContent}
            MISSION_FILE_END

            Contributing file: ${contributingFile}
            CONTRIBUTING_FILE_START
            ${contributingFileContent}
            CONTRIBUTING_FILE_END
            
            Dependencies file: ${dependenciesFile}
            DEPENDENCIES_FILE_START
            ${dependenciesFileContent}
            DEPENDENCIES_FILE_END
            
            Issue:
            ISSUE_START
            title: ${issueTitle}
            description:
            ${issueDescription}
            comments:
            ${issueCommentsText}
            ISSUE_END            

            Dependencies list from command: npm list
            DEPENDENCIES_LIST_START
            ${dependenciesListOutput}
            DEPENDENCIES_LIST_END    
            
            Build output from command: ${buildScript}
            TEST_OUTPUT_START
            ${buildOutput}
            TEST_OUTPUT_END      
            
            Test output from command: ${testScript}
            TEST_OUTPUT_START
            ${testOutput}
            TEST_OUTPUT_END            

            Main output from command: ${mainScript}
            MAIN_OUTPUT_START
            ${mainOutput}
            MAIN_OUTPUT_END    
            
            Answer strictly with a JSON object following this schema:
            {
              "fixed": "true", // if the fix is present, or "false" otherwise.
              "message": "The issue has been resolved.", // if the fix is present, or an explanation otherwise.
              "refinement": "None" // if the fix is present, or a suggested refinement to resolve the issue otherwise.
            }
            Ensure valid JSON.
            `;
            
            const ResponseSchema = z.object({ fixed: z.string(), message: z.string(), refinement: z.string() });
            
            // Define the function schema for function calling
            const tools = [{
              type: "function",
              function: {
                name: "review_issue",
                description: "Evaluate whether the supplied source file content resolves the issue. Return an object with fixed (string: 'true' or 'false'), message (explanation), and refinement (suggested refinement).",
                parameters: {
                  type: "object",
                  properties: {
                    fixed: { type: "string", description: "true if the issue is resolved, false otherwise" },
                    message: { type: "string", description: "A message explaining the result" },
                    refinement: { type: "string", description: "A suggested refinement if the issue is not resolved" }
                  },
                  required: ["fixed", "message", "refinement"],
                  additionalProperties: false
                },
                strict: true
              }
            }];

            // Call OpenAI using function calling format
            const response = await openai.chat.completions.create({
              model,
              messages: [
                { role: "system", content: "You are evaluating whether an issue has been resolved in the supplied source code. Answer strictly with a JSON object following the provided function schema." },
                { role: "user", content: prompt }
              ],
              tools: tools
            });
            
            let result;
            if (response.choices[0].message.tool_calls && response.choices[0].message.tool_calls.length > 0) {
              try {
                result = JSON.parse(response.choices[0].message.tool_calls[0].function.arguments);
              } catch (e) {
                core.setFailed(`Failed to parse function call arguments: ${e.message}`);
              }
            } else if (response.choices[0].message.content) {
              try {
                result = JSON.parse(response.choices[0].message.content);
              } catch (e) {
                core.setFailed(`Failed to parse response content: ${e.message}`);
              }
            } else {
              core.setFailed("No valid response received from OpenAI.");
            }
            
            try {
              const parsed = ResponseSchema.parse(result);
              core.setOutput("fixed", parsed.fixed);
              core.setOutput("message", parsed.message);
              core.setOutput("refinement", parsed.refinement);
              core.info(`fixed: "${parsed.fixed}"`);
              core.info(`message: "${parsed.message}"`);
              core.info(`refinement: "${parsed.refinement}"`);
            
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber,
                body: parsed.message
              });
            
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber,
                body: parsed.refinement
              });
            } catch (e) {
              core.setFailed(`Failed to parse ChatGPT response: ${e.message}`);
            }
            
            core.setOutput("response", JSON.stringify(response));
            core.setOutput("usage", JSON.stringify(response.usage));
            core.info(`response: "${JSON.stringify(response)}"`);
            core.info(`usage: "${JSON.stringify(response.usage)}"`);
      - name: Close fixed issues
        if: steps.verify.outputs.fixed == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PERSONAL_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}
          script: |
            const issueNumber = parseInt("${{ env.issueNumber }}");
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber,
              body: "The issue has been automatically resolved and the fix has been merged."
            });
            await github.rest.issues.update({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber,
              state: "closed"
            });

    outputs:
      fixed: ${{ steps.verify.outputs.fixed }}
      message: ${{ steps.verify.outputs.message }}
      refinement: ${{ steps.verify.outputs.refinement }}
.github/workflows/wfr-apply-fix.yml
==== Content of .github/workflows/wfr-apply-fix.yml ====
# .github/workflows/wfr-apply-fix.yml

#
# agentic-lib
# Copyright (C) 2025 Polycode Limited
#
# This file is part of agentic-lib.
#
# agentic-lib is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License v3.0 (GPL‑3).
# along with this program. If not, see <https://www.gnu.org/licenses/>.
#
# IMPORTANT: Any derived work must include the following attribution:
# "This work is derived from https://github.com/xn-intenton-z2a/agentic-lib"
#

name: ∞ wfr-apply-fix

on:
  workflow_call:
    inputs:
      target:
        description: 'The target file to review. e.g. "src/lib/main.js"'
        type: string
        required: false
        default: 'src/lib/main.js'
      testFile:
        description: 'The test file to review. e.g. "tests/unit/main.test.js"'
        type: string
        required: false
        default: 'tests/unit/main.test.js'
      readmeFile:
        description: 'The README file to review. e.g. "README.md"'
        type: string
        required: false
        default: 'README.md'
      missionFile:
        description: 'The MISSION statement file. e.g. "MISSION.md"'
        type: string
        required: false
        default: 'MISSION.md'
      contributingFile:
        description: 'The CONTRIBUTING file to review. e.g. "CONTRIBUTING.md"'
        type: string
        required: false
        default: 'CONTRIBUTING.md'
      dependenciesFile:
        description: 'The dependencies file to review. e.g. "package.json"'
        type: string
        required: false
        default: 'package.json'
      formattingFile:
        description: 'The formatting file to review. e.g. ".prettierrc"'
        type: string
        required: false
        default: '.prettierrc'
      lintingFile:
        description: 'The linting file to review. e.g. "eslint.config.js"'
        type: string
        required: false
        default: 'eslint.config.js'
      buildScript:
        description: 'The script must be runnable as: `npm ci ; <script>` and succeed with a zero exit code. e.g. `npm run build`'
        type: string
        required: false
        default: 'echo "No build script specified."'
      testScript:
        description: 'The script must be runnable as: `npm ci ; <script>` and succeed with a zero exit code. e.g. `npm test`'
        type: string
        required: false
        default: 'npm test'
      mainScript:
        description: 'The script must be runnable as: `npm ci ; <script>` and succeed with a zero exit code. e.g. `npm run start`'
        type: string
        required: false
        default: 'npm run start'
      model:
        description: 'The OpenAI model to use. e.g. "o3-mini"'
        type: string
        required: false
        default: ${{ vars.CHATGPT_API_MODEL || 'o3-mini' }}
      branch:
        description: 'The branch to use for the fix. e.g. "agentic-lib-issue-123"'
        type: string
        required: false
        default: ${{ github.ref }}
      npmAuthOrganisation:
        description: 'The GitHub organisation to authenticate with for npm. e.g. "xn-intenton-z2a"'
        type: string
        required: false
        default: ''
      gitUserEmail:
        description: 'The email to use for git commits. e.g. "action@github.com"'
        type: string
        required: false
        default: 'action@github.com'
      gitUserName:
        description: 'The name to use for git commits. e.g. "GitHub Actions[bot]"'
        type: string
        required: false
        default: 'GitHub Actions[bot]'
      # New inputs:
      s3BucketUrl:
        description: 'The S3 bucket URL with prefix to use. e.g. "s3://my-bucket/prefix"'
        type: string
        required: false
        default: ''
      iamRoleArn:
        description: 'The ARN of the IAM role to assume. e.g. "arn:aws:iam::123456789012:role/my-role"'
        type: string
        required: false
        default: ''
    secrets:
      PERSONAL_ACCESS_TOKEN:
        required: false
      CHATGPT_API_SECRET_KEY:
        required: true
    outputs:
      fixApplied:
        value: ${{ jobs.apply-fix.outputs.fixApplied }}
      message:
        value: ${{ jobs.apply-fix.outputs.message }}
      installAfterUpdateOutcome:
        value: ${{ jobs.apply-fix.outputs.installAfterUpdateOutcome }}
      ciAfterUpdateOutcome:
        value: ${{ jobs.apply-fix.outputs.ciAfterUpdateOutcome }}
      testAfterUpdateOutcome:
        value: ${{ jobs.apply-fix.outputs.testAfterUpdateOutcome }}
      mainAfterUpdateOutcome:
        value: ${{ jobs.apply-fix.outputs.mainAfterUpdateOutcome }}
      commitOutcome:
        value: ${{ jobs.apply-fix.outputs.commitOutcome }}
      postResolutionCommentOutcome:
        value: ${{ jobs.start-issue.outputs.postResolutionCommentOutcome }}
      allValidationStepsSuccessful:
        value: ${{ jobs.start-issue.outputs.allValidationStepsSuccessful }}

jobs:
  apply-fix:
    runs-on: ubuntu-latest

    env:
      target: ${{ inputs.target || 'src/lib/main.js' }}
      testFile: ${{ inputs.testFile || 'tests/unit/main.test.js' }}
      readmeFile: ${{ inputs.readmeFile || 'README.md' }}
      missionFile: ${{ inputs.missionFile || 'MISSION.md' }}
      contributingFile: ${{ inputs.contributingFile || 'CONTRIBUTING.md' }}
      dependenciesFile: ${{ inputs.dependenciesFile || 'package.json' }}
      formattingFile: ${{ inputs.formattingFile || '.prettierrc' }}
      lintingFile: ${{ inputs.lintingFile || 'eslint.config.js' }}
      buildScript: ${{ inputs.buildScript || 'npm run build' }}
      testScript: ${{ inputs.testScript || 'npm test' }}
      mainScript: ${{ inputs.mainScript || 'npm run start' }}
      mainScriptTimeout: '5m'
      model: ${{ inputs.model || vars.CHATGPT_API_MODEL || 'o3-mini' }}
      chatgptApiSecretKey: ${{ secrets.CHATGPT_API_SECRET_KEY }}
      npmAuthOrganisation: ${{ inputs.npmAuthOrganisation || '' }}
      branch: ${{ inputs.branch || github.ref }}
      gitUserEmail: ${{ inputs.gitUserEmail || 'action@github.com' }}
      gitUserName: ${{ inputs.gitUserName || 'GitHub Actions[bot]' }}

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ env.branch }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Check GitHub authentication
        if: ${{ env.npmAuthOrganisation != '' }}
        shell: bash
        run: |
          curl --include --header "Authorization: token ${{ secrets.PERSONAL_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}" https://api.github.com/user

      - name: Set up .npmrc
        if: ${{ env.npmAuthOrganisation != '' }}
        shell: bash
        run: |
          echo "${{ env.npmAuthOrganisation }}:registry=https://npm.pkg.github.com" >> .npmrc
          echo "//npm.pkg.github.com/:_authToken=${{ secrets.PERSONAL_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}" >> .npmrc
          echo "always-auth=true" >> .npmrc

      - name: Install dependencies
        id: install
        shell: bash
        run: |
          set +e
          output=$(npm install 2>&1)
          echo "output<<EOF" >> "$GITHUB_OUTPUT"
          echo "$output" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          echo "output=${output}"
          exit 0

      - name: Build project
        id: build
        shell: bash
        run: |
          set +e
          output=$(${{ env.buildScript }} 2>&1)
          echo "output<<EOF" >> "$GITHUB_OUTPUT"
          echo "$output" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          echo "output=${output}"
          exit 0

      - name: Tear down .npmrc
        if: ${{ env.npmAuthOrganisation != '' }}
        shell: bash
        run: rm -f .npmrc

      - name: Run tests
        id: test
        shell: bash
        run: |
          set +e
          output=$(${{ env.testScript }} 2>&1)
          echo "output<<EOF" >> "$GITHUB_OUTPUT"
          echo "$output" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          echo "output=${output}"
          exit 0

      - name: Run main
        id: main
        shell: bash
        run: |
          set +e
          output=$(timeout ${{ env.mainScriptTimeout }} ${{ env.mainScript }} 2>&1)
          echo "output<<EOF" >> "$GITHUB_OUTPUT"
          echo "$output" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          echo "output=${output}"
          exit 0

      - name: update-target
        id: update-target
        uses: actions/github-script@v7
        env:
          installOutput: ${{ steps.install.outputs.output }}
          buildOutput: ${{ steps.build.outputs.output }}
          testOutput: ${{ steps.test.outputs.output }}
          mainOutput: ${{ steps.main.outputs.output }}
        with:
          github-token: ${{ secrets.PERSONAL_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}
          script: |
            const target = process.env.target;
            const testFile = process.env.testFile;
            const readmeFile = process.env.readmeFile;
            const missionFile = process.env.missionFile;
            const contributingFile = process.env.contributingFile;
            const dependenciesFile = process.env.dependenciesFile;
            const formattingFile = process.env.formattingFile;
            const lintingFile = process.env.lintingFile;
            const model = process.env.model;
            const apiKey = process.env.chatgptApiSecretKey;
            const installOutput = process.env.installOutput;
            const dependenciesListOutput = process.env.dependenciesListOutput;
            const buildScript = process.env.buildScript;
            const buildOutput = process.env.buildOutput;
            const testScript = process.env.testScript;
            const testOutput = process.env.testOutput;
            const mainScript = process.env.mainScript;
            const mainOutput = process.env.mainOutput;
            
            const fs = require('fs');
            const OpenAI = require('openai').default;
            const { z } = require('zod');
            require('dotenv').config();
            
            if (!apiKey) { 
              core.setFailed("Missing CHATGPT_API_SECRET_KEY"); 
            }
            const openai = new OpenAI({ apiKey });
            
            core.info(`target: "${target}"`);
            core.info(`testFile: "${testFile}"`);
            core.info(`readmeFile: "${readmeFile}"`);
            core.info(`missionFile: "${missionFile}"`);
            core.info(`contributingFile: "${contributingFile}"`);
            core.info(`dependenciesFile: "${dependenciesFile}"`);
            core.info(`formattingFile: "${formattingFile}"`);
            core.info(`lintingFile: "${lintingFile}"`);
            const sourceFileContent = fs.readFileSync(target, 'utf8');
            const testFileContent = fs.readFileSync(testFile, 'utf8');
            const readmeFileContent = fs.readFileSync(readmeFile, 'utf8');
            const missionFileContent = fs.readFileSync(missionFile, 'utf8');
            const contributingFileContent = fs.readFileSync(contributingFile, 'utf8');
            const dependenciesFileContent = fs.readFileSync(dependenciesFile, 'utf8');
            const formattingFileContent = fs.readFileSync(formattingFile, 'utf8');
            const lintingFileContent = fs.readFileSync(lintingFile, 'utf8');
            core.info(`Target file '${target}' has been loaded (length ${sourceFileContent.length}).`);
            core.info(`Test file '${testFile}' has been loaded (length ${testFileContent.length}).`);
            core.info(`Readme file '${readmeFile}' has been loaded (length ${readmeFileContent.length}).`);
            core.info(`Dependencies file '${dependenciesFile}' has been loaded (length ${dependenciesFileContent.length}).`);
            core.info(`Formatting file '${formattingFile}' has been loaded (length ${formattingFileContent.length}).`);
            core.info(`Linting file '${lintingFile}' has been loaded (length ${lintingFileContent.length}).`);
            
            const prompt = `
            You are providing the entire new content of the source file, test file and README file with all necessary changes applied to resolve a possible build or test problem.
            Consider the following when refining your response:
            * Source file content
            * Test file content
            * README file content issue
            * MISSION file content
            * Contributing file content
            * Dependencies file content
            * Formatting file content
            * Linting file content
            * Dependency install output
            * Build output
            * Test output
            * Main execution output
            
            Apply the contributing guidelines to your response and when suggesting enhancements consider the tone and direction of the contributing guidelines.
            
            Source file: ${target}
            SOURCE_FILE_START
            ${sourceFileContent}
            SOURCE_FILE_END
            
            Test file: ${testFile}
            TEST_FILE_START
            ${testFileContent}
            TEST_FILE_END

            README file: ${readmeFile}
            README_FILE_START
            ${readmeFileContent}
            README_FILE_END
            
            MISSION file: ${missionFile}
            MISSION_FILE_START
            ${missionFileContent}
            MISSION_FILE_END

            Contributing file: ${contributingFile}
            CONTRIBUTING_FILE_START
            ${contributingFileContent}
            CONTRIBUTING_FILE_END
            
            Dependencies file: ${dependenciesFile}
            DEPENDENCIES_FILE_START
            ${dependenciesFileContent}
            DEPENDENCIES_FILE_END
            
            Formatting file: ${formattingFile}
            FORMATTING_FILE_START
            ${formattingFileContent}
            FORMATTING_FILE_END
            
            Linting file: ${lintingFile}
            LINTING_FILE_START
            ${lintingFileContent}
            LINTING_FILE_END        

            Dependencies install from command: npm install
            DEPENDENCIES_INSTALL_START
            ${installOutput}
            DEPENDENCIES_INSTALL_END    

            Build output from command: ${buildScript}
            BUILD_OUTPUT_START
            ${buildOutput}
            BUILD_OUTPUT_END      
            
            Test output from command: ${testScript}
            TEST_OUTPUT_START
            ${testOutput}
            TEST_OUTPUT_END            

            Main execution output from command: ${mainScript}
            MAIN_OUTPUT_START
            ${mainOutput}
            MAIN_OUTPUT_END    
            
            Please produce an updated version of the source file, and test file, and README and dependencies file that resolves the possible build or test problem.
            If there are no changes required, please provide the original content and state that no changes are necessary in the message.
            Answer strictly with a JSON object following this schema:
            
            {
              "updatedSourceFileContent": "The entire new content of the source file, with all necessary changes applied, if any.",
              "updatedTestFileContent": "The entire new content of the test file, with all necessary changes applied, if any.",
              "updatedReadmeFileContent": "The entire new content of the README file, with all necessary changes applied, if any.",
              "updatedDependenciesFileContent": "The entire new content of the dependencies file, with all necessary changes applied, if any.",
              "message": "A short sentence explaining the change applied (or why no changes were applied) suitable for a commit message or PR text."
            }
            
            Ensure valid JSON.
            `;
            
            const ResponseSchema = z.object({ updatedSourceFileContent: z.string(), updatedTestFileContent: z.string(), updatedReadmeFileContent: z.string(), updatedDependenciesFileContent: z.string(), message: z.string() });
            
            // Define the function schema for functional calling
            const applyIssueResolutionToSource = [{
              type: "function",
              function: {
                name: "applyIssueResolutionToSource",
                description: "Return an updated version of the source file content along with a commit message. Use the provided source file content and supporting context to generate the update.",
                parameters: {
                  type: "object",
                  properties: {
                    updatedSourceFileContent: {
                      type: "string",
                      description: "The entire new content of the source file, with all necessary changes applied, if any."
                    },
                    updatedTestFileContent: {
                      type: "string",
                      description: "The entire new content of the test file, with all necessary changes applied, if any."
                    },
                    updatedReadmeFileContent: {
                      type: "string",
                      description: "The entire new content of the README file, with all necessary changes applied, if any."
                    },
                    updatedDependenciesFileContent: {
                      type: "string",
                      description: "The entire new content of the dependencies file, with all necessary changes applied, if any."
                    },
                    message: {
                      type: "string",
                      description: "A short sentence explaining the change applied (or why no changes were applied) suitable for a commit message or PR text."
                    }
                  },
                  required: ["updatedSourceFileContent", "updatedTestFileContent", "updatedReadmeFileContent", "updatedDependenciesFileContent", "message"],
                  additionalProperties: false
                },
                strict: true
              }
            }];
            
            // Call OpenAI using the function calling format via the tools parameter
            const response = await openai.chat.completions.create({
              model,
              messages: [
                { role: "system", content: "You are a code fixer that returns an updated source file content, test file content, README file content and dependencies file content to resolve a possible build or test problem. Answer strictly with a JSON object that adheres to the provided function schema." },
                { role: "user", content: prompt }
              ],
              tools: applyIssueResolutionToSource
            });
            
            let fixApplied;
            let result;
            // Check if the model made a function call; if so, parse its arguments.
            if (response.choices[0].message.tool_calls && response.choices[0].message.tool_calls.length > 0) {
              try {
                result = JSON.parse(response.choices[0].message.tool_calls[0].function.arguments);
              } catch (e) {
                fixApplied = false;
                core.setFailed(`Failed to parse function call arguments: ${e.message}`);
              }
            } else if (response.choices[0].message.content) {
              try {
                result = JSON.parse(response.choices[0].message.content);
              } catch (e) {
                fixApplied = false;
                core.setFailed(`Failed to parse response content: ${e.message}`);
              }
            } else {
              fixApplied = false;
              core.setFailed("No valid response received from OpenAI.");
            }
            
            try {
              const parsed = ResponseSchema.parse(result);
              // Sanitize commit message: retain only alphanumerics, spaces, and basic URL-safe punctuation (-, _, ., ~)
              const sanitizedMessage = parsed.message.replace(/[^A-Za-z0-9 \-\_\.\~]/g, '').replace(/\s+/g, ' ').trim();
              core.setOutput("message", sanitizedMessage);
              core.info(`message: "${sanitizedMessage}"`);
            
              if(parsed.updatedSourceFileContent && parsed.updatedSourceFileContent.length > 1 && parsed.updatedSourceFileContent !== sourceFileContent) {
                fs.writeFileSync(target, parsed.updatedSourceFileContent, 'utf8');
                fixApplied = true;
                core.info(`Target file '${target}' has been updated (length ${parsed.updatedSourceFileContent.length}).`);
              }
              if(parsed.updatedTestFileContent && parsed.updatedTestFileContent.length > 1 && parsed.updatedTestFileContent !== testFileContent) {
                fs.writeFileSync(testFile, parsed.updatedTestFileContent, 'utf8');
                fixApplied = true;
                core.info(`Test file '${testFile}' has been updated (length ${parsed.updatedTestFileContent.length}).`);
              }
              if(parsed.updatedReadmeFileContent && parsed.updatedReadmeFileContent.length > 1 && parsed.updatedReadmeFileContent !== readmeFileContent) {
                fs.writeFileSync(readmeFile, parsed.updatedReadmeFileContent, 'utf8');
                fixApplied = true;
                core.info(`Readme file '${readmeFile}' has been updated (length ${parsed.updatedReadmeFileContent.length}).`);
              }
              if(parsed.updatedDependenciesFileContent && parsed.updatedDependenciesFileContent.length > 1 && parsed.updatedDependenciesFileContent !== dependenciesFileContent) {
                fs.writeFileSync(dependenciesFile, parsed.updatedDependenciesFileContent, 'utf8');
                fixApplied = true;
                core.info(`Dependencies file '${dependenciesFile}' has been updated (length ${parsed.updatedDependenciesFileContent.length}).`);
              }

            } catch (e) {
              fixApplied = false;
              core.setFailed(`Failed to validate or process the response: ${e.message}`);
            }
            
            core.setOutput("fixApplied", fixApplied);
            core.setOutput("usage", JSON.stringify(response.usage));
            core.info(`fixApplied: "${fixApplied}"`);
            core.info(`usage: "${JSON.stringify(response.usage)}"`);
            core.info(`response: "${JSON.stringify(response)}"`);

      - run: cat ${{ env.target }}

      - name: Examine the git working copy
        shell: bash
        run: |
          git config --local user.email '${{ env.gitUserEmail }}'
          git config --local user.name '${{ env.gitUserName }}'
          git status -v
          git diff ${{ env.target }}

      - name: install-after-update
        id: install-after-update
        shell: bash
        run: |
          set +e
          npm install
          exit 0

      - name: ci-after-update
        id: ci-after-update
        shell: bash
        run: |
          set +e
          npm ci
          exit 0

      - name: Test after update
        id: test-after-update
        shell: bash
        run: |
          set +e
          ${{ env.testScript }}
          exit 0

      - name: Run main after update
        id: main-after-update
        shell: bash
        run: |
          set +e
          timeout ${{ env.mainScriptTimeout }} ${{ env.mainScript }}
          exit 0

      - name: Commit changes
        id: commit
        continue-on-error: true
        run: |
          git config --local user.email '${{ env.gitUserEmail }}'
          git config --local user.name '${{ env.gitUserName }}'
          git status -v
          git add -v --all
          git diff '${{ env.target }}'
          git commit -m '${{ steps.update-target.outputs.message }}'
          git status -v
          git push -v origin ${{ env.branch }}
          git status -v

      - name: Extract Results
        if: always()
        id: results
        uses: actions/github-script@v7
        with:
          script: |
            const fixApplied = '${{ steps.update-target.outputs.fixApplied }}';
            const message = '${{ steps.update-target.outputs.message }}';
            const installAfterUpdateOutcome = '${{ steps.install-after-update.outcome }}';
            const ciAfterUpdateOutcome = '${{ steps.ci-after-update.outcome }}';
            const testAfterUpdateOutcome = '${{ steps.test-after-update.outcome }}';
            const mainAfterUpdateOutcome = '${{ steps.main-after-update.outcome }}';
            const commitOutcome = '${{ steps.commit.outcome }}';
            const allValidationStepsSuccessful = installAfterUpdateOutcome === "success" && ciAfterUpdateOutcome === "success" && testAfterUpdateOutcome === "success" && mainAfterUpdateOutcome === "success" && commitOutcome === "success";
            core.setOutput('fixApplied', fixApplied);
            core.setOutput('message', message);
            core.setOutput('installAfterUpdateOutcome', installAfterUpdateOutcome);
            core.setOutput('ciAfterUpdateOutcome', ciAfterUpdateOutcome);
            core.setOutput('testAfterUpdateOutcome', testAfterUpdateOutcome);
            core.setOutput('mainAfterUpdateOutcome', mainAfterUpdateOutcome);
            core.setOutput('commitOutcome', commitOutcome);
            core.setOutput('allValidationStepsSuccessful', allValidationStepsSuccessful);
            core.info(`fixApplied: "${fixApplied}"`);
            core.info(`message: "${message}"`);
            core.info(`installAfterUpdateOutcome: "${installAfterUpdateOutcome}"`);
            core.info(`ciAfterUpdateOutcome: "${ciAfterUpdateOutcome}"`);
            core.info(`testAfterUpdateOutcome: "${testAfterUpdateOutcome}"`);
            core.info(`mainAfterUpdateOutcome: "${mainAfterUpdateOutcome}"`);
            core.info(`commitOutcome: "${commitOutcome}"`);
            core.info(`allValidationStepsSuccessful: "${allValidationStepsSuccessful}"`);

    outputs:
      fixApplied: ${{ steps.results.outputs.fixApplied }}
      message: ${{ steps.results.outputs.message }}
      installAfterUpdateOutcome: ${{ steps.results.outputs.installAfterUpdateOutcome }}
      ciAfterUpdateOutcome: ${{ steps.results.outputs.ciAfterUpdateOutcome }}
      testAfterUpdateOutcome: ${{ steps.results.outputs.testAfterUpdateOutcome }}
      mainAfterUpdateOutcome: ${{ steps.results.outputs.mainAfterUpdateOutcome }}
      commitOutcome: ${{ steps.results.outputs.commitOutcome }}
      allValidationStepsSuccessful: ${{ steps.results.outputs.allValidationStepsSuccessful }}

.github/workflows/wfr-automerge-find-pr-from-pull-request.yml
==== Content of .github/workflows/wfr-automerge-find-pr-from-pull-request.yml ====
# .github/workflows/wfr-automerge-find-pr-from-pull-request.yml

#
# agentic-lib
# Copyright (C) 2025 Polycode Limited
#
# This file is part of agentic-lib.
#
# agentic-lib is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License v3.0 (GPL‑3).
# along with this program. If not, see <https://www.gnu.org/licenses/>.
#
# IMPORTANT: Any derived work must include the following attribution:
# "This work is derived from https://github.com/xn-intenton-z2a/agentic-lib"
#

name: ∞ automerge-find-pr-from-pull-request

on:
  workflow_call:
    inputs:
      s3BucketUrl:
        description: 'The S3 bucket URL with prefix to use. e.g. "s3://my-bucket/prefix"'
        type: string
        required: false
        default: ''
      iamRoleArn:
        description: 'The ARN of the IAM role to assume. e.g. "arn:aws:iam::123456789012:role/my-role"'
        type: string
        required: false
        default: ''
    secrets:
      PERSONAL_ACCESS_TOKEN:
        required: false
    outputs:
      pullNumber:
        description: 'The pull request number. e.g. "123"'
        value: ${{ jobs.check-pr.outputs.pullNumber }}
      shouldSkipMerge:
        description: 'Set to "true", if the merge request should be skipped because there is not a PR in the right state.'
        value: ${{ jobs.check-pr.outputs.shouldSkipMerge }}
      prMerged:
        description: 'Set to "true", if the PR has been merged either already or by this process.'
        value: ${{ jobs.check-pr.outputs.prMerged }}

jobs:
  check-pr:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: check-pr
        id: check-pr
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PERSONAL_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}
          script: |
            const pr = context.payload.pull_request;
            const pullNumber = pr.number;
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            let pullRequest;
            let shouldSkipMerge;
            let prMerged;
            
            const { data: pullRequests } = await github.rest.pulls.list({
              owner: owner,
              repo: repo,
            });
            if (pullRequests.length > 0) {
              const filteredPRs = pullRequests.filter(pr => pr.number === pullNumber);
              if (filteredPRs.length > 0) {
                pullRequest = filteredPRs[0];
                core.info(`Found pull request #${pullRequest.number}.`);
                const { data: pullRequestFromGet } = await github.rest.pulls.get({
                  owner,
                  repo,
                  pull_number: pullNumber,
                });
                pullRequest = pullRequestFromGet;
                core.info(JSON.stringify(pullRequest));
              } else {
                core.info(`No pull request found with number #${pullNumber}.`);
                pullRequest = null;
              }
            } else {
              pullRequest = null;
              core.info('No pull requests found.');
            }
            //const { data: pullRequest } = await github.rest.pulls.get({
            //  owner,
            //  repo,
            //  pull_number: pullNumber,
            //});

            if (pullRequest.state === "closed") {
              core.info(`PR #${pr.number} is already closed.`);
              shouldSkipMerge = 'true';
              prMerged = 'true';
            } else if (pullRequest.state !== "open") {
              core.info(`PR #${pr.number} is not open it is ${pullRequest.state}.`);
              shouldSkipMerge = 'true';
              prMerged = 'false';
            } else if (pullRequest.mergeable === true) {
              core.info(`PR #${pr.number} is mergeable at state ${pullRequest.state}.`);
              shouldSkipMerge = 'false';    //   <--- This PR is mergeable.
              prMerged = 'false';
            } else if (pullRequest.mergeable === false) {
              core.info(`PR #${pullNumber} is not mergeable.`);
              shouldSkipMerge = 'true';
              prMerged = 'false';
            } else if (pullRequest.mergeable === null) {
              core.info(`PR #${pullNumber} does not yet have a value for mergeability.`);
              shouldSkipMerge = 'true';
              prMerged = 'false';
            } else {
              core.info(`PR #${pullNumber} is not known.`);
              shouldSkipMerge = 'true';
              prMerged = 'false';
            }
            
            core.setOutput('pullNumber', !pullNumber ? '' : pullNumber.toString());
            core.setOutput('shouldSkipMerge', shouldSkipMerge);
            core.setOutput('prMerged', prMerged);
            core.info(`pullNumber: '${!pullNumber ? '' : pullNumber.toString()}'`);
            core.info(`shouldSkipMerge: '${shouldSkipMerge}'`);
            core.info(`prMerged: '${prMerged}'`);

    outputs:
      pullNumber: ${{ steps.check-pr.outputs.pullNumber }}
      shouldSkipMerge: ${{ steps.check-pr.outputs.shouldSkipMerge }}
      prMerged: ${{ steps.check-pr.outputs.prMerged }}

.github/workflows/publish.yml
==== Content of .github/workflows/publish.yml ====
# .github/workflows/publish.yml
#
# This file is part of the example suite for `agentic-lib` see: https://github.com/xn-intenton-z2a/agentic-lib
# This file is licensed under the MIT License. For details, see LICENSE-MIT

name: Publish
run-name: 'Publish packages [${{ github.ref_name }}] [${{ github.event.head_commit.message }}]'
concurrency: agentic-lib

on:
  #push:
  #  branches:
  #    # When publishing from a branch, add branch name here, e,g, 'beta'
  #    - main
  #  paths:
  #    - '**/*.sh'
  #    - '**/*.js'
  #    - '**/*.json'
  #    - '**/*.yml'
  #    - '**/*.properties'
  #    - '!intentions/**'
  #    - '!conversations/**'
  #    - '!exports/**'
  #    - '!programs/**'
  #    - '!results/**'
  workflow_dispatch:
    inputs:
      versionIncrement:
        description: 'Select the Semantic Versioning segment to increment'
        required: true
        default: 'prerelease'
        type: choice
        options:
          - prerelease
          - patch
          - minor
          - major
          - premajor
          - preminor
          - prepatch

jobs:

  npm-test-and-run-main:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: 'npm'

      - name: Set up ~/.npmrc
        run: |
          echo "@xn-intenton-z2a:registry=https://npm.pkg.github.com" >> ~/.npmrc
          echo "//npm.pkg.github.com/:_authToken=${{ secrets.PERSONAL_ACCESS_TOKEN }}" >> ~/.npmrc
          echo "always-auth=true" >> ~/.npmrc

      - run: npm ci

      - name: test
        id: test
        shell: bash
        run: 'npm test'

      - name: main
        id: main
        shell: bash
        run: timeout 5m ${{ vars.MAIN_SCRIPT || 'npm run start' }}

  mvn-package-cdk-synth:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: 'npm'

      - name: Set up ~/.npmrc
        run: |
          echo "@xn-intenton-z2a:registry=https://npm.pkg.github.com" >> ~/.npmrc
          echo "//npm.pkg.github.com/:_authToken=${{ secrets.PERSONAL_ACCESS_TOKEN }}" >> ~/.npmrc
          echo "always-auth=true" >> ~/.npmrc

      - run: npm ci

      - name: mvn
        id: mvn
        shell: bash
        run: |
          if [ -f pom.xml ]; then
            pomXmlExists='true'
          else
            pomXmlExists='false'
          fi
          echo "pomXmlExists=${pomXmlExists?}" | tee -a "${GITHUB_OUTPUT?}"

      - uses: actions/setup-java@v4
        if: steps.mvn.outputs.pomXmlExists == 'true'
        with:
          distribution: 'corretto'
          java-version: 21
          cache: 'maven'
          server-password: PERSONAL_ACCESS_TOKEN
        env:
          GITHUB_ACTOR: ${{ github.actor }}
          PERSONAL_ACCESS_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}

      - name: package
        id: package
        if: steps.mvn.outputs.pomXmlExists == 'true'
        shell: bash
        run: ./mvnw clean package
        env:
          GITHUB_ACTOR: ${{ github.actor }}
          PERSONAL_ACCESS_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}

      - name: synth
        id: synth
        if: steps.mvn.outputs.pomXmlExists == 'true'
        shell: bash
        run: npx cdk synth --strict --validation --no-staging
        env:
          GITHUB_ACTOR: ${{ github.actor }}
          PERSONAL_ACCESS_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}

    outputs:
      pomXmlExists: ${{ steps.mvn.outputs.pomXmlExists }}

  publish-npm:
    needs:
      - npm-test-and-run-main
    permissions:
      contents: write
      packages: write
    uses: 'xn-intenton-z2a/agentic-lib/.github/workflows/wfr-publish-npm.yml@main'
    with:
      versionIncrement: ${{ inputs.versionIncrement || 'prerelease' }}
      #githubRelease: true
      buildScript: 'npm run build'
      releaseNotes: 'Release increment: ${{ inputs.versionIncrement }}.'
      npmAuthOrganisation: '@xn-intenton-z2a'
      gitUserEmail: 'action@github.com'
      gitUserName: 'GitHub Actions[bot]'
    secrets:
      PERSONAL_ACCESS_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}

  publish-mvn:
    needs:
      - npm-test-and-run-main
      - publish-npm
      - mvn-package-cdk-synth
    if: needs.mvn-package-cdk-synth.outputs.pomXmlExists == 'true'
    permissions:
      contents: write
      packages: write
    uses: 'xn-intenton-z2a/agentic-lib/.github/workflows/wfr-publish-mvn.yml@main'
    with:
      versionIncrement: ${{ inputs.versionIncrement || 'prerelease' }}
      releaseVersionOverride: ${{ needs.publish-npm.outputs.releasedVersion }}
      newVersionOverride: ${{ needs.publish-npm.outputs.newVersion }}
      githubRelease: false
      mavenBuildScript: './mvnw --batch-mode clean install'
      mavenDeployScript: './mvnw --batch-mode deploy'
      releaseNotes: 'Release increment: ${{ inputs.versionIncrement }}.'
      gitUserEmail: 'action@github.com'
      gitUserName: 'GitHub Actions[bot]'
    secrets:
      PERSONAL_ACCESS_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}
.github/workflows/apply-fix.yml
==== Content of .github/workflows/apply-fix.yml ====
# .github/workflows/apply-fix.yml
#
# This file is part of the example suite for `agentic-lib` see: https://github.com/xn-intenton-z2a/agentic-lib
# This file is licensed under the MIT License. For details, see LICENSE-MIT

name: Apply Fix on Fail
concurrency: agentic-lib
run-name: "Apply Fix on Fail [${{ github.ref_name }}]"

on:
  workflow_dispatch:
    inputs:
      target:
        description: 'The source file whose content is used in the resolution prompt. e.g. "src/lib/main.js"'
        required: false
        type: string
        default: 'src/lib/main.js'
      testFile:
        description: 'The test file to run to validate the resolution. e.g. "tests/unit/main.test.js"'
        required: false
        type: string
        default: 'tests/unit/main.test.js'
      applyFixEvenIfTestsPass:
        description: 'Apply the fix even if the tests pass. e.g. true'
        required: false
        type: boolean
        default: false
      scanForBranches:
        description: 'Scan for branches matching the pattern. e.g. true'
        required: false
        type: boolean
        default: false
  workflow_run:
    workflows:
      - 'Tests'
    types:
      - completed
    branches:
      - agentic-lib-*
  schedule:
    - cron: '0 */4 * * *' # schedule-1
    #- cron: '*/30 * * * *' # schedule-2
    #- cron: '*/10 * * * *' # schedule-3

jobs:

  select-branch:
    runs-on: ubuntu-latest
    env:
      branchPrefix: 'agentic-lib-'
      gitUserEmail: 'action@github.com'
      gitUserName: 'GitHub Actions[bot]'
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Fetch all branches
        run: |
          git fetch --all
          git branch -r

      - name: determine-branch and auto-resolve merge conflicts
        id: determine
        uses: actions/github-script@v7
        with:
          script: |
            const { execSync } = require('child_process');

            let branch;
            // Determine branch using schedule or ref
            if (context.eventName === "schedule" || context.eventName === "workflow_run" || "${{ inputs.scanForBranches }}" === "true") {
              core.info("Schedule event detected. Scanning for matching branches.");
              const branchesResp = await github.rest.repos.listBranches({
                owner: context.repo.owner,
                repo: context.repo.repo,
              });
              // Use the branch prefix from env (ensure process.env.branchPrefix is defined)
              const prefix = process.env.branchPrefix || "agentic-lib-";
              const matchingBranches = branchesResp.data
                .filter(b => new RegExp(`^${prefix}`).test(b.name))
                .map(b => b.name);
              core.info(`Matching branches: ${matchingBranches}`);
              branch = matchingBranches.length > 0 ? matchingBranches[0] : context.payload.repository?.default_branch || "main";
            } else {
              branch = context.ref.startsWith("refs/heads/") ? context.ref.substring("refs/heads/".length) : context.ref;
            }
            core.info(`Selected branch: ${branch}`);
            core.setOutput("branch", branch);

            if (branch === "main") {
              core.info("Main branch selected. Skipping auto-resolution.");
              core.setOutput("conflictsDetected", "false");
              core.setOutput("conflictsResolved", "true");
            } else {
              core.info("Detect and resolve merge conflicts between the selected branch and main.");
              execSync("git config --local user.email '${{ env.gitUserEmail }}'", { stdio: 'pipe' });
              execSync("git config --local user.name '${{ env.gitUserName }}'", { stdio: 'pipe' });
              execSync("git status -v", { stdio: 'pipe' });
              execSync(`git checkout origin/${branch}`, { stdio: 'pipe' });
              try {
                core.info("Fetching main branch...");
                execSync("git fetch origin main", { stdio: 'pipe' });
                core.info("Attempting a dry-run merge of main into the branch...");
                // Attempt dry-run merge without committing.
                execSync("git merge origin/main --no-commit --no-ff", { stdio: 'pipe' });
                core.info("No merge conflicts detected.");
                // Abort the merge attempt.
                //execSync("git merge --abort", { stdio: 'pipe' });
                //core.setOutput("conflictsDetected", "false");
                //core.setOutput("conflictsResolved", "true");
              } catch (err) {
                core.info(`Merge conflicts detected. ${err.message}`);
                core.setOutput("conflictsDetected", "true");
                try {
                  core.info("Attempting auto-resolution by accepting main's changes...");
                  // Auto-resolve by checking out the version from main for all conflicting files.
                  execSync("git checkout --theirs .", { stdio: 'pipe' });
                  execSync("git add .", { stdio: 'pipe' });
                  execSync("git commit -m 'Auto-resolved merge conflicts: accepted main changes'", { stdio: 'pipe' });
                  core.info("Auto-resolution succeeded.");
                  core.setOutput("conflictsResolved", "true");
                } catch (e) {
                  core.error("Auto-resolution failed: " + e.message);
                  core.setOutput("conflictsResolved", "false");
                }
              }
            }

            // Extract issue number from branch name using branchPrefix.
            const prefix = process.env.branchPrefix || "agentic-lib-";
            const issueNumberMatch = branch.match(new RegExp(`${prefix}issue-(\\d+)`));
            const issueNumber = issueNumberMatch ? issueNumberMatch[1] : '';
            core.setOutput("issueNumber", issueNumber);
            core.info(`Issue number: ${issueNumber}`);
    outputs:
      branch: ${{ steps.determine.outputs.branch }}
      issueNumber: ${{ steps.determine.outputs.issueNumber }}

  npm-test:
    needs: select-branch
    name: 'npm test with coverage'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ needs.select-branch.outputs.branch }}
          fetch-depth: 0
      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: 'npm'
      - name: Set up .npmrc
        shell: bash
        run: |
          echo "${{ env.npmAuthOrganisation }}:registry=https://npm.pkg.github.com" >> .npmrc
          echo "//npm.pkg.github.com/:_authToken=${{ secrets.PERSONAL_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}" >> .npmrc
          echo "always-auth=true" >> .npmrc
        env:
          npmAuthOrganisation: '@xn-intenton-z2a'
      - run: npm ci
      - run: npm run test:unit

  npm-build:
    needs: select-branch
    name: 'npm run build'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ needs.select-branch.outputs.branch }}
          fetch-depth: 0
      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: 'npm'
      - name: Set up .npmrc
        shell: bash
        run: |
          echo "${{ env.npmAuthOrganisation }}:registry=https://npm.pkg.github.com" >> .npmrc
          echo "//npm.pkg.github.com/:_authToken=${{ secrets.PERSONAL_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}" >> .npmrc
          echo "always-auth=true" >> .npmrc
        env:
          npmAuthOrganisation: '@xn-intenton-z2a'
      - run: npm ci
      - run: npm run build

  npm-run:
    needs: select-branch
    name: 'npm run start'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ needs.select-branch.outputs.branch }}
          fetch-depth: 0
      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: 'npm'
      - name: Set up .npmrc
        shell: bash
        run: |
          echo "${{ env.npmAuthOrganisation }}:registry=https://npm.pkg.github.com" >> .npmrc
          echo "//npm.pkg.github.com/:_authToken=${{ secrets.PERSONAL_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}" >> .npmrc
          echo "always-auth=true" >> .npmrc
        env:
          npmAuthOrganisation: '@xn-intenton-z2a'
      - run: npm ci
      - run: ${{ vars.MAIN_SCRIPT || 'npm run start' }}

  needs-fix:
    needs:
      - select-branch
      - npm-test
      - npm-build
      - npm-run
    if: >
      ${{ always() &&
         (
           needs.npm-test.result != 'success' ||
           needs.npm-build.result != 'success' ||
           needs.npm-run.result != 'success' ||
           inputs.applyFixEvenIfTestsPass == true
         )
      }}
    runs-on: ubuntu-latest
    steps:
      - name: set-needs-fix
        id: set-needs-fix
        uses: actions/github-script@v7
        with:
          script: |
            const npmTestResult = "${{ needs.npm-test.result }}";
            const npmBuildResult = "${{ needs.npm-build.result }}";
            const npmRunResult = "${{ needs.npm-run.result }}";
            const applyFixEvenIfTestsPass = "${{ inputs.applyFixEvenIfTestsPass }}" === "true";
            const needsFix = npmTestResult !== "success" || npmBuildResult !== "success" || npmRunResult !== "success" || applyFixEvenIfTestsPass;
            core.info(`Needs Fix: ${needsFix}`);
            core.setOutput("needsFix", needsFix);
    outputs:
      needsFix: ${{ steps.set-needs-fix.outputs.needsFix }}

  branch-for-fix:
    needs:
      - select-branch
      - needs-fix
    if: ${{ always() }}
    runs-on: ubuntu-latest
    env:
      branchPrefix: 'agentic-lib-'
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ needs.select-branch.outputs.branch }}
          fetch-depth: 0
      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: 'npm'
      - name: create-branch-if-required
        id: create-branch-if-required
        run: |
          if [[ '${{ needs.select-branch.outputs.branch }}' == 'main' && '${{ needs.needs-fix.outputs.needsFix }}' == 'true' ]] ; then
            echo 'Creating or force pushing to branch: ${{ env.branchPrefix }}fix-main'
            git switch --force-create '${{ env.branchPrefix }}fix-main'
            git push -v --force origin '${{ env.branchPrefix }}fix-main'
            echo 'branch=${{ env.branchPrefix }}fix-main' >> $GITHUB_OUTPUT
          else
            echo 'Retaining existing branch: ${{ needs.select-branch.outputs.branch }}'
            echo 'branch=${{ needs.select-branch.outputs.branch }}' >> $GITHUB_OUTPUT
          fi
    outputs:
      branch: ${{ steps.create-branch-if-required.outputs.branch }}

  apply-fix:
    needs:
      - branch-for-fix
      - branch-for-fix
      - npm-test
      - npm-build
      - npm-run
      - needs-fix
    if: ${{ always() && needs.needs-fix.outputs.needsFix == 'true' }}
    permissions:
      contents: write
      issues: write
      id-token: write
    uses: 'xn-intenton-z2a/agentic-lib/.github/workflows/wfr-apply-fix.yml@main'
    with:
      target: ${{ inputs.target || 'src/lib/main.js' }}
      testFile: ${{ inputs.testFile || 'tests/unit/main.test.js' }}
      readmeFile: 'README.md'
      missionFile: 'MISSION.md'
      contributingFile: 'CONTRIBUTING.md'
      dependenciesFile: 'package.json'
      formattingFile: '.prettierrc'
      lintingFile: 'eslint.config.js'
      buildScript: 'npm run build'
      testScript: 'npm test'
      mainScript: ${{ vars.MAIN_SCRIPT || 'npm run start' }}
      model: ${{ vars.CHATGPT_API_MODEL || 'o3-mini' }}
      branch: ${{ needs.branch-for-fix.outputs.branch }}
      npmAuthOrganisation: '@xn-intenton-z2a'
      gitUserEmail: 'action@github.com'
      gitUserName: 'GitHub Actions[bot]'
    secrets:
      CHATGPT_API_SECRET_KEY: ${{ secrets.CHATGPT_API_SECRET_KEY }}
      PERSONAL_ACCESS_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}

  npm-test-after-fix:
    needs:
      - branch-for-fix
      - npm-test
      - npm-build
      - npm-run
      - needs-fix
      - apply-fix
    if: ${{ always() && needs.needs-fix.outputs.needsFix == 'true' }}
    name: 'npm test with coverage'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ needs.branch-for-fix.outputs.branch }}
          fetch-depth: 0
      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: "npm"
      - name: Get latest from remote
        run: |
          git config --local user.email "${{ env.gitUserEmail }}"
          git config --local user.name "${{ env.gitUserName }}"
          git pull --ff-only origin ${{ needs.branch-for-fix.outputs.branch }}
      - run: npm ci
      - run: npm run test:unit

  npm-build-after-fix:
    needs:
      - branch-for-fix
      - npm-test
      - npm-build
      - npm-run
      - needs-fix
      - apply-fix
    if: ${{ always() && needs.needs-fix.outputs.needsFix == 'true' }}
    name: 'npm run build'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ needs.branch-for-fix.outputs.branch }}
          fetch-depth: 0
      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: "npm"
      - name: Get latest from remote
        run: |
          git config --local user.email "${{ env.gitUserEmail }}"
          git config --local user.name "${{ env.gitUserName }}"
          git pull --ff-only origin ${{ needs.branch-for-fix.outputs.branch }}
      - run: npm ci
      - run: npm run build

  npm-run-after-fix:
    needs:
      - branch-for-fix
      - npm-test
      - npm-build
      - npm-run
      - needs-fix
      - apply-fix
    if: ${{ always() && needs.needs-fix.outputs.needsFix == 'true' }}
    name: 'npm run start'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ needs.branch-for-fix.outputs.branch }}
          fetch-depth: 0
      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: "npm"
      - name: Get latest from remote
        run: |
          git config --local user.email "${{ env.gitUserEmail }}"
          git config --local user.name "${{ env.gitUserName }}"
          git pull --ff-only origin ${{ needs.branch-for-fix.outputs.branch }}
      - name: Set up .npmrc
        shell: bash
        run: |
          echo "${{ env.npmAuthOrganisation }}:registry=https://npm.pkg.github.com" >> .npmrc
          echo "//npm.pkg.github.com/:_authToken=${{ secrets.PERSONAL_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}" >> .npmrc
          echo "always-auth=true" >> .npmrc
        env:
          npmAuthOrganisation: '@xn-intenton-z2a'
      - run: npm ci
      - run: ${{ vars.MAIN_SCRIPT || 'npm run start' }}

  needs-fix-after-fix:
    needs:
      - branch-for-fix
      - npm-test
      - npm-build
      - npm-run
      - needs-fix
      - apply-fix
      - npm-test-after-fix
      - npm-build-after-fix
      - npm-run-after-fix
    if: >
      ${{ always() &&
         (
           needs.npm-test-after-fix.result != 'success' ||
           needs.npm-build-after-fix.result != 'success' ||
           needs.npm-run-after-fix.result != 'success' ||
           inputs.applyFixEvenIfTestsPass == true
         )
      }}
    runs-on: ubuntu-latest
    steps:
      - name: set-needs-fix
        id: set-needs-fix
        uses: actions/github-script@v7
        with:
          script: |
            const applyFixEvenIfTestsPass = "${{ inputs.applyFixEvenIfTestsPass }}" === "true";
            const fixedFromTheBeginning = "${{ needs.needs-fix.outputs.needsFix }}" === "false";
            const anySkipped = "${{ needs.npm-test-after-fix.result == 'skipped' || needs.npm-build-after-fix.result == 'skipped' || needs.npm-run-after-fix.result == 'skipped' }}" === "true";
            const anyDidntSucceed = "${{ needs.npm-test-after-fix.result != 'success' || needs.npm-build-after-fix.result != 'success' || needs.npm-run-after-fix.result != 'success' }}" === "true";
            const readyToMerge = applyFixEvenIfTestsPass || fixedFromTheBeginning || !anySkipped && !anyDidntSucceed;
            
            core.setOutput("applyFixEvenIfTestsPass", applyFixEvenIfTestsPass);
            core.setOutput("fixedFromTheBeginning", fixedFromTheBeginning);
            core.setOutput("anySkipped", anySkipped);
            core.setOutput("anyDidntSucceed", anyDidntSucceed);
            core.setOutput("readyToMerge", readyToMerge);     
            
            core.info(`Apply fix even if tests pass: ${applyFixEvenIfTestsPass}`);
            core.info(`Fixed from the beginning: ${fixedFromTheBeginning}`);
            core.info(`Any skipped: ${anySkipped}`);
            core.info(`Any didn't succeed: ${anyDidntSucceed}`);
            core.info(`Ready to merge: ${readyToMerge}`);

    outputs:
      applyFixEvenIfTestsPass: ${{ steps.set-needs-fix.outputs.applyFixEvenIfTestsPass }}
      fixedFromTheBeginning: ${{ steps.set-needs-fix.outputs.fixedFromTheBeginning }}
      allSkipped: ${{ steps.set-needs-fix.outputs.allSkipped }}
      anyDidntSucceed: ${{ steps.set-needs-fix.outputs.anyDidntSucceed }}
      readyToMerge: ${{ steps.set-needs-fix.outputs.readyToMerge }}

  create-pr:
    needs:
      - select-branch
      - branch-for-fix
      - npm-test
      - npm-build
      - npm-run
      - apply-fix
      - needs-fix
      - npm-test-after-fix
      - npm-build-after-fix
      - npm-run-after-fix
      - needs-fix-after-fix
    if: ${{ always() && needs.branch-for-fix.outputs.branch != 'main' && needs.needs-fix-after-fix.outputs.readyToMerge == 'true' }}
    permissions:
      contents: write
      packages: write
      issues: write
      pull-requests: write
      checks: write
      id-token: write
    uses: 'xn-intenton-z2a/agentic-lib/.github/workflows/wfr-create-pr.yml@main'
    with:
      branch: "${{ needs.branch-for-fix.outputs.branch }}"
      baseBranch: 'main'
      gitCommitMessage: "${{ needs.apply-fix.outputs.message }} (fixes #${{ needs.select-branch.outputs.issueNumber }})"
      label: 'automerge'
.github/workflows/truncate-workflow-history.yml
==== Content of .github/workflows/truncate-workflow-history.yml ====
# .github/workflows/issue-creator.yml
#
# This file is part of the example suite for `agentic-lib` see: https://github.com/xn-intenton-z2a/agentic-lib
# This file is licensed under the MIT License. For details, see LICENSE-MIT

name: ∞ Truncate Workflow Runs
concurrency: truncate-workflow-runs

on:
  workflow_dispatch:
  schedule:
    - cron: '0 0 */7 * *' # schedule-1
    #- cron: '0 0 * * *' # schedule-2
    #- cron: '0 0 * * *' # schedule-3

jobs:
  cleanup:
    runs-on: ubuntu-latest
    steps:
      - name: Clean up old workflow runs and artifacts
        uses: actions/github-script@v7
        with:
          script: |
            // Set retention period (in days)
            const retentionDays = 7;
            const cutoffDate = new Date(Date.now() - retentionDays * 24 * 60 * 60 * 1000);
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const perPage = 100;
            let runsDeleted = 0;
            let artifactsDeleted = 0;

            console.log(`Deleting workflow runs and artifacts older than ${retentionDays} days (before ${cutoffDate.toISOString()})...`);

            // Delete old workflow runs
            let page = 1;
            while (true) {
              const runsResponse = await github.rest.actions.listWorkflowRunsForRepo({
                owner,
                repo,
                per_page: perPage,
                page
              });
              const runs = runsResponse.data.workflow_runs;
              if (runs.length === 0) break;
              for (const run of runs) {
                const runCreatedAt = new Date(run.created_at);
                if (runCreatedAt < cutoffDate) {
                  try {
                    await github.rest.actions.deleteWorkflowRun({
                      owner,
                      repo,
                      run_id: run.id
                    });
                    console.log(`Deleted workflow run ${run.id} (created at ${run.created_at})`);
                    runsDeleted++;
                  } catch (error) {
                    console.error(`Failed to delete run ${run.id}: ${error.message}`);
                  }
                }
              }
              page++;
            }
            console.log(`Total workflow runs deleted: ${runsDeleted}`);

            // Delete old artifacts
            page = 1;
            while (true) {
              const artifactsResponse = await github.rest.actions.listArtifactsForRepo({
                owner,
                repo,
                per_page: perPage,
                page
              });
              const artifacts = artifactsResponse.data.artifacts;
              if (artifacts.length === 0) break;
              for (const artifact of artifacts) {
                const artifactCreatedAt = new Date(artifact.created_at);
                if (artifactCreatedAt < cutoffDate) {
                  try {
                    await github.rest.actions.deleteArtifact({
                      owner,
                      repo,
                      artifact_id: artifact.id
                    });
                    console.log(`Deleted artifact ${artifact.id} (created at ${artifact.created_at})`);
                    artifactsDeleted++;
                  } catch (error) {
                    console.error(`Failed to delete artifact ${artifact.id}: ${error.message}`);
                  }
                }
              }
              page++;
            }
            console.log(`Total artifacts deleted: ${artifactsDeleted}`);

            return `Cleanup complete. Deleted ${runsDeleted} runs and ${artifactsDeleted} artifacts.`;
          result-encoding: string
.github/workflows/wfr-update-npm.yml
==== Content of .github/workflows/wfr-update-npm.yml ====
# .github/workflows/wfr-update-npm.yml

#
# agentic-lib
# Copyright (C) 2025 Polycode Limited
#
# This file is part of agentic-lib.
#
# agentic-lib is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License v3.0 (GPL‑3).
# along with this program. If not, see <https://www.gnu.org/licenses/>.
#
# IMPORTANT: Any derived work must include the following attribution:
# "This work is derived from https://github.com/xn-intenton-z2a/agentic-lib"
#

name: ∞ update-npm

on:
  workflow_call:
    inputs:
      buildScript:
        description: 'The script must be runnable as: `npm ci ; <script>` and succeed with a zero exit code. e.g. `npm run build`'
        type: string
        required: false
        default: 'echo "No build script specified."'
      testScript:
        description: 'The script must be runnable as: `npm ci ; <script>` and succeed with a zero exit code. e.g. `npm test`'
        type: string
        required: false
        default: 'npm test'
      mainScript:
        description: 'The script must be runnable as: `npm ci ; <script>` and succeed with a zero exit code. e.g. `npm run start`'
        type: string
        required: false
        default: 'npm run start'
      upgradeTarget:
        description: 'The type of upgrade to perform. e.g. "minor"'
        type: string
        required: false
        default: 'minor'
      branch:
        description: 'The branch to push changes to. e.g. "agentic-lib-update"'
        type: string
        required: false
        default: 'agentic-lib-update'
      npmAuthOrganisation:
        description: 'The GitHub organisation to authenticate with for npm. e.g. "xn-intenton-z2a"'
        type: string
        required: false
        default: ''
      gitUserEmail:
        description: 'The email to use for git commits. e.g. "action@github.com"'
        type: string
        required: false
        default: 'action@github.com'
      gitUserName:
        description: 'The name to use for git commits. e.g. "GitHub Actions[bot]"'
        type: string
        required: false
        default: 'GitHub Actions[bot]'
      gitCommitMessage:
        description: 'The message to use for git commits. e.g. "chore: dependency updates"'
        type: string
        required: false
        default: 'chore: dependency updates'
    secrets:
      PERSONAL_ACCESS_TOKEN:
        required: false
    outputs:
      updatedFiles:
          description: 'Whether files were updated by the script. e.g. "true"'
          value: ${{ jobs.update.outputs.updatedFiles }}

jobs:
  update:
    runs-on: ubuntu-latest

    env:
      buildScript: ${{ inputs.buildScript || 'npm run build' }}
      testScript: ${{ inputs.testScript || 'npm test' }}
      mainScript: ${{ inputs.mainScript || 'npm run start' }}
      mainScriptTimeout: '5m'
      upgradeTarget: ${{ inputs.upgradeTarget || 'minor' }}
      branch: ${{ inputs.branch || 'agentic-lib-update' }}
      npmAuthOrganisation: ${{ inputs.npmAuthOrganisation || '' }}
      gitUserEmail: ${{ inputs.gitUserEmail || 'action@github.com' }}
      gitUserName: ${{ inputs.gitUserName || 'GitHub Actions[bot]' }}
      gitCommitMessage: |
        ${{ inputs.gitCommitMessage || 'chore: dependency updates' }}

    steps:

      - name: Log which version
        if: ${{ github.event.client_payload }}
        shell: bash
        run: |
          echo "Package: ${{ github.event.client_payload.packageName }}"

      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Check GitHub authentication
        if: ${{ env.npmAuthOrganisation != '' }}
        shell: bash
        run: |
          curl --include --header "Authorization: token ${{ secrets.PERSONAL_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}" https://api.github.com/user

      - name: Set up .npmrc
        if: ${{ env.npmAuthOrganisation != '' }}
        shell: bash
        run: |
          echo "${{ env.npmAuthOrganisation }}:registry=https://npm.pkg.github.com" >> .npmrc
          echo "//npm.pkg.github.com/:_authToken=${{ secrets.PERSONAL_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}" >> .npmrc
          echo "always-auth=true" >> .npmrc

      - name: Get latest from remote
        run: |
          git config --local user.email "${{ env.gitUserEmail }}"
          git config --local user.name "${{ env.gitUserName }}"
          git pull --ff-only origin ${{ github.ref }}

      - run: rm -f package-lock.json

      - run: npm install

      - name: Build project
        id: build
        shell: bash
        run: |
          output=$(${{ env.buildScript }} 2>&1)
          echo "output<<EOF" >> "$GITHUB_OUTPUT"
          echo "$output" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          echo "output=${output}"

      - name: Run tests before update
        id: test
        shell: bash
        run: |
          output=$(${{ env.testScript }} 2>&1)
          echo "output<<EOF" >> "$GITHUB_OUTPUT"
          echo "$output" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          echo "output=${output}"

      - name: Run main before update
        id: main
        shell: bash
        run: |
          output=$(timeout ${{ env.mainScriptTimeout }} ${{ env.mainScript }} 2>&1)
          echo "output<<EOF" >> "$GITHUB_OUTPUT"
          echo "$output" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          echo "output=${output}"

      - name: Update packages with npm
        continue-on-error: true
        shell: bash
        env:
          ncuUpgradeTarget: ${{ env.upgradeTarget || 'minor' }}
        run: npm install --save ; npm update ; npm upgrade ; npm install

      - name: Update packages with ncu
        continue-on-error: true
        shell: bash
        env:
          ncuUpgradeTarget: ${{ env.upgradeTarget || 'minor' }}
        run: npx ncu --upgrade --enginesNode --retry 3 --target ${{ env.ncuUpgradeTarget }} --verbose ; npm install ; npm update ; npm upgrade ; npm install

      - name: git-diff
        id: git-diff
        shell: bash
        run: |
          savedOptions=$(set +o) \
          && set +e \
          ; if git diff --quiet; then
            echo "updated=false" | tee -a "${GITHUB_OUTPUT?}"
          else
            echo "updated=true" | tee -a "${GITHUB_OUTPUT?}"
          fi \
          ; eval "${savedOptions?}" \
          ;
        continue-on-error: true

      - run: rm -rf './node_modules/'

      - run: npm ci
        
      - name: Tear down .npmrc
        if: ${{ env.npmAuthOrganisation != '' }}
        shell: bash
        run: rm -f .npmrc

      - name: Run tests after update
        shell: bash
        run: |
          output=$(${{ env.testScript }} 2>&1)
          echo "output<<EOF" >> "$GITHUB_OUTPUT"
          echo "$output" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          echo "output=${output}"

      - name: Run main after update
        shell: bash
        run: |
          output=$(timeout ${{ env.mainScriptTimeout }} ${{ env.mainScript }} 2>&1)
          echo "output<<EOF" >> "$GITHUB_OUTPUT"
          echo "$output" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          echo "output=${output}"  

      - name: Commit
        if: ${{ steps.git-diff.outputs.updated == 'true' || env.git-force == 'true' }}
        shell: bash
        run: |
          git config --local user.email '${{ env.gitUserEmail }}'
          git config --local user.name '${{ env.gitUserName }}'
          git status -v
          git switch -c '${{ env.branch }}'
          git add -v --all
          git commit -v -m '${{ env.gitCommitMessage }}'
          #git pull --rebase --set-upstream origin '${{ env.branch }}'
          git pull --rebase origin main
          git push --set-upstream origin '${{ env.branch }}'
          git push -v
          git status -v

    outputs:
      updatedFiles: ${{ steps.git-diff.outputs.updated || '' }}
.github/workflows/wfr-automerge-label-issue.yml
==== Content of .github/workflows/wfr-automerge-label-issue.yml ====
# .github/workflows/wfr-automerge-label-issue.yml

#
# agentic-lib
# Copyright (C) 2025 Polycode Limited
#
# This file is part of agentic-lib.
#
# agentic-lib is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License v3.0 (GPL‑3).
# along with this program. If not, see <https://www.gnu.org/licenses/>.
#
# IMPORTANT: Any derived work must include the following attribution:
# "This work is derived from https://github.com/xn-intenton-z2a/agentic-lib"
#

name: ∞ automerge-label-issue

on:
  workflow_call:
    inputs:
      pullNumber:
        description: 'The pull request number. e.g. "123"'
        type: string
        required: true
      branchPrefix:
        description: 'The prefix for the issue branch. e.g. "agentic-lib-issue-".'
        type: string
        required: true
      commentPrefix:
        description: 'The prefix for the comment. e.g. "The feature branch ".'
        type: string
        required: false
        default: 'The feature branch has been merged: '
      s3BucketUrl:
        description: 'The S3 bucket URL with prefix to use. e.g. "s3://my-bucket/prefix"'
        type: string
        required: false
        default: ''
      iamRoleArn:
        description: 'The ARN of the IAM role to assume. e.g. "arn:aws:iam::123456789012:role/my-role"'
        type: string
        required: false
        default: ''
    secrets:
      PERSONAL_ACCESS_TOKEN:
        required: false
    outputs:
      issueNumber:
        description: 'The issue number just merged. e.g. "123"'
        value: ${{ jobs.check-pr.outputs.issueNumber }}
jobs:
  label-issue:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: extract-issueNumber
        id: extract-issue-number
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PERSONAL_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}
          script: |
            const pullNumber = parseInt('${{ inputs.pullNumber }}', 10);
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            
            const { data: pullRequest } = await github.rest.pulls.get({
              owner,
              repo,
              pull_number: pullNumber,
            });
            const branchName = pullRequest.head.ref;
            const issueNumberMatch = branchName.match(/${{ inputs.branchPrefix }}(\d+)/);
            let issueNumber;
            if (issueNumberMatch) {
              issueNumber = issueNumberMatch[1];
            } else {
              issueNumber = '';
            }

            core.setOutput('issueNumber', issueNumber);
            core.info(`issueNumber '${issueNumber}'`);

      - name: Add "merged" label and comment on issue
        if: steps.extract-issue-number.outputs.issueNumber != ''
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PERSONAL_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}
          script: |
            const pullNumber = parseInt('${{ inputs.pullNumber }}', 10);
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            
            const { data: pullRequest } = await github.rest.pulls.get({
              owner,
              repo,
              pull_number: pullNumber,
            });
            const issueNumber = '${{ steps.extract-issue-number.outputs.issueNumber }}';
            const branchName = pullRequest.head.ref;
            const commentBody = `${{ inputs.branchPrefix || 'The feature branch has been merged: ' }}${branchName}`;
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber,
              labels: ['merged']
            });
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber,
              body: commentBody
            });
    outputs:
      issueNumber: ${{ steps.extract-issue-number.outputs.issueNumber }}

.github/workflows/wfr-update-mvn.yml
==== Content of .github/workflows/wfr-update-mvn.yml ====
# .github/workflows/wfr-update-mvn.yml

#
# agentic-lib
# Copyright (C) 2025 Polycode Limited
#
# This file is part of agentic-lib.
#
# agentic-lib is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License v3.0 (GPL‑3).
# along with this program. If not, see <https://www.gnu.org/licenses/>.
#
# IMPORTANT: Any derived work must include the following attribution:
# "This work is derived from https://github.com/xn-intenton-z2a/agentic-lib"
#

name: ∞ update-mvn

on:
  workflow_call:
    inputs:
      buildScript:
        description: 'The script must be runnable as: `mvn clean install`'
        type: string
        required: false
        default: './mvnw clean install'
      testScript:
        description: 'The script must be runnable as: `mvn test`'
        type: string
        required: false
        default: './mvnw test'
      upgradeTarget:
        description: 'Ignored for Maven; use versions:use-latest-releases'
        type: string
        required: false
        default: 'minor'
      branch:
        description: 'The branch to push changes to. e.g. "agentic-lib-update"'
        type: string
        required: false
        default: 'agentic-lib-update'
      npmAuthOrganisation:
        description: '(Not used for Maven)'
        type: string
        required: false
        default: ''
      gitUserEmail:
        description: 'The email to use for git commits. e.g. "action@github.com"'
        type: string
        required: false
        default: 'action@github.com'
      gitUserName:
        description: 'The name to use for git commits. e.g. "GitHub Actions[bot]"'
        type: string
        required: false
        default: 'GitHub Actions[bot]'
      gitCommitMessage:
        description: 'The message to use for git commits. e.g. "chore: dependency updates"'
        type: string
        required: false
        default: 'chore: dependency updates'
    secrets:
      PERSONAL_ACCESS_TOKEN:
        required: false
    outputs:
      updatedFiles:
          description: 'Whether files were updated by the script. e.g. "true"'
          value: ${{ jobs.update.outputs.updatedFiles }}

jobs:
  update:
    runs-on: ubuntu-latest

    env:
      buildScript: ${{ inputs.buildScript || './mvnw clean install' }}
      testScript: ${{ inputs.testScript || './mvnw test' }}
      upgradeTarget: ${{ inputs.upgradeTarget || 'minor' }}
      branch: ${{ inputs.branch || 'agentic-lib-update' }}
      gitUserEmail: ${{ inputs.gitUserEmail || 'action@github.com' }}
      gitUserName: ${{ inputs.gitUserName || 'GitHub Actions[bot]' }}
      gitCommitMessage: |
        ${{ inputs.gitCommitMessage || 'chore: dependency updates' }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Java (JDK 21)
        uses: actions/setup-java@v3
        with:
          distribution: 'temurin'
          java-version: '21'

      - name: Get latest from remote
        run: |
          git config --local user.email "${{ env.gitUserEmail }}"
          git config --local user.name "${{ env.gitUserName }}"
          git pull --ff-only origin ${{ github.ref }}

      - name: Build project before update
        id: build
        shell: bash
        run: |
          output=$(${{env.buildScript}} 2>&1)
          echo "output<<EOF" >> "$GITHUB_OUTPUT"
          echo "$output" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          echo "output=${output}"

      - name: Run tests before update
        id: test
        shell: bash
        run: |
          output=$(${{env.testScript}} 2>&1)
          echo "output<<EOF" >> "$GITHUB_OUTPUT"
          echo "$output" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          echo "output=${output}"

      - name: Update Maven dependencies
        continue-on-error: true
        shell: bash
        run: |
          mvn versions:use-latest-releases -DallowSnapshots=false
          # Optionally, run: mvn versions:commit to finalize changes

      - name: Get git diff status
        id: git-diff
        shell: bash
        run: |
          savedOptions=$(set +o) && set +e
          if git diff --quiet; then
            echo "updated=false" | tee -a "${GITHUB_OUTPUT?}"
          else
            echo "updated=true" | tee -a "${GITHUB_OUTPUT?}"
          fi
          eval "${savedOptions?}"
        continue-on-error: true

      - name: Build project after update
        shell: bash
        run: ${{env.buildScript}}

      - name: Run tests after update
        shell: bash
        run: ${{env.testScript}}

      - name: Commit changes
        if: ${{ steps.git-diff.outputs.updated == 'true' || env.git-force == 'true' }}
        shell: bash
        run: |
          git config --local user.email "${{ env.gitUserEmail }}"
          git config --local user.name "${{ env.gitUserName }}"
          git status -v
          git switch -c "${{ env.branch }}"
          git add -v --all
          git commit -v -m "${{ env.gitCommitMessage }}"
          git pull --rebase origin main
          git push --set-upstream origin "${{ env.branch }}"
          git push -v
          git status -v

    outputs:
      updatedFiles: ${{ steps.git-diff.outputs.updated || '' }}
.github/workflows/wfr-automerge-merge-pr.yml
==== Content of .github/workflows/wfr-automerge-merge-pr.yml ====
# .github/workflows/wfr-automerge-merge-pr.yml

#
# agentic-lib
# Copyright (C) 2025 Polycode Limited
#
# This file is part of agentic-lib.
#
# agentic-lib is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License v3.0 (GPL‑3).
# along with this program. If not, see <https://www.gnu.org/licenses/>.
#
# IMPORTANT: Any derived work must include the following attribution:
# "This work is derived from https://github.com/xn-intenton-z2a/agentic-lib"
#

name: ∞ automerge-merge-pr

on:
  workflow_call:
    inputs:
      pullNumber:
        description: 'The pull request number. e.g. "123"'
        type: string
        required: true
      # New inputs:
      s3BucketUrl:
        description: 'The S3 bucket URL with prefix to use. e.g. "s3://my-bucket/prefix"'
        type: string
        required: false
        default: ''
      iamRoleArn:
        description: 'The ARN of the IAM role to assume. e.g. "arn:aws:iam::123456789012:role/my-role"'
        type: string
        required: false
        default: ''
    secrets:
      PERSONAL_ACCESS_TOKEN:
        required: false
    outputs:
      prMerged:
        description: 'Set to "true", if the PR has been merged either already or by this process.'
        value: ${{ jobs.merge-pr.outputs.prMerged }}

jobs:
  merge-pr:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: auto-merge-pr
        id: auto-merge-pr
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PERSONAL_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}
          script: |
            const pullNumber = parseInt('${{ inputs.pullNumber }}', 10);
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            let pullRequest;
            let prMerged;
            
            const { data: pullRequests } = await github.rest.pulls.list({
              owner: owner,
              repo: repo,
            });
            if (pullRequests.length > 0) {
              const filteredPRs = pullRequests.filter(pr => pr.number === pullNumber);
              if (filteredPRs.length > 0) {
                pullRequest = filteredPRs[0];
                core.info(`Found pull request #${pullRequest.number}.`);
                const { data: pullRequestFromGet } = await github.rest.pulls.get({
                  owner,
                  repo,
                  pull_number: pullNumber,
                });
                pullRequest = pullRequestFromGet;
                core.info(JSON.stringify(pullRequest));
              } else {
                core.info(`No pull request found with number #${pullNumber}.`);
                pullRequest = null;
              }
            } else {
              pullRequest = null;
              core.info('No pull requests found.');
            }

            if (pullRequest.state === "closed") {
              core.info(`PR #${pullNumber} is already closed.`);
              prMerged = 'true';
            } else if (pullRequest.state !== 'open') {
              core.info(`PR #${pullNumber} is not open it is ${pullRequest.state}.`);
              prMerged = 'false';
            } else if (pullRequest.mergeable && pullRequest.mergeable_state === 'clean') {
            
              await github.rest.pulls.merge({
                owner,
                repo,
                pull_number: pullNumber,
                merge_method: 'squash',
              });
              core.info(`PR #${pullNumber} merged.`);
            
              const branchRef = `heads/${pullRequest.head.ref}`;
              await github.rest.git.deleteRef({
                owner,
                repo,
                ref: branchRef,
              });
              core.info(`Branch '${pullRequest.head.ref}' deleted.`);
              prMerged = 'true';
            
            } else if (pullRequest.mergeable === false) {
              core.info(`PR #${pullNumber} is not mergeable.`);
              prMerged = 'false';
            } else if (pullRequest.mergeable === null) {
              core.info(`PR #${pullNumber} does not yet have a value for mergeability.`);
              prMerged = 'false';
            } else {
              core.info(`PR #${pullNumber} is not known.`);
              prMerged = 'false';
            }
            
            core.setOutput('prMerged', prMerged);
            core.info(`prMerged: '${prMerged}'`);

    outputs:
      prMerged: ${{ steps.auto-merge-pr.outputs.prMerged }}

.github/workflows/stats.yml
==== Content of .github/workflows/stats.yml ====
# .github/workflows/stats.yml
#
# This file is part of the example suite for `agentic-lib` see: https://github.com/xn-intenton-z2a/agentic-lib
# This file is licensed under the MIT License. For details, see LICENSE-MIT

name: ∞ Stats

on:
  workflow_dispatch:
  schedule:
    - cron: '0 */2 * * *' # schedule-1
    #- cron: '*/15 * * * *' # schedule-2
    #- cron: '*/5 * * * *' # schedule-3

jobs:
  generate-site:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      id-token: write
      pages: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.ref }}

      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: 'npm'

      - name: Set up ~/.npmrc
        run: |
          echo "@xn-intenton-z2a:registry=https://npm.pkg.github.com" >> ~/.npmrc
          echo "//npm.pkg.github.com/:_authToken=${{ secrets.PERSONAL_ACCESS_TOKEN }}" >> ~/.npmrc
          echo "always-auth=true" >> ~/.npmrc

      - run: npm ci

      - name: engine
        id: engine
        shell: bash
        run: |
          engine=$(grep '^[[:space:]]*- cron:.*#' .github/workflows/stats.yml | sed 's/^[[:space:]]*- cron:.*# //g')
          echo "engine=${engine}"
          echo "engine=${engine}" >> $GITHUB_OUTPUT

      - name: Generate raw JSON statistics file
        id: generate-json
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const path = require('path');
            const now = new Date();
            const { owner, repo } = context.repo;
            const jsonData = {};
            // Open issues count
            const issuesResp = await github.rest.issues.listForRepo({ owner, repo, state: "open", per_page: 256 });
            jsonData.openIssues = issuesResp.data.length;
            // Issues closed in last hour and day
            const sinceOneHour = new Date(now.getTime() - (60 * 60 * 1000)).toISOString();
            const closedHourResp = await github.rest.issues.listForRepo({ owner, repo, state: "closed", since: sinceOneHour, per_page: 256 });
            jsonData.issuesClosedLastHour = closedHourResp.data.length;
            const sinceOneDay = new Date(now.getTime() - (24 * 60 * 60 * 1000)).toISOString();
            const closedDayResp = await github.rest.issues.listForRepo({ owner, repo, state: "closed", since: sinceOneDay, per_page: 256 });
            jsonData.issuesClosedLastDay = closedDayResp.data.length;
            // Open pull requests with age in minutes
            const pullsResp = await github.rest.pulls.list({ owner, repo, state: "open", per_page: 256 });
            const prDetails = pullsResp.data.map(pr => {
              const createdAt = new Date(pr.created_at);
              const ageMinutes = Math.floor((now - createdAt) / (1000 * 60));
              return { title: pr.title, ageMinutes };
            });
            jsonData.openPRs = prDetails.length;
            jsonData.prDetails = prDetails;
            // Repository push details
            const repoResp = await github.rest.repos.get({ owner, repo });
            const pushedAt = new Date(repoResp.data.pushed_at);
            jsonData.diffMinutes = Math.floor((now - pushedAt) / (1000 * 60));
            const mainBranchResp = await github.rest.repos.getBranch({ owner, repo, branch: "main" });
            const mainPushedAt = new Date(mainBranchResp.data.commit.commit.author.date);
            jsonData.diffMinutesMain = Math.floor((now - mainPushedAt) / (1000 * 60));
            // Commits in the last hour and day
            const commitsLastHourResp = await github.rest.repos.listCommits({ owner, repo, since: sinceOneHour, per_page: 256 });
            jsonData.commitsLastHour = commitsLastHourResp.data.length;
            const commitsLastDayResp = await github.rest.repos.listCommits({ owner, repo, since: sinceOneDay, per_page: 256 });
            jsonData.commitsLastDay = commitsLastDayResp.data.length;
            // Last 5 commits on main
            const lastFiveCommitsResp = await github.rest.repos.listCommits({ owner, repo, sha: "main", per_page: 5 });
            jsonData.lastFiveCommitMessages = lastFiveCommitsResp.data.map(commit => {
              const commitDate = new Date(commit.commit.author.date);
              const hh = commitDate.getHours().toString().padStart(2, '0');
              const mm = commitDate.getMinutes().toString().padStart(2, '0');
              const message = commit.commit.message.length > 64 ? commit.commit.message.substring(0, 64) + "..." : commit.commit.message;
              return { time: `${hh}:${mm}`, message };
            });
            // Branches excluding "main" and "github-pages"
            const branchesResp = await github.rest.repos.listBranches({ owner, repo, per_page: 256 });
            const branchData = branchesResp.data.filter(branch => branch.name !== "main" && branch.name !== "github-pages");
            const branchDetails = await Promise.all(branchData.map(async branch => {
              const branchResp = await github.rest.repos.getBranch({ owner, repo, branch: branch.name });
              const lastCommitDate = new Date(branchResp.data.commit.commit.author.date);
              const minutesSinceLastCommit = Math.floor((now - lastCommitDate) / (1000 * 60));
              return { branch: branch.name, minutesSinceLastCommit };
            }));
            jsonData.branches = { count: branchDetails.length, details: branchDetails };
            // Additional metrics
            const averagePRAge = prDetails.length > 0 ? Math.floor(prDetails.reduce((sum, pr) => sum + pr.ageMinutes, 0) / prDetails.length) : 0;
            jsonData.averagePRAge = averagePRAge;
            jsonData.testStatus = "PASS";
            jsonData.testsLastPassedMinutes = 15;
            jsonData.generatedAt = now.toISOString();
            // Write JSON file
            const outputDir = "public";
            if (!fs.existsSync(outputDir)) { fs.mkdirSync(outputDir); }
            const outputPath = path.join(outputDir, "stats.json");
            fs.writeFileSync(outputPath, JSON.stringify(jsonData, null, 2), "utf8");
            core.info(`JSON stats generated at ${outputPath}.`);
            core.setOutput("jsonStatsPath", outputPath);

      #- run: npm install -g aws-cdk

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::541134664601:role/agentic-lib-github-actions-role
          role-chaining: false
          aws-region: eu-west-2
          audience: sts.amazonaws.com
          role-skip-session-tagging: true
          output-credentials: true
          retry-max-attempts: 3

      - run: aws sts get-caller-identity

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::541134664601:role/agentic-lib-deployment-role
          role-chaining: true
          aws-region: eu-west-2
          audience: sts.amazonaws.com
          role-skip-session-tagging: true
          output-credentials: true
          retry-max-attempts: 3

      - run: aws s3 ls s3://agentic-lib-bucket/events/ --summarize

      - name: Upload JSON stats artifact to S3
        shell: bash
        run: |
          aws s3 cp \
              ${{ steps.generate-json.outputs.jsonStatsPath }} \
              s3://agentic-lib-bucket/events/${{ github.event.repository.name }}-stats.json \
          ;

      - name: Upload JSON stats artifact to GitHub
        uses: actions/upload-artifact@v4
        with:
          name: stats-json
          path: ${{ steps.generate-json.outputs.jsonStatsPath }}

      - name: Generate statistics page
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const path = require('path');

            // Helper: truncate string to max length with ellipsis.
            function truncate(str, max) {
              return str.length > max ? str.substring(0, max) + "..." : str;
            }

            const now = new Date();
            const { owner, repo } = context.repo;
            core.info(`Gathering stats for ${owner}/${repo}...`);

            // Open issues count (up to 256)
            const issuesResp = await github.rest.issues.listForRepo({
              owner,
              repo,
              state: "open",
              per_page: 256
            });
            const openIssues = issuesResp.data.length;
            core.info(`Open issues: ${openIssues}`);

            // Issues closed in last hour and last 24 hours.
            const sinceOneHour = new Date(now.getTime() - (60 * 60 * 1000)).toISOString();
            const closedHourResp = await github.rest.issues.listForRepo({
              owner,
              repo,
              state: "closed",
              since: sinceOneHour,
              per_page: 256
            });
            const issuesClosedLastHour = closedHourResp.data.length;
            const sinceOneDay = new Date(now.getTime() - (24 * 60 * 60 * 1000)).toISOString();
            const closedDayResp = await github.rest.issues.listForRepo({
              owner,
              repo,
              state: "closed",
              since: sinceOneDay,
              per_page: 256
            });
            const issuesClosedLastDay = closedDayResp.data.length;

            // Open pull requests with age annotation (in minutes).
            const pullsResp = await github.rest.pulls.list({
              owner,
              repo,
              state: "open",
              per_page: 256
            });
            const prDetails = pullsResp.data.map(pr => {
              const createdAt = new Date(pr.created_at);
              const ageMinutes = Math.floor((now - createdAt) / (1000 * 60));
              return `[${ageMinutes}m] ${pr.title}`;
            });
            const openPRs = prDetails.length;
            core.info(`Open PRs (${openPRs}): ${prDetails.join('; ')}`);

            // Repository push details, converted to minutes.
            const repoResp = await github.rest.repos.get({ owner, repo });
            const pushedAt = new Date(repoResp.data.pushed_at);
            const diffMinutes = Math.floor((now - pushedAt) / (1000 * 60));

            const mainBranchResp = await github.rest.repos.getBranch({ owner, repo, branch: "main" });
            const mainPushedAt = new Date(mainBranchResp.data.commit.commit.author.date);
            const diffMinutesMain = Math.floor((now - mainPushedAt) / (1000 * 60));

            // Commits in the last hour and last day.
            const commitsLastHourResp = await github.rest.repos.listCommits({
              owner,
              repo,
              since: sinceOneHour,
              per_page: 256
            });
            const commitsLastHour = commitsLastHourResp.data.length;
            const commitsLastDayResp = await github.rest.repos.listCommits({
              owner,
              repo,
              since: sinceOneDay,
              per_page: 256
            });
            const commitsLastDay = commitsLastDayResp.data.length;

            // Last 5 commit messages from main with timestamp (HH:MM) and truncated.
            const lastFiveCommitsResp = await github.rest.repos.listCommits({
              owner,
              repo,
              sha: "main",
              per_page: 5
            });
            const lastFiveCommitMessages = lastFiveCommitsResp.data.map(commit => {
              const commitDate = new Date(commit.commit.author.date);
              const hh = commitDate.getHours().toString().padStart(2, '0');
              const mm = commitDate.getMinutes().toString().padStart(2, '0');
              const truncatedMsg = truncate(commit.commit.message, 64);
              return `[${hh}:${mm}] - ${truncatedMsg}`;
            });

            // Branches excluding "main" and "github-pages", with last commit time (in minutes).
            const branchesResp = await github.rest.repos.listBranches({
              owner,
              repo,
              per_page: 256
            });
            const branchData = branchesResp.data.filter(branch => branch.name !== "main" && branch.name !== "github-pages");
            const branchDetails = await Promise.all(branchData.map(async branch => {
              const branchResp = await github.rest.repos.getBranch({ owner, repo, branch: branch.name });
              const lastCommitDate = new Date(branchResp.data.commit.commit.author.date);
              const minutesSinceLastCommit = Math.floor((now - lastCommitDate) / (1000 * 60));
              // For lack of branch creation time, duplicate the last commit time.
              return `[${minutesSinceLastCommit}m/${minutesSinceLastCommit}m] ${branch.name}`;
            }));
            const branchCount = branchDetails.length;

            // Additional metrics: Average PR age and placeholder test status.
            const averagePRAge = openPRs > 0 ? Math.floor(prDetails.reduce((sum, prText) => {
              const match = prText.match(/^\[(\d+)m\]/);
              return sum + (match ? parseInt(match[1]) : 0);
            }, 0) / openPRs) : 0;
            const testStatus = "PASS"; // Placeholder (if tests info available, include it)
            const testsLastPassedMinutes = 15; // Placeholder

            const html = `
              <!DOCTYPE html>
              <html lang="en">
              <head>
              <meta charset="UTF-8">
              <title>${repo} stats</title>
              <style>
                body { font-family: Arial, sans-serif; margin: 2em; background-color: #f9f9f9; color: #333; }
                h1 { font-size: 1.5em; font-family: monospace; }
                section { margin-bottom: 1em; }
                ul { list-style: none; padding: 0; }
                li { margin: 0.5em 0; }
                .label { font-weight: bold; }
                footer { margin-top: 2em; font-size: 0.9em; color: #777; }
              </style>
              </head>
              <body>
                <header>
                  <h1>${repo}</h1>
                </header>
                <section>
                  <p><span class="label">Open Pull Requests (${openPRs}):</span> ${prDetails.join('; ') || 'None'}</p>
                </section>
                <section>
                  <p><span class="label">Branches (${branchCount}):</span> ${branchDetails.join(', ') || 'None'}</p>
                </section>
                <section>
                  <p><span class="label">Open Issues:</span> ${openIssues}</p>
                  <p><span class="label">Issues closed in last hour:</span> ${issuesClosedLastHour}</p>
                  <p><span class="label">Issues closed in last 24 hours:</span> ${issuesClosedLastDay}</p>
                </section>
                <section>
                  <p><span class="label">Engine:</span> ${{ steps.engine.outputs.engine }}</p>
                </section>
                <section>
                  <p><span class="label">Minutes since push anywhere:</span> ${diffMinutes}</p>
                  <p><span class="label">Minutes since push to main:</span> ${diffMinutesMain}</p>
                </section>
                <section>
                  <p><span class="label">Commits to main last hour:</span> ${commitsLastHour}</p>
                  <p><span class="label">Commits to main last day:</span> ${commitsLastDay}</p>
                </section>
                <section>
                  <p><span class="label">Last 5 commit messages from main:</span></p>
                  <ul>
                    ${lastFiveCommitMessages.map(msg => `<li>${msg}</li>`).join('')}
                  </ul>
                </section>
                <section>
                  <p>
                    <a href="https://github.com/${owner}/${repo}" target="_blank">repository 🔗</a> - 
                    <a href="https://${owner}.github.io/${repo}/index.html" target="_blank">site 🔗</a> - 
                    <a href="https://${owner}.github.io/${repo}/latest.html" target="_blank">stats 🔗</a> - 
                    <a href="https://${owner}.github.io/${repo}/all.html" target="_blank">all stats 🔗</a>
                  </p>
                </section>
                <footer>
                  <p>Generated on ${now.toISOString()}</p>
                </footer>
              </body>
              </html>
            `;
            
            // Ensure the output directory exists.
            const outputDir = "public";
            if (!fs.existsSync(outputDir)) {
              fs.mkdirSync(outputDir);
            }
            const outputPath = path.join(outputDir, "latest.html");
            fs.writeFileSync(outputPath, html, "utf8");
            core.info(`Static site generated at ${outputPath}.`);
            core.setOutput("sitePath", outputPath);

      - name: Generate index page
        shell: bash
        run: |
          ./scripts/md-to-html.js < README.md > public/index.agentic-lib.html
          cat public/index.agentic-lib.html | sed 's/agentic-lib/${{ github.event.repository.name }}/g' > public/index.html

      - name: Generate unique filename for this version
        id: uniqueFile
        run: |
          echo "[INFO] Generating a unique filename..."
          unique=$(date +%Y%m%d%H%M%S)-$(uuidgen).html
          cp public/latest.html "public/${unique}"
          echo "uniqueFile=${unique}" >> $GITHUB_OUTPUT
          echo "[INFO] Unique file created: public/${unique}"

      - name: Deploy to GitHub Pages
        uses: peaceiris/actions-gh-pages@v4
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: 'public'
          publish_branch: github-pages
          keep_files: true
          enable_jekyll: 'true'

      - name: Upload generated site as artifact
        uses: actions/upload-artifact@v4
        with:
          name: site
          path: 'public'

      - name: Output published URLs
        run: |
          echo "[INFO] Determining GitHub Pages URL..."
          # GitHub Pages URL typically: https://<owner>.github.io/<repo>/
          repoName=${{ github.event.repository.name }}
          owner=${{ github.repository_owner }}
          baseUrl="https://${owner}.github.io/${repoName}"
          latestUrl="${baseUrl}/latest.html"
          uniqueFile=$(echo "${{ steps.uniqueFile.outputs.uniqueFile }}" | tr -d '\n')
          uniqueUrl="${baseUrl}/${uniqueFile}"
          pwd
          echo "public:"
          ls -larth "public"
          echo "public/latest.html:"
          ls -larth "public/latest.html"
          echo "public/${uniqueFile}:"
          ls -larth "public/${uniqueFile}"
          echo "::notice:: latestUrl: ${latestUrl}"
          echo "::notice:: uniqueUrl: ${uniqueUrl}"
          echo "latestUrl=${latestUrl}" >> $GITHUB_OUTPUT
          echo "uniqueUrl=${uniqueUrl}" >> $GITHUB_OUTPUT

.github/workflows/test.yml
==== Content of .github/workflows/test.yml ====
# .github/workflows/test.yml
#
# This file is part of the example suite for `agentic-lib` see: https://github.com/xn-intenton-z2a/agentic-lib
# This file is licensed under the MIT License. For details, see LICENSE-MIT

name: Tests
run-name: 'Tests [${{ github.ref_name }}] [${{ github.event.head_commit.message }}]'

on:
  push:
    paths:
      - '**/*.sh'
      - '**/*.java'
      - '**/*.js'
      - '**/*.json'
      - '**/*.yml'
      - '**/pom.xml'
      - '**/*.properties'
      - '!exports/**'
  workflow_dispatch:
  workflow_run:
    workflows:
      - "Automerge"
    types:
      - completed
  schedule:
    - cron: '45 */6 * * *' # schedule-1
    #- cron: '45 */4 * * *' # schedule-2
    #- cron: '0 * * * *' # schedule-3


jobs:

  npm-test:
    name: 'npm test'
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: read
      id-token: write
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: 'npm'

      - name: Set up ~/.npmrc
        run: |
          echo "@xn-intenton-z2a:registry=https://npm.pkg.github.com" >> ~/.npmrc
          echo "//npm.pkg.github.com/:_authToken=${{ secrets.PERSONAL_ACCESS_TOKEN }}" >> ~/.npmrc
          echo "always-auth=true" >> ~/.npmrc

      - run: npm ci

      - run: npm test

  npm-unit-test:
    name: 'npm unit test with coverage'
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: 'npm'

      - name: Set up ~/.npmrc
        run: |
          echo "@xn-intenton-z2a:registry=https://npm.pkg.github.com" >> ~/.npmrc
          echo "//npm.pkg.github.com/:_authToken=${{ secrets.PERSONAL_ACCESS_TOKEN }}" >> ~/.npmrc
          echo "always-auth=true" >> ~/.npmrc

      - run: npm ci

      - run: npm run test:unit

  npm-build-test-and-run-main:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: 'npm'

      - name: Set up ~/.npmrc
        run: |
          echo "@xn-intenton-z2a:registry=https://npm.pkg.github.com" >> ~/.npmrc
          echo "//npm.pkg.github.com/:_authToken=${{ secrets.PERSONAL_ACCESS_TOKEN }}" >> ~/.npmrc
          echo "always-auth=true" >> ~/.npmrc

      - run: npm ci

      - name: build
        id: build
        shell: bash
        run: 'npm run build'

      - name: test
        id: test
        shell: bash
        run: 'npm test'

      - name: main
        id: main
        shell: bash
        run: timeout 5m ${{ vars.MAIN_SCRIPT || 'npm run start' }}

  mvn-package-cdk-synth:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: 'npm'

      - name: Set up ~/.npmrc
        run: |
          echo "@xn-intenton-z2a:registry=https://npm.pkg.github.com" >> ~/.npmrc
          echo "//npm.pkg.github.com/:_authToken=${{ secrets.PERSONAL_ACCESS_TOKEN }}" >> ~/.npmrc
          echo "always-auth=true" >> ~/.npmrc

      - run: npm ci

      - name: mvn
        id: mvn
        shell: bash
        run: |
          if [ -f pom.xml ]; then
            pomXmlExists='true'
          else
            pomXmlExists='false'
          fi
          echo "pomXmlExists=${pomXmlExists?}" | tee -a "${GITHUB_OUTPUT?}"

      - uses: actions/setup-java@v4
        if: steps.mvn.outputs.pomXmlExists == 'true'
        with:
          distribution: 'corretto'
          java-version: 21
          cache: 'maven'
          server-password: PERSONAL_ACCESS_TOKEN
        env:
          GITHUB_ACTOR: ${{ github.actor }}
          PERSONAL_ACCESS_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}

      - name: check
        id: check
        run: cat ~/.m2/settings.xml
        if: steps.mvn.outputs.pomXmlExists == 'true'

      - name: package
        id: package
        if: steps.mvn.outputs.pomXmlExists == 'true'
        shell: bash
        run: ./mvnw clean package
        env:
          GITHUB_ACTOR: ${{ github.actor }}
          PERSONAL_ACCESS_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}

      - name: synth
        id: synth
        if: steps.mvn.outputs.pomXmlExists == 'true'
        shell: bash
        run: npx cdk synth --strict --validation --no-staging --trace
        env:
          GITHUB_ACTOR: ${{ github.actor }}
          PERSONAL_ACCESS_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}
.github/workflows/wfr-echo.yml
==== Content of .github/workflows/wfr-echo.yml ====
# .github/workflows/wfr-echo.yml

#
# agentic-lib
# Copyright (C) 2025 Polycode Limited
#
# This file is part of agentic-lib.
#
# agentic-lib is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License v3.0 (GPL‑3).
# along with this program. If not, see <https://www.gnu.org/licenses/>.
#
# IMPORTANT: Any derived work must include the following attribution:
# "This work is derived from https://github.com/xn-intenton-z2a/agentic-lib"
#

name: ∞ echo

on:
  workflow_call:
    inputs:
      message:
        description: 'The message to echo. e.g. "Hello, World!"'
        required: false
        type: string
        default: 'Hello, World!'
      s3BucketUrl:
        description: 'The S3 bucket URL with prefix to use. e.g. "s3://my-bucket/prefix"'
        type: string
        required: false
        default: ''
      iamRoleArn:
        description: 'The ARN of the IAM role to assume. e.g. "arn:aws:iam::123456789012:role/my-role"'
        type: string
        required: false
        default: ''

jobs:
  publish:
    runs-on: ubuntu-latest

    env:
      message: ${{ inputs.message || 'Hello, World!' }}

    steps:
      - run: echo '${{ env.message }}'

.github/workflows/wfr-run-script-and-commit-to-branch.yml
==== Content of .github/workflows/wfr-run-script-and-commit-to-branch.yml ====
# .github/workflows/wfr-run-script-and-push-changes.yml

#
# agentic-lib
# Copyright (C) 2025 Polycode Limited
#
# This file is part of agentic-lib.
#
# agentic-lib is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License v3.0 (GPL‑3).
# along with this program. If not, see <https://www.gnu.org/licenses/>.
#
# IMPORTANT: Any derived work must include the following attribution:
# "This work is derived from https://github.com/xn-intenton-z2a/agentic-lib"
#

name: ∞ run-script-and-push-changes

on:
  workflow_call:
    inputs:
      script:
        description: 'The script must be runnable as: `npm ci ; <script>`.'
        type: string
        required: false
        default: ''
      sarifScript:
        description: 'The script must be runnable as: `npm ci ; <script>` and output a SARIF file. e.g. `npm run linting-json`'
        type: string
        required: false
        default: ''
      testScript:
        description: 'The script must be runnable as: `npm ci ; <script>` and succeed with a zero exit code. e.g. `npm test`'
        type: string
        required: false
        default: 'npm test'
      branch:
        description: 'The branch to push changes to. e.g. "apply-script"'
        type: string
        required: false
        default: ''
      npmAuthOrganisation:
        description: 'The GitHub organisation to authenticate with for npm. e.g. "xn-intenton-z2a"'
        type: string
        required: false
        default: ''
      gitUserEmail:
        description: 'The email to use for git commits. e.g. "action@github.com"'
        type: string
        required: false
        default: 'action@github.com'
      gitUserName:
        description: 'The name to use for git commits. e.g. "GitHub Actions[bot]"'
        type: string
        required: false
        default: 'GitHub Actions[bot]'
      gitCommitMessage:
        description: 'The message to use for git commits. e.g. "Updated by script"'
        type: string
        required: false
        default: 'Updated by script'
    secrets:
      PERSONAL_ACCESS_TOKEN:
        required: false
    outputs:
      updatedFiles:
          description: 'Whether files were updated by the script. e.g. "true"'
          value: ${{ jobs.update-and-push.outputs.updatedFiles }}
      scriptOutput:
        description: 'The output from running the script. '
        value: ${{ jobs.update-and-push.outputs.scriptOutput }}
      remainingResultsCount:
        description: 'The number of results from the SARIF script. e.g. "1"'
        value: ${{ jobs.update-and-push.outputs.remainingResultsCount }}
      fixStillRequired:
        description: 'Whether the SARIF script requires fixes. e.g. "true"'
        value: ${{ jobs.update-and-push.outputs.fixStillRequired }}

jobs:
  update-and-push:
    runs-on: ubuntu-latest

    env:
      script: ${{ inputs.script || '' }}
      sarifScript: ${{ inputs.sarifScript || '' }}
      testScript: ${{ inputs.testScript || 'npm test' }}
      branch: ${{ inputs.branch || '' }}
      npmAuthOrganisation: ${{ inputs.npmAuthOrganisation || '' }}
      gitUserEmail: ${{ inputs.gitUserEmail || 'action@github.com' }}
      gitUserName: ${{ inputs.gitUserName || 'GitHub Actions[bot]' }}
      gitCommitMessage: ${{ inputs.gitCommitMessage || 'Updated by inputs.script' }}

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.ref }}

      - uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Check GitHub authentication
        if: ${{ env.npmAuthOrganisation != '' }}
        shell: bash
        run: |
          curl --include --header "Authorization: token ${{ secrets.PERSONAL_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}" https://api.github.com/user

      - name: Set up .npmrc
        if: ${{ env.npmAuthOrganisation != '' }}
        shell: bash
        run: |
          echo "${{ env.npmAuthOrganisation }}:registry=https://npm.pkg.github.com" >> .npmrc
          echo "//npm.pkg.github.com/:_authToken=${{ secrets.PERSONAL_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}" >> .npmrc
          echo "always-auth=true" >> .npmrc

      - name: Get latest from remote
        run: |
          git config --local user.email "${{ env.gitUserEmail }}"
          git config --local user.name "${{ env.gitUserName }}"
          git pull --ff-only origin ${{ github.ref }}

      - run: npm ci

      - name: script
        id: script
        if: ${{ env.script != '' }}
        shell: bash
        run: |
          set +e
          output=$(${{ env.script }} 2>&1)
          echo "output<<EOF" >> "$GITHUB_OUTPUT"
          echo "$output" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          echo "output=${output}"
          if git diff --quiet; then
            updated='false'
          else
            updated='true'
          fi
          set -e
          echo "updated=${updated}" >> $GITHUB_OUTPUT
          echo "updated=${updated}"
        continue-on-error: true

      - name: sarif-script
        id: sarif-script
        if: ${{ env.sarifScript != '' }}
        continue-on-error: true
        shell: bash
        run: |
          set +e
          results=$(${{ env.sarifScript }})
          exitCode="$?"
          set -e
          echo "exitCode=${exitCode}"
          fixStillRequired=$([ $? -eq 0 ] && echo 'true' || echo 'false')
          echo "fixStillRequired={fixStillRequired}" >> $GITHUB_OUTPUT
          echo "fixStillRequired=${fixStillRequired}"
          remainingResultsCount=$(echo "${results}" | jq '.runs[0].results | length' 2>/dev/null || echo "unknown")
          echo "remainingResultsCount=${remainingResultsCount}" >> $GITHUB_OUTPUT
          echo "remainingResultsCount=${remainingResultsCount}"
          echo "results: ${results}"

      - name: Test
        if: ${{ steps.script.outputs.updated == 'true' || env.git-force == 'true' }}
        shell: bash
        run: |
          ${{ env.testScript }}

      - name: Tear down npm auth
        if: ${{ env.npmAuthOrganisation != '' }}
        run: rm -vf .npmrc

      - name: Commit
        if: ${{ env.branch != '' && steps.script.outputs.updated == 'true' || env.git-force == 'true' }}
        shell: bash
        run: |
          git config --local user.email '${{ env.gitUserEmail }}'
          git config --local user.name '${{ env.gitUserName }}'
          git status -v
          git switch -c '${{ env.branch }}'
          git branch --set-upstream-to=origin/main
          git add -v --all
          git commit -v -m '${{ env.gitCommitMessage }}'
          git pull --rebase
          git push --set-upstream origin '${{ env.branch }}'
          git push -v
          git status -v

      - name: Log outputs
        continue-on-error: true
        shell: bash
        run: |
          echo "updatedFiles: steps.script.outputs.updated=${{ steps.script.outputs.updated }}"
          echo "scriptOutput: steps.script.outputs.output=${{ steps.script.outputs.output }}"
          echo "remainingResultsCount: steps.sarif-script.outputs.remainingResultsCount=${{ steps.sarif-script.outputs.remainingResultsCount }}"
          echo "fixStillRequired: steps.sarif-script.outputs.fixStillRequired=${{ steps.sarif-script.outputs.fixStillRequired }}"

    outputs:
      updatedFiles: ${{ steps.script.outputs.updated }}
      scriptOutput: ${{ steps.script.outputs.output }}
      remainingResultsCount: ${{ steps.sarif-script.outputs.remainingResultsCount }}
      fixStillRequired: ${{ steps.sarif-script.outputs.fixStillRequired }}
.github/workflows/issue-creator.yml
==== Content of .github/workflows/issue-creator.yml ====
# .github/workflows/issue-creator.yml
#
# This file is part of the example suite for `agentic-lib` see: https://github.com/xn-intenton-z2a/agentic-lib
# This file is licensed under the MIT License. For details, see LICENSE-MIT

name: Create Issue
concurrency: create-issue
run-name: "Create Issue"

on:
  workflow_dispatch:
    inputs:
      prompt:
        description: 'Text to drive the issue creation (if "house choice", a currently random prompt will be selected). e.g. "Make an improvement to tests."'
        required: false
        type: string
        default: 'house choice'
  schedule:
    - cron: '0 4 * * *' # schedule-1
    #- cron: '0 */2 * * *' # schedule-2
    #- cron: '*/15 * * * *' # schedule-3

jobs:

  # If the issue title is "house choice", a random prompt will be selected from the prompt library otherwise the supplied title will be used.
  select-prompt:
    runs-on: ubuntu-latest
    outputs:
      prompt: ${{ steps.extract.outputs.prompt }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Select prompt from ./prompts
        id: select
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = require('path');
            let prompt = '${{ github.event.inputs.prompt }}';
            if (prompt === 'house choice') {
              const promptsDir = './prompts';
              // Get all items in the directory
              const items = fs.readdirSync(promptsDir);
              // Filter only the files (exclude directories)
              const files = items.filter(item => {
                const filePath = path.join(promptsDir, item);
                return fs.lstatSync(filePath).isFile();
              });
            
              if (files.length === 0) {
                core.setFailed('No prompt files found in the prompts directory.');
              } else {
                // Select a random file
                const randomFile = files[Math.floor(Math.random() * files.length)];
                const filePath = path.join(promptsDir, randomFile);
                prompt = fs.readFileSync(filePath, 'utf8');
              }
            }
              
            core.setOutput('prompt', prompt);
            core.info(`prompt: ${prompt}`);

  generate-issue:
    needs:
      - select-prompt
    permissions:
      contents: write
      issues: write
      id-token: write
    uses: 'xn-intenton-z2a/agentic-lib/.github/workflows/wfr-generate-issue.yml@main'
    with:
      prompt: ${{ needs.select-prompt.outputs.prompt }}
      target: ${{ inputs.target || 'src/lib/main.js' }}
      testFile: ${{ inputs.testFile || 'tests/unit/main.test.js' }}
      readmeFile: 'README.md'
      missionFile: 'MISSION.md'
      contributingFile: 'CONTRIBUTING.md'
      dependenciesFile: 'package.json'
      buildScript: 'npm run build'
      testScript: 'npm test'
      mainScript: ${{ vars.MAIN_SCRIPT || 'npm run start' }}
      model: ${{ vars.CHATGPT_API_MODEL || 'o3-mini' }}
      npmAuthOrganisation: '@xn-intenton-z2a'
    secrets:
      CHATGPT_API_SECRET_KEY: ${{ secrets.CHATGPT_API_SECRET_KEY }}
      PERSONAL_ACCESS_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}

  create-issue:
    needs:
      - select-prompt
      - generate-issue
    permissions:
      issues: write
      id-token: write
    uses: 'xn-intenton-z2a/agentic-lib/.github/workflows/wfr-create-issue.yml@main'
    with:
      issueTitle: ${{ needs.generate-issue.outputs.issueTitle }}
      issueBody: ${{ needs.generate-issue.outputs.issueDescription }}
.github/workflows/wfr-create-pr.yml
==== Content of .github/workflows/wfr-create-pr.yml ====
# .github/workflows/wfr-create-pr.yml

#
# agentic-lib
# Copyright (C) 2025 Polycode Limited
#
# This file is part of agentic-lib.
#
# agentic-lib is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License v3.0 (GPL‑3).
# along with this program. If not, see <https://www.gnu.org/licenses/>.
#
# IMPORTANT: Any derived work must include the following attribution:
# "This work is derived from https://github.com/xn-intenton-z2a/agentic-lib"
#

name: ∞ create-pr

on:
  workflow_call:
    inputs:
      branch:
        description: 'The branch to create a PR from. e.g. "agentic-lib-issue-123"'
        type: string
        required: true
      baseBranch:
        description: 'The base branch to compare the PRs against. e.g. "main"'
        type: string
        required: false
        default: 'main'
      pulls:
        description: 'The maximum number of PRs to process. e.g. "100"'
        type: string
        required: false
        default: '100'
      gitCommitMessage:
        description: 'The commit message to use for the PR. e.g. "Ready for pull"'
        type: string
        required: false
        default: 'Ready for pull'
      label:
        description: 'The labels to apply to the PR. e.g. "automerge"'
        type: string
        required: false
        default: 'automerge'
      s3BucketUrl:
        description: 'The S3 bucket URL with prefix to use. e.g. "s3://my-bucket/prefix"'
        type: string
        required: false
        default: ''
      iamRoleArn:
        description: 'The ARN of the IAM role to assume. e.g. "arn:aws:iam::123456789012:role/my-role"'
        type: string
        required: false
        default: ''
    secrets:
      PERSONAL_ACCESS_TOKEN:
        required: false

jobs:
  create-pr:
    runs-on: ubuntu-latest

    env:
      branch: ${{ inputs.branch }}
      baseBranch: ${{ inputs.baseBranch || 'main' }}
      pulls: ${{ inputs.pulls || '100' }}
      gitCommitMessage: ${{ inputs.gitCommitMessage || 'Change complete ready for review' }}
      label: 'automerge'

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Create pull request, if fixed after re-checking linting
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PERSONAL_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}
          script: |
            const { data: existingPulls } = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              head: `${context.repo.owner}:${{ env.branch }}`,
              base: '${{ env.baseBranch }}',
              state: 'open',
            });
            if (existingPulls.length === 0) {
              const { data: pr } = await github.rest.pulls.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: '${{ env.gitCommitMessage }}',
                head: '${{ env.branch }}',
                base: '${{ env.baseBranch }}',
                body: '${{ env.gitCommitMessage }}',
                maintainer_can_modify: true,
              });
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: pr.number,
                labels: ['${{ env.label }}'],
              });
              core.info(`Pull request created: ${pr.html_url}`);
            
              // Initiate Check Suites
              const { data: checkSuites } = await github.rest.checks.listForRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: pr.head.sha,
              });
              if (checkSuites.check_suites && checkSuites.check_suites.length > 0) {
                for (const suite of checkSuites.check_suites) {
                  await github.rest.checks.rerequestSuite({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    check_suite_id: suite.id,
                  });
                  core.info(`Re-ran check suite ${suite.id} for commit ${pr.head.sha}`);
                }
              } else {
                core.info('No check suites found for the new commit.');
              }
            } else {
              core.info('Pull request already exists for this branch.');
            }

.github/workflows/wfr-create-issue.yml
==== Content of .github/workflows/wfr-create-issue.yml ====
# .github/workflows/wfr-create-issue.yml

#
# agentic-lib
# Copyright (C) 2025 Polycode Limited
#
# This file is part of agentic-lib.
#
# agentic-lib is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License v3.0 (GPL‑3).
# along with this program. If not, see <https://www.gnu.org/licenses/>.
#
# IMPORTANT: Any derived work must include the following attribution:
# "This work is derived from https://github.com/xn-intenton-z2a/agentic-lib"
#

name: ∞ create-issue

on:
  workflow_call:
    inputs:
      issueTitle:
        description: 'Text to drive the issue title (if "house choice", a random prompt will be selected).'
        required: false
        type: string
        default: 'house choice'
      issueBody:
        description: 'Text to drive the issue body.'
        required: false
        type: string
        default: 'Please resolve the issue.'
      houseChoiceOptions:
        description: 'Options for house choice, separated by double pipes "||".'
        type: string
        required: false
        default: 'Make code changes that extend or improve the features or resolve issues shown in the included context.'
      s3BucketUrl:
        description: 'The S3 bucket URL with prefix to use. e.g. "s3://my-bucket/prefix"'
        type: string
        required: false
        default: ''
      iamRoleArn:
        description: 'The ARN of the IAM role to assume. e.g. "arn:aws:iam::123456789012:role/my-role"'
        type: string
        required: false
        default: ''
    secrets:
      PERSONAL_ACCESS_TOKEN:
        required: false
    outputs:
      issueTitle:
        description: 'The issue title to resolve. e.g. "Make a small improvement."'
        value: ${{ jobs.create-issue.outputs.issueTitle }}
      issueNumber:
        description: 'The issue number to review. e.g. "123"'
        value: ${{ jobs.create-issue.outputs.issueNumber }}

jobs:
  create-issue:
    runs-on: ubuntu-latest

    env:
      issueTitle: ${{ inputs.issueTitle || 'house choice' }}
      issueBody: ${{ inputs.issueBody || 'Please resolve the issue.' }}
      houseChoiceOptions: ${{ inputs.houseChoiceOptions || 'Make code changes that extend or improve the features or resolve issues shown in the included context.'}}

    steps:
      - uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: create-issue
        id: create-issue
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PERSONAL_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}
          script: |
            const issueTitle = process.env.issueTitle;
            const issueBody = process.env.issueBody;
            const houseChoiceOptions = process.env.houseChoiceOptions.split('||');

            let selectedIssueTitle;
            if (issueTitle === 'house choice') {
              selectedIssueTitle = houseChoiceOptions[Math.floor(Math.random() * houseChoiceOptions.length)];
            } else {
              selectedIssueTitle = issueTitle;
            }

            const { data: issue } = await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: selectedIssueTitle,
              body: issueBody,
              labels: ['automated']
            });

            core.setOutput("issueTitle", selectedIssueTitle);
            core.setOutput("issueBody", issueBody);
            core.setOutput("issueNumber", issue.number);
            core.info(`issueTitle: ${selectedIssueTitle}`);
            core.info(`issueBody: ${issueBody}`);    
            core.info(`issueNumber: ${issue.number}`);

    outputs:
      issueTitle: ${{ steps.create-issue.outputs.issueTitle }}
      issueBody: ${{ steps.create-issue.outputs.issueBody }}
      issueNumber: ${{ steps.create-issue.outputs.issueNumber }}

.github/workflows/deploy.yml
==== Content of .github/workflows/deploy.yml ====
# .github/workflows/deploy.yml
#
# This file is part of the example suite for `agentic-lib` see: https://github.com/xn-intenton-z2a/agentic-lib
# This file is licensed under the MIT License. For details, see LICENSE-MIT

name: Deploy
run-name: 'Deploy to AWS [${{ github.ref_name }}] [${{ github.event.head_commit.message }}]'
concurrency: agentic-lib

on:
  #push:
  #  branches:
  #    # When publishing from a branch, add branch name here, e,g, 'beta'
  #    - main
  #  paths:
  #    - '**/*.sh'
  #    - '**/*.js'
  #    - '**/*.json'
  #    - '**/*.yml'
  #    - '**/*.properties'
  #    - '!intentions/**'
  #    - '!conversations/**'
  #    - '!exports/**'
  #    - '!programs/**'
  #    - '!results/**'
  workflow_dispatch:

jobs:

  npm-test-and-run-main:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: 'npm'

      - name: Set up ~/.npmrc
        run: |
          echo "@xn-intenton-z2a:registry=https://npm.pkg.github.com" >> ~/.npmrc
          echo "//npm.pkg.github.com/:_authToken=${{ secrets.PERSONAL_ACCESS_TOKEN }}" >> ~/.npmrc
          echo "always-auth=true" >> ~/.npmrc

      - run: npm ci

      - name: test
        id: test
        shell: bash
        run: 'npm test'

      - name: main
        id: main
        shell: bash
        run: timeout 5m ${{ vars.MAIN_SCRIPT || 'npm run start' }}

  mvn-package-cdk-synth:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: 'npm'

      - name: Set up ~/.npmrc
        run: |
          echo "@xn-intenton-z2a:registry=https://npm.pkg.github.com" >> ~/.npmrc
          echo "//npm.pkg.github.com/:_authToken=${{ secrets.PERSONAL_ACCESS_TOKEN }}" >> ~/.npmrc
          echo "always-auth=true" >> ~/.npmrc

      - run: npm ci

      - name: mvn
        if: steps.mvn.outputs.pomXmlExists == 'true'
        id: mvn
        shell: bash
        run: |
          if [ -f pom.xml ]; then
            pomXmlExists='true'
          else
            pomXmlExists='false'
          fi
          echo "pomXmlExists=${pomXmlExists?}" | tee -a "${GITHUB_OUTPUT?}"

      - uses: actions/setup-java@v4
        if: steps.mvn.outputs.pomXmlExists == 'true'
        with:
          distribution: 'corretto'
          java-version: 21
          cache: 'maven'
          server-password: PERSONAL_ACCESS_TOKEN
        env:
          GITHUB_ACTOR: ${{ github.actor }}
          PERSONAL_ACCESS_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}

      - name: package
        id: package
        if: steps.mvn.outputs.pomXmlExists == 'true'
        shell: bash
        run: ./mvnw clean package
        env:
          GITHUB_ACTOR: ${{ github.actor }}
          PERSONAL_ACCESS_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}

      - name: synth
        id: synth
        if: steps.mvn.outputs.pomXmlExists == 'true'
        shell: bash
        run: npx cdk synth --strict --validation --no-staging
        env:
          GITHUB_ACTOR: ${{ github.actor }}
          PERSONAL_ACCESS_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}

  deploy:
    needs:
      - npm-test-and-run-main
      - mvn-package-cdk-synth
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.ref }}

      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: 'npm'

      - name: Set up ~/.npmrc
        run: |
          echo "@xn-intenton-z2a:registry=https://npm.pkg.github.com" >> ~/.npmrc
          echo "//npm.pkg.github.com/:_authToken=${{ secrets.PERSONAL_ACCESS_TOKEN }}" >> ~/.npmrc
          echo "always-auth=true" >> ~/.npmrc

      - run: npm ci

      - name: test
        id: test
        shell: bash
        run: npm test

      - name: mvn
        id: mvn
        shell: bash
        run: |
          if [ -f pom.xml ]; then
            pomXmlExists='true'
          else
            pomXmlExists='false'
          fi
          echo "pomXmlExists=${pomXmlExists?}" | tee -a "${GITHUB_OUTPUT?}"

      #- run: npm install -g aws-cdk

      - name: Configure AWS Credentials
        if: steps.mvn.outputs.pomXmlExists == 'true'
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::541134664601:role/agentic-lib-github-actions-role
          role-chaining: false
          aws-region: eu-west-2
          audience: sts.amazonaws.com
          role-skip-session-tagging: true
          output-credentials: true
          retry-max-attempts: 3

      - run: aws sts get-caller-identity --region eu-west-2
        if: steps.mvn.outputs.pomXmlExists == 'true'

      - name: Configure AWS Credentials
        if: steps.mvn.outputs.pomXmlExists == 'true'
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::541134664601:role/agentic-lib-deployment-role
          role-chaining: true
          aws-region: eu-west-2
          audience: sts.amazonaws.com
          role-skip-session-tagging: true
          output-credentials: true
          retry-max-attempts: 3

      - run: aws s3 ls --region eu-west-2
        if: steps.mvn.outputs.pomXmlExists == 'true'

      - uses: actions/setup-java@v4
        if: steps.mvn.outputs.pomXmlExists == 'true'
        with:
          distribution: 'corretto'
          java-version: 21
          cache: 'maven'
          server-password: PERSONAL_ACCESS_TOKEN
        env:
          GITHUB_ACTOR: ${{ github.actor }}
          PERSONAL_ACCESS_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}

      - name: package
        id: package
        if: steps.mvn.outputs.pomXmlExists == 'true'
        shell: bash
        run: ./mvnw clean package
        env:
          GITHUB_ACTOR: ${{ github.actor }}
          PERSONAL_ACCESS_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}

      - name: stacks
        id: stacks
        if: steps.mvn.outputs.pomXmlExists == 'true'
        shell: bash
        run: |
          synth=$(jq -r '.deployStacks' cdk.json)
          deploy=$(jq -r '.deployStacks' cdk.json)
          echo "deploy=${deploy?}" | tee -a "${GITHUB_OUTPUT?}"
          echo "synth=${synth?}" | tee -a "${GITHUB_OUTPUT?}"

      - name: synth
        id: synth
        if: steps.mvn.outputs.pomXmlExists == 'true'
        shell: bash
        run: ${{ steps.stacks.outputs.synth }}
        env:
          GITHUB_ACTOR: ${{ github.actor }}
          PERSONAL_ACCESS_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}

      - name: deploy
        id: deploy
        if: steps.mvn.outputs.pomXmlExists == 'true'
        shell: bash
        run: ${{ steps.stacks.outputs.deploy }}
        env:
          GITHUB_ACTOR: ${{ github.actor }}
          PERSONAL_ACCESS_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}
.github/workflows/wfr-delete-caches.yml
==== Content of .github/workflows/wfr-delete-caches.yml ====
# .github/workflows/wfr-delete-caches.yml

#
# agentic-lib
# Copyright (C) 2025 Polycode Limited
#
# This file is part of agentic-lib.
#
# agentic-lib is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License v3.0 (GPL‑3).
# along with this program. If not, see <https://www.gnu.org/licenses/>.
#
# IMPORTANT: Any derived work must include the following attribution:
# "This work is derived from https://github.com/xn-intenton-z2a/agentic-lib"
#

name: ∞ delete-caches

on:
  workflow_call:
    inputs:
      deleteAllCaches:
        description: 'Whether to delete all caches. e.g. "true"'
        type: string
        required: false
        default: 'false'
      s3BucketUrl:
        description: 'The S3 bucket URL with prefix to use. e.g. "s3://my-bucket/prefix"'
        type: string
        required: false
        default: ''
      iamRoleArn:
        description: 'The ARN of the IAM role to assume. e.g. "arn:aws:iam::123456789012:role/my-role"'
        type: string
        required: false
        default: ''
    secrets:
      PERSONAL_ACCESS_TOKEN:
        required: false

jobs:
  update:
    runs-on: ubuntu-latest

    env:
      deleteAllCaches: ${{ inputs.deleteAllCaches || 'false' }}

    steps:
      - name: Delete all GitHub Actions caches by iterating through each one to delete it
        if: ${{ env.deleteAllCaches }}
        run: |
          echo "Listing all caches in the repository for ${{ github.repository }}"
          # 1) List all caches in JSON
          result=$(curl -s \
            -H "Authorization: token ${{ secrets.PERSONAL_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}" \
            -H "Accept: application/vnd.github+json" \
            "https://api.github.com/repos/${{ github.repository }}/actions/caches")
          
          # Print the JSON for debugging
          echo "$result" | jq .
          
          # 2) Determine how many total_count
          total=$(echo "$result" | jq -r '.total_count')
          echo "Found $total caches in total."
          
          # 3) For each item in actions_caches array, extract .key and .ref,
          #    then call DELETE with "?key=...&ref=..."
          echo "$result" | jq -c '.actions_caches[]' | while read -r row; do
            key=$(echo "$row" | jq -r '.key')
            ref=$(echo "$row" | jq -r '.ref')
          
            echo "Deleting cache with key='$key' ref='$ref' ..."
            curl -s -X DELETE \
              -H "Authorization: token ${{ secrets.PERSONAL_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}" \
              -H "Accept: application/vnd.github+json" \
              "https://api.github.com/repos/${{ github.repository }}/actions/caches?key=$key&ref=$ref"
          done
          
          echo "Cache deletion iteration complete."

.github/workflows/issue-worker.yml
==== Content of .github/workflows/issue-worker.yml ====
# .github/workflows/issue-worker.yml
#
# This file is part of the example suite for `agentic-lib` see: https://github.com/xn-intenton-z2a/agentic-lib
# This file is licensed under the MIT License. For details, see LICENSE-MIT

name: Issue Worker
concurrency: agentic-lib
run-name: "Issue Worker [${{ github.ref_name }}]"

on:
  workflow_dispatch:
    inputs:
      issueNumber:
        description: 'The issue number to resolve. If not provided, the workflow will select one based on label. e.g. "123"'
        required: false
        type: string
        default: ''
      target:
        description: 'The source file whose content is used in the resolution prompt. e.g. "src/lib/main.js"'
        required: false
        type: string
        default: 'src/lib/main.js'
      testFile:
        description: 'The test file to run to validate the resolution. e.g. "tests/unit/main.test.js"'
        required: false
        type: string
        default: 'tests/unit/main.test.js'
      selectionLabel:
        description: 'Label used to filter issues for resolution. e.g. "automated"'
        required: false
        type: string
        default: 'automated'
  workflow_run:
    workflows:
      - "Create Issue"
      - "Linting"
    types:
      - completed
  schedule:
    - cron: '15 */4 * * *' # schedule-1
    #- cron: '*/30 * * * *' # schedule-2
    #- cron: '*/10 * * * *' # schedule-3

jobs:

  select-issue:
    permissions:
      issues: read
      id-token: write
    uses: 'xn-intenton-z2a/agentic-lib/.github/workflows/wfr-select-issue.yml@main'
    with:
      issueNumber: ${{ inputs.issueNumber || '' }}
      selectionLabel: ${{ inputs.selectionLabel || 'automated' }}
    secrets:
      CHATGPT_API_SECRET_KEY: ${{ secrets.CHATGPT_API_SECRET_KEY }}

  needs-resolution:
    runs-on: ubuntu-latest
    steps:
      - name: todo
        shell: bash
        run: |
          echo "TODO: Check if this issue has been resolved already by examining the current state and recent commits"

  npm-test:
    name: 'npm test with coverage'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ github.ref }}
          fetch-depth: 0
      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: 'npm'
      - name: Set up .npmrc
        shell: bash
        run: |
          echo "${{ env.npmAuthOrganisation }}:registry=https://npm.pkg.github.com" >> .npmrc
          echo "//npm.pkg.github.com/:_authToken=${{ secrets.PERSONAL_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}" >> .npmrc
          echo "always-auth=true" >> .npmrc
        env:
          npmAuthOrganisation: '@xn-intenton-z2a'
      - run: npm ci
      - run: npm run test:unit

  npm-build:
    name: 'npm run build'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ github.ref }}
          fetch-depth: 0
      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: 'npm'
      - name: Set up .npmrc
        shell: bash
        run: |
          echo "${{ env.npmAuthOrganisation }}:registry=https://npm.pkg.github.com" >> .npmrc
          echo "//npm.pkg.github.com/:_authToken=${{ secrets.PERSONAL_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}" >> .npmrc
          echo "always-auth=true" >> .npmrc
        env:
          npmAuthOrganisation: '@xn-intenton-z2a'
      - run: npm ci
      - run: npm run build

  npm-run:
    name: 'npm run start'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ github.ref }}
          fetch-depth: 0
      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: 'npm'
      - name: Set up .npmrc
        shell: bash
        run: |
          echo "${{ env.npmAuthOrganisation }}:registry=https://npm.pkg.github.com" >> .npmrc
          echo "//npm.pkg.github.com/:_authToken=${{ secrets.PERSONAL_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}" >> .npmrc
          echo "always-auth=true" >> .npmrc
        env:
          npmAuthOrganisation: '@xn-intenton-z2a'
      - run: npm ci
      - run: ${{ vars.MAIN_SCRIPT || 'npm run start' }}

  check-branch:
    needs:
      - select-issue
      - npm-test
      - npm-build
      - npm-run
      - needs-resolution
    if: ${{ needs.select-issue.outputs.issueNumber != '' }}
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write
    env:
      branchPrefix: 'agentic-lib-'
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.ref }}
      - name: Ensure there isn't already a branch for this prefix
        shell: bash
        run: |
          git fetch origin
          if git branch -r | grep -q 'origin/${{ env.branchPrefix }}'; then
            echo "A branch with the prefix '${{ env.branchPrefix }}' already exists."
            exit 1
          else
            echo "No existing branch with the prefix found."
          fi

  apply-issue-resolution:
    needs:
      - select-issue
      - needs-resolution
      - npm-test
      - npm-build
      - npm-run
      - check-branch
    if: ${{ needs.select-issue.outputs.issueNumber != '' }}
    permissions:
      contents: write
      issues: write
      id-token: write
    uses: 'xn-intenton-z2a/agentic-lib/.github/workflows/wfr-apply-issue-resolution.yml@main'
    with:
      issueNumber: ${{ needs.select-issue.outputs.issueNumber }}
      target: ${{ inputs.target || 'src/lib/main.js' }}
      testFile: ${{ inputs.testFile || 'tests/unit/main.test.js' }}
      readmeFile: 'README.md'
      missionFile: 'MISSION.md'
      contributingFile: 'CONTRIBUTING.md'
      dependenciesFile: 'package.json'
      formattingFile: '.prettierrc'
      lintingFile: 'eslint.config.js'
      branchPrefix: 'agentic-lib-issue-'
      buildScript: 'npm run build'
      testScript: 'npm test'
      mainScript: ${{ vars.MAIN_SCRIPT || 'npm run start' }}
      model: ${{ vars.CHATGPT_API_MODEL || 'o3-mini' }}
      npmAuthOrganisation: '@xn-intenton-z2a'
      gitUserEmail: 'action@github.com'
      gitUserName: 'GitHub Actions[bot]'
    secrets:
      CHATGPT_API_SECRET_KEY: ${{ secrets.CHATGPT_API_SECRET_KEY }}
      PERSONAL_ACCESS_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}

  npm-test-after-issue-resolution:
    needs:
      - needs-resolution
      - npm-test
      - npm-build
      - npm-run
      - apply-issue-resolution
    name: 'npm test with coverage'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ needs.apply-issue-resolution.outputs.branch }}
          fetch-depth: 0
      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: "npm"
      - name: Get latest from remote
        run: |
          git config --local user.email "${{ env.gitUserEmail }}"
          git config --local user.name "${{ env.gitUserName }}"
          git pull --ff-only origin ${{ needs.apply-issue-resolution.outputs.branch }}
      - name: Set up .npmrc
        shell: bash
        run: |
          echo "${{ env.npmAuthOrganisation }}:registry=https://npm.pkg.github.com" >> .npmrc
          echo "//npm.pkg.github.com/:_authToken=${{ secrets.PERSONAL_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}" >> .npmrc
          echo "always-auth=true" >> .npmrc
        env:
          npmAuthOrganisation: '@xn-intenton-z2a'
      - run: npm ci
      - run: npm run test:unit

  npm-build-after-issue-resolution:
    needs:
      - needs-resolution
      - npm-test
      - npm-build
      - npm-run
      - apply-issue-resolution
    name: 'npm run build'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ needs.apply-issue-resolution.outputs.branch }}
          fetch-depth: 0
      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: "npm"
      - name: Get latest from remote
        run: |
          git config --local user.email "${{ env.gitUserEmail }}"
          git config --local user.name "${{ env.gitUserName }}"
          git pull --ff-only origin ${{ needs.apply-issue-resolution.outputs.branch }}
      - name: Set up .npmrc
        shell: bash
        run: |
          echo "${{ env.npmAuthOrganisation }}:registry=https://npm.pkg.github.com" >> .npmrc
          echo "//npm.pkg.github.com/:_authToken=${{ secrets.PERSONAL_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}" >> .npmrc
          echo "always-auth=true" >> .npmrc
        env:
          npmAuthOrganisation: '@xn-intenton-z2a'
      - run: npm ci
      - run: npm run build

  npm-run-after-issue-resolution:
    needs:
      - needs-resolution
      - npm-test
      - npm-build
      - npm-run
      - apply-issue-resolution
    name: 'npm run start'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ needs.apply-issue-resolution.outputs.branch }}
          fetch-depth: 0
      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: "npm"
      - name: Get latest from remote
        run: |
          git config --local user.email "${{ env.gitUserEmail }}"
          git config --local user.name "${{ env.gitUserName }}"
          git pull --ff-only origin ${{ needs.apply-issue-resolution.outputs.branch }}
      - name: Set up .npmrc
        shell: bash
        run: |
          echo "${{ env.npmAuthOrganisation }}:registry=https://npm.pkg.github.com" >> .npmrc
          echo "//npm.pkg.github.com/:_authToken=${{ secrets.PERSONAL_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}" >> .npmrc
          echo "always-auth=true" >> .npmrc
        env:
          npmAuthOrganisation: '@xn-intenton-z2a'
      - run: npm ci
      - run: ${{ vars.MAIN_SCRIPT || 'npm run start' }}

  needs-fix-after-issue-resolution:
    needs:
      - needs-resolution
      - npm-test
      - npm-build
      - npm-run
      - apply-issue-resolution
      - npm-test-after-issue-resolution
      - npm-build-after-issue-resolution
      - npm-run-after-issue-resolution
    if: >
      ${{ always() &&
         (
           needs.npm-test-after-issue-resolution.result != 'success' ||
           needs.npm-build-after-issue-resolution.result != 'success' ||
           needs.npm-run-after-issue-resolution.result != 'success'
         )
      }}
    runs-on: ubuntu-latest
    steps:
      - name: set-needs-fix
        id: set-needs-fix
        uses: actions/github-script@v7
        with:
          script: |
            const anySkipped = "${{ needs.npm-test-after-issue-resolution.result == 'skipped' || needs.npm-build-after-issue-resolution.result == 'skipped' || needs.npm-run-after-issue-resolution.result == 'skipped' }}" === "true";
            const anyDidntSucceed = "${{ needs.npm-test-after-issue-resolution.result != 'success' || needs.npm-build-after-issue-resolution.result != 'success' || needs.npm-run-after-issue-resolution.result != 'success' }}" === "true";
            const readyToMerge = !anySkipped && !anyDidntSucceed;
            
            core.setOutput("anySkipped", anySkipped);
            core.setOutput("anyDidntSucceed", anyDidntSucceed);
            core.setOutput("readyToMerge", readyToMerge);     
            
            core.info(`Any skipped: ${anySkipped}`);
            core.info(`Any didn't succeed: ${anyDidntSucceed}`);
            core.info(`Ready to merge: ${readyToMerge}`);

    outputs:
      allSkipped: ${{ steps.set-needs-fix.outputs.allSkipped }}
      anyDidntSucceed: ${{ steps.set-needs-fix.outputs.anyDidntSucceed }}
      readyToMerge: ${{ steps.set-needs-fix.outputs.readyToMerge }}

  create-pr:
    needs:
      - select-issue
      - needs-resolution
      - apply-issue-resolution
      - needs-fix-after-issue-resolution
    if: ${{ needs.select-issue.outputs.issueNumber != '' && needs.apply-issue-resolution.outputs.fixApplied == 'true' && needs.needs-fix-after-issue-resolution.outputs.readyToMerge == 'true' }}
    permissions:
      contents: write
      packages: write
      issues: write
      pull-requests: write
      checks: write
      id-token: write
    uses: 'xn-intenton-z2a/agentic-lib/.github/workflows/wfr-create-pr.yml@main'
    with:
      branch: '${{ needs.apply-issue-resolution.outputs.branch }}'
      baseBranch: 'main'
      gitCommitMessage: "${{ needs.apply-issue-resolution.outputs.message }} (fixes #${{ needs.select-issue.outputs.issueNumber }})"
      label: 'automerge'
.github/workflows/wfr-publish-npm.yml
==== Content of .github/workflows/wfr-publish-npm.yml ====
# .github/workflows/wfr-publish-npm.yml

#
# agentic-lib
# Copyright (C) 2025 Polycode Limited
#
# This file is part of agentic-lib.
#
# agentic-lib is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License v3.0 (GPL‑3).
# along with this program. If not, see <https://www.gnu.org/licenses/>.
#
# IMPORTANT: Any derived work must include the following attribution:
# "This work is derived from https://github.com/xn-intenton-z2a/agentic-lib"
#

name: ∞ publish-npm

on:
  workflow_call:
    inputs:
      versionIncrement:
        description: 'The Semantic Versioning segment to increment. One of: major | minor | patch | premajor | preminor | prepatch | prerelease.'
        required: true
        type: string
        default: 'prerelease'
      githubRelease:
        description: 'Whether to create a GitHub release. e.g. true'
        type: boolean
        required: false
        default: true
      buildScript:
        description: 'The script must be runnable as: `npm ci ; <script>` and succeed with a zero exit code. e.g. `npm run build`'
        type: string
        required: false
        default: 'echo "No build script specified."'
      releaseNotes:
        description: 'The release notes to use for the GitHub release. e.g. "Feature release."'
        type: string
        required: false
        default: 'Feature release.'
      npmAuthOrganisation:
        description: 'The GitHub organisation to authenticate with for npm. e.g. "xn-intenton-z2a"'
        type: string
        required: false
        default: ''
      gitUserEmail:
        description: 'The email to use for git commits. e.g. "action@github.com"'
        type: string
        required: false
        default: 'action@github.com'
      gitUserName:
        description: 'The name to use for git commits. e.g. "GitHub Actions[bot]"'
        type: string
        required: false
        default: 'GitHub Actions[bot]'
    secrets:
      PERSONAL_ACCESS_TOKEN:
        required: false
    outputs:
      releasedVersion:
        description: 'The version that was released. e.g. "1.0.1"'
        value: ${{ jobs.publish.outputs.releasedVersion }}
      newVersion:
        description: 'The version that was bumped to. e.g. "1.0.2-0"'
        value: ${{ jobs.publish.outputs.newVersion }}

jobs:
  publish:
    runs-on: ubuntu-latest

    env:
      versionIncrement: ${{ inputs.versionIncrement || 'prerelease' }}
      buildScript: ${{ inputs.buildScript || 'npm run build' }}
      releaseNotes: ${{ inputs.releaseNotes || 'Feature release.' }}
      npmAuthOrganisation: ${{ inputs.npmAuthOrganisation || '' }}
      gitUserEmail: ${{ inputs.gitUserEmail || 'action@github.com' }}
      gitUserName: ${{ inputs.gitUserName || 'GitHub Actions[bot]' }}
      gitCommitMessage: |
        ${{ inputs.gitCommitMessage || 'chore: dependency updates' }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Check GitHub authentication
        if: ${{ env.npmAuthOrganisation != '' }}
        shell: bash
        run: |
          curl --include --header "Authorization: token ${{ secrets.PERSONAL_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}" https://api.github.com/user

      - name: Set up .npmrc
        if: ${{ env.npmAuthOrganisation != '' }}
        shell: bash
        run: |
          echo "${{ env.npmAuthOrganisation }}:registry=https://npm.pkg.github.com" >> .npmrc
          echo "//npm.pkg.github.com/:_authToken=${{ secrets.PERSONAL_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}" >> .npmrc
          echo "always-auth=true" >> .npmrc

      - name: Install dependencies
        run: npm ci

      - name: Set up .npmrc with only the GitHub token
        if: ${{ env.npmAuthOrganisation != '' }}
        shell: bash
        run: |
          echo "${{ env.npmAuthOrganisation }}:registry=https://npm.pkg.github.com" >> .npmrc
          echo "//npm.pkg.github.com/:_authToken=${{ secrets.GITHUB_TOKEN }}" >> .npmrc
          echo "always-auth=true" >> .npmrc

      - name: Build project before publishing begins
        id: build
        shell: bash
        run: ${{ env.buildScript }}

      - name: Examine the git working copy (should have no changes)
        shell: bash
        run: |
          git config --local user.email '${{ env.gitUserEmail }}'
          git config --local user.name '${{ env.gitUserName }}'
          git status -v

      - name: Get latest from remote
        run: |
          git config --local user.email "${{ env.gitUserEmail }}"
          git config --local user.name "${{ env.gitUserName }}"
          git pull --ff-only origin ${{ github.ref }}

      - name: released
        id: released
        if: ${{ env.versionIncrement == 'major' || env.versionIncrement == 'minor' || env.versionIncrement == 'patch' }}
        shell: bash
        run: |
          unset PERSONAL_ACCESS_TOKEN
          npm version ${{ env.versionIncrement }}
          ${{ env.buildScript }}
          npm publish --tag latest --access restricted
          git push --follow-tags
          releasedVersion=$(node -p "require('./package.json').version")
          echo "releasedVersion=${releasedVersion}" >> $GITHUB_OUTPUT
          echo "releasedVersion=${releasedVersion}"
        #env:
        #  PERSONAL_ACCESS_TOKEN: ""

      - name: Create GitHub Release
        if: ${{ inputs.githubRelease == 'true' || env.versionIncrement == 'major' || env.versionIncrement == 'minor' || env.versionIncrement == 'patch' }}
        uses: ncipollo/release-action@v1
        with:
          tag: ${{ steps.released.outputs.releasedVersion }}
          name: Release ${{ steps.released.outputs.releasedVersion }}
          body: ${{ env.releaseNotes }}

      - name: Rotate to next prepatch version from a released version
        if: ${{ env.versionIncrement == 'major' || env.versionIncrement == 'minor' || env.versionIncrement == 'patch' }}
        shell: bash
        run: |
          npm version --no-git-tag-version prepatch

      - name: Rotate to next [premajor|preminor|prepatch|prerelease] version
        if: ${{ env.versionIncrement == 'premajor' || env.versionIncrement == 'preminor' || env.versionIncrement == 'prepatch' || env.versionIncrement == 'prerelease' }}
        shell: bash
        run: |
          npm version --no-git-tag-version ${{ env.versionIncrement }}

      - name: rotated
        id: rotated
        shell: bash
        run: |
          newVersion=$(node -p "require('./package.json').version")
          echo "newVersion=${newVersion}" >> $GITHUB_OUTPUT
          echo "newVersion=${newVersion}"

      - name: Examine the git working copy
        shell: bash
        run: |
          git config --local user.email '${{ env.gitUserEmail }}'
          git config --local user.name '${{ env.gitUserName }}'
          git status -v

      - name: Run build after version bump
        run: ${{ env.buildScript }}

      - name: Examine the git working copy
        shell: bash
        run: |
          git config --local user.email '${{ env.gitUserEmail }}'
          git config --local user.name '${{ env.gitUserName }}'
          git status -v

      - name: Push version commit
        id: push
        shell: bash
        run: |
          git config --local user.email "${{ env.gitUserEmail }}"
          git config --local user.name "${{ env.gitUserName }}"
          git add -v --all
          newVersion=$(node -p "require('./package.json').version")
          git commit -m "${newVersion?}"
          git push origin HEAD

      - name: Tear down .npmrc
        if: ${{ env.npmAuthOrganisation != '' }}
        shell: bash
        run: rm -f .npmrc

      - name: Upload package.json artifact
        uses: actions/upload-artifact@v4
        with:
          name: package-json
          path: "./package.json"

      - name: Log final version
        shell: bash
        run: |
          echo "Final version: ${{ steps.rotated.outputs.newVersion }}"

    outputs:
      releasedVersion: ${{ steps.released.outputs.releasedVersion }}
      newVersion: ${{ steps.rotated.outputs.newVersion }}
.github/workflows/automerge.yml
==== Content of .github/workflows/automerge.yml ====
# .github/workflows/automerge.yml
#
# This file is part of the example suite for `agentic-lib` see: https://github.com/xn-intenton-z2a/agentic-lib
# This file is licensed under the MIT License. For details, see LICENSE-MIT

name: Automerge
concurrency: agentic-lib
run-name: "Automerge [${{ github.ref_name }}]"

on:
  pull_request:
  check_suite:
  workflow_dispatch:
  workflow_run:
    workflows:
      - "Issue Worker"
      - "Update"
    types:
      - completed
  schedule:
    - cron: '30 */4 * * *' # schedule-1
    #- cron: '*/30 * * * *' # schedule-2
    #- cron: '*/10 * * * *' # schedule-3

env:
  pullRequestLabel: 'automerge'

jobs:
  label:
    runs-on: ubuntu-latest
    steps:
      - name: echo
        shell: bash
        run: |
          echo "Label: ${{ env.pullRequestLabel }}"
    outputs:
      pullRequestLabel: ${{ env.pullRequestLabel }}

  echo-event:
    runs-on: ubuntu-latest
    steps:
      - run: |
          echo 'Triggered by: ${{ github.event_name }}'

  pull-request-event:
    if: github.event_name == 'pull_request'
    runs-on: ubuntu-latest
    steps:
      - run: |
          echo "Triggered by: pull_request"

  check-suite-event:
    if: github.event_name == 'check_suite'
    runs-on: ubuntu-latest
    steps:
      - run: |
          echo "Triggered by: check_suite"

  schedule-event:
    if: github.event_name == 'schedule'
    runs-on: ubuntu-latest
    steps:
      - run: |
          echo "Triggered by: schedule"

  workflow-dispatch-event:
    if: github.event_name == 'workflow_dispatch'
    runs-on: ubuntu-latest
    steps:
      - run: |
          echo "Triggered by: workflow_dispatch"

  workflow-run-event:
    if: github.event_name == 'workflow_run'
    runs-on: ubuntu-latest
    steps:
      - run: |
          echo "Triggered by: workflow_run"

  pr:
    needs: label
    if: github.event_name == 'pull_request' && contains(github.event.pull_request.labels.*.name, needs.label.outputs.pullRequestLabel )
    uses: 'xn-intenton-z2a/agentic-lib/.github/workflows/wfr-automerge-find-pr-from-pull-request.yml@main'

  cs:
    if: github.event_name == 'check_suite' && github.event.check_suite.conclusion == 'success'
    uses: 'xn-intenton-z2a/agentic-lib/.github/workflows/wfr-automerge-find-pr-in-check-suite.yml@main'

  ls:
    needs: label
    if: github.event_name == 'schedule' || github.event_name == 'workflow_dispatch' || github.event_name == 'workflow_run'
    runs-on: ubuntu-latest
    steps:
      - name: Determine pull request number
        id: get-pull
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            let pullRequest;
            let pullNumber;
            const { data: pullRequests } = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              per_page: 1,
              sort: 'created',
              direction: 'asc'
            });
            if (pullRequests.length > 0) {
              const filteredPRs = pullRequests.filter(pr => pr.labels.some(label => label.name === '${{ needs.label.outputs.pullRequestLabel }}' ));
              if (filteredPRs.length > 0) {
                pullRequest = filteredPRs[0];
                core.info(`Found open pull request with label ${{ needs.label.outputs.pullRequestLabel }}: #${pullRequest.number}.`);
                core.info(JSON.stringify(pullRequest));
              } else {
                core.info(`No open pull request found with label ${{ needs.label.outputs.pullRequestLabel }}.`);
                pullRequest = null;
              }
            } else {
              pullRequest = null;
              core.info('No open pull requests found.');
            }
            if (pullRequests.length > 0) {
              pullNumber = pullRequests[0].number;
            } else {
              pullNumber = '';
              core.info('No open pull requests found.');
            }
            core.info(`pullNumber: ${pullNumber}`);
            core.setOutput('pullNumber', pullNumber);
          result-encoding: string
    outputs:
      pullNumber: ${{ steps.get-pull.outputs.pullNumber }}

  merge-check:
    if: ${{ always() }}
    needs:
      - pr
      - cs
      - ls
    runs-on: ubuntu-latest
    steps:
      - name: set-outputs
        id: set-outputs
        uses: actions/github-script@v7
        with:
          script: |
            // Merge outputs from pr-check, cs-check, and determine-ls.
            // Only one of pr-check or cs-check should have run.
            let prMerged = '${{ needs.pr.outputs.prMerged || needs.cs.outputs.prMerged || 'false' }}';
            let pullNumber = '${{ needs.pr.outputs.pullNumber || needs.cs.outputs.pullNumber || needs.ls.outputs.pullNumber }}';
            let shouldSkipMerge = '${{ needs.pr.outputs.shouldSkipMerge || needs.cs.outputs.shouldSkipMerge || 'false' }}';
            core.setOutput('prMerged', `${prMerged}`);
            core.setOutput('pullNumber', `${pullNumber}`);
            core.setOutput('shouldSkipMerge', `${shouldSkipMerge}`);
            core.info(`prMerged: '${prMerged}'`);
            core.info(`pullNumber: '${pullNumber}'`);
            core.info(`shouldSkipMerge: '${shouldSkipMerge}'`);
          result-encoding: string
    outputs:
      prMerged: ${{ steps.set-outputs.outputs.prMerged }}
      pullNumber: ${{ steps.set-outputs.outputs.pullNumber }}
      shouldSkipMerge: ${{ steps.set-outputs.outputs.shouldSkipMerge }}

  label-issue-after-check-pr:
    needs:
      - merge-check
    if: needs.merge-check.outputs.prMerged == 'true' && needs.merge-check.outputs.pullNumber != ''
    permissions:
      contents: write
      pull-requests: read
      issues: write
    uses: 'xn-intenton-z2a/agentic-lib/.github/workflows/wfr-automerge-label-issue.yml@main'
    with:
      pullNumber: '${{ needs.merge-check.outputs.pullNumber }}'
      branchPrefix: 'agentic-lib-issue-'

  automerge:
    needs:
      - merge-check
    if: always() && needs.merge-check.outputs.shouldSkipMerge != 'true' && needs.merge-check.outputs.pullNumber != ''
    permissions:
      contents: write
      pull-requests: write
    uses: 'xn-intenton-z2a/agentic-lib/.github/workflows/wfr-automerge-merge-pr.yml@main'
    with:
      pullNumber: '${{ needs.merge-check.outputs.pullNumber }}'

  label-issue-after-automerge:
    needs:
      - merge-check
      - automerge
    if: always() && ( needs.automerge.outputs.prMerged == 'true' && needs.merge-check.outputs.pullNumber != '' )
    permissions:
      contents: write
      issues: write
      pull-requests: read
    uses: 'xn-intenton-z2a/agentic-lib/.github/workflows/wfr-automerge-label-issue.yml@main'
    with:
      pullNumber: ${{ needs.automerge.outputs.prMerged == 'true' && needs.merge-check.outputs.pullNumber || '' }}
      branchPrefix: 'agentic-lib-issue-'
.github/workflows/wfr-publish-mvn.yml
==== Content of .github/workflows/wfr-publish-mvn.yml ====
# .github/workflows/wfr-publish-mvn.yml

#
# agentic-lib
# Copyright (C) 2025 Polycode Limited
#
# This file is part of agentic-lib.
#
# agentic-lib is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License v3.0 (GPL‑3).
# along with this program. If not, see <https://www.gnu.org/licenses/>.
#
# IMPORTANT: Any derived work must include the following attribution:
# "This work is derived from https://github.com/xn-intenton-z2a/agentic-lib"
#

name: ∞ publish-mvn

on:
  workflow_call:
    inputs:
      versionIncrement:
        description: 'The version increment segment for Maven release. Expected values: major | minor | patch | premajor | preminor | prepatch | prerelease.'
        required: true
        type: string
        default: 'prerelease'
      releaseVersionOverride:
        description: 'The version number to set instead of following the current version. e.g. "0.0.1"'
        required: false
        type: string
        default: ''
      newVersionOverride:
        description: 'The version number to set instead of following the version increment. e.g. "0.0.2"'
        required: false
        type: string
        default: ''
      githubRelease:
        description: 'Whether to create a GitHub release. e.g. true'
        type: boolean
        required: false
        default: true
      mavenBuildScript:
        description: 'The Maven build command, e.g. "./mvnw clean install".'
        type: string
        required: false
        default: './mvnw clean install'
      mavenDeployScript:
        description: 'The Maven deploy command, e.g. "./mvnw deploy -P release".'
        type: string
        required: false
        default: './mvnw deploy -P release'
      releaseNotes:
        description: 'The release notes for the GitHub release.'
        type: string
        required: false
        default: 'Feature release.'
      gitUserEmail:
        description: 'The email to use for git commits.'
        type: string
        required: false
        default: 'action@github.com'
      gitUserName:
        description: 'The name to use for git commits.'
        type: string
        required: false
        default: 'GitHub Actions[bot]'
      gitCommitMessage:
        description: 'The commit message for version bump commits.'
        type: string
        required: false
        default: 'chore: version bump'
    secrets:
      PERSONAL_ACCESS_TOKEN:
        required: false
    outputs:
      releasedVersion:
        description: 'The version that was released. e.g. "1.0.1"'
        value: ${{ jobs.publish.outputs.releasedVersion }}
      newVersion:
        description: 'The new version after bumping, e.g. "1.0.2-SNAPSHOT"'
        value: ${{ jobs.publish.outputs.newVersion }}

jobs:
  publish:
    runs-on: ubuntu-latest

    env:
      versionIncrement: ${{ inputs.versionIncrement }}
      releaseVersionOverride: ${{ inputs.releaseVersionOverride }}
      newVersionOverride: ${{ inputs.newVersionOverride }}
      mavenBuildScript: ${{ inputs.mavenBuildScript }}
      mavenDeployScript: ${{ inputs.mavenDeployScript }}
      releaseNotes: ${{ inputs.releaseNotes }}
      gitUserEmail: ${{ inputs.gitUserEmail }}
      gitUserName: ${{ inputs.gitUserName }}
      gitCommitMessage: ${{ inputs.gitCommitMessage }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Java
        uses: actions/setup-java@v4
        with:
          distribution: 'corretto'
          java-version: 21
          cache: 'maven'
          server-password: PERSONAL_ACCESS_TOKEN
        env:
          GITHUB_ACTOR: ${{ github.actor }}
          PERSONAL_ACCESS_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}

      - run: cat ~/.m2/settings.xml

      - name: Validate settings.xml
        shell: bash
        run: mvn help:effective-settings
        env:
          GITHUB_ACTOR: ${{ github.actor }}
          PERSONAL_ACCESS_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}

      - name: Build project before publishing begins
        id: build
        shell: bash
        run: ${{ env.mavenBuildScript }}
        env:
          GITHUB_ACTOR: ${{ github.actor }}
          PERSONAL_ACCESS_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}

      #- name: Run deploy without deploying
      #  shell: bash
      #  run: ./mvnw --batch-mode --debug -Dmaven.wagon.http.debug=true ‑Dmaven.deploy.skip=true deploy

      - name: Setup Java using GitHub Token
        uses: actions/setup-java@v4
        with:
          distribution: 'corretto'
          java-version: 21
          cache: 'maven'
          #server-password: PERSONAL_ACCESS_TOKEN
          #env:
          #GITHUB_ACTOR: ${{ github.actor }}
          #PERSONAL_ACCESS_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}

      - run: cat ~/.m2/settings.xml

      - name: Validate settings.xml
        shell: bash
        run: mvn help:effective-settings
        #env:
          #GITHUB_ACTOR: ${{ github.actor }}
          #PERSONAL_ACCESS_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}

      - name: Examine the git working copy (pre-release)
        shell: bash
        run: |
          git config --local user.email "${{ env.gitUserEmail }}"
          git config --local user.name "${{ env.gitUserName }}"
          git status -v

      - name: Get latest from remote
        run: |
          git config --local user.email "${{ env.gitUserEmail }}"
          git config --local user.name "${{ env.gitUserName }}"
          git pull --ff-only origin ${{ github.ref }}

      - name: Setup Java
        uses: actions/setup-java@v4
        with:
          distribution: 'corretto'
          java-version: 21
          cache: 'maven'
          #server-password: PERSONAL_ACCESS_TOKEN
        #env:
          #GITHUB_ACTOR: ${{ github.actor }}
          #PERSONAL_ACCESS_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}

      - name: released
        id: released
        if: ${{ env.versionIncrement == 'major' || env.versionIncrement == 'minor' || env.versionIncrement == 'patch' }}
        shell: bash
        run: |
          releaseVersionOverride='${{ env.releaseVersionOverride }}'
          if [[ -n "$releaseVersionOverride" ]]; then
            newVersion="$releaseVersionOverride"
            mvn versions:set -DnewVersion=$newVersion
            echo "Using version override: $newVersion"
          else
            currentVersion=$(mvn help:evaluate -Dexpression=project.version -q -DforceStdout)
            # Bump version for release: remove -SNAPSHOT if present
            newVersion=${currentVersion/-SNAPSHOT/}
            mvn versions:set -DnewVersion=$newVersion
            echo "Using stadard version increment: $newVersion"
          fi
          ${{ env.mavenBuildScript }}
          echo "Deploying version: $newVersion"
          ${{ env.mavenDeployScript }}
          git push --follow-tags
          echo "releasedVersion=${newVersion}" >> $GITHUB_OUTPUT
          echo "releasedVersion=${newVersion}"
        env:
          GITHUB_TOKEN: ${{ github.token }}
          #GITHUB_ACTOR: ${{ github.actor }}
          #PERSONAL_ACCESS_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}

      - name: Create GitHub Release
        if: ${{ inputs.githubRelease == true && ( env.versionIncrement == 'major' || env.versionIncrement == 'minor' || env.versionIncrement == 'patch' ) }}
        uses: ncipollo/release-action@v1
        with:
          tag: ${{ steps.released.outputs.releasedVersion }}
          name: Release ${{ steps.released.outputs.releasedVersion }}
          body: ${{ env.releaseNotes }}
        #env:
          #GITHUB_ACTOR: ${{ github.actor }}
          #PERSONAL_ACCESS_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}

      - name: Rotate to next snapshot version (from a released version)
        if: ${{ env.versionIncrement == 'major' || env.versionIncrement == 'minor' || env.versionIncrement == 'patch' }}
        shell: bash
        run: |
          newVersionOverride='${{ env.newVersionOverride }}'
          if [[ -n "$newVersionOverride" ]]; then
            newVersion="$newVersionOverride"
            mvn versions:set -DnewVersion=$newVersion
            echo "Using version override: $newVersion"
          else
            currentVersion=$(mvn help:evaluate -Dexpression=project.version -q -DforceStdout)
            if [[ "$currentVersion" != *-SNAPSHOT ]]; then
              newVersion="${currentVersion}-SNAPSHOT"
              mvn versions:set -DnewVersion=$newVersion
            fi
            echo "Using incremented version: $newVersion"
          fi
        #env:
          #GITHUB_ACTOR: ${{ github.actor }}
          #PERSONAL_ACCESS_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}

      - name: Rotate to next pre-release version
        if: ${{ env.versionIncrement == 'premajor' || env.versionIncrement == 'preminor' || env.versionIncrement == 'prepatch' || env.versionIncrement == 'prerelease' }}
        shell: bash
        run: |
          newVersionOverride='${{ env.newVersionOverride }}'
          if [[ -n "$newVersionOverride" ]]; then
            newVersion="$newVersionOverride"
            mvn versions:set -DnewVersion=$newVersion
            echo "Using version override: $newVersion"
          else
            currentVersion=$(mvn help:evaluate -Dexpression=project.version -q -DforceStdout)
            newVersion="${currentVersion%-SNAPSHOT}-SNAPSHOT"
            mvn versions:set -DnewVersion=$newVersion
            echo "Using incremented version: $newVersion"
          fi
        #env:
          #GITHUB_ACTOR: ${{ github.actor }}
          #PERSONAL_ACCESS_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}

      - name: rotated
        id: rotated
        shell: bash
        run: |
          newVersion=$(mvn help:evaluate -Dexpression=project.version -q -DforceStdout)
          echo "newVersion=${newVersion}" >> $GITHUB_OUTPUT
          echo "newVersion=${newVersion}"
        #env:
          #GITHUB_ACTOR: ${{ github.actor }}
          #PERSONAL_ACCESS_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}

      - name: Examine the git working copy (post-rotation)
        shell: bash
        run: |
          git config --local user.email "${{ env.gitUserEmail }}"
          git config --local user.name "${{ env.gitUserName }}"
          git status -v

      - name: Run build after version bump
        run: ${{ env.mavenBuildScript }}
        #env:
          #GITHUB_ACTOR: ${{ github.actor }}
          #PERSONAL_ACCESS_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}

      - name: Examine the git working copy (pre-push)
        shell: bash
        run: |
          git config --local user.email "${{ env.gitUserEmail }}"
          git config --local user.name "${{ env.gitUserName }}"
          git status -v

      - name: Push version commit
        id: push
        shell: bash
        run: |
          git config --local user.email "${{ env.gitUserEmail }}"
          git config --local user.name "${{ env.gitUserName }}"
          newVersionOverride='${{ env.newVersionOverride }}'
          if [[ -n "$newVersionOverride" ]]; then
            git add -v --all
            newVersion=$(mvn help:evaluate -Dexpression=project.version -q -DforceStdout)
            git commit -m "${newVersion?}"
            git push origin HEAD
          fi
        #env:
          #GITHUB_ACTOR: ${{ github.actor }}
          #PERSONAL_ACCESS_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}

      - name: Upload pom.xml artifact
        uses: actions/upload-artifact@v4
        with:
          name: pom-xml
          path: "./pom.xml"

      - name: Log final version
        shell: bash
        run: |
          echo "Final version: ${{ steps.rotated.outputs.newVersion }}"

    outputs:
      releasedVersion: ${{ steps.released.outputs.releasedVersion }}
      newVersion: ${{ steps.rotated.outputs.newVersion }}
.github/workflows/wfr-apply-issue-resolution.yml
==== Content of .github/workflows/wfr-apply-issue-resolution.yml ====
# .github/workflows/wfr-apply-issue-resolution.yml

#
# agentic-lib
# Copyright (C) 2025 Polycode Limited
#
# This file is part of agentic-lib.
#
# agentic-lib is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License v3.0 (GPL‑3).
# along with this program. If not, see <https://www.gnu.org/licenses/>.
#
# IMPORTANT: Any derived work must include the following attribution:
# "This work is derived from https://github.com/xn-intenton-z2a/agentic-lib"
#

name: ∞ wfr-apply-issue-resolution

on:
  workflow_call:
    inputs:
      issueNumber:
        description: 'The issue number to review. e.g. "123"'
        type: string
        required: true
      target:
        description: 'The target file to review. e.g. "src/lib/main.js"'
        type: string
        required: false
        default: 'src/lib/main.js'
      testFile:
        description: 'The test file to review. e.g. "tests/unit/main.test.js"'
        type: string
        required: false
        default: 'tests/unit/main.test.js'
      readmeFile:
        description: 'The README file to review. e.g. "README.md"'
        type: string
        required: false
        default: 'README.md'
      missionFile:
        description: 'The MISSION statement file. e.g. "MISSION.md"'
        type: string
        required: false
        default: 'MISSION.md'
      contributingFile:
        description: 'The CONTRIBUTING file to review. e.g. "CONTRIBUTING.md"'
        type: string
        required: false
        default: 'CONTRIBUTING.md'
      dependenciesFile:
        description: 'The dependencies file to review. e.g. "package.json"'
        type: string
        required: false
        default: 'package.json'
      formattingFile:
        description: 'The formatting file to review. e.g. ".prettierrc"'
        type: string
        required: false
        default: '.prettierrc'
      lintingFile:
        description: 'The linting file to review. e.g. "eslint.config.js"'
        type: string
        required: false
        default: 'eslint.config.js'
      branchPrefix:
        description: 'The prefix for the issue branch. e.g. "agentic-lib-issue-".'
        type: string
        required: true
      buildScript:
        description: 'The script must be runnable as: `npm ci ; <script>` and succeed with a zero exit code. e.g. `npm run build`'
        type: string
        required: false
        default: 'echo "No build script specified."'
      testScript:
        description: 'The script must be runnable as: `npm ci ; <script>` and succeed with a zero exit code. e.g. `npm test`'
        type: string
        required: false
        default: 'npm test'
      mainScript:
        description: 'The script must be runnable as: `npm ci ; <script>` and succeed with a zero exit code. e.g. `npm run start`'
        type: string
        required: false
        default: 'npm run start'
      model:
        description: 'The OpenAI model to use. e.g. "o3-mini"'
        type: string
        required: false
        default: ${{ vars.CHATGPT_API_MODEL || 'o3-mini' }}
      npmAuthOrganisation:
        description: 'The GitHub organisation to authenticate with for npm. e.g. "@xn-intenton-z2a"'
        type: string
        required: false
        default: ''
      gitUserEmail:
        description: 'The email to use for git commits. e.g. "action@github.com"'
        type: string
        required: false
        default: 'action@github.com'
      gitUserName:
        description: 'The name to use for git commits. e.g. "GitHub Actions[bot]"'
        type: string
        required: false
        default: 'GitHub Actions[bot]'
      s3BucketUrl:
        description: 'The S3 bucket URL with prefix to use. e.g. "s3://my-bucket/prefix"'
        type: string
        required: false
        default: ''
      iamRoleArn:
        description: 'The ARN of the IAM role to assume. e.g. "arn:aws:iam::123456789012:role/my-role"'
        type: string
        required: false
        default: ''
    secrets:
      PERSONAL_ACCESS_TOKEN:
        required: false
      CHATGPT_API_SECRET_KEY:
        required: true
    outputs:
      fixApplied:
        value: ${{ jobs.apply-issue-resolution.outputs.fixApplied }}
      message:
        value: ${{ jobs.apply-issue-resolution.outputs.message }}
      installAfterUpdateOutcome:
        value: ${{ jobs.apply-issue-resolution.outputs.installAfterUpdateOutcome }}
      ciAfterUpdateOutcome:
        value: ${{ jobs.apply-issue-resolution.outputs.ciAfterUpdateOutcome }}
      testAfterUpdateOutcome:
        value: ${{ jobs.apply-issue-resolution.outputs.testAfterUpdateOutcome }}
      mainAfterUpdateOutcome:
        value: ${{ jobs.apply-issue-resolution.outputs.mainAfterUpdateOutcome }}
      commitOutcome:
        value: ${{ jobs.apply-issue-resolution.outputs.commitOutcome }}
      postResolutionCommentOutcome:
        value: ${{ jobs.apply-issue-resolution.outputs.postResolutionCommentOutcome }}
      allValidationStepsSuccessful:
        value: ${{ jobs.apply-issue-resolution.outputs.allValidationStepsSuccessful }}
      branch:
        value: ${{ inputs.branchPrefix || 'agentic-lib-issue-' }}${{ inputs.issueNumber }}

jobs:
  apply-issue-resolution:
    runs-on: ubuntu-latest

    env:
      issueNumber: ${{ inputs.issueNumber }}
      target: ${{ inputs.target || 'src/lib/main.js' }}
      testFile: ${{ inputs.testFile || 'tests/unit/main.test.js' }}
      readmeFile: ${{ inputs.readmeFile || 'README.md' }}
      missionFile: ${{ inputs.missionFile || 'MISSION.md' }}
      contributingFile: ${{ inputs.contributingFile || 'CONTRIBUTING.md' }}
      dependenciesFile: ${{ inputs.dependenciesFile || 'package.json' }}
      formattingFile: ${{ inputs.formattingFile || '.prettierrc' }}
      lintingFile: ${{ inputs.lintingFile || 'eslint.config.js' }}
      branch: ${{ inputs.branchPrefix || 'agentic-lib-issue-' }}${{ inputs.issueNumber }}
      buildScript: ${{ inputs.buildScript || 'npm run build' }}
      testScript: ${{ inputs.testScript || 'npm test' }}
      mainScript: ${{ inputs.mainScript || 'npm run start' }}
      mainScriptTimeout: '5m'
      model: ${{ inputs.model || vars.CHATGPT_API_MODEL || 'o3-mini' }}
      chatgptApiSecretKey: ${{ secrets.CHATGPT_API_SECRET_KEY }}
      npmAuthOrganisation: ${{ inputs.npmAuthOrganisation || '' }}
      gitUserEmail: ${{ inputs.gitUserEmail || 'action@github.com' }}
      gitUserName: ${{ inputs.gitUserName || 'GitHub Actions[bot]' }}

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.ref }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Check GitHub authentication
        if: ${{ env.npmAuthOrganisation != '' }}
        shell: bash
        run: |
          curl --include --header "Authorization: token ${{ secrets.PERSONAL_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}" https://api.github.com/user

      - name: Set up .npmrc
        if: ${{ env.npmAuthOrganisation != '' }}
        shell: bash
        run: |
          echo "${{ env.npmAuthOrganisation }}:registry=https://npm.pkg.github.com" >> .npmrc
          echo "//npm.pkg.github.com/:_authToken=${{ secrets.PERSONAL_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}" >> .npmrc
          echo "always-auth=true" >> .npmrc

      - name: Get latest from remote
        run: |
          git config --local user.email "${{ env.gitUserEmail }}"
          git config --local user.name "${{ env.gitUserName }}"
          git pull --ff-only origin ${{ github.ref }}

      - run: npm ci

      - name: List dependencies
        id: list
        shell: bash
        run: |
          output=$(npm list 2>&1)
          echo "output<<EOF" >> "$GITHUB_OUTPUT"
          echo "$output" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          echo "output=${output}"

      - name: Build project
        id: build
        shell: bash
        run: |
          output=$(${{ env.buildScript }} 2>&1)
          echo "output<<EOF" >> "$GITHUB_OUTPUT"
          echo "$output" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          echo "output=${output}"

      - name: Run tests
        id: test
        shell: bash
        run: |
          output=$(${{ env.testScript }} 2>&1)
          echo "output<<EOF" >> "$GITHUB_OUTPUT"
          echo "$output" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          echo "output=${output}"

      - name: Run main
        id: main
        shell: bash
        run: |
          output=$(timeout ${{ env.mainScriptTimeout }} ${{ env.mainScript }} 2>&1)
          echo "output<<EOF" >> "$GITHUB_OUTPUT"
          echo "$output" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          echo "output=${output}"

      - name: update-target
        id: update-target
        uses: actions/github-script@v7
        env:
          dependenciesListOutput: ${{ steps.list.outputs.output }}
          buildOutput: ${{ steps.build.outputs.output }}
          testOutput: ${{ steps.test.outputs.output }}
          mainOutput: ${{ steps.main.outputs.output }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const target = process.env.target;
            const testFile = process.env.testFile;
            const readmeFile = process.env.readmeFile;
            const missionFile = process.env.missionFile;
            const contributingFile = process.env.contributingFile;
            const dependenciesFile = process.env.dependenciesFile;
            const formattingFile = process.env.formattingFile;
            const lintingFile = process.env.lintingFile;
            const model = process.env.model;
            const apiKey = process.env.chatgptApiSecretKey;
            const issueNumber = parseInt(process.env.issueNumber);
            const dependenciesListOutput = process.env.dependenciesListOutput;
            const buildScript = process.env.buildScript;
            const buildOutput = process.env.buildOutput;
            const testScript = process.env.testScript;
            const testOutput = process.env.testOutput;
            const mainScript = process.env.mainScript;
            const mainOutput = process.env.mainOutput;
            
            const fs = require('fs');
            const OpenAI = require('openai').default;
            const { z } = require('zod');
            require('dotenv').config();
            
            if (!apiKey) { 
              core.setFailed("Missing CHATGPT_API_SECRET_KEY"); 
            }
            const openai = new OpenAI({ apiKey });
            
            core.info(`target: "${target}"`);
            core.info(`testFile: "${testFile}"`);
            core.info(`readmeFile: "${readmeFile}"`);
            core.info(`missionFile: "${missionFile}"`);
            core.info(`contributingFile: "${contributingFile}"`);
            core.info(`dependenciesFile: "${dependenciesFile}"`);
            core.info(`formattingFile: "${formattingFile}"`);
            core.info(`lintingFile: "${lintingFile}"`);
            const sourceFileContent = fs.readFileSync(target, 'utf8');
            const testFileContent = fs.readFileSync(testFile, 'utf8');
            const readmeFileContent = fs.readFileSync(readmeFile, 'utf8');
            const missionFileContent = fs.readFileSync(missionFile, 'utf8');
            const contributingFileContent = fs.readFileSync(contributingFile, 'utf8');
            const dependenciesFileContent = fs.readFileSync(dependenciesFile, 'utf8');
            const formattingFileContent = fs.readFileSync(formattingFile, 'utf8');
            const lintingFileContent = fs.readFileSync(lintingFile, 'utf8');
            core.info(`Target file '${target}' has been loaded (length ${sourceFileContent.length}).`);
            core.info(`Test file '${testFile}' has been loaded (length ${testFileContent.length}).`);
            core.info(`Readme file '${readmeFile}' has been loaded (length ${readmeFileContent.length}).`);
            core.info(`Dependencies file '${dependenciesFile}' has been loaded (length ${dependenciesFileContent.length}).`);
            core.info(`Formatting file '${formattingFile}' has been loaded (length ${formattingFileContent.length}).`);
            core.info(`Linting file '${lintingFile}' has been loaded (length ${lintingFileContent.length}).`);
            
            const issue = await github.rest.issues.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber
            });
            const issueTitle = issue.data.title;
            const issueDescription = issue.data.body;
            const issueComments = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber
            });
            const issueCommentsText = issueComments.data
              .map(comment => `Author:${comment.user.login}, Created:${comment.created_at}, Comment: ${comment.body}`)
              .join('\n');
            
            const prompt = `
            You are providing the entire new content of the source file, test file and README file with all necessary changes applied to resolve an issue.
            Consider the following when refining your response:
            * Source file content
            * Test file content
            * README file content issue
            * MISSION file content
            * Contributing file content
            * Dependencies file content
            * Formatting file content
            * Linting file content
            * Issue details
            * Dependency list
            * Build output
            * Test output
            * Main execution output
            
            Apply the contributing guidelines to your response and when suggesting enhancements consider the tone and direction of the contributing guidelines.
            
            Source file: ${target}
            SOURCE_FILE_START
            ${sourceFileContent}
            SOURCE_FILE_END
            
            Test file: ${testFile}
            TEST_FILE_START
            ${testFileContent}
            TEST_FILE_END

            README file: ${readmeFile}
            README_FILE_START
            ${readmeFileContent}
            README_FILE_END
            
            MISSION file: ${missionFile}
            MISSION_FILE_START
            ${missionFileContent}
            MISSION_FILE_END

            Contributing file: ${contributingFile}
            CONTRIBUTING_FILE_START
            ${contributingFileContent}
            CONTRIBUTING_FILE_END
            
            Dependencies file: ${dependenciesFile}
            DEPENDENCIES_FILE_START
            ${dependenciesFileContent}
            DEPENDENCIES_FILE_END
            
            Formatting file: ${formattingFile}
            FORMATTING_FILE_START
            ${formattingFileContent}
            FORMATTING_FILE_END
            
            Linting file: ${lintingFile}
            LINTING_FILE_START
            ${lintingFileContent}
            LINTING_FILE_END
                 
            Issue details:
            ISSUE_START
            title: ${issueTitle}
            description:
            ${issueDescription}
            comments:
            ${issueCommentsText}
            ISSUE_END            

            Dependencies list from command: npm list
            DEPENDENCIES_LIST_START
            ${dependenciesListOutput}
            DEPENDENCIES_LIST_END    

            Build output from command: ${buildScript}
            BUILD_OUTPUT_START
            ${buildOutput}
            BUILD_OUTPUT_END      
            
            Test output from command: ${testScript}
            TEST_OUTPUT_START
            ${testOutput}
            TEST_OUTPUT_END            

            Main execution output from command: ${mainScript}
            MAIN_OUTPUT_START
            ${mainOutput}
            MAIN_OUTPUT_END    
            
            Please produce an updated version of the source file, and test file, and README and dependencies file that resolves the issue.
            Answer strictly with a JSON object following this schema:
            
            {
              "updatedSourceFileContent": "The entire new content of the source file, with all necessary changes applied.",
              "updatedTestFileContent": "The entire new content of the test file, with all necessary changes applied.",
              "updatedReadmeFileContent": "The entire new content of the README file, with all necessary changes applied.",
              "updatedDependenciesFileContent": "The entire new content of the dependencies file, with all necessary changes applied.",
              "message": "A short sentence explaining the change applied suitable for a commit message."
            }
            
            Ensure valid JSON.
            `;
            
            const ResponseSchema = z.object({ updatedSourceFileContent: z.string(), updatedTestFileContent: z.string(), updatedReadmeFileContent: z.string(), updatedDependenciesFileContent: z.string(), message: z.string() });
            
            // Define the function schema for functional calling
            const applyIssueResolutionToSource = [{
              type: "function",
              function: {
                name: "applyIssueResolutionToSource",
                description: "Return an updated version of the source file content along with a commit message. Use the provided source file content and supporting context to generate the update.",
                parameters: {
                  type: "object",
                  properties: {
                    updatedSourceFileContent: {
                      type: "string",
                      description: "The entire new content of the source file, with all necessary changes applied."
                    },
                    updatedTestFileContent: {
                      type: "string",
                      description: "The entire new content of the test file, with all necessary changes applied."
                    },
                    updatedReadmeFileContent: {
                      type: "string",
                      description: "The entire new content of the README file, with all necessary changes applied."
                    },
                    updatedDependenciesFileContent: {
                      type: "string",
                      description: "The entire new content of the dependencies file, with all necessary changes applied."
                    },
                    message: {
                      type: "string",
                      description: "A short sentence explaining the change applied suitable for a commit message."
                    }
                  },
                  required: ["updatedSourceFileContent", "updatedTestFileContent", "updatedReadmeFileContent", "updatedDependenciesFileContent", "message"],
                  additionalProperties: false
                },
                strict: true
              }
            }];
            
            // Call OpenAI using the function calling format via the tools parameter
            const response = await openai.chat.completions.create({
              model,
              messages: [
                { role: "system", content: "You are a code fixer that returns an updated source file content, test file content, README file content and dependencies file content to resolve an issue. Answer strictly with a JSON object that adheres to the provided function schema." },
                { role: "user", content: prompt }
              ],
              tools: applyIssueResolutionToSource
            });
            
            let fixApplied;
            let result;
            // Check if the model made a function call; if so, parse its arguments.
            if (response.choices[0].message.tool_calls && response.choices[0].message.tool_calls.length > 0) {
              try {
                result = JSON.parse(response.choices[0].message.tool_calls[0].function.arguments);
              } catch (e) {
                fixApplied = false;
                core.setFailed(`Failed to parse function call arguments: ${e.message}`);
              }
            } else if (response.choices[0].message.content) {
              try {
                result = JSON.parse(response.choices[0].message.content);
              } catch (e) {
                fixApplied = false;
                core.setFailed(`Failed to parse response content: ${e.message}`);
              }
            } else {
              fixApplied = false;
              core.setFailed("No valid response received from OpenAI.");
            }
            
            try {
              const parsed = ResponseSchema.parse(result);
              // Sanitize commit message: retain only alphanumerics, spaces, and basic URL-safe punctuation (-, _, ., ~)
              const sanitizedMessage = parsed.message.replace(/[^A-Za-z0-9 \-\_\.\~]/g, '').replace(/\s+/g, ' ').trim();
              core.setOutput("message", sanitizedMessage);
              core.info(`message: "${sanitizedMessage}"`);
            
              if(parsed.updatedSourceFileContent && parsed.updatedSourceFileContent.length > 1 && parsed.updatedSourceFileContent !== sourceFileContent) {
                fs.writeFileSync(target, parsed.updatedSourceFileContent, 'utf8');
                fixApplied = true;
                core.info(`Target file '${target}' has been updated (length ${parsed.updatedSourceFileContent.length}).`);
              }
              if(parsed.updatedTestFileContent && parsed.updatedTestFileContent.length > 1 && parsed.updatedTestFileContent !== testFileContent) {
                fs.writeFileSync(testFile, parsed.updatedTestFileContent, 'utf8');
                fixApplied = true;
                core.info(`Test file '${testFile}' has been updated (length ${parsed.updatedTestFileContent.length}).`);
              }
              if(parsed.updatedReadmeFileContent && parsed.updatedReadmeFileContent.length > 1 && parsed.updatedReadmeFileContent !== readmeFileContent) {
                fs.writeFileSync(readmeFile, parsed.updatedReadmeFileContent, 'utf8');
                fixApplied = true;
                core.info(`Readme file '${readmeFile}' has been updated (length ${parsed.updatedReadmeFileContent.length}).`);
              }
              if(parsed.updatedDependenciesFileContent && parsed.updatedDependenciesFileContent.length > 1 && parsed.updatedDependenciesFileContent !== dependenciesFileContent) {
                fs.writeFileSync(dependenciesFile, parsed.updatedDependenciesFileContent, 'utf8');
                fixApplied = true;
                core.info(`Dependencies file '${dependenciesFile}' has been updated (length ${parsed.updatedDependenciesFileContent.length}).`);
              }

              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber,
                body: parsed.message
              });
            } catch (e) {
              fixApplied = false;
              core.setFailed(`Failed to validate or process the response: ${e.message}`);
            }
            
            core.setOutput("fixApplied", fixApplied);
            core.setOutput("usage", JSON.stringify(response.usage));
            core.info(`fixApplied: "${fixApplied}"`);
            core.info(`usage: "${JSON.stringify(response.usage)}"`);
            core.info(`response: "${JSON.stringify(response)}"`);

      - run: cat ${{ env.target }}

      - name: Examine the git working copy
        shell: bash
        run: |
          git config --local user.email '${{ env.gitUserEmail }}'
          git config --local user.name '${{ env.gitUserName }}'
          git status -v
          git diff ${{ env.target }}

      - run: rm -rf node_modules

      - name: install-after-update
        id: install-after-update
        run: npm install

      - name: ci-after-update
        id: ci-after-update
        continue-on-error: true
        run: npm ci

      - name: Tear down .npmrc
        continue-on-error: true
        if: ${{ env.npmAuthOrganisation != '' }}
        shell: bash
        run: rm -f .npmrc

      - name: test-after-update
        id: test-after-update
        continue-on-error: true
        shell: bash
        run: |
          ${{ env.testScript }}

      - name: Run main after update
        id: main-after-update
        continue-on-error: true
        shell: bash
        run: |
          timeout ${{ env.mainScriptTimeout }} ${{ env.mainScript }}

      - name: Commit to new branch
        id: commit
        continue-on-error: true
        run: |
          git config --local user.email '${{ env.gitUserEmail }}'
          git config --local user.name '${{ env.gitUserName }}'
          git status -v
          git switch -c '${{ env.branch }}'
          git add -v --all
          git diff '${{ env.target }}'
          git commit -m '${{ steps.update-target.outputs.message }} (fixes #${{ env.issueNumber }})'
          git push --set-upstream origin '${{ env.branch }}' -v
          git status -v

      - name: Post Resolution Comment
        id: post-resolution-comment
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const issueNumber = parseInt("${{ env.issueNumber }}");
            const branchName = `${{ env.branch }}`;
            const branchUrl = `https://github.com/${{ github.repository }}/tree/${branchName}`;
            const body = `${branchUrl}`;
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber,
              body: body
            });
            await github.rest.issues.addAssignees({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber,
              assignees: [ context.actor ]
            });

      - name: Extract Results
        if: always()
        id: results
        uses: actions/github-script@v7
        with:
          script: |
            const fixApplied = '${{ steps.update-target.outputs.fixApplied }}';
            const message = '${{ steps.update-target.outputs.message }}';
            const installAfterUpdateOutcome = '${{ steps.install-after-update.outcome }}';
            const ciAfterUpdateOutcome = '${{ steps.ci-after-update.outcome }}';
            const testAfterUpdateOutcome = '${{ steps.test-after-update.outcome }}';
            const mainAfterUpdateOutcome = '${{ steps.main-after-update.outcome }}';
            const commitOutcome = '${{ steps.commit.outcome }}';
            const postResolutionCommentOutcome = '${{ steps.post-resolution-comment.outcome }}';
            const allValidationStepsSuccessful = installAfterUpdateOutcome === "success" && ciAfterUpdateOutcome === "success" && testAfterUpdateOutcome === "success" && mainAfterUpdateOutcome === "success" && commitOutcome === "success" && postResolutionCommentOutcome === "success";
            core.setOutput('fixApplied', fixApplied);
            core.setOutput('message', message);
            core.setOutput('installAfterUpdateOutcome', installAfterUpdateOutcome);
            core.setOutput('ciAfterUpdateOutcome', ciAfterUpdateOutcome);
            core.setOutput('testAfterUpdateOutcome', testAfterUpdateOutcome);
            core.setOutput('mainAfterUpdateOutcome', mainAfterUpdateOutcome);
            core.setOutput('commitOutcome', commitOutcome);
            core.setOutput('postResolutionCommentOutcome', postResolutionCommentOutcome);
            core.setOutput('allValidationStepsSuccessful', allValidationStepsSuccessful);
            core.info(`fixApplied: "${fixApplied}"`);
            core.info(`message: "${message}"`);
            core.info(`installAfterUpdateOutcome: "${installAfterUpdateOutcome}"`);
            core.info(`ciAfterUpdateOutcome: "${ciAfterUpdateOutcome}"`);
            core.info(`testAfterUpdateOutcome: "${testAfterUpdateOutcome}"`);
            core.info(`mainAfterUpdateOutcome: "${mainAfterUpdateOutcome}"`);
            core.info(`commitOutcome: "${commitOutcome}"`);
            core.info(`postResolutionCommentOutcome: "${postResolutionCommentOutcome}"`);
            core.info(`allValidationStepsSuccessful: "${allValidationStepsSuccessful}"`);

    outputs:
      fixApplied: ${{ steps.results.outputs.fixApplied }}
      message: ${{ steps.results.outputs.message }}
      installAfterUpdateOutcome: ${{ steps.results.outputs.installAfterUpdateOutcome }}
      ciAfterUpdateOutcome: ${{ steps.results.outputs.ciAfterUpdateOutcome }}
      testAfterUpdateOutcome: ${{ steps.results.outputs.testAfterUpdateOutcome }}
      mainAfterUpdateOutcome: ${{ steps.results.outputs.mainAfterUpdateOutcome }}
      commitOutcome: ${{ steps.results.outputs.commitOutcome }}
      postResolutionCommentOutcome: ${{ steps.results.outputs.postResolutionCommentOutcome }}
      allValidationStepsSuccessful: ${{ steps.results.outputs.allValidationStepsSuccessful }}

.github/workflows/issue-for-linting.yml
==== Content of .github/workflows/issue-for-linting.yml ====
# .github/workflows/issue-for-linting.yml
#
# This file is part of the example suite for `agentic-lib` see: https://github.com/xn-intenton-z2a/agentic-lib
# This file is licensed under the MIT License. For details, see LICENSE-MIT

name: Linting
concurrency: agentic-lib
run-name: "Linting [${{ github.ref_name }}]"

on:
  workflow_dispatch:
  schedule:
    - cron: '15 4 */7 * *' # schedule-1
    #- cron: '15 4 * * *' # schedule-2
    #- cron: '15 4 * * *' # schedule-3

jobs:

  linting:
    permissions:
      contents: write
      packages: write
      id-token: write
    uses: 'xn-intenton-z2a/agentic-lib/.github/workflows/wfr-run-script-and-commit-to-branch.yml@main'
    with:
      #script: 'npm run linting "." -- --max-warnings=10'
      script: 'npm run linting src/lib/main.js tests/unit/main.test.js'
      sarifScript: 'npm run linting-json --silent src/lib/main.js tests/unit/main.test.js'
      testScript: 'npm test'

  create-issue:
    needs:
      - linting
    if: ${{ needs.linting.outputs.fixStillRequired == 'true' || needs.linting.outputs.fixStillRequired == true || needs.linting.outputs.remainingResultsCount != '0' }}
    permissions:
      issues: write
      id-token: write
    uses: 'xn-intenton-z2a/agentic-lib/.github/workflows/wfr-create-issue.yml@main'
    with:
      issueTitle: 'Resolve issues in output from running: npm run linting-fix "." -- --max-warnings=10'
      issueBody: ${{ needs.linting.outputs.scriptOutput }}
.github/workflows/update.yml
==== Content of .github/workflows/update.yml ====
# .github/workflows/update.yml
#
# This file is part of the example suite for `agentic-lib` see: https://github.com/xn-intenton-z2a/agentic-lib
# This file is licensed under the MIT License. For details, see LICENSE-MIT

name: Update
concurrency: agentic-lib
run-name: "Update [${{ github.ref_name }}]"

on:
  repository_dispatch:
    types: [package-published]
  schedule:
    - cron: '30 7 */7 * *' # schedule-1
    #- cron: '30 7 * * *' # schedule-2
    #- cron: '30 7 * * *' # schedule-3

  workflow_dispatch:
    inputs:
      upgradeTarget:
        description: 'Select the type of update to run'
        type: choice
        default: 'minor'
        required: false
        options:
          - greatest
          - latest
          - newest
          - patch
          - minor
          - semver

jobs:

  check-branch:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write
    env:
      branchPrefix: 'agentic-lib-'
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.ref }}
      - name: Ensure there isn't already a branch for this prefix
        shell: bash
        run: |
          git fetch origin
          if git branch -r | grep -q 'origin/${{ env.branchPrefix }}'; then
            echo "A branch with the prefix '${{ env.branchPrefix }}' already exists."
            exit 1
          else
            echo "No existing branch with the prefix found."
          fi

  update-npm:
    needs:
      - check-branch
    permissions:
      contents: write
      pull-requests: write
      id-token: write
      packages: write
    uses: 'xn-intenton-z2a/agentic-lib/.github/workflows/wfr-update-npm.yml@main'
    with:
      buildScript: 'npm run build'
      testScript: 'npm test'
      mainScript: ${{ vars.MAIN_SCRIPT || 'npm run start' }}
      upgradeTarget: ${{ inputs.upgradeTarget || 'patch' }}
      branch: 'agentic-lib-update'
      npmAuthOrganisation: '@xn-intenton-z2a'
      gitUserEmail: 'action@github.com'
      gitUserName: 'GitHub Actions[bot]'
      gitCommitMessage: 'chore: dependency updates'
    secrets:
      PERSONAL_ACCESS_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}

  update-mvn:
    needs:
      - check-branch
      - update-npm
    if: ${{ needs.update-npm.outputs.updatedFiles != 'true' }}
    permissions:
      contents: write
      pull-requests: write
      id-token: write
      packages: write
    uses: 'xn-intenton-z2a/agentic-lib/.github/workflows/wfr-update-mvn.yml@main'
    with:
      buildScript: './mvnw clean install'
      testScript: './mvnw test'
      upgradeTarget: 'minor'
      branch: 'agentic-lib-update'
      gitUserEmail: 'action@github.com'
      gitUserName: 'GitHub Actions[bot]'
      gitCommitMessage: 'chore: dependency updates'
    secrets:
      PERSONAL_ACCESS_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}

  create-pr-npm:
    needs:
      - update-npm
    if: ${{ needs.update-npm.outputs.updatedFiles == 'true' }}
    permissions:
      contents: write
      packages: write
      issues: write
      pull-requests: write
      checks: write
      id-token: write
    uses: 'xn-intenton-z2a/agentic-lib/.github/workflows/wfr-create-pr.yml@main'
    with:
      branch: 'agentic-lib-update'
      baseBranch: 'main'
      gitCommitMessage: 'chore: dependency updates'
      label: 'automerge'

  create-pr-mvn:
    needs:
      - update-mvn
    if: ${{ needs.update-mvn.outputs.updatedFiles == 'true' }}
    permissions:
      contents: write
      packages: write
      issues: write
      pull-requests: write
      checks: write
      id-token: write
    uses: 'xn-intenton-z2a/agentic-lib/.github/workflows/wfr-create-pr.yml@main'
    with:
      branch: 'agentic-lib-update'
      baseBranch: 'main'
      gitCommitMessage: 'chore: dependency updates'
      label: 'automerge'
.github/workflows/issue-reviewer.yml
==== Content of .github/workflows/issue-reviewer.yml ====
# .github/workflows/issue-reviewer.yml
#
# This file is part of the example suite for `agentic-lib` see: https://github.com/xn-intenton-z2a/agentic-lib
# This file is licensed under the MIT License. For details, see LICENSE-MIT

name: Review Issue
run-name: "Review Issue [${{ github.ref_name }}]"

on:
  workflow_dispatch:
    inputs:
      issueNumber:
        description: 'The issue number to review. If not provided, the workflow will select one based on label. e.g. "123"'
        required: false
        type: string
        default: ''
      selectionLabel:
        description: 'Label used to filter issues for review. e.g. "merged"'
        required: false
        type: string
        default: 'merged'
      target:
        description: 'The source file whose content was used in the resolution prompt. e.g. "src/lib/main.js"'
        required: false
        type: string
        default: 'src/lib/main.js'
      testFile:
        description: 'The test file to run to validate the resolution. e.g. "tests/unit/main.test.js"'
        required: false
        type: string
        default: 'tests/unit/main.test.js'
  workflow_run:
    workflows:
      - "Automerge"
    types:
      - completed
  schedule:
    - cron: '45 */6 * * *' # schedule-1
    #- cron: '*/15 * * * *' # schedule-2
    #- cron: '*/5 * * * *' # schedule-3

jobs:

  select-issue:
    permissions:
      issues: read
      id-token: write
    uses: 'xn-intenton-z2a/agentic-lib/.github/workflows/wfr-select-issue.yml@main'
    with:
      issueNumber: ${{ inputs.issueNumber || '' }}
      selectionLabel: ${{ inputs.selectionLabel || 'merged' }}
    secrets:
      CHATGPT_API_SECRET_KEY: ${{ secrets.CHATGPT_API_SECRET_KEY }}

  review-issue:
    needs:
      - select-issue
    if: ${{ needs.select-issue.outputs.issueNumber != '' && needs.select-issue.outputs.merged == 'true' }}
    permissions:
      contents: write
      issues: write
      id-token: write
    uses: 'xn-intenton-z2a/agentic-lib/.github/workflows/wfr-review-issue.yml@main'
    with:
      issueNumber: ${{ needs.select-issue.outputs.issueNumber }}
      target: ${{ inputs.target || 'src/lib/main.js' }}
      missionFile: 'MISSION.md'
      testFile: ${{ inputs.testFile || 'tests/unit/main.test.js' }}
      readmeFile: 'README.md'
      contributingFile: 'CONTRIBUTING.md'
      dependenciesFile: 'package.json'
      buildScript: 'npm run build'
      testScript: 'npm test'
      mainScript: ${{ vars.MAIN_SCRIPT || 'npm run start' }}
      model: ${{ vars.CHATGPT_API_MODEL || 'o3-mini' }}
    secrets:
      CHATGPT_API_SECRET_KEY: ${{ secrets.CHATGPT_API_SECRET_KEY }}
.github/workflows/formating.yml
==== Content of .github/workflows/formating.yml ====
# .github/workflows/formating.yml
#
# This file is part of the example suite for `agentic-lib` see: https://github.com/xn-intenton-z2a/agentic-lib
# This file is licensed under the MIT License. For details, see LICENSE-MIT

name: ∞ Formatting
concurrency: agentic-lib
run-name: "Formatting [${{ github.ref_name }}]"

on:
  workflow_dispatch:
  schedule:
    - cron: '15 3 */7 * *' # schedule-1
    #- cron: '15 3 * * *' # schedule-2
    #- cron: '15 3 * * *' # schedule-3

jobs:

  check-branch:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write
    env:
      branchPrefix: 'agentic-lib-'
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.ref }}
      - name: Ensure there isn't already a branch for this prefix
        shell: bash
        run: |
          git fetch origin
          if git branch -r | grep -q 'origin/${{ env.branchPrefix }}'; then
            echo "A branch with the prefix '${{ env.branchPrefix }}' already exists."
            exit 1
          else
            echo "No existing branch with the prefix found."
          fi

  formatting:
    needs:
      - check-branch
    permissions:
      contents: write
      packages: write
      id-token: write
    uses: 'xn-intenton-z2a/agentic-lib/.github/workflows/wfr-run-script-and-commit-to-branch.yml@main'
    with:
      script: 'npm run formatting-fix -- src/lib/main.js tests/unit/main.test.js ; npm run linting-fix src/lib/main.js tests/unit/main.test.js'
      sarifScript: ''
      testScript: 'npm test'
      branch: 'agentic-lib-formatting'
      gitUserEmail: 'action@github.com'
      gitUserName: 'GitHub Actions[bot]'
      gitCommitMessage: 'Updated by `npm run formatting-fix -- "." ; npm run linting-fix "."`'

  create-pr:
    needs:
      - formatting
    if: ${{ needs.formatting.outputs.updatedFiles == 'true' }}
    permissions:
      contents: write
      packages: write
      issues: write
      pull-requests: write
      checks: write
      id-token: write
    uses: 'xn-intenton-z2a/agentic-lib/.github/workflows/wfr-create-pr.yml@main'
    with:
      branch: 'agentic-lib-formatting'
      baseBranch: 'main'
      gitCommitMessage: 'chore: formatting fixes'
      label: 'automerge'
.github/workflows/wfr-automerge-find-pr-in-check-suite.yml
==== Content of .github/workflows/wfr-automerge-find-pr-in-check-suite.yml ====
# .github/workflows/wfr-automerge-find-pr-in-check-suite.yml

#
# agentic-lib
# Copyright (C) 2025 Polycode Limited
#
# This file is part of agentic-lib.
#
# agentic-lib is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License v3.0 (GPL‑3).
# along with this program. If not, see <https://www.gnu.org/licenses/>.
#
# IMPORTANT: Any derived work must include the following attribution:
# "This work is derived from https://github.com/xn-intenton-z2a/agentic-lib"
#

name: ∞ automerge-find-pr-in-check-suite

on:
  workflow_call:
    inputs:
      s3BucketUrl:
        description: 'The S3 bucket URL with prefix to use. e.g. "s3://my-bucket/prefix"'
        type: string
        required: false
        default: ''
      iamRoleArn:
        description: 'The ARN of the IAM role to assume. e.g. "arn:aws:iam::123456789012:role/my-role"'
        type: string
        required: false
        default: ''
    secrets:
      PERSONAL_ACCESS_TOKEN:
        required: false
    outputs:
      pullNumber:
        description: 'The pull request number.'
        value: ${{ jobs.check-pr.outputs.pullNumber }}
      shouldSkipMerge:
        description: 'Set to "true", if the merge request should be skipped because there is not a PR in the right state.'
        value: ${{ jobs.check-pr.outputs.shouldSkipMerge }}
      prMerged:
        description: 'Set to "true", if the PR has been merged either already or by this process.'
        value: ${{ jobs.check-pr.outputs.prMerged }}

jobs:
  find-pr:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: find-pr
        id: find-pr
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PERSONAL_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}
          script: |            
            const checkSuite = context.payload.check_suite;
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const headSha = checkSuite.head_sha;
            let pullNumber;
            let shouldSkipMerge;
            let prMerged;
            
            const { data: prs } = await github.rest.repos.listPullRequestsAssociatedWithCommit({
              owner,
              repo,
              commit_sha: headSha,
            });

            if (prs.length === 0) {
              core.info('No pull requests associated with this check suite.');            
              pullNumber = '';
              shouldSkipMerge = 'true';
              prMerged = 'false';
            } else {

              const openPRs = prs.filter(pr => pr.state === 'open');
              const prWithAutomerge = openPRs.find(pr => pr.labels.some(label => label.name === 'automerge'));
  
              if (!prWithAutomerge) {
                core.info('No open pull requests with the "automerge" label.');
                pullNumber = undefined;
                shouldSkipMerge = 'true';
                prMerged = 'false';
              } else {
                core.info(`Open pull request with the "automerge" label: ${prWithAutomerge.number}`);
                pullNumber = prWithAutomerge.number;
                shouldSkipMerge = 'false';
                prMerged = 'false';
              }
              
              core.setOutput('pullNumber', !pullNumber ? '' : pullNumber.toString());
              core.setOutput('shouldSkipMerge', shouldSkipMerge);
              core.setOutput('prMerged', prMerged);
              core.info(`pullNumber: '${!pullNumber ? '' : pullNumber.toString()}`);
              core.info(`shouldSkipMerge: '${shouldSkipMerge}'`);
              core.info(`prMerged: '${prMerged}'`);
            }

    outputs:
      pullNumber: ${{ steps.find-pr.outputs.pullNumber }}
      shouldSkipMerge: ${{ steps.find-pr.outputs.shouldSkipMerge }}
      prMerged: ${{ steps.find-pr.outputs.prMerged }}

.github/workflows/wfr-select-issue.yml
==== Content of .github/workflows/wfr-select-issue.yml ====
# .github/workflows/wfr-select-issue.yml

#
# agentic-lib
# Copyright (C) 2025 Polycode Limited
#
# This file is part of agentic-lib.
#
# agentic-lib is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License v3.0 (GPL‑3).
# along with this program. If not, see <https://www.gnu.org/licenses/>.
#
# IMPORTANT: Any derived work must include the following attribution:
# "This work is derived from https://github.com/xn-intenton-z2a/agentic-lib"
#

name: ∞ select-issue

on:
  workflow_call:
    inputs:
      issueNumber:
        description: 'The issue number to review. e.g. "123"'
        type: string
        required: true
      selectionLabel:
        description: 'Label used to filter issues for review. e.g. "merged"'
        required: false
        type: string
        default: 'merged'
    secrets:
      PERSONAL_ACCESS_TOKEN:
        required: false
      CHATGPT_API_SECRET_KEY:
        required: true
    outputs:
      issueNumber:
        description: 'The issue number to review. e.g. "123"'
        value: ${{ jobs.select-issue.outputs.issueNumber }}
      merged:
        description: 'Set to "true", if the issue has been merged either already or by this process.'
        value: ${{ jobs.select-issue.outputs.merged }}

jobs:
  select-issue:
    runs-on: ubuntu-latest

    env:
      issueNumber: ${{ inputs.issueNumber }}
      selectionLabel: ${{ inputs.selectionLabel || 'merged' }}

    steps:
      - uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: select-issue
        id: select-issue
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PERSONAL_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}
          script: |
            const issueNumberInput = process.env.issueNumber;
            const selectionLabel = process.env.selectionLabel;
            let issueNumberOutput;
            
            let issue;
            if (issueNumberInput) {
              const { data: issue } = await github.rest.issues.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: parseInt(issueNumberInput)
              });
            
              if (!issue) {
                issueNumberOutput = '';
                core.info(`No issue found with number: ${issueNumberInput}`);
              } else {
                issueNumberOutput = issue.number;
                core.info(`Found issue with number: ${issueNumberInput}`);
              }
            } else {
              const { data: issues } = await github.rest.issues.listForRepo({
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: 'open',
                labels: selectionLabel,
                per_page: 5
              });
            
              if (issues.length === 0) {
                issueNumberOutput = '';
                core.info(`No open issues found with label: "${selectionLabel}"`);
              } else {
                issueNumberOutput = issues[0].number;
                core.info(`Open issue '${issueNumberOutput}' found with label: '${selectionLabel}'`);
              }
            }
            
            core.setOutput("issueNumber", issueNumberOutput);
            core.info(`issueNumber '${issueNumberOutput}'`);

      - name: has-merged-label
        id: has-merged-label
        if: steps.select-issue.outputs.issueNumber != ''
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PERSONAL_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}
          script: |
            const issueNumber = parseInt("${{ steps.select-issue.outputs.issueNumber }}");
            const { data: issue } = await github.rest.issues.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber
            });
            
            const merged = issue.labels.some(label => label.name.toLowerCase() === "merged") ? "true" : "false";
            
            core.setOutput("merged", merged);
            core.info(`merged '${merged}'`);

    outputs:
      issueNumber: ${{ steps.select-issue.outputs.issueNumber }}
      merged: ${{ steps.has-merged-label.outputs.merged }}
.github/schedule.yml
==== Content of .github/schedule.yml ====
# Which agentic-lib workflow schedule should be used?
schedule: schedule-1
.github/dependabot.yml
==== Content of .github/dependabot.yml ====
# See: https://docs.github.com/code-security/dependabot/dependabot-version-updates/configuration-options-for-the-dependabot.yml-file
version: 2
updates:
  - package-ecosystem: "npm"
    directory: "/"
    schedule:
      interval: "weekly"
    labels:
      - dependencies
      - automated
    #ignore:
    #  - dependency-name: "some-dependency" # Example of ignoring a specific dependency
    #    versions: ["1.x", "2.x"]