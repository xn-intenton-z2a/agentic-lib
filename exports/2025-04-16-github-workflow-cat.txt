.github/FUNDING.yml
==== Content of .github/FUNDING.yml ====
github: Antony-at-Polycode
# paypal: https://www.paypal.com/donate/?hosted_button_id=Y8PK8XP3EJLWG
.github/workflows/wfr-github-find-pr-in-check-suite.yml
==== Content of .github/workflows/wfr-github-find-pr-in-check-suite.yml ====
# .github/workflows/wfr-github-find-pr-in-check-suite.yml

#
# agentic-lib
# Copyright (C) 2025 Polycode Limited
#
# This file is part of agentic-lib.
#
# agentic-lib is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License v3.0 (GPL‑3).
# along with this program. If not, see <https://www.gnu.org/licenses/>.
#
# IMPORTANT: Any derived work must include the following attribution:
# "This work is derived from https://github.com/xn-intenton-z2a/agentic-lib"
#

name: ∞ automerge-find-pr-in-check-suite

on:
  workflow_call:
    inputs:
      cache:
        description: 'The cache to use for npm. e.g. "npm"'
        type: string
        required: false
        default: 'npm'
      s3BucketUrl:
        description: 'The S3 bucket URL with prefix to use. e.g. "s3://my-bucket/prefix"'
        type: string
        required: false
        default: ''
      iamRoleArn:
        description: 'The ARN of the IAM role to assume. e.g. "arn:aws:iam::123456789012:role/my-role"'
        type: string
        required: false
        default: ''
    secrets:
      PERSONAL_ACCESS_TOKEN:
        required: false
    outputs:
      pullNumber:
        description: 'The pull request number.'
        value: ${{ jobs.check-pr.outputs.pullNumber }}
      shouldSkipMerge:
        description: 'Set to "true", if the merge request should be skipped because there is not a PR in the right state.'
        value: ${{ jobs.check-pr.outputs.shouldSkipMerge }}
      prMerged:
        description: 'Set to "true", if the PR has been merged either already or by this process.'
        value: ${{ jobs.check-pr.outputs.prMerged }}

jobs:
  find-pr:
    runs-on: ubuntu-latest

    env:
      cache: ${{ inputs.cache || 'npm' }}
      s3BucketUrl: ${{ inputs.s3BucketUrl || '' }}
      iamRoleArn: ${{ inputs.iamRoleArn || '' }}

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: ${{ env.cache }}

      - name: find-pr
        id: find-pr
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PERSONAL_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}
          script: |            
            const checkSuite = context.payload.check_suite;
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const headSha = checkSuite.head_sha;
            let pullNumber;
            let shouldSkipMerge;
            let prMerged;
            
            const { data: prs } = await github.rest.repos.listPullRequestsAssociatedWithCommit({
              owner,
              repo,
              commit_sha: headSha,
            });

            if (prs.length === 0) {
              core.info('No pull requests associated with this check suite.');            
              pullNumber = '';
              shouldSkipMerge = 'true';
              prMerged = 'false';
            } else {

              const openPRs = prs.filter(pr => pr.state === 'open');
              const prWithAutomerge = openPRs.find(pr => pr.labels.some(label => label.name === 'automerge'));
  
              if (!prWithAutomerge) {
                core.info('No open pull requests with the "automerge" label.');
                pullNumber = undefined;
                shouldSkipMerge = 'true';
                prMerged = 'false';
              } else {
                core.info(`Open pull request with the "automerge" label: ${prWithAutomerge.number}`);
                pullNumber = prWithAutomerge.number;
                shouldSkipMerge = 'false';
                prMerged = 'false';
              }
              
              core.setOutput('pullNumber', !pullNumber ? '' : pullNumber.toString());
              core.setOutput('shouldSkipMerge', shouldSkipMerge);
              core.setOutput('prMerged', prMerged);
              core.info(`pullNumber: '${!pullNumber ? '' : pullNumber.toString()}`);
              core.info(`shouldSkipMerge: '${shouldSkipMerge}'`);
              core.info(`prMerged: '${prMerged}'`);
            }

    outputs:
      pullNumber: ${{ steps.find-pr.outputs.pullNumber }}
      shouldSkipMerge: ${{ steps.find-pr.outputs.shouldSkipMerge }}
      prMerged: ${{ steps.find-pr.outputs.prMerged }}

.github/workflows/wfr-completion-generate-feature-development-issue.yml
==== Content of .github/workflows/wfr-completion-generate-feature-development-issue.yml ====
# .github/workflows/wfr-completion-generate-feature-development-issue.yml

#
# agentic-lib
# Copyright (C) 2025 Polycode Limited
#
# This file is part of agentic-lib.
#
# agentic-lib is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License v3.0 (GPL‑3).
# along with this program. If not, see <https://www.gnu.org/licenses/>.
#
# IMPORTANT: Any derived work must include the following attribution:
# "This work is derived from https://github.com/xn-intenton-z2a/agentic-lib"
#

name: ∞ generate-feature-development-issue

on:
  workflow_call:
    inputs:
      featureName:
        description: 'name of the feature to create an issue for. e.g. "WEBSITE"'
        type: string
        required: true
      featuresDir:
        description: 'The directory to create/update the features in. e.g. "features/"'
        type: string
        required: false
        default: 'features/'
      featureDevelopmentIssuesWipLimit:
        description: 'The WIP limit for the feature development issues. e.g. "5"'
        type: string
        required: false
        default: '5'
      target:
        description: 'The target file to create the issue to change. e.g. "src/lib/main.js"'
        type: string
        required: false
        default: 'src/lib/main.js'
      testFile:
        description: 'The test file. e.g. "tests/unit/main.test.js"'
        type: string
        required: false
        default: 'tests/unit/main.test.js'
      readmeFile:
        description: 'The README file. e.g. "README.md"'
        type: string
        required: false
        default: 'README.md'
      missionFile:
        description: 'The MISSION statement file. e.g. "MISSION.md"'
        type: string
        required: false
        default: 'MISSION.md'
      contributingFile:
        description: 'The CONTRIBUTING file. e.g. "CONTRIBUTING.md"'
        type: string
        required: false
        default: 'CONTRIBUTING.md'
      dependenciesFile:
        description: 'The dependencies file. e.g. "package.json"'
        type: string
        required: false
        default: 'package.json'
      buildScript:
        description: 'The script must be runnable as: `npm ci ; <script>` and succeed with a zero exit code. e.g. `npm run build`'
        type: string
        required: false
        default: 'echo "No build script specified."'
      testScript:
        description: 'The script must be runnable as: `npm ci ; <script>` and succeed with a zero exit code. e.g. `npm test`'
        type: string
        required: false
        default: 'npm test'
      issueSelectionLabel:
        description: 'Label used to filter issues for review. e.g. "feature"'
        required: false
        type: string
        default: 'feature'
      mainScript:
        description: 'The script must be runnable as: `npm ci ; <script>` and succeed with a zero exit code. e.g. `npm run start`'
        type: string
        required: false
        default: 'npm run start'
      model:
        description: 'The OpenAI model to use. e.g. "o3-mini"'
        type: string
        required: false
        default: ${{ vars.CHATGPT_API_MODEL || 'o3-mini' }}
      npmAuthOrganisation:
        description: 'The GitHub organisation to authenticate with for npm. e.g. "xn-intenton-z2a"'
        type: string
        required: false
        default: ''
      s3BucketUrl:
        description: 'The S3 bucket URL with prefix to use. e.g. "s3://my-bucket/prefix"'
        type: string
        required: false
        default: ''
      iamRoleArn:
        description: 'The ARN of the IAM role to assume. e.g. "arn:aws:iam::123456789012:role/my-role"'
        type: string
        required: false
        default: ''
    secrets:
      PERSONAL_ACCESS_TOKEN:
        required: false
      CHATGPT_API_SECRET_KEY:
        required: true
    outputs:
      issueTitle:
        value: ${{ jobs.generate-feature-development-issue.outputs.issueTitle }}
      issueDescription:
        value: ${{ jobs.generate-feature-development-issue.outputs.issueDescription }}

jobs:
  generate-feature-development-issue:
    runs-on: ubuntu-latest

    env:
      featureName: ${{ inputs.featureName || '' }}
      featuresDir: ${{ inputs.featuresDir || 'features/' }}
      featureDevelopmentIssuesWipLimit: ${{ inputs.featureDevelopmentIssuesWipLimit || '5' }}
      target: ${{ inputs.target || 'src/lib/main.js' }}
      testFile: ${{ inputs.testFile || 'tests/unit/main.test.js' }}
      readmeFile: ${{ inputs.readmeFile || 'README.md' }}
      missionFile: ${{ inputs.missionFile || 'MISSION.md' }}
      contributingFile: ${{ inputs.contributingFile || 'CONTRIBUTING.md' }}
      dependenciesFile: ${{ inputs.dependenciesFile || 'package.json' }}
      buildScript: ${{ inputs.buildScript || 'npm run build' }}
      testScript: ${{ inputs.testScript || 'npm test' }}
      mainScript: ${{ inputs.mainScript || 'npm run start' }}
      issueSelectionLabel: ${{ inputs.issueSelectionLabel || 'feature' }}
      mainScriptTimeout: '5m'
      model: ${{ inputs.model || vars.CHATGPT_API_MODEL || 'o3-mini' }}
      npmAuthOrganisation: ${{ inputs.npmAuthOrganisation || '' }}
      chatgptApiSecretKey: ${{ secrets.CHATGPT_API_SECRET_KEY }}
      s3BucketUrl: ${{ inputs.s3BucketUrl || '' }}
      iamRoleArn: ${{ inputs.iamRoleArn || '' }}

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Check GitHub authentication
        if: ${{ env.npmAuthOrganisation != '' }}
        shell: bash
        run: |
          curl --include --header "Authorization: token ${{ secrets.PERSONAL_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}" https://api.github.com/user

      - name: Set up .npmrc
        if: ${{ env.npmAuthOrganisation != '' }}
        shell: bash
        run: |
          echo "${{ env.npmAuthOrganisation }}:registry=https://npm.pkg.github.com" >> .npmrc
          echo "//npm.pkg.github.com/:_authToken=${{ secrets.PERSONAL_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}" >> .npmrc
          echo "always-auth=true" >> .npmrc

      - run: npm ci

      - name: List current features
        id: features
        shell: bash
        run: |
          output=$(find "${{ env.featuresDir }}" -maxdepth 1 -type f -name '*.md' -print -exec echo "# {}" \; -exec cat {} \; 2>&1 || echo 'none')
          echo "output<<EOF" >> "$GITHUB_OUTPUT"
          echo "$output" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          echo "output=${output}"

      - name: List dependencies
        id: list
        shell: bash
        run: |
          output=$(npm list 2>&1)
          echo "output<<EOF" >> "$GITHUB_OUTPUT"
          echo "$output" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          echo "output=${output}"

      - name: Build project
        id: build
        shell: bash
        run: |
          output=$(${{ env.buildScript }} 2>&1)
          echo "output<<EOF" >> "$GITHUB_OUTPUT"
          echo "$output" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          echo "output=${output}"

      - name: Tear down .npmrc
        if: ${{ env.npmAuthOrganisation != '' }}
        shell: bash
        run: rm -f .npmrc

      - name: Run tests
        id: test
        shell: bash
        run: |
          output=$(${{ env.testScript }} 2>&1)
          echo "output<<EOF" >> "$GITHUB_OUTPUT"
          echo "$output" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          echo "output=${output}"

      - name: Run main
        id: main
        shell: bash
        run: |
          output=$(timeout ${{ env.mainScriptTimeout }} ${{ env.mainScript }} 2>&1)
          echo "output<<EOF" >> "$GITHUB_OUTPUT"
          echo "$output" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          echo "output=${output}"

      - name: generate-feature-development-issue
        id: generate-feature-development-issue
        uses: actions/github-script@v7
        env:
          dependenciesListOutput: ${{ steps.list.outputs.output }}
          buildOutput: ${{ steps.build.outputs.output }}
          testOutput: ${{ steps.test.outputs.output }}
          mainOutput: ${{ steps.main.outputs.output }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const featureName = process.env.featureName;
            const currentFeatures = process.env.currentFeatures;
            const featureDevelopmentIssuesWipLimit = process.env.featureDevelopmentIssuesWipLimit;
            const target = process.env.target;
            const testFile = process.env.testFile;
            const readmeFile = process.env.readmeFile;
            const missionFile = process.env.missionFile;
            const contributingFile = process.env.contributingFile;
            const dependenciesFile = process.env.dependenciesFile;
            const model = process.env.model;
            const apiKey = process.env.chatgptApiSecretKey;
            const dependenciesListOutput = process.env.dependenciesListOutput;
            const buildScript = process.env.buildScript;
            const buildOutput = process.env.buildOutput;
            const testScript = process.env.testScript;
            const testOutput = process.env.testOutput;
            const mainScript = process.env.mainScript;
            const mainOutput = process.env.mainOutput;
            const issueSelectionLabel = process.env.issueSelectionLabel;

            const fs = require('fs');
            const OpenAI = require('openai').default;
            const { z } = require('zod');
            require('dotenv').config();

            // Gather the titles of all open issues
            const openIssues = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              labels: issueSelectionLabel
            });
            core.info(`Open issues: ${JSON.stringify(openIssues)}`);
            const openIssueTitles = openIssues.data.map(issue => issue.title).join(', ');
            core.info(`Open issue titles: ${openIssueTitles}`);
            if (openIssues.data.length >= featureDevelopmentIssuesWipLimit) {
              core.setFailed(`There are already ${featureDevelopmentIssuesWipLimit} open issues with the label '${issueSelectionLabel}'.`);
            }
            
            if (!apiKey) { 
              core.setFailed("Missing CHATGPT_API_SECRET_KEY"); 
            }
            const openai = new OpenAI({ apiKey });

            core.info(`featureName: "${featureName}"`); 
            core.info(`currentFeatures: "${currentFeatures}"`);
            core.info(`featureDevelopmentIssuesWipLimit: "${featureDevelopmentIssuesWipLimit}"`);
            core.info(`target: "${target}"`);
            core.info(`testFile: "${testFile}"`);
            core.info(`readmeFile: "${readmeFile}"`);
            core.info(`missionFile: "${missionFile}"`);
            core.info(`contributingFile: "${contributingFile}"`);
            core.info(`dependenciesFile: "${dependenciesFile}"`);
            const sourceFileContent = fs.readFileSync(target, 'utf8');
            const testFileContent = fs.readFileSync(testFile, 'utf8');
            const readmeFileContent = fs.readFileSync(readmeFile, 'utf8');
            const missionFileContent = fs.readFileSync(missionFile, 'utf8');
            const contributingFileContent = fs.readFileSync(contributingFile, 'utf8');
            const dependenciesFileContent = fs.readFileSync(dependenciesFile, 'utf8');
            core.info(`Target file '${target}' has been loaded (length ${sourceFileContent.length}).`);
            core.info(`Test file '${testFile}' has been loaded (length ${testFileContent.length}).`);
            core.info(`Readme file '${readmeFile}' has been loaded (length ${readmeFileContent.length}).`);
            core.info(`Dependencies file '${dependenciesFile}' has been loaded (length ${dependenciesFileContent.length}).`);
            
            const chatGptPrompt = `
            Please generate the title and description of a GitHub issue to which will be used to further the development of the ${featureName} feature.
            You may only give instructions in the issues to only change the source file, test file, README file and dependencies file content. You may not create issues that request new files, delete existing files, or change the other files provided in the prompt context.
            Examine the details named feature ${featureName} in the current feature names and specifications, and evaluate the current state of the repository to determine which changes will implement the feature and allow it's value to be realised.
            The issue will be resolved by an LLM which can process over 200,000 tokens of context and it will provide completed source files in the response.
            Do not include steps that would need to be taken manually by a human and expect to "dry-run" without an execution environment.
            The maximum number of feature development issues that should be open at any one time is ${featureDevelopmentIssuesWipLimit}, if there are already ${featureDevelopmentIssuesWipLimit} open issues fail this request.
            Do not add valueless layers of validation, configuration, and abstraction. In particular do not create issues related to NaNs.
            Ensure that the issue is distinct from any existing open issues in the repository so that the new issue remains valid when the other open issues are closed.
            Consider the following when refining your response:
            * Prompt details
            * Current feature names and specifications in the repository
            * Source file content
            * Test file content
            * README file content
            * MISSION file content
            * Contributing file content
            * Dependencies file content
            * Dependency list
            * Build output
            * Test output
            * Main execution output
            * Open issue titles
            
            Current feature names and specifications:
            CURRENT_FEATURES_START
            ${currentFeatures}
            CURRENT_FEATURES_END
            
            Source file: ${target}
            SOURCE_FILE_START
            ${sourceFileContent}
            SOURCE_FILE_END
            
            Test file: ${testFile}
            TEST_FILE_START
            ${testFileContent}
            TEST_FILE_END

            README file: ${readmeFile}
            README_FILE_START
            ${readmeFileContent}
            README_FILE_END
            
            MISSION file: ${missionFile}
            MISSION_FILE_START
            ${missionFileContent}
            MISSION_FILE_END

            Contributing file: ${contributingFile}
            CONTRIBUTING_FILE_START
            ${contributingFileContent}
            CONTRIBUTING_FILE_END
            
            Dependencies file: ${dependenciesFile}
            DEPENDENCIES_FILE_START
            ${dependenciesFileContent}
            DEPENDENCIES_FILE_END          

            Dependencies list from command: npm list
            DEPENDENCIES_LIST_START
            ${dependenciesListOutput}
            DEPENDENCIES_LIST_END    
            
            Build output from command: ${buildScript}
            TEST_OUTPUT_START
            ${buildOutput}
            TEST_OUTPUT_END      
            
            Test output from command: ${testScript}
            TEST_OUTPUT_START
            ${testOutput}
            TEST_OUTPUT_END            

            Main output from command: ${mainScript}
            MAIN_OUTPUT_START
            ${mainOutput}
            MAIN_OUTPUT_END    
            
            Open issue titles:
            OPEN_ISSUE_TITLES_START
            ${openIssueTitles}
            OPEN_ISSUE_TITLES_END
            
            Answer strictly with a JSON object following this schema:
            {
              "issueTitle": "The title of the GitHub issue summarising the change",
              "issueDescription": "The description of the GitHub issue detailing the change and how to apply and verify it.",
            }
            Ensure valid JSON.
            `;
            
            const ResponseSchema = z.object({ issueTitle: z.string(), issueDescription: z.string() });
            
            // Define the function schema for function calling
            const tools = [{
              type: "function",
              function: {
                name: "generate_issue",
                description: "Further development of the feature through changes to the project files captured in the issueTitle and issueDescription of a GitHub Issue. Return an object with issueTitle (string), and issueDescription (string).",
                parameters: {
                  type: "object",
                  properties: {
                    issueTitle: { type: "string", description: "A summary of the change to make as a title." },
                    issueDescription: { type: "string", description: "Detail about the change, how to apply and verify it." }
                  },
                  required: ["issueTitle", "issueDescription"],
                  additionalProperties: false
                },
                strict: true
              }
            }];

            // Call OpenAI using function calling format
            const response = await openai.chat.completions.create({
              model,
              messages: [
                { role: "system", content: "You are raising a GitHub issue which will be processed by an LLM with a token limit of 200,000 tokens in order to manifest a specific named feature as code, tests or documentation. You will respond to the intention of the prompt using a detailed assessment of the current state of the repository, the current feature set and the mission statement. Answer strictly with a JSON object following the provided function schema." },
                { role: "user", content: chatGptPrompt }
              ],
              tools: tools
            });
            
            let result;
            if (response.choices[0].message.tool_calls && response.choices[0].message.tool_calls.length > 0) {
              try {
                result = JSON.parse(response.choices[0].message.tool_calls[0].function.arguments);
              } catch (e) {
                core.setFailed(`Failed to parse function call arguments: ${e.message}`);
              }
            } else if (response.choices[0].message.content) {
              try {
                result = JSON.parse(response.choices[0].message.content);
              } catch (e) {
                core.setFailed(`Failed to parse response content: ${e.message}`);
              }
            } else {
              core.setFailed("No valid response received from OpenAI.");
            }
            
            try {
              const parsed = ResponseSchema.parse(result);
              core.setOutput("issueTitle", parsed.issueTitle);
              core.setOutput("issueDescription", parsed.issueDescription);
              core.info(`issueTitle: "${parsed.issueTitle}"`);
              core.info(`issueDescription: "${parsed.issueDescription}"`);
            
            } catch (e) {
              core.setFailed(`Failed to parse ChatGPT response: ${e.message}`);
            }
            
            core.setOutput("response", JSON.stringify(response));
            core.setOutput("usage", JSON.stringify(response.usage));
            core.info(`response: "${JSON.stringify(response)}"`);
            core.info(`usage: "${JSON.stringify(response.usage)}"`);
    outputs:
      issueTitle: ${{ steps.generate-feature-development-issue.outputs.issueTitle }}
      issueDescription: ${{ steps.generate-feature-development-issue.outputs.issueDescription }}
.github/workflows/wfr-github-stats.yml
==== Content of .github/workflows/wfr-github-stats.yml ====
# .github/workflows/wfr-github-stats.yml

#
# agentic-lib
# Copyright (C) 2025 Polycode Limited
#
# This file is part of agentic-lib.
#
# agentic-lib is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License v3.0 (GPL‑3).
# along with this program. If not, see <https://www.gnu.org/licenses/>.
#
# IMPORTANT: Any derived work must include the following attribution:
# "This work is derived from https://github.com/xn-intenton-z2a/agentic-lib"
#

name: ∞ stats

on:
  workflow_call:
    inputs:
      public:
        description: 'The public directory to use. e.g. "public"'
        type: string
        required: false
        default: 'public'
      cache:
        description: 'The cache to use for npm. e.g. "npm"'
        type: string
        required: false
        default: 'npm'
      npmAuthOrganisation:
        description: 'The npm auth organisation to use. e.g. "@xn-intenton-z2a"'
        type: string
        required: false
      lastActivityName:
        description: 'The name of the last activity. e.g. "stats"'
        type: string
        required: false
      lastActivityBranchName:
        description: 'The name of the last activity branch. e.g. "main"'
        type: string
        required: false
      branchPrefix:
        description: 'The prefix for the issue branch. e.g. "agentic-lib-issue-"'
        type: string
        required: false
        default: 'agentic-lib-issue-'
      nextIssue:
        description: 'The next issue to review. e.g. "123 My issue automated"'
        type: string
        required: false
      publishToAWS:
        description: 'Whether to publish to AWS. e.g. "true"'
        type: string
        required: false
        default: 'true'
      publishToGitHubPages:
        description: 'Whether to publish to GitHub Pages. e.g. "true"'
        type: string
        required: false
        default: 'false'
      s3BucketUrl:
        description: 'The S3 bucket URL with prefix to use. e.g. "s3://my-bucket/prefix"'
        type: string
        required: false
        default: ''
      s3WebsiteBucketUrl:
        description: 'The S3 website bucket URL with prefix to use. e.g. "s3://my-website-bucket/"'
        type: string
        required: false
        default: ''
      iamActionsRoleArn:
        description: 'The ARN of the IAM role to assume. e.g. "arn:aws:iam::123456789012:role/my-role"'
        type: string
        required: false
        default: ''
      iamStatsBucketWriterRoleArn:
        description: 'The ARN of the IAM role to assume when writing to the stats bucket. e.g. "arn:aws:iam::123456789012:role/my-role"'
        type: string
        required: false
        default: ''
      iamPublicWebsiteStatsBucketWriterRoleArn:
        description: 'The ARN of the IAM role to assume when writing to the public website stats bucket. e.g. "arn:aws:iam::123456789012:role/my-role"'
        type: string
        required: false
        default: ''
    secrets:
      PERSONAL_ACCESS_TOKEN:
        required: false
    outputs:
      thisRepositoryStatsUrl:
        description: 'The URL of the latest stats page. e.g. "https://xn-intenton-z2a.github.io/agentic-lib/latest.html"'
        value: ${{ jobs.stats.outputs.thisRepositoryStatsUrl }}

jobs:
  stats:
    runs-on: ubuntu-latest

    env:
      public: ${{ inputs.public || 'public' }}
      cache: ${{ inputs.cache || 'npm' }}
      npmAuthOrganisation: ${{ inputs.npmAuthOrganisation || '' }}
      lastActivityName: ${{ inputs.lastActivityName || '' }}
      lastActivityBranchName: ${{ inputs.lastActivityBranchName || '' }}
      branchPrefix: ${{ inputs.branchPrefix || 'agentic-lib-issue-' }}
      nextIssue: ${{ inputs.nextIssue || '' }}
      publishToAWS: ${{ inputs.publishToAWS || 'true' }}
      publishToGitHubPages: ${{ inputs.publishToGitHubPages || 'false' }}
      s3BucketUrl: ${{ inputs.s3BucketUrl || '' }}
      s3WebsiteBucketUrl: ${{ inputs.s3WebsiteBucketUrl || '' }}
      iamActionsRoleArn: ${{ inputs.iamActionsRoleArn || '' }}
      iamStatsBucketWriterRoleArn: ${{ inputs.iamStatsBucketWriterRoleArn || '' }}
      iamPublicWebsiteStatsBucketWriterRoleArn: ${{ inputs.iamPublicWebsiteStatsBucketWriterRoleArn || '' }}

    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ github.ref }}
          fetch-depth: 0

      - uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: ${{ env.cache }}

      - name: Set up .npmrc
        shell: bash
        run: |
          echo "${{ env.npmAuthOrganisation }}:registry=https://npm.pkg.github.com" >> .npmrc
          echo "//npm.pkg.github.com/:_authToken=${{ secrets.PERSONAL_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}" >> .npmrc
          echo "always-auth=true" >> .npmrc

      - name: engine
        id: engine
        shell: bash
        run: |
          engine=$(grep '^schedule:' .github/agentic-lib.yml | awk '{print $2}')
          echo "engine=${engine}"
          echo "engine=${engine}" >> $GITHUB_OUTPUT

      - name: Generate raw JSON statistics file
        id: generate-json
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const path = require('path');
            const now = new Date();
            
            const { owner, repo } = context.repo;
            const engine = "${{ steps.engine.outputs.engine }}";
            const lastActivityName = "${{ env.lastActivityName }}";
            const lastActivityBranchName = "${{ env.lastActivityBranchName }}";
            const nextIssue = "${{ env.nextIssue }}";
            const branchPrefix = "${{ env.branchPrefix }}";
            
            // Open issues count
            const { data: issuesResp } = await github.rest.issues.listForRepo({ owner, repo, state: "open", per_page: 256 });
            
            // Issues closed in last hour and day
            const sinceOneHour = new Date(now.getTime() - (60 * 60 * 1000)).toISOString();
            const { data: closedHourResp } = await github.rest.issues.listForRepo({ owner, repo, state: "closed", since: sinceOneHour, per_page: 256 });
            const sinceOneDay = new Date(now.getTime() - (24 * 60 * 60 * 1000)).toISOString();
            const { data: closedDayResp } = await github.rest.issues.listForRepo({ owner, repo, state: "closed", since: sinceOneDay, per_page: 256 });
            
            // Open pull requests with age in minutes
            const { data: pullsResp } = await github.rest.pulls.list({ owner, repo, state: "open", per_page: 256 });
            const prDetails = pullsResp.map(pr => {
              const createdAt = new Date(pr.created_at);
              const ageMinutes = Math.floor((now - createdAt) / (1000 * 60));
              return { title: pr.title, ageMinutes };
            });
            const averagePRAge = prDetails.length > 0 ? Math.floor(prDetails.reduce((sum, pr) => sum + pr.ageMinutes, 0) / prDetails.length) : 0;
            
            // Repository push details
            const { data: repoResp } = await github.rest.repos.get({ owner, repo });
            const pushedAt = new Date(repoResp.pushed_at);
            const { data: mainBranchResp } = await github.rest.repos.getBranch({ owner, repo, branch: "main" });
            const mainPushedAt = new Date(mainBranchResp.commit.commit.author.date);
            
            // Commits in the last hour and day
            const { data: commitsLastHourResp }  = await github.rest.repos.listCommits({ owner, repo, since: sinceOneHour, per_page: 256 });
            const { data: commitsLastDayResp } = await github.rest.repos.listCommits({ owner, repo, since: sinceOneDay, per_page: 256 });
            
            // Last 5 commits on main
            const { data: lastFiveCommitsResp } = await github.rest.repos.listCommits({ owner, repo, sha: "main", per_page: 5 });
            const lastFiveCommitMessages = lastFiveCommitsResp.map(commit => {
              const commitDate = new Date(commit.commit.author.date);
              const hh = commitDate.getHours().toString().padStart(2, '0');
              const mm = commitDate.getMinutes().toString().padStart(2, '0');
              const message = commit.commit.message.length > 64 ? commit.commit.message.substring(0, 64) + "..." : commit.commit.message;
              return { time: `${hh}:${mm}`, message };
            });

            // Branches excluding "main" and "github-pages"
            const { data: branchesResp } = await github.rest.repos.listBranches({ owner, repo, per_page: 256 });
            const branchData = branchesResp.filter(branch => branch.name !== "main" && branch.name !== "github-pages");
            const branchDetails = await Promise.all(branchData.map(async branch => {
              const { data: branchResp } = await github.rest.repos.getBranch({ owner, repo, branch: branch.name });
              const lastCommitDate = new Date(branchResp.commit.commit.author.date);
              const minutesSinceLastCommit = Math.floor((now - lastCommitDate) / (1000 * 60));
              let issueNumber = '';
              let issueTitle = "";
              let issueLabels = "";
              const issueNumberMatch = branch.name.match(new RegExp(branchPrefix + "(\\d+)"));
              if (issueNumberMatch) {
                issueNumber = issueNumberMatch[1];
                const { data: issue } = await github.rest.issues.get({
                  owner,
                  repo,
                  issue_number: parseInt(issueNumber)
                });
                if (issue) {
                  issueTitle = issue.title;
                  issueLabels = issue.labels.map(label => label.name).join(', ');
                }
              }  
              return { branch: branch.name, issueNumber, issueTitle, issueLabels, minutesSinceLastCommit };
            }));
            const averageBranchAge = branchDetails.length > 0 ? Math.floor(branchDetails.reduce((sum, branch) => sum + branch.minutesSinceLastCommit, 0) / branchDetails.length) : 0;

            let checks = [];
            for (const branch of branchesResp) {
              core.info(`Checking branch: ${branch.name}`);
              const { data: branchResp } = await github.rest.repos.getBranch({ owner, repo, branch: branch.name });
              if( branchResp ) {
                const commitSha = branchResp.commit.sha;
                const { data: branchChecks } = await github.rest.checks.listForRef({
                  owner,
                  repo,
                  ref: commitSha,
                });
                //checks.push(...branchChecks.check_runs.map(check => {...check, branchName: branch.name, branch }));
                const checkRuns = branchChecks.check_runs.map(check => {
                  return {
                    ...check,
                    branchName: branch.name,
                    branch
                  };
                });
                checks.push(...checkRuns);
              } else {
                core.info(`Branch ${branch.name} not found.`);
              }
            }

            const jsonData = { 
              owner, 
              repo,
              engine,
              agenticLib: {
                schedule: engine
              },
              lastActivityName,
              lastActivityBranchName,
              repository: {
                count: repoResp.length,
                details: repoResp,
                owner, 
                repo,
                lastActivityName,
                lastActivityBranchName
              },
              nextIssue,
              openIssues: issuesResp.length,
              issuesClosedLastHour: closedHourResp.length,
              issuesClosedLastDay: closedDayResp.length,
              issues: {
                open: {
                  count: issuesResp.length, 
                  details: issuesResp,
                },
                closed: {
                  count: closedDayResp.length, 
                  details: closedDayResp
                },
                nextIssue,
                openIssues: issuesResp.length,
                issuesClosedLastHour: closedHourResp.length,
                issuesClosedLastDay: closedDayResp.length
              },
              openPRs: prDetails.length,
              averagePRAge: averagePRAge,
              prDetails: prDetails.map(pr => `[${pr.ageMinutes}m] ${pr.title}`),
              diffMinutes: Math.floor((now - pushedAt) / (1000 * 60)),
              diffMinutesMain: Math.floor((now - mainPushedAt) / (1000 * 60)),
              prs: {
                count: pullsResp.length, 
                details: pullsResp,
                openPRs: prDetails.length,
                averagePRAge: averagePRAge,
                prDetails: prDetails.map(pr => `[${pr.ageMinutes}m] ${pr.title}`),
                diffMinutes: Math.floor((now - pushedAt) / (1000 * 60)),
                diffMinutesMain: Math.floor((now - mainPushedAt) / (1000 * 60))
              },
              commitsLastHour: commitsLastHourResp.length,
              commitsLastDay: commitsLastDayResp.length,
              lastFiveCommitMessages: lastFiveCommitMessages.map(commit => `[${commit.time}] - ${commit.message}`),
              commits: {
                count: commitsLastDayResp.length, 
                details: commitsLastDayResp,
                commitsLastHour: commitsLastHourResp.length,
                commitsLastDay: commitsLastDayResp.length,
                lastFiveCommitMessages: lastFiveCommitMessages.map(commit => `[${commit.time}] - ${commit.message}`)
              },
              branches: { 
                count: branchDetails.length, 
                details: branchDetails.map(branch => `[${branch.minutesSinceLastCommit}m] ${branch.branch}`),
                countRaw: branchesResp.length, 
                detailsRaw: branchesResp,
                branchIssueDetails: branchDetails.map(branch => `[${branch.issueNumber}] ${branch.issueTitle} ${branch.issueLabels}`),
                averageBranchAge
              },
              checks: {
                count: checks.length,
                checks: checks,
                testStatusOnBranch: "PASS - placeholder",
                testsLastPassedMinutes: "15 - placeholder"
              },
              statsGeneratedAt: now.toISOString(),
              context,
              github
            };

            // Write JSON file
            const outputDir = "${{ env.public }}";
            if (!fs.existsSync(outputDir)) { fs.mkdirSync(outputDir); }
            const outputPath = path.join(outputDir, "${{ github.event.repository.name }}-stats.json");
            fs.writeFileSync(outputPath, JSON.stringify(jsonData, null, 2), "utf8");

            core.info(`JSON stats generated at ${outputPath}.`);
            core.setOutput("jsonStatsPath", outputPath);

      - name: Configure AWS Credentials
        if: ${{ env.publishToAWS == 'true' }}
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ env.iamActionsRoleArn }}
          role-chaining: false
          aws-region: eu-west-2
          audience: sts.amazonaws.com
          role-skip-session-tagging: true
          output-credentials: true
          retry-max-attempts: 3

      - run: aws sts get-caller-identity
        if: ${{ env.publishToAWS == 'true' }}

      - name: Configure AWS Credentials
        if: ${{ env.publishToAWS == 'true' }}
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ env.iamStatsBucketWriterRoleArn }}
          role-chaining: true
          aws-region: eu-west-2
          audience: sts.amazonaws.com
          role-skip-session-tagging: true
          output-credentials: true
          retry-max-attempts: 3

      - name: Upload JSON stats artifact to S3
        if: ${{ env.publishToAWS == 'true' }}
        shell: bash
        run: |
          aws s3 cp \
              ${{ steps.generate-json.outputs.jsonStatsPath }} \
              ${{ env.s3BucketUrl }}${{ github.event.repository.name }}-stats.json \
          ;

      - run: aws s3 ls ${{ env.s3BucketUrl }} --summarize
        if: ${{ env.publishToAWS == 'true' }}

      - name: Configure AWS Credentials (resetting back from the stats bucket writer role)
        if: ${{ env.publishToAWS == 'true' }}
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ env.iamActionsRoleArn }}
          role-chaining: false
          aws-region: eu-west-2
          audience: sts.amazonaws.com
          role-skip-session-tagging: true
          output-credentials: true
          retry-max-attempts: 3

      - run: aws sts get-caller-identity
        if: ${{ env.publishToAWS == 'true' }}

      - name: Configure AWS Credentials
        if: ${{ env.publishToAWS == 'true' }}
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ env.iamPublicWebsiteStatsBucketWriterRoleArn }}
          role-chaining: true
          aws-region: eu-west-2
          audience: sts.amazonaws.com
          role-skip-session-tagging: true
          output-credentials: true
          retry-max-attempts: 3

      - name: Upload JSON stats artifact to S3 website bucket
        if: ${{ env.publishToAWS == 'true' }}
        shell: bash
        run: |
          aws s3 cp \
              ${{ steps.generate-json.outputs.jsonStatsPath }} \
              ${{ env.s3WebsiteBucketUrl }}${{ github.event.repository.name }}-stats.json \
          ;

      - name: Upload website artefacts to S3 website bucket
        if: ${{ env.publishToAWS == 'true' }}
        shell: bash
        run: |
          aws s3 cp \
              ${{ steps.generate-json.outputs.jsonStatsPath }}  \
              ${{ env.s3WebsiteBucketUrl }}${{ github.event.repository.name }}-stats.json \
          ;
          aws s3 cp \
              ${{ env.public }}/stats.html \
              ${{ env.s3WebsiteBucketUrl }}stats.html \
          ;
          aws s3 cp \
              ${{ env.public }}/all.html \
              ${{ env.s3WebsiteBucketUrl }}index.html \
          ;

      - run: aws s3 ls ${{ env.s3WebsiteBucketUrl }} --summarize
        if: ${{ env.publishToAWS == 'true' }}

      - name: Output published website bucket pages URLs
        id: output-website-bucket-urls
        if: ${{ env.publishToAWS == 'true' }}
        shell: bash
        run: |
          s3WebsiteBucketUrl='${{ env.s3WebsiteBucketUrl }}'
          bucket=$(echo "${s3WebsiteBucketUrl?}" | sed -e 's|s3://||' -e 's|/$||')
          baseUrl="http://${bucket?}.s3-website.eu-west-2.amazonaws.com/"
          allRespositoryStatsUrl="${baseUrl?}"
          echo "${allRespositoryStatsUrl?}"
          echo "::notice:: allRespositoryStatsUrl: ${allRespositoryStatsUrl?}"
          echo "allRespositoryStatsUrl=${allRespositoryStatsUrl?}" >> $GITHUB_OUTPUT

      - name: Upload JSON stats artifact to GitHub
        uses: actions/upload-artifact@v4
        with:
          name: stats-json
          path: ${{ steps.generate-json.outputs.jsonStatsPath }}

      - run: npm install
        if: ${{ env.publishToGitHubPages == 'true' }}

      - name: Generate HTML page for statistics
        id: generate-html
        if: ${{ env.publishToGitHubPages == 'true' }}
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const path = require('path');
            const ejs = require('ejs');

            // Generate HTML contents from ${{ env.public }}/stats.html and the JSON file at ${{ steps.generate-json.outputs.jsonStatsPath }}
            const statsDataFilePath = "${{ steps.generate-json.outputs.jsonStatsPath }}";
            const statsData = JSON.parse(fs.readFileSync(statsDataFilePath, "utf8"));
            const htmlEJSTemlatePath = "${{ env.public }}/stats.html";
            const template = fs.readFileSync(htmlEJSTemlatePath, "utf8");
            const html = ejs.render(template, statsData);
              
            // Ensure the output directory exists.
            const outputDir = "${{ env.public }}";
            if (!fs.existsSync(outputDir)) {
              fs.mkdirSync(outputDir);
            }
            const outputPath = path.join(outputDir, "latest.html");
            fs.writeFileSync(outputPath, html, "utf8");
            core.info(`Static site generated at ${outputPath}.`);
            core.setOutput("sitePath", outputPath);

      - name: Generate index page
        if: ${{ env.publishToGitHubPages == 'true' }}
        shell: bash
        run: |
          ./scripts/md-to-html.js < README.md > ${{ env.public }}/index.agentic-lib.html
          cat ${{ env.public }}/index.agentic-lib.html | sed 's/agentic-lib/${{ github.event.repository.name }}/g' > ${{ env.public }}/index.html

      - name: Deploy to GitHub Pages
        if: ${{ env.publishToGitHubPages == 'true' }}
        uses: peaceiris/actions-gh-pages@v4
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: ${{ env.public }}
          publish_branch: github-pages
          keep_files: true
          enable_jekyll: 'true'

      - name: Upload generated site as artifact
        if: ${{ env.publishToGitHubPages == 'true' }}
        uses: actions/upload-artifact@v4
        with:
          name: site
          path: ${{ env.public }}

      - name: Output published github pages URLs
        if: ${{ env.publishToGitHubPages == 'true' }}
        id: output-pages-urls
        run: |
          echo "[INFO] Determining GitHub Pages URL..."
          # GitHub Pages URL typically: https://<owner>.github.io/<repo>/
          repoName=${{ github.event.repository.name }}
          owner=${{ github.repository_owner }}
          baseUrl="https://${owner}.github.io/${repoName}"
          thisRepositoryStatsUrl="${baseUrl}/latest.html"
          thisHomePageUrl="${baseUrl}/index.html"
          pwd
          echo "${{ env.public }}:"
          ls -larth "${{ env.public }}"
          echo "${{ env.public }}/latest.html:"
          ls -larth "${{ env.public }}/latest.html"
          echo "::notice:: thisRepositoryStatsUrl: ${thisRepositoryStatsUrl}"
          echo "thisRepositoryStatsUrl=${thisRepositoryStatsUrl}" >> $GITHUB_OUTPUT
          echo "::notice:: thisHomePageUrl: ${thisHomePageUrl}"
          echo "thisHomePageUrl=${thisHomePageUrl}" >> $GITHUB_OUTPUT

    outputs:
      thisRepositoryStatsUrl: ${{ steps.output-pages-urls.outputs.thisRepositoryStatsUrl }}
      websiteBucketUrl: ${{ steps.output-website-bucket-urls.outputs.allStatsUrl }}

.github/workflows/wfr-npm-publish.yml
==== Content of .github/workflows/wfr-npm-publish.yml ====
# .github/workflows/wfr-npm-publish.yml

#
# agentic-lib
# Copyright (C) 2025 Polycode Limited
#
# This file is part of agentic-lib.
#
# agentic-lib is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License v3.0 (GPL‑3).
# along with this program. If not, see <https://www.gnu.org/licenses/>.
#
# IMPORTANT: Any derived work must include the following attribution:
# "This work is derived from https://github.com/xn-intenton-z2a/agentic-lib"
#

name: ∞ publish-npm

on:
  workflow_call:
    inputs:
      versionIncrement:
        description: 'The Semantic Versioning segment to increment. One of: major | minor | patch | premajor | preminor | prepatch | prerelease.'
        required: true
        type: string
        default: 'prerelease'
      githubRelease:
        description: 'Whether to create a GitHub release. e.g. true'
        type: boolean
        required: false
        default: true
      buildScript:
        description: 'The script must be runnable as: `npm ci ; <script>` and succeed with a zero exit code. e.g. `npm run build`'
        type: string
        required: false
        default: 'echo "No build script specified."'
      cache:
        description: 'The cache to use for npm. e.g. "npm"'
        type: string
        required: false
        default: 'npm'
      releaseNotes:
        description: 'The release notes to use for the GitHub release. e.g. "Feature release."'
        type: string
        required: false
        default: 'Feature release.'
      npmAuthOrganisation:
        description: 'The GitHub organisation to authenticate with for npm. e.g. "xn-intenton-z2a"'
        type: string
        required: false
        default: ''
      gitUserEmail:
        description: 'The email to use for git commits. e.g. "action@github.com"'
        type: string
        required: false
        default: 'action@github.com'
      gitUserName:
        description: 'The name to use for git commits. e.g. "GitHub Actions[bot]"'
        type: string
        required: false
        default: 'GitHub Actions[bot]'
    secrets:
      PERSONAL_ACCESS_TOKEN:
        required: false
    outputs:
      releasedVersion:
        description: 'The version that was released. e.g. "1.0.1"'
        value: ${{ jobs.publish.outputs.releasedVersion }}
      newVersion:
        description: 'The version that was bumped to. e.g. "1.0.2-0"'
        value: ${{ jobs.publish.outputs.newVersion }}

jobs:
  publish:
    runs-on: ubuntu-latest

    env:
      versionIncrement: ${{ inputs.versionIncrement || 'prerelease' }}
      buildScript: ${{ inputs.buildScript || 'npm run build' }}
      cache: ${{ inputs.cache || 'npm' }}
      releaseNotes: ${{ inputs.releaseNotes || 'Feature release.' }}
      npmAuthOrganisation: ${{ inputs.npmAuthOrganisation || '' }}
      gitUserEmail: ${{ inputs.gitUserEmail || 'action@github.com' }}
      gitUserName: ${{ inputs.gitUserName || 'GitHub Actions[bot]' }}
      gitCommitMessage: |
        ${{ inputs.gitCommitMessage || 'chore: dependency updates' }}

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: ${{ env.cache }}

      - name: Check GitHub authentication
        if: ${{ env.npmAuthOrganisation != '' }}
        shell: bash
        run: |
          curl --include --header "Authorization: token ${{ secrets.PERSONAL_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}" https://api.github.com/user

      - name: Set up .npmrc
        if: ${{ env.npmAuthOrganisation != '' }}
        shell: bash
        run: |
          echo "${{ env.npmAuthOrganisation }}:registry=https://npm.pkg.github.com" >> .npmrc
          echo "//npm.pkg.github.com/:_authToken=${{ secrets.PERSONAL_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}" >> .npmrc
          echo "always-auth=true" >> .npmrc

      - name: Install dependencies
        run: npm ci

      - name: Set up .npmrc with only the GitHub token
        if: ${{ env.npmAuthOrganisation != '' }}
        shell: bash
        run: |
          echo "${{ env.npmAuthOrganisation }}:registry=https://npm.pkg.github.com" >> .npmrc
          echo "//npm.pkg.github.com/:_authToken=${{ secrets.GITHUB_TOKEN }}" >> .npmrc
          echo "always-auth=true" >> .npmrc

      - name: Build project before publishing begins
        id: build
        shell: bash
        run: ${{ env.buildScript }}

      - name: Examine the git working copy (should have no changes)
        shell: bash
        run: |
          git config --local user.email '${{ env.gitUserEmail }}'
          git config --local user.name '${{ env.gitUserName }}'
          git status -v

      - name: Get latest from remote
        run: |
          git config --local user.email "${{ env.gitUserEmail }}"
          git config --local user.name "${{ env.gitUserName }}"
          git pull --ff-only origin ${{ github.ref }}

      - name: released
        id: released
        if: ${{ env.versionIncrement == 'major' || env.versionIncrement == 'minor' || env.versionIncrement == 'patch' }}
        shell: bash
        run: |
          unset PERSONAL_ACCESS_TOKEN
          npm version ${{ env.versionIncrement }}
          ${{ env.buildScript }}
          npm publish --tag latest --access restricted
          git push --follow-tags
          releasedVersion=$(node -p "require('./package.json').version")
          echo "releasedVersion=${releasedVersion}" >> $GITHUB_OUTPUT
          echo "releasedVersion=${releasedVersion}"
        #env:
        #  PERSONAL_ACCESS_TOKEN: ""

      - name: Create GitHub Release
        if: ${{ inputs.githubRelease == 'true' || env.versionIncrement == 'major' || env.versionIncrement == 'minor' || env.versionIncrement == 'patch' }}
        uses: ncipollo/release-action@v1
        with:
          tag: ${{ steps.released.outputs.releasedVersion }}
          name: Release ${{ steps.released.outputs.releasedVersion }}
          body: ${{ env.releaseNotes }}

      - name: Rotate to next prepatch version from a released version
        if: ${{ env.versionIncrement == 'major' || env.versionIncrement == 'minor' || env.versionIncrement == 'patch' }}
        shell: bash
        run: |
          npm version --no-git-tag-version prepatch

      - name: Rotate to next [premajor|preminor|prepatch|prerelease] version
        if: ${{ env.versionIncrement == 'premajor' || env.versionIncrement == 'preminor' || env.versionIncrement == 'prepatch' || env.versionIncrement == 'prerelease' }}
        shell: bash
        run: |
          npm version --no-git-tag-version ${{ env.versionIncrement }}

      - name: rotated
        id: rotated
        shell: bash
        run: |
          newVersion=$(node -p "require('./package.json').version")
          echo "newVersion=${newVersion}" >> $GITHUB_OUTPUT
          echo "newVersion=${newVersion}"

      - name: Examine the git working copy
        shell: bash
        run: |
          git config --local user.email '${{ env.gitUserEmail }}'
          git config --local user.name '${{ env.gitUserName }}'
          git status -v

      - name: Run build after version bump
        run: ${{ env.buildScript }}

      - name: Examine the git working copy
        shell: bash
        run: |
          git config --local user.email '${{ env.gitUserEmail }}'
          git config --local user.name '${{ env.gitUserName }}'
          git status -v

      - name: Push version commit
        id: push
        shell: bash
        run: |
          git config --local user.email "${{ env.gitUserEmail }}"
          git config --local user.name "${{ env.gitUserName }}"
          git add -v --all
          newVersion=$(node -p "require('./package.json').version")
          git commit -m "${newVersion?}"
          git push origin HEAD

      - name: Tear down .npmrc
        if: ${{ env.npmAuthOrganisation != '' }}
        shell: bash
        run: rm -f .npmrc

      - name: Upload package.json artifact
        uses: actions/upload-artifact@v4
        with:
          name: package-json
          path: "./package.json"

      - name: Log final version
        shell: bash
        run: |
          echo "Final version: ${{ steps.rotated.outputs.newVersion }}"

    outputs:
      releasedVersion: ${{ steps.released.outputs.releasedVersion }}
      newVersion: ${{ steps.rotated.outputs.newVersion }}
.github/workflows/wfr-npm-run-script-and-commit-to-branch.yml
==== Content of .github/workflows/wfr-npm-run-script-and-commit-to-branch.yml ====
# .github/workflows/wfr-run-script-and-push-changes.yml

#
# agentic-lib
# Copyright (C) 2025 Polycode Limited
#
# This file is part of agentic-lib.
#
# agentic-lib is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License v3.0 (GPL‑3).
# along with this program. If not, see <https://www.gnu.org/licenses/>.
#
# IMPORTANT: Any derived work must include the following attribution:
# "This work is derived from https://github.com/xn-intenton-z2a/agentic-lib"
#

name: ∞ run-script-and-push-changes

on:
  workflow_call:
    inputs:
      script:
        description: 'The script must be runnable as: `npm ci ; <script>`.'
        type: string
        required: false
        default: ''
      sarifScript:
        description: 'The script must be runnable as: `npm ci ; <script>` and output a SARIF file. e.g. `npm run linting-json`'
        type: string
        required: false
        default: ''
      testScript:
        description: 'The script must be runnable as: `npm ci ; <script>` and succeed with a zero exit code. e.g. `npm test`'
        type: string
        required: false
        default: 'npm test'
      branch:
        description: 'The branch to push changes to. e.g. "apply-script"'
        type: string
        required: false
        default: ''
      npmAuthOrganisation:
        description: 'The GitHub organisation to authenticate with for npm. e.g. "xn-intenton-z2a"'
        type: string
        required: false
        default: ''
      gitUserEmail:
        description: 'The email to use for git commits. e.g. "action@github.com"'
        type: string
        required: false
        default: 'action@github.com'
      gitUserName:
        description: 'The name to use for git commits. e.g. "GitHub Actions[bot]"'
        type: string
        required: false
        default: 'GitHub Actions[bot]'
      cache:
        description: 'The cache to use for npm. e.g. "npm"'
        type: string
        required: false
        default: 'npm'
      gitCommitMessage:
        description: 'The message to use for git commits. e.g. "Updated by script"'
        type: string
        required: false
        default: 'Updated by script'
    secrets:
      PERSONAL_ACCESS_TOKEN:
        required: false
    outputs:
      updatedFiles:
          description: 'Whether files were updated by the script. e.g. "true"'
          value: ${{ jobs.update-and-push.outputs.updatedFiles }}
      scriptOutput:
        description: 'The output from running the script. '
        value: ${{ jobs.update-and-push.outputs.scriptOutput }}
      remainingResultsCount:
        description: 'The number of results from the SARIF script. e.g. "1"'
        value: ${{ jobs.update-and-push.outputs.remainingResultsCount }}
      fixStillRequired:
        description: 'Whether the SARIF script requires fixes. e.g. "true"'
        value: ${{ jobs.update-and-push.outputs.fixStillRequired }}

jobs:
  update-and-push:
    runs-on: ubuntu-latest

    env:
      script: ${{ inputs.script || '' }}
      sarifScript: ${{ inputs.sarifScript || '' }}
      testScript: ${{ inputs.testScript || 'npm test' }}
      branch: ${{ inputs.branch || '' }}
      npmAuthOrganisation: ${{ inputs.npmAuthOrganisation || '' }}
      gitUserEmail: ${{ inputs.gitUserEmail || 'action@github.com' }}
      gitUserName: ${{ inputs.gitUserName || 'GitHub Actions[bot]' }}
      cache: ${{ inputs.cache || 'npm' }}
      gitCommitMessage: ${{ inputs.gitCommitMessage || 'Updated by inputs.script' }}

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.ref }}

      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: ${{ env.cache }}

      - name: Check GitHub authentication
        if: ${{ env.npmAuthOrganisation != '' }}
        shell: bash
        run: |
          curl --include --header "Authorization: token ${{ secrets.PERSONAL_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}" https://api.github.com/user

      - name: Set up .npmrc
        if: ${{ env.npmAuthOrganisation != '' }}
        shell: bash
        run: |
          echo "${{ env.npmAuthOrganisation }}:registry=https://npm.pkg.github.com" >> .npmrc
          echo "//npm.pkg.github.com/:_authToken=${{ secrets.PERSONAL_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}" >> .npmrc
          echo "always-auth=true" >> .npmrc

      - name: Get latest from remote
        run: |
          git config --local user.email "${{ env.gitUserEmail }}"
          git config --local user.name "${{ env.gitUserName }}"
          git pull --ff-only origin ${{ github.ref }}

      - run: npm ci

      - name: script
        id: script
        if: ${{ env.script != '' }}
        shell: bash
        run: |
          set +e
          output=$(${{ env.script }} 2>&1)
          echo "output<<EOF" >> "$GITHUB_OUTPUT"
          echo "$output" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          echo "output=${output}"
          if git diff --quiet; then
            updated='false'
          else
            updated='true'
          fi
          set -e
          echo "updated=${updated}" >> $GITHUB_OUTPUT
          echo "updated=${updated}"
        continue-on-error: true

      - name: sarif-script
        id: sarif-script
        if: ${{ env.sarifScript != '' }}
        continue-on-error: true
        shell: bash
        run: |
          set +e
          results=$(${{ env.sarifScript }})
          exitCode="$?"
          set -e
          echo "exitCode=${exitCode}"
          fixStillRequired=$([ $? -eq 0 ] && echo 'true' || echo 'false')
          echo "fixStillRequired={fixStillRequired}" >> $GITHUB_OUTPUT
          echo "fixStillRequired=${fixStillRequired}"
          remainingResultsCount=$(echo "${results}" | jq '.runs[0].results | length' 2>/dev/null || echo "unknown")
          echo "remainingResultsCount=${remainingResultsCount}" >> $GITHUB_OUTPUT
          echo "remainingResultsCount=${remainingResultsCount}"
          echo "results: ${results}"

      - name: Test
        if: ${{ steps.script.outputs.updated == 'true' || env.git-force == 'true' }}
        shell: bash
        run: |
          ${{ env.testScript }}

      - name: Tear down npm auth
        if: ${{ env.npmAuthOrganisation != '' }}
        run: rm -vf .npmrc

      - name: Commit
        if: ${{ env.branch != '' && steps.script.outputs.updated == 'true' || env.git-force == 'true' }}
        shell: bash
        run: |
          git config --local user.email '${{ env.gitUserEmail }}'
          git config --local user.name '${{ env.gitUserName }}'
          git status -v
          git switch -c '${{ env.branch }}'
          git branch --set-upstream-to=origin/main
          git add -v --all
          git commit -v -m '${{ env.gitCommitMessage }}'
          git pull --rebase
          git push --set-upstream origin '${{ env.branch }}'
          git push -v
          git status -v

      - name: Log outputs
        continue-on-error: true
        shell: bash
        run: |
          echo "updatedFiles: steps.script.outputs.updated=${{ steps.script.outputs.updated }}"
          echo "scriptOutput: steps.script.outputs.output=${{ steps.script.outputs.output }}"
          echo "remainingResultsCount: steps.sarif-script.outputs.remainingResultsCount=${{ steps.sarif-script.outputs.remainingResultsCount }}"
          echo "fixStillRequired: steps.sarif-script.outputs.fixStillRequired=${{ steps.sarif-script.outputs.fixStillRequired }}"

    outputs:
      updatedFiles: ${{ steps.script.outputs.updated }}
      scriptOutput: ${{ steps.script.outputs.output }}
      remainingResultsCount: ${{ steps.sarif-script.outputs.remainingResultsCount }}
      fixStillRequired: ${{ steps.sarif-script.outputs.fixStillRequired }}
.github/workflows/wfr-completion-maintain-library.yml
==== Content of .github/workflows/wfr-completion-maintain-library.yml ====
# .github/workflows/wfr-completion-maintain-library.yml

#
# agentic-lib
# Copyright (C) 2025 Polycode Limited
#
# This file is part of agentic-lib.
#
# agentic-lib is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License v3.0 (GPL‑3).
# along with this program. If not, see <https://www.gnu.org/licenses/>.
#
# IMPORTANT: Any derived work must include the following attribution:
# "This work is derived from https://github.com/xn-intenton-z2a/agentic-lib"
#

name: ∞ maintain-library

on:
  workflow_call:
    inputs:
      document:
        description: 'Text to drive the library maintenance (if "house choice", the repository will be assessed and an action chosen). e.g. "Get a document about agents."'
        type: string
        required: false
        default: 'house choice'
      libraryDir:
        description: 'The directory to create/update the documents in. e.g. "library/"'
        type: string
        required: false
        default: 'library/'
      sourcesFile:
        description: 'The file containing the sources to extract sections from. e.g. "SOURCES.md"'
        type: string
        required: false
        default: 'SOURCES.md'
      documentsLimit:
        description: 'The maximum number of documents to have in the library to create. e.g. "3"'
        type: string
        required: false
        default: '3'
      summaryWordLimit:
        description: 'The maximum number of words for the URL content summary. e.g. "200"'
        type: string
        required: false
        default: '200'
      featuresDir:
        description: 'The directory containing feature files. e.g. "features/"'
        type: string
        required: false
        default: 'features/'
      target:
        description: 'The target file to create the issue to change. e.g. "src/lib/main.js"'
        type: string
        required: false
        default: 'src/lib/main.js'
      testFile:
        description: 'The test file. e.g. "tests/unit/main.test.js"'
        type: string
        required: false
        default: 'tests/unit/main.test.js'
      readmeFile:
        description: 'The README file. e.g. "README.md"'
        type: string
        required: false
        default: 'README.md'
      missionFile:
        description: 'The MISSION statement file. e.g. "MISSION.md"'
        type: string
        required: false
        default: 'MISSION.md'
      contributingFile:
        description: 'The CONTRIBUTING file. e.g. "CONTRIBUTING.md"'
        type: string
        required: false
        default: 'CONTRIBUTING.md'
      dependenciesFile:
        description: 'The dependencies file. e.g. "package.json"'
        type: string
        required: false
        default: 'package.json'
      buildScript:
        description: 'The script must be runnable as: `npm ci ; <script>` and succeed with a zero exit code. e.g. `npm run build`'
        type: string
        required: false
        default: 'echo "No build script specified."'
      testScript:
        description: 'The script must be runnable as: `npm ci ; <script>` and succeed with a zero exit code. e.g. `npm test`'
        type: string
        required: false
        default: 'npm test'
      mainScript:
        description: 'The script must be runnable as: `npm ci ; <script>` and succeed with a zero exit code. e.g. `npm run start`'
        type: string
        required: false
        default: 'npm run start'
      mainScriptTimeout:
        description: 'The timeout for the main script. e.g. "5m"'
        type: string
        required: false
        default: '5m'
      testScriptTimeout:
        description: 'The timeout for the test script. e.g. "5m"'
        type: string
        required: false
        default: '5m'
      buildScriptTimeout:
        description: 'The timeout for the build script. e.g. "5m"'
        type: string
        required: false
        default: '5m'
      model:
        description: 'The OpenAI model to use. e.g. "o3-mini"'
        type: string
        required: false
        default: ${{ vars.CHATGPT_API_MODEL || 'o3-mini' }}
      npmAuthOrganisation:
        description: 'The GitHub organisation to authenticate with for npm. e.g. "xn-intenton-z2a"'
        type: string
        required: false
        default: ''
      gitUserEmail:
        description: 'The email to use for git commits. e.g. "action@github.com"'
        type: string
        required: false
        default: 'action@github.com'
      gitUserName:
        description: 'The name to use for git commits. e.g. "GitHub Actions[bot]"'
        type: string
        required: false
        default: 'GitHub Actions[bot]'
      s3BucketUrl:
        description: 'The S3 bucket URL with prefix to use. e.g. "s3://my-bucket/prefix"'
        type: string
        required: false
        default: ''
      iamRoleArn:
        description: 'The ARN of the IAM role to assume. e.g. "arn:aws:iam::123456789012:role/my-role"'
        type: string
        required: false
        default: ''
    secrets:
      PERSONAL_ACCESS_TOKEN:
        required: false
      CHATGPT_API_SECRET_KEY:
        required: true
    outputs:
      documentName:
        value: ${{ jobs.maintain-library.outputs.documentName }}
      documentSummary:
        value: ${{ jobs.maintain-library.outputs.documentSummary }}
      crawlSummary:
        value: ${{ jobs.maintain-library.outputs.crawlSummary }}

jobs:
  maintain-library:
    runs-on: ubuntu-latest

    env:
      document: ${{ inputs.document || '' }}
      libraryDir: ${{ inputs.libraryDir || 'library/' }}
      sourcesFile: ${{ inputs.sourcesFile || 'SOURCES.md' }}
      documentsLimit: ${{ inputs.documentsLimit || '3' }}
      summaryWordLimit: ${{ inputs.summaryWordLimit || '10000' }}
      featuresDir: ${{ inputs.featuresDir || 'features/' }}
      target: ${{ inputs.target || 'src/lib/main.js' }}
      testFile: ${{ inputs.testFile || 'tests/unit/main.test.js' }}
      readmeFile: ${{ inputs.readmeFile || 'README.md' }}
      missionFile: ${{ inputs.missionFile || 'MISSION.md' }}
      contributingFile: ${{ inputs.contributingFile || 'CONTRIBUTING.md' }}
      dependenciesFile: ${{ inputs.dependenciesFile || 'package.json' }}
      buildScript: ${{ inputs.buildScript || 'npm run build' }}
      testScript: ${{ inputs.testScript || 'npm test' }}
      mainScript: ${{ inputs.mainScript || 'npm run start' }}
      mainScriptTimeout: ${{ inputs.mainScriptTimeout || '5m' }}
      testScriptTimeout: ${{ inputs.testScriptTimeout || '5m' }}
      buildScriptTimeout: ${{ inputs.buildScriptTimeout || '5m' }}
      model: ${{ inputs.model || vars.CHATGPT_API_MODEL || 'o3-mini' }}
      npmAuthOrganisation: ${{ inputs.npmAuthOrganisation || '' }}
      gitUserEmail: ${{ inputs.gitUserEmail || 'action@github.com' }}
      gitUserName: ${{ inputs.gitUserName || 'GitHub Actions[bot]' }}
      chatgptApiSecretKey: ${{ secrets.CHATGPT_API_SECRET_KEY }}
      s3BucketUrl: ${{ inputs.s3BucketUrl || '' }}
      iamRoleArn: ${{ inputs.iamRoleArn || '' }}

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Check GitHub authentication
        if: ${{ env.npmAuthOrganisation != '' }}
        shell: bash
        run: |
          curl --include --header "Authorization: token ${{ secrets.PERSONAL_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}" https://api.github.com/user

      - name: Set up .npmrc
        if: ${{ env.npmAuthOrganisation != '' }}
        shell: bash
        run: |
          echo "${{ env.npmAuthOrganisation }}:registry=https://npm.pkg.github.com" >> .npmrc
          echo "//npm.pkg.github.com/:_authToken=${{ secrets.PERSONAL_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}" >> .npmrc
          echo "always-auth=true" >> .npmrc

      - run: npm ci

      - name: Install web crawling dependencies
        run: npm install axios cheerio

      - name: List current features
        id: features
        shell: bash
        run: |
          output=$(find "${{ env.featuresDir }}" -maxdepth 1 -type f -name '*.md' -print -exec echo "# {}" \; -exec cat {} \; 2>&1 || echo 'none')
          echo "output<<EOF" >> "$GITHUB_OUTPUT"
          echo "$output" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          echo "output=${output}"

      - name: List rejected feature named
        id: rejectedFeatures
        shell: bash
        run: |
          mkdir -p "${{ env.featuresDir }}/rejects"
          output=$(ls -1 "${{ env.featuresDir }}/rejects" | sed 's/\.md//' | xargs echo )
          echo "output<<EOF" >> "$GITHUB_OUTPUT"
          echo "$output" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          echo "output=${output}"

      - name: List dependencies
        id: list
        shell: bash
        run: |
          output=$(npm list 2>&1)
          echo "output<<EOF" >> "$GITHUB_OUTPUT"
          echo "$output" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          echo "output=${output}"

      - name: Build project
        id: build
        shell: bash
        run: |
          output=$(timeout ${{ env.buildScriptTimeout }} ${{ env.buildScript }} 2>&1)
          echo "output<<EOF" >> "$GITHUB_OUTPUT"
          echo "$output" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          echo "output=${output}"

      - name: Tear down .npmrc
        if: ${{ env.npmAuthOrganisation != '' }}
        shell: bash
        run: rm -f .npmrc

      - name: Run tests
        id: test
        shell: bash
        run: |
          output=$(timeout ${{ env.testScriptTimeout }} ${{ env.testScript }} 2>&1)
          echo "output<<EOF" >> "$GITHUB_OUTPUT"
          echo "$output" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          echo "output=${output}"

      - name: Run main
        id: main
        shell: bash
        run: |
          output=$(timeout ${{ env.mainScriptTimeout }} ${{ env.mainScript }} 2>&1)
          echo "output<<EOF" >> "$GITHUB_OUTPUT"
          echo "$output" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          echo "output=${output}"

      - name: maintain-library
        id: maintain-library
        uses: actions/github-script@v7
        env:
          currentFeatures: ${{ steps.features.outputs.output }}
          rejectedFeatures: ${{ steps.rejectedFeatures.outputs.output }}
          dependenciesListOutput: ${{ steps.list.outputs.output }}
          buildOutput: ${{ steps.build.outputs.output }}
          testOutput: ${{ steps.test.outputs.output }}
          mainOutput: ${{ steps.main.outputs.output }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const document = process.env.document;
            const libraryDir = process.env.libraryDir;
            const sourcesFile = process.env.sourcesFile;
            const documentsLimit = process.env.documentsLimit;
            const featuresDir = process.env.featuresDir;
            const currentFeatures = process.env.currentFeatures;
            const rejectedFeatures = process.env.rejectedFeatures;
            const target = process.env.target;
            const testFile = process.env.testFile;
            const readmeFile = process.env.readmeFile;
            const missionFile = process.env.missionFile;
            const contributingFile = process.env.contributingFile;
            const dependenciesFile = process.env.dependenciesFile;
            const model = process.env.model;
            const apiKey = process.env.chatgptApiSecretKey;
            const dependenciesListOutput = process.env.dependenciesListOutput;
            const buildScript = process.env.buildScript;
            const buildOutput = process.env.buildOutput;
            const testScript = process.env.testScript;
            const testOutput = process.env.testOutput;
            const mainScript = process.env.mainScript;
            const mainOutput = process.env.mainOutput;
            const summaryWordLimit = process.env.summaryWordLimit;

            const fs = require('fs');
            const path = require('path');
            const OpenAI = require('openai').default;
            const { z } = require('zod');
            const axios = require('axios');
            const cheerio = require('cheerio');
            require('dotenv').config();

            if (!apiKey) { 
              core.setFailed("Missing CHATGPT_API_SECRET_KEY"); 
            }
            const openai = new OpenAI({ apiKey });

            core.info(`document: "${document}"`);
            core.info(`libraryDir: "${libraryDir}"`);
            core.info(`sourcesFile: "${sourcesFile}"`);
            core.info(`featuresDir: "${featuresDir}"`);
            core.info(`currentFeatures: "${currentFeatures}"`);
            core.info(`target: "${target}"`);
            core.info(`testFile: "${testFile}"`);
            core.info(`readmeFile: "${readmeFile}"`);
            core.info(`missionFile: "${missionFile}"`);
            core.info(`contributingFile: "${contributingFile}"`);
            core.info(`dependenciesFile: "${dependenciesFile}"`);

            // Load the sources file
            const sourcesFileContent = fs.readFileSync(sourcesFile, 'utf8');
            core.info(`Sources file '${sourcesFile}' has been loaded (length ${sourcesFileContent.length}).`);

            const sourceFileContent = fs.readFileSync(target, 'utf8');
            const testFileContent = fs.readFileSync(testFile, 'utf8');
            const readmeFileContent = fs.readFileSync(readmeFile, 'utf8');
            const missionFileContent = fs.readFileSync(missionFile, 'utf8');
            const contributingFileContent = fs.readFileSync(contributingFile, 'utf8');
            const dependenciesFileContent = fs.readFileSync(dependenciesFile, 'utf8');
            core.info(`Target file '${target}' has been loaded (length ${sourceFileContent.length}).`);
            core.info(`Test file '${testFile}' has been loaded (length ${testFileContent.length}).`);
            core.info(`Readme file '${readmeFile}' has been loaded (length ${readmeFileContent.length}).`);
            core.info(`Dependencies file '${dependenciesFile}' has been loaded (length ${dependenciesFileContent.length}).`);

            // Get list of existing library documents
            let existingDocuments = [];
            try {
              if (fs.existsSync(libraryDir)) {
                existingDocuments = fs.readdirSync(libraryDir)
                  .filter(file => file.endsWith('.md'))
                  .map(file => path.join(libraryDir, file));
              } else {
                fs.mkdirSync(libraryDir, { recursive: true });
              }
            } catch (e) {
              core.warning(`Error reading library directory: ${e.message}`);
              fs.mkdirSync(libraryDir, { recursive: true });
            }

            core.info(`Found ${existingDocuments.length} existing documents in ${libraryDir}`);

            // Parse the sources file to extract sections
            // Each source entry starts with a level 1 heading (#) and contains URL, description, and license
            const sourceEntries = [];
            const sourceLines = sourcesFileContent.split('\n');
            let currentEntry = null;

            for (let i = 0; i < sourceLines.length; i++) {
              const line = sourceLines[i];

              if (line.startsWith('# ')) {
                // If we have a current entry, push it to the array
                if (currentEntry) {
                  sourceEntries.push(currentEntry);
                }

                // Start a new entry
                currentEntry = {
                  name: line.substring(2).trim(),
                  url: '',
                  description: '',
                  license: '',
                  content: line + '\n'
                };
              } else if (currentEntry) {
                currentEntry.content += line + '\n';

                if (line.startsWith('## http')) {
                  currentEntry.url = line.substring(3).trim();
                } else if (line.startsWith('## ')) {
                  currentEntry.license = line.substring(3).trim();
                } else if (line && !line.startsWith('#')) {
                  if (!currentEntry.description) {
                    currentEntry.description = line.trim();
                  }
                }
              }
            }

            // Don't forget the last entry
            if (currentEntry) {
              sourceEntries.push(currentEntry);
            }

            core.info(`Parsed ${sourceEntries.length} source entries from ${sourcesFile}`);

            // Function to crawl a URL and its links for 10 seconds
            async function crawlUrl(url, maxTime = 10000) {
              if (!url || !url.startsWith('http')) {
                return { content: '', links: [], dataSize: 0, error: 'Invalid URL' };
              }

              const startTime = Date.now();
              const visitedUrls = new Set();
              const result = {
                content: '',
                links: [],
                dataSize: 0,
                error: null
              };

              try {
                // Queue of URLs to visit
                const urlQueue = [url];

                while (urlQueue.length > 0 && (Date.now() - startTime) < maxTime) {
                  const currentUrl = urlQueue.shift();

                  // Skip if already visited
                  if (visitedUrls.has(currentUrl)) {
                    continue;
                  }

                  visitedUrls.add(currentUrl);

                  try {
                    core.info(`Crawling URL: ${currentUrl}`);
                    const response = await axios.get(currentUrl, { 
                      timeout: 5000,
                      headers: {
                        'User-Agent': 'Mozilla/5.0 (compatible; AgenticLibBot/1.0; +https://github.com/xn-intenton-z2a/agentic-lib)'
                      }
                    });

                    const contentType = response.headers['content-type'] || '';

                    // Only process HTML content
                    if (contentType.includes('text/html')) {
                      const $ = cheerio.load(response.data);

                      // Extract text content
                      const pageText = $('body').text().replace(/\\s+/g, ' ').trim();
                      result.content += pageText + '\\n\\n';
                      result.dataSize += pageText.length;

                      // Extract links
                      $('a').each((i, link) => {
                        const href = $(link).attr('href');
                        if (href && href.startsWith('http') && !visitedUrls.has(href)) {
                          result.links.push(href);
                          urlQueue.push(href);
                        }
                      });
                    }
                  } catch (error) {
                    core.warning(`Error crawling ${currentUrl}: ${error.message}`);
                  }
                }

                core.info(`Crawling completed. Visited ${visitedUrls.size} URLs. Data size: ${result.dataSize} bytes.`);
                return result;
              } catch (error) {
                core.warning(`Crawling error: ${error.message}`);
                result.error = error.message;
                return result;
              }
            }

            // Randomly select a source entry
            const randomIndex = Math.floor(Math.random() * sourceEntries.length);
            const randomSourceEntry = sourceEntries[randomIndex];
            core.info(`Randomly selected source entry: ${randomSourceEntry.name} (${randomSourceEntry.url})`);

            // generate the document prompt either by using the supplied document prompt or by reviewing the current features and full context
            let prompt = document;
            if (document === 'house choice') {
              prompt = `Please review the current documents in the library and either;
                * add a new document to the repository, or
                * extend an existing document to add a new aspect to it, or
                * update an existing document to bring it to a high standard matching other documents in the repository.
                The document name should either be a current document name or be supplied with a summary which is distinct from any other document in the repository.
              `;
            }

            // Crawl the URL from the randomly selected source entry
            core.info(`Crawling URL: ${randomSourceEntry.url}`);
            let crawlResult = { content: '', links: [], dataSize: 0, error: 'Not crawled' };
            try {
              crawlResult = await crawlUrl(randomSourceEntry.url);
            } catch (error) {
              core.warning(`Error during crawling: ${error.message}`);
            }

            const chatGptPrompt = `
            Please generate a document summary based on the supplied prompt and project files.
            Before adding a new document ensure that this document is distinct from any other document in the library, otherwise update an existing document.
            The document name should be one or two words in SCREAMING_SNAKECASE.

            You should extract a section from the sources file to create the document. Each document should contain:
            1. The original content from the source section in SOURCES.md
            2. A summary of the crawled content from the URL (limited to ${summaryWordLimit} words)
            3. The date when the content was retrieved (current date)
            4. Attribution information and data size obtained during crawling

            Consider the following when refining your response:
            * Document prompt details
            * Current feature names and specifications in the repository
            * Rejected feature names
            * Source file content
            * Test file content
            * README file content
            * MISSION file content
            * Contributing file content
            * Dependencies file content
            * Dependency list
            * Build output
            * Test output
            * Main execution output
            * Available source entries from SOURCES.md

            Document prompt:
            DOCUMENT_PROMPT_START
            ${prompt}
            DOCUMENT_PROMPT_END            

            Current feature names and specifications:
            CURRENT_FEATURES_START
            ${currentFeatures}
            CURRENT_FEATURES_END

            Rejected feature names:
            REJECTED_FEATURES_START
            ${rejectedFeatures}
            REJECTED_FEATURES_END

            Source file: ${target}
            SOURCE_FILE_START
            ${sourceFileContent}
            SOURCE_FILE_END

            Test file: ${testFile}
            TEST_FILE_START
            ${testFileContent}
            TEST_FILE_END

            README file: ${readmeFile}
            README_FILE_START
            ${readmeFileContent}
            README_FILE_END

            MISSION file: ${missionFile}
            MISSION_FILE_START
            ${missionFileContent}
            MISSION_FILE_END

            Contributing file: ${contributingFile}
            CONTRIBUTING_FILE_START
            ${contributingFileContent}
            CONTRIBUTING_FILE_END

            Dependencies file: ${dependenciesFile}
            DEPENDENCIES_FILE_START
            ${dependenciesFileContent}
            DEPENDENCIES_FILE_END

            Dependencies list from command: npm list
            DEPENDENCIES_LIST_START
            ${dependenciesListOutput}
            DEPENDENCIES_LIST_END    

            Build output from command: ${buildScript}
            TEST_OUTPUT_START
            ${buildOutput}
            TEST_OUTPUT_END      

            Test output from command: ${testScript}
            TEST_OUTPUT_START
            ${testOutput}
            TEST_OUTPUT_END            

            Main output from command: ${mainScript}
            MAIN_OUTPUT_START
            ${mainOutput}
            MAIN_OUTPUT_END

            Available source entries from SOURCES.md (${sourceEntries.length} entries):
            SOURCES_ENTRIES_START
            ${sourceEntries.map((entry, index) => `Entry ${index + 1}: ${entry.name} (${entry.url})`).join('\n')}
            SOURCES_ENTRIES_END

            Crawled content from URL (${randomSourceEntry.url}):
            CRAWLED_CONTENT_START
            Data Size: ${crawlResult.dataSize} bytes
            Links Found: ${crawlResult.links.length}
            Error: ${crawlResult.error || 'None'}
            Content Preview: ${crawlResult.content.substring(0, 1000)}...
            CRAWLED_CONTENT_END

            Answer strictly with a JSON object following this schema:
            {
              "documentName": "The document name as one or two words in SCREAMING_SNAKECASE.",
              "documentSummary": "The document summary as multiline markdown with a few level 1 headings, including the original content from the source and the date when the content was retrieved.",
              "documentNamesToBeDeleted": "The comma separated list of document names to be deleted or 'none' if no document is to be deleted.",
              "sourceEntryIndex": "The index (1-based) of the source entry used for this document."
            }
            Ensure valid JSON.
            `;

            const ResponseSchema = z.object({ 
              documentName: z.string(), 
              documentSummary: z.string(), 
              documentNamesToBeDeleted: z.string(),
              sourceEntryIndex: z.string(),
              crawlSummary: z.string()
            });

            // Define the function schema for function calling
            const tools = [{
              type: "function",
              function: {
                name: "generate_document",
                description: "Elaborate on the supplied prompt and project files to create the documentName, documentSummary, and crawlSummary of a repository document, and the document names to be deleted. Return an object with documentName (string), documentSummary (string), documentNamesToBeDeleted (string), sourceEntryIndex (string), and crawlSummary (string).",
                parameters: {
                  type: "object",
                  properties: {
                    documentName: { type: "string", description: "The document name as one or two words in SCREAMING_SNAKECASE." },
                    documentSummary: { type: "string", description: "The document summary as multiline markdown with a few level 1 headings, including the original content from the source and the date when the content was retrieved." },
                    documentNamesToBeDeleted: { type: "string", description: "The comma separated list of document names to be deleted or 'none' if no document is to be deleted." },
                    sourceEntryIndex: { type: "string", description: "The index (1-based) of the source entry used for this document." },
                    crawlSummary: { type: "string", description: "A summary of the crawled content from the URL, limited to the specified word limit." }
                  },
                  required: ["documentName", "documentSummary", "documentNamesToBeDeleted", "sourceEntryIndex", "crawlSummary"],
                  additionalProperties: false
                },
                strict: true
              }
            }];

            // Call OpenAI using function calling format
            const response = await openai.chat.completions.create({
              model,
              messages: [
                { role: "system", content: "You are maintaining a library set by providing expert contemporary insight into both the product market and you will perform a detailed analysis of the current state of the repository and current document set in search of value opportunities and unique selling points. Answer strictly with a JSON object following the provided function schema." },
                { role: "user", content: chatGptPrompt }
              ],
              tools: tools
            });

            let result;
            if (response.choices[0].message.tool_calls && response.choices[0].message.tool_calls.length > 0) {
              try {
                result = JSON.parse(response.choices[0].message.tool_calls[0].function.arguments);
              } catch (e) {
                core.setFailed(`Failed to parse function call arguments: ${e.message}`);
              }
            } else if (response.choices[0].message.content) {
              try {
                result = JSON.parse(response.choices[0].message.content);
              } catch (e) {
                core.setFailed(`Failed to parse response content: ${e.message}`);
              }
            } else {
              core.setFailed("No valid response received from OpenAI.");
            }

            try {
              const parsed = ResponseSchema.parse(result);
              core.setOutput("documentName", parsed.documentName);
              core.setOutput("documentSummary", parsed.documentSummary);
              core.setOutput("documentNamesToBeDeleted", parsed.documentNamesToBeDeleted);
              core.setOutput("sourceEntryIndex", parsed.sourceEntryIndex);
              core.setOutput("crawlSummary", parsed.crawlSummary);
              core.info(`documentName: "${parsed.documentName}"`);
              core.info(`documentSummary: "${parsed.documentSummary}"`);
              core.info(`documentNamesToBeDeleted: "${parsed.documentNamesToBeDeleted}"`);
              core.info(`sourceEntryIndex: "${parsed.sourceEntryIndex}"`);
              core.info(`crawlSummary: "${parsed.crawlSummary}"`);

              // Get the source entry used for this document
              const sourceEntryIndex = parseInt(parsed.sourceEntryIndex, 10) - 1;
              let sourceEntry = null;
              if (sourceEntryIndex >= 0 && sourceEntryIndex < sourceEntries.length) {
                sourceEntry = sourceEntries[sourceEntryIndex];
                core.info(`Using source entry: ${sourceEntry.name} (${sourceEntry.url})`);
              } else {
                core.warning(`Invalid source entry index: ${parsed.sourceEntryIndex}`);
              }

              // Add the current date to the document summary
              const now = new Date();
              const dateStr = now.toISOString().split('T')[0]; // YYYY-MM-DD format

              // Create the document content
              let documentContent = parsed.documentSummary;

              // If we have a valid source entry, add the original content, crawl summary, and attribution fields
              if (sourceEntry) {
                const crawlDate = new Date();
                const crawlDateStr = crawlDate.toISOString();

                documentContent = `# ${parsed.documentName}\n\n`;
                documentContent += `## Original Source\n${sourceEntry.name}\n${sourceEntry.url}\n\n`;
                documentContent += `## Content\n${sourceEntry.content}\n\n`;
                documentContent += `## Crawl Summary\n${parsed.crawlSummary}\n\n`;
                documentContent += `## Attribution\n`;
                documentContent += `- Source: ${sourceEntry.name}\n`;
                documentContent += `- URL: ${sourceEntry.url}\n`;
                documentContent += `- License: ${sourceEntry.license || 'Unknown'}\n`;
                documentContent += `- Crawl Date: ${crawlDateStr}\n`;
                documentContent += `- Data Size: ${crawlResult.dataSize} bytes\n`;
                documentContent += `- Links Found: ${crawlResult.links.length}\n\n`;
                documentContent += `## Retrieved\n${dateStr}\n`;
              } else {
                // If no valid source entry, just add the date at the end
                documentContent += `\n\n_Retrieved: ${dateStr}_\n`;
              }

              // Save the document to a file
              const documentName = parsed.documentName.replace(/ /g, "_").toUpperCase();
              const documentFilePath = path.join(libraryDir, `${documentName}.md`);
              try {
                fs.mkdirSync(libraryDir, { recursive: true });
                fs.writeFileSync(documentFilePath, documentContent);
                core.info(`Document saved to ${documentFilePath}`);
              } catch (e) {
                core.setFailed(`Failed to save document: ${e.message}`);
              }

              // Delete any documents that should be deleted
              const documentNamesToBeDeleted = parsed.documentNamesToBeDeleted
                .split(',')
                .map(name => name.trim())
                .filter(name => name && name !== 'none');

              for (const name of documentNamesToBeDeleted) {
                const documentNameToDelete = name.replace(/ /g, "_").toUpperCase().replace(/\.md$/, "") + ".md";
                const documentPathToDelete = path.join(libraryDir, documentNameToDelete);
                try {
                  if (fs.existsSync(documentPathToDelete)) {
                    core.info(`Deleting document: ${documentPathToDelete}`);
                    fs.unlinkSync(documentPathToDelete);
                  } else {
                    core.warning(`Document not found for deletion: ${documentPathToDelete}`);
                  }
                } catch (e) {
                  core.warning(`Error deleting document ${documentPathToDelete}: ${e.message}`);
                }
              }

            } catch (e) {
              core.setFailed(`Failed to parse ChatGPT response: ${e.message}`);
            }

            core.setOutput("response", JSON.stringify(response));
            core.setOutput("usage", JSON.stringify(response.usage));
            core.info(`response: "${JSON.stringify(response)}"`);
            core.info(`usage: "${JSON.stringify(response.usage)}"`);

      - name: Commit changes
        id: commit
        continue-on-error: true
        run: |
          git config --local user.email '${{ env.gitUserEmail }}'
          git config --local user.name '${{ env.gitUserName }}'
          git status -v
          git add -v --all '${{ env.libraryDir }}'
          git commit -m 'Maintain ${{ steps.maintain-library.outputs.documentName }}'
          git status -v
          git push -v origin ${{ github.ref }}
          git status -v

    outputs:
      documentName: ${{ steps.maintain-library.outputs.documentName }}
      documentSummary: ${{ steps.maintain-library.outputs.documentSummary }}
      crawlSummary: ${{ steps.maintain-library.outputs.crawlSummary }}
.github/workflows/publish.yml
==== Content of .github/workflows/publish.yml ====
# .github/workflows/publish.yml
#
# This file is part of the example suite for `agentic-lib` see: https://github.com/xn-intenton-z2a/agentic-lib
# This file is licensed under the MIT License. For details, see LICENSE-MIT

name: Publish
run-name: 'Publish packages [${{ github.ref_name }}] [${{ github.event.head_commit.message }}]'
concurrency: agentic-lib-commit

on:
  #push:
  #  branches:
  #    # When publishing from a branch, add branch name here, e,g, 'beta'
  #    - main
  #  paths:
  #    - '**/*.sh'
  #    - '**/*.js'
  #    - '**/*.json'
  #    - '**/*.yml'
  #    - '**/*.properties'
  #    - '!intentions/**'
  #    - '!conversations/**'
  #    - '!exports/**'
  #    - '!programs/**'
  #    - '!results/**'
  workflow_dispatch:
    inputs:
      versionIncrement:
        description: 'Select the Semantic Versioning segment to increment'
        required: true
        default: 'prerelease'
        type: choice
        options:
          - prerelease
          - patch
          - minor
          - major
          - premajor
          - preminor
          - prepatch
  schedule:
    - cron: '50 8 15 1 *' # schedule-1
    #- cron: '50 8 15 1 *' # schedule-2
    #- cron: '50 8 15 1 *' # schedule-3
    #- cron: '50 8 15 1 *' # schedule-4

jobs:

  npm-test-and-run-main:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: 'npm'

      - name: Set up ~/.npmrc
        run: |
          echo "@xn-intenton-z2a:registry=https://npm.pkg.github.com" >> ~/.npmrc
          echo "//npm.pkg.github.com/:_authToken=${{ secrets.PERSONAL_ACCESS_TOKEN }}" >> ~/.npmrc
          echo "always-auth=true" >> ~/.npmrc

      - run: npm ci

      - name: test
        id: test
        shell: bash
        run: 'npm test'

      - name: main
        id: main
        shell: bash
        run: timeout 5m ${{ vars.MAIN_SCRIPT || 'npm run start' }}

  mvn-package-cdk-synth:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: 'npm'

      - name: Set up ~/.npmrc
        run: |
          echo "@xn-intenton-z2a:registry=https://npm.pkg.github.com" >> ~/.npmrc
          echo "//npm.pkg.github.com/:_authToken=${{ secrets.PERSONAL_ACCESS_TOKEN }}" >> ~/.npmrc
          echo "always-auth=true" >> ~/.npmrc

      - run: npm ci

      - name: mvn
        id: mvn
        shell: bash
        run: |
          if [ -f pom.xml ]; then
            pomXmlExists='true'
          else
            pomXmlExists='false'
          fi
          echo "pomXmlExists=${pomXmlExists?}" | tee -a "${GITHUB_OUTPUT?}"

      - uses: actions/setup-java@v4
        if: steps.mvn.outputs.pomXmlExists == 'true'
        with:
          distribution: 'corretto'
          java-version: 21
          cache: 'maven'
          server-password: PERSONAL_ACCESS_TOKEN
        env:
          GITHUB_ACTOR: ${{ github.actor }}
          PERSONAL_ACCESS_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}

      - name: package
        id: package
        if: steps.mvn.outputs.pomXmlExists == 'true'
        shell: bash
        run: ./mvnw clean package
        env:
          GITHUB_ACTOR: ${{ github.actor }}
          PERSONAL_ACCESS_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}

      - name: synth
        id: synth
        if: steps.mvn.outputs.pomXmlExists == 'true'
        shell: bash
        run: npx cdk synth --strict --validation --no-staging
        env:
          GITHUB_ACTOR: ${{ github.actor }}
          PERSONAL_ACCESS_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}

    outputs:
      pomXmlExists: ${{ steps.mvn.outputs.pomXmlExists }}

  publish-npm:
    needs:
      - npm-test-and-run-main
      - mvn-package-cdk-synth
    permissions:
      contents: write
      packages: write
    uses: 'xn-intenton-z2a/agentic-lib/.github/workflows/wfr-npm-publish.yml@main'
    with:
      versionIncrement: ${{ inputs.versionIncrement || 'prerelease' }}
      #githubRelease: true
      buildScript: 'npm run build'
      releaseNotes: 'Release increment: ${{ inputs.versionIncrement }}.'
      npmAuthOrganisation: '@xn-intenton-z2a'
      gitUserEmail: 'action@github.com'
      gitUserName: 'GitHub Actions[bot]'
    secrets:
      PERSONAL_ACCESS_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}

  publish-mvn:
    needs:
      - npm-test-and-run-main
      - publish-npm
      - mvn-package-cdk-synth
    if: needs.mvn-package-cdk-synth.outputs.pomXmlExists == 'true'
    permissions:
      contents: write
      packages: write
    uses: 'xn-intenton-z2a/agentic-lib/.github/workflows/wfr-mvn-publish.yml@main'
    with:
      versionIncrement: ${{ inputs.versionIncrement || 'prerelease' }}
      releaseVersionOverride: ${{ needs.publish-npm.outputs.releasedVersion }}
      newVersionOverride: ${{ needs.publish-npm.outputs.newVersion }}
      githubRelease: false
      mavenBuildScript: './mvnw --batch-mode clean install'
      mavenDeployScript: './mvnw --batch-mode deploy'
      releaseNotes: 'Release increment: ${{ inputs.versionIncrement }}.'
      gitUserEmail: 'action@github.com'
      gitUserName: 'GitHub Actions[bot]'
    secrets:
      PERSONAL_ACCESS_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}

  select-issue:
    permissions:
      issues: read
      id-token: write
    uses: 'xn-intenton-z2a/agentic-lib/.github/workflows/wfr-github-select-issue.yml@main'
    with:
      issueNumber: ''
      selectionLabel: 'automated'
    secrets:
      CHATGPT_API_SECRET_KEY: ${{ secrets.CHATGPT_API_SECRET_KEY }}

  stats:
    needs:
      - select-issue
      - publish-npm
      - publish-mvn
    if: ${{ always() }}
    permissions:
      contents: write
      id-token: write
      pages: write
    uses: 'xn-intenton-z2a/agentic-lib/.github/workflows/wfr-github-stats.yml@main'
    with:
      cache: 'npm'
      npmAuthOrganisation: '@xn-intenton-z2a'
      lastActivityName: ${{ github.workflow }}
      lastActivityBranchName: ${{ github.ref_name }}
      nextIssue: "[${{ needs.select-issue.outputs.issueNumber }}] ${{ needs.select-issue.outputs.issueTitle }} ${{ needs.select-issue.outputs.issueLabels }}"
      public: 'public'
      s3BucketUrl: 's3://agentic-lib-telemetry-bucket/events/'
      s3WebsiteBucketUrl: 's3://agentic-lib-public-website-stats-bucket/'
      iamActionsRoleArn: 'arn:aws:iam::541134664601:role/agentic-lib-github-actions-role'
      iamStatsBucketWriterRoleArn: 'arn:aws:iam::541134664601:role/agentic-lib-deployment-role'
      iamPublicWebsiteStatsBucketWriterRoleArn: 'arn:aws:iam::541134664601:role/agentic-lib-public-website-stats-bucket-writer-role'
    secrets:
      PERSONAL_ACCESS_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}
.github/workflows/apply-fix.yml
==== Content of .github/workflows/apply-fix.yml ====
# .github/workflows/apply-fix.yml
#
# This file is part of the example suite for `agentic-lib` see: https://github.com/xn-intenton-z2a/agentic-lib
# This file is licensed under the MIT License. For details, see LICENSE-MIT

name: Apply Fix on Fail
concurrency: agentic-lib-commit-branch
run-name: "Apply Fix on Fail [${{ github.ref_name }}]"

on:
  workflow_dispatch:
    inputs:
      target:
        description: 'The source file whose content is used in the resolution prompt. e.g. "src/lib/main.js"'
        required: false
        type: string
        default: 'src/lib/main.js'
      testFile:
        description: 'The test file to run to validate the resolution. e.g. "tests/unit/main.test.js"'
        required: false
        type: string
        default: 'tests/unit/main.test.js'
      branchPrefix:
        description: 'The prefix of the branch to scan for. e.g. "agentic-lib-"'
        required: false
        type: string
        default: 'agentic-lib-'
      applyFixEvenIfTestsPass:
        description: 'Apply the fix even if the tests pass. e.g. true'
        required: false
        type: boolean
        default: false
      scanForBranches:
        description: 'Scan for branches matching the pattern. e.g. true'
        required: false
        type: boolean
        default: false
  #workflow_run:
  #  workflows:
  #    - 'Tests'
  #    - 'Issue Worker'
  #  types:
  #    - completed
  #  branches:
  #    - agentic-lib-*
  schedule:
    - cron: '15 */12 * * *' # schedule-1
    #- cron: '15 */4 * * *' # schedule-2
    #- cron: '15,30,45 */1 * * *' # schedule-3
    #- cron: '15,30,45 */1 * * *' # schedule-4

jobs:

  agentic-lib:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: agentic-lib
        id: agentic-lib
        shell: bash
        run: |
          attemptsPerBranch=$(grep '^attemptsPerBranch:' .github/agentic-lib.yml | awk '{print $2}')
          echo "attemptsPerBranch=${attemptsPerBranch}"
          echo "attemptsPerBranch=${attemptsPerBranch}" >> $GITHUB_OUTPUT
    outputs:
      attemptsPerBranch: ${{ steps.agentic-lib.outputs.attemptsPerBranch }}

  select-branch:
    runs-on: ubuntu-latest
    env:
      branchPrefix: ${{ inputs.branchPrefix || 'agentic-lib-' }}
      gitUserEmail: 'action@github.com'
      gitUserName: 'GitHub Actions[bot]'
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Fetch all branches
        run: |
          git fetch --all
          git branch -r

      - name: determine-branch and auto-resolve merge conflicts
        id: determine
        uses: actions/github-script@v7
        with:
          script: |
            const { execSync } = require('child_process');
            const attemptsPerBranch = "${{ needs.agentic-lib.outputs.attemptsPerBranch }}";
            // Use the branch prefix from env (ensure process.env.branchPrefix is defined)
            const prefix = process.env.branchPrefix || "agentic-lib-";
            
            let branch;
            // Determine branch using schedule or ref
            if (context.eventName === "schedule" || context.eventName === "workflow_run" || "${{ inputs.scanForBranches }}" === "true") {
              core.info("Schedule event detected. Scanning for matching branches.");
              const branchesResp = await github.rest.repos.listBranches({
                owner: context.repo.owner,
                repo: context.repo.repo,
              });
              const matchingBranches = branchesResp.data
                .filter(b => new RegExp(`^${prefix}`).test(b.name))
                .map(b => b.name);
              core.info(`Matching branches: ${matchingBranches}`);
              
              // Check if any of the matching branches have a PR open
              const openPRs = await github.rest.pulls.list({
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: 'open',
              });
              const matchingBranchesWithNoPRs = matchingBranches.filter(b => !openPRs.data.some(pr => pr.head.ref === b));
              if(matchingBranchesWithNoPRs.length > 0) {
                core.info(`Matching branches with ${prefix} and no PRs: ${matchingBranchesWithNoPRs}`);
                branch = matchingBranchesWithNoPRs[0];
              } else {
                core.info(`No matching branches with ${prefix} but without PRs found.`);
              }
            } else {
              branch = context.ref.startsWith("refs/heads/") ? context.ref.substring("refs/heads/".length) : context.ref;
            }
            core.info(`Selected branch: ${branch}`);
            core.setOutput("branch", branch);

            if (branch === "main") {
              core.info("Main branch selected. Skipping auto-resolution.");
              core.setOutput("conflictsDetected", "false");
              core.setOutput("conflictsResolved", "true");
            } else {
              core.info("Detect and resolve merge conflicts between the selected branch and main.");
              execSync("git config --local user.email '${{ env.gitUserEmail }}'", { stdio: 'pipe' });
              execSync("git config --local user.name '${{ env.gitUserName }}'", { stdio: 'pipe' });
              execSync("git status -v", { stdio: 'pipe' });
              execSync(`git checkout origin/${branch}`, { stdio: 'pipe' });
              try {
                core.info("Fetching main branch...");
                execSync("git fetch origin main", { stdio: 'pipe' });
                core.info("Attempting a dry-run merge of main into the branch...");
                // Attempt dry-run merge without committing.
                execSync("git merge origin/main --no-commit --no-ff", { stdio: 'pipe' });
                core.info("No merge conflicts detected.");
                // Abort the merge attempt.
                //execSync("git merge --abort", { stdio: 'pipe' });
                //core.setOutput("conflictsDetected", "false");
                //core.setOutput("conflictsResolved", "true");
              } catch (err) {
                core.info(`Merge conflicts detected. ${err.message}`);
                core.setOutput("conflictsDetected", "true");
                try {
                  core.info("Attempting auto-resolution by accepting main's changes...");
                  // Auto-resolve by checking out the version from main for all conflicting files.
                  execSync("git checkout --theirs .", { stdio: 'pipe' });
                  execSync("git add .", { stdio: 'pipe' });
                  execSync("git commit -m 'Auto-resolved merge conflicts: accepted main changes'", { stdio: 'pipe' });
                  core.info("Auto-resolution succeeded.");
                  core.setOutput("conflictsResolved", "true");
                } catch (e) {
                  core.error("Auto-resolution failed: " + e.message);
                  core.setOutput("conflictsResolved", "false");
                }
              }
            }

            // Extract issue number from branch name using branchPrefix.
            const issueNumberMatch = branch.match(new RegExp(`${prefix}issue-(\\d+)`));
            const issueNumber = issueNumberMatch ? issueNumberMatch[1] : '';

            core.setOutput("issueNumber", issueNumber);
            core.info(`Issue number: ${issueNumber}`);
    outputs:
      branch: ${{ steps.determine.outputs.branch }}
      issueNumber: ${{ steps.determine.outputs.issueNumber }}

  check-attempts-limit:
    needs:
      - agentic-lib
      - select-branch
    runs-on: ubuntu-latest
    permissions:
      issues: write
      contents: write
      id-token: write
    env:
      issueNumber: ${{ needs.select-branch.outputs.issueNumber }}
      branch: ${{ needs.select-branch.outputs.branch }}
      attemptsPerBranch: ${{ needs.agentic-lib.outputs.attemptsPerBranch }}
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ github.ref }}
          fetch-depth: 0
      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: 'npm'
      - name: Set up .npmrc
        shell: bash
        run: |
          echo "${{ env.npmAuthOrganisation }}:registry=https://npm.pkg.github.com" >> .npmrc
          echo "//npm.pkg.github.com/:_authToken=${{ secrets.PERSONAL_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}" >> .npmrc
          echo "always-auth=true" >> .npmrc
        env:
          npmAuthOrganisation: '@xn-intenton-z2a'
      - run: npm ci
      - name: check
        id: check
        if: ${{ needs.select-branch.outputs.issueNumber != '' }}
        uses: actions/github-script@v7
        with:
          script: |
            const issueNumber = "${{ env.issueNumber }}";
            const attemptsPerBranch = parseInt("${{ env.attemptsPerBranch }}");
            const branch = "${{ env.branch }}";
            
            // If attempts to [work++fix] a branch exceed the limit as per agentic-lib.yml, then comment the issue and delete the branch.       
            const { data: issue } = await github.rest.issues.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber
            });
            const issueLabelsStartingWithApplyFix = issue.labels.filter(label => label.name.startsWith("apply-fix-"));
            const issueLabelsStartingWithIssueWorker = issue.labels.filter(label => label.name.startsWith("issue-worker-"));
            const attemptsOnBranch = issueLabelsStartingWithApplyFix.length + issueLabelsStartingWithIssueWorker.length
            if(attemptsOnBranch >= attemptsPerBranch) {
               const message = `${branch} has Reached the limit of ${attemptsPerBranch} attempts with ${attemptsOnBranch} attempts.`;
            
              // Delete the branch if it isn't main
              if (branch === "main") {
                core.info(`Skipping branch delete but ${message}`);
              } else {
                core.info(`Deleting branch ${branch} because ${message}`);
                await github.rest.git.deleteRef({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  ref: `heads/${branch}`
                });
                core.info(`Deleted branch ${branch}.`);
              }
            
              // Comment the issue
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber,
                body: message
              });
            
              core.setFailure(`${message}`);
            }

            core.setOutput("attemptsOnBranch", attemptsOnBranch);
            core.info(`attemptsOnBranch: ${attemptsOnBranch}`);
    outputs:
      attemptsOnBranch: ${{ steps.check.outputs.attemptsOnBranch }}

  npm-test:
    needs:
      - select-branch
      - check-attempts-limit
    name: 'npm test with coverage'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ needs.select-branch.outputs.branch }}
          fetch-depth: 0
      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: 'npm'
      - name: Set up .npmrc
        shell: bash
        run: |
          echo "${{ env.npmAuthOrganisation }}:registry=https://npm.pkg.github.com" >> .npmrc
          echo "//npm.pkg.github.com/:_authToken=${{ secrets.PERSONAL_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}" >> .npmrc
          echo "always-auth=true" >> .npmrc
        env:
          npmAuthOrganisation: '@xn-intenton-z2a'
      - run: npm ci
      - run: npm run test:unit

  npm-build:
    needs:
      - select-branch
      - check-attempts-limit
    name: 'npm run build'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ needs.select-branch.outputs.branch }}
          fetch-depth: 0
      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: 'npm'
      - name: Set up .npmrc
        shell: bash
        run: |
          echo "${{ env.npmAuthOrganisation }}:registry=https://npm.pkg.github.com" >> .npmrc
          echo "//npm.pkg.github.com/:_authToken=${{ secrets.PERSONAL_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}" >> .npmrc
          echo "always-auth=true" >> .npmrc
        env:
          npmAuthOrganisation: '@xn-intenton-z2a'
      - run: npm ci
      - run: npm run build

  npm-run:
    needs:
      - select-branch
      - check-attempts-limit
    name: 'npm run start'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ needs.select-branch.outputs.branch }}
          fetch-depth: 0
      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: 'npm'
      - name: Set up .npmrc
        shell: bash
        run: |
          echo "${{ env.npmAuthOrganisation }}:registry=https://npm.pkg.github.com" >> .npmrc
          echo "//npm.pkg.github.com/:_authToken=${{ secrets.PERSONAL_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}" >> .npmrc
          echo "always-auth=true" >> .npmrc
        env:
          npmAuthOrganisation: '@xn-intenton-z2a'
      - run: npm ci
      - run: ${{ vars.MAIN_SCRIPT || 'npm run start' }}

  needs-fix:
    needs:
      - select-branch
      - check-attempts-limit
      - npm-test
      - npm-build
      - npm-run
    if: >
      ${{ always() &&
         (
           needs.npm-test.result != 'success' ||
           needs.npm-build.result != 'success' ||
           needs.npm-run.result != 'success' ||
           inputs.applyFixEvenIfTestsPass == true
         )
      }}
    runs-on: ubuntu-latest
    steps:
      - name: set-needs-fix
        id: set-needs-fix
        uses: actions/github-script@v7
        with:
          script: |
            const npmTestResult = "${{ needs.npm-test.result }}";
            const npmBuildResult = "${{ needs.npm-build.result }}";
            const npmRunResult = "${{ needs.npm-run.result }}";
            const applyFixEvenIfTestsPass = "${{ inputs.applyFixEvenIfTestsPass }}" === "true";
            const needsFix = npmTestResult !== "success" || npmBuildResult !== "success" || npmRunResult !== "success" || applyFixEvenIfTestsPass;
            core.info(`Needs Fix: ${needsFix}`);
            core.setOutput("needsFix", needsFix);
    outputs:
      needsFix: ${{ steps.set-needs-fix.outputs.needsFix }}

  branch-for-fix:
    needs:
      - select-branch
      - needs-fix
    if: ${{ always() }}
    runs-on: ubuntu-latest
    env:
      branchPrefix: 'agentic-lib-'
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ needs.select-branch.outputs.branch }}
          fetch-depth: 0
      - name: create-branch-if-required
        id: create-branch-if-required
        run: |
          if [[ '${{ needs.select-branch.outputs.branch }}' == 'main' && '${{ needs.needs-fix.outputs.needsFix }}' == 'true' ]] ; then
            echo 'Creating or force pushing to branch: ${{ env.branchPrefix }}fix-main'
            git switch --force-create '${{ env.branchPrefix }}fix-main'
            git push -v --force origin '${{ env.branchPrefix }}fix-main'
            echo 'branch=${{ env.branchPrefix }}fix-main' >> $GITHUB_OUTPUT
          else
            echo 'Retaining existing branch: ${{ needs.select-branch.outputs.branch }}'
            echo 'branch=${{ needs.select-branch.outputs.branch }}' >> $GITHUB_OUTPUT
          fi
    outputs:
      branch: ${{ steps.create-branch-if-required.outputs.branch }}

  label-issue-before-attempt:
    needs:
      - select-branch
      - branch-for-fix
      - npm-test
      - npm-build
      - npm-run
      - needs-fix
    if: ${{ always() && needs.needs-fix.outputs.needsFix == 'true' && needs.select-branch.outputs.issueNumber != '' }}
    permissions:
      contents: write
      issues: write
      pull-requests: read
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ github.ref }}
          fetch-depth: 0

      - uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: ${{ env.cache }}

      - name: Set up .npmrc
        shell: bash
        run: |
          echo "${{ env.npmAuthOrganisation }}:registry=https://npm.pkg.github.com" >> .npmrc
          echo "//npm.pkg.github.com/:_authToken=${{ secrets.PERSONAL_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}" >> .npmrc
          echo "always-auth=true" >> .npmrc
        env:
          npmAuthOrganisation: '@xn-intenton-z2a'

      - name: Add "issueWorker-<run-id>" label
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: "${{ needs.select-branch.outputs.issueNumber }}",
              labels: [`apply-fix-${{ github.run_id }}`]
            });

  apply-fix:
    needs:
      - branch-for-fix
      - branch-for-fix
      - npm-test
      - npm-build
      - npm-run
      - needs-fix
    if: ${{ always() && needs.needs-fix.outputs.needsFix == 'true' }}
    permissions:
      contents: write
      issues: write
      id-token: write
    uses: 'xn-intenton-z2a/agentic-lib/.github/workflows/wfr-completion-apply-fix.yml@main'
    with:
      target: ${{ inputs.target || 'src/lib/main.js' }}
      testFile: ${{ inputs.testFile || 'tests/unit/main.test.js' }}
      readmeFile: 'README.md'
      missionFile: 'MISSION.md'
      contributingFile: 'CONTRIBUTING.md'
      dependenciesFile: 'package.json'
      formattingFile: '.prettierrc'
      lintingFile: 'eslint.config.js'
      buildScript: 'npm run build'
      testScript: 'npm test'
      mainScript: ${{ vars.MAIN_SCRIPT || 'npm run start' }}
      model: ${{ vars.CHATGPT_API_MODEL || 'o3-mini' }}
      branch: ${{ needs.branch-for-fix.outputs.branch }}
      npmAuthOrganisation: '@xn-intenton-z2a'
      gitUserEmail: 'action@github.com'
      gitUserName: 'GitHub Actions[bot]'
    secrets:
      CHATGPT_API_SECRET_KEY: ${{ secrets.CHATGPT_API_SECRET_KEY }}
      PERSONAL_ACCESS_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}

  npm-test-after-fix:
    needs:
      - branch-for-fix
      - npm-test
      - npm-build
      - npm-run
      - needs-fix
      - apply-fix
    if: ${{ always() && needs.needs-fix.outputs.needsFix == 'true' }}
    name: 'npm test with coverage'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ needs.branch-for-fix.outputs.branch }}
          fetch-depth: 0
      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: "npm"
      - name: Get latest from remote
        run: |
          git config --local user.email "${{ env.gitUserEmail }}"
          git config --local user.name "${{ env.gitUserName }}"
          git pull --ff-only origin ${{ needs.branch-for-fix.outputs.branch }}
      - name: Set up .npmrc
        shell: bash
        run: |
          echo "${{ env.npmAuthOrganisation }}:registry=https://npm.pkg.github.com" >> .npmrc
          echo "//npm.pkg.github.com/:_authToken=${{ secrets.PERSONAL_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}" >> .npmrc
          echo "always-auth=true" >> .npmrc
        env:
          npmAuthOrganisation: '@xn-intenton-z2a'
      - run: npm ci
      - run: npm run test:unit

  npm-build-after-fix:
    needs:
      - branch-for-fix
      - npm-test
      - npm-build
      - npm-run
      - needs-fix
      - apply-fix
    if: ${{ always() && needs.needs-fix.outputs.needsFix == 'true' }}
    name: 'npm run build'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ needs.branch-for-fix.outputs.branch }}
          fetch-depth: 0
      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: "npm"
      - name: Get latest from remote
        run: |
          git config --local user.email "${{ env.gitUserEmail }}"
          git config --local user.name "${{ env.gitUserName }}"
          git pull --ff-only origin ${{ needs.branch-for-fix.outputs.branch }}
      - name: Set up .npmrc
        shell: bash
        run: |
          echo "${{ env.npmAuthOrganisation }}:registry=https://npm.pkg.github.com" >> .npmrc
          echo "//npm.pkg.github.com/:_authToken=${{ secrets.PERSONAL_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}" >> .npmrc
          echo "always-auth=true" >> .npmrc
        env:
          npmAuthOrganisation: '@xn-intenton-z2a'
      - run: npm ci
      - run: npm run build

  npm-run-after-fix:
    needs:
      - branch-for-fix
      - npm-test
      - npm-build
      - npm-run
      - needs-fix
      - apply-fix
    if: ${{ always() && needs.needs-fix.outputs.needsFix == 'true' }}
    name: 'npm run start'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ needs.branch-for-fix.outputs.branch }}
          fetch-depth: 0
      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: "npm"
      - name: Get latest from remote
        run: |
          git config --local user.email "${{ env.gitUserEmail }}"
          git config --local user.name "${{ env.gitUserName }}"
          git pull --ff-only origin ${{ needs.branch-for-fix.outputs.branch }}
      - name: Set up .npmrc
        shell: bash
        run: |
          echo "${{ env.npmAuthOrganisation }}:registry=https://npm.pkg.github.com" >> .npmrc
          echo "//npm.pkg.github.com/:_authToken=${{ secrets.PERSONAL_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}" >> .npmrc
          echo "always-auth=true" >> .npmrc
        env:
          npmAuthOrganisation: '@xn-intenton-z2a'
      - run: npm ci
      - run: ${{ vars.MAIN_SCRIPT || 'npm run start' }}

  needs-fix-after-fix:
    needs:
      - branch-for-fix
      - npm-test
      - npm-build
      - npm-run
      - needs-fix
      - apply-fix
      - npm-test-after-fix
      - npm-build-after-fix
      - npm-run-after-fix
    runs-on: ubuntu-latest
    if: ${{ always() }}
    steps:
      - name: set-needs-fix
        id: set-needs-fix
        uses: actions/github-script@v7
        with:
          script: |
            const applyFixEvenIfTestsPass = "${{ inputs.applyFixEvenIfTestsPass }}" === "true";
            const fixedFromTheBeginning = "${{ needs.needs-fix.outputs.needsFix }}" === "false";
            const anySkipped = "${{ needs.npm-test-after-fix.result == 'skipped' || needs.npm-build-after-fix.result == 'skipped' || needs.npm-run-after-fix.result == 'skipped' }}" === "true";
            const anyDidntSucceed = "${{ needs.npm-test-after-fix.result != 'success' || needs.npm-build-after-fix.result != 'success' || needs.npm-run-after-fix.result != 'success' }}" === "true";
            const readyToMerge = applyFixEvenIfTestsPass || fixedFromTheBeginning || !anySkipped && !anyDidntSucceed;
            
            core.setOutput("applyFixEvenIfTestsPass", applyFixEvenIfTestsPass);
            core.setOutput("fixedFromTheBeginning", fixedFromTheBeginning);
            core.setOutput("anySkipped", anySkipped);
            core.setOutput("anyDidntSucceed", anyDidntSucceed);
            core.setOutput("readyToMerge", readyToMerge);     
            
            core.info(`Apply fix even if tests pass: ${applyFixEvenIfTestsPass}`);
            core.info(`Fixed from the beginning: ${fixedFromTheBeginning}`);
            core.info(`Any skipped: ${anySkipped}`);
            core.info(`Any didn't succeed: ${anyDidntSucceed}`);
            core.info(`Ready to merge: ${readyToMerge}`);

    outputs:
      applyFixEvenIfTestsPass: ${{ steps.set-needs-fix.outputs.applyFixEvenIfTestsPass }}
      fixedFromTheBeginning: ${{ steps.set-needs-fix.outputs.fixedFromTheBeginning }}
      allSkipped: ${{ steps.set-needs-fix.outputs.allSkipped }}
      anyDidntSucceed: ${{ steps.set-needs-fix.outputs.anyDidntSucceed }}
      readyToMerge: ${{ steps.set-needs-fix.outputs.readyToMerge }}

  create-pr:
    needs:
      - select-branch
      - branch-for-fix
      - npm-test
      - npm-build
      - npm-run
      - apply-fix
      - needs-fix
      - npm-test-after-fix
      - npm-build-after-fix
      - npm-run-after-fix
      - needs-fix-after-fix
    if: ${{ always() && needs.branch-for-fix.outputs.branch != 'main' && needs.needs-fix-after-fix.outputs.readyToMerge == 'true' }}
    permissions:
      contents: write
      packages: write
      issues: write
      pull-requests: write
      checks: write
      id-token: write
    uses: 'xn-intenton-z2a/agentic-lib/.github/workflows/wfr-github-create-pr.yml@main'
    with:
      branch: "${{ needs.branch-for-fix.outputs.branch }}"
      baseBranch: 'main'
      gitCommitMessage: "${{ needs.apply-fix.outputs.message }} (fixes #${{ needs.select-branch.outputs.issueNumber }})"
      label: 'automerge'

  select-issue:
    permissions:
      issues: read
      id-token: write
    uses: 'xn-intenton-z2a/agentic-lib/.github/workflows/wfr-github-select-issue.yml@main'
    with:
      issueNumber: ''
      selectionLabel: 'automated'
    secrets:
      CHATGPT_API_SECRET_KEY: ${{ secrets.CHATGPT_API_SECRET_KEY }}

  stats:
    needs:
      - select-issue
      - apply-fix
      - needs-fix-after-fix
      - create-pr
    if: ${{ always() }}
    permissions:
      contents: write
      id-token: write
      pages: write
    uses: 'xn-intenton-z2a/agentic-lib/.github/workflows/wfr-github-stats.yml@main'
    with:
      cache: 'npm'
      npmAuthOrganisation: '@xn-intenton-z2a'
      lastActivityName: ${{ github.workflow }}
      lastActivityBranchName: ${{ github.ref_name }}
      nextIssue: "[${{ needs.select-issue.outputs.issueNumber }}] ${{ needs.select-issue.outputs.issueTitle }} ${{ needs.select-issue.outputs.issueLabels }}"
      public: 'public'
      s3BucketUrl: 's3://agentic-lib-telemetry-bucket/events/'
      s3WebsiteBucketUrl: 's3://agentic-lib-public-website-stats-bucket/'
      iamActionsRoleArn: 'arn:aws:iam::541134664601:role/agentic-lib-github-actions-role'
      iamStatsBucketWriterRoleArn: 'arn:aws:iam::541134664601:role/agentic-lib-deployment-role'
      iamPublicWebsiteStatsBucketWriterRoleArn: 'arn:aws:iam::541134664601:role/agentic-lib-public-website-stats-bucket-writer-role'
    secrets:
      PERSONAL_ACCESS_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}
.github/workflows/truncate-workflow-history.yml
==== Content of .github/workflows/truncate-workflow-history.yml ====
# .github/workflows/maintenance-issue-creator.yml
#
# This file is part of the example suite for `agentic-lib` see: https://github.com/xn-intenton-z2a/agentic-lib
# This file is licensed under the MIT License. For details, see LICENSE-MIT

name: ∞ Truncate Workflow Runs
concurrency: truncate-workflow-runs

on:
  workflow_dispatch:
  schedule:
    - cron: '52 7 */7 * *' # schedule-1
    #- cron: '52 7 * * *' # schedule-2
    #- cron: '52 7 * * *' # schedule-3
    #- cron: '52 7 * * *' # schedule-4

jobs:
  cleanup:
    runs-on: ubuntu-latest
    steps:
      - name: Clean up old workflow runs and artifacts
        uses: actions/github-script@v7
        with:
          script: |
            // Set retention period (in days)
            const retentionDays = 7;
            const cutoffDate = new Date(Date.now() - retentionDays * 24 * 60 * 60 * 1000);
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const perPage = 100;
            let runsDeleted = 0;
            let artifactsDeleted = 0;

            console.log(`Deleting workflow runs and artifacts older than ${retentionDays} days (before ${cutoffDate.toISOString()})...`);

            // Delete old workflow runs
            let page = 1;
            while (true) {
              const runsResponse = await github.rest.actions.listWorkflowRunsForRepo({
                owner,
                repo,
                per_page: perPage,
                page
              });
              const runs = runsResponse.data.workflow_runs;
              if (runs.length === 0) break;
              for (const run of runs) {
                const runCreatedAt = new Date(run.created_at);
                if (runCreatedAt < cutoffDate) {
                  try {
                    await github.rest.actions.deleteWorkflowRun({
                      owner,
                      repo,
                      run_id: run.id
                    });
                    console.log(`Deleted workflow run ${run.id} (created at ${run.created_at})`);
                    runsDeleted++;
                  } catch (error) {
                    console.error(`Failed to delete run ${run.id}: ${error.message}`);
                  }
                }
              }
              page++;
            }
            console.log(`Total workflow runs deleted: ${runsDeleted}`);

            // Delete old artifacts
            page = 1;
            while (true) {
              const artifactsResponse = await github.rest.actions.listArtifactsForRepo({
                owner,
                repo,
                per_page: perPage,
                page
              });
              const artifacts = artifactsResponse.data.artifacts;
              if (artifacts.length === 0) break;
              for (const artifact of artifacts) {
                const artifactCreatedAt = new Date(artifact.created_at);
                if (artifactCreatedAt < cutoffDate) {
                  try {
                    await github.rest.actions.deleteArtifact({
                      owner,
                      repo,
                      artifact_id: artifact.id
                    });
                    console.log(`Deleted artifact ${artifact.id} (created at ${artifact.created_at})`);
                    artifactsDeleted++;
                  } catch (error) {
                    console.error(`Failed to delete artifact ${artifact.id}: ${error.message}`);
                  }
                }
              }
              page++;
            }
            console.log(`Total artifacts deleted: ${artifactsDeleted}`);

            return `Cleanup complete. Deleted ${runsDeleted} runs and ${artifactsDeleted} artifacts.`;
          result-encoding: string

  select-issue:
    permissions:
      issues: read
      id-token: write
    uses: 'xn-intenton-z2a/agentic-lib/.github/workflows/wfr-github-select-issue.yml@main'
    with:
      issueNumber: ''
      selectionLabel: 'automated'
    secrets:
      CHATGPT_API_SECRET_KEY: ${{ secrets.CHATGPT_API_SECRET_KEY }}

  stats:
    needs:
      - select-issue
      - cleanup
    if: ${{ always() }}
    permissions:
      contents: write
      id-token: write
      pages: write
    uses: 'xn-intenton-z2a/agentic-lib/.github/workflows/wfr-github-stats.yml@main'
    with:
      cache: 'npm'
      npmAuthOrganisation: '@xn-intenton-z2a'
      lastActivityName: ${{ github.workflow }}
      lastActivityBranchName: ${{ github.ref_name }}
      nextIssue: "[${{ needs.select-issue.outputs.issueNumber }}] ${{ needs.select-issue.outputs.issueTitle }} ${{ needs.select-issue.outputs.issueLabels }}"
      public: 'public'
      s3BucketUrl: 's3://agentic-lib-telemetry-bucket/events/'
      s3WebsiteBucketUrl: 's3://agentic-lib-public-website-stats-bucket/'
      iamActionsRoleArn: 'arn:aws:iam::541134664601:role/agentic-lib-github-actions-role'
      iamStatsBucketWriterRoleArn: 'arn:aws:iam::541134664601:role/agentic-lib-deployment-role'
      iamPublicWebsiteStatsBucketWriterRoleArn: 'arn:aws:iam::541134664601:role/agentic-lib-public-website-stats-bucket-writer-role'
    secrets:
      PERSONAL_ACCESS_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}
.github/workflows/wfr-github-select-issue.yml
==== Content of .github/workflows/wfr-github-select-issue.yml ====
# .github/workflows/wfr-github-select-issue.yml

#
# agentic-lib
# Copyright (C) 2025 Polycode Limited
#
# This file is part of agentic-lib.
#
# agentic-lib is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License v3.0 (GPL‑3).
# along with this program. If not, see <https://www.gnu.org/licenses/>.
#
# IMPORTANT: Any derived work must include the following attribution:
# "This work is derived from https://github.com/xn-intenton-z2a/agentic-lib"
#

name: ∞ select-issue

on:
  workflow_call:
    inputs:
      issueNumber:
        description: 'The issue number to review. e.g. "123"'
        type: string
        required: true
      selectionLabel:
        description: 'Label used to filter issues for review. e.g. "automated"'
        required: false
        type: string
        default: 'automated'
      cache:
        description: 'The cache to use for npm. e.g. "npm"'
        type: string
        required: false
        default: 'npm'
    secrets:
      PERSONAL_ACCESS_TOKEN:
        required: false
      CHATGPT_API_SECRET_KEY:
        required: true
    outputs:
      issueNumber:
        description: 'The issue number to review. e.g. "123"'
        value: ${{ jobs.select-issue.outputs.issueNumber }}
      issueTitle:
        description: 'The issue title found. e.g. "My issue"'
        value: ${{ jobs.select-issue.outputs.issueTitle }}
      issueDescription:
        description: 'The issue description found. e.g. "My issue description"'
        value: ${{ jobs.select-issue.outputs.issueDescription }}
      issueLabels:
        description: 'The issue labels found. e.g. "automated"'
        value: ${{ jobs.select-issue.outputs.issueLabels }}
      merged:
        description: 'Set to "true", if the issue has been merged either already or by this process.'
        value: ${{ jobs.select-issue.outputs.merged }}

jobs:
  select-issue:
    runs-on: ubuntu-latest

    env:
      issueNumber: ${{ inputs.issueNumber }}
      selectionLabel: ${{ inputs.selectionLabel || 'automated' }}
      cache: ${{ inputs.cache || 'npm' }}

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: ${{ env.cache }}

      - name: select-issue
        id: select-issue
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PERSONAL_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}
          script: |
            const issueNumberInput = process.env.issueNumber;
            const selectionLabel = process.env.selectionLabel;
            let issueNumberOutput;
            let issueTitleOutput;
            let issueDescriptionOutput;
            let issueLabelsOutput;
            
            let issue;
            if (issueNumberInput) {
              const { data: issue } = await github.rest.issues.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: parseInt(issueNumberInput)
              });
            
              if (!issue) {
                issueNumberOutput = '';
                core.info(`No issue found with number: ${issueNumberInput}`);
              } else {
                issueNumberOutput = issue.number;
                core.info(`Found issue with number: ${issueNumberInput}`);
              }
            } else {
              const { data: issues } = await github.rest.issues.listForRepo({
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: 'open',
                labels: selectionLabel,
                per_page: 5
              });
            
              if (issues.length === 0) {
                issueNumberOutput = '';
                issueTitleOutput = '';
                issueDescriptionOutput = '';
                issueLabelsOutput = '';
                core.info(`No open issues found with label: "${selectionLabel}"`);
              } else {
                issueNumberOutput = issues[0].number;
                issueTitleOutput = issues[0].title; 
                issueDescriptionOutput = issues[0].body;
                issueLabelsOutput = issues[0].labels.map(label => label.name).join(', ');
                core.info(`Open issue '${issueNumberOutput}' found with label: '${selectionLabel}'`);
              }
            }
            
            core.setOutput("issueNumber", issueNumberOutput);
            core.setOutput("issueTitle", issueTitleOutput);
            core.setOutput("issueDescription", issueDescriptionOutput);
            core.setOutput("issueLabels", issueLabelsOutput);
            core.info(`issueNumber '${issueNumberOutput}'`);
            core.info(`issueTitle '${issueTitleOutput}'`);
            core.info(`issueDescription '${issueDescriptionOutput}'`);
            core.info(`issueLabels '${issueLabelsOutput}'`);

      - name: has-merged-label
        id: has-merged-label
        if: steps.select-issue.outputs.issueNumber != ''
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PERSONAL_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}
          script: |
            const issueNumber = parseInt("${{ steps.select-issue.outputs.issueNumber }}");
            const { data: issue } = await github.rest.issues.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber
            });
            
            const merged = issue.labels.some(label => label.name.toLowerCase() === "merged") ? "true" : "false";
            
            core.setOutput("merged", merged);
            core.info(`merged '${merged}'`);

    outputs:
      issueNumber: ${{ steps.select-issue.outputs.issueNumber }}
      issueTitle: ${{ steps.select-issue.outputs.issueTitle }}
      issueDescription: ${{ steps.select-issue.outputs.issueDescription }}
      issueLabels: ${{ steps.select-issue.outputs.issueLabels }}
      merged: ${{ steps.has-merged-label.outputs.merged }}
.github/workflows/publish-web.yml
==== Content of .github/workflows/publish-web.yml ====
# .github/workflows/publish-web.yml
#
# This file is part of the example suite for `agentic-lib` see: https://github.com/xn-intenton-z2a/agentic-lib
# This file is licensed under the MIT License. For details, see LICENSE-MIT

name: Publish Web

on:
  workflow_dispatch:
  schedule:
    - cron: '15 */12 * * *' # schedule-1
    #- cron: '15 * * * *' # schedule-2
    #- cron: '15 * * * *' # schedule-3
    #- cron: '15 * * * *' # schedule-4

jobs:

  select-issue:
    permissions:
      issues: read
      id-token: write
    uses: 'xn-intenton-z2a/agentic-lib/.github/workflows/wfr-github-select-issue.yml@main'
    with:
      issueNumber: ''
      selectionLabel: 'automated'
    secrets:
      CHATGPT_API_SECRET_KEY: ${{ secrets.CHATGPT_API_SECRET_KEY }}

  publish-web:
    needs:
      - select-issue
    permissions:
      contents: write
      id-token: write
      pages: write
    uses: 'xn-intenton-z2a/agentic-lib/.github/workflows/wfr-github-publish-web.yml@main'
    with:
      cache: 'npm'
      npmAuthOrganisation: '@xn-intenton-z2a'
      lastActivityName: ${{ github.workflow }}
      lastActivityBranchName: ${{ github.ref_name }}
      nextIssue: "[${{ needs.select-issue.outputs.issueNumber }}] ${{ needs.select-issue.outputs.issueTitle }} ${{ needs.select-issue.outputs.issueLabels }}"
      public: 'public'
      publishToGitHubPages: 'true'
    secrets:
      PERSONAL_ACCESS_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}.github/workflows/wfr-mvn-publish.yml
==== Content of .github/workflows/wfr-mvn-publish.yml ====
# .github/workflows/wfr-mvn-publish.yml

#
# agentic-lib
# Copyright (C) 2025 Polycode Limited
#
# This file is part of agentic-lib.
#
# agentic-lib is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License v3.0 (GPL‑3).
# along with this program. If not, see <https://www.gnu.org/licenses/>.
#
# IMPORTANT: Any derived work must include the following attribution:
# "This work is derived from https://github.com/xn-intenton-z2a/agentic-lib"
#

name: ∞ publish-mvn

on:
  workflow_call:
    inputs:
      versionIncrement:
        description: 'The version increment segment for Maven release. Expected values: major | minor | patch | premajor | preminor | prepatch | prerelease.'
        required: true
        type: string
        default: 'prerelease'
      releaseVersionOverride:
        description: 'The version number to set instead of following the current version. e.g. "0.0.1"'
        required: false
        type: string
        default: ''
      newVersionOverride:
        description: 'The version number to set instead of following the version increment. e.g. "0.0.2"'
        required: false
        type: string
        default: ''
      githubRelease:
        description: 'Whether to create a GitHub release. e.g. true'
        type: boolean
        required: false
        default: true
      mavenBuildScript:
        description: 'The Maven build command, e.g. "./mvnw clean install".'
        type: string
        required: false
        default: './mvnw clean install'
      mavenDeployScript:
        description: 'The Maven deploy command, e.g. "./mvnw deploy -P release".'
        type: string
        required: false
        default: './mvnw deploy -P release'
      cache:
        description: 'The cache to use for Maven. e.g. "maven"'
        type: string
        required: false
        default: 'maven'
      releaseNotes:
        description: 'The release notes for the GitHub release.'
        type: string
        required: false
        default: 'Feature release.'
      gitUserEmail:
        description: 'The email to use for git commits.'
        type: string
        required: false
        default: 'action@github.com'
      gitUserName:
        description: 'The name to use for git commits.'
        type: string
        required: false
        default: 'GitHub Actions[bot]'
      gitCommitMessage:
        description: 'The commit message for version bump commits.'
        type: string
        required: false
        default: 'chore: version bump'
    secrets:
      PERSONAL_ACCESS_TOKEN:
        required: false
    outputs:
      releasedVersion:
        description: 'The version that was released. e.g. "1.0.1"'
        value: ${{ jobs.publish.outputs.releasedVersion }}
      newVersion:
        description: 'The new version after bumping, e.g. "1.0.2-SNAPSHOT"'
        value: ${{ jobs.publish.outputs.newVersion }}

jobs:
  publish:
    runs-on: ubuntu-latest

    env:
      versionIncrement: ${{ inputs.versionIncrement }}
      releaseVersionOverride: ${{ inputs.releaseVersionOverride }}
      newVersionOverride: ${{ inputs.newVersionOverride }}
      mavenBuildScript: ${{ inputs.mavenBuildScript }}
      mavenDeployScript: ${{ inputs.mavenDeployScript }}
      cache: ${{ inputs.cache }}
      releaseNotes: ${{ inputs.releaseNotes }}
      gitUserEmail: ${{ inputs.gitUserEmail }}
      gitUserName: ${{ inputs.gitUserName }}
      gitCommitMessage: ${{ inputs.gitCommitMessage }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Java
        uses: actions/setup-java@v4
        with:
          distribution: 'corretto'
          java-version: 21
          cache: ${{ env.cache }}
          server-password: PERSONAL_ACCESS_TOKEN
        env:
          GITHUB_ACTOR: ${{ github.actor }}
          PERSONAL_ACCESS_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}

      - run: cat ~/.m2/settings.xml

      - name: Validate settings.xml
        shell: bash
        run: mvn help:effective-settings
        env:
          GITHUB_ACTOR: ${{ github.actor }}
          PERSONAL_ACCESS_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}

      - name: Build project before publishing begins
        id: build
        shell: bash
        run: ${{ env.mavenBuildScript }}
        env:
          GITHUB_ACTOR: ${{ github.actor }}
          PERSONAL_ACCESS_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}

      #- name: Run deploy without deploying
      #  shell: bash
      #  run: ./mvnw --batch-mode --debug -Dmaven.wagon.http.debug=true ‑Dmaven.deploy.skip=true deploy

      - name: Setup Java using GitHub Token
        uses: actions/setup-java@v4
        with:
          distribution: 'corretto'
          java-version: 21
          cache: ${{ env.cache }}
          #server-password: PERSONAL_ACCESS_TOKEN
          #env:
          #GITHUB_ACTOR: ${{ github.actor }}
          #PERSONAL_ACCESS_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}

      - run: cat ~/.m2/settings.xml

      - name: Validate settings.xml
        shell: bash
        run: mvn help:effective-settings
        #env:
          #GITHUB_ACTOR: ${{ github.actor }}
          #PERSONAL_ACCESS_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}

      - name: Examine the git working copy (pre-release)
        shell: bash
        run: |
          git config --local user.email "${{ env.gitUserEmail }}"
          git config --local user.name "${{ env.gitUserName }}"
          git status -v

      - name: Get latest from remote
        run: |
          git config --local user.email "${{ env.gitUserEmail }}"
          git config --local user.name "${{ env.gitUserName }}"
          git pull --ff-only origin ${{ github.ref }}

      - name: Setup Java
        uses: actions/setup-java@v4
        with:
          distribution: 'corretto'
          java-version: 21
          cache: 'maven'
          #server-password: PERSONAL_ACCESS_TOKEN
        #env:
          #GITHUB_ACTOR: ${{ github.actor }}
          #PERSONAL_ACCESS_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}

      - name: released
        id: released
        if: ${{ env.versionIncrement == 'major' || env.versionIncrement == 'minor' || env.versionIncrement == 'patch' }}
        shell: bash
        run: |
          releaseVersionOverride='${{ env.releaseVersionOverride }}'
          if [[ -n "$releaseVersionOverride" ]]; then
            newVersion="$releaseVersionOverride"
            mvn versions:set -DnewVersion=$newVersion
            echo "Using version override: $newVersion"
          else
            currentVersion=$(mvn help:evaluate -Dexpression=project.version -q -DforceStdout)
            # Bump version for release: remove -SNAPSHOT if present
            newVersion=${currentVersion/-SNAPSHOT/}
            mvn versions:set -DnewVersion=$newVersion
            echo "Using stadard version increment: $newVersion"
          fi
          ${{ env.mavenBuildScript }}
          echo "Deploying version: $newVersion"
          ${{ env.mavenDeployScript }}
          git push --follow-tags
          echo "releasedVersion=${newVersion}" >> $GITHUB_OUTPUT
          echo "releasedVersion=${newVersion}"
        env:
          GITHUB_TOKEN: ${{ github.token }}
          #GITHUB_ACTOR: ${{ github.actor }}
          #PERSONAL_ACCESS_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}

      - name: Create GitHub Release
        if: ${{ inputs.githubRelease == true && ( env.versionIncrement == 'major' || env.versionIncrement == 'minor' || env.versionIncrement == 'patch' ) }}
        uses: ncipollo/release-action@v1
        with:
          tag: ${{ steps.released.outputs.releasedVersion }}
          name: Release ${{ steps.released.outputs.releasedVersion }}
          body: ${{ env.releaseNotes }}
        #env:
          #GITHUB_ACTOR: ${{ github.actor }}
          #PERSONAL_ACCESS_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}

      - name: Rotate to next snapshot version (from a released version)
        if: ${{ env.versionIncrement == 'major' || env.versionIncrement == 'minor' || env.versionIncrement == 'patch' }}
        shell: bash
        run: |
          newVersionOverride='${{ env.newVersionOverride }}'
          if [[ -n "$newVersionOverride" ]]; then
            newVersion="$newVersionOverride"
            mvn versions:set -DnewVersion=$newVersion
            echo "Using version override: $newVersion"
          else
            currentVersion=$(mvn help:evaluate -Dexpression=project.version -q -DforceStdout)
            if [[ "$currentVersion" != *-SNAPSHOT ]]; then
              newVersion="${currentVersion}-SNAPSHOT"
              mvn versions:set -DnewVersion=$newVersion
            fi
            echo "Using incremented version: $newVersion"
          fi
        #env:
          #GITHUB_ACTOR: ${{ github.actor }}
          #PERSONAL_ACCESS_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}

      - name: Rotate to next pre-release version
        if: ${{ env.versionIncrement == 'premajor' || env.versionIncrement == 'preminor' || env.versionIncrement == 'prepatch' || env.versionIncrement == 'prerelease' }}
        shell: bash
        run: |
          newVersionOverride='${{ env.newVersionOverride }}'
          if [[ -n "$newVersionOverride" ]]; then
            newVersion="$newVersionOverride"
            mvn versions:set -DnewVersion=$newVersion
            echo "Using version override: $newVersion"
          else
            currentVersion=$(mvn help:evaluate -Dexpression=project.version -q -DforceStdout)
            newVersion="${currentVersion%-SNAPSHOT}-SNAPSHOT"
            mvn versions:set -DnewVersion=$newVersion
            echo "Using incremented version: $newVersion"
          fi
        #env:
          #GITHUB_ACTOR: ${{ github.actor }}
          #PERSONAL_ACCESS_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}

      - name: rotated
        id: rotated
        shell: bash
        run: |
          newVersion=$(mvn help:evaluate -Dexpression=project.version -q -DforceStdout)
          echo "newVersion=${newVersion}" >> $GITHUB_OUTPUT
          echo "newVersion=${newVersion}"
        #env:
          #GITHUB_ACTOR: ${{ github.actor }}
          #PERSONAL_ACCESS_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}

      - name: Examine the git working copy (post-rotation)
        shell: bash
        run: |
          git config --local user.email "${{ env.gitUserEmail }}"
          git config --local user.name "${{ env.gitUserName }}"
          git status -v

      - name: Run build after version bump
        run: ${{ env.mavenBuildScript }}
        #env:
          #GITHUB_ACTOR: ${{ github.actor }}
          #PERSONAL_ACCESS_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}

      - name: Examine the git working copy (pre-push)
        shell: bash
        run: |
          git config --local user.email "${{ env.gitUserEmail }}"
          git config --local user.name "${{ env.gitUserName }}"
          git status -v

      - name: Push version commit
        id: push
        shell: bash
        run: |
          git config --local user.email "${{ env.gitUserEmail }}"
          git config --local user.name "${{ env.gitUserName }}"
          newVersionOverride='${{ env.newVersionOverride }}'
          if [[ -n "$newVersionOverride" ]]; then
            git add -v --all
            newVersion=$(mvn help:evaluate -Dexpression=project.version -q -DforceStdout)
            git commit -m "${newVersion?}"
            git push origin HEAD
          fi
        #env:
          #GITHUB_ACTOR: ${{ github.actor }}
          #PERSONAL_ACCESS_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}

      - name: Upload pom.xml artifact
        uses: actions/upload-artifact@v4
        with:
          name: pom-xml
          path: "./pom.xml"

      - name: Log final version
        shell: bash
        run: |
          echo "Final version: ${{ steps.rotated.outputs.newVersion }}"

    outputs:
      releasedVersion: ${{ steps.released.outputs.releasedVersion }}
      newVersion: ${{ steps.rotated.outputs.newVersion }}
.github/workflows/wfr-github-create-issue.yml
==== Content of .github/workflows/wfr-github-create-issue.yml ====
# .github/workflows/wfr-github-create-issue.yml

#
# agentic-lib
# Copyright (C) 2025 Polycode Limited
#
# This file is part of agentic-lib.
#
# agentic-lib is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License v3.0 (GPL‑3).
# along with this program. If not, see <https://www.gnu.org/licenses/>.
#
# IMPORTANT: Any derived work must include the following attribution:
# "This work is derived from https://github.com/xn-intenton-z2a/agentic-lib"
#

name: ∞ create-issue

on:
  workflow_call:
    inputs:
      issueTitle:
        description: 'Text to drive the issue title (if "house choice", a random prompt will be selected).'
        required: false
        type: string
        default: 'house choice'
      issueBody:
        description: 'Text to drive the issue body.'
        required: false
        type: string
        default: 'Please resolve the issue.'
      issueLabels:
        description: 'Labels to apply to the issue, separated by commas. e.g. "automated,feature"'
        required: false
        type: string
        default: 'automated'
      houseChoiceOptions:
        description: 'Options for house choice, separated by double pipes "||".'
        type: string
        required: false
        default: 'Make code changes that extend or improve the features or resolve issues shown in the included context.'
      s3BucketUrl:
        description: 'The S3 bucket URL with prefix to use. e.g. "s3://my-bucket/prefix"'
        type: string
        required: false
        default: ''
      iamRoleArn:
        description: 'The ARN of the IAM role to assume. e.g. "arn:aws:iam::123456789012:role/my-role"'
        type: string
        required: false
        default: ''
    secrets:
      PERSONAL_ACCESS_TOKEN:
        required: false
    outputs:
      issueTitle:
        description: 'The issue title to resolve. e.g. "Make a small improvement."'
        value: ${{ jobs.create-issue.outputs.issueTitle }}
      issueNumber:
        description: 'The issue number to review. e.g. "123"'
        value: ${{ jobs.create-issue.outputs.issueNumber }}

jobs:
  create-issue:
    runs-on: ubuntu-latest

    env:
      issueTitle: ${{ inputs.issueTitle || 'house choice' }}
      issueBody: ${{ inputs.issueBody || 'Please resolve the issue.' }}
      issueLabels: ${{ inputs.issueLabels || 'automated' }}
      houseChoiceOptions: ${{ inputs.houseChoiceOptions || 'Make code changes that extend or improve the features or resolve issues shown in the included context.'}}
      s3BucketUrl: ${{ inputs.s3BucketUrl || '' }}
      iamRoleArn: ${{ inputs.iamRoleArn || '' }}

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: create-issue
        id: create-issue
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PERSONAL_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}
          script: |
            const issueTitle = process.env.issueTitle;
            const issueBody = process.env.issueBody;
            const issueLabels = process.env.issueLabels.split(',').map(label => label.trim());
            const houseChoiceOptions = process.env.houseChoiceOptions.split('||');

            let selectedIssueTitle;
            if (issueTitle === 'house choice') {
              selectedIssueTitle = houseChoiceOptions[Math.floor(Math.random() * houseChoiceOptions.length)];
            } else {
              selectedIssueTitle = issueTitle;
            }

            const { data: issue } = await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: selectedIssueTitle,
              body: issueBody,
              labels: issueLabels
            });

            core.setOutput("issueTitle", selectedIssueTitle);
            core.setOutput("issueBody", issueBody);
            core.setOutput("issueNumber", issue.number);
            core.info(`issueTitle: ${selectedIssueTitle}`);
            core.info(`issueBody: ${issueBody}`);    
            core.info(`issueNumber: ${issue.number}`);

    outputs:
      issueTitle: ${{ steps.create-issue.outputs.issueTitle }}
      issueBody: ${{ steps.create-issue.outputs.issueBody }}
      issueNumber: ${{ steps.create-issue.outputs.issueNumber }}

.github/workflows/stats.yml
==== Content of .github/workflows/stats.yml ====
# .github/workflows/stats.yml
#
# This file is part of the example suite for `agentic-lib` see: https://github.com/xn-intenton-z2a/agentic-lib
# This file is licensed under the MIT License. For details, see LICENSE-MIT

name: Stats

on:
  workflow_dispatch:
  schedule:
    - cron: '55 */12 * *  *' # schedule-1
    #- cron: '55 * * * *' # schedule-2
    #- cron: '55 * * * *' # schedule-3
    #- cron: '55 * * * *' # schedule-4

jobs:

  select-issue:
    permissions:
      issues: read
      id-token: write
    uses: 'xn-intenton-z2a/agentic-lib/.github/workflows/wfr-github-select-issue.yml@main'
    with:
      issueNumber: ''
      selectionLabel: 'automated'
    secrets:
      CHATGPT_API_SECRET_KEY: ${{ secrets.CHATGPT_API_SECRET_KEY }}

  stats:
    needs:
      - select-issue
    permissions:
      contents: write
      id-token: write
      pages: write
    uses: 'xn-intenton-z2a/agentic-lib/.github/workflows/wfr-github-stats.yml@main'
    with:
      cache: 'npm'
      npmAuthOrganisation: '@xn-intenton-z2a'
      lastActivityName: ${{ github.workflow }}
      lastActivityBranchName: ${{ github.ref_name }}
      nextIssue: "[${{ needs.select-issue.outputs.issueNumber }}] ${{ needs.select-issue.outputs.issueTitle }} ${{ needs.select-issue.outputs.issueLabels }}"
      public: 'public'
      s3BucketUrl: 's3://agentic-lib-telemetry-bucket/events/'
      s3WebsiteBucketUrl: 's3://agentic-lib-public-website-stats-bucket/'
      iamActionsRoleArn: 'arn:aws:iam::541134664601:role/agentic-lib-github-actions-role'
      iamStatsBucketWriterRoleArn: 'arn:aws:iam::541134664601:role/agentic-lib-telemetry-bucket-writer-role'
      iamPublicWebsiteStatsBucketWriterRoleArn: 'arn:aws:iam::541134664601:role/agentic-lib-public-website-stats-bucket-writer-role'
    secrets:
      PERSONAL_ACCESS_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}.github/workflows/test.yml
==== Content of .github/workflows/test.yml ====
# .github/workflows/test.yml
#
# This file is part of the example suite for `agentic-lib` see: https://github.com/xn-intenton-z2a/agentic-lib
# This file is licensed under the MIT License. For details, see LICENSE-MIT

name: Tests
run-name: 'Tests [${{ github.ref_name }}] [${{ github.event.head_commit.message }}]'

on:
  push:
    paths:
      - '**/*.sh'
      - '**/*.java'
      - '**/*.js'
      - '**/*.json'
      - '**/*.yml'
      - '**/pom.xml'
      - '**/*.properties'
      - '!exports/**'
  workflow_dispatch:
  #workflow_run:
  #  workflows:
  #    - "Automerge"
  #  types:
  #    - completed
  schedule:
    - cron: '17 */12 * * *' # schedule-1
    #- cron: '17 */4 * * *' # schedule-2
    #- cron: '2,17,32,47 */1 * * *' # schedule-3
    #- cron: '2,17,32,47 */1 * * *' # schedule-4

jobs:

  npm-test:
    name: 'npm test'
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: read
      id-token: write
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: 'npm'

      - name: Set up ~/.npmrc
        run: |
          echo "@xn-intenton-z2a:registry=https://npm.pkg.github.com" >> ~/.npmrc
          echo "//npm.pkg.github.com/:_authToken=${{ secrets.PERSONAL_ACCESS_TOKEN }}" >> ~/.npmrc
          echo "always-auth=true" >> ~/.npmrc

      - run: npm ci

      - run: npm test

  npm-unit-test:
    name: 'npm unit test with coverage'
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: 'npm'

      - name: Set up ~/.npmrc
        run: |
          echo "@xn-intenton-z2a:registry=https://npm.pkg.github.com" >> ~/.npmrc
          echo "//npm.pkg.github.com/:_authToken=${{ secrets.PERSONAL_ACCESS_TOKEN }}" >> ~/.npmrc
          echo "always-auth=true" >> ~/.npmrc

      - run: npm ci

      - run: npm run test:unit

  npm-build-test-and-run-main:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: 'npm'

      - name: Set up ~/.npmrc
        run: |
          echo "@xn-intenton-z2a:registry=https://npm.pkg.github.com" >> ~/.npmrc
          echo "//npm.pkg.github.com/:_authToken=${{ secrets.PERSONAL_ACCESS_TOKEN }}" >> ~/.npmrc
          echo "always-auth=true" >> ~/.npmrc

      - run: npm ci

      - name: build
        id: build
        shell: bash
        run: 'npm run build'

      - name: test
        id: test
        shell: bash
        run: 'npm test'

      - name: main
        id: main
        shell: bash
        run: timeout 5m ${{ vars.MAIN_SCRIPT || 'npm run start' }}

  mvn-package-cdk-synth:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: 'npm'

      - name: Set up ~/.npmrc
        run: |
          echo "@xn-intenton-z2a:registry=https://npm.pkg.github.com" >> ~/.npmrc
          echo "//npm.pkg.github.com/:_authToken=${{ secrets.PERSONAL_ACCESS_TOKEN }}" >> ~/.npmrc
          echo "always-auth=true" >> ~/.npmrc

      - run: npm ci

      - name: mvn
        id: mvn
        shell: bash
        run: |
          if [ -f pom.xml ]; then
            pomXmlExists='true'
          else
            pomXmlExists='false'
          fi
          echo "pomXmlExists=${pomXmlExists?}" | tee -a "${GITHUB_OUTPUT?}"

      - uses: actions/setup-java@v4
        if: steps.mvn.outputs.pomXmlExists == 'true'
        with:
          distribution: 'corretto'
          java-version: 21
          cache: 'maven'
          server-password: PERSONAL_ACCESS_TOKEN
        env:
          GITHUB_ACTOR: ${{ github.actor }}
          PERSONAL_ACCESS_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}

      - name: check
        id: check
        run: cat ~/.m2/settings.xml
        if: steps.mvn.outputs.pomXmlExists == 'true'

      - name: package
        id: package
        if: steps.mvn.outputs.pomXmlExists == 'true'
        shell: bash
        run: ./mvnw clean package
        env:
          GITHUB_ACTOR: ${{ github.actor }}
          PERSONAL_ACCESS_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}

      - name: synth
        id: synth
        if: steps.mvn.outputs.pomXmlExists == 'true'
        shell: bash
        run: npx cdk synth --strict --validation --no-staging --trace
        env:
          GITHUB_ACTOR: ${{ github.actor }}
          PERSONAL_ACCESS_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}

  select-issue:
    permissions:
      issues: read
      id-token: write
    uses: 'xn-intenton-z2a/agentic-lib/.github/workflows/wfr-github-select-issue.yml@main'
    with:
      issueNumber: ''
      selectionLabel: 'automated'
    secrets:
      CHATGPT_API_SECRET_KEY: ${{ secrets.CHATGPT_API_SECRET_KEY }}

  stats:
    needs:
      - select-issue
    if: ${{ always() }}
    permissions:
      contents: write
      id-token: write
      pages: write
    uses: 'xn-intenton-z2a/agentic-lib/.github/workflows/wfr-github-stats.yml@main'
    with:
      cache: 'npm'
      npmAuthOrganisation: '@xn-intenton-z2a'
      lastActivityName: ${{ github.workflow }}
      lastActivityBranchName: ${{ github.ref_name }}
      nextIssue: "[${{ needs.select-issue.outputs.issueNumber }}] ${{ needs.select-issue.outputs.issueTitle }} ${{ needs.select-issue.outputs.issueLabels }}"
      public: 'public'
      s3BucketUrl: 's3://agentic-lib-telemetry-bucket/events/'
      s3WebsiteBucketUrl: 's3://agentic-lib-public-website-stats-bucket/'
      iamActionsRoleArn: 'arn:aws:iam::541134664601:role/agentic-lib-github-actions-role'
      iamStatsBucketWriterRoleArn: 'arn:aws:iam::541134664601:role/agentic-lib-deployment-role'
      iamPublicWebsiteStatsBucketWriterRoleArn: 'arn:aws:iam::541134664601:role/agentic-lib-public-website-stats-bucket-writer-role'
    secrets:
      PERSONAL_ACCESS_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}
.github/workflows/wfr-github-publish-web.yml
==== Content of .github/workflows/wfr-github-publish-web.yml ====
# .github/workflows/wfr-github-publish-web.yml

#
# agentic-lib
# Copyright (C) 2025 Polycode Limited
#
# This file is part of agentic-lib.
#
# agentic-lib is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License v3.0 (GPL‑3).
# along with this program. If not, see <https://www.gnu.org/licenses/>.
#
# IMPORTANT: Any derived work must include the following attribution:
# "This work is derived from https://github.com/xn-intenton-z2a/agentic-lib"
#

name: ∞ publish web

on:
  workflow_call:
    inputs:
      public:
        description: 'The public directory to use. e.g. "public"'
        type: string
        required: false
        default: 'public'
      cache:
        description: 'The cache to use for npm. e.g. "npm"'
        type: string
        required: false
        default: 'npm'
      npmAuthOrganisation:
        description: 'The npm auth organisation to use. e.g. "@xn-intenton-z2a"'
        type: string
        required: false
      lastActivityName:
        description: 'The name of the last activity. e.g. "publish-web"'
        type: string
        required: false
      lastActivityBranchName:
        description: 'The name of the last activity branch. e.g. "main"'
        type: string
        required: false
      branchPrefix:
        description: 'The prefix for the issue branch. e.g. "agentic-lib-issue-"'
        type: string
        required: false
        default: 'agentic-lib-issue-'
      nextIssue:
        description: 'The next issue to review. e.g. "123 My issue automated"'
        type: string
        required: false
      publishToGitHubPages:
        description: 'Whether to publish to GitHub Pages. e.g. "true"'
        type: string
        required: false
        default: 'true'
      featuresDir:
        description: 'The directory containing feature files. e.g. "features/"'
        type: string
        required: false
        default: 'features/'
    secrets:
      PERSONAL_ACCESS_TOKEN:
        required: false
    outputs:
      thisRepositoryWebsiteUrl:
        description: 'The URL of the website. e.g. "https://xn-intenton-z2a.github.io/agentic-lib/index.html"'
        value: ${{ jobs.publish-web.outputs.thisRepositoryWebsiteUrl }}

jobs:
  publish-web:
    runs-on: ubuntu-latest

    env:
      public: ${{ inputs.public || 'public' }}
      cache: ${{ inputs.cache || 'npm' }}
      npmAuthOrganisation: ${{ inputs.npmAuthOrganisation || '' }}
      lastActivityName: ${{ inputs.lastActivityName || '' }}
      lastActivityBranchName: ${{ inputs.lastActivityBranchName || '' }}
      branchPrefix: ${{ inputs.branchPrefix || 'agentic-lib-issue-' }}
      nextIssue: ${{ inputs.nextIssue || '' }}
      publishToGitHubPages: ${{ inputs.publishToGitHubPages || 'true' }}
      featuresDir: ${{ inputs.featuresDir || 'features/' }}

    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ github.ref }}
          fetch-depth: 0

      - uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: ${{ env.cache }}

      - name: Set up .npmrc
        shell: bash
        run: |
          echo "${{ env.npmAuthOrganisation }}:registry=https://npm.pkg.github.com" >> .npmrc
          echo "//npm.pkg.github.com/:_authToken=${{ secrets.PERSONAL_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}" >> .npmrc
          echo "always-auth=true" >> .npmrc

      - name: engine
        id: engine
        shell: bash
        run: |
          if [ -f ".github/agentic-lib.yml" ]; then
            engine=$(grep '^schedule:' .github/agentic-lib.yml | awk '{print $2}')
            echo "engine=${engine}"
            echo "engine=${engine}" >> $GITHUB_OUTPUT
          else
            echo "engine=default"
            echo "engine=default" >> $GITHUB_OUTPUT
            echo "Warning: .github/agentic-lib.yml file not found, using default engine"
          fi

      - run: npm install
        if: ${{ env.publishToGitHubPages == 'true' }}

      - name: Generate HTML articles from library documents
        id: generate-articles
        if: ${{ env.publishToGitHubPages == 'true' }}
        shell: bash
        run: |
          # Create public directory if it doesn't exist
          mkdir -p ${{ env.public }}

          # Check if scripts directory and md-to-html.js exist
          if [ ! -d "scripts" ]; then
            echo "Warning: scripts directory not found, creating it"
            mkdir -p scripts
          fi

          if [ ! -f "scripts/md-to-html.js" ]; then
            echo "Error: scripts/md-to-html.js not found"
            echo "Creating a simple placeholder HTML file for each markdown file"

            # Find all markdown files in the features directory
            find "${{ env.featuresDir }}" -maxdepth 2 -type f -name "*.md" | while read -r file; do
              # Get the filename without path and extension
              filename=$(basename "$file" .md)
              echo "Creating placeholder HTML for $file to ${{ env.public }}/$filename.html"

              # Create a simple HTML file
              echo "<!DOCTYPE html><html><head><title>$filename</title></head><body><h1>$filename</h1><p>Markdown conversion failed: scripts/md-to-html.js not found</p></body></html>" > "${{ env.public }}/$filename.html"
            done
          else
            # Find all markdown files in the features directory
            find "${{ env.featuresDir }}" -maxdepth 2 -type f -name "*.md" | while read -r file; do
              # Get the filename without path and extension
              filename=$(basename "$file" .md)
              echo "Converting $file to ${{ env.public }}/$filename.html"

              # Convert markdown to HTML using the md-to-html.js script
              ./scripts/md-to-html.js < "$file" > "${{ env.public }}/$filename.html"
            done
          fi

          # Create a list of all articles for the index page
          echo "Generating article list for index page"
          article_list=""
          find "${{ env.public }}" -type f -name "*.html" | grep -v "index.html" | sort | while read -r html_file; do
            filename=$(basename "$html_file")
            name="${filename%.*}"
            # Skip if this is not a feature file
            if [[ "$html_file" != *"${{ env.public }}"* ]]; then
              continue
            fi
            article_list="${article_list}<li><a href=\"${filename}\">${name}</a></li>\n"
          done

          # Save the article list to a file for later use
          echo -e "$article_list" > "${{ env.public }}/article_list.txt"

          echo "Articles generated successfully"

      - name: Generate index page
        if: ${{ env.publishToGitHubPages == 'true' }}
        shell: bash
        run: |
          # Check if README.md exists
          if [ ! -f "README.md" ]; then
            echo "Warning: README.md not found, creating a placeholder"
            echo "# Project README" > README.md
            echo "This is a placeholder README file." >> README.md
          fi

          # Check if scripts/md-to-html.js exists
          if [ ! -f "scripts/md-to-html.js" ]; then
            echo "Warning: scripts/md-to-html.js not found, creating a simple HTML file"
            echo "<!DOCTYPE html><html><head><title>README</title></head><body><h1>Project README</h1><p>This is a placeholder README file.</p></body></html>" > ${{ env.public }}/readme.html
          else
            # Convert README.md to HTML for the summary
            ./scripts/md-to-html.js < README.md > ${{ env.public }}/readme.html
          fi

          # Extract the article list
          article_list=$(cat "${{ env.public }}/article_list.txt")

          # Create the index.html file with the article list and README summary
          cat > ${{ env.public }}/index.html << EOF
          <!DOCTYPE html>
          <html lang="en">
          <head>
            <meta charset="UTF-8">
            <title>agentic-lib Documentation</title>
            <style>
              body { font-family: Arial, sans-serif; margin: 2em; background-color: #f9f9f9; color: #333; }
              header { padding-bottom: 1em; border-bottom: 2px solid #ccc; margin-bottom: 1em; }
              h1 { font-size: 2em; }
              h2 { font-size: 1.5em; margin-top: 1.5em; }
              section { margin-bottom: 1.5em; }
              ul { list-style: none; padding: 0; }
              li { margin: 0.5em 0; }
              .label { font-weight: bold; }
              footer { margin-top: 2em; font-size: 0.9em; color: #777; }
              a { color: #0366d6; text-decoration: none; }
              a:hover { text-decoration: underline; }
            </style>
          </head>
          <body>
            <header>
              <h1>agentic-lib Documentation</h1>
              <p><a href="https://github.com/xn-intenton-z2a/agentic-lib">Repository</a></p>
            </header>

            <section>
              <h2>Library Documents</h2>
              <ul>
                ${article_list}
              </ul>
            </section>

            <section>
              <h2>Project Summary</h2>
              $(cat ${{ env.public }}/readme.html | grep -v '<!DOCTYPE' | grep -v '<html' | grep -v '<head>' | grep -v '<body>' | grep -v '</body>' | grep -v '</html>')
            </section>

            <footer>
              <p>Generated on $(date -u +"%Y-%m-%dT%H:%M:%SZ")</p>
            </footer>
          </body>
          </html>
          EOF

          # Clean up temporary files
          rm -f ${{ env.public }}/article_list.txt
          rm -f ${{ env.public }}/readme.html

          echo "Index page generated successfully"

      - name: Deploy to GitHub Pages
        if: ${{ env.publishToGitHubPages == 'true' }}
        uses: peaceiris/actions-gh-pages@v4
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: ${{ env.public }}
          publish_branch: github-pages
          keep_files: true
          enable_jekyll: 'true'

      - name: Upload generated site as artifact
        if: ${{ env.publishToGitHubPages == 'true' }}
        uses: actions/upload-artifact@v4
        with:
          name: site
          path: ${{ env.public }}

      - name: Output published github pages URLs
        if: ${{ env.publishToGitHubPages == 'true' }}
        id: output-pages-urls
        run: |
          echo "[INFO] Determining GitHub Pages URL..."
          # GitHub Pages URL typically: https://<owner>.github.io/<repo>/
          repoName=${{ github.event.repository.name }}
          owner=${{ github.repository_owner }}
          baseUrl="https://${owner}.github.io/${repoName}"
          thisRepositoryWebsiteUrl="${baseUrl}/index.html"
          echo "::notice:: thisRepositoryWebsiteUrl: ${thisRepositoryWebsiteUrl}"
          echo "thisRepositoryWebsiteUrl=${thisRepositoryWebsiteUrl}" >> $GITHUB_OUTPUT

    outputs:
      thisRepositoryWebsiteUrl: ${{ steps.output-pages-urls.outputs.thisRepositoryWebsiteUrl }}
.github/workflows/wfr-completion-maintain-sources.yml
==== Content of .github/workflows/wfr-completion-maintain-sources.yml ====
# .github/workflows/wfr-completion-maintain-sources.yml

#
# agentic-lib
# Copyright (C) 2025 Polycode Limited
#
# This file is part of agentic-lib.
#
# agentic-lib is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License v3.0 (GPL‑3).
# along with this program. If not, see <https://www.gnu.org/licenses/>.
#
# IMPORTANT: Any derived work must include the following attribution:
# "This work is derived from https://github.com/xn-intenton-z2a/agentic-lib"
#

name: ∞ maintain-sources

on:
  workflow_call:
    inputs:
      source:
        description: 'Text to drive the source creation (if "house choice", the repository will be assessed and an action chosen). e.g. "Add a source about agents."'
        type: string
        required: false
        default: 'house choice'
      sourcesFile:
        description: 'The file to create/update the sources in. e.g. "SOURCES.md"'
        type: string
        required: false
        default: 'SOURCES.md'
      sourcesLimit:
        description: 'The maximum number of sources to create. e.g. "3"'
        type: string
        required: false
        default: '32'
      featuresDir:
        description: 'The directory to read the features from. e.g. "features/"'
        type: string
        required: false
        default: 'features/'
      target:
        description: 'The target file to create the issue to change. e.g. "src/lib/main.js"'
        type: string
        required: false
        default: 'src/lib/main.js'
      testFile:
        description: 'The test file. e.g. "tests/unit/main.test.js"'
        type: string
        required: false
        default: 'tests/unit/main.test.js'
      readmeFile:
        description: 'The README file. e.g. "README.md"'
        type: string
        required: false
        default: 'README.md'
      missionFile:
        description: 'The MISSION statement file. e.g. "MISSION.md"'
        type: string
        required: false
        default: 'MISSION.md'
      contributingFile:
        description: 'The CONTRIBUTING file. e.g. "CONTRIBUTING.md"'
        type: string
        required: false
        default: 'CONTRIBUTING.md'
      dependenciesFile:
        description: 'The dependencies file. e.g. "package.json"'
        type: string
        required: false
        default: 'package.json'
      buildScript:
        description: 'The script must be runnable as: `npm ci ; <script>` and succeed with a zero exit code. e.g. `npm run build`'
        type: string
        required: false
        default: 'echo "No build script specified."'
      testScript:
        description: 'The script must be runnable as: `npm ci ; <script>` and succeed with a zero exit code. e.g. `npm test`'
        type: string
        required: false
        default: 'npm test'
      mainScript:
        description: 'The script must be runnable as: `npm ci ; <script>` and succeed with a zero exit code. e.g. `npm run start`'
        type: string
        required: false
        default: 'npm run start'
      model:
        description: 'The OpenAI model to use. e.g. "o3-mini"'
        type: string
        required: false
        default: ${{ vars.CHATGPT_API_MODEL || 'o3-mini' }}
      npmAuthOrganisation:
        description: 'The GitHub organisation to authenticate with for npm. e.g. "xn-intenton-z2a"'
        type: string
        required: false
        default: ''
      gitUserEmail:
        description: 'The email to use for git commits. e.g. "action@github.com"'
        type: string
        required: false
        default: 'action@github.com'
      gitUserName:
        description: 'The name to use for git commits. e.g. "GitHub Actions[bot]"'
        type: string
        required: false
        default: 'GitHub Actions[bot]'
      s3BucketUrl:
        description: 'The S3 bucket URL with prefix to use. e.g. "s3://my-bucket/prefix"'
        type: string
        required: false
        default: ''
      iamRoleArn:
        description: 'The ARN of the IAM role to assume. e.g. "arn:aws:iam::123456789012:role/my-role"'
        type: string
        required: false
        default: ''
    secrets:
      PERSONAL_ACCESS_TOKEN:
        required: false
      CHATGPT_API_SECRET_KEY:
        required: true
    outputs:
      sourcesDirectoryFileContent:
        value: ${{ jobs.maintain-sources.outputs.sourcesDirectoryFileContent }}

jobs:
  maintain-sources:
    runs-on: ubuntu-latest

    env:
      source: ${{ inputs.source || '' }}
      sourcesFile: ${{ inputs.sourcesFile || 'SOURCES.md' }}
      sourcesLimit: ${{ inputs.sourcesLimit || '32' }}
      featuresDir: ${{ inputs.featuresDir || 'features/' }}
      target: ${{ inputs.target || 'src/lib/main.js' }}
      testFile: ${{ inputs.testFile || 'tests/unit/main.test.js' }}
      readmeFile: ${{ inputs.readmeFile || 'README.md' }}
      missionFile: ${{ inputs.missionFile || 'MISSION.md' }}
      contributingFile: ${{ inputs.contributingFile || 'CONTRIBUTING.md' }}
      dependenciesFile: ${{ inputs.dependenciesFile || 'package.json' }}
      buildScript: ${{ inputs.buildScript || 'npm run build' }}
      testScript: ${{ inputs.testScript || 'npm test' }}
      mainScript: ${{ inputs.mainScript || 'npm run start' }}
      mainScriptTimeout: '5m'
      testScriptTimeout: '5m'
      buildScriptTimeout: '5m'
      model: ${{ inputs.model || vars.CHATGPT_API_MODEL || 'o3-mini' }}
      npmAuthOrganisation: ${{ inputs.npmAuthOrganisation || '' }}
      gitUserEmail: ${{ inputs.gitUserEmail || 'action@github.com' }}
      gitUserName: ${{ inputs.gitUserName || 'GitHub Actions[bot]' }}
      chatgptApiSecretKey: ${{ secrets.CHATGPT_API_SECRET_KEY }}
      s3BucketUrl: ${{ inputs.s3BucketUrl || '' }}
      iamRoleArn: ${{ inputs.iamRoleArn || '' }}

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Check GitHub authentication
        if: ${{ env.npmAuthOrganisation != '' }}
        shell: bash
        run: |
          curl --include --header "Authorization: token ${{ secrets.PERSONAL_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}" https://api.github.com/user

      - name: Set up .npmrc
        if: ${{ env.npmAuthOrganisation != '' }}
        shell: bash
        run: |
          echo "${{ env.npmAuthOrganisation }}:registry=https://npm.pkg.github.com" >> .npmrc
          echo "//npm.pkg.github.com/:_authToken=${{ secrets.PERSONAL_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}" >> .npmrc
          echo "always-auth=true" >> .npmrc

      - run: npm ci

      - name: List current features
        id: features
        shell: bash
        run: |
          output=$(find "${{ env.featuresDir }}" -maxdepth 1 -type f -name '*.md' -print -exec echo "# {}" \; -exec cat {} \; 2>&1 || echo 'none')
          echo "output<<EOF" >> "$GITHUB_OUTPUT"
          echo "$output" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          echo "output=${output}"

      - name: List rejected features
        id: rejectedFeatures
        shell: bash
        run: |
          mkdir -p "${{ env.featuresDir }}/rejects"
          output=$(ls -1 "${{ env.featuresDir }}/rejects" | sed 's/\.md//' | xargs echo )
          echo "output<<EOF" >> "$GITHUB_OUTPUT"
          echo "$output" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          echo "output=${output}"

      - name: List dependencies
        id: list
        shell: bash
        run: |
          output=$(npm list 2>&1)
          echo "output<<EOF" >> "$GITHUB_OUTPUT"
          echo "$output" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          echo "output=${output}"

      - name: Build project
        id: build
        shell: bash
        run: |
          output=$(timeout ${{ env.buildScriptTimeout }} ${{ env.buildScript }} 2>&1)
          echo "output<<EOF" >> "$GITHUB_OUTPUT"
          echo "$output" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          echo "output=${output}"

      - name: Tear down .npmrc
        if: ${{ env.npmAuthOrganisation != '' }}
        shell: bash
        run: rm -f .npmrc

      - name: Run tests
        id: test
        shell: bash
        run: |
          output=$(timeout ${{ env.testScriptTimeout }} ${{ env.testScript }} 2>&1)
          echo "output<<EOF" >> "$GITHUB_OUTPUT"
          echo "$output" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          echo "output=${output}"

      - name: Run main
        id: main
        shell: bash
        run: |
          output=$(timeout ${{ env.mainScriptTimeout }} ${{ env.mainScript }} 2>&1)
          echo "output<<EOF" >> "$GITHUB_OUTPUT"
          echo "$output" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          echo "output=${output}"

      - name: Touch or create sources file
        id: touch
        shell: bash
        run: |
          if [ ! -f "${{ env.sourcesFile }}" ]; then
            echo "Creating sources file ${GITHUB_WORKSPACE}/${{ env.sourcesFile }}"
            touch "${{ env.sourcesFile }}"
            ls -lrt "${{ env.sourcesFile }}"
            cat "${{ env.sourcesFile }}"
          else
            echo "Touching sources file ${GITHUB_WORKSPACE}/${{ env.sourcesFile }}"
            touch "${{ env.sourcesFile }}"
            ls -lrt "${{ env.sourcesFile }}"
            cat "${{ env.sourcesFile }}"
          fi

      - name: maintain-sources
        id: maintain-sources
        uses: actions/github-script@v7
        env:
          currentFeatures: ${{ steps.features.outputs.output }}
          rejectedFeatures: ${{ steps.rejectedFeatures.outputs.output }}
          dependenciesListOutput: ${{ steps.list.outputs.output }}
          buildOutput: ${{ steps.build.outputs.output }}
          testOutput: ${{ steps.test.outputs.output }}
          mainOutput: ${{ steps.main.outputs.output }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const source = process.env.source;
            const sourcesFile = process.env.sourcesFile;
            const sourcesLimit = process.env.sourcesLimit;
            const currentFeatures = process.env.currentFeatures;
            const rejectedFeatures = process.env.rejectedFeatures;
            const target = process.env.target;
            const testFile = process.env.testFile;
            const readmeFile = process.env.readmeFile;
            const missionFile = process.env.missionFile;
            const contributingFile = process.env.contributingFile;
            const dependenciesFile = process.env.dependenciesFile;
            const model = process.env.model;
            const apiKey = process.env.chatgptApiSecretKey;
            const dependenciesListOutput = process.env.dependenciesListOutput;
            const buildScript = process.env.buildScript;
            const buildOutput = process.env.buildOutput;
            const testScript = process.env.testScript;
            const testOutput = process.env.testOutput;
            const mainScript = process.env.mainScript;
            const mainOutput = process.env.mainOutput;

            const fs = require('fs');
            const path = require('path');
            const OpenAI = require('openai').default;
            const { z } = require('zod');
            require('dotenv').config();

            if (!apiKey) { 
              core.setFailed("Missing CHATGPT_API_SECRET_KEY"); 
            }
            const openai = new OpenAI({ apiKey });

            core.info(`source: "${source}"`);
            core.info(`sourcesFile: "${sourcesFile}"`);
            core.info(`currentFeatures: "${currentFeatures}"`);
            core.info(`target: "${target}"`);
            core.info(`testFile: "${testFile}"`);
            core.info(`readmeFile: "${readmeFile}"`);
            core.info(`missionFile: "${missionFile}"`);
            core.info(`contributingFile: "${contributingFile}"`);
            core.info(`dependenciesFile: "${dependenciesFile}"`);

            core.info(`Loading sources directory file '${sourcesFile}'...`);            
            const sourcesFileContent = fs.readFileSync(sourcesFile, 'utf8');
            core.info(`Sources directory file '${sourcesFile}' has been loaded (length ${sourcesFileContent.length}).`);

            const targetFileContent = fs.readFileSync(target, 'utf8');
            const testFileContent = fs.readFileSync(testFile, 'utf8');
            const readmeFileContent = fs.readFileSync(readmeFile, 'utf8');
            const missionFileContent = fs.readFileSync(missionFile, 'utf8');
            const contributingFileContent = fs.readFileSync(contributingFile, 'utf8');
            const dependenciesFileContent = fs.readFileSync(dependenciesFile, 'utf8');
            core.info(`Target file '${target}' has been loaded (length ${targetFileContent.length}).`);
            core.info(`Test file '${testFile}' has been loaded (length ${testFileContent.length}).`);
            core.info(`Readme file '${readmeFile}' has been loaded (length ${readmeFileContent.length}).`);
            core.info(`Dependencies file '${dependenciesFile}' has been loaded (length ${dependenciesFileContent.length}).`);

            // generate the source prompt either by using the supplied source prompt or by reviewing the current sources and full context
            let prompt = source;
            if (source === 'house choice') {
              prompt = `Please review the current sources in the directory and either;
                * add a new source to the repository, or
                * extend an existing source to add a new aspect to it, or
                * update an existing source to bring it to a high standard matching other sources in the repository.
                The source name should either be a current source name or be supplied with a source specification which is distinct from any other feature in the repository.
              `;
            }

            const chatGptPrompt = `
            Please create, extend or update the document sources in the sourcesFile based the supplied source prompt.
            Add or update as many as you can, review and refine the summaries to match the latest information you have.
            If there is nothing to add consider pruning some overlapping topics.
            If you can request some content from the URL do so and summarise it.
            The sources should be URLs which can be accessed without authentication for content which is publicly available.
            The URLs should be public URLS on the internet external to this repository. e.g. https://docs.github.com/en/rest
            Pick subjects which are relevant to the repository and which are not already covered by the current sources.
            Locate competitors and similar projects to the repository and find their documentation providing that it is permissible to do so.
            Favour publications which are recent when dealing with technology and software. Increase your temperature if his model supports it.
            You are maintaining a file which should contain name, descriptions, licenses and URLS of document sources to be used in the repository.
            The file is in markdown format and should be a list of sources with repeated sections of the following format:
            START_OF_FORMAT
            # Source Name
            ## https://docs.github.com/en/rest
            Source description. This can be several sentences long and should be a summary of the content of the source.
            Include last known publication dates if you can and view you have on how authoritative the source is (and how you know this).
            ## License if known
            END_OF_FORMAT
            If there are more than the maximum number of ${sourcesLimit} sources in the repository, you must merge similar sources into a single source.
            Always return the whole modified sources file content (not just the changed parts).
            The source directory should be a multiline markdown with a few level 1 (#) headings for a source name then level 2 (##) with the url of a document source 
            followed by a description and license.
            Consider the following when refining your response:
            * Source prompt details
            * Current sources file content
            * Current feature names and specifications in the repository
            * Rejected feature names
            * Target file content
            * Test file content
            * README file content
            * MISSION file content
            * Contributing file content
            * Dependencies file content
            * Dependency list
            * Build output
            * Test output
            * Main execution output

            Source prompt:
            SOURCE_PROMPT_START
            ${prompt}
            SOURCE_PROMPT_END            

            Current sources file content:
            SOURCES_FILE_START
            ${sourcesFileContent}
            SOURCES_FILE_END

            Current feature names and specifications:
            CURRENT_FEATURES_START
            ${currentFeatures}
            CURRENT_FEATURES_END

            Rejected feature names:
            REJECTED_FEATURES_START
            ${rejectedFeatures}
            REJECTED_FEATURES_END

            Target file: ${target}
            TARGET_FILE_START
            ${targetFileContent}
            TARGET_FILE_END

            Test file: ${testFile}
            TEST_FILE_START
            ${testFileContent}
            TEST_FILE_END

            README file: ${readmeFile}
            README_FILE_START
            ${readmeFileContent}
            README_FILE_END

            MISSION file: ${missionFile}
            MISSION_FILE_START
            ${missionFileContent}
            MISSION_FILE_END

            Contributing file: ${contributingFile}
            CONTRIBUTING_FILE_START
            ${contributingFileContent}
            CONTRIBUTING_FILE_END

            Dependencies file: ${dependenciesFile}
            DEPENDENCIES_FILE_START
            ${dependenciesFileContent}
            DEPENDENCIES_FILE_END

            Dependencies list from command: npm list
            DEPENDENCIES_LIST_START
            ${dependenciesListOutput}
            DEPENDENCIES_LIST_END    

            Build output from command: ${buildScript}
            BUILD_OUTPUT_START
            ${buildOutput}
            BUILD_OUTPUT_END      

            Test output from command: ${testScript}
            TEST_OUTPUT_START
            ${testOutput}
            TEST_OUTPUT_END            

            Main output from command: ${mainScript}
            MAIN_OUTPUT_START
            ${mainOutput}
            MAIN_OUTPUT_END

            Answer strictly with a JSON object following this schema:
            {
              "sourcesDirectoryFileContent": "The source directory should be a multiline markdown with a few level 1 (#) headings a source name preceding level 2 (##) with the url of a document source."
            }
            Ensure valid JSON.
            `;

            const ResponseSchema = z.object({ sourcesDirectoryFileContent: z.string() });

            // Define the function schema for function calling
            const tools = [{
              type: "function",
              function: {
                name: "generate_sources",
                description: "Elaborate on the supplied prompt and project files to create the sourcesDirectoryFileContent of a repository source. Return an object with sourcesDirectoryFileContent (string).",
                parameters: {
                  type: "object",
                  properties: {
                    sourcesDirectoryFileContent: { type: "string", description: "The source directory should be a multiline markdown with a few level 1 (#) headings a source name preceding level 2 (##) with the url of a document source." }
                  },
                  required: ["sourcesDirectoryFileContent"],
                  additionalProperties: false
                },
                strict: true
              }
            }];

            // Call OpenAI using function calling format
            const response = await openai.chat.completions.create({
              model,
              messages: [
                { role: "system", content: "You are maintaining a library of repository context providing expert contemporary insight into both the product market and you will perform a detailed analysis of the current state of the repository and current feature set in search of ideas for find useful information sources. Answer strictly with a JSON object following the provided function schema." },
                { role: "user", content: chatGptPrompt }
              ],
              tools: tools
            });

            let result;
            if (response.choices[0].message.tool_calls && response.choices[0].message.tool_calls.length > 0) {
              try {
                result = JSON.parse(response.choices[0].message.tool_calls[0].function.arguments);
              } catch (e) {
                core.setFailed(`Failed to parse function call arguments: ${e.message}`);
              }
            } else if (response.choices[0].message.content) {
              try {
                result = JSON.parse(response.choices[0].message.content);
              } catch (e) {
                core.setFailed(`Failed to parse response content: ${e.message}`);
              }
            } else {
              core.setFailed("No valid response received from OpenAI.");
            }

            try {
              const parsed = ResponseSchema.parse(result);
              core.setOutput("sourcesDirectoryFileContent", parsed.sourcesDirectoryFileContent);
              core.info(`sourcesDirectoryFileContent: "${parsed.sourcesDirectoryFileContent}"`);

              const sourcesDirectoryFileContent = parsed.sourcesDirectoryFileContent;
              const sourcesDirectoryFilePath = process.env.sourcesFile || 'SOURCES.md';

              try {
                fs.writeFileSync(sourcesDirectoryFilePath, sourcesDirectoryFileContent);
                core.info(`source directory saved to ${sourcesDirectoryFilePath}`);
              } catch (e) {
                core.setFailed(`Failed to save source directory: ${e.message}`);
              }

            } catch (e) {
              core.setFailed(`Failed to parse ChatGPT response: ${e.message}`);
            }

            core.setOutput("response", JSON.stringify(response));
            core.setOutput("usage", JSON.stringify(response.usage));
            core.info(`response: "${JSON.stringify(response)}"`);
            core.info(`usage: "${JSON.stringify(response.usage)}"`);

      - name: Commit changes
        id: commit
        continue-on-error: true
        run: |
          git config --local user.email '${{ env.gitUserEmail }}'
          git config --local user.name '${{ env.gitUserName }}'
          git status -v
          git add -v --all '${{ env.sourcesFile }}'
          git commit -m 'Maintain ${{ env.sourcesFile }}'
          git status -v
          git push -v origin ${{ github.ref }}
          git status -v
.github/workflows/source-worker.yml
==== Content of .github/workflows/source-worker.yml ====
# .github/workflows/source-worker.yml
#
# This file is part of the example suite for `agentic-lib` see: https://github.com/xn-intenton-z2a/agentic-lib
# This file is licensed under the MIT License. For details, see LICENSE-MIT

name: Source Worker
concurrency: source-worker
run-name: "Source Worker"

on:
  #push:
  #  paths:
  #    - '**/*.yml'
  workflow_dispatch:
    inputs:
      source:
        description: 'Text to drive the source creation (if "house choice", the repository will be assessed and an action chosen). e.g. "Find out about using agents and LLMs."'
        required: false
        type: string
        default: 'house choice'
  schedule:
    - cron: '5 4 */7 * *' # schedule-1
    #- cron: '5 4 * * *' # schedule-2
    #- cron: '5 */1 * * *' # schedule-3
    #- cron: '5 * * * *' # schedule-4

jobs:

  agentic-lib:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: agentic-lib
        id: agentic-lib
        shell: bash
        run: |
          if [ -f ".github/agentic-lib.yml" ]; then
            sourcesLimit=$(grep '^sourcesLimit:' .github/agentic-lib.yml | awk '{print $2}')
            if [ -z "$sourcesLimit" ]; then
              sourcesLimit="32"
              echo "Warning: sourcesLimit not found in .github/agentic-lib.yml, using default value: ${sourcesLimit}"
            fi
          else
            sourcesLimit="32"
            echo "Warning: .github/agentic-lib.yml file not found, using default sourcesLimit: ${sourcesLimit}"
          fi
          echo "sourcesLimit=${sourcesLimit}"
          echo "sourcesLimit=${sourcesLimit}" >> $GITHUB_OUTPUT
    outputs:
      sourcesLimit: ${{ steps.agentic-lib.outputs.sourcesLimit }}

  # If the feature is "house choice", the repository will be assessed an action chosen otherwise the supplied text will be used to generate a new feature.
  maintain-sources:
    needs:
      - agentic-lib
    permissions:
      contents: write
      issues: write
      id-token: write
    uses: 'xn-intenton-z2a/agentic-lib/.github/workflows/wfr-completion-maintain-sources.yml@main'
    with:
      source: ${{ inputs.source }}
      sourcesFile: 'SOURCES.md'
      sourcesLimit: '${{ needs.agentic-lib.outputs.sourcesLimit }}'
      target: ${{ inputs.target || 'src/lib/main.js' }}
      testFile: ${{ inputs.testFile || 'tests/unit/main.test.js' }}
      readmeFile: 'README.md'
      missionFile: 'MISSION.md'
      contributingFile: 'CONTRIBUTING.md'
      dependenciesFile: 'package.json'
      buildScript: 'npm run build'
      testScript: 'npm test'
      mainScript: ${{ vars.MAIN_SCRIPT || 'npm run start' }}
      model: ${{ vars.CHATGPT_API_MODEL || 'o3-mini' }}
      npmAuthOrganisation: '@xn-intenton-z2a'
      gitUserEmail: 'action@github.com'
      gitUserName: 'GitHub Actions[bot]'
    secrets:
      CHATGPT_API_SECRET_KEY: ${{ secrets.CHATGPT_API_SECRET_KEY }}
      PERSONAL_ACCESS_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}

  select-issue:
    permissions:
      issues: read
      id-token: write
    uses: 'xn-intenton-z2a/agentic-lib/.github/workflows/wfr-github-select-issue.yml@main'
    with:
      issueNumber: ''
      selectionLabel: 'automated'
    secrets:
      CHATGPT_API_SECRET_KEY: ${{ secrets.CHATGPT_API_SECRET_KEY }}

  stats:
    needs:
      - select-issue
      - maintain-sources
    if: ${{ always() }}
    permissions:
      contents: write
      id-token: write
      pages: write
    uses: 'xn-intenton-z2a/agentic-lib/.github/workflows/wfr-github-stats.yml@main'
    with:
      cache: 'npm'
      npmAuthOrganisation: '@xn-intenton-z2a'
      lastActivityName: ${{ github.workflow }}
      lastActivityBranchName: ${{ github.ref_name }}
      nextIssue: "[${{ needs.select-issue.outputs.issueNumber }}] ${{ needs.select-issue.outputs.issueTitle }} ${{ needs.select-issue.outputs.issueLabels }}"
      public: 'public'
      s3BucketUrl: 's3://agentic-lib-telemetry-bucket/events/'
      s3WebsiteBucketUrl: 's3://agentic-lib-public-website-stats-bucket/'
      iamActionsRoleArn: 'arn:aws:iam::541134664601:role/agentic-lib-github-actions-role'
      iamStatsBucketWriterRoleArn: 'arn:aws:iam::541134664601:role/agentic-lib-deployment-role'
      iamPublicWebsiteStatsBucketWriterRoleArn: 'arn:aws:iam::541134664601:role/agentic-lib-public-website-stats-bucket-writer-role'
    secrets:
      PERSONAL_ACCESS_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}
.github/workflows/maintenance-issue-creator.yml
==== Content of .github/workflows/maintenance-issue-creator.yml ====
# .github/workflows/maintenance-issue-creator.yml
#
# This file is part of the example suite for `agentic-lib` see: https://github.com/xn-intenton-z2a/agentic-lib
# This file is licensed under the MIT License. For details, see LICENSE-MIT

name: Create Maintenance Issue
concurrency: agentic-lib-issue
run-name: "Create Maintenance Issue"

on:
  workflow_dispatch:
    inputs:
      prompt:
        description: 'Text to drive the issue creation (if "house choice", a currently random prompt will be selected). e.g. "Make an improvement to tests."'
        required: false
        type: string
        default: 'house choice'
  schedule:
    - cron: '0 5 */7 * *' # schedule-1
    #- cron: '0 5 * * *' # schedule-2
    #- cron: '0 */1 4-31/4 * *' # schedule-3
    #- cron: '0,27 */1 4-31/4 * *' # schedule-4

jobs:

  agentic-lib:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: agentic-lib
        id: agentic-lib
        shell: bash
        run: |
          maintenanceIssuesWipLimit=$(grep '^maintenanceIssuesWipLimit:' .github/agentic-lib.yml | awk '{print $2}')
          echo "maintenanceIssuesWipLimit=${maintenanceIssuesWipLimit}"
          echo "maintenanceIssuesWipLimit=${maintenanceIssuesWipLimit}" >> $GITHUB_OUTPUT
    outputs:
      maintenanceIssuesWipLimit: ${{ steps.agentic-lib.outputs.maintenanceIssuesWipLimit }}

  # If the prompt is "house choice", a random prompt will be selected from the prompt library otherwise the supplied title will be used.
  select-prompt:
    runs-on: ubuntu-latest
    outputs:
      prompt: ${{ steps.extract.outputs.prompt }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Select prompt from ./prompts
        id: select
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = require('path');
            let prompt = '${{ inputs.prompt }}';
            if (prompt === 'house choice') {
              const promptsDir = './prompts';
              // Get all items in the directory
              const items = fs.readdirSync(promptsDir);
              // Filter only the files (exclude directories)
              const files = items.filter(item => {
                const filePath = path.join(promptsDir, item);
                return fs.lstatSync(filePath).isFile();
              });
            
              if (files.length === 0) {
                core.setFailed('No prompt files found in the prompts directory.');
              } else {
                // Select a random file
                const randomFile = files[Math.floor(Math.random() * files.length)];
                const filePath = path.join(promptsDir, randomFile);
                prompt = fs.readFileSync(filePath, 'utf8');
              }
            }
              
            core.setOutput('prompt', prompt);
            core.info(`prompt: ${prompt}`);

  generate-maintenance-issue:
    needs:
      - select-prompt
    permissions:
      contents: write
      issues: write
      id-token: write
    uses: 'xn-intenton-z2a/agentic-lib/.github/workflows/wfr-completion-generate-maintenance-issue.yml@main'
    with:
      prompt: ${{ needs.select-prompt.outputs.prompt }}
      maintenanceIssuesWipLimit: '${{ needs.agentic-lib.outputs.maintenanceIssuesWipLimit }}'
      target: ${{ inputs.target || 'src/lib/main.js' }}
      testFile: ${{ inputs.testFile || 'tests/unit/main.test.js' }}
      readmeFile: 'README.md'
      missionFile: 'MISSION.md'
      contributingFile: 'CONTRIBUTING.md'
      dependenciesFile: 'package.json'
      buildScript: 'npm run build'
      testScript: 'npm test'
      issueSelectionLabel: 'maintenance'
      mainScript: ${{ vars.MAIN_SCRIPT || 'npm run start' }}
      model: ${{ vars.CHATGPT_API_MODEL || 'o3-mini' }}
      npmAuthOrganisation: '@xn-intenton-z2a'
    secrets:
      CHATGPT_API_SECRET_KEY: ${{ secrets.CHATGPT_API_SECRET_KEY }}
      PERSONAL_ACCESS_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}

  create-issue:
    needs:
      - select-prompt
      - generate-maintenance-issue
    permissions:
      issues: write
      id-token: write
    uses: 'xn-intenton-z2a/agentic-lib/.github/workflows/wfr-github-create-issue.yml@main'
    with:
      issueTitle: ${{ needs.generate-maintenance-issue.outputs.issueTitle }}
      issueBody: ${{ needs.generate-maintenance-issue.outputs.issueDescription }}
      issueLabels: 'maintenance, automated'

  select-issue:
    permissions:
      issues: read
      id-token: write
    uses: 'xn-intenton-z2a/agentic-lib/.github/workflows/wfr-github-select-issue.yml@main'
    with:
      issueNumber: ''
      selectionLabel: 'automated'
    secrets:
      CHATGPT_API_SECRET_KEY: ${{ secrets.CHATGPT_API_SECRET_KEY }}

  stats:
    needs:
      - select-issue
      - create-issue
    if: ${{ always() }}
    permissions:
      contents: write
      id-token: write
      pages: write
    uses: 'xn-intenton-z2a/agentic-lib/.github/workflows/wfr-github-stats.yml@main'
    with:
      cache: 'npm'
      npmAuthOrganisation: '@xn-intenton-z2a'
      lastActivityName: ${{ github.workflow }}
      lastActivityBranchName: ${{ github.ref_name }}
      nextIssue: "[${{ needs.select-issue.outputs.issueNumber }}] ${{ needs.select-issue.outputs.issueTitle }} ${{ needs.select-issue.outputs.issueLabels }}"
      public: 'public'
      s3BucketUrl: 's3://agentic-lib-telemetry-bucket/events/'
      s3WebsiteBucketUrl: 's3://agentic-lib-public-website-stats-bucket/'
      iamActionsRoleArn: 'arn:aws:iam::541134664601:role/agentic-lib-github-actions-role'
      iamStatsBucketWriterRoleArn: 'arn:aws:iam::541134664601:role/agentic-lib-deployment-role'
      iamPublicWebsiteStatsBucketWriterRoleArn: 'arn:aws:iam::541134664601:role/agentic-lib-public-website-stats-bucket-writer-role'
    secrets:
      PERSONAL_ACCESS_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}
.github/workflows/deploy.yml
==== Content of .github/workflows/deploy.yml ====
# .github/workflows/deploy.yml
#
# This file is part of the example suite for `agentic-lib` see: https://github.com/xn-intenton-z2a/agentic-lib
# This file is licensed under the MIT License. For details, see LICENSE-MIT

name: Deploy
run-name: 'Deploy to AWS [${{ github.ref_name }}] [${{ github.event.head_commit.message }}]'
concurrency: agentic-lib-deploy

on:
  #push:
  #  branches:
  #    # When publishing from a branch, add branch name here, e,g, 'beta'
  #    - main
  #  paths:
  #    - '**/*.sh'
  #    - '**/*.js'
  #    - '**/*.json'
  #    - '**/*.yml'
  #    - '**/*.properties'
  #    - '!intentions/**'
  #    - '!conversations/**'
  #    - '!exports/**'
  #    - '!programs/**'
  #    - '!results/**'
  workflow_dispatch:
  schedule:
    - cron: '22 */12 */7 * *' # schedule-1
    #- cron: '22 */12 * * *' # schedule-2
    #- cron: '22 */3 * * *' # schedule-3
    #- cron: '22 */3 * * *' # schedule-4

jobs:

  npm-test-and-run-main:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: 'npm'

      - name: Set up ~/.npmrc
        run: |
          echo "@xn-intenton-z2a:registry=https://npm.pkg.github.com" >> ~/.npmrc
          echo "//npm.pkg.github.com/:_authToken=${{ secrets.PERSONAL_ACCESS_TOKEN }}" >> ~/.npmrc
          echo "always-auth=true" >> ~/.npmrc

      - run: npm ci

      - name: test
        id: test
        shell: bash
        run: 'npm test'

      - name: main
        id: main
        shell: bash
        run: timeout 5m ${{ vars.MAIN_SCRIPT || 'npm run start' }}

  mvn-package-cdk-synth:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: 'npm'

      - name: Set up ~/.npmrc
        run: |
          echo "@xn-intenton-z2a:registry=https://npm.pkg.github.com" >> ~/.npmrc
          echo "//npm.pkg.github.com/:_authToken=${{ secrets.PERSONAL_ACCESS_TOKEN }}" >> ~/.npmrc
          echo "always-auth=true" >> ~/.npmrc

      - run: npm ci

      - name: mvn
        if: steps.mvn.outputs.pomXmlExists == 'true'
        id: mvn
        shell: bash
        run: |
          if [ -f pom.xml ]; then
            pomXmlExists='true'
          else
            pomXmlExists='false'
          fi
          echo "pomXmlExists=${pomXmlExists?}" | tee -a "${GITHUB_OUTPUT?}"

      - uses: actions/setup-java@v4
        if: steps.mvn.outputs.pomXmlExists == 'true'
        with:
          distribution: 'corretto'
          java-version: 21
          cache: 'maven'
          server-password: PERSONAL_ACCESS_TOKEN
        env:
          GITHUB_ACTOR: ${{ github.actor }}
          PERSONAL_ACCESS_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}

      - name: package
        id: package
        if: steps.mvn.outputs.pomXmlExists == 'true'
        shell: bash
        run: ./mvnw clean package
        env:
          GITHUB_ACTOR: ${{ github.actor }}
          PERSONAL_ACCESS_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}

      - name: synth
        id: synth
        if: steps.mvn.outputs.pomXmlExists == 'true'
        shell: bash
        run: npx cdk synth --strict --validation --no-staging
        env:
          GITHUB_ACTOR: ${{ github.actor }}
          PERSONAL_ACCESS_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}

  deploy:
    needs:
      - npm-test-and-run-main
      - mvn-package-cdk-synth
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.ref }}

      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: 'npm'

      - name: Set up ~/.npmrc
        run: |
          echo "@xn-intenton-z2a:registry=https://npm.pkg.github.com" >> ~/.npmrc
          echo "//npm.pkg.github.com/:_authToken=${{ secrets.PERSONAL_ACCESS_TOKEN }}" >> ~/.npmrc
          echo "always-auth=true" >> ~/.npmrc

      - run: npm ci

      - name: test
        id: test
        shell: bash
        run: npm test

      - name: mvn
        id: mvn
        shell: bash
        run: |
          if [ -f pom.xml ]; then
            pomXmlExists='true'
          else
            pomXmlExists='false'
          fi
          echo "pomXmlExists=${pomXmlExists?}" | tee -a "${GITHUB_OUTPUT?}"

      #- run: npm install -g aws-cdk

      - name: Configure AWS Credentials
        if: steps.mvn.outputs.pomXmlExists == 'true'
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::541134664601:role/agentic-lib-github-actions-role
          role-chaining: false
          aws-region: eu-west-2
          audience: sts.amazonaws.com
          role-skip-session-tagging: true
          output-credentials: true
          retry-max-attempts: 3

      - run: aws sts get-caller-identity --region eu-west-2
        if: steps.mvn.outputs.pomXmlExists == 'true'

      - name: Configure AWS Credentials
        if: steps.mvn.outputs.pomXmlExists == 'true'
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::541134664601:role/agentic-lib-deployment-role
          role-chaining: true
          aws-region: eu-west-2
          audience: sts.amazonaws.com
          role-skip-session-tagging: true
          output-credentials: true
          retry-max-attempts: 3

      - run: aws s3 ls --region eu-west-2
        if: steps.mvn.outputs.pomXmlExists == 'true'

      - uses: actions/setup-java@v4
        if: steps.mvn.outputs.pomXmlExists == 'true'
        with:
          distribution: 'corretto'
          java-version: 21
          cache: 'maven'
          server-password: PERSONAL_ACCESS_TOKEN
        env:
          GITHUB_ACTOR: ${{ github.actor }}
          PERSONAL_ACCESS_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}

      - name: package
        id: package
        if: steps.mvn.outputs.pomXmlExists == 'true'
        shell: bash
        run: ./mvnw clean package
        env:
          GITHUB_ACTOR: ${{ github.actor }}
          PERSONAL_ACCESS_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}

      - name: stacks
        id: stacks
        if: steps.mvn.outputs.pomXmlExists == 'true'
        shell: bash
        run: |
          synth=$(jq -r '.deployStacks' cdk.json)
          deploy=$(jq -r '.deployStacks' cdk.json)
          echo "deploy=${deploy?}" | tee -a "${GITHUB_OUTPUT?}"
          echo "synth=${synth?}" | tee -a "${GITHUB_OUTPUT?}"

      - name: synth
        id: synth
        if: steps.mvn.outputs.pomXmlExists == 'true'
        shell: bash
        run: ${{ steps.stacks.outputs.synth }}
        env:
          GITHUB_ACTOR: ${{ github.actor }}
          PERSONAL_ACCESS_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}

      - name: deploy
        id: deploy
        if: steps.mvn.outputs.pomXmlExists == 'true'
        shell: bash
        run: ${{ steps.stacks.outputs.deploy }}
        env:
          GITHUB_ACTOR: ${{ github.actor }}
          PERSONAL_ACCESS_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}

  select-issue:
    permissions:
      issues: read
      id-token: write
    uses: 'xn-intenton-z2a/agentic-lib/.github/workflows/wfr-github-select-issue.yml@main'
    with:
      issueNumber: ''
      selectionLabel: 'automated'
    secrets:
      CHATGPT_API_SECRET_KEY: ${{ secrets.CHATGPT_API_SECRET_KEY }}

  stats:
    needs:
      - select-issue
      - deploy
    if: ${{ always() }}
    permissions:
      contents: write
      id-token: write
      pages: write
    uses: 'xn-intenton-z2a/agentic-lib/.github/workflows/wfr-github-stats.yml@main'
    with:
      cache: 'npm'
      npmAuthOrganisation: '@xn-intenton-z2a'
      lastActivityName: ${{ github.workflow }}
      lastActivityBranchName: ${{ github.ref_name }}
      nextIssue: "[${{ needs.select-issue.outputs.issueNumber }}] ${{ needs.select-issue.outputs.issueTitle }} ${{ needs.select-issue.outputs.issueLabels }}"
      public: 'public'
      s3BucketUrl: 's3://agentic-lib-telemetry-bucket/events/'
      s3WebsiteBucketUrl: 's3://agentic-lib-public-website-stats-bucket/'
      iamActionsRoleArn: 'arn:aws:iam::541134664601:role/agentic-lib-github-actions-role'
      iamStatsBucketWriterRoleArn: 'arn:aws:iam::541134664601:role/agentic-lib-deployment-role'
      iamPublicWebsiteStatsBucketWriterRoleArn: 'arn:aws:iam::541134664601:role/agentic-lib-public-website-stats-bucket-writer-role'
    secrets:
      PERSONAL_ACCESS_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}
.github/workflows/wfr-github-create-pr.yml
==== Content of .github/workflows/wfr-github-create-pr.yml ====
# .github/workflows/wfr-github-create-pr.yml

#
# agentic-lib
# Copyright (C) 2025 Polycode Limited
#
# This file is part of agentic-lib.
#
# agentic-lib is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License v3.0 (GPL‑3).
# along with this program. If not, see <https://www.gnu.org/licenses/>.
#
# IMPORTANT: Any derived work must include the following attribution:
# "This work is derived from https://github.com/xn-intenton-z2a/agentic-lib"
#

name: ∞ create-pr

on:
  workflow_call:
    inputs:
      branch:
        description: 'The branch to create a PR from. e.g. "agentic-lib-issue-123"'
        type: string
        required: true
      baseBranch:
        description: 'The base branch to compare the PRs against. e.g. "main"'
        type: string
        required: false
        default: 'main'
      pulls:
        description: 'The maximum number of PRs to process. e.g. "100"'
        type: string
        required: false
        default: '100'
      gitCommitMessage:
        description: 'The commit message to use for the PR. e.g. "Ready for pull"'
        type: string
        required: false
        default: 'Ready for pull'
      cache:
        description: 'The cache to use for npm. e.g. "npm"'
        type: string
        required: false
        default: 'npm'
      label:
        description: 'The labels to apply to the PR. e.g. "automerge"'
        type: string
        required: false
        default: 'automerge'
      s3BucketUrl:
        description: 'The S3 bucket URL with prefix to use. e.g. "s3://my-bucket/prefix"'
        type: string
        required: false
        default: ''
      iamRoleArn:
        description: 'The ARN of the IAM role to assume. e.g. "arn:aws:iam::123456789012:role/my-role"'
        type: string
        required: false
        default: ''
    secrets:
      PERSONAL_ACCESS_TOKEN:
        required: false

jobs:
  create-pr:
    runs-on: ubuntu-latest

    env:
      branch: ${{ inputs.branch }}
      baseBranch: ${{ inputs.baseBranch || 'main' }}
      pulls: ${{ inputs.pulls || '100' }}
      gitCommitMessage: ${{ inputs.gitCommitMessage || 'Change complete ready for review' }}
      label: 'automerge'

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: ${{ env.cache }}

      - name: Create pull request, if fixed after re-checking linting
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PERSONAL_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}
          script: |
            const { data: existingPulls } = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              head: `${context.repo.owner}:${{ env.branch }}`,
              base: '${{ env.baseBranch }}',
              state: 'open',
            });
            if (existingPulls.length === 0) {
              const comparison = await github.rest.repos.compareCommits({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  base: '${{ env.baseBranch }}',
                  head: '${{ env.branch }}',
              });
              // Delete the branch if there is no addition to the base branch (and this branch isn't main)
              if('${{ env.branch }}' != 'main' && comparison.data.ahead_by === 0){
                core.info('No additions detected in ${{ env.branch }} compared to ${{ env.baseBranch }}. Deleting branch: ${{ env.branch }}');
                await github.rest.git.deleteRef({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  ref: 'heads/${{ env.branch }}',
                });
              } else {
                const { data: pr } = await github.rest.pulls.create({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  title: '${{ env.gitCommitMessage }}',
                  head: '${{ env.branch }}',
                  base: '${{ env.baseBranch }}',
                  body: '${{ env.gitCommitMessage }}',
                  maintainer_can_modify: true,
                });
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: pr.number,
                  labels: ['${{ env.label }}'],
                });
                core.info(`Pull request created: ${pr.html_url}`);
              
                // Initiate Check Suites
                const { data: checkSuites } = await github.rest.checks.listForRef({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  ref: pr.head.sha,
                });
                if (checkSuites.check_suites && checkSuites.check_suites.length > 0) {
                  for (const suite of checkSuites.check_suites) {
                    await github.rest.checks.rerequestSuite({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      check_suite_id: suite.id,
                    });
                    core.info(`Re-ran check suite ${suite.id} for commit ${pr.head.sha}`);
                  }
                } else {
                  core.info('No check suites found for the new commit.');
                }
              }
            } else {
              core.info('Pull request already exists for this branch.');
            }

.github/workflows/wfr-completion-apply-issue-resolution.yml
==== Content of .github/workflows/wfr-completion-apply-issue-resolution.yml ====
# .github/workflows/wfr-completion-apply-issue-resolution.yml

#
# agentic-lib
# Copyright (C) 2025 Polycode Limited
#
# This file is part of agentic-lib.
#
# agentic-lib is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License v3.0 (GPL‑3).
# along with this program. If not, see <https://www.gnu.org/licenses/>.
#
# IMPORTANT: Any derived work must include the following attribution:
# "This work is derived from https://github.com/xn-intenton-z2a/agentic-lib"
#

name: ∞ wfr-apply-issue-resolution

on:
  workflow_call:
    inputs:
      issueNumber:
        description: 'The issue number to review. e.g. "123"'
        type: string
        required: true
      featuresDir:
        description: 'The directory to create/update the features in. e.g. "features/"'
        type: string
        required: false
        default: 'features/'
      target:
        description: 'The target file to review. e.g. "src/lib/main.js"'
        type: string
        required: false
        default: 'src/lib/main.js'
      testFile:
        description: 'The test file to review. e.g. "tests/unit/main.test.js"'
        type: string
        required: false
        default: 'tests/unit/main.test.js'
      readmeFile:
        description: 'The README file to review. e.g. "README.md"'
        type: string
        required: false
        default: 'README.md'
      missionFile:
        description: 'The MISSION statement file. e.g. "MISSION.md"'
        type: string
        required: false
        default: 'MISSION.md'
      contributingFile:
        description: 'The CONTRIBUTING file to review. e.g. "CONTRIBUTING.md"'
        type: string
        required: false
        default: 'CONTRIBUTING.md'
      dependenciesFile:
        description: 'The dependencies file to review. e.g. "package.json"'
        type: string
        required: false
        default: 'package.json'
      formattingFile:
        description: 'The formatting file to review. e.g. ".prettierrc"'
        type: string
        required: false
        default: '.prettierrc'
      lintingFile:
        description: 'The linting file to review. e.g. "eslint.config.js"'
        type: string
        required: false
        default: 'eslint.config.js'
      branchPrefix:
        description: 'The prefix for the issue branch. e.g. "agentic-lib-issue-".'
        type: string
        required: true
      buildScript:
        description: 'The script must be runnable as: `npm ci ; <script>` and succeed with a zero exit code. e.g. `npm run build`'
        type: string
        required: false
        default: 'echo "No build script specified."'
      testScript:
        description: 'The script must be runnable as: `npm ci ; <script>` and succeed with a zero exit code. e.g. `npm test`'
        type: string
        required: false
        default: 'npm test'
      mainScript:
        description: 'The script must be runnable as: `npm ci ; <script>` and succeed with a zero exit code. e.g. `npm run start`'
        type: string
        required: false
        default: 'npm run start'
      model:
        description: 'The OpenAI model to use. e.g. "o3-mini"'
        type: string
        required: false
        default: ${{ vars.CHATGPT_API_MODEL || 'o3-mini' }}
      npmAuthOrganisation:
        description: 'The GitHub organisation to authenticate with for npm. e.g. "@xn-intenton-z2a"'
        type: string
        required: false
        default: ''
      gitUserEmail:
        description: 'The email to use for git commits. e.g. "action@github.com"'
        type: string
        required: false
        default: 'action@github.com'
      gitUserName:
        description: 'The name to use for git commits. e.g. "GitHub Actions[bot]"'
        type: string
        required: false
        default: 'GitHub Actions[bot]'
      cache:
        description: 'The cache to use for npm. e.g. "npm"'
        type: string
        required: false
        default: 'npm'
      s3BucketUrl:
        description: 'The S3 bucket URL with prefix to use. e.g. "s3://my-bucket/prefix"'
        type: string
        required: false
        default: ''
      iamRoleArn:
        description: 'The ARN of the IAM role to assume. e.g. "arn:aws:iam::123456789012:role/my-role"'
        type: string
        required: false
        default: ''
    secrets:
      PERSONAL_ACCESS_TOKEN:
        required: false
      CHATGPT_API_SECRET_KEY:
        required: true
    outputs:
      fixApplied:
        value: ${{ jobs.apply-issue-resolution.outputs.fixApplied }}
      message:
        value: ${{ jobs.apply-issue-resolution.outputs.message }}
      installAfterUpdateOutcome:
        value: ${{ jobs.apply-issue-resolution.outputs.installAfterUpdateOutcome }}
      ciAfterUpdateOutcome:
        value: ${{ jobs.apply-issue-resolution.outputs.ciAfterUpdateOutcome }}
      testAfterUpdateOutcome:
        value: ${{ jobs.apply-issue-resolution.outputs.testAfterUpdateOutcome }}
      mainAfterUpdateOutcome:
        value: ${{ jobs.apply-issue-resolution.outputs.mainAfterUpdateOutcome }}
      commitOutcome:
        value: ${{ jobs.apply-issue-resolution.outputs.commitOutcome }}
      postResolutionCommentOutcome:
        value: ${{ jobs.apply-issue-resolution.outputs.postResolutionCommentOutcome }}
      allValidationStepsSuccessful:
        value: ${{ jobs.apply-issue-resolution.outputs.allValidationStepsSuccessful }}
      branch:
        value: ${{ inputs.branchPrefix || 'agentic-lib-issue-' }}${{ inputs.issueNumber }}

jobs:
  apply-issue-resolution:
    runs-on: ubuntu-latest

    env:
      issueNumber: ${{ inputs.issueNumber }}
      featuresDir: ${{ inputs.featuresDir || 'features/' }}
      target: ${{ inputs.target || 'src/lib/main.js' }}
      testFile: ${{ inputs.testFile || 'tests/unit/main.test.js' }}
      readmeFile: ${{ inputs.readmeFile || 'README.md' }}
      missionFile: ${{ inputs.missionFile || 'MISSION.md' }}
      contributingFile: ${{ inputs.contributingFile || 'CONTRIBUTING.md' }}
      dependenciesFile: ${{ inputs.dependenciesFile || 'package.json' }}
      formattingFile: ${{ inputs.formattingFile || '.prettierrc' }}
      lintingFile: ${{ inputs.lintingFile || 'eslint.config.js' }}
      branch: ${{ inputs.branchPrefix || 'agentic-lib-issue-' }}${{ inputs.issueNumber }}
      buildScript: ${{ inputs.buildScript || 'npm run build' }}
      testScript: ${{ inputs.testScript || 'npm test' }}
      mainScript: ${{ inputs.mainScript || 'npm run start' }}
      mainScriptTimeout: '5m'
      model: ${{ inputs.model || vars.CHATGPT_API_MODEL || 'o3-mini' }}
      chatgptApiSecretKey: ${{ secrets.CHATGPT_API_SECRET_KEY }}
      npmAuthOrganisation: ${{ inputs.npmAuthOrganisation || '' }}
      gitUserEmail: ${{ inputs.gitUserEmail || 'action@github.com' }}
      gitUserName: ${{ inputs.gitUserName || 'GitHub Actions[bot]' }}
      cache: ${{ inputs.cache || 'npm' }}
      s3BucketUrl: ${{ inputs.s3BucketUrl || '' }}
      iamRoleArn: ${{ inputs.iamRoleArn || '' }}

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.ref }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: ${{ env.cache }}

      - name: Check GitHub authentication
        if: ${{ env.npmAuthOrganisation != '' }}
        shell: bash
        run: |
          curl --include --header "Authorization: token ${{ secrets.PERSONAL_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}" https://api.github.com/user

      - name: Set up .npmrc
        if: ${{ env.npmAuthOrganisation != '' }}
        shell: bash
        run: |
          echo "${{ env.npmAuthOrganisation }}:registry=https://npm.pkg.github.com" >> .npmrc
          echo "//npm.pkg.github.com/:_authToken=${{ secrets.PERSONAL_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}" >> .npmrc
          echo "always-auth=true" >> .npmrc

      - name: Get latest from remote
        run: |
          git config --local user.email "${{ env.gitUserEmail }}"
          git config --local user.name "${{ env.gitUserName }}"
          git pull --ff-only origin ${{ github.ref }}

      - run: npm ci

      - name: List current features
        id: features
        shell: bash
        run: |
          output=$(find "${{ env.featuresDir }}" -maxdepth 1 -type f -name '*.md' -print -exec echo "# {}" \; -exec cat {} \; 2>&1 || echo 'none')
          echo "output<<EOF" >> "$GITHUB_OUTPUT"
          echo "$output" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          echo "output=${output}"

      - name: List dependencies
        id: list
        shell: bash
        run: |
          output=$(npm list 2>&1)
          echo "output<<EOF" >> "$GITHUB_OUTPUT"
          echo "$output" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          echo "output=${output}"

      - name: Build project
        id: build
        shell: bash
        run: |
          output=$(${{ env.buildScript }} 2>&1)
          echo "output<<EOF" >> "$GITHUB_OUTPUT"
          echo "$output" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          echo "output=${output}"

      - name: Run tests
        id: test
        shell: bash
        run: |
          output=$(${{ env.testScript }} 2>&1)
          echo "output<<EOF" >> "$GITHUB_OUTPUT"
          echo "$output" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          echo "output=${output}"

      - name: Run main
        id: main
        shell: bash
        run: |
          output=$(timeout ${{ env.mainScriptTimeout }} ${{ env.mainScript }} 2>&1)
          echo "output<<EOF" >> "$GITHUB_OUTPUT"
          echo "$output" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          echo "output=${output}"

      - name: update-target
        id: update-target
        uses: actions/github-script@v7
        env:
          dependenciesListOutput: ${{ steps.list.outputs.output }}
          buildOutput: ${{ steps.build.outputs.output }}
          testOutput: ${{ steps.test.outputs.output }}
          mainOutput: ${{ steps.main.outputs.output }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const currentFeatures = process.env.currentFeatures;
            const target = process.env.target;
            const testFile = process.env.testFile;
            const readmeFile = process.env.readmeFile;
            const missionFile = process.env.missionFile;
            const contributingFile = process.env.contributingFile;
            const dependenciesFile = process.env.dependenciesFile;
            const formattingFile = process.env.formattingFile;
            const lintingFile = process.env.lintingFile;
            const model = process.env.model;
            const apiKey = process.env.chatgptApiSecretKey;
            const issueNumber = parseInt(process.env.issueNumber);
            const dependenciesListOutput = process.env.dependenciesListOutput;
            const buildScript = process.env.buildScript;
            const buildOutput = process.env.buildOutput;
            const testScript = process.env.testScript;
            const testOutput = process.env.testOutput;
            const mainScript = process.env.mainScript;
            const mainOutput = process.env.mainOutput;
            
            const fs = require('fs');
            const OpenAI = require('openai').default;
            const { z } = require('zod');
            require('dotenv').config();
            
            if (!apiKey) { 
              core.setFailed("Missing CHATGPT_API_SECRET_KEY"); 
            }
            const openai = new OpenAI({ apiKey });
            
            core.info(`currentFeatures: "${currentFeatures}"`);
            core.info(`target: "${target}"`);
            core.info(`testFile: "${testFile}"`);
            core.info(`readmeFile: "${readmeFile}"`);
            core.info(`missionFile: "${missionFile}"`);
            core.info(`contributingFile: "${contributingFile}"`);
            core.info(`dependenciesFile: "${dependenciesFile}"`);
            core.info(`formattingFile: "${formattingFile}"`);
            core.info(`lintingFile: "${lintingFile}"`);
            const sourceFileContent = fs.readFileSync(target, 'utf8');
            const testFileContent = fs.readFileSync(testFile, 'utf8');
            const readmeFileContent = fs.readFileSync(readmeFile, 'utf8');
            const missionFileContent = fs.readFileSync(missionFile, 'utf8');
            const contributingFileContent = fs.readFileSync(contributingFile, 'utf8');
            const dependenciesFileContent = fs.readFileSync(dependenciesFile, 'utf8');
            const formattingFileContent = fs.readFileSync(formattingFile, 'utf8');
            const lintingFileContent = fs.readFileSync(lintingFile, 'utf8');
            core.info(`Target file '${target}' has been loaded (length ${sourceFileContent.length}).`);
            core.info(`Test file '${testFile}' has been loaded (length ${testFileContent.length}).`);
            core.info(`Readme file '${readmeFile}' has been loaded (length ${readmeFileContent.length}).`);
            core.info(`Dependencies file '${dependenciesFile}' has been loaded (length ${dependenciesFileContent.length}).`);
            core.info(`Formatting file '${formattingFile}' has been loaded (length ${formattingFileContent.length}).`);
            core.info(`Linting file '${lintingFile}' has been loaded (length ${lintingFileContent.length}).`);
            
            const issue = await github.rest.issues.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber
            });
            const issueTitle = issue.data.title;
            const issueDescription = issue.data.body;
            const issueComments = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber
            });
            const issueCommentsText = issueComments.data
              .map(comment => `Author:${comment.user.login}, Created:${comment.created_at}, Comment: ${comment.body}`)
              .join('\n');
            
            const prompt = `
            You are providing the entire new content of the source file, test file and README file with all necessary changes applied to resolve an issue.
            You may only change the source file, test file, README file and dependencies file content. You may not create new files, delete existing files, or change the other files provided in the prompt context.
            Consider the following when refining your response:
            * Current feature names and specifications in the repository
            * Source file content
            * Test file content
            * README file content
            * MISSION file content
            * Contributing file content
            * Dependencies file content
            * Formatting file content
            * Linting file content
            * Issue details
            * Dependency list
            * Build output
            * Test output
            * Main execution output
            
            Apply the contributing guidelines to your response and when suggesting enhancements consider the tone and direction of the contributing guidelines.
            
            Current feature names and specifications:
            CURRENT_FEATURES_START
            ${currentFeatures}
            CURRENT_FEATURES_END
            
            Source file: ${target}
            SOURCE_FILE_START
            ${sourceFileContent}
            SOURCE_FILE_END
            
            Test file: ${testFile}
            TEST_FILE_START
            ${testFileContent}
            TEST_FILE_END

            README file: ${readmeFile}
            README_FILE_START
            ${readmeFileContent}
            README_FILE_END
            
            MISSION file: ${missionFile}
            MISSION_FILE_START
            ${missionFileContent}
            MISSION_FILE_END

            Contributing file: ${contributingFile}
            CONTRIBUTING_FILE_START
            ${contributingFileContent}
            CONTRIBUTING_FILE_END
            
            Dependencies file: ${dependenciesFile}
            DEPENDENCIES_FILE_START
            ${dependenciesFileContent}
            DEPENDENCIES_FILE_END
            
            Formatting file: ${formattingFile}
            FORMATTING_FILE_START
            ${formattingFileContent}
            FORMATTING_FILE_END
            
            Linting file: ${lintingFile}
            LINTING_FILE_START
            ${lintingFileContent}
            LINTING_FILE_END
                 
            Issue details:
            ISSUE_START
            title: ${issueTitle}
            description:
            ${issueDescription}
            comments:
            ${issueCommentsText}
            ISSUE_END            

            Dependencies list from command: npm list
            DEPENDENCIES_LIST_START
            ${dependenciesListOutput}
            DEPENDENCIES_LIST_END    

            Build output from command: ${buildScript}
            BUILD_OUTPUT_START
            ${buildOutput}
            BUILD_OUTPUT_END      
            
            Test output from command: ${testScript}
            TEST_OUTPUT_START
            ${testOutput}
            TEST_OUTPUT_END            

            Main execution output from command: ${mainScript}
            MAIN_OUTPUT_START
            ${mainOutput}
            MAIN_OUTPUT_END    
            
            Please produce an updated version of the source file, and test file, and README and dependencies file that resolves the issue.
            Answer strictly with a JSON object following this schema:
            
            {
              "updatedSourceFileContent": "The entire new content of the source file, with all necessary changes applied.",
              "updatedTestFileContent": "The entire new content of the test file, with all necessary changes applied.",
              "updatedReadmeFileContent": "The entire new content of the README file, with all necessary changes applied.",
              "updatedDependenciesFileContent": "The entire new content of the dependencies file, with all necessary changes applied.",
              "message": "A short sentence explaining the change applied suitable for a commit message."
            }
            
            Ensure valid JSON.
            `;
            
            const ResponseSchema = z.object({ updatedSourceFileContent: z.string(), updatedTestFileContent: z.string(), updatedReadmeFileContent: z.string(), updatedDependenciesFileContent: z.string(), message: z.string() });
            
            // Define the function schema for functional calling
            const applyIssueResolutionToSource = [{
              type: "function",
              function: {
                name: "applyIssueResolutionToSource",
                description: "Return an updated version of the source file content along with a commit message. Use the provided source file content and supporting context to generate the update.",
                parameters: {
                  type: "object",
                  properties: {
                    updatedSourceFileContent: {
                      type: "string",
                      description: "The entire new content of the source file, with all necessary changes applied."
                    },
                    updatedTestFileContent: {
                      type: "string",
                      description: "The entire new content of the test file, with all necessary changes applied."
                    },
                    updatedReadmeFileContent: {
                      type: "string",
                      description: "The entire new content of the README file, with all necessary changes applied."
                    },
                    updatedDependenciesFileContent: {
                      type: "string",
                      description: "The entire new content of the dependencies file, with all necessary changes applied."
                    },
                    message: {
                      type: "string",
                      description: "A short sentence explaining the change applied suitable for a commit message."
                    }
                  },
                  required: ["updatedSourceFileContent", "updatedTestFileContent", "updatedReadmeFileContent", "updatedDependenciesFileContent", "message"],
                  additionalProperties: false
                },
                strict: true
              }
            }];
            
            // Call OpenAI using the function calling format via the tools parameter
            const response = await openai.chat.completions.create({
              model,
              messages: [
                { role: "system", content: "You are a code fixer that returns an updated source file content, test file content, README file content and dependencies file content to resolve an issue. Answer strictly with a JSON object that adheres to the provided function schema." },
                { role: "user", content: prompt }
              ],
              tools: applyIssueResolutionToSource
            });
            
            let fixApplied;
            let result;
            // Check if the model made a function call; if so, parse its arguments.
            if (response.choices[0].message.tool_calls && response.choices[0].message.tool_calls.length > 0) {
              try {
                result = JSON.parse(response.choices[0].message.tool_calls[0].function.arguments);
              } catch (e) {
                fixApplied = false;
                core.setFailed(`Failed to parse function call arguments: ${e.message}`);
              }
            } else if (response.choices[0].message.content) {
              try {
                result = JSON.parse(response.choices[0].message.content);
              } catch (e) {
                fixApplied = false;
                core.setFailed(`Failed to parse response content: ${e.message}`);
              }
            } else {
              fixApplied = false;
              core.setFailed("No valid response received from OpenAI.");
            }
            
            try {
              const parsed = ResponseSchema.parse(result);
              // Sanitize commit message: retain only alphanumerics, spaces, and basic URL-safe punctuation (-, _, ., ~)
              const sanitizedMessage = parsed.message.replace(/[^A-Za-z0-9 \-\_\.\~]/g, '').replace(/\s+/g, ' ').trim();
              core.setOutput("message", sanitizedMessage);
              core.info(`message: "${sanitizedMessage}"`);
            
              if(parsed.updatedSourceFileContent && parsed.updatedSourceFileContent.length > 1 && parsed.updatedSourceFileContent !== sourceFileContent) {
                fs.writeFileSync(target, parsed.updatedSourceFileContent, 'utf8');
                fixApplied = true;
                core.info(`Target file '${target}' has been updated (length ${parsed.updatedSourceFileContent.length}).`);
              }
              if(parsed.updatedTestFileContent && parsed.updatedTestFileContent.length > 1 && parsed.updatedTestFileContent !== testFileContent) {
                fs.writeFileSync(testFile, parsed.updatedTestFileContent, 'utf8');
                fixApplied = true;
                core.info(`Test file '${testFile}' has been updated (length ${parsed.updatedTestFileContent.length}).`);
              }
              if(parsed.updatedReadmeFileContent && parsed.updatedReadmeFileContent.length > 1 && parsed.updatedReadmeFileContent !== readmeFileContent) {
                fs.writeFileSync(readmeFile, parsed.updatedReadmeFileContent, 'utf8');
                fixApplied = true;
                core.info(`Readme file '${readmeFile}' has been updated (length ${parsed.updatedReadmeFileContent.length}).`);
              }
              if(parsed.updatedDependenciesFileContent && parsed.updatedDependenciesFileContent.length > 1 && parsed.updatedDependenciesFileContent !== dependenciesFileContent) {
                fs.writeFileSync(dependenciesFile, parsed.updatedDependenciesFileContent, 'utf8');
                fixApplied = true;
                core.info(`Dependencies file '${dependenciesFile}' has been updated (length ${parsed.updatedDependenciesFileContent.length}).`);
              }

              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber,
                body: parsed.message
              });
            } catch (e) {
              fixApplied = false;
              core.setFailed(`Failed to validate or process the response: ${e.message}`);
            }
            
            core.setOutput("fixApplied", fixApplied);
            core.setOutput("usage", JSON.stringify(response.usage));
            core.info(`fixApplied: "${fixApplied}"`);
            core.info(`usage: "${JSON.stringify(response.usage)}"`);
            core.info(`response: "${JSON.stringify(response)}"`);

      - run: cat ${{ env.target }}

      - name: Examine the git working copy
        shell: bash
        run: |
          git config --local user.email '${{ env.gitUserEmail }}'
          git config --local user.name '${{ env.gitUserName }}'
          git status -v
          git diff ${{ env.target }}

      - run: rm -rf node_modules

      - name: install-after-update
        id: install-after-update
        run: npm install

      - name: ci-after-update
        id: ci-after-update
        continue-on-error: true
        run: npm ci

      - name: Tear down .npmrc
        continue-on-error: true
        if: ${{ env.npmAuthOrganisation != '' }}
        shell: bash
        run: rm -f .npmrc

      - name: test-after-update
        id: test-after-update
        continue-on-error: true
        shell: bash
        run: |
          ${{ env.testScript }}

      - name: Run main after update
        id: main-after-update
        continue-on-error: true
        shell: bash
        run: |
          timeout ${{ env.mainScriptTimeout }} ${{ env.mainScript }}

      - name: Commit to new branch
        id: commit
        continue-on-error: true
        run: |
          git config --local user.email '${{ env.gitUserEmail }}'
          git config --local user.name '${{ env.gitUserName }}'
          git status -v
          git switch -c '${{ env.branch }}'
          git add -v --all
          git diff '${{ env.target }}'
          git commit -m '${{ steps.update-target.outputs.message }} (fixes #${{ env.issueNumber }})'
          git push --set-upstream origin '${{ env.branch }}' -v
          git status -v

      - name: Post Resolution Comment
        id: post-resolution-comment
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const issueNumber = parseInt("${{ env.issueNumber }}");
            const branchName = `${{ env.branch }}`;
            const branchUrl = `https://github.com/${{ github.repository }}/tree/${branchName}`;
            const body = `${branchUrl}`;
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber,
              body: body
            });
            await github.rest.issues.addAssignees({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber,
              assignees: [ context.actor ]
            });

      - name: Extract Results
        if: always()
        id: results
        uses: actions/github-script@v7
        with:
          script: |
            const fixApplied = '${{ steps.update-target.outputs.fixApplied }}';
            const message = '${{ steps.update-target.outputs.message }}';
            const installAfterUpdateOutcome = '${{ steps.install-after-update.outcome }}';
            const ciAfterUpdateOutcome = '${{ steps.ci-after-update.outcome }}';
            const testAfterUpdateOutcome = '${{ steps.test-after-update.outcome }}';
            const mainAfterUpdateOutcome = '${{ steps.main-after-update.outcome }}';
            const commitOutcome = '${{ steps.commit.outcome }}';
            const postResolutionCommentOutcome = '${{ steps.post-resolution-comment.outcome }}';
            const allValidationStepsSuccessful = installAfterUpdateOutcome === "success" && ciAfterUpdateOutcome === "success" && testAfterUpdateOutcome === "success" && mainAfterUpdateOutcome === "success" && commitOutcome === "success" && postResolutionCommentOutcome === "success";
            core.setOutput('fixApplied', fixApplied);
            core.setOutput('message', message);
            core.setOutput('installAfterUpdateOutcome', installAfterUpdateOutcome);
            core.setOutput('ciAfterUpdateOutcome', ciAfterUpdateOutcome);
            core.setOutput('testAfterUpdateOutcome', testAfterUpdateOutcome);
            core.setOutput('mainAfterUpdateOutcome', mainAfterUpdateOutcome);
            core.setOutput('commitOutcome', commitOutcome);
            core.setOutput('postResolutionCommentOutcome', postResolutionCommentOutcome);
            core.setOutput('allValidationStepsSuccessful', allValidationStepsSuccessful);
            core.info(`fixApplied: "${fixApplied}"`);
            core.info(`message: "${message}"`);
            core.info(`installAfterUpdateOutcome: "${installAfterUpdateOutcome}"`);
            core.info(`ciAfterUpdateOutcome: "${ciAfterUpdateOutcome}"`);
            core.info(`testAfterUpdateOutcome: "${testAfterUpdateOutcome}"`);
            core.info(`mainAfterUpdateOutcome: "${mainAfterUpdateOutcome}"`);
            core.info(`commitOutcome: "${commitOutcome}"`);
            core.info(`postResolutionCommentOutcome: "${postResolutionCommentOutcome}"`);
            core.info(`allValidationStepsSuccessful: "${allValidationStepsSuccessful}"`);

    outputs:
      fixApplied: ${{ steps.results.outputs.fixApplied }}
      message: ${{ steps.results.outputs.message }}
      installAfterUpdateOutcome: ${{ steps.results.outputs.installAfterUpdateOutcome }}
      ciAfterUpdateOutcome: ${{ steps.results.outputs.ciAfterUpdateOutcome }}
      testAfterUpdateOutcome: ${{ steps.results.outputs.testAfterUpdateOutcome }}
      mainAfterUpdateOutcome: ${{ steps.results.outputs.mainAfterUpdateOutcome }}
      commitOutcome: ${{ steps.results.outputs.commitOutcome }}
      postResolutionCommentOutcome: ${{ steps.results.outputs.postResolutionCommentOutcome }}
      allValidationStepsSuccessful: ${{ steps.results.outputs.allValidationStepsSuccessful }}

.github/workflows/issue-worker.yml
==== Content of .github/workflows/issue-worker.yml ====
# .github/workflows/issue-worker.yml
#
# This file is part of the example suite for `agentic-lib` see: https://github.com/xn-intenton-z2a/agentic-lib
# This file is licensed under the MIT License. For details, see LICENSE-MIT

name: Issue Worker
concurrency: agentic-lib-commit-main
run-name: "Issue Worker [${{ github.ref_name }}]"

on:
  workflow_dispatch:
    inputs:
      issueNumber:
        description: 'The issue number to resolve. If not provided, the workflow will select one based on label. e.g. "123"'
        required: false
        type: string
        default: ''
      target:
        description: 'The source file whose content is used in the resolution prompt. e.g. "src/lib/main.js"'
        required: false
        type: string
        default: 'src/lib/main.js'
      testFile:
        description: 'The test file to run to validate the resolution. e.g. "tests/unit/main.test.js"'
        required: false
        type: string
        default: 'tests/unit/main.test.js'
      selectionLabel:
        description: 'Label used to filter issues for resolution. e.g. "automated"'
        required: false
        type: string
        default: 'automated'
  workflow_run:
    workflows:
      - "Create Feature Development Issue"
      - "Create Maintenance Issue"
      - "Linting"
    types:
      - completed
  schedule:
    - cron: '50 */12 * * *' # schedule-1
    #- cron: '50 */4 * * *' # schedule-2
    #- cron: '50 */1 * * *' # schedule-3
    #- cron: '50 */1 * * *' # schedule-4

jobs:

  agentic-lib:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: agentic-lib
        id: agentic-lib
        shell: bash
        run: |
          attemptsPerIssue=$(grep '^attemptsPerIssue:' .github/agentic-lib.yml | awk '{print $2}')
          echo "attemptsPerIssue=${attemptsPerIssue}"
          echo "attemptsPerIssue=${attemptsPerIssue}" >> $GITHUB_OUTPUT
    outputs:
      attemptsPerIssue: ${{ steps.agentic-lib.outputs.attemptsPerIssue }}

  select-issue:
    permissions:
      issues: read
      id-token: write
    uses: 'xn-intenton-z2a/agentic-lib/.github/workflows/wfr-github-select-issue.yml@main'
    with:
      issueNumber: ${{ inputs.issueNumber || '' }}
      selectionLabel: ${{ inputs.selectionLabel || 'automated' }}
    secrets:
      CHATGPT_API_SECRET_KEY: ${{ secrets.CHATGPT_API_SECRET_KEY }}

  needs-resolution:
    needs:
      - select-issue
    runs-on: ubuntu-latest
    steps:
      - name: todo
        shell: bash
        run: |
          echo "TODO: Check if this issue has been resolved already by examining the current state and recent commits"

  check-attempts-limit:
    needs:
      - agentic-lib
      - select-issue
    runs-on: ubuntu-latest
    permissions:
      issues: write
      contents: write
      id-token: write
    env:
      issueNumber: ${{ needs.select-issue.outputs.issueNumber }}
      attemptsPerIssue: ${{ needs.agentic-lib.outputs.attemptsPerIssue }}
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ github.ref }}
          fetch-depth: 0
      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: 'npm'
      - name: Set up .npmrc
        shell: bash
        run: |
          echo "${{ env.npmAuthOrganisation }}:registry=https://npm.pkg.github.com" >> .npmrc
          echo "//npm.pkg.github.com/:_authToken=${{ secrets.PERSONAL_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}" >> .npmrc
          echo "always-auth=true" >> .npmrc
        env:
          npmAuthOrganisation: '@xn-intenton-z2a'
      - run: npm ci
      - name: check
        id: check
        uses: actions/github-script@v7
        with:
          script: |
            const issueNumber = "${{ env.issueNumber }}";
            const attemptsPerIssue = parseInt("${{ env.attemptsPerIssue }}");
            
            // If attempts to [work++fix] a branch exceed the limit as per agentic-lib.yml, then comment the issue and close it      
            const { data: issue } = await github.rest.issues.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber
            });
            const issueLabelsStartingWithApplyFix = issue.labels.filter(label => label.name.startsWith("apply-fix-"));
            const issueLabelsStartingWithIssueWorker = issue.labels.filter(label => label.name.startsWith("issue-worker-"));
            const attemptsOnIssue = issueLabelsStartingWithApplyFix.length + issueLabelsStartingWithIssueWorker.length
            if(attemptsOnIssue >= attemptsPerIssue) {
               const message = `Reached the limit of ${attemptsPerIssue} attempts with ${attemptsOnIssue} attempts.`;
  
              // Comment the issue
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber,
                body: message
              });
            
              // Close the issue
              await github.rest.issues.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber,
                state: "closed"
              });
            
              core.setFailure(`${message}`);
            }

            core.setOutput("attemptsOnIssue", attemptsOnIssue);
            core.info(`attemptsOnIssue: ${attemptsOnIssue}`);
    outputs:
      attemptsOnIssue: ${{ steps.check.outputs.attemptsOnIssue }}

  npm-test:
    name: 'npm test with coverage'
    needs:
      - select-issue
      - needs-resolution
      - check-attempts-limit
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ github.ref }}
          fetch-depth: 0
      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: 'npm'
      - name: Set up .npmrc
        shell: bash
        run: |
          echo "${{ env.npmAuthOrganisation }}:registry=https://npm.pkg.github.com" >> .npmrc
          echo "//npm.pkg.github.com/:_authToken=${{ secrets.PERSONAL_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}" >> .npmrc
          echo "always-auth=true" >> .npmrc
        env:
          npmAuthOrganisation: '@xn-intenton-z2a'
      - run: npm ci
      - run: npm run test:unit

  npm-build:
    name: 'npm run build'
    needs:
      - select-issue
      - needs-resolution
      - check-attempts-limit
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ github.ref }}
          fetch-depth: 0
      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: 'npm'
      - name: Set up .npmrc
        shell: bash
        run: |
          echo "${{ env.npmAuthOrganisation }}:registry=https://npm.pkg.github.com" >> .npmrc
          echo "//npm.pkg.github.com/:_authToken=${{ secrets.PERSONAL_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}" >> .npmrc
          echo "always-auth=true" >> .npmrc
        env:
          npmAuthOrganisation: '@xn-intenton-z2a'
      - run: npm ci
      - run: npm run build

  npm-run:
    name: 'npm run start'
    needs:
      - select-issue
      - needs-resolution
      - check-attempts-limit
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ github.ref }}
          fetch-depth: 0
      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: 'npm'
      - name: Set up .npmrc
        shell: bash
        run: |
          echo "${{ env.npmAuthOrganisation }}:registry=https://npm.pkg.github.com" >> .npmrc
          echo "//npm.pkg.github.com/:_authToken=${{ secrets.PERSONAL_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}" >> .npmrc
          echo "always-auth=true" >> .npmrc
        env:
          npmAuthOrganisation: '@xn-intenton-z2a'
      - run: npm ci
      - run: ${{ vars.MAIN_SCRIPT || 'npm run start' }}

  check-branch:
    needs:
      - select-issue
      - needs-resolution
      - check-attempts-limit
      - npm-test
      - npm-build
      - npm-run
    if: ${{ needs.select-issue.outputs.issueNumber != '' }}
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write
    env:
      branchPrefix: 'agentic-lib-'
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.ref }}
      - name: Ensure there isn't already a branch for this prefix
        shell: bash
        run: |
          git fetch origin
          if git branch -r | grep -q 'origin/${{ env.branchPrefix }}'; then
            echo "A branch with the prefix '${{ env.branchPrefix }}' already exists."
            exit 1
          else
            echo "No existing branch with the prefix found."
          fi

  label-issue-before-attempt:
    needs:
      - select-issue
      - check-attempts-limit
      - needs-resolution
      - npm-test
      - npm-build
      - npm-run
      - check-branch
    if: ${{ needs.select-issue.outputs.issueNumber != '' }}
    permissions:
      contents: write
      issues: write
      pull-requests: read
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ github.ref }}
          fetch-depth: 0

      - uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: ${{ env.cache }}

      - name: Set up .npmrc
        shell: bash
        run: |
          echo "${{ env.npmAuthOrganisation }}:registry=https://npm.pkg.github.com" >> .npmrc
          echo "//npm.pkg.github.com/:_authToken=${{ secrets.PERSONAL_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}" >> .npmrc
          echo "always-auth=true" >> .npmrc
        env:
          npmAuthOrganisation: '@xn-intenton-z2a'

      - name: Add "issueWorker-<run-id>" label
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: "${{ needs.select-issue.outputs.issueNumber }}",
              labels: [`issue-worker-${{ github.run_id }}`]
            });

  apply-issue-resolution:
    needs:
      - select-issue
      - needs-resolution
      - check-attempts-limit
      - npm-test
      - npm-build
      - npm-run
      - check-branch
    if: ${{ needs.select-issue.outputs.issueNumber != '' }}
    permissions:
      contents: write
      issues: write
      id-token: write
    uses: 'xn-intenton-z2a/agentic-lib/.github/workflows/wfr-completion-apply-issue-resolution.yml@main'
    with:
      issueNumber: ${{ needs.select-issue.outputs.issueNumber }}
      target: ${{ inputs.target || 'src/lib/main.js' }}
      testFile: ${{ inputs.testFile || 'tests/unit/main.test.js' }}
      readmeFile: 'README.md'
      missionFile: 'MISSION.md'
      contributingFile: 'CONTRIBUTING.md'
      dependenciesFile: 'package.json'
      formattingFile: '.prettierrc'
      lintingFile: 'eslint.config.js'
      branchPrefix: 'agentic-lib-issue-'
      buildScript: 'npm run build'
      testScript: 'npm test'
      mainScript: ${{ vars.MAIN_SCRIPT || 'npm run start' }}
      model: ${{ vars.CHATGPT_API_MODEL || 'o3-mini' }}
      npmAuthOrganisation: '@xn-intenton-z2a'
      gitUserEmail: 'action@github.com'
      gitUserName: 'GitHub Actions[bot]'
    secrets:
      CHATGPT_API_SECRET_KEY: ${{ secrets.CHATGPT_API_SECRET_KEY }}
      PERSONAL_ACCESS_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}

  npm-test-after-issue-resolution:
    needs:
      - needs-resolution
      - check-attempts-limit
      - npm-test
      - npm-build
      - npm-run
      - apply-issue-resolution
    name: 'npm test with coverage'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ needs.apply-issue-resolution.outputs.branch }}
          fetch-depth: 0
      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: "npm"
      - name: Get latest from remote
        run: |
          git config --local user.email "${{ env.gitUserEmail }}"
          git config --local user.name "${{ env.gitUserName }}"
          git pull --ff-only origin ${{ needs.apply-issue-resolution.outputs.branch }}
      - name: Set up .npmrc
        shell: bash
        run: |
          echo "${{ env.npmAuthOrganisation }}:registry=https://npm.pkg.github.com" >> .npmrc
          echo "//npm.pkg.github.com/:_authToken=${{ secrets.PERSONAL_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}" >> .npmrc
          echo "always-auth=true" >> .npmrc
        env:
          npmAuthOrganisation: '@xn-intenton-z2a'
      - run: npm ci
      - run: npm run test:unit

  npm-build-after-issue-resolution:
    needs:
      - needs-resolution
      - check-attempts-limit
      - npm-test
      - npm-build
      - npm-run
      - apply-issue-resolution
    name: 'npm run build'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ needs.apply-issue-resolution.outputs.branch }}
          fetch-depth: 0
      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: "npm"
      - name: Get latest from remote
        run: |
          git config --local user.email "${{ env.gitUserEmail }}"
          git config --local user.name "${{ env.gitUserName }}"
          git pull --ff-only origin ${{ needs.apply-issue-resolution.outputs.branch }}
      - name: Set up .npmrc
        shell: bash
        run: |
          echo "${{ env.npmAuthOrganisation }}:registry=https://npm.pkg.github.com" >> .npmrc
          echo "//npm.pkg.github.com/:_authToken=${{ secrets.PERSONAL_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}" >> .npmrc
          echo "always-auth=true" >> .npmrc
        env:
          npmAuthOrganisation: '@xn-intenton-z2a'
      - run: npm ci
      - run: npm run build

  npm-run-after-issue-resolution:
    needs:
      - needs-resolution
      - check-attempts-limit
      - npm-test
      - npm-build
      - npm-run
      - apply-issue-resolution
    name: 'npm run start'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ needs.apply-issue-resolution.outputs.branch }}
          fetch-depth: 0
      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: "npm"
      - name: Get latest from remote
        run: |
          git config --local user.email "${{ env.gitUserEmail }}"
          git config --local user.name "${{ env.gitUserName }}"
          git pull --ff-only origin ${{ needs.apply-issue-resolution.outputs.branch }}
      - name: Set up .npmrc
        shell: bash
        run: |
          echo "${{ env.npmAuthOrganisation }}:registry=https://npm.pkg.github.com" >> .npmrc
          echo "//npm.pkg.github.com/:_authToken=${{ secrets.PERSONAL_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}" >> .npmrc
          echo "always-auth=true" >> .npmrc
        env:
          npmAuthOrganisation: '@xn-intenton-z2a'
      - run: npm ci
      - run: ${{ vars.MAIN_SCRIPT || 'npm run start' }}

  needs-fix-after-issue-resolution:
    needs:
      - needs-resolution
      - check-attempts-limit
      - npm-test
      - npm-build
      - npm-run
      - apply-issue-resolution
      - npm-test-after-issue-resolution
      - npm-build-after-issue-resolution
      - npm-run-after-issue-resolution
    if: >
      ${{ always() &&
         (
           needs.npm-test-after-issue-resolution.result != 'success' ||
           needs.npm-build-after-issue-resolution.result != 'success' ||
           needs.npm-run-after-issue-resolution.result != 'success'
         )
      }}
    runs-on: ubuntu-latest
    steps:
      - name: set-needs-fix
        id: set-needs-fix
        uses: actions/github-script@v7
        with:
          script: |
            const anySkipped = "${{ needs.npm-test-after-issue-resolution.result == 'skipped' || needs.npm-build-after-issue-resolution.result == 'skipped' || needs.npm-run-after-issue-resolution.result == 'skipped' }}" === "true";
            const anyDidntSucceed = "${{ needs.npm-test-after-issue-resolution.result != 'success' || needs.npm-build-after-issue-resolution.result != 'success' || needs.npm-run-after-issue-resolution.result != 'success' }}" === "true";
            const readyToMerge = !anySkipped && !anyDidntSucceed;
            
            core.setOutput("anySkipped", anySkipped);
            core.setOutput("anyDidntSucceed", anyDidntSucceed);
            core.setOutput("readyToMerge", readyToMerge);     
            
            core.info(`Any skipped: ${anySkipped}`);
            core.info(`Any didn't succeed: ${anyDidntSucceed}`);
            core.info(`Ready to merge: ${readyToMerge}`);

    outputs:
      allSkipped: ${{ steps.set-needs-fix.outputs.allSkipped }}
      anyDidntSucceed: ${{ steps.set-needs-fix.outputs.anyDidntSucceed }}
      readyToMerge: ${{ steps.set-needs-fix.outputs.readyToMerge }}

  create-pr:
    needs:
      - select-issue
      - needs-resolution
      - check-attempts-limit
      - apply-issue-resolution
      - needs-fix-after-issue-resolution
    if: ${{ needs.select-issue.outputs.issueNumber != '' && needs.apply-issue-resolution.outputs.fixApplied == 'true' && needs.needs-fix-after-issue-resolution.outputs.readyToMerge == 'true' }}
    permissions:
      contents: write
      packages: write
      issues: write
      pull-requests: write
      checks: write
      id-token: write
    uses: 'xn-intenton-z2a/agentic-lib/.github/workflows/wfr-github-create-pr.yml@main'
    with:
      branch: '${{ needs.apply-issue-resolution.outputs.branch }}'
      baseBranch: 'main'
      gitCommitMessage: "${{ needs.apply-issue-resolution.outputs.message }} (fixes #${{ needs.select-issue.outputs.issueNumber }})"
      label: 'automerge'

  stats:
    needs:
      - select-issue
      - apply-issue-resolution
      - create-pr
    if: ${{ always() }}
    permissions:
      contents: write
      id-token: write
      pages: write
    uses: 'xn-intenton-z2a/agentic-lib/.github/workflows/wfr-github-stats.yml@main'
    with:
      cache: 'npm'
      npmAuthOrganisation: '@xn-intenton-z2a'
      lastActivityName: ${{ github.workflow }}
      lastActivityBranchName: ${{ github.ref_name }}
      nextIssue: "[${{ needs.select-issue.outputs.issueNumber }}] ${{ needs.select-issue.outputs.issueTitle }} ${{ needs.select-issue.outputs.issueLabels }}"
      public: 'public'
      s3BucketUrl: 's3://agentic-lib-telemetry-bucket/events/'
      s3WebsiteBucketUrl: 's3://agentic-lib-public-website-stats-bucket/'
      iamActionsRoleArn: 'arn:aws:iam::541134664601:role/agentic-lib-github-actions-role'
      iamStatsBucketWriterRoleArn: 'arn:aws:iam::541134664601:role/agentic-lib-deployment-role'
      iamPublicWebsiteStatsBucketWriterRoleArn: 'arn:aws:iam::541134664601:role/agentic-lib-public-website-stats-bucket-writer-role'
    secrets:
      PERSONAL_ACCESS_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}
.github/workflows/feature-worker.yml
==== Content of .github/workflows/feature-worker.yml ====
# .github/workflows/feature-worker.yml
#
# This file is part of the example suite for `agentic-lib` see: https://github.com/xn-intenton-z2a/agentic-lib
# This file is licensed under the MIT License. For details, see LICENSE-MIT

name: Feature Worker
concurrency: feature-worker
run-name: "Feature Worker"

on:
  workflow_dispatch:
    inputs:
      feature:
        description: 'Text to drive the feature creation (if "house choice", the repository will be assessed and an action chosen). e.g. "Support output to PDF."'
        required: false
        type: string
        default: 'house choice'
  schedule:
    - cron: '50 11 */7 * *' # schedule-1
    #- cron: '50 */4 * * *' # schedule-2
    #- cron: '50 */1 * * *' # schedule-3
    #- cron: '50 */1 * * *' # schedule-4

jobs:

  agentic-lib:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: agentic-lib
        id: agentic-lib
        shell: bash
        run: |
          featuresWipLimit=$(grep '^featuresWipLimit:' .github/agentic-lib.yml | awk '{print $2}')
          echo "featuresWipLimit=${featuresWipLimit}"
          echo "featuresWipLimit=${featuresWipLimit}" >> $GITHUB_OUTPUT
    outputs:
      featuresWipLimit: ${{ steps.agentic-lib.outputs.featuresWipLimit }}

  # If the feature is "house choice", the repository will be assessed an action chosen otherwise the supplied text will be used to generate a new feature.
  maintain-features:
    needs:
      - agentic-lib
    permissions:
      contents: write
      issues: write
      id-token: write
    uses: 'xn-intenton-z2a/agentic-lib/.github/workflows/wfr-completion-maintain-features.yml@main'
    with:
      feature: ${{ inputs.feature }}
      featuresDir: 'features/'
      featuresWipLimit: '${{ needs.agentic-lib.outputs.featuresWipLimit }}'
      target: ${{ inputs.target || 'src/lib/main.js' }}
      testFile: ${{ inputs.testFile || 'tests/unit/main.test.js' }}
      readmeFile: 'README.md'
      missionFile: 'MISSION.md'
      contributingFile: 'CONTRIBUTING.md'
      dependenciesFile: 'package.json'
      buildScript: 'npm run build'
      testScript: 'npm test'
      mainScript: ${{ vars.MAIN_SCRIPT || 'npm run start' }}
      model: ${{ vars.CHATGPT_API_MODEL || 'o3-mini' }}
      npmAuthOrganisation: '@xn-intenton-z2a'
      gitUserEmail: 'action@github.com'
      gitUserName: 'GitHub Actions[bot]'
    secrets:
      CHATGPT_API_SECRET_KEY: ${{ secrets.CHATGPT_API_SECRET_KEY }}
      PERSONAL_ACCESS_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}

  select-issue:
    permissions:
      issues: read
      id-token: write
    uses: 'xn-intenton-z2a/agentic-lib/.github/workflows/wfr-github-select-issue.yml@main'
    with:
      issueNumber: ''
      selectionLabel: 'automated'
    secrets:
      CHATGPT_API_SECRET_KEY: ${{ secrets.CHATGPT_API_SECRET_KEY }}

  stats:
    needs:
      - select-issue
      - maintain-features
    if: ${{ always() }}
    permissions:
      contents: write
      id-token: write
      pages: write
    uses: 'xn-intenton-z2a/agentic-lib/.github/workflows/wfr-github-stats.yml@main'
    with:
      cache: 'npm'
      npmAuthOrganisation: '@xn-intenton-z2a'
      lastActivityName: ${{ github.workflow }}
      lastActivityBranchName: ${{ github.ref_name }}
      nextIssue: "[${{ needs.select-issue.outputs.issueNumber }}] ${{ needs.select-issue.outputs.issueTitle }} ${{ needs.select-issue.outputs.issueLabels }}"
      public: 'public'
      s3BucketUrl: 's3://agentic-lib-telemetry-bucket/events/'
      s3WebsiteBucketUrl: 's3://agentic-lib-public-website-stats-bucket/'
      iamActionsRoleArn: 'arn:aws:iam::541134664601:role/agentic-lib-github-actions-role'
      iamStatsBucketWriterRoleArn: 'arn:aws:iam::541134664601:role/agentic-lib-deployment-role'
      iamPublicWebsiteStatsBucketWriterRoleArn: 'arn:aws:iam::541134664601:role/agentic-lib-public-website-stats-bucket-writer-role'
    secrets:
      PERSONAL_ACCESS_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}
.github/workflows/automerge.yml
==== Content of .github/workflows/automerge.yml ====
# .github/workflows/automerge.yml
#
# This file is part of the example suite for `agentic-lib` see: https://github.com/xn-intenton-z2a/agentic-lib
# This file is licensed under the MIT License. For details, see LICENSE-MIT

name: Automerge
concurrency: agentic-lib-commit-main
run-name: "Automerge [${{ github.ref_name }}]"

on:
  pull_request:
  check_suite:
  workflow_dispatch:
  #workflow_run:
  #  workflows:
  #    - "Issue Worker"
  #  types:
  #    - completed
  schedule:
    - cron: '10 */12 * * *' # schedule-1
    #- cron: '10 */4 * * *' # schedule-2
    #- cron: '10,25,40,55 */1 * * *' # schedule-3
    #- cron: '10,25,40,55 */1 * * *' # schedule-4

env:
  pullRequestLabel: 'automerge'

jobs:
  label:
    runs-on: ubuntu-latest
    steps:
      - name: echo
        shell: bash
        run: |
          echo "Label: ${{ env.pullRequestLabel }}"
    outputs:
      pullRequestLabel: ${{ env.pullRequestLabel }}

  echo-event:
    runs-on: ubuntu-latest
    steps:
      - run: |
          echo 'Triggered by: ${{ github.event_name }}'

  pull-request-event:
    if: github.event_name == 'pull_request'
    runs-on: ubuntu-latest
    steps:
      - run: |
          echo "Triggered by: pull_request"

  check-suite-event:
    if: github.event_name == 'check_suite'
    runs-on: ubuntu-latest
    steps:
      - run: |
          echo "Triggered by: check_suite"

  schedule-event:
    if: github.event_name == 'schedule'
    runs-on: ubuntu-latest
    steps:
      - run: |
          echo "Triggered by: schedule"

  workflow-dispatch-event:
    if: github.event_name == 'workflow_dispatch'
    runs-on: ubuntu-latest
    steps:
      - run: |
          echo "Triggered by: workflow_dispatch"

  workflow-run-event:
    if: github.event_name == 'workflow_run'
    runs-on: ubuntu-latest
    steps:
      - run: |
          echo "Triggered by: workflow_run"

  pr:
    needs: label
    if: github.event_name == 'pull_request' && contains(github.event.pull_request.labels.*.name, needs.label.outputs.pullRequestLabel )
    uses: 'xn-intenton-z2a/agentic-lib/.github/workflows/wfr-github-find-pr-from-pull-request.yml@main'

  cs:
    if: github.event_name == 'check_suite' && github.event.check_suite.conclusion == 'success'
    uses: 'xn-intenton-z2a/agentic-lib/.github/workflows/wfr-github-find-pr-in-check-suite.yml@main'

  ls:
    needs: label
    if: github.event_name == 'schedule' || github.event_name == 'workflow_dispatch' || github.event_name == 'workflow_run'
    runs-on: ubuntu-latest
    steps:
      - name: Determine pull request number
        id: get-pull
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            let pullRequest;
            let pullNumber;
            const { data: pullRequests } = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              per_page: 1,
              sort: 'created',
              direction: 'asc'
            });
            if (pullRequests.length > 0) {
              const filteredPRs = pullRequests.filter(pr => pr.labels.some(label => label.name === '${{ needs.label.outputs.pullRequestLabel }}' ));
              if (filteredPRs.length > 0) {
                pullRequest = filteredPRs[0];
                core.info(`Found open pull request with label ${{ needs.label.outputs.pullRequestLabel }}: #${pullRequest.number}.`);
                core.info(JSON.stringify(pullRequest));
              } else {
                core.info(`No open pull request found with label ${{ needs.label.outputs.pullRequestLabel }}.`);
                pullRequest = null;
              }
            } else {
              pullRequest = null;
              core.info('No open pull requests found.');
            }
            if (pullRequests.length > 0) {
              pullNumber = pullRequests[0].number;
            } else {
              pullNumber = '';
              core.info('No open pull requests found.');
            }
            core.info(`pullNumber: ${pullNumber}`);
            core.setOutput('pullNumber', pullNumber);
          result-encoding: string
    outputs:
      pullNumber: ${{ steps.get-pull.outputs.pullNumber }}

  merge-check:
    if: ${{ always() }}
    needs:
      - pr
      - cs
      - ls
    runs-on: ubuntu-latest
    steps:
      - name: set-outputs
        id: set-outputs
        uses: actions/github-script@v7
        with:
          script: |
            // Merge outputs from pr-check, cs-check, and determine-ls.
            // Only one of pr-check or cs-check should have run.
            let prMerged = '${{ needs.pr.outputs.prMerged || needs.cs.outputs.prMerged || 'false' }}';
            let pullNumber = '${{ needs.pr.outputs.pullNumber || needs.cs.outputs.pullNumber || needs.ls.outputs.pullNumber }}';
            let shouldSkipMerge = '${{ needs.pr.outputs.shouldSkipMerge || needs.cs.outputs.shouldSkipMerge || 'false' }}';
            core.setOutput('prMerged', `${prMerged}`);
            core.setOutput('pullNumber', `${pullNumber}`);
            core.setOutput('shouldSkipMerge', `${shouldSkipMerge}`);
            core.info(`prMerged: '${prMerged}'`);
            core.info(`pullNumber: '${pullNumber}'`);
            core.info(`shouldSkipMerge: '${shouldSkipMerge}'`);
          result-encoding: string
    outputs:
      prMerged: ${{ steps.set-outputs.outputs.prMerged }}
      pullNumber: ${{ steps.set-outputs.outputs.pullNumber }}
      shouldSkipMerge: ${{ steps.set-outputs.outputs.shouldSkipMerge }}

  label-issue-after-check-pr:
    needs:
      - merge-check
    if: needs.merge-check.outputs.prMerged == 'true' && needs.merge-check.outputs.pullNumber != ''
    permissions:
      contents: write
      pull-requests: read
      issues: write
    uses: 'xn-intenton-z2a/agentic-lib/.github/workflows/wfr-github-label-issue.yml@main'
    with:
      pullNumber: '${{ needs.merge-check.outputs.pullNumber }}'
      branchPrefix: 'agentic-lib-issue-'

  automerge:
    needs:
      - merge-check
    if: always() && needs.merge-check.outputs.shouldSkipMerge != 'true' && needs.merge-check.outputs.pullNumber != ''
    permissions:
      contents: write
      pull-requests: write
      checks: write
    uses: 'xn-intenton-z2a/agentic-lib/.github/workflows/wfr-github-merge-pr.yml@main'
    with:
      pullNumber: '${{ needs.merge-check.outputs.pullNumber }}'

  label-issue-after-automerge:
    needs:
      - merge-check
      - automerge
    if: always() && ( needs.automerge.outputs.prMerged == 'true' && needs.merge-check.outputs.pullNumber != '' )
    permissions:
      contents: write
      issues: write
      pull-requests: read
    uses: 'xn-intenton-z2a/agentic-lib/.github/workflows/wfr-github-label-issue.yml@main'
    with:
      pullNumber: ${{ needs.automerge.outputs.prMerged == 'true' && needs.merge-check.outputs.pullNumber || '' }}
      branchPrefix: 'agentic-lib-issue-'
      removeAllLabels: 'true'

  select-issue:
    permissions:
      issues: read
      id-token: write
    uses: 'xn-intenton-z2a/agentic-lib/.github/workflows/wfr-github-select-issue.yml@main'
    with:
      issueNumber: ''
      selectionLabel: 'automated'
    secrets:
      CHATGPT_API_SECRET_KEY: ${{ secrets.CHATGPT_API_SECRET_KEY }}

  stats:
    needs:
      - select-issue
      - merge-check
      - automerge
      - label-issue-after-automerge
    if: ${{ always() }}
    permissions:
      contents: write
      id-token: write
      pages: write
    uses: 'xn-intenton-z2a/agentic-lib/.github/workflows/wfr-github-stats.yml@main'
    with:
      cache: 'npm'
      npmAuthOrganisation: '@xn-intenton-z2a'
      lastActivityName: ${{ github.workflow }}
      lastActivityBranchName: ${{ github.ref_name }}
      nextIssue: "[${{ needs.select-issue.outputs.issueNumber }}] ${{ needs.select-issue.outputs.issueTitle }} ${{ needs.select-issue.outputs.issueLabels }}"
      public: 'public'
      s3BucketUrl: 's3://agentic-lib-telemetry-bucket/events/'
      s3WebsiteBucketUrl: 's3://agentic-lib-public-website-stats-bucket/'
      iamActionsRoleArn: 'arn:aws:iam::541134664601:role/agentic-lib-github-actions-role'
      iamStatsBucketWriterRoleArn: 'arn:aws:iam::541134664601:role/agentic-lib-deployment-role'
      iamPublicWebsiteStatsBucketWriterRoleArn: 'arn:aws:iam::541134664601:role/agentic-lib-public-website-stats-bucket-writer-role'
    secrets:
      PERSONAL_ACCESS_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}
.github/workflows/wfr-github-label-issue.yml
==== Content of .github/workflows/wfr-github-label-issue.yml ====
# .github/workflows/wfr-github-label-issue.yml

#
# agentic-lib
# Copyright (C) 2025 Polycode Limited
#
# This file is part of agentic-lib.
#
# agentic-lib is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License v3.0 (GPL‑3).
# along with this program. If not, see <https://www.gnu.org/licenses/>.
#
# IMPORTANT: Any derived work must include the following attribution:
# "This work is derived from https://github.com/xn-intenton-z2a/agentic-lib"
#

name: ∞ automerge-label-issue

on:
  workflow_call:
    inputs:
      pullNumber:
        description: 'The pull request number. e.g. "123"'
        type: string
        required: true
      branchPrefix:
        description: 'The prefix for the issue branch. e.g. "agentic-lib-issue-".'
        type: string
        required: true
      removeAllLabels:
        description: 'Whether to remove all labels from the issue. e.g. "true"'
        type: string
        required: false
        default: 'false'
      commentPrefix:
        description: 'The prefix for the comment. e.g. "The feature branch ".'
        type: string
        required: false
        default: 'The feature branch has been merged: '
      npmAuthOrganisation:
        description: 'The organisation for npm authentication. e.g. "@xn-intenton-z2a"'
        type: string
        required: false
        default: '@xn-intenton-z2a'
      cache:
        description: 'The cache to use for npm. e.g. "npm"'
        type: string
        required: false
        default: 'npm'
      s3BucketUrl:
        description: 'The S3 bucket URL with prefix to use. e.g. "s3://my-bucket/prefix"'
        type: string
        required: false
        default: ''
      iamRoleArn:
        description: 'The ARN of the IAM role to assume. e.g. "arn:aws:iam::123456789012:role/my-role"'
        type: string
        required: false
        default: ''
    secrets:
      PERSONAL_ACCESS_TOKEN:
        required: false
    outputs:
      issueNumber:
        description: 'The issue number just merged. e.g. "123"'
        value: ${{ jobs.check-pr.outputs.issueNumber }}
jobs:
  label-issue:
    runs-on: ubuntu-latest

    env:
      pullNumber: ${{ inputs.pullNumber || ''}}
      branchPrefix: ${{ inputs.branchPrefix || '' }}
      commentPrefix: ${{ inputs.commentPrefix || '' }}
      npmAuthOrganisation: ${{ inputs.npmAuthOrganisation || '@xn-intenton-z2a' }}
      cache: ${{ inputs.cache || 'npm' }}
      removeAllLabels: ${{ inputs.removeAllLabels || 'false' }}
      s3BucketUrl: ${{ inputs.s3BucketUrl || '' }}
      iamRoleArn: ${{ inputs.iamRoleArn || '' }}

    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ github.ref }}
          fetch-depth: 0

      - uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: ${{ env.cache }}

      - name: Set up .npmrc
        shell: bash
        run: |
          echo "${{ env.npmAuthOrganisation }}:registry=https://npm.pkg.github.com" >> .npmrc
          echo "//npm.pkg.github.com/:_authToken=${{ secrets.PERSONAL_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}" >> .npmrc
          echo "always-auth=true" >> .npmrc

      - name: extract-issueNumber
        id: extract-issue-number
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PERSONAL_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}
          script: |
            const pullNumber = parseInt('${{ env.pullNumber }}', 10);
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            
            const { data: pullRequest } = await github.rest.pulls.get({
              owner,
              repo,
              pull_number: pullNumber,
            });
            const branchName = pullRequest.head.ref;
            const issueNumberMatch = branchName.match(/${{ env.branchPrefix }}(\d+)/);
            let issueNumber;
            if (issueNumberMatch) {
              issueNumber = issueNumberMatch[1];
            } else {
              issueNumber = '';
            }

            core.setOutput('issueNumber', issueNumber);
            core.info(`issueNumber '${issueNumber}'`);

      - name: Add "merged" label and comment on issue
        if: steps.extract-issue-number.outputs.issueNumber != ''
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PERSONAL_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}
          script: |
            const pullNumber = parseInt('${{ env.pullNumber }}', 10);
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const removeAllLabels = process.env.removeAllLabels === 'true';
            
            const { data: pullRequest } = await github.rest.pulls.get({
              owner,
              repo,
              pull_number: pullNumber,
            });
            const issueNumber = '${{ steps.extract-issue-number.outputs.issueNumber }}';
            const branchName = pullRequest.head.ref;
            const commentBody = `${{ env.branchPrefix || 'The feature branch has been merged: ' }}${branchName}`;
            if(removeAllLabels){
              core.info(`Removing all labels from issue #${issueNumber}`);
              await github.rest.issues.removeAllLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber,
              });
            }
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber,
              labels: ['merged']
            });
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber,
              body: commentBody
            });
    outputs:
      issueNumber: ${{ steps.extract-issue-number.outputs.issueNumber }}

.github/workflows/wfr-completion-apply-fix.yml
==== Content of .github/workflows/wfr-completion-apply-fix.yml ====
# .github/workflows/wfr-completion-apply-fix.yml

#
# agentic-lib
# Copyright (C) 2025 Polycode Limited
#
# This file is part of agentic-lib.
#
# agentic-lib is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License v3.0 (GPL‑3).
# along with this program. If not, see <https://www.gnu.org/licenses/>.
#
# IMPORTANT: Any derived work must include the following attribution:
# "This work is derived from https://github.com/xn-intenton-z2a/agentic-lib"
#

name: ∞ wfr-apply-fix

on:
  workflow_call:
    inputs:
      featuresDir:
        description: 'The directory to create/update the features in. e.g. "features/"'
        type: string
        required: false
        default: 'features/'
      target:
        description: 'The target file to review. e.g. "src/lib/main.js"'
        type: string
        required: false
        default: 'src/lib/main.js'
      testFile:
        description: 'The test file to review. e.g. "tests/unit/main.test.js"'
        type: string
        required: false
        default: 'tests/unit/main.test.js'
      readmeFile:
        description: 'The README file to review. e.g. "README.md"'
        type: string
        required: false
        default: 'README.md'
      missionFile:
        description: 'The MISSION statement file. e.g. "MISSION.md"'
        type: string
        required: false
        default: 'MISSION.md'
      contributingFile:
        description: 'The CONTRIBUTING file to review. e.g. "CONTRIBUTING.md"'
        type: string
        required: false
        default: 'CONTRIBUTING.md'
      dependenciesFile:
        description: 'The dependencies file to review. e.g. "package.json"'
        type: string
        required: false
        default: 'package.json'
      formattingFile:
        description: 'The formatting file to review. e.g. ".prettierrc"'
        type: string
        required: false
        default: '.prettierrc'
      lintingFile:
        description: 'The linting file to review. e.g. "eslint.config.js"'
        type: string
        required: false
        default: 'eslint.config.js'
      buildScript:
        description: 'The script must be runnable as: `npm ci ; <script>` and succeed with a zero exit code. e.g. `npm run build`'
        type: string
        required: false
        default: 'echo "No build script specified."'
      testScript:
        description: 'The script must be runnable as: `npm ci ; <script>` and succeed with a zero exit code. e.g. `npm test`'
        type: string
        required: false
        default: 'npm test'
      mainScript:
        description: 'The script must be runnable as: `npm ci ; <script>` and succeed with a zero exit code. e.g. `npm run start`'
        type: string
        required: false
        default: 'npm run start'
      model:
        description: 'The OpenAI model to use. e.g. "o3-mini"'
        type: string
        required: false
        default: ${{ vars.CHATGPT_API_MODEL || 'o3-mini' }}
      branch:
        description: 'The branch to use for the fix. e.g. "agentic-lib-issue-123"'
        type: string
        required: false
        default: ${{ github.ref }}
      npmAuthOrganisation:
        description: 'The GitHub organisation to authenticate with for npm. e.g. "xn-intenton-z2a"'
        type: string
        required: false
        default: ''
      gitUserEmail:
        description: 'The email to use for git commits. e.g. "action@github.com"'
        type: string
        required: false
        default: 'action@github.com'
      gitUserName:
        description: 'The name to use for git commits. e.g. "GitHub Actions[bot]"'
        type: string
        required: false
        default: 'GitHub Actions[bot]'
      cache:
        description: 'The cache to use for npm. e.g. "npm"'
        type: string
        required: false
        default: 'npm'
      s3BucketUrl:
        description: 'The S3 bucket URL with prefix to use. e.g. "s3://my-bucket/prefix"'
        type: string
        required: false
        default: ''
      iamRoleArn:
        description: 'The ARN of the IAM role to assume. e.g. "arn:aws:iam::123456789012:role/my-role"'
        type: string
        required: false
        default: ''
    secrets:
      PERSONAL_ACCESS_TOKEN:
        required: false
      CHATGPT_API_SECRET_KEY:
        required: true
    outputs:
      fixApplied:
        value: ${{ jobs.apply-fix.outputs.fixApplied }}
      message:
        value: ${{ jobs.apply-fix.outputs.message }}
      installAfterUpdateOutcome:
        value: ${{ jobs.apply-fix.outputs.installAfterUpdateOutcome }}
      ciAfterUpdateOutcome:
        value: ${{ jobs.apply-fix.outputs.ciAfterUpdateOutcome }}
      testAfterUpdateOutcome:
        value: ${{ jobs.apply-fix.outputs.testAfterUpdateOutcome }}
      mainAfterUpdateOutcome:
        value: ${{ jobs.apply-fix.outputs.mainAfterUpdateOutcome }}
      commitOutcome:
        value: ${{ jobs.apply-fix.outputs.commitOutcome }}
      postResolutionCommentOutcome:
        value: ${{ jobs.start-issue.outputs.postResolutionCommentOutcome }}
      allValidationStepsSuccessful:
        value: ${{ jobs.start-issue.outputs.allValidationStepsSuccessful }}

jobs:
  apply-fix:
    runs-on: ubuntu-latest

    env:
      featuresDir: ${{ inputs.featuresDir || 'features/' }}
      target: ${{ inputs.target || 'src/lib/main.js' }}
      testFile: ${{ inputs.testFile || 'tests/unit/main.test.js' }}
      readmeFile: ${{ inputs.readmeFile || 'README.md' }}
      missionFile: ${{ inputs.missionFile || 'MISSION.md' }}
      contributingFile: ${{ inputs.contributingFile || 'CONTRIBUTING.md' }}
      dependenciesFile: ${{ inputs.dependenciesFile || 'package.json' }}
      formattingFile: ${{ inputs.formattingFile || '.prettierrc' }}
      lintingFile: ${{ inputs.lintingFile || 'eslint.config.js' }}
      buildScript: ${{ inputs.buildScript || 'npm run build' }}
      testScript: ${{ inputs.testScript || 'npm test' }}
      mainScript: ${{ inputs.mainScript || 'npm run start' }}
      mainScriptTimeout: '5m'
      model: ${{ inputs.model || vars.CHATGPT_API_MODEL || 'o3-mini' }}
      chatgptApiSecretKey: ${{ secrets.CHATGPT_API_SECRET_KEY }}
      npmAuthOrganisation: ${{ inputs.npmAuthOrganisation || '' }}
      branch: ${{ inputs.branch || github.ref }}
      gitUserEmail: ${{ inputs.gitUserEmail || 'action@github.com' }}
      gitUserName: ${{ inputs.gitUserName || 'GitHub Actions[bot]' }}
      cache: ${{ inputs.cache || 'npm' }}
      s3BucketUrl: ${{ inputs.s3BucketUrl || '' }}
      iamRoleArn: ${{ inputs.iamRoleArn || '' }}

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ env.branch }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: ${{ env.cache }}

      - name: Check GitHub authentication
        if: ${{ env.npmAuthOrganisation != '' }}
        shell: bash
        run: |
          curl --include --header "Authorization: token ${{ secrets.PERSONAL_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}" https://api.github.com/user

      - name: Set up .npmrc
        if: ${{ env.npmAuthOrganisation != '' }}
        shell: bash
        run: |
          echo "${{ env.npmAuthOrganisation }}:registry=https://npm.pkg.github.com" >> .npmrc
          echo "//npm.pkg.github.com/:_authToken=${{ secrets.PERSONAL_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}" >> .npmrc
          echo "always-auth=true" >> .npmrc

      - name: List current features
        id: features
        shell: bash
        run: |
          output=$(find "${{ env.featuresDir }}" -maxdepth 1 -type f -name '*.md' -print -exec echo "# {}" \; -exec cat {} \; 2>&1 || echo 'none')
          echo "output<<EOF" >> "$GITHUB_OUTPUT"
          echo "$output" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          echo "output=${output}"

      - name: Install dependencies
        id: install
        shell: bash
        run: |
          set +e
          output=$(npm install 2>&1)
          echo "output<<EOF" >> "$GITHUB_OUTPUT"
          echo "$output" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          echo "output=${output}"
          exit 0

      - name: Build project
        id: build
        shell: bash
        run: |
          set +e
          output=$(${{ env.buildScript }} 2>&1)
          echo "output<<EOF" >> "$GITHUB_OUTPUT"
          echo "$output" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          echo "output=${output}"
          exit 0

      - name: Tear down .npmrc
        if: ${{ env.npmAuthOrganisation != '' }}
        shell: bash
        run: rm -f .npmrc

      - name: Run tests
        id: test
        shell: bash
        run: |
          set +e
          output=$(${{ env.testScript }} 2>&1)
          echo "output<<EOF" >> "$GITHUB_OUTPUT"
          echo "$output" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          echo "output=${output}"
          exit 0

      - name: Run main
        id: main
        shell: bash
        run: |
          set +e
          output=$(timeout ${{ env.mainScriptTimeout }} ${{ env.mainScript }} 2>&1)
          echo "output<<EOF" >> "$GITHUB_OUTPUT"
          echo "$output" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          echo "output=${output}"
          exit 0

      - name: update-target
        id: update-target
        uses: actions/github-script@v7
        env:
          installOutput: ${{ steps.install.outputs.output }}
          buildOutput: ${{ steps.build.outputs.output }}
          testOutput: ${{ steps.test.outputs.output }}
          mainOutput: ${{ steps.main.outputs.output }}
        with:
          github-token: ${{ secrets.PERSONAL_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}
          script: |
            const currentFeatures = process.env.currentFeatures;
            const target = process.env.target;
            const testFile = process.env.testFile;
            const readmeFile = process.env.readmeFile;
            const missionFile = process.env.missionFile;
            const contributingFile = process.env.contributingFile;
            const dependenciesFile = process.env.dependenciesFile;
            const formattingFile = process.env.formattingFile;
            const lintingFile = process.env.lintingFile;
            const model = process.env.model;
            const apiKey = process.env.chatgptApiSecretKey;
            const installOutput = process.env.installOutput;
            const dependenciesListOutput = process.env.dependenciesListOutput;
            const buildScript = process.env.buildScript;
            const buildOutput = process.env.buildOutput;
            const testScript = process.env.testScript;
            const testOutput = process.env.testOutput;
            const mainScript = process.env.mainScript;
            const mainOutput = process.env.mainOutput;
            
            const fs = require('fs');
            const OpenAI = require('openai').default;
            const { z } = require('zod');
            require('dotenv').config();
            
            if (!apiKey) { 
              core.setFailed("Missing CHATGPT_API_SECRET_KEY"); 
            }
            const openai = new OpenAI({ apiKey });
            
            core.info(`currentFeatures: "${currentFeatures}"`);
            core.info(`target: "${target}"`);
            core.info(`testFile: "${testFile}"`);
            core.info(`readmeFile: "${readmeFile}"`);
            core.info(`missionFile: "${missionFile}"`);
            core.info(`contributingFile: "${contributingFile}"`);
            core.info(`dependenciesFile: "${dependenciesFile}"`);
            core.info(`formattingFile: "${formattingFile}"`);
            core.info(`lintingFile: "${lintingFile}"`);
            const sourceFileContent = fs.readFileSync(target, 'utf8');
            const testFileContent = fs.readFileSync(testFile, 'utf8');
            const readmeFileContent = fs.readFileSync(readmeFile, 'utf8');
            const missionFileContent = fs.readFileSync(missionFile, 'utf8');
            const contributingFileContent = fs.readFileSync(contributingFile, 'utf8');
            const dependenciesFileContent = fs.readFileSync(dependenciesFile, 'utf8');
            const formattingFileContent = fs.readFileSync(formattingFile, 'utf8');
            const lintingFileContent = fs.readFileSync(lintingFile, 'utf8');
            core.info(`Target file '${target}' has been loaded (length ${sourceFileContent.length}).`);
            core.info(`Test file '${testFile}' has been loaded (length ${testFileContent.length}).`);
            core.info(`Readme file '${readmeFile}' has been loaded (length ${readmeFileContent.length}).`);
            core.info(`Dependencies file '${dependenciesFile}' has been loaded (length ${dependenciesFileContent.length}).`);
            core.info(`Formatting file '${formattingFile}' has been loaded (length ${formattingFileContent.length}).`);
            core.info(`Linting file '${lintingFile}' has been loaded (length ${lintingFileContent.length}).`);
            
            const prompt = `
            You are providing the entire new content of the source file, test file and README file with all necessary changes applied to resolve a possible build or test problem.
            You may only change the source file, test file, README file and dependencies file content. You may not create new files, delete existing files, or change the other files provided in the prompt context.
            Consider the following when refining your response:
            * Current feature names and specifications in the repository
            * Source file content
            * Test file content
            * README file content
            * MISSION file content
            * Contributing file content
            * Dependencies file content
            * Formatting file content
            * Linting file content
            * Dependency install output
            * Build output
            * Test output
            * Main execution output
            
            Apply the contributing guidelines to your response and when suggesting enhancements consider the tone and direction of the contributing guidelines.
            
            Current feature names and specifications:
            CURRENT_FEATURES_START
            ${currentFeatures}
            CURRENT_FEATURES_END
            
            Source file: ${target}
            SOURCE_FILE_START
            ${sourceFileContent}
            SOURCE_FILE_END
            
            Test file: ${testFile}
            TEST_FILE_START
            ${testFileContent}
            TEST_FILE_END

            README file: ${readmeFile}
            README_FILE_START
            ${readmeFileContent}
            README_FILE_END
            
            MISSION file: ${missionFile}
            MISSION_FILE_START
            ${missionFileContent}
            MISSION_FILE_END

            Contributing file: ${contributingFile}
            CONTRIBUTING_FILE_START
            ${contributingFileContent}
            CONTRIBUTING_FILE_END
            
            Dependencies file: ${dependenciesFile}
            DEPENDENCIES_FILE_START
            ${dependenciesFileContent}
            DEPENDENCIES_FILE_END
            
            Formatting file: ${formattingFile}
            FORMATTING_FILE_START
            ${formattingFileContent}
            FORMATTING_FILE_END
            
            Linting file: ${lintingFile}
            LINTING_FILE_START
            ${lintingFileContent}
            LINTING_FILE_END        

            Dependencies install from command: npm install
            DEPENDENCIES_INSTALL_START
            ${installOutput}
            DEPENDENCIES_INSTALL_END    

            Build output from command: ${buildScript}
            BUILD_OUTPUT_START
            ${buildOutput}
            BUILD_OUTPUT_END      
            
            Test output from command: ${testScript}
            TEST_OUTPUT_START
            ${testOutput}
            TEST_OUTPUT_END            

            Main execution output from command: ${mainScript}
            MAIN_OUTPUT_START
            ${mainOutput}
            MAIN_OUTPUT_END    
            
            Please produce an updated version of the source file, and test file, and README and dependencies file that resolves the possible build or test problem.
            If there are no changes required, please provide the original content and state that no changes are necessary in the message.
            Answer strictly with a JSON object following this schema:
            
            {
              "updatedSourceFileContent": "The entire new content of the source file, with all necessary changes applied, if any.",
              "updatedTestFileContent": "The entire new content of the test file, with all necessary changes applied, if any.",
              "updatedReadmeFileContent": "The entire new content of the README file, with all necessary changes applied, if any.",
              "updatedDependenciesFileContent": "The entire new content of the dependencies file, with all necessary changes applied, if any.",
              "message": "A short sentence explaining the change applied (or why no changes were applied) suitable for a commit message or PR text."
            }
            
            Ensure valid JSON.
            `;
            
            const ResponseSchema = z.object({ updatedSourceFileContent: z.string(), updatedTestFileContent: z.string(), updatedReadmeFileContent: z.string(), updatedDependenciesFileContent: z.string(), message: z.string() });
            
            // Define the function schema for functional calling
            const applyIssueResolutionToSource = [{
              type: "function",
              function: {
                name: "applyIssueResolutionToSource",
                description: "Return an updated version of the source file content along with a commit message. Use the provided source file content and supporting context to generate the update.",
                parameters: {
                  type: "object",
                  properties: {
                    updatedSourceFileContent: {
                      type: "string",
                      description: "The entire new content of the source file, with all necessary changes applied, if any."
                    },
                    updatedTestFileContent: {
                      type: "string",
                      description: "The entire new content of the test file, with all necessary changes applied, if any."
                    },
                    updatedReadmeFileContent: {
                      type: "string",
                      description: "The entire new content of the README file, with all necessary changes applied, if any."
                    },
                    updatedDependenciesFileContent: {
                      type: "string",
                      description: "The entire new content of the dependencies file, with all necessary changes applied, if any."
                    },
                    message: {
                      type: "string",
                      description: "A short sentence explaining the change applied (or why no changes were applied) suitable for a commit message or PR text."
                    }
                  },
                  required: ["updatedSourceFileContent", "updatedTestFileContent", "updatedReadmeFileContent", "updatedDependenciesFileContent", "message"],
                  additionalProperties: false
                },
                strict: true
              }
            }];
            
            // Call OpenAI using the function calling format via the tools parameter
            const response = await openai.chat.completions.create({
              model,
              messages: [
                { role: "system", content: "You are a code fixer that returns an updated source file content, test file content, README file content and dependencies file content to resolve a possible build or test problem. Answer strictly with a JSON object that adheres to the provided function schema." },
                { role: "user", content: prompt }
              ],
              tools: applyIssueResolutionToSource
            });
            
            let fixApplied;
            let result;
            // Check if the model made a function call; if so, parse its arguments.
            if (response.choices[0].message.tool_calls && response.choices[0].message.tool_calls.length > 0) {
              try {
                result = JSON.parse(response.choices[0].message.tool_calls[0].function.arguments);
              } catch (e) {
                fixApplied = false;
                core.setFailed(`Failed to parse function call arguments: ${e.message}`);
              }
            } else if (response.choices[0].message.content) {
              try {
                result = JSON.parse(response.choices[0].message.content);
              } catch (e) {
                fixApplied = false;
                core.setFailed(`Failed to parse response content: ${e.message}`);
              }
            } else {
              fixApplied = false;
              core.setFailed("No valid response received from OpenAI.");
            }
            
            try {
              const parsed = ResponseSchema.parse(result);
              // Sanitize commit message: retain only alphanumerics, spaces, and basic URL-safe punctuation (-, _, ., ~)
              const sanitizedMessage = parsed.message.replace(/[^A-Za-z0-9 \-\_\.\~]/g, '').replace(/\s+/g, ' ').trim();
              core.setOutput("message", sanitizedMessage);
              core.info(`message: "${sanitizedMessage}"`);
            
              if(parsed.updatedSourceFileContent && parsed.updatedSourceFileContent.length > 1 && parsed.updatedSourceFileContent !== sourceFileContent) {
                fs.writeFileSync(target, parsed.updatedSourceFileContent, 'utf8');
                fixApplied = true;
                core.info(`Target file '${target}' has been updated (length ${parsed.updatedSourceFileContent.length}).`);
              }
              if(parsed.updatedTestFileContent && parsed.updatedTestFileContent.length > 1 && parsed.updatedTestFileContent !== testFileContent) {
                fs.writeFileSync(testFile, parsed.updatedTestFileContent, 'utf8');
                fixApplied = true;
                core.info(`Test file '${testFile}' has been updated (length ${parsed.updatedTestFileContent.length}).`);
              }
              if(parsed.updatedReadmeFileContent && parsed.updatedReadmeFileContent.length > 1 && parsed.updatedReadmeFileContent !== readmeFileContent) {
                fs.writeFileSync(readmeFile, parsed.updatedReadmeFileContent, 'utf8');
                fixApplied = true;
                core.info(`Readme file '${readmeFile}' has been updated (length ${parsed.updatedReadmeFileContent.length}).`);
              }
              if(parsed.updatedDependenciesFileContent && parsed.updatedDependenciesFileContent.length > 1 && parsed.updatedDependenciesFileContent !== dependenciesFileContent) {
                fs.writeFileSync(dependenciesFile, parsed.updatedDependenciesFileContent, 'utf8');
                fixApplied = true;
                core.info(`Dependencies file '${dependenciesFile}' has been updated (length ${parsed.updatedDependenciesFileContent.length}).`);
              }

            } catch (e) {
              fixApplied = false;
              core.setFailed(`Failed to validate or process the response: ${e.message}`);
            }
            
            core.setOutput("fixApplied", fixApplied);
            core.setOutput("usage", JSON.stringify(response.usage));
            core.info(`fixApplied: "${fixApplied}"`);
            core.info(`usage: "${JSON.stringify(response.usage)}"`);
            core.info(`response: "${JSON.stringify(response)}"`);

      - run: cat ${{ env.target }}

      - name: Examine the git working copy
        shell: bash
        run: |
          git config --local user.email '${{ env.gitUserEmail }}'
          git config --local user.name '${{ env.gitUserName }}'
          git status -v
          git diff ${{ env.target }}

      - name: install-after-update
        id: install-after-update
        shell: bash
        run: |
          set +e
          npm install
          exit 0

      - name: ci-after-update
        id: ci-after-update
        shell: bash
        run: |
          set +e
          npm ci
          exit 0

      - name: Test after update
        id: test-after-update
        shell: bash
        run: |
          set +e
          ${{ env.testScript }}
          exit 0

      - name: Run main after update
        id: main-after-update
        shell: bash
        run: |
          set +e
          timeout ${{ env.mainScriptTimeout }} ${{ env.mainScript }}
          exit 0

      - name: Commit changes
        id: commit
        continue-on-error: true
        run: |
          git config --local user.email '${{ env.gitUserEmail }}'
          git config --local user.name '${{ env.gitUserName }}'
          git status -v
          git add -v --all
          git diff '${{ env.target }}'
          git commit -m '${{ steps.update-target.outputs.message }}'
          git status -v
          git push -v origin ${{ env.branch }}
          git status -v

      - name: Extract Results
        if: always()
        id: results
        uses: actions/github-script@v7
        with:
          script: |
            const fixApplied = '${{ steps.update-target.outputs.fixApplied }}';
            const message = '${{ steps.update-target.outputs.message }}';
            const installAfterUpdateOutcome = '${{ steps.install-after-update.outcome }}';
            const ciAfterUpdateOutcome = '${{ steps.ci-after-update.outcome }}';
            const testAfterUpdateOutcome = '${{ steps.test-after-update.outcome }}';
            const mainAfterUpdateOutcome = '${{ steps.main-after-update.outcome }}';
            const commitOutcome = '${{ steps.commit.outcome }}';
            const allValidationStepsSuccessful = installAfterUpdateOutcome === "success" && ciAfterUpdateOutcome === "success" && testAfterUpdateOutcome === "success" && mainAfterUpdateOutcome === "success" && commitOutcome === "success";
            core.setOutput('fixApplied', fixApplied);
            core.setOutput('message', message);
            core.setOutput('installAfterUpdateOutcome', installAfterUpdateOutcome);
            core.setOutput('ciAfterUpdateOutcome', ciAfterUpdateOutcome);
            core.setOutput('testAfterUpdateOutcome', testAfterUpdateOutcome);
            core.setOutput('mainAfterUpdateOutcome', mainAfterUpdateOutcome);
            core.setOutput('commitOutcome', commitOutcome);
            core.setOutput('allValidationStepsSuccessful', allValidationStepsSuccessful);
            core.info(`fixApplied: "${fixApplied}"`);
            core.info(`message: "${message}"`);
            core.info(`installAfterUpdateOutcome: "${installAfterUpdateOutcome}"`);
            core.info(`ciAfterUpdateOutcome: "${ciAfterUpdateOutcome}"`);
            core.info(`testAfterUpdateOutcome: "${testAfterUpdateOutcome}"`);
            core.info(`mainAfterUpdateOutcome: "${mainAfterUpdateOutcome}"`);
            core.info(`commitOutcome: "${commitOutcome}"`);
            core.info(`allValidationStepsSuccessful: "${allValidationStepsSuccessful}"`);

    outputs:
      fixApplied: ${{ steps.results.outputs.fixApplied }}
      message: ${{ steps.results.outputs.message }}
      installAfterUpdateOutcome: ${{ steps.results.outputs.installAfterUpdateOutcome }}
      ciAfterUpdateOutcome: ${{ steps.results.outputs.ciAfterUpdateOutcome }}
      testAfterUpdateOutcome: ${{ steps.results.outputs.testAfterUpdateOutcome }}
      mainAfterUpdateOutcome: ${{ steps.results.outputs.mainAfterUpdateOutcome }}
      commitOutcome: ${{ steps.results.outputs.commitOutcome }}
      allValidationStepsSuccessful: ${{ steps.results.outputs.allValidationStepsSuccessful }}

.github/workflows/wfr-mvn-update.yml
==== Content of .github/workflows/wfr-mvn-update.yml ====
# .github/workflows/wfr-mvn-update.yml

#
# agentic-lib
# Copyright (C) 2025 Polycode Limited
#
# This file is part of agentic-lib.
#
# agentic-lib is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License v3.0 (GPL‑3).
# along with this program. If not, see <https://www.gnu.org/licenses/>.
#
# IMPORTANT: Any derived work must include the following attribution:
# "This work is derived from https://github.com/xn-intenton-z2a/agentic-lib"
#

name: ∞ update-mvn

on:
  workflow_call:
    inputs:
      buildScript:
        description: 'The script must be runnable as: `mvn clean install`'
        type: string
        required: false
        default: './mvnw clean install'
      testScript:
        description: 'The script must be runnable as: `mvn test`'
        type: string
        required: false
        default: './mvnw test'
      upgradeTarget:
        description: 'Ignored for Maven; use versions:use-latest-releases'
        type: string
        required: false
        default: 'minor'
      branch:
        description: 'The branch to push changes to. e.g. "agentic-lib-update"'
        type: string
        required: false
        default: 'agentic-lib-update'
      npmAuthOrganisation:
        description: '(Not used for Maven)'
        type: string
        required: false
        default: ''
      gitUserEmail:
        description: 'The email to use for git commits. e.g. "action@github.com"'
        type: string
        required: false
        default: 'action@github.com'
      gitUserName:
        description: 'The name to use for git commits. e.g. "GitHub Actions[bot]"'
        type: string
        required: false
        default: 'GitHub Actions[bot]'
      cache:
        description: 'The cache to use for npm. e.g. "maven"'
        type: string
        required: false
        default: 'maven'
      gitCommitMessage:
        description: 'The message to use for git commits. e.g. "chore: dependency updates"'
        type: string
        required: false
        default: 'chore: dependency updates'
    secrets:
      PERSONAL_ACCESS_TOKEN:
        required: false
    outputs:
      updatedFiles:
          description: 'Whether files were updated by the script. e.g. "true"'
          value: ${{ jobs.update.outputs.updatedFiles }}

jobs:
  update:
    runs-on: ubuntu-latest

    env:
      buildScript: ${{ inputs.buildScript || './mvnw clean install' }}
      testScript: ${{ inputs.testScript || './mvnw test' }}
      upgradeTarget: ${{ inputs.upgradeTarget || 'minor' }}
      branch: ${{ inputs.branch || 'agentic-lib-update' }}
      gitUserEmail: ${{ inputs.gitUserEmail || 'action@github.com' }}
      gitUserName: ${{ inputs.gitUserName || 'GitHub Actions[bot]' }}
      cache: ${{ inputs.cache || 'maven' }}
      gitCommitMessage: |
        ${{ inputs.gitCommitMessage || 'chore: dependency updates' }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Java (JDK 21)
        uses: actions/setup-java@v3
        with:
          distribution: 'temurin'
          java-version: '21'
          cache: ${{ env.cache }}

      - name: Get latest from remote
        run: |
          git config --local user.email "${{ env.gitUserEmail }}"
          git config --local user.name "${{ env.gitUserName }}"
          git pull --ff-only origin ${{ github.ref }}

      - name: Build project before update
        id: build
        shell: bash
        run: |
          output=$(${{env.buildScript}} 2>&1)
          echo "output<<EOF" >> "$GITHUB_OUTPUT"
          echo "$output" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          echo "output=${output}"

      - name: Run tests before update
        id: test
        shell: bash
        run: |
          output=$(${{env.testScript}} 2>&1)
          echo "output<<EOF" >> "$GITHUB_OUTPUT"
          echo "$output" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          echo "output=${output}"

      - name: Update Maven dependencies
        continue-on-error: true
        shell: bash
        run: |
          mvn versions:use-latest-releases -DallowSnapshots=false
          # Optionally, run: mvn versions:commit to finalize changes

      - name: Get git diff status
        id: git-diff
        shell: bash
        run: |
          savedOptions=$(set +o) && set +e
          if git diff --quiet; then
            echo "updated=false" | tee -a "${GITHUB_OUTPUT?}"
          else
            echo "updated=true" | tee -a "${GITHUB_OUTPUT?}"
          fi
          eval "${savedOptions?}"
        continue-on-error: true

      - name: Build project after update
        shell: bash
        run: ${{env.buildScript}}

      - name: Run tests after update
        shell: bash
        run: ${{env.testScript}}

      - name: Commit changes
        if: ${{ steps.git-diff.outputs.updated == 'true' || env.git-force == 'true' }}
        shell: bash
        run: |
          git config --local user.email "${{ env.gitUserEmail }}"
          git config --local user.name "${{ env.gitUserName }}"
          git status -v
          git switch -c "${{ env.branch }}"
          git add -v --all
          git commit -v -m "${{ env.gitCommitMessage }}"
          git pull --rebase origin main
          git push --set-upstream origin "${{ env.branch }}"
          git push -v
          git status -v

    outputs:
      updatedFiles: ${{ steps.git-diff.outputs.updated || '' }}
.github/workflows/issue-for-linting.yml
==== Content of .github/workflows/issue-for-linting.yml ====
# .github/workflows/issue-for-linting.yml
#
# This file is part of the example suite for `agentic-lib` see: https://github.com/xn-intenton-z2a/agentic-lib
# This file is licensed under the MIT License. For details, see LICENSE-MIT

name: Linting
run-name: "Linting [${{ github.ref_name }}]"

on:
  workflow_dispatch:
  schedule:
    - cron: '30 6 */14 * *' # schedule-1
    #- cron: '30 6 */3 * *' # schedule-2
    #- cron: '30 6 * * *' # schedule-3
    #- cron: '30 6 * * *' # schedule-4

jobs:

  linting:
    permissions:
      contents: write
      packages: write
      id-token: write
    uses: 'xn-intenton-z2a/agentic-lib/.github/workflows/wfr-npm-run-script-and-commit-to-branch.yml@main'
    with:
      #script: 'npm run linting "." -- --max-warnings=10'
      script: 'npm run linting src/lib/main.js tests/unit/main.test.js'
      sarifScript: 'npm run linting-json --silent src/lib/main.js tests/unit/main.test.js'
      testScript: 'npm test'

  create-issue:
    needs:
      - linting
    if: ${{ needs.linting.outputs.fixStillRequired == 'true' || needs.linting.outputs.fixStillRequired == true || needs.linting.outputs.remainingResultsCount != '0' }}
    permissions:
      issues: write
      id-token: write
    uses: 'xn-intenton-z2a/agentic-lib/.github/workflows/wfr-github-create-issue.yml@main'
    with:
      issueTitle: 'Resolve issues in output from running: npm run linting-fix "." -- --max-warnings=10'
      issueBody: ${{ needs.linting.outputs.scriptOutput }}
      issueLabels: 'maintenance, automated'

  select-issue:
    permissions:
      issues: read
      id-token: write
    uses: 'xn-intenton-z2a/agentic-lib/.github/workflows/wfr-github-select-issue.yml@main'
    with:
      issueNumber: ''
      selectionLabel: 'automated'
    secrets:
      CHATGPT_API_SECRET_KEY: ${{ secrets.CHATGPT_API_SECRET_KEY }}

  stats:
    needs:
      - select-issue
      - create-issue
    if: ${{ always() }}
    permissions:
      contents: write
      id-token: write
      pages: write
    uses: 'xn-intenton-z2a/agentic-lib/.github/workflows/wfr-github-stats.yml@main'
    with:
      cache: 'npm'
      npmAuthOrganisation: '@xn-intenton-z2a'
      lastActivityName: ${{ github.workflow }}
      lastActivityBranchName: ${{ github.ref_name }}
      nextIssue: "[${{ needs.select-issue.outputs.issueNumber }}] ${{ needs.select-issue.outputs.issueTitle }} ${{ needs.select-issue.outputs.issueLabels }}"
      public: 'public'
      s3BucketUrl: 's3://agentic-lib-telemetry-bucket/events/'
      s3WebsiteBucketUrl: 's3://agentic-lib-public-website-stats-bucket/'
      iamActionsRoleArn: 'arn:aws:iam::541134664601:role/agentic-lib-github-actions-role'
      iamStatsBucketWriterRoleArn: 'arn:aws:iam::541134664601:role/agentic-lib-deployment-role'
      iamPublicWebsiteStatsBucketWriterRoleArn: 'arn:aws:iam::541134664601:role/agentic-lib-public-website-stats-bucket-writer-role'
    secrets:
      PERSONAL_ACCESS_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}
.github/workflows/wfr-completion-review-issue.yml
==== Content of .github/workflows/wfr-completion-review-issue.yml ====
# .github/workflows/wfr-completion-review-issue.yml

#
# agentic-lib
# Copyright (C) 2025 Polycode Limited
#
# This file is part of agentic-lib.
#
# agentic-lib is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License v3.0 (GPL‑3).
# along with this program. If not, see <https://www.gnu.org/licenses/>.
#
# IMPORTANT: Any derived work must include the following attribution:
# "This work is derived from https://github.com/xn-intenton-z2a/agentic-lib"
#

name: ∞ review-issue

on:
  workflow_call:
    inputs:
      issueNumber:
        description: 'The issue number to review. e.g. "123"'
        type: string
        required: true
      featuresDir:
        description: 'The directory to create/update the features in. e.g. "features/"'
        type: string
        required: false
        default: 'features/'
      target:
        description: 'The target file to review. e.g. "src/lib/main.js"'
        type: string
        required: false
        default: 'src/lib/main.js'
      testFile:
        description: 'The test file to review. e.g. "tests/unit/main.test.js"'
        type: string
        required: false
        default: 'tests/unit/main.test.js'
      readmeFile:
        description: 'The README file to review. e.g. "README.md"'
        type: string
        required: false
        default: 'README.md'
      missionFile:
        description: 'The MISSION statement file. e.g. "MISSION.md"'
        type: string
        required: false
        default: 'MISSION.md'
      contributingFile:
        description: 'The CONTRIBUTING file to review. e.g. "CONTRIBUTING.md"'
        type: string
        required: false
        default: 'CONTRIBUTING.md'
      dependenciesFile:
        description: 'The dependencies file to review. e.g. "package.json"'
        type: string
        required: false
        default: 'package.json'
      buildScript:
        description: 'The script must be runnable as: `npm ci ; <script>` and succeed with a zero exit code. e.g. `npm run build`'
        type: string
        required: false
        default: 'echo "No build script specified."'
      testScript:
        description: 'The script must be runnable as: `npm ci ; <script>` and succeed with a zero exit code. e.g. `npm test`'
        type: string
        required: false
        default: 'npm test'
      mainScript:
        description: 'The script must be runnable as: `npm ci ; <script>` and succeed with a zero exit code. e.g. `npm run start`'
        type: string
        required: false
        default: 'npm run start'
      model:
        description: 'The OpenAI model to use. e.g. "o3-mini"'
        type: string
        required: false
        default: ${{ vars.CHATGPT_API_MODEL || 'o3-mini' }}
      cache:
        description: 'The cache to use for npm. e.g. "npm"'
        type: string
        required: false
        default: 'npm'
      s3BucketUrl:
        description: 'The S3 bucket URL with prefix to use. e.g. "s3://my-bucket/prefix"'
        type: string
        required: false
        default: ''
      iamRoleArn:
        description: 'The ARN of the IAM role to assume. e.g. "arn:aws:iam::123456789012:role/my-role"'
        type: string
        required: false
        default: ''
    secrets:
      PERSONAL_ACCESS_TOKEN:
        required: false
      CHATGPT_API_SECRET_KEY:
        required: true
    outputs:
      fixed:
        value: ${{ jobs.review-issue.outputs.fixed }}

jobs:
  review-issue:
    runs-on: ubuntu-latest

    env:
      issueNumber: ${{ inputs.issueNumber }}
      featuresDir: ${{ inputs.featuresDir || 'features/' }}
      target: ${{ inputs.target || 'src/lib/main.js' }}
      testFile: ${{ inputs.testFile || 'tests/unit/main.test.js' }}
      readmeFile: ${{ inputs.readmeFile || 'README.md' }}
      missionFile: ${{ inputs.missionFile || 'MISSION.md' }}
      contributingFile: ${{ inputs.contributingFile || 'CONTRIBUTING.md' }}
      dependenciesFile: ${{ inputs.dependenciesFile || 'package.json' }}
      buildScript: ${{ inputs.buildScript || 'npm run build' }}
      testScript: ${{ inputs.testScript || 'npm test' }}
      mainScript: ${{ inputs.mainScript || 'npm run start' }}
      mainScriptTimeout: '5m'
      model: ${{ inputs.model || vars.CHATGPT_API_MODEL || 'o3-mini' }}
      chatgptApiSecretKey: ${{ secrets.CHATGPT_API_SECRET_KEY }}
      cache: ${{ inputs.cache || 'npm' }}
      s3BucketUrl: ${{ inputs.s3BucketUrl || '' }}
      iamRoleArn: ${{ inputs.iamRoleArn || '' }}

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: ${{ env.cache }}

      - name: Check GitHub authentication
        if: ${{ env.npmAuthOrganisation != '' }}
        shell: bash
        run: |
          curl --include --header "Authorization: token ${{ secrets.PERSONAL_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}" https://api.github.com/user

      - name: Set up .npmrc
        if: ${{ env.npmAuthOrganisation != '' }}
        shell: bash
        run: |
          echo "${{ env.npmAuthOrganisation }}:registry=https://npm.pkg.github.com" >> .npmrc
          echo "//npm.pkg.github.com/:_authToken=${{ secrets.PERSONAL_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}" >> .npmrc
          echo "always-auth=true" >> .npmrc

      - run: npm ci

      - name: List current features
        id: features
        shell: bash
        run: |
          output=$(find "${{ env.featuresDir }}" -maxdepth 1 -type f -name '*.md' -print -exec echo "# {}" \; -exec cat {} \; 2>&1 || echo 'none')
          echo "output<<EOF" >> "$GITHUB_OUTPUT"
          echo "$output" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          echo "output=${output}"

      - name: List dependencies
        id: list
        shell: bash
        run: |
          output=$(npm list 2>&1)
          echo "output<<EOF" >> "$GITHUB_OUTPUT"
          echo "$output" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          echo "output=${output}"

      - name: Build project
        id: build
        shell: bash
        run: |
          output=$(${{ env.buildScript }} 2>&1)
          echo "output<<EOF" >> "$GITHUB_OUTPUT"
          echo "$output" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          echo "output=${output}"

      - name: Tear down .npmrc
        if: ${{ env.npmAuthOrganisation != '' }}
        shell: bash
        run: rm -f .npmrc

      - name: Run tests
        id: test
        shell: bash
        run: |
          output=$(${{ env.testScript }} 2>&1)
          echo "output<<EOF" >> "$GITHUB_OUTPUT"
          echo "$output" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          echo "output=${output}"

      - name: Run main
        id: main
        shell: bash
        run: |
          output=$(timeout ${{ env.mainScriptTimeout }} ${{ env.mainScript }} 2>&1)
          echo "output<<EOF" >> "$GITHUB_OUTPUT"
          echo "$output" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          echo "output=${output}"

      - name: verify
        id: verify
        uses: actions/github-script@v7
        env:
          dependenciesListOutput: ${{ steps.list.outputs.output }}
          buildOutput: ${{ steps.build.outputs.output }}
          testOutput: ${{ steps.test.outputs.output }}
          mainOutput: ${{ steps.main.outputs.output }}
        with:
          github-token: ${{ secrets.PERSONAL_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}
          script: |
            const currentFeatures = process.env.currentFeatures;
            const target = process.env.target;
            const testFile = process.env.testFile;
            const readmeFile = process.env.readmeFile;
            const missionFile = process.env.missionFile;
            const contributingFile = process.env.contributingFile;
            const dependenciesFile = process.env.dependenciesFile;
            const model = process.env.model;
            const apiKey = process.env.chatgptApiSecretKey;
            const issueNumber = parseInt(process.env.issueNumber);
            const dependenciesListOutput = process.env.dependenciesListOutput;
            const buildScript = process.env.buildScript;
            const buildOutput = process.env.buildOutput;
            const testScript = process.env.testScript;
            const testOutput = process.env.testOutput;
            const mainScript = process.env.mainScript;
            const mainOutput = process.env.mainOutput;

            const fs = require('fs');
            const OpenAI = require('openai').default;
            const { z } = require('zod');
            require('dotenv').config();

            if (!apiKey) { 
              core.setFailed("Missing CHATGPT_API_SECRET_KEY"); 
            }
            const openai = new OpenAI({ apiKey });

            core.info(`currentFeatures: "${currentFeatures}"`);
            core.info(`target: "${target}"`);
            core.info(`testFile: "${testFile}"`);
            core.info(`readmeFile: "${readmeFile}"`);
            core.info(`missionFile: "${missionFile}"`);
            core.info(`contributingFile: "${contributingFile}"`);
            core.info(`dependenciesFile: "${dependenciesFile}"`);
            const sourceFileContent = fs.readFileSync(target, 'utf8');
            const testFileContent = fs.readFileSync(testFile, 'utf8');
            const readmeFileContent = fs.readFileSync(readmeFile, 'utf8');
            const missionFileContent = fs.readFileSync(missionFile, 'utf8');
            const contributingFileContent = fs.readFileSync(contributingFile, 'utf8');
            const dependenciesFileContent = fs.readFileSync(dependenciesFile, 'utf8');
            core.info(`Target file '${target}' has been loaded (length ${sourceFileContent.length}).`);
            core.info(`Test file '${testFile}' has been loaded (length ${testFileContent.length}).`);
            core.info(`Readme file '${readmeFile}' has been loaded (length ${readmeFileContent.length}).`);
            core.info(`Dependencies file '${dependenciesFile}' has been loaded (length ${dependenciesFileContent.length}).`);
            
            const issue = await github.rest.issues.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber
            });
            const issueTitle = issue.data.title;
            const issueDescription = issue.data.body;
            const issueComments = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber
            });
            const issueCommentsText = issueComments.data
              .map(comment => `Author:${comment.user.login}, Created:${comment.created_at}, Comment: ${comment.body}`)
              .join('\n');
            
            const prompt = `
            Does the combination source file, test file, README file and dependencies file show a solution with a reasonable likelihood of including a resolution to the following issue?
            Consider the following when refining your response:
            * Current feature names and specifications in the repository
            * Source file content
            * Test file content
            * README file content
            * MISSION file content
            * Contributing file content
            * Dependencies file content
            * Issue details
            * Dependency list
            * Build output
            * Test output
            * Main execution output
            
            Current feature names and specifications:
            CURRENT_FEATURES_START
            ${currentFeatures}
            CURRENT_FEATURES_END
            
            Source file: ${target}
            SOURCE_FILE_START
            ${sourceFileContent}
            SOURCE_FILE_END
            
            Test file: ${testFile}
            TEST_FILE_START
            ${testFileContent}
            TEST_FILE_END

            README file: ${readmeFile}
            README_FILE_START
            ${readmeFileContent}
            README_FILE_END
            
            MISSION file: ${missionFile}
            MISSION_FILE_START
            ${missionFileContent}
            MISSION_FILE_END

            Contributing file: ${contributingFile}
            CONTRIBUTING_FILE_START
            ${contributingFileContent}
            CONTRIBUTING_FILE_END
            
            Dependencies file: ${dependenciesFile}
            DEPENDENCIES_FILE_START
            ${dependenciesFileContent}
            DEPENDENCIES_FILE_END
            
            Issue:
            ISSUE_START
            title: ${issueTitle}
            description:
            ${issueDescription}
            comments:
            ${issueCommentsText}
            ISSUE_END            

            Dependencies list from command: npm list
            DEPENDENCIES_LIST_START
            ${dependenciesListOutput}
            DEPENDENCIES_LIST_END    
            
            Build output from command: ${buildScript}
            TEST_OUTPUT_START
            ${buildOutput}
            TEST_OUTPUT_END      
            
            Test output from command: ${testScript}
            TEST_OUTPUT_START
            ${testOutput}
            TEST_OUTPUT_END            

            Main output from command: ${mainScript}
            MAIN_OUTPUT_START
            ${mainOutput}
            MAIN_OUTPUT_END    
            
            Answer strictly with a JSON object following this schema:
            {
              "fixed": "true", // if the fix is present, or "false" otherwise.
              "message": "The issue has been resolved.", // if the fix is present, or an explanation otherwise.
              "refinement": "None" // if the fix is present, or a suggested refinement to resolve the issue otherwise.
            }
            Ensure valid JSON.
            `;
            
            const ResponseSchema = z.object({ fixed: z.string(), message: z.string(), refinement: z.string() });
            
            // Define the function schema for function calling
            const tools = [{
              type: "function",
              function: {
                name: "review_issue",
                description: "Evaluate whether the supplied source file content resolves the issue. Return an object with fixed (string: 'true' or 'false'), message (explanation), and refinement (suggested refinement).",
                parameters: {
                  type: "object",
                  properties: {
                    fixed: { type: "string", description: "true if the issue is resolved, false otherwise" },
                    message: { type: "string", description: "A message explaining the result" },
                    refinement: { type: "string", description: "A suggested refinement if the issue is not resolved" }
                  },
                  required: ["fixed", "message", "refinement"],
                  additionalProperties: false
                },
                strict: true
              }
            }];

            // Call OpenAI using function calling format
            const response = await openai.chat.completions.create({
              model,
              messages: [
                { role: "system", content: "You are evaluating whether an issue has been resolved in the supplied source code. Answer strictly with a JSON object following the provided function schema." },
                { role: "user", content: prompt }
              ],
              tools: tools
            });
            
            let result;
            if (response.choices[0].message.tool_calls && response.choices[0].message.tool_calls.length > 0) {
              try {
                result = JSON.parse(response.choices[0].message.tool_calls[0].function.arguments);
              } catch (e) {
                core.setFailed(`Failed to parse function call arguments: ${e.message}`);
              }
            } else if (response.choices[0].message.content) {
              try {
                result = JSON.parse(response.choices[0].message.content);
              } catch (e) {
                core.setFailed(`Failed to parse response content: ${e.message}`);
              }
            } else {
              core.setFailed("No valid response received from OpenAI.");
            }
            
            try {
              const parsed = ResponseSchema.parse(result);
              core.setOutput("fixed", parsed.fixed);
              core.setOutput("message", parsed.message);
              core.setOutput("refinement", parsed.refinement);
              core.info(`fixed: "${parsed.fixed}"`);
              core.info(`message: "${parsed.message}"`);
              core.info(`refinement: "${parsed.refinement}"`);
            
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber,
                body: parsed.message
              });
            
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber,
                body: parsed.refinement
              });
            } catch (e) {
              core.setFailed(`Failed to parse ChatGPT response: ${e.message}`);
            }
            
            core.setOutput("response", JSON.stringify(response));
            core.setOutput("usage", JSON.stringify(response.usage));
            core.info(`response: "${JSON.stringify(response)}"`);
            core.info(`usage: "${JSON.stringify(response.usage)}"`);
      - name: Close fixed issues
        if: steps.verify.outputs.fixed == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PERSONAL_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}
          script: |
            const issueNumber = parseInt("${{ env.issueNumber }}");
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber,
              body: "The issue has been automatically resolved and the fix has been merged."
            });
            await github.rest.issues.update({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber,
              state: "closed"
            });

    outputs:
      fixed: ${{ steps.verify.outputs.fixed }}
      message: ${{ steps.verify.outputs.message }}
      refinement: ${{ steps.verify.outputs.refinement }}
.github/workflows/update.yml
==== Content of .github/workflows/update.yml ====
# .github/workflows/update.yml
#
# This file is part of the example suite for `agentic-lib` see: https://github.com/xn-intenton-z2a/agentic-lib
# This file is licensed under the MIT License. For details, see LICENSE-MIT

name: Update
concurrency: agentic-lib-commit-main
run-name: "Update [${{ github.ref_name }}]"

on:
  repository_dispatch:
    types: [package-published]
  schedule:
    - cron: '30 7 */28 * *' # schedule-1
    #- cron: '30 7 */7 * *' # schedule-2
    #- cron: '30 7 * * *' # schedule-3
    #- cron: '30 7 * * *' # schedule-4

  workflow_dispatch:
    inputs:
      upgradeTarget:
        description: 'Select the type of update to run'
        type: choice
        default: 'minor'
        required: false
        options:
          - greatest
          - latest
          - newest
          - patch
          - minor
          - semver

jobs:

  check-branch:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write
    env:
      branchPrefix: 'agentic-lib-'
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.ref }}
      - name: Ensure there isn't already a branch for this prefix
        shell: bash
        run: |
          git fetch origin
          if git branch -r | grep -q 'origin/${{ env.branchPrefix }}'; then
            echo "A branch with the prefix '${{ env.branchPrefix }}' already exists."
            exit 1
          else
            echo "No existing branch with the prefix found."
          fi

  pom-check:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: mvn
        id: mvn
        shell: bash
        run: |
          if [ -f pom.xml ]; then
            pomXmlExists='true'
          else
            pomXmlExists='false'
          fi
          echo "pomXmlExists=${pomXmlExists?}" | tee -a "${GITHUB_OUTPUT?}"

      - uses: actions/setup-java@v4
        if: steps.mvn.outputs.pomXmlExists == 'true'
        with:
          distribution: 'corretto'
          java-version: 21
          cache: 'maven'
          server-password: PERSONAL_ACCESS_TOKEN
        env:
          GITHUB_ACTOR: ${{ github.actor }}
          PERSONAL_ACCESS_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}

      - name: package
        id: package
        if: steps.mvn.outputs.pomXmlExists == 'true'
        shell: bash
        run: ./mvnw validate
        env:
          GITHUB_ACTOR: ${{ github.actor }}
          PERSONAL_ACCESS_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}

    outputs:
      pomXmlExists: ${{ steps.mvn.outputs.pomXmlExists }}


  update-npm:
    needs:
      - check-branch
    permissions:
      contents: write
      pull-requests: write
      id-token: write
      packages: write
    uses: 'xn-intenton-z2a/agentic-lib/.github/workflows/wfr-npm-update.yml@main'
    with:
      buildScript: 'npm run build'
      testScript: 'npm test'
      mainScript: ${{ vars.MAIN_SCRIPT || 'npm run start' }}
      upgradeTarget: ${{ inputs.upgradeTarget || 'patch' }}
      branch: 'agentic-lib-update'
      npmAuthOrganisation: '@xn-intenton-z2a'
      gitUserEmail: 'action@github.com'
      gitUserName: 'GitHub Actions[bot]'
      gitCommitMessage: 'chore: dependency updates'
    secrets:
      PERSONAL_ACCESS_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}

  update-mvn:
    needs:
      - check-branch
      - update-npm
      - pom-check
    if: ${{ needs.update-npm.outputs.updatedFiles != 'true' && needs.pom-check.outputs.pomXmlExists == 'true' }}
    permissions:
      contents: write
      pull-requests: write
      id-token: write
      packages: write
    uses: 'xn-intenton-z2a/agentic-lib/.github/workflows/wfr-mvn-update.yml@main'
    with:
      buildScript: './mvnw clean install'
      testScript: './mvnw test'
      upgradeTarget: 'minor'
      branch: 'agentic-lib-update'
      gitUserEmail: 'action@github.com'
      gitUserName: 'GitHub Actions[bot]'
      gitCommitMessage: 'chore: dependency updates'
    secrets:
      PERSONAL_ACCESS_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}

  create-pr-npm:
    needs:
      - update-npm
    if: ${{ needs.update-npm.outputs.updatedFiles == 'true' }}
    permissions:
      contents: write
      packages: write
      issues: write
      pull-requests: write
      checks: write
      id-token: write
    uses: 'xn-intenton-z2a/agentic-lib/.github/workflows/wfr-github-create-pr.yml@main'
    with:
      branch: 'agentic-lib-update'
      baseBranch: 'main'
      gitCommitMessage: 'chore: dependency updates'
      label: 'automerge'

  create-pr-mvn:
    needs:
      - update-mvn
      - pom-check
    if: ${{ needs.update-mvn.outputs.updatedFiles == 'true' && needs.pom-check.outputs.pomXmlExists == 'true' }}
    permissions:
      contents: write
      packages: write
      issues: write
      pull-requests: write
      checks: write
      id-token: write
    uses: 'xn-intenton-z2a/agentic-lib/.github/workflows/wfr-github-create-pr.yml@main'
    with:
      branch: 'agentic-lib-update'
      baseBranch: 'main'
      gitCommitMessage: 'chore: dependency updates'
      label: 'automerge'

  select-issue:
    permissions:
      issues: read
      id-token: write
    uses: 'xn-intenton-z2a/agentic-lib/.github/workflows/wfr-github-select-issue.yml@main'
    with:
      issueNumber: ''
      selectionLabel: 'automated'
    secrets:
      CHATGPT_API_SECRET_KEY: ${{ secrets.CHATGPT_API_SECRET_KEY }}

  stats:
    needs:
      - select-issue
      - check-branch
      - create-pr-npm
      - create-pr-mvn
    if: ${{ always() }}
    permissions:
      contents: write
      id-token: write
      pages: write
    uses: 'xn-intenton-z2a/agentic-lib/.github/workflows/wfr-github-stats.yml@main'
    with:
      cache: 'npm'
      npmAuthOrganisation: '@xn-intenton-z2a'
      lastActivityName: ${{ github.workflow }}
      lastActivityBranchName: ${{ github.ref_name }}
      nextIssue: "[${{ needs.select-issue.outputs.issueNumber }}] ${{ needs.select-issue.outputs.issueTitle }} ${{ needs.select-issue.outputs.issueLabels }}"
      public: 'public'
      s3BucketUrl: 's3://agentic-lib-telemetry-bucket/events/'
      s3WebsiteBucketUrl: 's3://agentic-lib-public-website-stats-bucket/'
      iamActionsRoleArn: 'arn:aws:iam::541134664601:role/agentic-lib-github-actions-role'
      iamStatsBucketWriterRoleArn: 'arn:aws:iam::541134664601:role/agentic-lib-deployment-role'
      iamPublicWebsiteStatsBucketWriterRoleArn: 'arn:aws:iam::541134664601:role/agentic-lib-public-website-stats-bucket-writer-role'
    secrets:
      PERSONAL_ACCESS_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}
.github/workflows/wfr-npm-update.yml
==== Content of .github/workflows/wfr-npm-update.yml ====
# .github/workflows/wfr-npm-update.yml

#
# agentic-lib
# Copyright (C) 2025 Polycode Limited
#
# This file is part of agentic-lib.
#
# agentic-lib is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License v3.0 (GPL‑3).
# along with this program. If not, see <https://www.gnu.org/licenses/>.
#
# IMPORTANT: Any derived work must include the following attribution:
# "This work is derived from https://github.com/xn-intenton-z2a/agentic-lib"
#

name: ∞ update-npm

on:
  workflow_call:
    inputs:
      buildScript:
        description: 'The script must be runnable as: `npm ci ; <script>` and succeed with a zero exit code. e.g. `npm run build`'
        type: string
        required: false
        default: 'echo "No build script specified."'
      testScript:
        description: 'The script must be runnable as: `npm ci ; <script>` and succeed with a zero exit code. e.g. `npm test`'
        type: string
        required: false
        default: 'npm test'
      mainScript:
        description: 'The script must be runnable as: `npm ci ; <script>` and succeed with a zero exit code. e.g. `npm run start`'
        type: string
        required: false
        default: 'npm run start'
      upgradeTarget:
        description: 'The type of upgrade to perform. e.g. "minor"'
        type: string
        required: false
        default: 'minor'
      branch:
        description: 'The branch to push changes to. e.g. "agentic-lib-update"'
        type: string
        required: false
        default: 'agentic-lib-update'
      npmAuthOrganisation:
        description: 'The GitHub organisation to authenticate with for npm. e.g. "xn-intenton-z2a"'
        type: string
        required: false
        default: ''
      gitUserEmail:
        description: 'The email to use for git commits. e.g. "action@github.com"'
        type: string
        required: false
        default: 'action@github.com'
      gitUserName:
        description: 'The name to use for git commits. e.g. "GitHub Actions[bot]"'
        type: string
        required: false
        default: 'GitHub Actions[bot]'
      cache:
        description: 'The cache to use for npm. e.g. "npm"'
        type: string
        required: false
        default: 'npm'
      gitCommitMessage:
        description: 'The message to use for git commits. e.g. "chore: dependency updates"'
        type: string
        required: false
        default: 'chore: dependency updates'
    secrets:
      PERSONAL_ACCESS_TOKEN:
        required: false
    outputs:
      updatedFiles:
          description: 'Whether files were updated by the script. e.g. "true"'
          value: ${{ jobs.update.outputs.updatedFiles }}

jobs:
  update:
    runs-on: ubuntu-latest

    env:
      buildScript: ${{ inputs.buildScript || 'npm run build' }}
      testScript: ${{ inputs.testScript || 'npm test' }}
      mainScript: ${{ inputs.mainScript || 'npm run start' }}
      mainScriptTimeout: '5m'
      upgradeTarget: ${{ inputs.upgradeTarget || 'minor' }}
      branch: ${{ inputs.branch || 'agentic-lib-update' }}
      npmAuthOrganisation: ${{ inputs.npmAuthOrganisation || '' }}
      gitUserEmail: ${{ inputs.gitUserEmail || 'action@github.com' }}
      gitUserName: ${{ inputs.gitUserName || 'GitHub Actions[bot]' }}
      cache: ${{ inputs.cache || 'npm' }}
      gitCommitMessage: |
        ${{ inputs.gitCommitMessage || 'chore: dependency updates' }}

    steps:

      - name: Log which version
        if: ${{ github.event.client_payload }}
        shell: bash
        run: |
          echo "Package: ${{ github.event.client_payload.packageName }}"

      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: ${{ env.cache }}

      - name: Check GitHub authentication
        if: ${{ env.npmAuthOrganisation != '' }}
        shell: bash
        run: |
          curl --include --header "Authorization: token ${{ secrets.PERSONAL_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}" https://api.github.com/user

      - name: Set up .npmrc
        if: ${{ env.npmAuthOrganisation != '' }}
        shell: bash
        run: |
          echo "${{ env.npmAuthOrganisation }}:registry=https://npm.pkg.github.com" >> .npmrc
          echo "//npm.pkg.github.com/:_authToken=${{ secrets.PERSONAL_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}" >> .npmrc
          echo "always-auth=true" >> .npmrc

      - name: Get latest from remote
        run: |
          git config --local user.email "${{ env.gitUserEmail }}"
          git config --local user.name "${{ env.gitUserName }}"
          git pull --ff-only origin ${{ github.ref }}

      - run: rm -f package-lock.json

      - run: npm install

      - name: Build project
        id: build
        shell: bash
        run: |
          output=$(${{ env.buildScript }} 2>&1)
          echo "output<<EOF" >> "$GITHUB_OUTPUT"
          echo "$output" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          echo "output=${output}"

      - name: Run tests before update
        id: test
        shell: bash
        run: |
          output=$(${{ env.testScript }} 2>&1)
          echo "output<<EOF" >> "$GITHUB_OUTPUT"
          echo "$output" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          echo "output=${output}"

      - name: Run main before update
        id: main
        shell: bash
        run: |
          output=$(timeout ${{ env.mainScriptTimeout }} ${{ env.mainScript }} 2>&1)
          echo "output<<EOF" >> "$GITHUB_OUTPUT"
          echo "$output" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          echo "output=${output}"

      - name: Update packages with npm
        continue-on-error: true
        shell: bash
        env:
          ncuUpgradeTarget: ${{ env.upgradeTarget || 'minor' }}
        run: npm install --save ; npm update ; npm upgrade ; npm install

      - name: Update packages with ncu
        continue-on-error: true
        shell: bash
        env:
          ncuUpgradeTarget: ${{ env.upgradeTarget || 'minor' }}
        run: npx ncu --upgrade --enginesNode --retry 3 --target ${{ env.ncuUpgradeTarget }} --verbose ; npm install ; npm update ; npm upgrade ; npm install

      - name: git-diff
        id: git-diff
        shell: bash
        run: |
          savedOptions=$(set +o) \
          && set +e \
          ; if git diff --quiet; then
            echo "updated=false" | tee -a "${GITHUB_OUTPUT?}"
          else
            echo "updated=true" | tee -a "${GITHUB_OUTPUT?}"
          fi \
          ; eval "${savedOptions?}" \
          ;
        continue-on-error: true

      - run: rm -rf './node_modules/'

      - run: npm ci
        
      - name: Tear down .npmrc
        if: ${{ env.npmAuthOrganisation != '' }}
        shell: bash
        run: rm -f .npmrc

      - name: Run tests after update
        shell: bash
        run: |
          output=$(${{ env.testScript }} 2>&1)
          echo "output<<EOF" >> "$GITHUB_OUTPUT"
          echo "$output" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          echo "output=${output}"

      - name: Run main after update
        shell: bash
        run: |
          output=$(timeout ${{ env.mainScriptTimeout }} ${{ env.mainScript }} 2>&1)
          echo "output<<EOF" >> "$GITHUB_OUTPUT"
          echo "$output" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          echo "output=${output}"  

      - name: Commit
        if: ${{ steps.git-diff.outputs.updated == 'true' || env.git-force == 'true' }}
        shell: bash
        run: |
          git config --local user.email '${{ env.gitUserEmail }}'
          git config --local user.name '${{ env.gitUserName }}'
          git status -v
          git switch -c '${{ env.branch }}'
          git add -v --all
          git commit -v -m '${{ env.gitCommitMessage }}'
          #git pull --rebase --set-upstream origin '${{ env.branch }}'
          git pull --rebase origin main
          git push --set-upstream origin '${{ env.branch }}'
          git push -v
          git status -v

    outputs:
      updatedFiles: ${{ steps.git-diff.outputs.updated || '' }}
.github/workflows/library-worker.yml
==== Content of .github/workflows/library-worker.yml ====
# .github/workflows/library-worker.yml
#
# This file is part of the example suite for `agentic-lib` see: https://github.com/xn-intenton-z2a/agentic-lib
# This file is licensed under the MIT License. For details, see LICENSE-MIT

name: Library Worker
concurrency: library-worker
run-name: "Library Worker"

on:
  workflow_dispatch:
    inputs:
      document:
        description: 'Text to drive the library maintenance (if "house choice", the repository will be assessed and an action chosen). e.g. "Get a document about agents."'
        required: false
        type: string
        default: 'house choice'
  schedule:
    - cron: '50 11 */7 * *' # schedule-1
    #- cron: '50 */4 * * *' # schedule-2
    #- cron: '50 */1 * * *' # schedule-3
    #- cron: '*/10 * * * *' # schedule-4

jobs:

  agentic-lib:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: agentic-lib
        id: agentic-lib
        shell: bash
        run: |
          if [ -f ".github/agentic-lib.yml" ]; then
            documentsLimit=$(grep '^documentsLimit:' .github/agentic-lib.yml | awk '{print $2}')
            if [ -z "$documentsLimit" ]; then
              documentsLimit="3"
              echo "Warning: documentsLimit not found in .github/agentic-lib.yml, using default value: ${documentsLimit}"
            fi
          else
            documentsLimit="3"
            echo "Warning: .github/agentic-lib.yml file not found, using default documentsLimit: ${documentsLimit}"
          fi
          echo "documentsLimit=${documentsLimit}"
          echo "documentsLimit=${documentsLimit}" >> $GITHUB_OUTPUT
    outputs:
      documentsLimit: ${{ steps.agentic-lib.outputs.documentsLimit }}

  # If the document is "house choice", the repository will be assessed and an action chosen otherwise the supplied text will be used to generate a new document.
  maintain-library:
    needs:
      - agentic-lib
    permissions:
      contents: write
      issues: write
      id-token: write
    uses: 'xn-intenton-z2a/agentic-lib/.github/workflows/wfr-completion-maintain-library.yml@main'
    with:
      document: ${{ inputs.document }}
      libraryDir: 'library/'
      sourcesFile: 'SOURCES.md'
      documentsLimit: '${{ needs.agentic-lib.outputs.documentsLimit }}'
      target: ${{ inputs.target || 'src/lib/main.js' }}
      testFile: ${{ inputs.testFile || 'tests/unit/main.test.js' }}
      readmeFile: 'README.md'
      missionFile: 'MISSION.md'
      contributingFile: 'CONTRIBUTING.md'
      dependenciesFile: 'package.json'
      buildScript: 'npm run build'
      testScript: 'npm test'
      mainScript: ${{ vars.MAIN_SCRIPT || 'npm run start' }}
      model: ${{ vars.CHATGPT_API_MODEL || 'o3-mini' }}
      npmAuthOrganisation: '@xn-intenton-z2a'
      gitUserEmail: 'action@github.com'
      gitUserName: 'GitHub Actions[bot]'
    secrets:
      CHATGPT_API_SECRET_KEY: ${{ secrets.CHATGPT_API_SECRET_KEY }}
      PERSONAL_ACCESS_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}

  select-issue:
    permissions:
      issues: read
      id-token: write
    uses: 'xn-intenton-z2a/agentic-lib/.github/workflows/wfr-github-select-issue.yml@main'
    with:
      issueNumber: ''
      selectionLabel: 'automated'
    secrets:
      CHATGPT_API_SECRET_KEY: ${{ secrets.CHATGPT_API_SECRET_KEY }}

  stats:
    needs:
      - select-issue
      - maintain-library
    if: ${{ always() }}
    permissions:
      contents: write
      id-token: write
      pages: write
    uses: 'xn-intenton-z2a/agentic-lib/.github/workflows/wfr-github-stats.yml@main'
    with:
      cache: 'npm'
      npmAuthOrganisation: '@xn-intenton-z2a'
      lastActivityName: ${{ github.workflow }}
      lastActivityBranchName: ${{ github.ref_name }}
      nextIssue: "[${{ needs.select-issue.outputs.issueNumber }}] ${{ needs.select-issue.outputs.issueTitle }} ${{ needs.select-issue.outputs.issueLabels }}"
      public: 'public'
      s3BucketUrl: 's3://agentic-lib-telemetry-bucket/events/'
      s3WebsiteBucketUrl: 's3://agentic-lib-public-website-stats-bucket/'
      iamActionsRoleArn: 'arn:aws:iam::541134664601:role/agentic-lib-github-actions-role'
      iamStatsBucketWriterRoleArn: 'arn:aws:iam::541134664601:role/agentic-lib-deployment-role'
      iamPublicWebsiteStatsBucketWriterRoleArn: 'arn:aws:iam::541134664601:role/agentic-lib-public-website-stats-bucket-writer-role'
    secrets:
      PERSONAL_ACCESS_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}
.github/workflows/issue-reviewer.yml
==== Content of .github/workflows/issue-reviewer.yml ====
# .github/workflows/issue-reviewer.yml
#
# This file is part of the example suite for `agentic-lib` see: https://github.com/xn-intenton-z2a/agentic-lib
# This file is licensed under the MIT License. For details, see LICENSE-MIT

name: Review Issue
run-name: "Review Issue [${{ github.ref_name }}]"

on:
  workflow_dispatch:
    inputs:
      issueNumber:
        description: 'The issue number to review. If not provided, the workflow will select one based on label. e.g. "123"'
        required: false
        type: string
        default: ''
      selectionLabel:
        description: 'Label used to filter issues for review. e.g. "merged"'
        required: false
        type: string
        default: 'merged'
      target:
        description: 'The source file whose content was used in the resolution prompt. e.g. "src/lib/main.js"'
        required: false
        type: string
        default: 'src/lib/main.js'
      testFile:
        description: 'The test file to run to validate the resolution. e.g. "tests/unit/main.test.js"'
        required: false
        type: string
        default: 'tests/unit/main.test.js'
  #workflow_run:
  #  workflows:
  #    - "Automerge"
  #  types:
  #    - completed
  schedule:
    - cron: '20 */12 * * *' # schedule-1
    #- cron: '20 */4 * * *' # schedule-2
    #- cron: '5,20,45,50 */1 * * *' # schedule-3
    #- cron: '5,20,45,50 */1 * * *' # schedule-4

jobs:

  select-issue:
    permissions:
      issues: read
      id-token: write
    uses: 'xn-intenton-z2a/agentic-lib/.github/workflows/wfr-github-select-issue.yml@main'
    with:
      issueNumber: ${{ inputs.issueNumber || '' }}
      selectionLabel: ${{ inputs.selectionLabel || 'merged' }}
    secrets:
      CHATGPT_API_SECRET_KEY: ${{ secrets.CHATGPT_API_SECRET_KEY }}

  review-issue:
    needs:
      - select-issue
    if: ${{ needs.select-issue.outputs.issueNumber != '' && needs.select-issue.outputs.merged == 'true' }}
    permissions:
      contents: write
      issues: write
      id-token: write
    uses: 'xn-intenton-z2a/agentic-lib/.github/workflows/wfr-completion-review-issue.yml@main'
    with:
      issueNumber: ${{ needs.select-issue.outputs.issueNumber }}
      target: ${{ inputs.target || 'src/lib/main.js' }}
      missionFile: 'MISSION.md'
      testFile: ${{ inputs.testFile || 'tests/unit/main.test.js' }}
      readmeFile: 'README.md'
      contributingFile: 'CONTRIBUTING.md'
      dependenciesFile: 'package.json'
      buildScript: 'npm run build'
      testScript: 'npm test'
      mainScript: ${{ vars.MAIN_SCRIPT || 'npm run start' }}
      model: ${{ vars.CHATGPT_API_MODEL || 'o3-mini' }}
    secrets:
      CHATGPT_API_SECRET_KEY: ${{ secrets.CHATGPT_API_SECRET_KEY }}

  select-next-issue:
    permissions:
      issues: read
      id-token: write
    uses: 'xn-intenton-z2a/agentic-lib/.github/workflows/wfr-github-select-issue.yml@main'
    with:
      issueNumber: ''
      selectionLabel: 'automated'
    secrets:
      CHATGPT_API_SECRET_KEY: ${{ secrets.CHATGPT_API_SECRET_KEY }}

  stats:
    needs:
      - select-next-issue
      - review-issue
    if: ${{ always() }}
    permissions:
      contents: write
      id-token: write
      pages: write
    uses: 'xn-intenton-z2a/agentic-lib/.github/workflows/wfr-github-stats.yml@main'
    with:
      cache: 'npm'
      npmAuthOrganisation: '@xn-intenton-z2a'
      lastActivityName: ${{ github.workflow }}
      lastActivityBranchName: ${{ github.ref_name }}
      nextIssue: "[${{ needs.select-next-issue.outputs.issueNumber }}] ${{ needs.select-next-issue.outputs.issueTitle }} ${{ needs.select-next-issue.outputs.issueLabels }}"
      public: 'public'
      s3BucketUrl: 's3://agentic-lib-telemetry-bucket/events/'
      s3WebsiteBucketUrl: 's3://agentic-lib-public-website-stats-bucket/'
      iamActionsRoleArn: 'arn:aws:iam::541134664601:role/agentic-lib-github-actions-role'
      iamStatsBucketWriterRoleArn: 'arn:aws:iam::541134664601:role/agentic-lib-deployment-role'
      iamPublicWebsiteStatsBucketWriterRoleArn: 'arn:aws:iam::541134664601:role/agentic-lib-public-website-stats-bucket-writer-role'
    secrets:
      PERSONAL_ACCESS_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}
.github/workflows/wfr-github-delete-caches.yml
==== Content of .github/workflows/wfr-github-delete-caches.yml ====
# .github/workflows/wfr-github-delete-caches.yml

#
# agentic-lib
# Copyright (C) 2025 Polycode Limited
#
# This file is part of agentic-lib.
#
# agentic-lib is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License v3.0 (GPL‑3).
# along with this program. If not, see <https://www.gnu.org/licenses/>.
#
# IMPORTANT: Any derived work must include the following attribution:
# "This work is derived from https://github.com/xn-intenton-z2a/agentic-lib"
#

name: ∞ delete-caches

on:
  workflow_call:
    inputs:
      deleteAllCaches:
        description: 'Whether to delete all caches. e.g. "true"'
        type: string
        required: false
        default: 'false'
      s3BucketUrl:
        description: 'The S3 bucket URL with prefix to use. e.g. "s3://my-bucket/prefix"'
        type: string
        required: false
        default: ''
      iamRoleArn:
        description: 'The ARN of the IAM role to assume. e.g. "arn:aws:iam::123456789012:role/my-role"'
        type: string
        required: false
        default: ''
    secrets:
      PERSONAL_ACCESS_TOKEN:
        required: false

jobs:
  update:
    runs-on: ubuntu-latest

    env:
      deleteAllCaches: ${{ inputs.deleteAllCaches || 'false' }}
      s3BucketUrl: ${{ inputs.s3BucketUrl || '' }}
      iamRoleArn: ${{ inputs.iamRoleArn || '' }}

    steps:
      - name: Delete all GitHub Actions caches by iterating through each one to delete it
        if: ${{ env.deleteAllCaches }}
        run: |
          echo "Listing all caches in the repository for ${{ github.repository }}"
          # 1) List all caches in JSON
          result=$(curl -s \
            -H "Authorization: token ${{ secrets.PERSONAL_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}" \
            -H "Accept: application/vnd.github+json" \
            "https://api.github.com/repos/${{ github.repository }}/actions/caches")
          
          # Print the JSON for debugging
          echo "$result" | jq .
          
          # 2) Determine how many total_count
          total=$(echo "$result" | jq -r '.total_count')
          echo "Found $total caches in total."
          
          # 3) For each item in actions_caches array, extract .key and .ref,
          #    then call DELETE with "?key=...&ref=..."
          echo "$result" | jq -c '.actions_caches[]' | while read -r row; do
            key=$(echo "$row" | jq -r '.key')
            ref=$(echo "$row" | jq -r '.ref')
          
            echo "Deleting cache with key='$key' ref='$ref' ..."
            curl -s -X DELETE \
              -H "Authorization: token ${{ secrets.PERSONAL_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}" \
              -H "Accept: application/vnd.github+json" \
              "https://api.github.com/repos/${{ github.repository }}/actions/caches?key=$key&ref=$ref"
          done
          
          echo "Cache deletion iteration complete."

.github/workflows/wfr-github-merge-pr.yml
==== Content of .github/workflows/wfr-github-merge-pr.yml ====
# .github/workflows/wfr-github-merge-pr.yml

#
# agentic-lib
# Copyright (C) 2025 Polycode Limited
#
# This file is part of agentic-lib.
#
# agentic-lib is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License v3.0 (GPL‑3).
# along with this program. If not, see <https://www.gnu.org/licenses/>.
#
# IMPORTANT: Any derived work must include the following attribution:
# "This work is derived from https://github.com/xn-intenton-z2a/agentic-lib"
#

name: ∞ automerge-merge-pr

on:
  workflow_call:
    inputs:
      pullNumber:
        description: 'The pull request number. e.g. "123"'
        type: string
        required: true
      cache:
        description: 'The cache to use for npm. e.g. "npm"'
        type: string
        required: false
        default: 'npm'
      s3BucketUrl:
        description: 'The S3 bucket URL with prefix to use. e.g. "s3://my-bucket/prefix"'
        type: string
        required: false
        default: ''
      iamRoleArn:
        description: 'The ARN of the IAM role to assume. e.g. "arn:aws:iam::123456789012:role/my-role"'
        type: string
        required: false
        default: ''
    secrets:
      PERSONAL_ACCESS_TOKEN:
        required: false
    outputs:
      prMerged:
        description: 'Set to "true", if the PR has been merged either already or by this process.'
        value: ${{ jobs.merge-pr.outputs.prMerged }}

jobs:
  merge-pr:
    runs-on: ubuntu-latest

    env:
      cache: ${{ inputs.cache || 'npm' }}
      s3BucketUrl: ${{ inputs.s3BucketUrl || '' }}
      iamRoleArn: ${{ inputs.iamRoleArn || '' }}

    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ github.ref }}
          fetch-depth: 0

      - uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: ${{ env.cache }}

      - name: Set up .npmrc
        shell: bash
        run: |
          echo "${{ env.npmAuthOrganisation }}:registry=https://npm.pkg.github.com" >> .npmrc
          echo "//npm.pkg.github.com/:_authToken=${{ secrets.PERSONAL_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}" >> .npmrc
          echo "always-auth=true" >> .npmrc

      - name: trigger-checks
        id: trigger-checks
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PERSONAL_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}
          script: |
            const pullNumber = parseInt('${{ inputs.pullNumber }}', 10);
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            
            // Get the latest PR information
            const { data: pullRequest } = await github.rest.pulls.get({
              owner,
              repo,
              pull_number: pullNumber,
            });
            core.info(`Found pull request #${pullRequest.number} with state: ${pullRequest.state} and mergeable state: ${pullRequest.mergeable_state}`);
            core.info(`PR: ${JSON.stringify(pullRequest)}`);
            
            let mergeable = pullRequest.mergeable;
            if (pullRequest.state === "closed") { 
              core.info(`PR #${pullNumber} is already closed.`);
            } else if (mergeable === null) {
              core.info(`PR #${pullNumber} does not yet have a value for mergeability, triggering checks.`);
              const ref = pullRequest.head.sha;
              const { data: checkSuites } = await github.rest.checks.listSuitesForRef({
                owner,
                repo,
                ref
              });
              core.info(`PR check suites: ${JSON.stringify(checkSuites)}`);
              for (const suite of checkSuites.check_suites) {
                try{ 
                  await github.rest.checks.rerequestSuite({
                    owner,
                    repo,
                    check_suite_id: suite.id
                  });
                } catch (error) {
                  core.info(`Failed to trigger check suite for PR #${pullNumber}: ${error.message}`);
                  core.info(`${JSON.stringify(error)}`);
                }
              }
            } else {
              core.info(`PR #${pullNumber} is in mergeable state ${mergeable}.`);
            }
            
            core.setOutput('mergeable', mergeable);
            core.info(`mergeable: '${mergeable}'`);

      - name: Wait for 5 seconds
        run: sleep 5

      - name: auto-merge-pr
        id: auto-merge-pr
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PERSONAL_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}
          script: |
            const pullNumber = parseInt('${{ inputs.pullNumber }}', 10);
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            let prMerged;
          
            // Get the latest PR information
            const { data: pullRequest } = await github.rest.pulls.get({
              owner,
              repo,
              pull_number: pullNumber,
            });
            core.info(`Found pull request #${pullRequest.number} with state: ${pullRequest.state} and mergeable state: ${pullRequest.mergeable_state}`);
          
            if (pullRequest.state === "closed") { 
              core.info(`PR #${pullNumber} is already closed.`);
              if (pullRequest.merged) {
                core.info(`PR #${pullNumber} is closed and merged.`);
                prMerged = 'true';
              } else {
                core.info(`PR #${pullNumber} is closed but not merged.`);
                prMerged = 'false';
              }
            } else if (pullRequest.mergeable && pullRequest.mergeable_state === 'clean') {
              // If the PR is mergeable (clean), proceed with merging
              await github.rest.pulls.merge({
                owner,
                repo,
                pull_number: pullNumber,
                merge_method: 'squash',
              });
              core.info(`PR #${pullNumber} merged successfully.`);
              const branchRef = `heads/${pullRequest.head.ref}`;
              await github.rest.git.deleteRef({
                owner,
                repo,
                ref: branchRef,
              });
              core.info(`Branch '${pullRequest.head.ref}' deleted.`);
              prMerged = 'true';
            } else if (pullRequest.mergeable_state === 'dirty' || pullRequest.mergeable === false) {
              // PR has conflicts or failing tests – close the PR and delete the branch
              core.info(`PR #${pullNumber} has conflicts. Commenting on the PR and closing it.`);
              await github.rest.issues.createComment({
                  owner,
                  repo,
                  issue_number: pullNumber,
                  body: `This pull request is being closed due to conflicts (mergeable_state: ${pullRequest.mergeable_state}, mergeable: ${pullRequest.mergeable}).`,
                });
              await github.rest.pulls.update({
                owner,
                repo,
                pull_number: pullNumber,
                state: "closed",
              });
              const branchRef = `heads/${pullRequest.head.ref}`;
              try {
                await github.rest.git.deleteRef({
                  owner,
                  repo,
                  ref: branchRef,
                });
                core.info(`Branch '${pullRequest.head.ref}' deleted.`);
              } catch (error) {
                core.warning(`Failed to delete branch '${pullRequest.head.ref}': ${error.message}`);
              }
              prMerged = 'false';
            } else if (pullRequest.mergeable === null) {
              core.info(`PR #${pullNumber} does not yet have a value for mergeability.`);
              prMerged = 'false';
            } else {
              core.info(`PR #${pullNumber} is in an unexpected state.`);
              prMerged = 'false';
            }
          
            core.setOutput('prMerged', prMerged);
            core.info(`prMerged: '${prMerged}'`);

    outputs:
      prMerged: ${{ steps.auto-merge-pr.outputs.prMerged }}

.github/workflows/wfr-completion-generate-maintenance-issue.yml
==== Content of .github/workflows/wfr-completion-generate-maintenance-issue.yml ====
# .github/workflows/wfr-completion-generate-maintenance-issue.yml

#
# agentic-lib
# Copyright (C) 2025 Polycode Limited
#
# This file is part of agentic-lib.
#
# agentic-lib is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License v3.0 (GPL‑3).
# along with this program. If not, see <https://www.gnu.org/licenses/>.
#
# IMPORTANT: Any derived work must include the following attribution:
# "This work is derived from https://github.com/xn-intenton-z2a/agentic-lib"
#

name: ∞ generate-maintenance-issue

on:
  workflow_call:
    inputs:
      prompt:
        description: 'The prompt to guide the issue creation. e.g. "Make an improvement to tests."'
        type: string
        required: true
      featuresDir:
        description: 'The directory to create/update the features in. e.g. "features/"'
        type: string
        required: false
        default: 'features/'
      maintenanceIssuesWipLimit:
        description: 'The WIP limit for maintenance issues. e.g. "5"'
        type: string
        required: false
        default: '5'
      target:
        description: 'The target file to create the issue to change. e.g. "src/lib/main.js"'
        type: string
        required: false
        default: 'src/lib/main.js'
      testFile:
        description: 'The test file. e.g. "tests/unit/main.test.js"'
        type: string
        required: false
        default: 'tests/unit/main.test.js'
      readmeFile:
        description: 'The README file. e.g. "README.md"'
        type: string
        required: false
        default: 'README.md'
      missionFile:
        description: 'The MISSION statement file. e.g. "MISSION.md"'
        type: string
        required: false
        default: 'MISSION.md'
      contributingFile:
        description: 'The CONTRIBUTING file. e.g. "CONTRIBUTING.md"'
        type: string
        required: false
        default: 'CONTRIBUTING.md'
      dependenciesFile:
        description: 'The dependencies file. e.g. "package.json"'
        type: string
        required: false
        default: 'package.json'
      buildScript:
        description: 'The script must be runnable as: `npm ci ; <script>` and succeed with a zero exit code. e.g. `npm run build`'
        type: string
        required: false
        default: 'echo "No build script specified."'
      testScript:
        description: 'The script must be runnable as: `npm ci ; <script>` and succeed with a zero exit code. e.g. `npm test`'
        type: string
        required: false
        default: 'npm test'
      mainScript:
        description: 'The script must be runnable as: `npm ci ; <script>` and succeed with a zero exit code. e.g. `npm run start`'
        type: string
        required: false
        default: 'npm run start'
      issueSelectionLabel:
        description: 'Label used to filter issues for review. e.g. "maintenance"'
        required: false
        type: string
        default: 'maintenance'
      model:
        description: 'The OpenAI model to use. e.g. "o3-mini"'
        type: string
        required: false
        default: ${{ vars.CHATGPT_API_MODEL || 'o3-mini' }}
      npmAuthOrganisation:
        description: 'The GitHub organisation to authenticate with for npm. e.g. "xn-intenton-z2a"'
        type: string
        required: false
        default: ''
      s3BucketUrl:
        description: 'The S3 bucket URL with prefix to use. e.g. "s3://my-bucket/prefix"'
        type: string
        required: false
        default: ''
      iamRoleArn:
        description: 'The ARN of the IAM role to assume. e.g. "arn:aws:iam::123456789012:role/my-role"'
        type: string
        required: false
        default: ''
    secrets:
      PERSONAL_ACCESS_TOKEN:
        required: false
      CHATGPT_API_SECRET_KEY:
        required: true
    outputs:
      issueTitle:
        value: ${{ jobs.generate-maintenance-issue.outputs.issueTitle }}
      issueDescription:
        value: ${{ jobs.generate-maintenance-issue.outputs.issueDescription }}

jobs:
  generate-maintenance-issue:
    runs-on: ubuntu-latest

    env:
      prompt: ${{ inputs.prompt || '' }}
      featuresDir: ${{ inputs.featuresDir || 'features/' }}
      maintenanceIssuesWipLimit: ${{ inputs.maintenanceIssuesWipLimit || '5' }}
      target: ${{ inputs.target || 'src/lib/main.js' }}
      testFile: ${{ inputs.testFile || 'tests/unit/main.test.js' }}
      readmeFile: ${{ inputs.readmeFile || 'README.md' }}
      missionFile: ${{ inputs.missionFile || 'MISSION.md' }}
      contributingFile: ${{ inputs.contributingFile || 'CONTRIBUTING.md' }}
      dependenciesFile: ${{ inputs.dependenciesFile || 'package.json' }}
      buildScript: ${{ inputs.buildScript || 'npm run build' }}
      testScript: ${{ inputs.testScript || 'npm test' }}
      issueSelectionLabel: ${{ inputs.issueSelectionLabel || 'maintenance' }}
      mainScript: ${{ inputs.mainScript || 'npm run start' }}
      mainScriptTimeout: '5m'
      model: ${{ inputs.model || vars.CHATGPT_API_MODEL || 'o3-mini' }}
      npmAuthOrganisation: ${{ inputs.npmAuthOrganisation || '' }}
      chatgptApiSecretKey: ${{ secrets.CHATGPT_API_SECRET_KEY }}
      s3BucketUrl: ${{ inputs.s3BucketUrl || '' }}
      iamRoleArn: ${{ inputs.iamRoleArn || '' }}

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Check GitHub authentication
        if: ${{ env.npmAuthOrganisation != '' }}
        shell: bash
        run: |
          curl --include --header "Authorization: token ${{ secrets.PERSONAL_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}" https://api.github.com/user

      - name: Set up .npmrc
        if: ${{ env.npmAuthOrganisation != '' }}
        shell: bash
        run: |
          echo "${{ env.npmAuthOrganisation }}:registry=https://npm.pkg.github.com" >> .npmrc
          echo "//npm.pkg.github.com/:_authToken=${{ secrets.PERSONAL_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}" >> .npmrc
          echo "always-auth=true" >> .npmrc

      - run: npm ci

      - name: List current features
        id: features
        shell: bash
        run: |
          output=$(find "${{ env.featuresDir }}" -maxdepth 1 -type f -name '*.md' -print -exec echo "# {}" \; -exec cat {} \; 2>&1 || echo 'none')
          echo "output<<EOF" >> "$GITHUB_OUTPUT"
          echo "$output" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          echo "output=${output}"

      - name: List dependencies
        id: list
        shell: bash
        run: |
          output=$(npm list 2>&1)
          echo "output<<EOF" >> "$GITHUB_OUTPUT"
          echo "$output" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          echo "output=${output}"

      - name: Build project
        id: build
        shell: bash
        run: |
          output=$(${{ env.buildScript }} 2>&1)
          echo "output<<EOF" >> "$GITHUB_OUTPUT"
          echo "$output" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          echo "output=${output}"

      - name: Tear down .npmrc
        if: ${{ env.npmAuthOrganisation != '' }}
        shell: bash
        run: rm -f .npmrc

      - name: Run tests
        id: test
        shell: bash
        run: |
          output=$(${{ env.testScript }} 2>&1)
          echo "output<<EOF" >> "$GITHUB_OUTPUT"
          echo "$output" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          echo "output=${output}"

      - name: Run main
        id: main
        shell: bash
        run: |
          output=$(timeout ${{ env.mainScriptTimeout }} ${{ env.mainScript }} 2>&1)
          echo "output<<EOF" >> "$GITHUB_OUTPUT"
          echo "$output" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          echo "output=${output}"

      - name: generate-maintenance-issue
        id: generate-maintenance-issue
        uses: actions/github-script@v7
        env:
          dependenciesListOutput: ${{ steps.list.outputs.output }}
          buildOutput: ${{ steps.build.outputs.output }}
          testOutput: ${{ steps.test.outputs.output }}
          mainOutput: ${{ steps.main.outputs.output }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const currentFeatures = process.env.currentFeatures;
            const maintenanceIssuesWipLimit = process.env.maintenanceIssuesWipLimit;
            const target = process.env.target;
            const testFile = process.env.testFile;
            const readmeFile = process.env.readmeFile;
            const missionFile = process.env.missionFile;
            const contributingFile = process.env.contributingFile;
            const dependenciesFile = process.env.dependenciesFile;
            const model = process.env.model;
            const apiKey = process.env.chatgptApiSecretKey;
            const prompt = parseInt(process.env.prompt);
            const dependenciesListOutput = process.env.dependenciesListOutput;
            const buildScript = process.env.buildScript;
            const buildOutput = process.env.buildOutput;
            const testScript = process.env.testScript;
            const testOutput = process.env.testOutput;
            const mainScript = process.env.mainScript;
            const mainOutput = process.env.mainOutput;
            const issueSelectionLabel = process.env.issueSelectionLabel;
            
            const fs = require('fs');
            const OpenAI = require('openai').default;
            const { z } = require('zod');
            require('dotenv').config();

            // Gather the titles of all open issues
            const openIssues = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              labels: issueSelectionLabel
            });
            core.info(`Open issues: ${JSON.stringify(openIssues)}`);
            const openIssueTitles = openIssues.data.map(issue => issue.title).join(', ');
            core.info(`Open issue titles: ${openIssueTitles}`);
            if (openIssues.data.length >= maintenanceIssuesWipLimit) {
              core.setFailed(`There are already ${maintenanceIssuesWipLimit} open issues with the label '${issueSelectionLabel}'.`);
            }
  
            if (!apiKey) { 
              core.setFailed("Missing CHATGPT_API_SECRET_KEY"); 
            }
            const openai = new OpenAI({ apiKey });

            core.info(`currentFeatures: "${currentFeatures}"`);
            core.info(`maintenanceIssuesWipLimit: "${maintenanceIssuesWipLimit}"`);
            core.info(`target: "${target}"`);
            core.info(`testFile: "${testFile}"`);
            core.info(`readmeFile: "${readmeFile}"`);
            core.info(`missionFile: "${missionFile}"`);
            core.info(`contributingFile: "${contributingFile}"`);
            core.info(`dependenciesFile: "${dependenciesFile}"`);
            const sourceFileContent = fs.readFileSync(target, 'utf8');
            const testFileContent = fs.readFileSync(testFile, 'utf8');
            const readmeFileContent = fs.readFileSync(readmeFile, 'utf8');
            const missionFileContent = fs.readFileSync(missionFile, 'utf8');
            const contributingFileContent = fs.readFileSync(contributingFile, 'utf8');
            const dependenciesFileContent = fs.readFileSync(dependenciesFile, 'utf8');
            core.info(`Target file '${target}' has been loaded (length ${sourceFileContent.length}).`);
            core.info(`Test file '${testFile}' has been loaded (length ${testFileContent.length}).`);
            core.info(`Readme file '${readmeFile}' has been loaded (length ${readmeFileContent.length}).`);
            core.info(`Dependencies file '${dependenciesFile}' has been loaded (length ${dependenciesFileContent.length}).`);
            
            const chatGptPrompt = `
            Please generate the title and description of a GitHub issue to which will be used to action the supplied prompt.
            You may only give instructions in the issues to only change the source file, test file, README file and dependencies file content. You may not create issues that request new files, delete existing files, or change the other files provided in the prompt context.
            The issue will be resolved by an LLM which can process over 200,000 tokens of context and it will provide completed source files in the response.
            Do not include steps that would need to be taken manually by a human and expect to "dry-run" without an execution environment.
            The maximum number of maintenance issues that should be open at any one time is ${maintenanceIssuesWipLimit}, if there are already ${maintenanceIssuesWipLimit} open issues fail this request.
            Do not add valueless layers of validation, configuration, and abstraction. In particular do not create issues related to NaNs.
            Ensure that the issue is distinct from any existing open issues in the repository so that the new issue remains valid when the other open issues are closed.
            Consider the following when refining your response:
            * Prompt details
            * Current feature names and specifications in the repository
            * Source file content
            * Test file content
            * README file content
            * MISSION file content
            * Contributing file content
            * Dependencies file content
            * Dependency list
            * Build output
            * Test output
            * Main execution output
            * Open issue titles
            
            Current feature names and specifications:
            CURRENT_FEATURES_START
            ${currentFeatures}
            CURRENT_FEATURES_END
            
            Source file: ${target}
            SOURCE_FILE_START
            ${sourceFileContent}
            SOURCE_FILE_END
            
            Test file: ${testFile}
            TEST_FILE_START
            ${testFileContent}
            TEST_FILE_END

            README file: ${readmeFile}
            README_FILE_START
            ${readmeFileContent}
            README_FILE_END
            
            MISSION file: ${missionFile}
            MISSION_FILE_START
            ${missionFileContent}
            MISSION_FILE_END

            Contributing file: ${contributingFile}
            CONTRIBUTING_FILE_START
            ${contributingFileContent}
            CONTRIBUTING_FILE_END
            
            Dependencies file: ${dependenciesFile}
            DEPENDENCIES_FILE_START
            ${dependenciesFileContent}
            DEPENDENCIES_FILE_END
            
            Prompt:
            PROMPT_START
            ${prompt}
            PROMPT_END            

            Dependencies list from command: npm list
            DEPENDENCIES_LIST_START
            ${dependenciesListOutput}
            DEPENDENCIES_LIST_END    
            
            Build output from command: ${buildScript}
            TEST_OUTPUT_START
            ${buildOutput}
            TEST_OUTPUT_END      
            
            Test output from command: ${testScript}
            TEST_OUTPUT_START
            ${testOutput}
            TEST_OUTPUT_END            

            Main output from command: ${mainScript}
            MAIN_OUTPUT_START
            ${mainOutput}
            MAIN_OUTPUT_END    
            
            Open issue titles:
            OPEN_ISSUE_TITLES_START
            ${openIssueTitles}
            OPEN_ISSUE_TITLES_END
            
            Answer strictly with a JSON object following this schema:
            {
              "issueTitle": "The title of the GitHub issue summarising the change",
              "issueDescription": "The description of the GitHub issue detailing the change and how to apply and verify it.",
            }
            Ensure valid JSON.
            `;
            
            const ResponseSchema = z.object({ issueTitle: z.string(), issueDescription: z.string() });
            
            // Define the function schema for function calling
            const tools = [{
              type: "function",
              function: {
                name: "generate_issue",
                description: "Elaborate on the supplied prompt and project files to create the issueTitle and issueDescription of a GitHub Issue. Return an object with issueTitle (string), and issueDescription (string).",
                parameters: {
                  type: "object",
                  properties: {
                    issueTitle: { type: "string", description: "A summary of the change to make as a title." },
                    issueDescription: { type: "string", description: "Detail about the change, how to apply and verify it." }
                  },
                  required: ["issueTitle", "issueDescription"],
                  additionalProperties: false
                },
                strict: true
              }
            }];

            // Call OpenAI using function calling format
            const response = await openai.chat.completions.create({
              model,
              messages: [
                { role: "system", content: "You are responding to a prompt for action by raising a GitHub issue that will be processed by an LLM with a token limit of 200,000 tokens in order tio manifest the prompt action as code, tests or documentation. You will respond to the intention of the prompt using a detailed assessment of the current state of the repository, the current feature set and the mission statement. Answer strictly with a JSON object following the provided function schema." },
                { role: "user", content: chatGptPrompt }
              ],
              tools: tools
            });
            
            let result;
            if (response.choices[0].message.tool_calls && response.choices[0].message.tool_calls.length > 0) {
              try {
                result = JSON.parse(response.choices[0].message.tool_calls[0].function.arguments);
              } catch (e) {
                core.setFailed(`Failed to parse function call arguments: ${e.message}`);
              }
            } else if (response.choices[0].message.content) {
              try {
                result = JSON.parse(response.choices[0].message.content);
              } catch (e) {
                core.setFailed(`Failed to parse response content: ${e.message}`);
              }
            } else {
              core.setFailed("No valid response received from OpenAI.");
            }
            
            try {
              const parsed = ResponseSchema.parse(result);
              core.setOutput("issueTitle", parsed.issueTitle);
              core.setOutput("issueDescription", parsed.issueDescription);
              core.info(`issueTitle: "${parsed.issueTitle}"`);
              core.info(`issueDescription: "${parsed.issueDescription}"`);
            
            } catch (e) {
              core.setFailed(`Failed to parse ChatGPT response: ${e.message}`);
            }
            
            core.setOutput("response", JSON.stringify(response));
            core.setOutput("usage", JSON.stringify(response.usage));
            core.info(`response: "${JSON.stringify(response)}"`);
            core.info(`usage: "${JSON.stringify(response.usage)}"`);
    outputs:
      issueTitle: ${{ steps.generate-maintenance-issue.outputs.issueTitle }}
      issueDescription: ${{ steps.generate-maintenance-issue.outputs.issueDescription }}
.github/workflows/wfr-completion-maintain-features.yml
==== Content of .github/workflows/wfr-completion-maintain-features.yml ====
# .github/workflows/wfr-completion-maintain-features.yml

#
# agentic-lib
# Copyright (C) 2025 Polycode Limited
#
# This file is part of agentic-lib.
#
# agentic-lib is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License v3.0 (GPL‑3).
# along with this program. If not, see <https://www.gnu.org/licenses/>.
#
# IMPORTANT: Any derived work must include the following attribution:
# "This work is derived from https://github.com/xn-intenton-z2a/agentic-lib"
#

name: ∞ maintain-features

on:
  workflow_call:
    inputs:
      feature:
        description: 'Text to drive the feature creation (if "house choice", the repository will be assessed an action chosen). e.g. "Support output to PDF."'
        type: string
        required: false
        default: 'house choice'
      featuresDir:
        description: 'The directory to create/update the features in. e.g. "features/"'
        type: string
        required: false
        default: 'features/'
      featuresWipLimit:
        description: 'The maximum number of features to create. e.g. "3"'
        type: string
        required: false
        default: '3'
      target:
        description: 'The target file to create the issue to change. e.g. "src/lib/main.js"'
        type: string
        required: false
        default: 'src/lib/main.js'
      testFile:
        description: 'The test file. e.g. "tests/unit/main.test.js"'
        type: string
        required: false
        default: 'tests/unit/main.test.js'
      readmeFile:
        description: 'The README file. e.g. "README.md"'
        type: string
        required: false
        default: 'README.md'
      missionFile:
        description: 'The MISSION statement file. e.g. "MISSION.md"'
        type: string
        required: false
        default: 'MISSION.md'
      contributingFile:
        description: 'The CONTRIBUTING file. e.g. "CONTRIBUTING.md"'
        type: string
        required: false
        default: 'CONTRIBUTING.md'
      dependenciesFile:
        description: 'The dependencies file. e.g. "package.json"'
        type: string
        required: false
        default: 'package.json'
      buildScript:
        description: 'The script must be runnable as: `npm ci ; <script>` and succeed with a zero exit code. e.g. `npm run build`'
        type: string
        required: false
        default: 'echo "No build script specified."'
      testScript:
        description: 'The script must be runnable as: `npm ci ; <script>` and succeed with a zero exit code. e.g. `npm test`'
        type: string
        required: false
        default: 'npm test'
      mainScript:
        description: 'The script must be runnable as: `npm ci ; <script>` and succeed with a zero exit code. e.g. `npm run start`'
        type: string
        required: false
        default: 'npm run start'
      model:
        description: 'The OpenAI model to use. e.g. "o3-mini"'
        type: string
        required: false
        default: ${{ vars.CHATGPT_API_MODEL || 'o3-mini' }}
      npmAuthOrganisation:
        description: 'The GitHub organisation to authenticate with for npm. e.g. "xn-intenton-z2a"'
        type: string
        required: false
        default: ''
      gitUserEmail:
        description: 'The email to use for git commits. e.g. "action@github.com"'
        type: string
        required: false
        default: 'action@github.com'
      gitUserName:
        description: 'The name to use for git commits. e.g. "GitHub Actions[bot]"'
        type: string
        required: false
        default: 'GitHub Actions[bot]'
      s3BucketUrl:
        description: 'The S3 bucket URL with prefix to use. e.g. "s3://my-bucket/prefix"'
        type: string
        required: false
        default: ''
      iamRoleArn:
        description: 'The ARN of the IAM role to assume. e.g. "arn:aws:iam::123456789012:role/my-role"'
        type: string
        required: false
        default: ''
    secrets:
      PERSONAL_ACCESS_TOKEN:
        required: false
      CHATGPT_API_SECRET_KEY:
        required: true
    outputs:
      featureName:
        value: ${{ jobs.maintain-features.outputs.featureName }}
      featureSpec:
        value: ${{ jobs.maintain-features.outputs.featureSpec }}

jobs:
  maintain-features:
    runs-on: ubuntu-latest

    env:
      feature: ${{ inputs.feature || '' }}
      featuresDir: ${{ inputs.featuresDir || 'features/' }}
      featuresWipLimit: ${{ inputs.featuresWipLimit || '3' }}
      target: ${{ inputs.target || 'src/lib/main.js' }}
      testFile: ${{ inputs.testFile || 'tests/unit/main.test.js' }}
      readmeFile: ${{ inputs.readmeFile || 'README.md' }}
      missionFile: ${{ inputs.missionFile || 'MISSION.md' }}
      contributingFile: ${{ inputs.contributingFile || 'CONTRIBUTING.md' }}
      dependenciesFile: ${{ inputs.dependenciesFile || 'package.json' }}
      buildScript: ${{ inputs.buildScript || 'npm run build' }}
      testScript: ${{ inputs.testScript || 'npm test' }}
      mainScript: ${{ inputs.mainScript || 'npm run start' }}
      mainScriptTimeout: '5m'
      model: ${{ inputs.model || vars.CHATGPT_API_MODEL || 'o3-mini' }}
      npmAuthOrganisation: ${{ inputs.npmAuthOrganisation || '' }}
      gitUserEmail: ${{ inputs.gitUserEmail || 'action@github.com' }}
      gitUserName: ${{ inputs.gitUserName || 'GitHub Actions[bot]' }}
      chatgptApiSecretKey: ${{ secrets.CHATGPT_API_SECRET_KEY }}
      s3BucketUrl: ${{ inputs.s3BucketUrl || '' }}
      iamRoleArn: ${{ inputs.iamRoleArn || '' }}

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Check GitHub authentication
        if: ${{ env.npmAuthOrganisation != '' }}
        shell: bash
        run: |
          curl --include --header "Authorization: token ${{ secrets.PERSONAL_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}" https://api.github.com/user

      - name: Set up .npmrc
        if: ${{ env.npmAuthOrganisation != '' }}
        shell: bash
        run: |
          echo "${{ env.npmAuthOrganisation }}:registry=https://npm.pkg.github.com" >> .npmrc
          echo "//npm.pkg.github.com/:_authToken=${{ secrets.PERSONAL_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}" >> .npmrc
          echo "always-auth=true" >> .npmrc

      - run: npm ci

      - name: List current features
        id: features
        shell: bash
        run: |
          output=$(find "${{ env.featuresDir }}" -maxdepth 1 -type f -name '*.md' -print -exec echo "# {}" \; -exec cat {} \; 2>&1 || echo 'none')
          echo "output<<EOF" >> "$GITHUB_OUTPUT"
          echo "$output" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          echo "output=${output}"

      - name: List rejected feature named
        id: rejectedFeatures
        shell: bash
        run: |
          mkdir -p "${{ env.featuresDir }}/rejects"
          output=$(ls -1 "${{ env.featuresDir }}/rejects" | sed 's/\.md//' | xargs echo )
          echo "output<<EOF" >> "$GITHUB_OUTPUT"
          echo "$output" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          echo "output=${output}"

      - name: List dependencies
        id: list
        shell: bash
        run: |
          output=$(npm list 2>&1)
          echo "output<<EOF" >> "$GITHUB_OUTPUT"
          echo "$output" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          echo "output=${output}"

      - name: Build project
        id: build
        shell: bash
        run: |
          output=$(${{ env.buildScript }} 2>&1)
          echo "output<<EOF" >> "$GITHUB_OUTPUT"
          echo "$output" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          echo "output=${output}"

      - name: Tear down .npmrc
        if: ${{ env.npmAuthOrganisation != '' }}
        shell: bash
        run: rm -f .npmrc

      - name: Run tests
        id: test
        shell: bash
        run: |
          output=$(${{ env.testScript }} 2>&1)
          echo "output<<EOF" >> "$GITHUB_OUTPUT"
          echo "$output" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          echo "output=${output}"

      - name: Run main
        id: main
        shell: bash
        run: |
          output=$(timeout ${{ env.mainScriptTimeout }} ${{ env.mainScript }} 2>&1)
          echo "output<<EOF" >> "$GITHUB_OUTPUT"
          echo "$output" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          echo "output=${output}"

      - name: maintain-features
        id: maintain-features
        uses: actions/github-script@v7
        env:
          currentFeatures: ${{ steps.features.outputs.output }}
          rejectedFeatures: ${{ steps.rejectedFeatures.outputs.output }}
          dependenciesListOutput: ${{ steps.list.outputs.output }}
          buildOutput: ${{ steps.build.outputs.output }}
          testOutput: ${{ steps.test.outputs.output }}
          mainOutput: ${{ steps.main.outputs.output }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const feature = process.env.feature;
            const featuresDir = process.env.featuresDir;
            const featuresWipLimit = process.env.featuresWipLimit;
            const currentFeatures = process.env.currentFeatures;
            const rejectedFeatures = process.env.rejectedFeatures;
            const target = process.env.target;
            const testFile = process.env.testFile;
            const readmeFile = process.env.readmeFile;
            const missionFile = process.env.missionFile;
            const contributingFile = process.env.contributingFile;
            const dependenciesFile = process.env.dependenciesFile;
            const model = process.env.model;
            const apiKey = process.env.chatgptApiSecretKey;
            const dependenciesListOutput = process.env.dependenciesListOutput;
            const buildScript = process.env.buildScript;
            const buildOutput = process.env.buildOutput;
            const testScript = process.env.testScript;
            const testOutput = process.env.testOutput;
            const mainScript = process.env.mainScript;
            const mainOutput = process.env.mainOutput;

            const fs = require('fs');
            const path = require('path');
            const OpenAI = require('openai').default;
            const { z } = require('zod');
            require('dotenv').config();
  
            if (!apiKey) { 
              core.setFailed("Missing CHATGPT_API_SECRET_KEY"); 
            }
            const openai = new OpenAI({ apiKey });

            core.info(`feature: "${feature}"`);
            core.info(`featuresDir: "${featuresDir}"`);
            core.info(`currentFeatures: "${currentFeatures}"`);
            core.info(`target: "${target}"`);
            core.info(`testFile: "${testFile}"`);
            core.info(`readmeFile: "${readmeFile}"`);
            core.info(`missionFile: "${missionFile}"`);
            core.info(`contributingFile: "${contributingFile}"`);
            core.info(`dependenciesFile: "${dependenciesFile}"`);
            const sourceFileContent = fs.readFileSync(target, 'utf8');
            const testFileContent = fs.readFileSync(testFile, 'utf8');
            const readmeFileContent = fs.readFileSync(readmeFile, 'utf8');
            const missionFileContent = fs.readFileSync(missionFile, 'utf8');
            const contributingFileContent = fs.readFileSync(contributingFile, 'utf8');
            const dependenciesFileContent = fs.readFileSync(dependenciesFile, 'utf8');
            core.info(`Target file '${target}' has been loaded (length ${sourceFileContent.length}).`);
            core.info(`Test file '${testFile}' has been loaded (length ${testFileContent.length}).`);
            core.info(`Readme file '${readmeFile}' has been loaded (length ${readmeFileContent.length}).`);
            core.info(`Dependencies file '${dependenciesFile}' has been loaded (length ${dependenciesFileContent.length}).`);
            
            // generate the feature prompt either by using the supplied feature or by reviewing the current features and full context
            let prompt = feature;
            if (feature === 'house choice') {
              prompt = `Please review the current features in the repository and either;
                * add a new feature to the repository, or
                * extend an existing feature to add a new aspect to it, or
                * update an existing feature to bring it to a high standard matching other features in the repository.
                The feature name should either be a current feature name or be supplied with a feature specification which is distinct from any other feature in the repository.
              `;
            }
            
            const chatGptPrompt = `
            Please generate the name and specification for a software feature which will be added or updated to action the supplied feature prompt.
            Prefer to refine a feature focusing on achievable value with a single repository, not a grandiose vision, or bloated feature set.
            You may only create features to only change the source file, test file, README file and dependencies file content. You may not create features that request new files, delete existing files, or change the other files provided in the prompt context.
            If there are more than the maximum number of ${featuresWipLimit} features in the repository, you must merge similar features into a single feature and name the features to be deleted.
            The feature will be iterated upon to deliver the feature. New features should be thematically distinct from other features.
            If a significant feature of the repository is not present in the current feature set, please add it either to a new feature or an existing feature.
            All significant features of the repository should be present in the feature set before new features are added and features can be consolidated to make room below the maximum of ${featuresWipLimit} features.
            Before adding a new feature ensure that this feature is distinct from any other feature in the repository, otherwise update an existing feature.
            When updating an existing feature, ensure that the existing aspects are not omitted in the response, provide the full feature spec.
            The feature name should be one or two words in SCREAMING_SNAKECASE.
            Any new feature should not be similar to any of the rejected features and steer existing features away from the rejected features.
            The feature spec should be a detailed description of the feature, compatible with the guidelines in CONTRIBUTING.md.
            You may also just update a feature spec to bring it to a high standard matching other features in the repository.
            A feature can be added based on a behaviour already present in the repository described within the guidelines in CONTRIBUTING.md.
            Features must be achievable in a single software repository not part of a corporate initiative.
            The feature spec should be a multiline markdown with a few level 1 headings.
            The feature must be compatible with the mission statement in MISSION.md and ideally realise part of the value in the mission.
            The feature must be something than can be realised in a single source file (as below), ideally just as a library, CLI tool or possibly an HTTP API in combination with infrastructure as code deployment.
            Consider the following when refining your response:
            * Feature prompt details
            * Current feature names and specifications in the repository
            * Rejected feature names
            * Source file content
            * Test file content
            * README file content
            * MISSION file content
            * Contributing file content
            * Dependencies file content
            * Dependency list
            * Build output
            * Test output
            * Main execution output
            
            Feature prompt:
            FEATURE_PROMPT_START
            ${prompt}
            FEATURE_PROMPT_END            
            
            Current feature names and specifications:
            CURRENT_FEATURES_START
            ${currentFeatures}
            CURRENT_FEATURES_END
            
            Rejected feature names:
            REJECTED_FEATURES_START
            ${rejectedFeatures}
            REJECTED_FEATURES_END
            
            Source file: ${target}
            SOURCE_FILE_START
            ${sourceFileContent}
            SOURCE_FILE_END
            
            Test file: ${testFile}
            TEST_FILE_START
            ${testFileContent}
            TEST_FILE_END

            README file: ${readmeFile}
            README_FILE_START
            ${readmeFileContent}
            README_FILE_END
            
            MISSION file: ${missionFile}
            MISSION_FILE_START
            ${missionFileContent}
            MISSION_FILE_END

            Contributing file: ${contributingFile}
            CONTRIBUTING_FILE_START
            ${contributingFileContent}
            CONTRIBUTING_FILE_END
            
            Dependencies file: ${dependenciesFile}
            DEPENDENCIES_FILE_START
            ${dependenciesFileContent}
            DEPENDENCIES_FILE_END
            
            Dependencies list from command: npm list
            DEPENDENCIES_LIST_START
            ${dependenciesListOutput}
            DEPENDENCIES_LIST_END    
            
            Build output from command: ${buildScript}
            TEST_OUTPUT_START
            ${buildOutput}
            TEST_OUTPUT_END      
            
            Test output from command: ${testScript}
            TEST_OUTPUT_START
            ${testOutput}
            TEST_OUTPUT_END            

            Main output from command: ${mainScript}
            MAIN_OUTPUT_START
            ${mainOutput}
            MAIN_OUTPUT_END
            
            Answer strictly with a JSON object following this schema:
            {
              "featureName": "The feature name as one or two words in SCREAMING_SNAKECASE.",
              "featureSpec": "The feature specification as multiline markdown with a few level 1 headings.",
              "featureNamesToBeDeleted": "The comma separated list of feature names to be deleted or 'none' if no feature is to be deleted."
            }
            Ensure valid JSON.
            `;
            
            const ResponseSchema = z.object({ featureName: z.string(), featureSpec: z.string(), featureNamesToBeDeleted: z.string() });
            
            // Define the function schema for function calling
            const tools = [{
              type: "function",
              function: {
                name: "generate_feature",
                description: "Elaborate on the supplied prompt and project files to create the featureName and featureSpec of a repository feature, and the feature names to be deleted. Return an object with featureName (string), featureSpec (string), and featureNamesToBeDeleted (string).",
                parameters: {
                  type: "object",
                  properties: {
                    featureName: { type: "string", description: "The feature name as one or two words in SCREAMING_SNAKECASE." },
                    featureSpec: { type: "string", description: "The feature specification as multiline markdown with a few level 1 headings." },
                    featureNamesToBeDeleted: { type: "string", description: "The comma separated list of feature names to be deleted or 'none' if no feature is to be deleted." }
                  },
                  required: ["featureName", "featureSpec", "featureNamesToBeDeleted"],
                  additionalProperties: false
                },
                strict: true
              }
            }];

            // Call OpenAI using function calling format
            const response = await openai.chat.completions.create({
              model,
              messages: [
                { role: "system", content: "You are maintaining a feature set by providing expert contemporary insight into both the product market and you will perform a detailed analysis of the current state of the repository and current feature set in search of value opportunities and unique selling points. Answer strictly with a JSON object following the provided function schema." },
                { role: "user", content: chatGptPrompt }
              ],
              tools: tools
            });
            
            let result;
            if (response.choices[0].message.tool_calls && response.choices[0].message.tool_calls.length > 0) {
              try {
                result = JSON.parse(response.choices[0].message.tool_calls[0].function.arguments);
              } catch (e) {
                core.setFailed(`Failed to parse function call arguments: ${e.message}`);
              }
            } else if (response.choices[0].message.content) {
              try {
                result = JSON.parse(response.choices[0].message.content);
              } catch (e) {
                core.setFailed(`Failed to parse response content: ${e.message}`);
              }
            } else {
              core.setFailed("No valid response received from OpenAI.");
            }
            
            try {
              const parsed = ResponseSchema.parse(result);
              core.setOutput("featureName", parsed.featureName);
              core.setOutput("featureSpec", parsed.featureSpec);
              core.setOutput("featureNamesToBeDeleted", parsed.featureNamesToBeDeleted);
              core.info(`featureName: "${parsed.featureName}"`);
              core.info(`featureSpec: "${parsed.featureSpec}"`);
              core.info(`featureNamesToBeDeleted: "${parsed.featureNamesToBeDeleted}"`);
            
              // Save the feature spec to a file using the convention of <featuresDir> plus path SCREAMING_SNAKE_CASE(<feature name>).md
              const featureName = parsed.featureName.replace(/ /g, "_").toUpperCase();
              const featureSpec = parsed.featureSpec;
              const featuresDir = process.env.featuresDir || 'features/';
              
              const featureFilePath = path.join(featuresDir, `${featureName}.md`);
              try {
                fs.mkdirSync(featuresDir, { recursive: true });
                fs.writeFileSync(featureFilePath, featureSpec);
                core.info(`Feature spec saved to ${featureFilePath}`);
              } catch (e) {
                core.setFailed(`Failed to save feature spec: ${e.message}`);
              }
            
              const featureFilepathsToBeDeleted = parsed.featureNamesToBeDeleted
                .split(',')
                .map(name => path.join(featuresDir, `${name.trim().replace(/.md^/, "").toUpperCase()}.md`));
              for (const filepath of featureFilepathsToBeDeleted) {
                try {
                  if( fs.existsSync(filepath) ) {
                    core.info(`Deleting feature file: ${filepath}`);
                    fs.unlinkSync(filepath);
                  }
                } catch (e) {
                  core.info(`Could not delete ${filepath}: ${e.message}`);
                }
              }
            
            } catch (e) {
              core.setFailed(`Failed to parse ChatGPT response: ${e.message}`);
            }
              
            core.setOutput("response", JSON.stringify(response));
            core.setOutput("usage", JSON.stringify(response.usage));
            core.info(`response: "${JSON.stringify(response)}"`);
            core.info(`usage: "${JSON.stringify(response.usage)}"`);

      - name: Commit changes
        id: commit
        continue-on-error: true
        run: |
          git config --local user.email '${{ env.gitUserEmail }}'
          git config --local user.name '${{ env.gitUserName }}'
          git status -v
          git add -v --all '${{ env.featuresDir }}'
          git commit -m 'Maintain ${{ steps.maintain-features.outputs.featureName }}'
          git status -v
          git push -v origin ${{ github.ref }}
          git status -v

    outputs:
      featureName: ${{ steps.maintain-features.outputs.featureName }}
      featureSpec: ${{ steps.maintain-features.outputs.featureSpec }}
.github/workflows/feature-development-issue-creator.yml
==== Content of .github/workflows/feature-development-issue-creator.yml ====
# .github/workflows/feature-development-issue-creator.yml
#
# This file is part of the example suite for `agentic-lib` see: https://github.com/xn-intenton-z2a/agentic-lib
# This file is licensed under the MIT License. For details, see LICENSE-MIT

name: Create Feature Development Issue
concurrency: agentic-lib-issue
run-name: "Create Feature Development Issue"

on:
  workflow_dispatch:
    inputs:
      featureName:
        description: 'name of the feature to create an issue for (if "house choice", a currently random feature will be selected). e.g. "WEBSITE"'
        required: false
        type: string
        default: 'house choice'
  schedule:
    - cron: '0 4 */7 * *' # schedule-1
    #- cron: '0 4 * * *' # schedule-2
    #- cron: '0 */1 1-3,5-7,9-11,13-15,17-19,21-23,25-27,29-31 * *' # schedule-3
    #- cron: '0,27 */1 1-3,5-7,9-11,13-15,17-19,21-23,25-27,29-31 * *' # schedule-4

jobs:

  agentic-lib:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: agentic-lib
        id: agentic-lib
        shell: bash
        run: |
          featureDevelopmentIssuesWipLimit=$(grep '^featureDevelopmentIssuesWipLimit:' .github/agentic-lib.yml | awk '{print $2}')
          echo "featureDevelopmentIssuesWipLimit=${featureDevelopmentIssuesWipLimit}"
          echo "featureDevelopmentIssuesWipLimit=${featureDevelopmentIssuesWipLimit}" >> $GITHUB_OUTPUT
    outputs:
      featureDevelopmentIssuesWipLimit: ${{ steps.agentic-lib.outputs.featureDevelopmentIssuesWipLimit }}

  # If the prompt is "house choice", a random feature will be selected from the feature library otherwise the supplied feature name will be used.
  select-feature:
    runs-on: ubuntu-latest
    outputs:
      prompt: ${{ steps.extract.outputs.prompt }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Select feature from ./features
        id: select
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = require('path');
            let featureName = '${{ inputs.featureName }}';
            if (featureName === 'house choice') {
              const promptsDir = './features';
              // Get all items in the directory
              const items = fs.readdirSync(promptsDir);
              // Filter only the files (exclude directories)
              const files = items.filter(item => {
                const filePath = path.join(promptsDir, item);
                return fs.lstatSync(filePath).isFile();
              });
            
              if (files.length === 0) {
                core.setFailed('No prompt files found in the prompts directory.');
              } else {
                // Select a random file
                const randomFile = files[Math.floor(Math.random() * files.length)];
                featureName = randomFile.replace('.md', '');
              }
            }
              
            core.setOutput('featureName', featureName);
            core.info(`featureName: ${featureName}`);

  generate-feature-development-issue:
    needs:
      - select-feature
    permissions:
      contents: write
      issues: write
      id-token: write
    uses: 'xn-intenton-z2a/agentic-lib/.github/workflows/wfr-completion-generate-feature-development-issue.yml@main'
    with:
      featureName: ${{ needs.select-prompt.outputs.featureName }}
      featuresDir: './features'
      featureDevelopmentIssuesWipLimit: '${{ needs.agentic-lib.outputs.featureDevelopmentIssuesWipLimit }}'
      target: ${{ inputs.target || 'src/lib/main.js' }}
      testFile: ${{ inputs.testFile || 'tests/unit/main.test.js' }}
      readmeFile: 'README.md'
      missionFile: 'MISSION.md'
      contributingFile: 'CONTRIBUTING.md'
      dependenciesFile: 'package.json'
      buildScript: 'npm run build'
      testScript: 'npm test'
      issueSelectionLabel: 'feature'
      mainScript: ${{ vars.MAIN_SCRIPT || 'npm run start' }}
      model: ${{ vars.CHATGPT_API_MODEL || 'o3-mini' }}
      npmAuthOrganisation: '@xn-intenton-z2a'
    secrets:
      CHATGPT_API_SECRET_KEY: ${{ secrets.CHATGPT_API_SECRET_KEY }}
      PERSONAL_ACCESS_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}

  create-issue:
    needs:
      - select-feature
      - generate-feature-development-issue
    permissions:
      issues: write
      id-token: write
    uses: 'xn-intenton-z2a/agentic-lib/.github/workflows/wfr-github-create-issue.yml@main'
    with:
      issueTitle: ${{ needs.generate-feature-development-issue.outputs.issueTitle }}
      issueBody: ${{ needs.generate-feature-development-issue.outputs.issueDescription }}
      issueLabels: 'feature, automated'

  select-issue:
    permissions:
      issues: read
      id-token: write
    uses: 'xn-intenton-z2a/agentic-lib/.github/workflows/wfr-github-select-issue.yml@main'
    with:
      issueNumber: ''
      selectionLabel: 'automated'
    secrets:
      CHATGPT_API_SECRET_KEY: ${{ secrets.CHATGPT_API_SECRET_KEY }}

  stats:
    needs:
      - select-issue
      - create-issue
    if: ${{ always() }}
    permissions:
      contents: write
      id-token: write
      pages: write
    uses: 'xn-intenton-z2a/agentic-lib/.github/workflows/wfr-github-stats.yml@main'
    with:
      cache: 'npm'
      npmAuthOrganisation: '@xn-intenton-z2a'
      lastActivityName: ${{ github.workflow }}
      lastActivityBranchName: ${{ github.ref_name }}
      nextIssue: "[${{ needs.select-issue.outputs.issueNumber }}] ${{ needs.select-issue.outputs.issueTitle }} ${{ needs.select-issue.outputs.issueLabels }}"
      public: 'public'
      s3BucketUrl: 's3://agentic-lib-telemetry-bucket/events/'
      s3WebsiteBucketUrl: 's3://agentic-lib-public-website-stats-bucket/'
      iamActionsRoleArn: 'arn:aws:iam::541134664601:role/agentic-lib-github-actions-role'
      iamStatsBucketWriterRoleArn: 'arn:aws:iam::541134664601:role/agentic-lib-deployment-role'
      iamPublicWebsiteStatsBucketWriterRoleArn: 'arn:aws:iam::541134664601:role/agentic-lib-public-website-stats-bucket-writer-role'
    secrets:
      PERSONAL_ACCESS_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}
.github/workflows/formating.yml
==== Content of .github/workflows/formating.yml ====
# .github/workflows/formating.yml
#
# This file is part of the example suite for `agentic-lib` see: https://github.com/xn-intenton-z2a/agentic-lib
# This file is licensed under the MIT License. For details, see LICENSE-MIT

name: ∞ Formatting
concurrency: agentic-lib-commit-main
run-name: "Formatting [${{ github.ref_name }}]"

on:
  workflow_dispatch:
  schedule:
    - cron: '30 5 */14 * *' # schedule-1
    #- cron: '30 5 */3 * *' # schedule-2
    #- cron: '30 5 * * *' # schedule-3
    #- cron: '30 5 * * *' # schedule-4

jobs:

  check-branch:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write
    env:
      branchPrefix: 'agentic-lib-'
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.ref }}
      - name: Ensure there isn't already a branch for this prefix
        shell: bash
        run: |
          git fetch origin
          if git branch -r | grep -q 'origin/${{ env.branchPrefix }}'; then
            echo "A branch with the prefix '${{ env.branchPrefix }}' already exists."
            exit 1
          else
            echo "No existing branch with the prefix found."
          fi

  formatting:
    needs:
      - check-branch
    permissions:
      contents: write
      packages: write
      id-token: write
    uses: 'xn-intenton-z2a/agentic-lib/.github/workflows/wfr-npm-run-script-and-commit-to-branch.yml@main'
    with:
      script: 'npm run formatting-fix -- src/lib/main.js tests/unit/main.test.js ; npm run linting-fix src/lib/main.js tests/unit/main.test.js'
      sarifScript: ''
      testScript: 'npm test'
      branch: 'agentic-lib-formatting'
      gitUserEmail: 'action@github.com'
      gitUserName: 'GitHub Actions[bot]'
      gitCommitMessage: 'Updated by `npm run formatting-fix -- "." ; npm run linting-fix "."`'

  create-pr:
    needs:
      - formatting
    if: ${{ needs.formatting.outputs.updatedFiles == 'true' }}
    permissions:
      contents: write
      packages: write
      issues: write
      pull-requests: write
      checks: write
      id-token: write
    uses: 'xn-intenton-z2a/agentic-lib/.github/workflows/wfr-github-create-pr.yml@main'
    with:
      branch: 'agentic-lib-formatting'
      baseBranch: 'main'
      gitCommitMessage: 'chore: formatting fixes'
      label: 'automerge'

  select-issue:
    permissions:
      issues: read
      id-token: write
    uses: 'xn-intenton-z2a/agentic-lib/.github/workflows/wfr-github-select-issue.yml@main'
    with:
      issueNumber: ''
      selectionLabel: 'automated'
    secrets:
      CHATGPT_API_SECRET_KEY: ${{ secrets.CHATGPT_API_SECRET_KEY }}

  stats:
    needs:
      - select-issue
      - create-pr
    if: ${{ always() }}
    permissions:
      contents: write
      id-token: write
      pages: write
    uses: 'xn-intenton-z2a/agentic-lib/.github/workflows/wfr-github-stats.yml@main'
    with:
      cache: 'npm'
      npmAuthOrganisation: '@xn-intenton-z2a'
      lastActivityName: ${{ github.workflow }}
      lastActivityBranchName: ${{ github.ref_name }}
      nextIssue: "[${{ needs.select-issue.outputs.issueNumber }}] ${{ needs.select-issue.outputs.issueTitle }} ${{ needs.select-issue.outputs.issueLabels }}"
      public: 'public'
      s3BucketUrl: 's3://agentic-lib-telemetry-bucket/events/'
      s3WebsiteBucketUrl: 's3://agentic-lib-public-website-stats-bucket/'
      iamActionsRoleArn: 'arn:aws:iam::541134664601:role/agentic-lib-github-actions-role'
      iamStatsBucketWriterRoleArn: 'arn:aws:iam::541134664601:role/agentic-lib-deployment-role'
      iamPublicWebsiteStatsBucketWriterRoleArn: 'arn:aws:iam::541134664601:role/agentic-lib-public-website-stats-bucket-writer-role'
    secrets:
      PERSONAL_ACCESS_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}
.github/workflows/truncate-issue-history.yml
==== Content of .github/workflows/truncate-issue-history.yml ====
# .github/workflows/truncate-issue-history.yml
#
# This file is part of the example suite for `agentic-lib` see: https://github.com/xn-intenton-z2a/agentic-lib
# This file is licensed under the MIT License. For details, see LICENSE-MIT

name: ∞ Truncate Issue History
concurrency: truncate-issue-history

on:
  workflow_dispatch:
  schedule:
    - cron: '0 0 * * *'

jobs:
  cleanup:
    runs-on: ubuntu-latest
    steps:
      - name: Redact old GitHub issues and delete their comments
        uses: actions/github-script@v7
        with:
          script: |
            // Set retention period (in days)
            const retentionDays = 7;
            const cutoffDate = new Date(Date.now() - retentionDays * 24 * 60 * 60 * 1000);
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const perPage = 100;
            let issuesRedacted = 0;
            let commentsDeleted = 0;

            console.log(`Redacting issues not updated in the last ${retentionDays} days (before ${cutoffDate.toISOString()})...`);

            let page = 1;
            while (true) {
              const issuesResponse = await github.rest.issues.listForRepo({
                owner,
                repo,
                state: 'all',
                per_page: perPage,
                page
              });
              const issues = issuesResponse.data;
              if (issues.length === 0) break;
              for (const issue of issues) {
                // Skip pull requests
                if (issue.pull_request) continue;
                const updatedAt = new Date(issue.updated_at);
                if (updatedAt < cutoffDate) {
                  try {
                    // Update the issue's title and body to "redact" details.
                    await github.rest.issues.update({
                      owner,
                      repo,
                      issue_number: issue.number,
                      title: "Redacted",
                      body: "This issue has been redacted."
                    });
                    console.log(`Redacted issue #${issue.number} (last updated at ${issue.updated_at})`);
                    issuesRedacted++;

                    // List and delete all comments for the issue.
                    let commentPage = 1;
                    while (true) {
                      const commentsResponse = await github.rest.issues.listComments({
                        owner,
                        repo,
                        issue_number: issue.number,
                        per_page: perPage,
                        page: commentPage
                      });
                      const comments = commentsResponse.data;
                      if (comments.length === 0) break;
                      for (const comment of comments) {
                        try {
                          await github.rest.issues.deleteComment({
                            owner,
                            repo,
                            comment_id: comment.id
                          });
                          console.log(`Deleted comment ${comment.id} on issue #${issue.number}`);
                          commentsDeleted++;
                        } catch (err) {
                          console.error(`Failed to delete comment ${comment.id} on issue #${issue.number}: ${err.message}`);
                        }
                      }
                      commentPage++;
                    }
                  } catch (error) {
                    console.error(`Failed to update issue #${issue.number}: ${error.message}`);
                  }
                }
              }
              page++;
            }
            console.log(`Total issues redacted: ${issuesRedacted}`);
            console.log(`Total comments deleted: ${commentsDeleted}`);
            return `Cleanup complete. Redacted ${issuesRedacted} issues and deleted ${commentsDeleted} comments.`;
          result-encoding: string
.github/workflows/wfr-github-find-pr-from-pull-request.yml
==== Content of .github/workflows/wfr-github-find-pr-from-pull-request.yml ====
# .github/workflows/wfr-github-find-pr-from-pull-request.yml

#
# agentic-lib
# Copyright (C) 2025 Polycode Limited
#
# This file is part of agentic-lib.
#
# agentic-lib is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License v3.0 (GPL‑3).
# along with this program. If not, see <https://www.gnu.org/licenses/>.
#
# IMPORTANT: Any derived work must include the following attribution:
# "This work is derived from https://github.com/xn-intenton-z2a/agentic-lib"
#

name: ∞ automerge-find-pr-from-pull-request

on:
  workflow_call:
    inputs:
      cache:
          description: 'The cache to use for npm. e.g. "npm"'
          type: string
          required: false
          default: 'npm'
      s3BucketUrl:
        description: 'The S3 bucket URL with prefix to use. e.g. "s3://my-bucket/prefix"'
        type: string
        required: false
        default: ''
      iamRoleArn:
        description: 'The ARN of the IAM role to assume. e.g. "arn:aws:iam::123456789012:role/my-role"'
        type: string
        required: false
        default: ''
    secrets:
      PERSONAL_ACCESS_TOKEN:
        required: false
    outputs:
      pullNumber:
        description: 'The pull request number. e.g. "123"'
        value: ${{ jobs.check-pr.outputs.pullNumber }}
      shouldSkipMerge:
        description: 'Set to "true", if the merge request should be skipped because there is not a PR in the right state.'
        value: ${{ jobs.check-pr.outputs.shouldSkipMerge }}
      prMerged:
        description: 'Set to "true", if the PR has been merged either already or by this process.'
        value: ${{ jobs.check-pr.outputs.prMerged }}

jobs:
  check-pr:
    runs-on: ubuntu-latest

    env:
      cache: ${{ inputs.cache || 'npm' }}
      s3BucketUrl: ${{ inputs.s3BucketUrl || '' }}
      iamRoleArn: ${{ inputs.iamRoleArn || '' }}

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: ${{ env.cache }}

      - name: check-pr
        id: check-pr
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PERSONAL_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}
          script: |
            const pr = context.payload.pull_request;
            const pullNumber = pr.number;
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            let pullRequest;
            let shouldSkipMerge;
            let prMerged;
            
            const { data: pullRequests } = await github.rest.pulls.list({
              owner: owner,
              repo: repo,
            });
            if (pullRequests.length > 0) {
              const filteredPRs = pullRequests.filter(pr => pr.number === pullNumber);
              if (filteredPRs.length > 0) {
                pullRequest = filteredPRs[0];
                core.info(`Found pull request #${pullRequest.number}.`);
                const { data: pullRequestFromGet } = await github.rest.pulls.get({
                  owner,
                  repo,
                  pull_number: pullNumber,
                });
                pullRequest = pullRequestFromGet;
                core.info(JSON.stringify(pullRequest));
              } else {
                core.info(`No pull request found with number #${pullNumber}.`);
                pullRequest = null;
              }
            } else {
              pullRequest = null;
              core.info('No pull requests found.');
            }
            //const { data: pullRequest } = await github.rest.pulls.get({
            //  owner,
            //  repo,
            //  pull_number: pullNumber,
            //});

            if (pullRequest.state === "closed") {
              core.info(`PR #${pr.number} is already closed.`);
              shouldSkipMerge = 'true';
              prMerged = 'true';
            } else if (pullRequest.state !== "open") {
              core.info(`PR #${pr.number} is not open it is ${pullRequest.state}.`);
              shouldSkipMerge = 'true';
              prMerged = 'false';
            } else if (pullRequest.mergeable === true) {
              core.info(`PR #${pr.number} is mergeable at state ${pullRequest.state}.`);
              shouldSkipMerge = 'false';    //   <--- This PR is mergeable.
              prMerged = 'false';
            } else if (pullRequest.mergeable === false) {
              core.info(`PR #${pullNumber} is not mergeable.`);
              shouldSkipMerge = 'true';
              prMerged = 'false';
            } else if (pullRequest.mergeable === null) {
              core.info(`PR #${pullNumber} does not yet have a value for mergeability.`);
              shouldSkipMerge = 'true';
              prMerged = 'false';
            } else {
              core.info(`PR #${pullNumber} is not known.`);
              shouldSkipMerge = 'true';
              prMerged = 'false';
            }
            
            core.setOutput('pullNumber', !pullNumber ? '' : pullNumber.toString());
            core.setOutput('shouldSkipMerge', shouldSkipMerge);
            core.setOutput('prMerged', prMerged);
            core.info(`pullNumber: '${!pullNumber ? '' : pullNumber.toString()}'`);
            core.info(`shouldSkipMerge: '${shouldSkipMerge}'`);
            core.info(`prMerged: '${prMerged}'`);

    outputs:
      pullNumber: ${{ steps.check-pr.outputs.pullNumber }}
      shouldSkipMerge: ${{ steps.check-pr.outputs.shouldSkipMerge }}
      prMerged: ${{ steps.check-pr.outputs.prMerged }}

.github/agentic-lib.yml
==== Content of .github/agentic-lib.yml ====
# Which agentic-lib workflow schedule should be used?
schedule: schedule-1
# How many sources should exist for document fetching.
sourcesLimit: 4096
# How many documents should exist in the library.
documentsLimit: 128
# How many features should exist concurrently open for issue creation.
featuresWipLimit: 2
# TODO: Separate the concept of features in development and features in maintenance.
# How many issues should be open to be picked up?
featureDevelopmentIssuesWipLimit: 3
maintenanceIssuesWipLimit: 2
# How many attempts should be made to work on an issue?
attemptsPerBranch: 2
attemptsPerIssue: 2
.github/dependabot.yml
==== Content of .github/dependabot.yml ====
# See: https://docs.github.com/code-security/dependabot/dependabot-version-updates/configuration-options-for-the-dependabot.yml-file
version: 2
updates:
  - package-ecosystem: "npm"
    directory: "/"
    schedule:
      interval: "weekly"
    labels:
      - dependencies
      - automated
    #ignore:
    #  - dependency-name: "some-dependency" # Example of ignoring a specific dependency
    #    versions: ["1.x", "2.x"]