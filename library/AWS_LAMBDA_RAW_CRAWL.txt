Thanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideWhen to use LambdaKey featuresWhat is AWS Lambda?You can use AWS Lambda to run code without provisioning or managing servers. Lambda runs your code
    on a high-availability compute infrastructure and performs all of the administration of the compute resources,
    including server and operating system maintenance, capacity provisioning and automatic scaling, and
    logging. With Lambda, all you need to do is supply your code in one of the language runtimes that Lambda supports.You organize your code into Lambda functions. The Lambda service runs your function only when needed and scales automatically. You only pay for the compute time that you consume—there is no charge when your code is not running. For more information, see AWS Lambda Pricing.TipTo learn how to build serverless solutions, check out the Serverless Developer Guide.
    When to use Lambda
    Lambda is an ideal compute service for application scenarios that need to scale up rapidly, and scale down to
      zero when not in demand. For example, you can use Lambda for:
  
     
     
     
     
     
  
      File processing: Use Amazon Simple Storage Service (Amazon S3) to trigger Lambda data processing in real time after an upload.
    
      Stream processing: Use Lambda and Amazon Kinesis to process real-time streaming data for application activity tracking, transaction order processing, clickstream analysis, data cleansing, log filtering, indexing, social media analysis, Internet of Things (IoT) device data telemetry, and metering.
    
      Web applications: Combine Lambda with other AWS services to build powerful web applications that automatically scale up and down and run in a highly available configuration across multiple data centers.
    
      IoT backends: Build serverless backends using Lambda to handle web, mobile, IoT, and third-party API requests.
    
      Mobile backends: Build backends using Lambda and Amazon API Gateway  to authenticate and process API requests. Use AWS Amplify to easily integrate with your iOS, Android, Web, and React Native frontends.
    
    When using Lambda, you are responsible only for your code. Lambda manages the compute fleet that offers a
      balance of memory, CPU, network, and other resources to run your code. Because Lambda manages these resources, you
      cannot log in to compute instances or customize the operating system on provided
        runtimes. Lambda performs operational and administrative activities on your behalf, including managing
      capacity, monitoring, and logging your Lambda functions.
   
    Key features
    The following key features help you develop Lambda applications that are scalable, secure, and easily
      extensible:

    
    
       

       
      
       
      
       
      
       
  
       
      
       
           
       

       
      
       

       

       
      
    
        Environment variables
        
          Use environment variables to adjust your function's behavior without updating code.
        
      
        Versions
        
          Manage the deployment of your functions with versions, so that, for example, a new function can be used for beta testing without affecting users of the stable production version.
        
      
        Container images
        
          Create a container image for a Lambda function by using an AWS provided base image or an alternative base
            image so that you can reuse your existing container tooling or deploy larger workloads that rely on sizable dependencies, such as machine learning.
        
      
        Lambda layers
        
          Package libraries and other dependencies to reduce the size of deployment archives and makes it faster to deploy your code.
        
      
        Lambda extensions
        
          Augment your Lambda functions with tools for monitoring, observability, security, and governance.
        
      
        Function URLs
        
          Add a dedicated HTTP(S) endpoint to your Lambda function.
        
      
        Response streaming
        
          Configure your Lambda function URLs to stream response payloads back to clients from Node.js functions, to improve time to first byte (TTFB) performance or to return larger payloads.
        
      
        Concurrency and scaling controls
        
          Apply fine-grained control over the scaling and responsiveness of your production applications.
        
      
        Code signing
        
          Verify that only approved developers publish unaltered, trusted code in your Lambda functions 
        
      
        Private networking
        
          Create a private network for resources such as databases, cache instances, or internal services.
        
      
        File system
        
          Configure a function to mount an Amazon Elastic File System (Amazon EFS) to a local directory, so that your function code can access and modify shared resources safely and at high concurrency.
        
      
        Lambda SnapStart
        
          Lambda SnapStart can provide as low as sub-second startup performance, typically with no changes to your function code.
        
      
  Document ConventionsCreate your first functionDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\n\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideWhen to use LambdaKey featuresWhat is AWS Lambda?You can use AWS Lambda to run code without provisioning or managing servers. Lambda runs your code
    on a high-availability compute infrastructure and performs all of the administration of the compute resources,
    including server and operating system maintenance, capacity provisioning and automatic scaling, and
    logging. With Lambda, all you need to do is supply your code in one of the language runtimes that Lambda supports.You organize your code into Lambda functions. The Lambda service runs your function only when needed and scales automatically. You only pay for the compute time that you consume—there is no charge when your code is not running. For more information, see AWS Lambda Pricing.TipTo learn how to build serverless solutions, check out the Serverless Developer Guide.
    When to use Lambda
    Lambda is an ideal compute service for application scenarios that need to scale up rapidly, and scale down to
      zero when not in demand. For example, you can use Lambda for:
  
     
     
     
     
     
  
      File processing: Use Amazon Simple Storage Service (Amazon S3) to trigger Lambda data processing in real time after an upload.
    
      Stream processing: Use Lambda and Amazon Kinesis to process real-time streaming data for application activity tracking, transaction order processing, clickstream analysis, data cleansing, log filtering, indexing, social media analysis, Internet of Things (IoT) device data telemetry, and metering.
    
      Web applications: Combine Lambda with other AWS services to build powerful web applications that automatically scale up and down and run in a highly available configuration across multiple data centers.
    
      IoT backends: Build serverless backends using Lambda to handle web, mobile, IoT, and third-party API requests.
    
      Mobile backends: Build backends using Lambda and Amazon API Gateway  to authenticate and process API requests. Use AWS Amplify to easily integrate with your iOS, Android, Web, and React Native frontends.
    
    When using Lambda, you are responsible only for your code. Lambda manages the compute fleet that offers a
      balance of memory, CPU, network, and other resources to run your code. Because Lambda manages these resources, you
      cannot log in to compute instances or customize the operating system on provided
        runtimes. Lambda performs operational and administrative activities on your behalf, including managing
      capacity, monitoring, and logging your Lambda functions.
   
    Key features
    The following key features help you develop Lambda applications that are scalable, secure, and easily
      extensible:

    
    
       

       
      
       
      
       
      
       
  
       
      
       
           
       

       
      
       

       

       
      
    
        Environment variables
        
          Use environment variables to adjust your function's behavior without updating code.
        
      
        Versions
        
          Manage the deployment of your functions with versions, so that, for example, a new function can be used for beta testing without affecting users of the stable production version.
        
      
        Container images
        
          Create a container image for a Lambda function by using an AWS provided base image or an alternative base
            image so that you can reuse your existing container tooling or deploy larger workloads that rely on sizable dependencies, such as machine learning.
        
      
        Lambda layers
        
          Package libraries and other dependencies to reduce the size of deployment archives and makes it faster to deploy your code.
        
      
        Lambda extensions
        
          Augment your Lambda functions with tools for monitoring, observability, security, and governance.
        
      
        Function URLs
        
          Add a dedicated HTTP(S) endpoint to your Lambda function.
        
      
        Response streaming
        
          Configure your Lambda function URLs to stream response payloads back to clients from Node.js functions, to improve time to first byte (TTFB) performance or to return larger payloads.
        
      
        Concurrency and scaling controls
        
          Apply fine-grained control over the scaling and responsiveness of your production applications.
        
      
        Code signing
        
          Verify that only approved developers publish unaltered, trusted code in your Lambda functions 
        
      
        Private networking
        
          Create a private network for resources such as databases, cache instances, or internal services.
        
      
        File system
        
          Configure a function to mount an Amazon Elastic File System (Amazon EFS) to a local directory, so that your function code can access and modify shared resources safely and at high concurrency.
        
      
        Lambda SnapStart
        
          Lambda SnapStart can provide as low as sub-second startup performance, typically with no changes to your function code.
        
      
  Document ConventionsCreate your first functionDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideWhen to use LambdaKey featuresWhat is AWS Lambda?You can use AWS Lambda to run code without provisioning or managing servers. Lambda runs your code
    on a high-availability compute infrastructure and performs all of the administration of the compute resources,
    including server and operating system maintenance, capacity provisioning and automatic scaling, and
    logging. With Lambda, all you need to do is supply your code in one of the language runtimes that Lambda supports.You organize your code into Lambda functions. The Lambda service runs your function only when needed and scales automatically. You only pay for the compute time that you consume—there is no charge when your code is not running. For more information, see AWS Lambda Pricing.TipTo learn how to build serverless solutions, check out the Serverless Developer Guide.
    When to use Lambda
    Lambda is an ideal compute service for application scenarios that need to scale up rapidly, and scale down to
      zero when not in demand. For example, you can use Lambda for:
  
     
     
     
     
     
  
      File processing: Use Amazon Simple Storage Service (Amazon S3) to trigger Lambda data processing in real time after an upload.
    
      Stream processing: Use Lambda and Amazon Kinesis to process real-time streaming data for application activity tracking, transaction order processing, clickstream analysis, data cleansing, log filtering, indexing, social media analysis, Internet of Things (IoT) device data telemetry, and metering.
    
      Web applications: Combine Lambda with other AWS services to build powerful web applications that automatically scale up and down and run in a highly available configuration across multiple data centers.
    
      IoT backends: Build serverless backends using Lambda to handle web, mobile, IoT, and third-party API requests.
    
      Mobile backends: Build backends using Lambda and Amazon API Gateway  to authenticate and process API requests. Use AWS Amplify to easily integrate with your iOS, Android, Web, and React Native frontends.
    
    When using Lambda, you are responsible only for your code. Lambda manages the compute fleet that offers a
      balance of memory, CPU, network, and other resources to run your code. Because Lambda manages these resources, you
      cannot log in to compute instances or customize the operating system on provided
        runtimes. Lambda performs operational and administrative activities on your behalf, including managing
      capacity, monitoring, and logging your Lambda functions.
   
    Key features
    The following key features help you develop Lambda applications that are scalable, secure, and easily
      extensible:

    
    
       

       
      
       
      
       
      
       
  
       
      
       
           
       

       
      
       

       

       
      
    
        Environment variables
        
          Use environment variables to adjust your function's behavior without updating code.
        
      
        Versions
        
          Manage the deployment of your functions with versions, so that, for example, a new function can be used for beta testing without affecting users of the stable production version.
        
      
        Container images
        
          Create a container image for a Lambda function by using an AWS provided base image or an alternative base
            image so that you can reuse your existing container tooling or deploy larger workloads that rely on sizable dependencies, such as machine learning.
        
      
        Lambda layers
        
          Package libraries and other dependencies to reduce the size of deployment archives and makes it faster to deploy your code.
        
      
        Lambda extensions
        
          Augment your Lambda functions with tools for monitoring, observability, security, and governance.
        
      
        Function URLs
        
          Add a dedicated HTTP(S) endpoint to your Lambda function.
        
      
        Response streaming
        
          Configure your Lambda function URLs to stream response payloads back to clients from Node.js functions, to improve time to first byte (TTFB) performance or to return larger payloads.
        
      
        Concurrency and scaling controls
        
          Apply fine-grained control over the scaling and responsiveness of your production applications.
        
      
        Code signing
        
          Verify that only approved developers publish unaltered, trusted code in your Lambda functions 
        
      
        Private networking
        
          Create a private network for resources such as databases, cache instances, or internal services.
        
      
        File system
        
          Configure a function to mount an Amazon Elastic File System (Amazon EFS) to a local directory, so that your function code can access and modify shared resources safely and at high concurrency.
        
      
        Lambda SnapStart
        
          Lambda SnapStart can provide as low as sub-second startup performance, typically with no changes to your function code.
        
      
  Document ConventionsCreate your first functionDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideCreate environment variablesExample scenario for environment variablesRetrieve environment variablesDefined runtime environment variablesWorking with Lambda environment variablesYou can use environment variables to adjust your function's behavior without updating code. An environment
    variable is a pair of strings that is stored in a function's version-specific configuration. The Lambda runtime makes
    environment variables available to your code and sets additional environment variables that contain information
    about the function and invocation request.NoteTo increase security, we recommend that you use AWS Secrets Manager instead of environment variables to store
      database credentials and other sensitive information like API keys or authorization tokens. For more information, see Use Secrets Manager secrets in Lambda functions.Environment variables are not evaluated before the function invocation. Any value you define is considered a
    literal string and not expanded. Perform the variable evaluation in your function code.
    Creating Lambda environment variables
  You can configure environment variables in Lambda using the Lambda console, the AWS Command Line Interface (AWS CLI), AWS Serverless Application Model (AWS SAM), or using an AWS SDK.
 
   Console
       You define environment variables on the unpublished version of your function. When you publish a version, the
         environment variables are locked for that version along with other version-specific configuration settings.
       You create an environment variable for your function by defining a key and a value. Your function uses the
         name of the key to retrieve the value of the environment variable.
       To set environment variables in the Lambda consoleOpen the Functions page of the Lambda console.
           Choose a function.
         
           Choose the Configuration tab, then choose Environment variables.
         
           Under Environment variables, choose Edit.
         
           Choose Add environment variable.
         
           Enter a key and value.
           
             Requirements
              
              
              
              
           
               Keys start with a letter and are at least two characters.
             
               Keys only contain letters, numbers, and the underscore character (_).
             
               Keys aren't reserved by Lambda.
             
               The total size of all environment variables doesn't exceed 4 KB.
             
         
           Choose Save.
         
       To generate a list of environment variables in the console code editorYou can generate a list of environment variables in the Lambda code editor. This is a quick way to reference
           your environment variables while you code.
           Choose the Code tab.
         
           Scroll down to the ENVIRONMENT VARIABLES section of the code editor. Existing environment variables are listed here:
           
              
               
              
              
           
         
           To create new environment variables, choose the choose the plus sign (
                
                 
                
                
             ):
           
              
               
              
              
           
         
       Environment variables remain encrypted when listed in the console code editor. If you enabled encryption helpers for encryption in transit, then those settings remain unchanged. For more information, see Securing Lambda environment variables.
The environment variables list is read-only and is available only on the Lambda console. This file is not included when you download the function's .zip file archive, and you can't add environment variables by uploading this file.
     
   AWS CLI
       The following example sets two environment variables on a function named my-function.
       aws lambda update-function-configuration \
  --function-name my-function \
  --environment "Variables={BUCKET=amzn-s3-demo-bucket,KEY=file.txt}"
       When you apply environment variables with the update-function-configuration command, the entire
         contents of the Variables structure is replaced. To retain existing environment variables when you
         add a new one, include all existing values in your request.
       To get the current configuration, use the get-function-configuration command.
       aws lambda get-function-configuration \
  --function-name my-function
       You should see the following output:
       {
    "FunctionName": "my-function",
    "FunctionArn": "arn:aws:lambda:us-east-2:111122223333:function:my-function",
    "Runtime": "nodejs22.x",
    "Role": "arn:aws:iam::111122223333:role/lambda-role",
    "Environment": {
        "Variables": {
            "BUCKET": "amzn-s3-demo-bucket",
            "KEY": "file.txt"
        }
    },
    "RevisionId": "0894d3c1-2a3d-4d48-bf7f-abade99f3c15",
    ...
}
       You can pass the revision ID from the output of get-function-configuration as a parameter to
         update-function-configuration. This ensures that the values don't change between when you read the
         configuration and when you update it.
       
       To configure a function's encryption key, set the KMSKeyARN option.
       aws lambda update-function-configuration \
  --function-name my-function \
  --kms-key-arn arn:aws:kms:us-east-2:111122223333:key/055efbb4-xmpl-4336-ba9c-538c7d31f599
     
   AWS SAM
       You can use the  AWS Serverless Application Model to configure environment variables for your function. Update the Environment and Variables properties in your template.yaml file and then run sam deploy.
       Example template.yamlAWSTemplateFormatVersion: '2010-09-09'
Transform: AWS::Serverless-2016-10-31
Description: An AWS Serverless Application Model template describing your function.
Resources:
  my-function:
    Type: AWS::Serverless::Function
    Properties:
      CodeUri: .
      Description: ''
      MemorySize: 128
      Timeout: 120
      Handler: index.handler
      Runtime: nodejs22.x
      Architectures:
        - x86_64
      EphemeralStorage:
        Size: 10240
      Environment:
        Variables:
          BUCKET: amzn-s3-demo-bucket
          KEY: file.txt
      # Other function properties...   
     
   AWS SDKs
       To manage environment variables using an AWS SDK, use the following API operations.
         
         
       
       
       
    UpdateFunctionConfigurationGetFunctionConfigurationCreateFunction
       To learn more, refer to the AWS SDK documentation for your preferred programming language.
     
 
   
    Example scenario for environment variables
    
    You can use environment variables to customize function behavior in your test environment and production
      environment. For example, you can create two functions with the same code but different configurations. One
      function connects to a test database, and the other connects to a production database. In this situation, you use
      environment variables to pass the hostname and other connection details for the database to the function. 
    The following example shows how to define the database host and database name as environment variables.
    
       
        
       
       
    
    If you want your test environment to generate more debug information than the production environment, you
      could set an environment variable to configure your test environment to use more verbose logging or more detailed
      tracing.
    For example, in your test environment, you could set an environment variable with the key LOG_LEVEL and a value indicating a log level of 
      debug or trace. In your Lambda function's code, you can then use this environment variable to set the log level.
    The following code examples in Python and Node.js illustrate how you can achieve this. These examples assume your environment variable has a 
      value of DEBUG in Python or debug in Node.js.
    
      Python
          Example Python code to set log levelimport os
import logging

# Initialize the logger
logger = logging.getLogger()

# Get the log level from the environment variable and default to INFO if not set
log_level = os.environ.get('LOG_LEVEL', 'INFO')

# Set the log level
logger.setLevel(log_level)

def lambda_handler(event, context):
    # Produce some example log outputs
    logger.debug('This is a log with detailed debug information - shown only in test environment')
    logger.info('This is a log with standard information - shown in production and test environments')
    

        
      Node.js (ES module format)
          Example Node.js code to set log levelThis example uses the winston logging library. Use npm to add this library to your function's deployment package. For more information, see
              Creating a .zip deployment package with dependencies.import winston from 'winston';

// Initialize the logger using the log level from environment variables, defaulting to INFO if not set
const logger = winston.createLogger({
   level: process.env.LOG_LEVEL || 'info',
   format: winston.format.json(),
   transports: [new winston.transports.Console()]
});

export const handler = async (event) => {
   // Produce some example log outputs
   logger.debug('This is a log with detailed debug information - shown only in test environment');
   logger.info('This is a log with standard information - shown in production and test environment');
   
};
        
    
   
    Retrieving Lambda environment variables
    To retrieve environment variables in your function code, use the standard method for your programming
      language.
    
      Node.js
          let region = process.env.AWS_REGION
        
      Python
          import os
  region = os.environ['AWS_REGION']
          NoteIn some cases, you may need to use the following format:region = os.environ.get('AWS_REGION')
        
      Ruby
          region = ENV["AWS_REGION"]
        
      Java
          String region = System.getenv("AWS_REGION");
        
      Go
          var region = os.Getenv("AWS_REGION")
        
      C#
          string region = Environment.GetEnvironmentVariable("AWS_REGION");
        
      PowerShell
          $region = $env:AWS_REGION
        
    
    
    Lambda stores environment variables securely by encrypting them at rest. You can configure Lambda to use a different encryption key, encrypt
      environment variable values on the client side, or set environment variables in an AWS CloudFormation template with
      AWS Secrets Manager.
   
    Defined runtime environment variables
    Lambda runtimes set several environment variables during initialization.
      Most of the environment variables provide information about the function or runtime. The keys for these
      environment variables are reserved and cannot be set in your function configuration.
    
      Reserved environment variables
       
       
       
       
       
       
       
       
       
       
       
       
       
       
    
        _HANDLER – The handler location configured on the function.
      
        _X_AMZN_TRACE_ID – The X-Ray tracing
          header. This environment variable changes with each invocation.
        
           
           
        
            This environment variable is not defined for OS-only runtimes (the provided runtime family).
              You can set _X_AMZN_TRACE_ID for custom runtimes using the
              Lambda-Runtime-Trace-Id response header from the
              Next invocation.
          
            For Java runtime versions 17 and later, this environment variable is not used.
              Instead, Lambda stores tracing information in the com.amazonaws.xray.traceHeader
              system property.
          
      
        AWS_DEFAULT_REGION – The default AWS Region where the Lambda function is executed.
      
        AWS_REGION – The AWS Region where the Lambda function is executed. If defined, this value overrides the AWS_DEFAULT_REGION.
        
           
        
            For more information about using the AWS Region environment variables with AWS SDKs, see AWS Region 
              in the AWS SDKs and Tools Reference Guide.
          
      
        AWS_EXECUTION_ENV – The runtime identifier,
          prefixed by AWS_Lambda_ (for example, AWS_Lambda_java8). This environment variable is not defined for OS-only runtimes (the provided runtime family).
      
        AWS_LAMBDA_FUNCTION_NAME – The name of the function.
      
        AWS_LAMBDA_FUNCTION_MEMORY_SIZE – The amount of memory available to the function in
          MB.
      
        AWS_LAMBDA_FUNCTION_VERSION – The version of the function being
          executed.
      
        AWS_LAMBDA_INITIALIZATION_TYPE – The initialization type of the function, which is on-demand, provisioned-concurrency, or snap-start. For information, see  Configuring provisioned concurrency or Improving startup performance with Lambda SnapStart.
      
        AWS_LAMBDA_LOG_GROUP_NAME, AWS_LAMBDA_LOG_STREAM_NAME – The name of the
          Amazon CloudWatch Logs group and stream for the function. The AWS_LAMBDA_LOG_GROUP_NAME and AWS_LAMBDA_LOG_STREAM_NAME environment variables are not available in Lambda SnapStart functions.
      
        AWS_ACCESS_KEY, AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY, AWS_SESSION_TOKEN
          – The access keys obtained from the function's execution
            role.
      
        AWS_LAMBDA_RUNTIME_API – (Custom runtime) The
          host and port of the runtime API.
      
        LAMBDA_TASK_ROOT – The path to your Lambda function code.
      
        LAMBDA_RUNTIME_DIR – The path to runtime libraries.
      
    The following additional environment variables aren't reserved and can be extended in your function
      configuration.
    
      Unreserved environment variables
       
       
       
       
       
       
       
       
       
       
    
        LANG – The locale of the runtime (en_US.UTF-8).
      
        PATH – The execution path
          (/usr/local/bin:/usr/bin/:/bin:/opt/bin).
      
        LD_LIBRARY_PATH – The system library path
          (/var/lang/lib:/lib64:/usr/lib64:$LAMBDA_RUNTIME_DIR:$LAMBDA_RUNTIME_DIR/lib:$LAMBDA_TASK_ROOT:$LAMBDA_TASK_ROOT/lib:/opt/lib).
      
        NODE_PATH – (Node.js) The Node.js library path
          (/opt/nodejs/node12/node_modules/:/opt/nodejs/node_modules:$LAMBDA_RUNTIME_DIR/node_modules).
      
        PYTHONPATH – (Python) The Python
          library path ($LAMBDA_RUNTIME_DIR).
      
        GEM_PATH – (Ruby) The Ruby library path
          ($LAMBDA_TASK_ROOT/vendor/bundle/ruby/3.3.0:/opt/ruby/gems/3.3.0).
      
        AWS_XRAY_CONTEXT_MISSING – For X-Ray tracing, Lambda sets this to
          LOG_ERROR to avoid throwing runtime errors from the X-Ray SDK.
      
        AWS_XRAY_DAEMON_ADDRESS – For X-Ray tracing, the IP address and port of the X-Ray
          daemon.
      
        AWS_LAMBDA_DOTNET_PREJIT – (.NET) Set this variable to enable or
          disable .NET specific runtime optimizations. Values include always, never, and
          provisioned-concurrency. For more information, see Configuring provisioned concurrency for a function.
      
        TZ – The environment's time zone (:UTC). The execution environment uses
          NTP to synchronize the system clock.
      
    The sample values shown reflect the latest runtimes. The presence of specific variables or their values can
      vary on earlier runtimes.
  Document ConventionsTimeoutSecuring environment variablesDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideCreating function versionsUsing versionsGranting permissionsManage Lambda function versionsYou can use versions to manage the deployment of your functions. For example, you can publish a new version of a
    function for beta testing without affecting users of the stable production version. Lambda creates a new version of
    your function each time that you publish the function. The new version is a copy of the unpublished version of the
    function. The unpublished version is named $LATEST.Importantly, any time you deploy your function code, you overwrite the current code in $LATEST.
    To save the current iteration of $LATEST, create a new function version. If $LATEST
    is identical to a previously published version, you won't be able to create a new version until you deploy changes
    to $LATEST. These changes can include updating the code, or modifying the function configuration settings.After you publish a function version, its code, runtime, architecture, memory, layers, and
    most other configuration settings are immutable. This means that you can't change these settings
    without publishing a new version from $LATEST. You can configure the following items for a
    published function version:
     
     
     
     
     
  TriggersDestinationsProvisioned concurrencyAsynchronous invocationDatabase connections and proxiesNoteWhen using runtime management controls with Auto
      mode, the runtime version used by the function version is updated automatically. 
      When using Function update or Manual mode, the runtime version is not updated.
      For more information, see Understanding how Lambda manages runtime version updates.SectionsCreating function versionsUsing versionsGranting permissions
    Creating function versions
    You can change the function code and settings only on the unpublished version of a function. When you publish
      a version, Lambda locks the code and most of the settings to maintain a consistent experience for users of that
      version.
    You can create a function version using the Lambda console.
    To create a new function versionOpen the Functions page of the Lambda console.
        Choose a function and then choose the Versions tab.
      
        On the versions configuration page, choose Publish new
          version.
      
        (Optional) Enter a version description.
      
        Choose Publish.
      
    Alternatively, you can publish a version of a function using the PublishVersion API operation.
    The following AWS CLI command publishes a new version of a function. The response returns configuration information
      about the new version, including the version number and the function ARN with the version suffix.
    aws lambda publish-version --function-name my-function
    You should see the following output:
{
  "FunctionName": "my-function",
  "FunctionArn": "arn:aws:lambda:us-east-2:123456789012:function:my-function:1",
  "Version": "1",
  "Role": "arn:aws:iam::123456789012:role/lambda-role",
  "Handler": "function.handler",
  "Runtime": "nodejs22.x",
  ...
}
    NoteLambda assigns monotonically increasing sequence numbers for versioning. Lambda never reuses version
      numbers, even after you delete and recreate a function.
   
    Using versions
    You can reference your Lambda function using either a qualified ARN or an unqualified ARN.
    
       
       
    
        Qualified ARN – The function ARN with a version suffix. The
          following example refers to version 42 of the helloworld function.
        arn:aws:lambda:aws-region:acct-id:function:helloworld:42       
      
        Unqualified ARN – The function ARN without a version suffix.
        arn:aws:lambda:aws-region:acct-id:function:helloworld
      
    You can use a qualified or an unqualified ARN in all relevant API operations. However, you can't use an
      unqualified ARN to create an alias.
    If you decide not to publish function versions, you can invoke the function using either the qualified or
      unqualified ARN in your event source mapping. When you invoke
      a function using an unqualified ARN, Lambda implicitly invokes $LATEST.
    Lambda publishes a new function version only if the code has never been published, or if
      the code has changed from the last published version. If there is no change, the function
      version remains at the last published version.
    The qualified ARN for each Lambda function version is unique. After you publish a version, you can't change the
      ARN or the function code.
   
    Granting permissions
    You can use a resource-based policy or an identity-based policy to grant access to your function. The scope
      of the permission depends on whether you apply the policy to a function or to one version of a function. For more
      information about function resource names in policies, see Fine-tuning the Resources and Conditions sections of policies. 
    You can simplify the management of event sources and AWS Identity and Access Management (IAM) policies by using function aliases. For
      more information, see Create an alias for a Lambda function.
  Document ConventionsWeighted aliasesTagsDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideRequirementsUsing an AWS base imageUsing an AWS OS-only base imageUsing a non-AWS base imageRuntime interface clientsAmazon ECR permissionsFunction lifecycleCreate a Lambda function using a container imageYour AWS Lambda function's code consists of scripts or compiled programs and their dependencies. 
You use a deployment package to deploy your function code to Lambda. Lambda supports two types of deployment packages: 
container images and .zip file archives. There are three ways to build a container image for a Lambda function:
     
	 
     
  
      Using an AWS base image for Lambda
      The AWS base images are preloaded with a language runtime, a runtime interface client to manage the interaction between Lambda and your function code, and a runtime interface emulator for local testing.
    
      Using an AWS OS-only base image
      AWS OS-only base images contain an Amazon Linux distribution and the runtime interface emulator. These images are commonly used to create container images for compiled languages, such as Go and Rust, and for a language or language version that Lambda doesn't provide a base image for, such as Node.js 19. You can also use OS-only base images to implement a custom runtime. To make the image compatible with Lambda, you must include a runtime interface client for your language in the image.
    
      Using a non-AWS base image
      You can use an alternative base image from another container registry, such as Alpine Linux or Debian. You can also use a custom image created by your organization. To make the image compatible with Lambda, you must include a runtime interface client for your language in the image.
    TipTo reduce the time it takes for Lambda container functions to become active, see Use multi-stage builds in the Docker documentation. To build efficient container images, follow the Best practices for writing Dockerfiles.To create a Lambda function from a container image, build your image locally and upload it to an Amazon Elastic Container Registry (Amazon ECR) repository. Then, specify the repository URI when you create the function. The Amazon ECR repository must be in the same AWS Region as the Lambda function. You can create a function using an image in a different AWS account, as long as the image is in the same Region as the Lambda function. For more information, see  Amazon ECR cross-account permissions.NoteLambda does not support Amazon ECR FIPS endpoints for container images. If your repository URI includes
      ecr-fips, you are using a FIPS endpoint. Example: 111122223333.dkr.ecr-fips.us-east-1.amazonaws.com.This page explains the base image types and requirements for creating Lambda-compatible container images.NoteYou cannot change the deployment package type (.zip or container image) for an existing function. For example, you cannot convert a container image function to use a .zip file archive. You must create a new function.TopicsRequirementsUsing an AWS base image for LambdaUsing an AWS OS-only base imageUsing a non-AWS base imageRuntime interface clientsAmazon ECR permissionsFunction lifecycle
    Requirements
    Install the AWS CLI version 2 and the Docker CLI. 
      Additionally, note the following requirements:
    
       
       
       
       
       
    
        The container image must implement the Using the Lambda runtime API for custom runtimes. The AWS
          open-source runtime interface clients implement the API. You can
          add a runtime interface client to your preferred base image to make it compatible with Lambda.
      
        The container image must be able to run on a read-only file system. Your function code can access a
          writable /tmp directory with between 512 MB and 10,240 MB, in 1-MB increments, of storage.  
      
        The default Lambda user must be able to read all the files required to run your function code. Lambda
          follows security best practices by defining a default Linux user with least-privileged permissions. This means that you don't need to specify a USER  in your Dockerfile. Verify
          that your application code does not rely on files that other Linux users are restricted from running.
      
        Lambda supports only Linux-based container images.
      
        Lambda provides multi-architecture base images. However, the image you build for your function must target
          only one of the architectures. Lambda does not support functions that use multi-architecture container
          images.
      
   
    Using an AWS base image for Lambda
    You can use one of the AWS base images for Lambda to build the container image for your
      function code. The base images are preloaded with a language runtime and other components
      required to run a container image on Lambda. You add your function code and dependencies to the
      base image and then package it as a container image.
    AWS periodically provides updates to the AWS base images for Lambda. If your Dockerfile includes the
      image name in the FROM property, your Docker client pulls the latest version of the image from the Amazon ECR repository. To
      use the updated base image, you must rebuild your container image and update the function code.
      The Node.js 20, Python 3.12, Java 21, .NET 8, Ruby 3.3, and later base images are based on the Amazon Linux 2023 minimal container image. Earlier base images use Amazon Linux 2. AL2023 provides several advantages over Amazon Linux 2, including a smaller deployment footprint and updated versions of libraries such as glibc.
    AL2023-based images use microdnf (symlinked as dnf) as the package manager instead of yum, which is the default package manager in Amazon Linux 2. microdnf is a standalone implementation of dnf. For a list of packages that are included in AL2023-based images, refer to the Minimal Container columns in Comparing packages installed on Amazon Linux 2023 Container Images. For more information about the differences between AL2023 and Amazon Linux 2, see Introducing the Amazon Linux 2023 runtime for AWS Lambda on the AWS
      Compute Blog.    
    NoteTo run AL2023-based images locally, including with AWS Serverless Application Model (AWS SAM), you must use Docker version 20.10.10 or later.  
    To build a container image using an AWS base image, choose the instructions for your preferred language:
    
       
       
       
       
       
       
       
    
        Node.js
      
        TypeScript (uses a Node.js base image) 
      
        Python
      
        Java 
      
        Go
      
        .NET
      
        Ruby
      
   
    Using an AWS OS-only base image
    AWS OS-only base images contain an Amazon Linux distribution and the runtime interface emulator. These images are commonly used to create container images for compiled languages, such as Go and Rust, and for a language or language version that Lambda doesn't provide a base image for, such as Node.js 19. You can also use OS-only base images to implement a custom runtime. To make the image compatible with Lambda, you must include a runtime interface client for your language in the image.
    
          
            Tags
            Runtime
            Operating system
            Dockerfile
            Deprecation
          
        
      
            al2023
            OS-only Runtime
            Amazon Linux 2023
            Dockerfile
                for OS-only Runtime on GitHub
            
                          Jun 30, 2029
            
              
          
      
            al2
            OS-only Runtime
            Amazon Linux 2
            Dockerfile
                for OS-only Runtime on GitHub
            
                          Jun 30, 2026
            
              
          
    
    Amazon Elastic Container Registry Public Gallery: gallery.ecr.aws/lambda/provided
     
    Using a non-AWS base image
    Lambda
      supports any image that conforms to one of the following image manifest formats:
    
       
       
    Docker image manifest V2, schema 2 (used with Docker version 1.10 and newer)Open Container Initiative (OCI) Specifications (v1.0.0 and up)
    Lambda supports a maximum uncompressed image size of 10 GB, including all layers.
    NoteTo make the image compatible with Lambda, you must include a runtime interface client for your language in the image.
   
    Runtime interface clients
    If you use an OS-only base image or an alternative base image, you must include a runtime interface client in your image. The runtime interface client must extend the Using the Lambda runtime API for custom runtimes, which manages the interaction between Lambda and your function code. AWS provides open-source runtime interface clients for the following languages:
    
  
   
  
   
  
   
  
   
  
   
  
   
  
     

    
      Node.js
    
  
    
      Python
    
  
    
      Java
    
  
    
      .NET
    
  
    
      Go
    
  
    
      Ruby
    
  
    
      Rust – The Rust runtime client is an experimental package. It is subject to change and intended only for evaluation purposes.
    
  
    If you're using a language that doesn't have an AWS-provided runtime interface client, you must create your own.
   
    Amazon ECR permissions
    Before you create a Lambda function from a container image, you must build the image locally and upload it to an Amazon ECR repository. When you create the function, specify the Amazon ECR repository URI.
    Make sure that the permissions for the user or role that creates the function includes GetRepositoryPolicy and SetRepositoryPolicy.
    For example, use the IAM console to create a role with the following policy:
    {
  "Version": "2012-10-17",
  "Statement": [
    {
      "Sid": "VisualEditor0",
      "Effect": "Allow",
      "Action": [
        "ecr:SetRepositoryPolicy",
        "ecr:GetRepositoryPolicy"
      ],
      "Resource": "arn:aws:ecr:us-east-1:111122223333:repository/hello-world"
    }
  ]
}
     
      Amazon ECR repository policies
      For a function in the same account as the container image in Amazon ECR, you can add ecr:BatchGetImage
        and ecr:GetDownloadUrlForLayer permissions to your Amazon ECR repository policy. The following example shows the
        minimum policy:
      {
        "Sid": "LambdaECRImageRetrievalPolicy",
        "Effect": "Allow",
        "Principal": {
          "Service": "lambda.amazonaws.com"
        },
        "Action": [
          "ecr:BatchGetImage",
          "ecr:GetDownloadUrlForLayer"
        ]
    }   
      For more information about Amazon ECR
        repository permissions, see Private repository policies in the
        Amazon Elastic Container Registry User Guide.
      If the Amazon ECR repository does not include these permissions, Lambda attempts to add them automatically. Lambda can add
        permissions only if the principal calling Lambda has ecr:getRepositoryPolicy and
          ecr:setRepositoryPolicy permissions. 
      To view or edit your Amazon ECR repository permissions, follow the directions in Setting a private repository policy statement in the
          Amazon Elastic Container Registry User Guide.
       
         Amazon ECR cross-account permissions
        A different account in the same region can create a function that uses a container image owned by your
          account. In the following example, your Amazon ECR repository permissions policy needs the following statements to
          grant access to account number 123456789012.
        
           
           
        CrossAccountPermission – Allows account 123456789012 to create and update Lambda
              functions that use images from this ECR repository.LambdaECRImageCrossAccountRetrievalPolicy – Lambda will eventually set a
              function's state to inactive if it is not invoked for an extended period. This statement is required so that
              Lambda can retrieve the container image for optimization and caching on behalf of the function owned by
              123456789012.  
        Example — Add cross-account permission to your repository{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Sid": "CrossAccountPermission",
      "Effect": "Allow",
      "Action": [
        "ecr:BatchGetImage",
        "ecr:GetDownloadUrlForLayer"
      ],
      "Principal": {
        "AWS": "arn:aws:iam::123456789012:root"
      }
    },
    {
      "Sid": "LambdaECRImageCrossAccountRetrievalPolicy",
      "Effect": "Allow",
      "Action": [
        "ecr:BatchGetImage",
        "ecr:GetDownloadUrlForLayer"
      ],
      "Principal": {
        "Service": "lambda.amazonaws.com"
      },
      "Condition": {
        "StringLike": {
          "aws:sourceARN": "arn:aws:lambda:us-east-1:123456789012:function:*"
        }
      }
    }
  ]
}
        To give access to multiple accounts, you add the account IDs to the Principal list in the
            CrossAccountPermission policy and to the Condition evaluation list in the
            LambdaECRImageCrossAccountRetrievalPolicy.
        If you are working with multiple accounts in an AWS Organization, we recommend that you enumerate each
          account ID in the ECR permissions policy. This approach aligns with the AWS security best practice of setting
          narrow permissions in IAM policies.
        In addition to Lambda permissions, the user or role that creates the function must also have BatchGetImage and GetDownloadUrlForLayer permissions.
       
     
   
    Function lifecycle
    After you upload a new or updated container image, Lambda optimizes the image before the function can process invocations. The
      optimization process can take a few seconds. The function remains in the Pending state until the
      process completes, when the state transitions to Active. You can't invoke the function until it reaches the Active state. 
    If a function is not invoked for multiple weeks, Lambda reclaims its optimized version, and the function
      transitions to the Inactive state. To reactivate the function, you must invoke it. Lambda rejects the
      first invocation and the function enters the Pending state until Lambda re-optimizes the image. The
      function then returns to the Active state.
    Lambda periodically fetches the associated container image from the Amazon ECR repository. If the
      corresponding container image no longer exists on Amazon ECR or permissions are revoked, the function enters the Failed state, and
      Lambda returns a failure for any function invocations.
    You can use the Lambda API to get information about a function's state. For more information, see Lambda function states.
  Document ConventionsEncryptionMemoryDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideHow to use layersLayers and layer versionsManaging Lambda dependencies with layersA Lambda layer is a .zip file archive that contains supplementary code or data.
  Layers usually contain library dependencies, a custom runtime,
  or configuration files. There are multiple reasons why you might consider using layers:
     
     
     
     
  
      To reduce the size of your deployment packages.
        Instead of including all of your function dependencies along with your function code
        in your deployment package, put them in a layer. This keeps deployment packages small
        and organized.
    
      To separate core function logic from dependencies.
        With layers, you can update your function dependencies independent of your function code,
        and vice versa. This promotes separation of concerns and helps you focus on your function
        logic.
    
      To share dependencies across multiple functions.
        After you create a layer, you can apply it to any number of functions in your account.
        Without layers, you need to include the same dependencies in each individual deployment
        package.
    
      To use the Lambda console code editor. The code
        editor is a useful tool for testing minor function code updates quickly. However, you
        can’t use the editor if your deployment package size is too large. Using layers reduces
        your package size and can unlock usage of the code editor.
    If you're working with Lambda functions in Go or Rust, we recommend against using layers.
    For Go and Rust functions, you provide your function code as an executable, which includes your
    compiled function code along with all of its dependencies. Putting your dependencies in a
    layer forces your function to manually load additional assemblies during the initialization
    phase, which can increase cold start times. For optimal performance for Go and Rust functions,
    include your dependencies along with your deployment package.The following diagram illustrates the high-level architectural differences between two
    functions that share dependencies. One uses Lambda layers, and the other does not.
     
      
     
     
  When you add a layer to a function, Lambda extracts the layer contents into the /opt
    directory in your function’s execution environment.
    All natively supported Lambda runtimes include paths to specific directories within the
    /opt directory. This gives your function access to your layer content. For more
    information about these specific paths and how to properly package your layers, see
    Packaging your layer content.You can include up to five layers per function. Also, you can use layers only with Lambda functions
    deployed as a .zip file archive. For functions
    defined as a container image, package your preferred runtime
    and all code dependencies when you create the container image. For more information, see
    
    Working with Lambda layers and extensions in container images on the AWS Compute Blog.TopicsHow to use layersLayers and layer versionsPackaging your layer contentCreating and deleting layers in LambdaAdding layers to functionsUsing AWS CloudFormation with layersUsing AWS SAM with layers
    How to use layers
    To create a layer, package your dependencies into a .zip file, similar to how you
      create a normal deployment package. More
      specifically, the general process of creating and using layers involves these three steps:
    
       
       
       
    
        First, package your layer content. This means creating a
          .zip file archive. For more information, see Packaging your layer content.
      
        Next, create the layer in Lambda. For more information,
          see Creating and deleting layers in Lambda.
      
        Add the layer to your function(s). For more information,
          see Adding layers to functions.
      
   
    Layers and layer versions
    A layer version is an immutable snapshot of a specific version of a layer. When you create
      a new layer, Lambda creates a new layer version with a version number of 1. Each time you publish
      an update to the layer, Lambda increments the version number and creates a new layer version.
    Every layer version is identified by a unique Amazon Resource Name (ARN). When adding a layer
      to the function, you must specify the exact layer version you want to use.
  Document ConventionsApplication SignalsPackaging layersDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideExecution environmentImpact on performance and resources PermissionsAugment Lambda functions using Lambda extensionsYou can use Lambda extensions to augment your Lambda functions. For example, use Lambda extensions to integrate
    functions with your preferred monitoring, observability, security, and governance tools. You can choose from a broad
    set of tools that AWS Lambda Partners provides, or you can
    create your own Lambda extensions.Lambda supports external and internal extensions. An external extension runs as an independent process in the
    execution environment and continues to run after the function invocation is fully processed. Because extensions run
    as separate processes, you can write them in a different language than the function. All Lambda runtimes support extensions.An internal extension runs as part of the runtime process. Your function accesses internal extensions by using
    wrapper scripts or in-process mechanisms such as JAVA_TOOL_OPTIONS. For more information, see Modifying the runtime environment.You can add extensions to a function using the Lambda console, the AWS Command Line Interface (AWS CLI), or infrastructure as code
    (IaC) services and tools such as AWS CloudFormation, AWS Serverless Application Model (AWS SAM), and Terraform.You are charged for the execution time that the extension consumes (in 1 ms increments). There is no cost to
    install your own extensions. For more pricing information for extensions, see
    AWS Lambda Pricing. For pricing
    information for partner extensions, see those partners' websites. See AWS Lambda extensions partners
    for a list of official partner extensions.For a tutorial on extensions and how to use them with your Lambda functions, see the
    AWS Lambda Extensions Workshop.TopicsExecution environmentImpact on performance and resources PermissionsConfiguring Lambda extensionsAWS Lambda extensions partnersUsing the Lambda Extensions API to create extensionsAccessing real-time telemetry data for extensions using the Telemetry API
    Execution environment
    Lambda invokes your function in an execution environment, which
      provides a secure and isolated runtime environment. The execution environment manages the resources required to
      run your function and provides lifecycle support for the function's runtime and extensions.
    
The lifecycle of the execution environment includes the following phases:
      
         
         
         
         
      
          Init: In this phase, Lambda creates or
            unfreezes an execution environment with the configured resources, downloads the code for the function and
            all layers, initializes any extensions, initializes the runtime, and then runs the function’s initialization
            code (the code outside the main handler). The Init phase happens either during the first
            invocation, or in advance of function invocations if you have enabled provisioned concurrency.
          The Init phase is split into three sub-phases: Extension init, 
          Runtime init, and Function init. These sub-phases ensure that all extensions and the runtime complete their setup tasks before the function code runs.
          When Lambda SnapStart is activated, the Init phase happens when you publish a function version. Lambda saves a snapshot of the memory and disk state of the initialized execution environment, persists the encrypted snapshot, and caches it for low-latency access. If you have a before-checkpoint runtime hook, then the code runs at the end of Init phase.
        
        Restore (SnapStart only): When you first invoke a SnapStart function and as the function scales up, Lambda resumes new execution environments from the persisted snapshot instead of initializing the function from scratch. If you have an after-restore runtime hook, the code runs at the end of the Restore phase. You are charged for the duration of after-restore runtime hooks. The runtime must load and after-restore runtime hooks must complete within the timeout limit (10 seconds). Otherwise, you'll get a SnapStartTimeoutException. When the Restore phase completes, Lambda invokes the function handler (the Invoke phase).
        
          Invoke: In this phase, Lambda invokes the function handler.
            After the function runs to completion, Lambda prepares to handle another function
            invocation.
        
          Shutdown: This phase is triggered if the Lambda function does not
            receive any invocations for a period of time. In the Shutdown phase, Lambda shuts down
            the runtime, alerts the extensions to let them stop cleanly, and then removes the environment. Lambda
            sends a Shutdown event to each extension, which tells the extension that the environment is about
            to be shut down.
        

    During the Init phase, Lambda extracts layers containing extensions into the /opt
      directory in the execution environment. Lambda looks for extensions in the /opt/extensions/ directory,
      interprets each file as an executable bootstrap for launching the extension, and starts all extensions in
      parallel.
   
    Impact on performance and resources 
    The size of your function's extensions counts towards the deployment package size limit. For a .zip file
      archive, the total unzipped size of the function and all extensions cannot exceed the unzipped deployment package
      size limit of 250 MB.
    Extensions can impact the performance of your function because they share function resources such as CPU,
      memory, and storage. For example, if an extension performs compute-intensive operations, you may see your
      function's execution duration increase.
    Each extension must complete its initialization before Lambda invokes the function. Therefore, an extension
      that consumes significant initialization time can increase the latency of the function invocation.
    To measure the extra time that the extension takes after the function execution, you can use the
      PostRuntimeExtensionsDuration
      function metric. To measure the increase in memory used, you can use the
      MaxMemoryUsed metric. To understand the impact of a specific extension, you can run different
      versions of your functions side by side.
    NoteMaxMemoryUsed metric is one of the Metrics collected by Lambda Insights and not a Lambda native metric.
   
    Permissions
    Extensions have access to the same resources as functions. Because extensions are executed within the same
      environment as the function, permissions are shared between the function and the extension.
    For a .zip file archive, you can create an AWS CloudFormation template to simplify the task of attaching the same extension
      configuration—including AWS Identity and Access Management (IAM) permissions—to multiple functions.
  Document ConventionsLayers with AWS SAMConfiguring extensionsDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideCreating a function URL (console)Creating a function URL (AWS CLI)Adding a function URL to a CloudFormation templateCross-origin resource sharing (CORS)Throttling function URLsDeactivating function URLsDeleting function URLsCreating and managing Lambda function URLsA function URL is a dedicated HTTP(S) endpoint for your Lambda function. You can create and configure a function URL through the Lambda console or the Lambda API.TipLambda offers two ways to invoke your function through an HTTP endpoint: function URLs and Amazon API Gateway. If you're not sure which is the best method for your 
   use case, see Select a method to invoke your Lambda function using an HTTP request.When you create a function URL, Lambda automatically generates a unique URL endpoint for you. Once you create a function URL, its URL endpoint never changes. Function
      URL endpoints have the following format:https://<url-id>.lambda-url.<region>.on.awsNoteFunction URLs are not supported in the following AWS Regions: Asia Pacific (Hyderabad) (ap-south-2),  Asia Pacific (Melbourne) (ap-southeast-4), Asia Pacific (Malaysia) (ap-southeast-5), Canada West (Calgary) (ca-west-1), Europe (Spain) (eu-south-2), Europe (Zurich) (eu-central-2), Israel (Tel Aviv) (il-central-1), and Middle East (UAE) (me-central-1).Function URLs are dual stack-enabled, supporting IPv4 and IPv6. After you configure a function URL for your
    function, you can invoke your function through its HTTP(S) endpoint via a web browser, curl, Postman, or any HTTP
    client.NoteYou can access your function URL through the public Internet only. While Lambda functions do support
    AWS PrivateLink, function URLs do not.Lambda function URLs use resource-based policies for
    security and access control. Function URLs also support cross-origin resource sharing (CORS) configuration
    options.You can apply function URLs to any function alias, or to the $LATEST unpublished function version.
    You can't add a function URL to any other function version.The following section show how to create and manage a function URL using the Lambda console, AWS CLI, and AWS CloudFormation templateTopicsCreating a function URL (console)Creating a function URL (AWS CLI)Adding a function URL to a CloudFormation templateCross-origin resource sharing (CORS)Throttling function URLsDeactivating function URLsDeleting function URLsControl access to Lambda function URLsInvoking Lambda function URLsMonitoring Lambda function URLsSelect a method to invoke your Lambda function using an HTTP requestTutorial: Creating a webhook endpoint using a Lambda function URL
    Creating a function URL (console)
    Follow these steps to create a function URL using the console.
    
            Open the Functions page of the Lambda console.
          
            Choose the name of the function that you want to create the function URL for.
          
            Choose the Configuration tab, and then choose Function
              URL.
          
            Choose Create function URL.
          
            For Auth type, choose AWS_IAM or
                NONE. For more information about function URL authentication, see Access control.
          
            (Optional) Select Configure cross-origin resource sharing (CORS), and then configure
              the CORS settings for your function URL. For more information about CORS, see Cross-origin resource sharing (CORS).
          
            Choose Save.
          This creates a function URL for the $LATEST unpublished version of your function. The function URL
          appears in the Function overview section of the console.
    
            Open the Functions page of the Lambda console.
          
            Choose the name of the function with the alias that you want to create the function URL for.
          
            Choose the Aliases tab, and then choose the name of the alias that you want to create
              the function URL for.
          
            Choose the Configuration tab, and then choose Function
              URL.
          
            Choose Create function URL.
          
            For Auth type, choose AWS_IAM or NONE.
              For more information about function URL authentication, see Access control.
          
            (Optional) Select Configure cross-origin resource sharing (CORS), and then configure
              the CORS settings for your function URL. For more information about CORS, see Cross-origin resource sharing (CORS).
          
            Choose Save.
          This creates a function URL for your function alias. The function URL appears in the console's Function
          overview section for your alias.
    To create a new function with a function URL (console)
            Open the Functions page of the Lambda console.
          
            Choose Create function.
          
            Under Basic information, do the following:
            
                For Function name, enter a name for your function, such as
                    my-function.
              
                For Runtime, choose the language runtime that you prefer, such as
                    Node.js 18.x.
              
                For Architecture, choose either x86_64 or
                    arm64.
              
                Expand Permissions, then choose whether to create a new execution role or use
                  an existing one.
              
          
            Expand Advanced settings, and then select Function URL.
          
            For Auth type, choose AWS_IAM or NONE.
              For more information about function URL authentication, see Access control.
          
            (Optional) Select Configure cross-origin resource sharing (CORS). By selecting this
              option during function creation, your function URL allows requests from all origins by default. You can edit
              the CORS settings for your function URL after creating the function. For more information about CORS, see
              Cross-origin resource sharing (CORS).
          
            Choose Create function.
          This creates a new function with a function URL for the $LATEST
          unpublished version of the function. The function URL appears in the Function
            overview section of the console.
   
    Creating a function URL (AWS CLI)
    To create a function URL for an existing Lambda function using the AWS Command Line Interface (AWS CLI), run the following
      command:
    aws lambda create-function-url-config \
    --function-name my-function \
    --qualifier prod \ // optional
    --auth-type AWS_IAM
    --cors-config {AllowOrigins="https://example.com"} // optional
    This adds a function URL to the prod qualifier for the function
        my-function. For more information about these configuration parameters, see
      CreateFunctionUrlConfig in the API reference.
    NoteTo create a function URL via the AWS CLI, the function must already exist.
   
    Adding a function URL to a CloudFormation template
    To add an AWS::Lambda::Url resource to your AWS CloudFormation template, use the following syntax:
     
      JSON
      {
  "Type" : "AWS::Lambda::Url",
  "Properties" : {
      "AuthType" : String,
      "Cors" : Cors,
      "Qualifier" : String,
      "TargetFunctionArn" : String
    }
}
     
     
      YAML
      Type: AWS::Lambda::Url
Properties: 
  AuthType: String
  Cors: 
    Cors
  Qualifier: String
  TargetFunctionArn: String
     
     
      Parameters
      
         
         
         
         
      (Required) AuthType – Defines the type of authentication for your function URL. Possible
            values are either AWS_IAM or NONE. To restrict access to authenticated users
            only, set to AWS_IAM. To bypass IAM authentication and allow any user to make requests to
            your function, set to NONE.
          (Optional) Cors – Defines the CORS settings for
            your function URL. To add Cors to your AWS::Lambda::Url resource in CloudFormation,
            use the following syntax.
          
          Example AWS::Lambda::Url.Cors (JSON){
  "AllowCredentials" : Boolean,
  "AllowHeaders" : [ String, ... ],
  "AllowMethods" : [ String, ... ],
  "AllowOrigins" : [ String, ... ],
  "ExposeHeaders" : [ String, ... ],
  "MaxAge" : Integer
}
          Example AWS::Lambda::Url.Cors (YAML)  AllowCredentials: Boolean
  AllowHeaders: 
    - String
  AllowMethods: 
    - String
  AllowOrigins: 
    - String
  ExposeHeaders: 
    - String
  MaxAge: Integer
        (Optional) Qualifier – The alias name.(Required) TargetFunctionArn – The name or Amazon Resource Name (ARN) of the Lambda function.
          Valid name formats include the following:
          
             
             
             
          Function name – my-functionFunction ARN –
              arn:aws:lambda:us-west-2:123456789012:function:my-functionPartial ARN – 123456789012:function:my-function
        
     
   
    Cross-origin resource sharing (CORS)
    To define how different origins can access your function URL, use cross-origin resource sharing (CORS). We
      recommend configuring CORS if you intend to call your function URL from a different domain. Lambda supports the
      following CORS headers for function URLs.
    
          
            CORS header
            CORS configuration property
            Example values
          
        
          
            
              
                Access-Control-Allow-Origin
            
            
              AllowOrigins
            
            
              * (allow all origins)
              https://www.example.com
              http://localhost:60905
            
          
          
            
              
                Access-Control-Allow-Methods
            
            
              AllowMethods
            
            
              GET, POST, DELETE, *
            
          
          
            
              
                Access-Control-Allow-Headers
            
            
              AllowHeaders
            
            
              Date, Keep-Alive, X-Custom-Header
            
          
          
            
              
                Access-Control-Expose-Headers
            
            
              ExposeHeaders
            
            
              Date, Keep-Alive, X-Custom-Header
            
          
          
            
              
                Access-Control-Allow-Credentials
            
            
              AllowCredentials
            
            
              TRUE
            
          
          
            
              
                Access-Control-Max-Age
            
            
              MaxAge
            
            
              5 (default), 300
            
          
        
    When you configure CORS for a function URL using the Lambda console or the AWS CLI, Lambda automatically adds the
      CORS headers to all responses through the function URL. Alternatively, you can manually add CORS headers to your
      function response. If there are conflicting headers, the expected behavior depends on the
      type of request:
    
       
       
    
        For preflight requests such as OPTIONS requests, the configured CORS headers on the function URL take
          precedence. Lambda returns only these CORS headers in the response.
      
        For non-preflight requests such as GET or POST requests, Lambda returns both the configured CORS headers
          on the function URL, as well as the CORS headers returned by the function. This can result in duplicate CORS
          headers in the response. You may see an error similar to the following: The 'Access-Control-Allow-Origin'
          header contains multiple values '*, *', but only one is allowed.
      
    In general, we recommend configuring all CORS settings on the function URL, rather than sending CORS
      headers manually in the function response.
   
    Throttling function URLs
    Throttling limits the rate at which your function processes requests. This is useful in many situations, such
      as preventing your function from overloading downstream resources, or handling a sudden surge in requests.
    You can throttle the rate of requests that your Lambda function processes through a function URL by configuring
      reserved concurrency. Reserved concurrency limits the number of maximum concurrent invocations
      for your function. Your function's maximum request rate per second (RPS) is equivalent to 10 times the configured
      reserved concurrency. For example, if you configure your function with a reserved concurrency of 100, then the
      maximum RPS is 1,000.
    Whenever your function concurrency exceeds the reserved concurrency, your function URL returns an HTTP
      429 status code. If your function receives a request that exceeds the 10x RPS maximum based on your
      configured reserved concurrency, you also receive an HTTP 429 error. For more information about
      reserved concurrency, see Configuring reserved concurrency for a function.
   
    Deactivating function URLs
    In an emergency, you might want to reject all traffic to your function URL. To deactivate your function URL,
      set the reserved concurrency to zero. This throttles all requests to your function URL, resulting in HTTP
      429 status responses. To reactivate your function URL, delete the reserved concurrency
      configuration, or set the configuration to an amount greater than zero.
   
    Deleting function URLs
    When you delete a function URL, you can’t recover it. Creating a new function URL will result in a different URL address.
    NoteIf you delete a function URL with auth type NONE, Lambda doesn't automatically delete the
        associated resource-based policy. If you want to delete this policy, you must manually do so.
    
        Open the Functions page of the Lambda console.
      
        Choose the name of the function.
      
        Choose the Configuration tab, and then choose Function
          URL.
      
        Choose Delete.
      
        Enter the word delete into the field to confirm the deletion.
      
        Choose Delete.
      
    NoteWhen you delete a function that has a function URL, Lambda asynchronously deletes the function URL. If you immediately create a new function with the same name in the same account, it is possible that the original function URL will be mapped to the new function instead of deleted.
  Document ConventionsRecursive loop detectionAccess controlDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideBandwidth limits for response streamingResponse streaming for Lambda functionsYou can configure your Lambda function URLs to stream response payloads back to clients. Response
    streaming can benefit latency sensitive applications by improving time to first byte (TTFB)
    performance. This is because you can send partial responses back to the client as they become
    available. Additionally, you can use response streaming to build functions that return larger
    payloads. Response stream payloads have a soft limit of 20 MB as compared to the 6 MB limit for
    buffered responses. Streaming a response also means that your function doesn’t need to fit the entire 
    response in memory. For very large responses, this can reduce the amount of memory you need to 
    configure for your function. The speed at which Lambda streams your responses depends on the response size. The streaming rate for 
    the first 6MB of your function’s response is uncapped. For responses larger than 6MB, the remainder of the response 
    is subject to a bandwidth cap. For more information on streaming bandwidth, see Bandwidth limits for response streaming.Streaming responses incurs a cost. For more information, see AWS Lambda Pricing.Lambda supports response streaming on Node.js managed runtimes. For other languages, you can use a
    custom runtime with a custom Runtime API integration to stream responses or use the Lambda Web Adapter. 
    You can stream responses through Lambda function URLs, the AWS SDK, 
    or using the Lambda InvokeWithResponseStream 
    API.NoteWhen testing your function through the Lambda console, you'll always see responses as buffered.TopicsBandwidth limits for response streamingWriting response streaming-enabled Lambda functionsInvoking a response streaming enabled function using Lambda function URLsTutorial: Creating a response streaming Lambda
      function with a function URL
    Bandwidth limits for response streaming
    The first 6MB of your function’s response payload has uncapped bandwidth. After this initial burst, Lambda streams your response at a 
      maximum rate of  2MBps. If your function responses never exceed 6MB, then this bandwidth limit never applies. 
    NoteBandwidth limits only apply to your function’s response payload, and not to network access by your function.
    The rate of uncapped bandwidth varies depending on a number of factors, including your function’s processing speed.  You can normally 
      expect a rate higher than 2MBps for the first 6MB of your function’s response. If your function is streaming a response to a destination 
      outside of AWS, the streaming rate also depends on the speed of the external internet connection.
    
  Document ConventionsTagsWriting functionsDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideUnderstanding and visualizing concurrencyCalculating concurrency for a functionUnderstanding reserved concurrency and provisioned concurrencyUnderstanding concurrency and requests per secondConcurrency quotasUnderstanding Lambda function scalingConcurrency is the number of in-flight requests that your AWS Lambda function is
    handling at the same time. For each concurrent request, Lambda provisions a separate instance of your execution
    environment. As your functions receive more requests, Lambda automatically handles scaling the number of execution
    environments until you reach your account's concurrency limit. By default, Lambda provides your account with a total
    concurrency limit of 1,000 concurrent executions across all functions in an AWS Region. To support your specific
    account needs, you can request a quota
      increase and configure function-level concurrency controls so that your critical functions don't
    experience throttling.This topic explains concurrency concepts and function scaling in Lambda. By the end of this topic, you'll be able to
    understand how to calculate concurrency, visualize the two main concurrency control options (reserved and
    provisioned), estimate appropriate concurrency control settings, and view metrics for further optimization.SectionsUnderstanding and visualizing concurrencyCalculating concurrency for a functionUnderstanding reserved concurrency and provisioned concurrencyUnderstanding concurrency and requests per secondConcurrency quotasConfiguring reserved concurrency for a functionConfiguring provisioned concurrency for a functionLambda scaling behaviorMonitoring concurrency
    Understanding and visualizing concurrency
    Lambda invokes your function in a secure and isolated execution environment. To handle a
      request, Lambda must first initialize an execution environment (the Init phase),
      before using it to invoke your function (the Invoke phase):
    
       
        
       
       
    
    NoteActual Init and Invoke durations can vary depending on many factors, such as the runtime you choose
      and the Lambda function code. The previous diagram isn't meant to represent the exact proportions of Init and
      Invoke phase durations.
    The previous diagram uses a rectangle to represent a single execution environment. When your function
      receives its very first request (represented by the yellow circle with label 1), Lambda creates
      a new execution environment and runs the code outside your main handler during the Init phase. Then, Lambda
      runs your function's main handler code during the Invoke phase. During this entire process, this execution
      environment is busy and cannot process other requests.
    When Lambda finishes processing the first request, this execution environment can then process additional
      requests for the same function. For subsequent requests, Lambda doesn't need to re-initialize the environment.
    
       
        
       
       
    
    In the previous diagram, Lambda reuses the execution environment to handle the second request
      (represented by the yellow circle with label 2).
    So far, we've focused on just a single instance of your execution environment (that is, a concurrency of 1).
      In practice, Lambda may need to provision multiple execution environment instances in parallel to handle all
      incoming requests. When your function receives a new request, one of two things can happen:
    
       
       
    
        If a pre-initialized execution environment instance is available, Lambda uses it to process the request.
      
        Otherwise, Lambda creates a new execution environment instance to process the request.
      
    For example, let's explore what happens when your function receives 10 requests:
    
       
        
       
       
    
    In the previous diagram, each horizontal plane represents a single execution environment instance (labeled
      from A through F). Here's how Lambda handles each request:
    
          
            Request
            Lambda behavior
            Reasoning
          
        
          
            
              1
            
            
              Provisions new environment A
            
            
              This is the first request; no execution environment instances are available.
            
          
          
            
              2
            
            
              Provisions new environment B
            
            
              Existing execution environment instance A is busy.
            
          
          
            
              3
            
            
              Provisions new environment C
            
            
              Existing execution environment instances A and B are both busy.
            
          
          
            
              4
            
            
              Provisions new environment D
            
            
              Existing execution environment instances A, B, and C are all busy.
            
          
          
            
              5
            
            
              Provisions new environment E
            
            
              Existing execution environment instances A, B, C, and D are all
                busy.
            
          
          
            
              6
            
            
              Reuses environment A
            
            
              Execution environment instance A has finished processing request
                  1 and is now available.
            
          
          
            
              7
            
            
              Reuses environment B
            
            
              Execution environment instance B has finished processing request
                  2 and is now available.
            
          
          
            
              8
            
            
              Reuses environment C
            
            
              Execution environment instance C has finished processing request
                  3 and is now available.
            
          
          
            
              9
            
            
              Provisions new environment F
            
            
              Existing execution environment instances A, B, C, D, and E are all busy.
            
          
          
            
              10
            
            
              Reuses environment D
            
            
              Execution environment instance D has finished processing request
                  4 and is now available.
            
          
        
    As your function receives more concurrent requests, Lambda scales up the number of execution
      environment instances in response. The following animation tracks the number of concurrent
      requests over time:
    
       
        
       
       
    
    By freezing the previous animation at six distinct points in time, we get the following
      diagram:
    
       
        
       
       
    
    In the previous diagram, we can draw a vertical line at any point in time and count the number of environments
      that intersect this line. This gives us the number of concurrent requests at that point in time. For example, at
      time t1, there are three active environments serving three concurrent requests. The maximum number of
      concurrent requests in this simulation occurs at time t4, when there are six active environments
      serving six concurrent requests.
    To summarize, your function's concurrency is the number of concurrent requests that it's handling
      at the same time. In response to an increase in your function's concurrency, Lambda provisions more
      execution environment instances to meet request demand.
   
    Calculating concurrency for a function
    In general, concurrency of a system is the ability to process more than one task simultaneously.
      In Lambda, concurrency is the number of in-flight requests that your function is handling at the same
      time. A quick and practical way of measuring concurrency of a Lambda function is to use the following
      formula:
    Concurrency = (average requests per second) * (average request duration in seconds)
    Concurrency differs from requests per second. For example, suppose your
      function receives 100 requests per second on average. If the average request duration is one second, then it's
      true that the concurrency is also 100:
    Concurrency = (100 requests/second) * (1 second/request) = 100
    However, if the average request duration is 500 ms, then the concurrency is 50:
    Concurrency = (100 requests/second) * (0.5 second/request) = 50
    What does a concurrency of 50 mean in practice? If the average request duration is 500 ms, then you can think
      of an instance of your function as being able to handle two requests per second. Then, it takes 50 instances of
      your function to handle a load of 100 requests per second. A concurrency of 50 means that Lambda must provision 50
      execution environment instances to efficiently handle this workload without any throttling. Here's how to express
      this in equation form:
    Concurrency = (100 requests/second) / (2 requests/second) = 50
    If your function receives double the number of requests (200 requests per second), but only requires half the
      time to process each request (250 ms), then the concurrency is still 50:
    Concurrency = (200 requests/second) * (0.25 second/request) = 50
    Suppose you have a function that takes, on average, 200 ms to run. During peak load, you
          observe 5,000 requests per second. What is the concurrency of your function during
          peak load?
        The average function duration is 200 ms, or 0.2 seconds. Using the concurrency formula, you can plug
              in the numbers to get a concurrency of 1,000:Concurrency = (5,000 requests/second) * (0.2 seconds/request) = 1,000Alternatively, an average function duration of 200 ms means that your function can process
              5 requests per second. To handle the 5,000 request per second workload, you need 1,000
              execution environment instances. Thus, the concurrency is 1,000:Concurrency = (5,000 requests/second) / (5 requests/second) = 1,000
   
    Understanding reserved concurrency and provisioned concurrency
    By default, your account has a concurrency limit of 1,000 concurrent executions across all functions in a
      Region. Your functions share this pool of 1,000 concurrency on an on-demand basis. Your functions experiences
      throttling (that is, they start to drop requests) if you run out of available concurrency.
    Some of your functions might be more critical than others. As a result, you might want to configure
      concurrency settings to ensure that critical functions get the concurrency that they need. There are two types of
      concurrency controls available: reserved concurrency and provisioned concurrency.
    
       
       
    
        Use reserved concurrency to reserve a portion of your account's
          concurrency for a function. This is useful if you don't want other functions taking up all the
          available unreserved concurrency.
      
        Use provisioned concurrency to pre-initialize a number of
          environment instances for a function. This is useful for reducing cold start latencies.
      
     
      Reserved concurrency
      If you want to guarantee that a certain amount of concurrency is available for your function at any
        time, use reserved concurrency.
      Reserved concurrency is the maximum number of concurrent instances that you want to allocate to your
        function. When you dedicate reserved concurrency to a function, no other function can use that concurrency. In
        other words, setting reserved concurrency can impact the concurrency pool that's available to other functions.
        Functions that don't have reserved concurrency share the remaining pool of unreserved concurrency.
      Configuring reserved concurrency counts towards your overall account concurrency limit. There is no charge
        for configuring reserved concurrency for a function.
      To better understand reserved concurrency, consider the following diagram:
      
         
          
         
         
      
      In this diagram, your account concurrency limit for all the functions in this Region is at the default limit
        of 1,000. Suppose you have two critical functions, function-blue and function-orange,
        that routinely expect to get high invocation volumes. You decide to give 400 units of reserved concurrency to
          function-blue, and 400 units of reserved concurrency to function-orange. In this
        example, all other functions in your account must share the remaining 200 units of unreserved
        concurrency.
      The diagram has five points of interest:
      
         
         
         
         
         
      
          At t1, both function-orange and function-blue begin receiving
            requests. Each function begins to use up its allocated portion of reserved concurrency units.
        
          At t2, function-orange and function-blue steadily receive more
            requests. At the same time, you deploy some other Lambda functions, which begin receiving requests. You don't
            allocate reserved concurrency to these other functions. They begin using the remaining 200 units of
            unreserved concurrency.
        
          At t3, function-orange hits the max concurrency of 400. Although there is
            unused concurrency elsewhere in your account, function-orange cannot access it. The red line
            indicates that function-orange is experiencing throttling, and Lambda may drop requests.
        
          At t4, function-orange starts to receive fewer requests and is no longer
            throttling. However, your other functions experience a spike in traffic and begin throttling. Although
            there is unused concurrency elsewhere in your account, these other functions cannot access it. The red
            line indicates that your other functions are experiencing throttling.
        
          At t5, other functions start to receive fewer requests and are no longer throttling.
        
      From this example, notice that reserving concurrency has the following effects:
      
         
         
         
      
          Your function can scale independently of other functions in your
              account. All of your account's functions in the same Region that don't have reserved
            concurrency share the pool of unreserved concurrency. Without reserved concurrency, other functions can
            potentially use up all of your available concurrency. This prevents critical functions from scaling up if
            needed.
        
          Your function can't scale out of control. Reserved concurrency caps
            your function's maximum concurrency. This means that your function can't use concurrency reserved for other
            functions, or concurrency from the unreserved pool. You can reserve concurrency to prevent your function
            from using all the available concurrency in your account, or from overloading downstream resources.
        
          You may not be able to use all of your account's available concurrency.
            Reserving concurrency counts towards your account concurrency limit, but this also means that other
            functions cannot use that chunk of reserved concurrency. If your function doesn't use up all of the
            concurrency that you reserve for it, you're effectively wasting that concurrency. This isn't an issue unless
            other functions in your account could benefit from the wasted concurrency.
        
      To learn how to manage reserved concurrency settings for your functions, see Configuring reserved concurrency for a function.
     
     
      Provisioned concurrency
      You use reserved concurrency to define the maximum number of execution environments reserved for a Lambda function.
        However, none of these environments come pre-initialized. As a result, your function invocations may take longer
        because Lambda must first initialize the new environment before being able to use it to invoke your function.
        When Lambda has to initialize a new environment in order to carry out an invocation, this is known as a
        cold start. 
        To mitigate cold starts, you can use provisioned concurrency.
      Provisioned concurrency is the number of pre-initialized execution environments that you want to allocate to
        your function. If you set provisioned concurrency on a function, Lambda initializes that number of execution
        environments so that they are prepared to respond immediately to function requests.
      NoteUsing provisioned concurrency incurs additional charges to your account. If you're working with the Java
          11 or Java 17 runtimes, you can also use Lambda SnapStart to mitigate cold start issues at no additional cost.
          SnapStart uses cached snapshots of your execution environment to significantly improve startup
          performance. You cannot use both SnapStart and provisioned concurrency on the same function version. For more
          information about SnapStart features, limitations, and supported Regions, see Improving startup performance with Lambda SnapStart.
      When using provisioned concurrency, Lambda still recycles execution environments in the background. For example,
        this can occur after an invocation failure. However, at
        any given time, Lambda always ensures that the number of pre-initialized environments is equal to the value of your
        function's provisioned concurrency setting. Importantly, even if you're using provisioned concurrency, you can
        still experience a cold start delay if Lambda has to reset the execution environment.
      In contrast, when using reserved concurrency, Lambda may completely terminate an environment after a period of
        inactivity. The following diagram illustrates this by comparing the lifecycle of a single execution environment
        when you configure your function using reserved concurrency compared to provisioned concurrency.
      
         
          
         
         
      
      The diagram has four points of interest:
      
            
              Time
              Reserved concurrency
              Provisioned concurrency
            
          
            
              
                t1
              
              
                Nothing happens.
              
              
                Lambda pre-initializes an execution environment instance.
              
            
            
              
                t2
              
              
                Request 1 comes in. Lambda must initialize a new execution environment instance.
              
              
                Request 1 comes in. Lambda uses the pre-initialized environment instance.
              
            
            
              
                t3
              
              
                After some inactivity, Lambda terminates the active environment instance.
              
              
                Nothing happens.
              
            
            
              
                t4
              
              
                Request 2 comes in. Lambda must initialize a new execution environment instance.
              
              
                Request 2 comes in. Lambda uses the pre-initialized environment instance.
              
            
          
      To better understand provisioned concurrency, consider the following diagram:
      
         
          
         
         
      
      In this diagram, you have an account concurrency limit of 1,000. You decide to give 400 units of provisioned
        concurrency to function-orange. All functions in your account, including
        function-orange, can use the remaining 600 units of unreserved concurrency.
      The diagram has five points of interest:
      
         
         
         
         
         
      
          At t1, function-orange begins receiving requests. Since Lambda has pre-initialized
            400 execution environment instances, function-orange is ready for immediate invocation.
        
          At t2, function-orange reaches 400 concurrent requests. As a result,
            function-orange runs out of provisioned concurrency. However, since there's still unreserved
            concurrency available, Lambda can use this to handle additional requests to function-orange
            (there's no throttling). Lambda must create new instances to serve these requests, and your function may
            experience cold start latencies.
        
          At t3, function-orange returns to 400 concurrent requests after a brief spike
            in traffic. Lambda is again able to handle all requests without cold start latencies.
        
          At t4, functions in your account experience a burst in traffic. This burst can come from
            function-orange or any other function in your account. Lambda uses unreserved concurrency to
            handle these requests.
        
          At t5, functions in your account reach the maximum concurrency limit of 1,000, and
            experience throttling.
        
      The previous example considered only provisioned concurrency. In practice, you can set both provisioned
        concurrency and reserved concurrency on a function. You might do this if you had a function that handles a
        consistent load of invocations on weekdays, but routinely sees spikes of traffic on weekends. In this case, you
        could use provisioned concurrency to set a baseline amount of environments to handle request during weekdays,
        and use reserved concurrency to handle the weekend spikes. Consider the following diagram:
      
         
          
         
         
      
      In this diagram, suppose that you configure 200 units of provisioned concurrency and 400 units of
        reserved concurrency for function-orange. Because you configured reserved concurrency,
        function-orange cannot use any of the 600 units of unreserved concurrency.
      This diagram has five points of interest:
      
         
         
         
         
         
      
          At t1, function-orange begins receiving requests. Since Lambda has
            pre-initialized 200 execution environment instances, function-orange is ready for
            immediate invocation.
        
          At t2, function-orange uses up all its provisioned concurrency.
            function-orange can continue serving requests using reserved concurrency, but these
            requests may experience cold start latencies.
        
          At t3, function-orange reaches 400 concurrent requests. As a result,
            function-orange uses up all its reserved concurrency. Since function-orange
            cannot use unreserved concurrency, requests begin to throttle.
        
          At t4, function-orange starts to receive fewer requests, and no longer
            throttles.
        
          At t5, function-orange drops down to 200 concurrent requests, so all requests
            are again able to use provisioned concurrency (that is, no cold start latencies).
        
      Both reserved concurrency and provisioned concurrency count towards your account concurrency limit and Regional quotas. In other words, allocating reserved and provisioned
        concurrency can impact the concurrency pool that's available to other functions. Configuring provisioned
        concurrency incurs charges to your AWS account.
      NoteIf the amount of provisioned concurrency on a function's versions and aliases adds up to the function's reserved
          concurrency, then all invocations run on provisioned concurrency. This configuration also has the effect of
          throttling the unpublished version of the function ($LATEST), which prevents it from executing.
          You can't allocate more provisioned concurrency than reserved concurrency for a function.
      To manage provisioned concurrency settings for your functions, see Configuring provisioned concurrency for a function. To automate
        provisioned concurrency scaling based on a schedule or application utilization, see Using Application Auto Scaling to automate provisioned concurrency management.
     
     
      How Lambda allocates provisioned concurrency
      Provisioned concurrency doesn't come online immediately after you configure it. Lambda
        starts allocating provisioned concurrency after a minute or two of preparation. For each 
        function, Lambda can provision up to 6,000 execution environments every minute, regardless 
        of AWS Region. This is exactly the same as the concurrency scaling rate for functions.
      When you submit a request to allocate provisioned concurrency, you can't access
        any of those environments until Lambda completely finishes allocating them. For example,
        if you request 5,000 provisioned concurrency, none of your requests can use
        provisioned concurrency until Lambda completely finishes allocating the 5,000 execution
        environments.
     
     
      Comparing reserved concurrency and provisioned concurrency
      The following table summarizes and compares reserved and provisioned concurrency.
      
            
              Topic
              Reserved concurrency
              Provisioned concurrency
            
          
            
              
                Definition
              
              
                Maximum number of execution environment instances for your function.
              
              
                Set number of pre-provisioned execution environment instances for your function.
              
            
            
              
                Provisioning behavior
              
              
                Lambda provisions new instances on an on-demand basis.
              
              
                Lambda pre-provisions instances (that is, before your function starts receiving requests).
              
            
            
              
                Cold start behavior
              
              
                Cold start latency possible, since Lambda must create new instances on-demand.
              
              
                Cold start latency not possible, since Lambda doesn't have to create instances on-demand.
              
            
            
              
                Throttling behavior
              
              
                Function throttled when reserved concurrency limit reached.
              
              
                If reserved concurrency not set: function uses unreserved concurrency when provisioned concurrency
                  limit reached.
                If reserved concurrency set: function throttled when reserved concurrency limit reached.
              
            
            
              
                Default behavior if not set
              
              
                Function uses unreserved concurrency available in your account.
              
              
                Lambda doesn't pre-provision any instances. Instead, if reserved concurrency not set: function uses
                  unreserved concurrency available in your account.
                If reserved concurrency set: function uses reserved concurrency.
              
            
            
              
                Pricing
              
              
                No additional charge.
              
              
                Incurs additional charges.
              
            
          
     
   
    Understanding concurrency and requests per second
    As mentioned in the previous section, concurrency differs from requests per second. This is an
      especially important distinction to make when working with functions that have an average request
      duration of less than 100 ms.
    Across all functions in your account, Lambda enforces a requests per second limit that's equal to 10
      times your account concurrency. For example, since the default account concurrency limit is 1,000,
      functions in your account can handle a maximum of 10,000 requests per second.
    For example, consider a function with an average request duration of 50 ms. At 20,000 requests
      per second, here's the concurrency of this function:
    Concurrency = (20,000 requests/second) * (0.05 second/request) = 1,000
    Based on this result, you might expect that the account concurrency limit of 1,000 is sufficient
      to handle this load. However, because of the 10,000 requests per second limit, your function can only
      handle 10,000 requests per second out of the 20,000 total requests. This function experiences throttling.
    The lesson is that you must consider both concurrency and requests per second when configuring concurrency
      settings for your functions. In this case, you need to request an account concurrency limit increase to
      2,000, since this would increase your total requests per second limit to 20,000.
    NoteBased on this request per second limit, it's incorrect to say that each Lambda execution
        environment can handle only a maximum of 10 requests per second. Instead of observing the
        load on any individual execution environment, Lambda only considers overall concurrency and
        overall requests per second when calculating your quotas.
    Suppose that you have a function that takes, on average, 20 ms to run. During peak load, you observe 30,000
          requests per second. What is the concurrency of your function during peak load?The average function duration is 20 ms, or 0.02 seconds. Using the concurrency formula,
              you can plug in the numbers to get a concurrency of 600:Concurrency = (30,000 requests/second) * (0.02 seconds/request) = 600By default, the account concurrency limit of 1,000 seems sufficient to handle this load.
              However, the requests per second limit of 10,000 isn't enough to handle the incoming 30,000
              requests per second. To fully accommodate the 30,000 requests, you need to request an account
              concurrency limit increase to 3,000 or higher.
    The requests per second limit applies to all quotas in Lambda that involve concurrency. In other
      words, it applies to synchronous on-demand functions, functions that use provisioned concurrency,
      and concurrency scaling behavior. For example, here
      are a few scenarios where you must carefully consider both your concurrency and request per second limits:
    
       
       
    
        A function using on-demand concurrency can experience a burst increase of 500 concurrency
          every 10 seconds, or by 5,000 requests per second every 10 seconds, whichever happens first.
      
        Suppose you have a function that has a provisioned concurrency allocation of 10. This
          function spills over into on-demand concurrency after 10 concurrency or 100 requests per
          second, whichever happens first.
      
   
    Concurrency quotas
    Lambda sets quotas for the total amount of concurrency that you can use across all functions in a Region. These
      quotas exist on two levels:
    
       
       
       
    
        At the account level, your functions can have up to 1,000 units of
          concurrency by default. To increase this limit, see Requesting a quota increase in the
            Service Quotas User Guide.
      
        At the function level, you can reserve up to 900 units of concurrency
          across all your functions by default. Regardless of your total account concurrency limit, Lambda always
          reserves 100 units of concurrency for your functions that don't explicitly reserve concurrency. For example,
          if you increased your account concurrency limit to 2,000, then you can reserve up to 1,900 units of
          concurrency at the function level.
      
        At both the account level and the function level, Lambda also enforces a requests per second limit of
          equal to 10 times the corresponding concurrency quota. For instance, this applies to account-level
          concurrency, functions using on-demand concurrency, functions using provisoned concurrency, and
          concurrency scaling behavior. For more information, see
          Understanding concurrency and requests per second.
      
    To check your current account level concurrency quota, use the AWS Command Line Interface (AWS CLI) to run the following
      command:
    aws lambda get-account-settings
    You should see output that looks like the following:
    {
    "AccountLimit": {
        "TotalCodeSize": 80530636800,
        "CodeSizeUnzipped": 262144000,
        "CodeSizeZipped": 52428800,
        "ConcurrentExecutions": 1000,
        "UnreservedConcurrentExecutions": 900
    },
    "AccountUsage": {
        "TotalCodeSize": 410759889,
        "FunctionCount": 8
    }
}

    ConcurrentExecutions is your total account-level concurrency quota.
        UnreservedConcurrentExecutions is the amount of reserved concurrency that you can still allocate to
      your functions.
    As your function receives more requests, Lambda automatically scales up the number of execution environments to
      handle these requests until your account reaches its concurrency quota. However, to protect against over-scaling in
      response to sudden bursts of traffic, Lambda limits how fast your functions can scale. This 
      concurrency scaling rate is the maximum rate at which functions in your account can scale in response
      to increased requests. (That is, how quickly Lambda can create new execution environments.) The concurrency scaling
      rate differs from the account-level concurrency limit, which is the total amount of concurrency available to your
      functions.
    In each AWS Region, and for each function,
      your concurrency scaling rate is 1,000 execution environment instances every 10 seconds (or 10,000 requests per
      second every 10 seconds). In other words, every 10 seconds, Lambda can allocate
      at most 1,000 additional execution environment instances, or accommodate 10,000 additional
      requests per second, to each of your functions.
    Usually, you don't need to worry about this limitation. Lambda's scaling rate is sufficient for most
      use cases.
    Importantly, the concurrency scaling rate is a function-level limit. This means that each function in your
      account can scale independently of other functions.
    For more information about scaling behavior, see Lambda scaling behavior.
  Document ConventionsTutorial: Creating a webhook endpointConfiguring reserved concurrencyDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideSignature validationUsing code signing to verify code integrity with LambdaCode signing helps ensure that only trusted code is deployed to your Lambda functions. Using AWS Signer, you can create digitally signed code packages for your functions. When you add a code signing configuration to a function, Lambda verifies that all new code deployments are signed by a trusted source. Because code signing validation checks run at deployment time, there is no impact on function execution.ImportantCode signing configurations only prevent new deployments of unsigned code. If you add a code signing configuration to an existing function that has unsigned code, that code keeps running until you deploy a new code package.When you enable code signing for a function, any layers that you add to the function must also be signed by an allowed signing profile.There is no additional charge for using AWS Signer or code signing for AWS Lambda.
    Signature validation
    Lambda performs the following validation checks when you deploy a signed code package to your function:
    
       
       
       
       
    
        Integrity: Validates that the code package has not been modified since it was signed. Lambda
          compares the hash of the package with the hash from the signature.
      
        Expiry: Validates that the signature of the code package has not expired.
      
        Mismatch: Validates that the code package is signed with an allowed signing profile
      
        Revocation: Validates that the signature of the code package has not been revoked.
      
    When you create a code signing configuration, you can use the UntrustedArtifactOnDeployment parameter to specify how Lambda should respond if the expiry, mismatch, or revocation checks fail. You can choose one of these actions:
    
       
       
    
        Warn: This is the default setting. Lambda allows the deployment of the code package, but issues a warning. Lambda issues a new
          Amazon CloudWatch metric and also stores the warning in the CloudTrail log.
      
        Enforce Lambda issues a warning (the same as for the Warn action) and blocks the deployment of the
          code package.
      
  TopicsCreating code signing configurations for LambdaConfiguring IAM policies for Lambda code signing configurationsUsing tags on code signing configurationsDocument ConventionsSecuring workloads with public endpointsCreate configurationDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideRequired IAM permissionsAttaching Lambda functions to an Amazon VPC in your AWS accountInternet access when attached to a VPCIPv6 supportBest practices for using Lambda with Amazon VPCsUnderstanding Hyperplane Elastic Network Interfaces (ENIs)Using IAM condition keys for VPC settingsVPC tutorialsGiving Lambda functions access to resources in an Amazon VPCWith Amazon Virtual Private Cloud (Amazon VPC), you can create private networks in your AWS account to host resources such as Amazon Elastic Compute Cloud (Amazon EC2) 
    instances, Amazon Relational Database Service (Amazon RDS) instances, and Amazon ElastiCache instances. You can give your Lambda function access to resources hosted 
    in an Amazon VPC by attaching your function to the VPC through the private subnets that contain the resources. Follow the instructions 
    in the following sections to attach a Lambda function to an Amazon VPC using the Lambda console, the AWS Command Line Interface (AWS CLI), or AWS SAM.NoteEvery Lambda function runs inside a VPC that is owned and managed by the Lambda service. These VPCs are maintained automatically 
      by Lambda and are not visible to customers. Configuring your function to access other AWS resources in an Amazon VPC has no effect on the 
      Lambda-managed VPC your function runs inside.SectionsRequired IAM permissionsAttaching Lambda functions to an Amazon VPC in your AWS accountInternet access when attached to a VPCIPv6 supportBest practices for using Lambda with Amazon VPCsUnderstanding Hyperplane Elastic Network Interfaces (ENIs)Using IAM condition keys for VPC settingsVPC tutorials
      Required IAM permissions
    To attach a Lambda function to an Amazon VPC in your AWS account, Lambda needs permissions to create and manage the network 
      interfaces it uses to give your function access to the resources in the VPC.
    The network interfaces that Lambda creates are known as Hyperplane Elastic Network Interfaces, or Hyperplane ENIs. To learn more about 
      these network interfaces, see Understanding Hyperplane Elastic Network Interfaces (ENIs).
      You can give your function the permissions it needs by attaching the AWS managed policy 
        AWSLambdaVPCAccessExecutionRole to your function's execution role. When you create a new function in the Lambda console 
        and attach it to a VPC, Lambda automatically adds this permissions policy for you. 
      If you prefer to create your own IAM permissions policy, make sure to add all of the following permissions:
    
       
       
       
       
       
       
    
        ec2:CreateNetworkInterface
      
        ec2:DescribeNetworkInterfaces – This action only works if it's allowed on all resources 
          ("Resource": "*").
      
        ec2:DescribeSubnets
      
        ec2:DeleteNetworkInterface – If you don't specify a resource ID for 
          DeleteNetworkInterface in the execution role, your function may not be able to access the 
          VPC. Either specify a unique resource ID, or include all resource IDs, for example, "Resource": "arn:aws:ec2:us-west-2:123456789012:*/*".
      
        ec2:AssignPrivateIpAddresses
      
        ec2:UnassignPrivateIpAddresses
      
    Note that your function's role only needs these permissions to create the network interfaces, not to invoke your function. You can still 
      invoke your function successfully when it’s attached to an Amazon VPC, even if you remove these permissions from your function’s execution role. 
    To attach your function to a VPC, Lambda also needs to verify network resources using your IAM user role. Ensure that your user role 
      has the following IAM permissions:
    
       
       
       
       
    
        ec2:DescribeSecurityGroups
      
        ec2:DescribeSubnets
      
        ec2:DescribeVpcs
      
        ec2:getSecurityGroupsForVpc
      
    NoteThe Amazon EC2 permissions that you grant to your function's execution role are used by the Lambda service to attach your function 
        to a VPC. However, you're also implicitly granting these permissions to your function's code. This means that your function code is 
        able to make these Amazon EC2 API calls. For advice on following security best practices, see Security best practices.
     
    Attaching Lambda functions to an Amazon VPC in your AWS account
    Attach your function to an Amazon VPC in your AWS account by using the Lambda console, the AWS CLI or AWS SAM. If you're using the AWS CLI or AWS SAM, or attaching 
    an existing function to a VPC using the Lambda console, make sure that your function's execution role has the necessary permissions listed in the previous section.
      Lambda functions can't connect directly to a VPC with  dedicated instance tenancy. To connect to resources
        in a dedicated VPC, peer it to a
          second VPC with default tenancy.
    
    
      Lambda console
          To attach a function to an Amazon VPC when you create it
              Open the Functions page of the Lambda console and choose Create function.
            
              Under Basic information, for Function name, enter a name for your function.
            
              Configure VPC settings for the function by doing the following:
              
                  Expand Advanced settings.
                
                  Select Enable VPC, and then select the VPC you want to attach the function to.
                
                  (Optional) To allow outbound IPv6 traffic, select Allow IPv6 traffic for dual-stack subnets.
                
                  Choose the subnets and security groups to create the network interface for. If you selected Allow IPv6 traffic for dual-stack subnets, 
                    all selected subnets must have an IPv4 CIDR block and an IPv6 CIDR block.
                  NoteTo access private resources, connect your function to private subnets. If your function needs internet access, see 
                      Enable internet access for VPC-connected Lambda functions. Connecting a function to a public subnet doesn't give it internet access or a public IP address. 
                
            
              Choose Create function.
            
          To attach an existing function to an Amazon VPC
              Open the Functions page of the Lambda console and select your function.
            
              Choose the Configuration tab, then choose VPC.
            
              Choose Edit.
            
              Under VPC, select the Amazon VPC you want to attach your function to.
            
              (Optional) To allow outbound IPv6 traffic, select Allow IPv6 traffic for dual-stack subnets. 
            
              Choose the subnets and security groups to create the network interface for. If you selected Allow IPv6 traffic for dual-stack subnets, 
                all selected subnets must have an IPv4 CIDR block and an IPv6 CIDR block.
              NoteTo access private resources, connect your function to private subnets. If your function needs internet access, see 
                  Enable internet access for VPC-connected Lambda functions. Connecting a function to a public subnet doesn't give it internet access or a public IP address. 
            
              Choose Save.
            
        
      AWS CLI
          To attach a function to an Amazon VPC when you create it
              To create a Lambda function and attach it to a VPC, run the following CLI create-function command.
              aws lambda create-function --function-name my-function \
--runtime nodejs22.x --handler index.js --zip-file fileb://function.zip \
--role arn:aws:iam::123456789012:role/lambda-role \
--vpc-config Ipv6AllowedForDualStack=true,SubnetIds=subnet-071f712345678e7c8,subnet-07fd123456788a036,SecurityGroupIds=sg-085912345678492fb
              Specify your own subnets and security groups and set Ipv6AllowedForDualStack to true or false according to your use case.
            
          To attach an existing function to an Amazon VPC
              To attach an existing function to a VPC, run the following CLI update-function-configuration command.
              aws lambda update-function-configuration --function-name my-function \
--vpc-config Ipv6AllowedForDualStack=true, SubnetIds=subnet-071f712345678e7c8,subnet-07fd123456788a036,SecurityGroupIds=sg-085912345678492fb
            
           To unattach your function from a VPC
              To unattach your function from a VPC, run the following update-function-configurationCLI command with an empty list of VPC subnets and security groups.
              aws lambda update-function-configuration --function-name my-function \
--vpc-config SubnetIds=[],SecurityGroupIds=[]
            
        
      AWS SAM
          To attach your function to a VPC
              To attach a Lambda function to an Amazon VPC, add the VpcConfig property to your function definition as shown in 
                the following example template. For more information about this property, see AWS::Lambda::Function VpcConfig 
                in the AWS CloudFormation User Guide (the AWS SAM VpcConfig property is passed directly to the VpcConfig 
                property of an AWS CloudFormation AWS::Lambda::Function resource).
              AWSTemplateFormatVersion: '2010-09-09'
Transform: AWS::Serverless-2016-10-31

Resources:
  MyFunction:
    Type: AWS::Serverless::Function
    Properties:
      CodeUri: ./lambda_function/
      Handler: lambda_function.handler
      Runtime: python3.12
      VpcConfig:
        SecurityGroupIds:
          - !Ref MySecurityGroup
        SubnetIds:
          - !Ref MySubnet1
          - !Ref MySubnet2
      Policies:
        - AWSLambdaVPCAccessExecutionRole

  MySecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Security group for Lambda function
      VpcId: !Ref MyVPC

  MySubnet1:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref MyVPC
      CidrBlock: 10.0.1.0/24

  MySubnet2:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref MyVPC
      CidrBlock: 10.0.2.0/24

  MyVPC:
    Type: AWS::EC2::VPC
    Properties:
      CidrBlock: 10.0.0.0/16
              For more information about configuring your VPC in AWS SAM, see AWS::EC2::VPC 
                in the AWS CloudFormation User Guide.
            
        
    
   
    Internet access when attached to a VPC
    By default, Lambda functions have access to the public internet. When you attach your function to a VPC, it can only access resources 
      available within that VPC. To give your function access to the internet, you also need to configure the VPC to have internet access. To 
      learn more, see Enable internet access for VPC-connected Lambda functions.
   
  IPv6 support
  Your function can connect to resources in dual-stack VPC subnets over IPv6. This option is turned off by default. To allow outbound IPv6 traffic, use the console or the --vpc-config Ipv6AllowedForDualStack=true option with the create-function or update-function-configuration command.
  NoteTo allow outbound IPv6 traffic in a VPC, all of the subnets that are connected to the function must be dual-stack subnets. Lambda doesn't support outbound IPv6 connections for IPv6-only subnets in a VPC or outbound IPv6 connections for functions that are not connected to a VPC.
  You can update your function code to explicitly connect to subnet resources over IPv6. The following Python example opens a socket and connects to an IPv6 server.
  Example  — Connect to IPv6 serverdef connect_to_server(event, context):
    server_address = event['host']
    server_port = event['port']
    message = event['message']
    run_connect_to_server(server_address, server_port, message)

def run_connect_to_server(server_address, server_port, message):
    sock = socket.socket(socket.AF_INET6, socket.SOCK_STREAM, 0)
    try:
        # Send data
        sock.connect((server_address, int(server_port), 0, 0))
        sock.sendall(message.encode())
        BUFF_SIZE = 4096
        data = b''
        while True:
            segment = sock.recv(BUFF_SIZE)
            data += segment
            # Either 0 or end of data
            if len(segment) < BUFF_SIZE:
                break
        return data
    finally:
        sock.close()

 
    Best practices for using Lambda with Amazon VPCs
    To ensure that your Lambda VPC configuration meets best practice guidelines, follow the advice in the following sections.
     
      Security best practices
      To attach your Lambda function to a VPC, you need to give your function’s execution role a number of Amazon EC2 permissions. These 
        permissions are required to create the network interfaces your function uses to access the resources in the VPC. However, these 
        permissions are also implicitly granted to your function’s code. This means that your function code has permission to make these Amazon EC2 API calls.
      To follow the principle of least-privilege access, add a deny policy like the following example to your function’s execution role. 
        This policy prevents your function from making calls to the Amazon EC2 APIs that the Lambda service uses to attach your function to a VPC.
      {
    "Version": "2012-10-17",
    "Statement": [
        {
            "Effect": "Deny",
            "Action": [ 
                 "ec2:CreateNetworkInterface",
                 "ec2:DeleteNetworkInterface",
                 "ec2:DescribeNetworkInterfaces",
                 "ec2:DescribeSubnets",
                 "ec2:DetachNetworkInterface",
                 "ec2:AssignPrivateIpAddresses",
                 "ec2:UnassignPrivateIpAddresses"
            ],
            "Resource": [ "*" ],
            "Condition": {
                "ArnEquals": {
                    "lambda:SourceFunctionArn": [
                        "arn:aws:lambda:us-west-2:123456789012:function:my_function"
                    ]
                }
            }
        }
    ]
}
      AWS provides security groups and 
        network Access Control Lists (ACLs) to increase security 
        in your VPC. Security groups control inbound and outbound traffic for your resources, and network ACLs control inbound and outbound traffic 
        for your subnets. Security groups provide enough access control for most subnets. You can use network ACLs if you want an additional layer 
        of security for your VPC. For general guidelines on security best practices when using Amazon VPCs, see Security best practices for your VPC 
        in the Amazon Virtual Private Cloud User Guide.
     
     
      Performance best practices
      When you attach your function to a VPC, Lambda checks to see if there is an available network resource (Hyperplane ENI) it can use to 
        connect to. Hyperplane ENIs are associated with a particular combination of security groups and VPC subnets. If you’ve already attached 
        one function to a VPC, specifying the same subnets and security groups when you attach another function means that Lambda can share the 
        network resources and avoid the need to create a new Hyperplane ENI. For more information about Hyperplane ENIs and their lifecycle, 
        see Understanding Hyperplane Elastic Network Interfaces (ENIs).
     
   
    Understanding Hyperplane Elastic Network Interfaces (ENIs)
    A Hyperplane ENI is a managed resource that acts as a network interface between your Lambda function and the resources you want your function 
      to connect to. The Lambda service creates and manages these ENIs automatically when you attach your function to a VPC.
    Hyperplane ENIs are not directly visible to you, and you don’t need to configure or manage them. However, knowing how they work can help 
      you to understand your function’s behavior when you attach it to a VPC.
    The first time you attach a function to a VPC using a particular subnet and security group combination, Lambda creates a Hyperplane ENI. Other 
      functions in your account that use the same subnet and security group combination can also use this ENI. Wherever possible, Lambda reuses existing 
      ENIs to optimize resource utilization and minimize the creation of new ENIs. Each Hyperplane ENI supports up to 65,000 connections/ports. If the 
      number of connections exceeds this limit, Lambda scales the number of ENIs automatically based on network traffic and concurrency requirements.
    For new functions, while Lambda is creating a Hyperplane ENI, your function remains in the Pending state and you can’t invoke it. Your function 
      transitions to the Active state only when the Hyperplane ENI is ready, which can take several minutes. For existing functions, you can’t perform 
      additional operations that target the function, such as creating versions or updating the function’s code, but you can continue to invoke previous 
      versions of the function.
      As part of managing the ENI lifecycle, Lambda may delete and recreate ENIs to load balance network traffic across ENIs or to address issues found 
        in ENI health-checks. Additionally, if a Lambda function remains idle for 30 days, Lambda reclaims any unused Hyperplane ENIs and sets the function state to idle. The next invocation attempt will fail, and the function re-enters the Pending state until Lambda completes the creation or allocation of a Hyperplane ENI. We recommend that your design doesn't rely on the persistence of ENIs.
    When you update a function to remove its VPC configuration, Lambda requires up to 20 minutes to delete the
      attached Hyperplane ENI. Lambda only deletes the ENI if no other function (or published function version) is
      using that Hyperplane ENI. 
    Lambda relies on permissions in the function  execution
      role to delete the Hyperplane ENI. If you delete the execution role before Lambda deletes the Hyperplane
      ENI, Lambda won't be able to delete the Hyperplane ENI. You can manually perform the deletion.
   
    Using IAM condition keys for VPC settings
    You can use Lambda-specific condition keys for VPC settings to provide additional permission controls for your
      Lambda functions. For example, you can require that all functions in your organization are connected to a VPC. You
      can also specify the subnets and security groups that the function's users can and can't use.
    Lambda supports the following condition keys in IAM policies:
    
       
       
       
    
        lambda:VpcIds – Allow or deny one or more VPCs.
      
        lambda:SubnetIds – Allow or deny one or more subnets.
      
        lambda:SecurityGroupIds – Allow or deny one or more security
          groups.
      
    The Lambda API operations CreateFunction and UpdateFunctionConfiguration support these condition keys. For
      more information about using condition keys in IAM policies, see IAM JSON Policy Elements:
        Condition in the IAM User Guide.
    TipIf your function already includes a VPC configuration from a previous API request, you can send an
        UpdateFunctionConfiguration request without the VPC configuration.
     
      Example policies with condition keys for VPC settings
      The following examples demonstrate how to use condition keys for VPC settings. After you create a policy
        statement with the desired restrictions, append the policy statement for the target user or role.
       
        Ensure that users deploy only VPC-connected functions
        To ensure that all users deploy only VPC-connected functions, you can deny function create and update
          operations that don't include a valid VPC ID. 
        Note that VPC ID is not an input parameter to the CreateFunction or
          UpdateFunctionConfiguration request. Lambda retrieves the VPC ID value based on the subnet and
          security group parameters.
        {
  "Version": "2012-10-17",
  "Statement": [
    {
      "Sid": "EnforceVPCFunction",
      "Action": [
          "lambda:CreateFunction",
          "lambda:UpdateFunctionConfiguration"
       ],
      "Effect": "Deny",
      "Resource": "*",
      "Condition": {
        "Null": {
           "lambda:VpcIds": "true"
        }
      }
    }
  ]
}
        
       
       
        Deny users access to specific VPCs, subnets, or security
            groups
        To deny users access to specific VPCs, use StringEquals to check the value of the
          lambda:VpcIds condition. The following example denies users access to vpc-1 and
          vpc-2.
        {
  "Version": "2012-10-17",
  "Statement": [
    {
      "Sid": "EnforceOutOfVPC",
      "Action": [
          "lambda:CreateFunction",
          "lambda:UpdateFunctionConfiguration"
       ],
      "Effect": "Deny",
      "Resource": "*",
      "Condition": {
        "StringEquals": {
            "lambda:VpcIds": ["vpc-1", "vpc-2"]
        }
      }
    } 
        
        To deny users access to specific subnets, use StringEquals to check the value of the
          lambda:SubnetIds condition. The following example denies users access to subnet-1
          and subnet-2.
        {
      "Sid": "EnforceOutOfSubnet",
      "Action": [
          "lambda:CreateFunction",
          "lambda:UpdateFunctionConfiguration"
       ],
      "Effect": "Deny",
      "Resource": "*",
      "Condition": {
        "ForAnyValue:StringEquals": {
            "lambda:SubnetIds": ["subnet-1", "subnet-2"]
        }
      }
    }
       
        To deny users access to specific security groups, use StringEquals to check the value of the
          lambda:SecurityGroupIds condition. The following example denies users access to
          sg-1 and sg-2.
        {
      "Sid": "EnforceOutOfSecurityGroups",
      "Action": [
          "lambda:CreateFunction",
          "lambda:UpdateFunctionConfiguration"
       ],
      "Effect": "Deny",
      "Resource": "*",
      "Condition": {
        "ForAnyValue:StringEquals": {
            "lambda:SecurityGroupIds": ["sg-1", "sg-2"]
        }
      }
    }
  ]
}
        
       
       
        Allow users to create and update functions with specific VPC
            settings
        To allow users to access specific VPCs, use StringEquals to check the value of the
          lambda:VpcIds condition. The following example allows users to access vpc-1 and
          vpc-2.
        {
  "Version": "2012-10-17",
  "Statement": [
    {
      "Sid": "EnforceStayInSpecificVpc",
      "Action": [
          "lambda:CreateFunction",
          "lambda:UpdateFunctionConfiguration"
       ],
      "Effect": "Allow",
      "Resource": "*",
      "Condition": {
        "StringEquals": {
            "lambda:VpcIds": ["vpc-1", "vpc-2"]
        }
      }
    }
        
        To allow users to access specific subnets, use StringEquals to check the value of the
          lambda:SubnetIds condition. The following example allows users to access subnet-1
          and subnet-2.
        {
      "Sid": "EnforceStayInSpecificSubnets",
      "Action": [
          "lambda:CreateFunction",
          "lambda:UpdateFunctionConfiguration"
       ],
      "Effect": "Allow",
      "Resource": "*",
      "Condition": {
        "ForAllValues:StringEquals": {
            "lambda:SubnetIds": ["subnet-1", "subnet-2"]
        }
      }
    }
      
        To allow users to access specific security groups, use StringEquals to check the value of the
          lambda:SecurityGroupIds condition. The following example allows users to access
          sg-1 and sg-2.
        {
      "Sid": "EnforceStayInSpecificSecurityGroup",
      "Action": [
          "lambda:CreateFunction",
          "lambda:UpdateFunctionConfiguration"
       ],
      "Effect": "Allow",
      "Resource": "*",
      "Condition": {
        "ForAllValues:StringEquals": {
            "lambda:SecurityGroupIds": ["sg-1", "sg-2"]
        }
      }
    }
  ]
} 
        
       
     
   
    VPC tutorials
    In the following tutorials, you connect a Lambda function to resources in your VPC.
    
       
       
    
        Tutorial: Using a Lambda function to access Amazon RDS in an Amazon VPC
      
        Tutorial: Configuring a Lambda function to access Amazon ElastiCache in an Amazon VPC
      
  Document ConventionsSecuring environment variablesAttaching functions to resources in another accountDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideExecution role and user permissionsConfiguring a file system and access pointConnecting to a file system (console)Configuring file system access for Lambda functionsYou can configure a function to mount an Amazon Elastic File System (Amazon EFS) file system to a local directory. With Amazon EFS, your
    function code can access and modify shared resources safely and at high concurrency.SectionsExecution role and user permissionsConfiguring a file system and access pointConnecting to a file system (console)
    Execution role and user permissions
    
    If the file system doesn't have a user-configured AWS Identity and Access Management (IAM) policy, EFS uses a default policy that grants full access to any client that can connect to the file system using a file system mount target. 
      If the file system has a user-configured IAM policy, your function's
      execution role must have the correct elasticfilesystem permissions.
    
      Execution role permissions
       
       
    
        elasticfilesystem:ClientMount
      
        elasticfilesystem:ClientWrite (not required for read-only
          connections)
      
    These permissions are included in the AmazonElasticFileSystemClientReadWriteAccess
      managed policy. Additionally, your execution role must have the permissions
      required to connect to the file system's VPC.
    When you configure a file system, Lambda uses your permissions to verify mount targets. To configure a function
      to connect to a file system, your user needs the following permissions:
    
      User permissions
       
    
        elasticfilesystem:DescribeMountTargets
      
   
    Configuring a file system and access point
    
    Create a file system in Amazon EFS with a mount target in every Availability Zone that your function connects to.
      For performance and resilience, use at least two Availability Zones. For example, in a simple configuration you
      could have a VPC with two private subnets in separate Availability Zones. The function connects to both subnets
      and a mount target is available in each. Ensure that NFS traffic (port 2049) is allowed by the security groups
      used by the function and mount targets.
    
    NoteWhen you create a file system, you choose a performance mode that can't be changed later. General
        purpose mode has lower latency, and Max I/O mode supports a higher maximum
        throughput and IOPS. For help choosing, see Amazon EFS
          performance in the Amazon Elastic File System User Guide.
    
    An access point connects each instance of the function to the right mount target for the Availability Zone it
      connects to. For best performance, create an access point with a non-root path, and limit the number of files that
      you create in each directory. The
      following example creates a directory named my-function on the file system and sets the owner ID to
      1001 with standard directory permissions (755).
    Example access point configuration
         
         
         
         
         
         
         
      
          Name – files
        
          User ID – 1001
        
          Group ID – 1001
        
          Path – /my-function
        
          Permissions – 755
        
          Owner user ID – 1001
        
          Group user ID – 1001
        
    When a function uses the access point, it is given user ID 1001 and has full access to the directory.
    For more information, see the following topics in the Amazon Elastic File System User Guide:
    
       
       
    
        Creating resources for Amazon EFS
      
        Working with users, groups, and
          permissions
      
   
    Connecting to a file system (console)
    
    A function connects to a file system over the local network in a VPC. The subnets that your function connects to
      can be the same subnets that contain mount points for your file system, or subnets in the same Availability Zone
      that can route NFS traffic (port 2049) to the file system.
    NoteIf your function is not already connected to a VPC, see Giving Lambda functions access to resources in an Amazon VPC.
    To configure file system accessOpen the Functions page of the Lambda console.
        Choose a function.
      
        Choose Configuration and then choose File systems.
      
        Under File system, choose Add file system.
      
        Configure the following properties:
        
           
           
        
            EFS file system – The access point for a file system in the same VPC.
          
            Local mount path – The location where the file system is mounted on the
              Lambda function, starting with /mnt/.
          
      
    
    PricingAmazon EFS charges for storage and throughput, with rates that vary by storage class. For details, see Amazon EFS pricing.Lambda charges for data transfer between VPCs. This only applies if your function's VPC is peered to another
        VPC with a file system. The rates are the same as for Amazon EC2 data transfer between VPCs in the same Region. For
        details, see Lambda pricing.
  Document ConventionsInbound networkingAliasesDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideUse casesSupported features and limitationsSupported RegionsCompatibility considerationsPricingImproving startup performance with Lambda SnapStartLambda SnapStart can provide as low as sub-second startup performance, typically with no changes to your function code. SnapStart makes it easier to build highly responsive and scalable applications without provisioning resources or implementing complex performance optimizations.The largest contributor to startup latency (often referred to as cold start time) is the time that Lambda spends initializing the function, which includes loading the function's code, starting the runtime, and initializing the function code. With SnapStart, Lambda initializes your function when you publish a function version. Lambda takes a Firecracker
      microVM snapshot of the memory and disk state of the initialized execution environment, encrypts the snapshot, and intelligently caches it to optimize retrieval latency.To ensure resiliency, Lambda maintains several copies of each snapshot. Lambda automatically patches snapshots and their copies with the latest runtime and security updates. When you invoke the function version for the first time, and as the invocations scale up,
    Lambda resumes new execution environments from the cached snapshot instead of initializing them from scratch, improving
    startup latency.ImportantIf your applications depend on uniqueness of state, you must evaluate your function code and verify that it is
      resilient to snapshot operations. For more information, see Handling uniqueness with Lambda SnapStart.TopicsWhen to use SnapStartSupported features and limitationsSupported RegionsCompatibility considerationsSnapStart pricingActivating and managing Lambda SnapStartHandling uniqueness with Lambda SnapStartImplement code before or after Lambda function snapshotsMonitoring for Lambda SnapStartSecurity model for Lambda SnapStartMaximize Lambda SnapStart performanceTroubleshooting SnapStart errors for Lambda functions
    When to use SnapStart
    Lambda SnapStart is designed to address the latency variability introduced by one-time initialization code, such as loading module dependencies or frameworks. These operations can sometimes take several seconds to complete during the initial invocation. Use SnapStart to reduce this latency from several seconds to as low as sub-second, in optimal scenarios. SnapStart works best when used with function invocations at scale. Functions that are invoked infrequently might not experience the same performance improvements.
      SnapStart is particularly beneficial for two main types of applications:
    
       
       
    
        Latency-sensitive APIs and user flows: Functions that are part of critical API endpoints or user-facing flows can benefit from SnapStart's reduced latency and improved response times.
      
        Latency-sensitive data processing workflows: Time-bound data processing workflows that use Lambda functions can achieve better throughput by reducing outlier function initialization latency.
      
    Provisioned concurrency keeps functions initialized and ready to respond in double-digit milliseconds. Use provisioned concurrency if your application has strict cold start latency requirements that can't be adequately addressed by SnapStart.
   
    Supported features and limitations
    SnapStart is available for the following Lambda managed runtimes:
    
       
       
       
    
        Java 11 and later
      
        Python 3.12 and later
      
        .NET 8 and later. If you're using the Lambda Annotations framework for .NET, upgrade to Amazon.Lambda.Annotations version 1.6.0 or later to ensure compatibility with SnapStart.
      
    Other managed runtimes (such as nodejs22.x and ruby3.4), OS-only runtimes, and container images are not supported.
    SnapStart does not support provisioned concurrency, Amazon Elastic File System (Amazon EFS), or ephemeral
      storage greater than 512 MB.
    NoteYou can use SnapStart only on published function
          versions and aliases that point to versions. You can't use
        SnapStart on a function's unpublished version ($LATEST).
   
    Supported Regions
    For Java runtimes, Lambda SnapStart is available in all commercial Regions except Asia Pacific (Malaysia).For Python and .NET runtimes, Lambda SnapStart is available in the following AWS Regions:
           
           
           
           
           
           
           
           
           
        US East (N. Virginia)US East (Ohio)US West (Oregon)Asia Pacific (Singapore)Asia Pacific (Sydney)Asia Pacific (Tokyo)Europe (Frankfurt)Europe (Ireland)Europe (Stockholm)
   
    Compatibility considerations
    
      With SnapStart, Lambda uses a single snapshot as the initial state for multiple execution environments. If
        your function uses any of the following during the initialization
          phase, then you might need to make some changes before using SnapStart:
       
       
       
    
        Uniqueness
        
          If your initialization code generates unique content that is included in the snapshot, then the content might not be unique when it is reused across execution environments. To maintain uniqueness when using SnapStart, you must generate unique content after initialization. This includes unique IDs, unique secrets, and entropy that's used to generate pseudorandomness. To learn how to restore uniqueness, see Handling uniqueness with Lambda SnapStart.
        
      
        Network connections
        
          The state of connections that your function establishes during the initialization phase isn't guaranteed when Lambda resumes your function from a snapshot. Validate the state of your network connections and re-establish them as necessary.
            In most cases, network connections that an AWS SDK establishes automatically resume. For other connections, review the best
              practices. 
        
      
        Temporary data
        
          Some functions download or initialize ephemeral data, such as temporary credentials or cached
            timestamps, during the initialization phase. Refresh ephemeral data in the function handler before using it, even when not using SnapStart.
        
      
   
    SnapStart pricing
    NoteFor Java managed runtimes, there's no additional cost for SnapStart. You're charged based on the number of requests for your functions,
        the time that it takes your code to run, and the memory configured for your function.
    The cost of using SnapStart includes the following:    
    
       
       
    
        Caching: For every function version that you publish with SnapStart enabled,  you pay for the cost of caching and maintaining the snapshot. The price depends on the amount of memory that you allocate to your function. You're charged for a minimum of 3 hours. You will continue to be charged as long as your function remains active. Use the ListVersionsByFunction API action to identify function versions, and then use DeleteFunction to delete unused versions. To automatically delete unused function versions, see the Lambda Version Cleanup pattern on Serverless Land.
      
        Restoration: Each time a function instance is restored from a snapshot, you pay a restoration charge. The price depends on the amount of memory you allocate to your function.
      
    As with all Lambda functions, duration charges apply to code that runs in the function handler. For SnapStart functions, duration charges also apply to initialization code that's declared outside of the handler, the time it takes for the runtime to load, and any code that runs in a runtime hook. Duration is calculated from the time that your code begins running until it returns or otherwise ends, rounded up to the nearest 1 ms. Lambda maintains cached copies of your snapshot for resiliency and automatically applies software updates, such as runtime upgrades and security patches to them. Charges apply each time that Lambda re-runs your initialization code to apply software updates.
    For more information about the cost of using SnapStart, see AWS Lambda Pricing.
  Document ConventionsTesting serverless functionsActivating SnapStartDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationReference guideAWS security credentialsAWS IP address rangesAWS APIsAWS services endpoints and quotasAWS GlossaryAWS General ReferenceThe AWS General Reference provides AWS service endpoint and quota information for Amazon Web Services. Additionally, you can find links to other common topics.ContentsAWS security credentialsAWS IP address rangesAWS APIsAWS services endpoints and quotasAWS Glossary
    AWS security credentials
    
    When you interact with AWS, you specify your AWS security
      credentials to verify who you are and whether you have permission to access the
      resources that you are requesting. AWS uses the security credentials to authenticate and
      authorize your requests.
 
    For more information, see the following resources:
        
    
       
       
      
    
      
      AWS security credentials in the
        IAM User GuideAWS
        security audit guidelines in the
        IAM User Guide
    
   
    AWS IP address ranges
    
    AWS publishes its current IP address ranges in JSON format. You can download
      a .json file to view current ranges. 
    The IP address ranges that you bring to AWS through bring your own IP addresses (BYOIP)
      are not included in the .json file.
    For more information, see the following resources:
    
    
       
       
    AWS IP address ranges in the
        Amazon VPC User GuideAWS services that support IPv6 in the
        Amazon VPC User Guide
   
    AWS APIs
    
    The following pages provide information that is useful when using an AWS API:
    
    
       
       
    Retry behavior in the
        AWS SDKs and Tools Reference GuideSigning AWS API requests in the
        IAM User Guide
    
   
    AWS services endpoints and quotas
    
    You can learn about the endpoints and service quotas in the following pages:
    
    
       
       
       
       
    AWS service endpointsAWS service quotasService endpoints and quotasSpecifying which AWS Regions your account can use in the AWS Account Management Guide
    
    
    
    
    
    
    
   
    AWS Glossary
    
    For the latest AWS terminology, see the AWS Glossary.  
  Document ConventionsAWS service endpointsDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideCreate environment variablesExample scenario for environment variablesRetrieve environment variablesDefined runtime environment variablesWorking with Lambda environment variablesYou can use environment variables to adjust your function's behavior without updating code. An environment
    variable is a pair of strings that is stored in a function's version-specific configuration. The Lambda runtime makes
    environment variables available to your code and sets additional environment variables that contain information
    about the function and invocation request.NoteTo increase security, we recommend that you use AWS Secrets Manager instead of environment variables to store
      database credentials and other sensitive information like API keys or authorization tokens. For more information, see Use Secrets Manager secrets in Lambda functions.Environment variables are not evaluated before the function invocation. Any value you define is considered a
    literal string and not expanded. Perform the variable evaluation in your function code.
    Creating Lambda environment variables
  You can configure environment variables in Lambda using the Lambda console, the AWS Command Line Interface (AWS CLI), AWS Serverless Application Model (AWS SAM), or using an AWS SDK.
 
   Console
       You define environment variables on the unpublished version of your function. When you publish a version, the
         environment variables are locked for that version along with other version-specific configuration settings.
       You create an environment variable for your function by defining a key and a value. Your function uses the
         name of the key to retrieve the value of the environment variable.
       To set environment variables in the Lambda consoleOpen the Functions page of the Lambda console.
           Choose a function.
         
           Choose the Configuration tab, then choose Environment variables.
         
           Under Environment variables, choose Edit.
         
           Choose Add environment variable.
         
           Enter a key and value.
           
             Requirements
              
              
              
              
           
               Keys start with a letter and are at least two characters.
             
               Keys only contain letters, numbers, and the underscore character (_).
             
               Keys aren't reserved by Lambda.
             
               The total size of all environment variables doesn't exceed 4 KB.
             
         
           Choose Save.
         
       To generate a list of environment variables in the console code editorYou can generate a list of environment variables in the Lambda code editor. This is a quick way to reference
           your environment variables while you code.
           Choose the Code tab.
         
           Scroll down to the ENVIRONMENT VARIABLES section of the code editor. Existing environment variables are listed here:
           
              
               
              
              
           
         
           To create new environment variables, choose the choose the plus sign (
                
                 
                
                
             ):
           
              
               
              
              
           
         
       Environment variables remain encrypted when listed in the console code editor. If you enabled encryption helpers for encryption in transit, then those settings remain unchanged. For more information, see Securing Lambda environment variables.
The environment variables list is read-only and is available only on the Lambda console. This file is not included when you download the function's .zip file archive, and you can't add environment variables by uploading this file.
     
   AWS CLI
       The following example sets two environment variables on a function named my-function.
       aws lambda update-function-configuration \
  --function-name my-function \
  --environment "Variables={BUCKET=amzn-s3-demo-bucket,KEY=file.txt}"
       When you apply environment variables with the update-function-configuration command, the entire
         contents of the Variables structure is replaced. To retain existing environment variables when you
         add a new one, include all existing values in your request.
       To get the current configuration, use the get-function-configuration command.
       aws lambda get-function-configuration \
  --function-name my-function
       You should see the following output:
       {
    "FunctionName": "my-function",
    "FunctionArn": "arn:aws:lambda:us-east-2:111122223333:function:my-function",
    "Runtime": "nodejs22.x",
    "Role": "arn:aws:iam::111122223333:role/lambda-role",
    "Environment": {
        "Variables": {
            "BUCKET": "amzn-s3-demo-bucket",
            "KEY": "file.txt"
        }
    },
    "RevisionId": "0894d3c1-2a3d-4d48-bf7f-abade99f3c15",
    ...
}
       You can pass the revision ID from the output of get-function-configuration as a parameter to
         update-function-configuration. This ensures that the values don't change between when you read the
         configuration and when you update it.
       
       To configure a function's encryption key, set the KMSKeyARN option.
       aws lambda update-function-configuration \
  --function-name my-function \
  --kms-key-arn arn:aws:kms:us-east-2:111122223333:key/055efbb4-xmpl-4336-ba9c-538c7d31f599
     
   AWS SAM
       You can use the  AWS Serverless Application Model to configure environment variables for your function. Update the Environment and Variables properties in your template.yaml file and then run sam deploy.
       Example template.yamlAWSTemplateFormatVersion: '2010-09-09'
Transform: AWS::Serverless-2016-10-31
Description: An AWS Serverless Application Model template describing your function.
Resources:
  my-function:
    Type: AWS::Serverless::Function
    Properties:
      CodeUri: .
      Description: ''
      MemorySize: 128
      Timeout: 120
      Handler: index.handler
      Runtime: nodejs22.x
      Architectures:
        - x86_64
      EphemeralStorage:
        Size: 10240
      Environment:
        Variables:
          BUCKET: amzn-s3-demo-bucket
          KEY: file.txt
      # Other function properties...   
     
   AWS SDKs
       To manage environment variables using an AWS SDK, use the following API operations.
         
         
       
       
       
    UpdateFunctionConfigurationGetFunctionConfigurationCreateFunction
       To learn more, refer to the AWS SDK documentation for your preferred programming language.
     
 
   
    Example scenario for environment variables
    
    You can use environment variables to customize function behavior in your test environment and production
      environment. For example, you can create two functions with the same code but different configurations. One
      function connects to a test database, and the other connects to a production database. In this situation, you use
      environment variables to pass the hostname and other connection details for the database to the function. 
    The following example shows how to define the database host and database name as environment variables.
    
       
        
       
       
    
    If you want your test environment to generate more debug information than the production environment, you
      could set an environment variable to configure your test environment to use more verbose logging or more detailed
      tracing.
    For example, in your test environment, you could set an environment variable with the key LOG_LEVEL and a value indicating a log level of 
      debug or trace. In your Lambda function's code, you can then use this environment variable to set the log level.
    The following code examples in Python and Node.js illustrate how you can achieve this. These examples assume your environment variable has a 
      value of DEBUG in Python or debug in Node.js.
    
      Python
          Example Python code to set log levelimport os
import logging

# Initialize the logger
logger = logging.getLogger()

# Get the log level from the environment variable and default to INFO if not set
log_level = os.environ.get('LOG_LEVEL', 'INFO')

# Set the log level
logger.setLevel(log_level)

def lambda_handler(event, context):
    # Produce some example log outputs
    logger.debug('This is a log with detailed debug information - shown only in test environment')
    logger.info('This is a log with standard information - shown in production and test environments')
    

        
      Node.js (ES module format)
          Example Node.js code to set log levelThis example uses the winston logging library. Use npm to add this library to your function's deployment package. For more information, see
              Creating a .zip deployment package with dependencies.import winston from 'winston';

// Initialize the logger using the log level from environment variables, defaulting to INFO if not set
const logger = winston.createLogger({
   level: process.env.LOG_LEVEL || 'info',
   format: winston.format.json(),
   transports: [new winston.transports.Console()]
});

export const handler = async (event) => {
   // Produce some example log outputs
   logger.debug('This is a log with detailed debug information - shown only in test environment');
   logger.info('This is a log with standard information - shown in production and test environment');
   
};
        
    
   
    Retrieving Lambda environment variables
    To retrieve environment variables in your function code, use the standard method for your programming
      language.
    
      Node.js
          let region = process.env.AWS_REGION
        
      Python
          import os
  region = os.environ['AWS_REGION']
          NoteIn some cases, you may need to use the following format:region = os.environ.get('AWS_REGION')
        
      Ruby
          region = ENV["AWS_REGION"]
        
      Java
          String region = System.getenv("AWS_REGION");
        
      Go
          var region = os.Getenv("AWS_REGION")
        
      C#
          string region = Environment.GetEnvironmentVariable("AWS_REGION");
        
      PowerShell
          $region = $env:AWS_REGION
        
    
    
    Lambda stores environment variables securely by encrypting them at rest. You can configure Lambda to use a different encryption key, encrypt
      environment variable values on the client side, or set environment variables in an AWS CloudFormation template with
      AWS Secrets Manager.
   
    Defined runtime environment variables
    Lambda runtimes set several environment variables during initialization.
      Most of the environment variables provide information about the function or runtime. The keys for these
      environment variables are reserved and cannot be set in your function configuration.
    
      Reserved environment variables
       
       
       
       
       
       
       
       
       
       
       
       
       
       
    
        _HANDLER – The handler location configured on the function.
      
        _X_AMZN_TRACE_ID – The X-Ray tracing
          header. This environment variable changes with each invocation.
        
           
           
        
            This environment variable is not defined for OS-only runtimes (the provided runtime family).
              You can set _X_AMZN_TRACE_ID for custom runtimes using the
              Lambda-Runtime-Trace-Id response header from the
              Next invocation.
          
            For Java runtime versions 17 and later, this environment variable is not used.
              Instead, Lambda stores tracing information in the com.amazonaws.xray.traceHeader
              system property.
          
      
        AWS_DEFAULT_REGION – The default AWS Region where the Lambda function is executed.
      
        AWS_REGION – The AWS Region where the Lambda function is executed. If defined, this value overrides the AWS_DEFAULT_REGION.
        
           
        
            For more information about using the AWS Region environment variables with AWS SDKs, see AWS Region 
              in the AWS SDKs and Tools Reference Guide.
          
      
        AWS_EXECUTION_ENV – The runtime identifier,
          prefixed by AWS_Lambda_ (for example, AWS_Lambda_java8). This environment variable is not defined for OS-only runtimes (the provided runtime family).
      
        AWS_LAMBDA_FUNCTION_NAME – The name of the function.
      
        AWS_LAMBDA_FUNCTION_MEMORY_SIZE – The amount of memory available to the function in
          MB.
      
        AWS_LAMBDA_FUNCTION_VERSION – The version of the function being
          executed.
      
        AWS_LAMBDA_INITIALIZATION_TYPE – The initialization type of the function, which is on-demand, provisioned-concurrency, or snap-start. For information, see  Configuring provisioned concurrency or Improving startup performance with Lambda SnapStart.
      
        AWS_LAMBDA_LOG_GROUP_NAME, AWS_LAMBDA_LOG_STREAM_NAME – The name of the
          Amazon CloudWatch Logs group and stream for the function. The AWS_LAMBDA_LOG_GROUP_NAME and AWS_LAMBDA_LOG_STREAM_NAME environment variables are not available in Lambda SnapStart functions.
      
        AWS_ACCESS_KEY, AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY, AWS_SESSION_TOKEN
          – The access keys obtained from the function's execution
            role.
      
        AWS_LAMBDA_RUNTIME_API – (Custom runtime) The
          host and port of the runtime API.
      
        LAMBDA_TASK_ROOT – The path to your Lambda function code.
      
        LAMBDA_RUNTIME_DIR – The path to runtime libraries.
      
    The following additional environment variables aren't reserved and can be extended in your function
      configuration.
    
      Unreserved environment variables
       
       
       
       
       
       
       
       
       
       
    
        LANG – The locale of the runtime (en_US.UTF-8).
      
        PATH – The execution path
          (/usr/local/bin:/usr/bin/:/bin:/opt/bin).
      
        LD_LIBRARY_PATH – The system library path
          (/var/lang/lib:/lib64:/usr/lib64:$LAMBDA_RUNTIME_DIR:$LAMBDA_RUNTIME_DIR/lib:$LAMBDA_TASK_ROOT:$LAMBDA_TASK_ROOT/lib:/opt/lib).
      
        NODE_PATH – (Node.js) The Node.js library path
          (/opt/nodejs/node12/node_modules/:/opt/nodejs/node_modules:$LAMBDA_RUNTIME_DIR/node_modules).
      
        PYTHONPATH – (Python) The Python
          library path ($LAMBDA_RUNTIME_DIR).
      
        GEM_PATH – (Ruby) The Ruby library path
          ($LAMBDA_TASK_ROOT/vendor/bundle/ruby/3.3.0:/opt/ruby/gems/3.3.0).
      
        AWS_XRAY_CONTEXT_MISSING – For X-Ray tracing, Lambda sets this to
          LOG_ERROR to avoid throwing runtime errors from the X-Ray SDK.
      
        AWS_XRAY_DAEMON_ADDRESS – For X-Ray tracing, the IP address and port of the X-Ray
          daemon.
      
        AWS_LAMBDA_DOTNET_PREJIT – (.NET) Set this variable to enable or
          disable .NET specific runtime optimizations. Values include always, never, and
          provisioned-concurrency. For more information, see Configuring provisioned concurrency for a function.
      
        TZ – The environment's time zone (:UTC). The execution environment uses
          NTP to synchronize the system clock.
      
    The sample values shown reflect the latest runtimes. The presence of specific variables or their values can
      vary on earlier runtimes.
  Document ConventionsTimeoutSecuring environment variablesDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideCreate environment variablesExample scenario for environment variablesRetrieve environment variablesDefined runtime environment variablesWorking with Lambda environment variablesYou can use environment variables to adjust your function's behavior without updating code. An environment
    variable is a pair of strings that is stored in a function's version-specific configuration. The Lambda runtime makes
    environment variables available to your code and sets additional environment variables that contain information
    about the function and invocation request.NoteTo increase security, we recommend that you use AWS Secrets Manager instead of environment variables to store
      database credentials and other sensitive information like API keys or authorization tokens. For more information, see Use Secrets Manager secrets in Lambda functions.Environment variables are not evaluated before the function invocation. Any value you define is considered a
    literal string and not expanded. Perform the variable evaluation in your function code.
    Creating Lambda environment variables
  You can configure environment variables in Lambda using the Lambda console, the AWS Command Line Interface (AWS CLI), AWS Serverless Application Model (AWS SAM), or using an AWS SDK.
 
   Console
       You define environment variables on the unpublished version of your function. When you publish a version, the
         environment variables are locked for that version along with other version-specific configuration settings.
       You create an environment variable for your function by defining a key and a value. Your function uses the
         name of the key to retrieve the value of the environment variable.
       To set environment variables in the Lambda consoleOpen the Functions page of the Lambda console.
           Choose a function.
         
           Choose the Configuration tab, then choose Environment variables.
         
           Under Environment variables, choose Edit.
         
           Choose Add environment variable.
         
           Enter a key and value.
           
             Requirements
              
              
              
              
           
               Keys start with a letter and are at least two characters.
             
               Keys only contain letters, numbers, and the underscore character (_).
             
               Keys aren't reserved by Lambda.
             
               The total size of all environment variables doesn't exceed 4 KB.
             
         
           Choose Save.
         
       To generate a list of environment variables in the console code editorYou can generate a list of environment variables in the Lambda code editor. This is a quick way to reference
           your environment variables while you code.
           Choose the Code tab.
         
           Scroll down to the ENVIRONMENT VARIABLES section of the code editor. Existing environment variables are listed here:
           
              
               
              
              
           
         
           To create new environment variables, choose the choose the plus sign (
                
                 
                
                
             ):
           
              
               
              
              
           
         
       Environment variables remain encrypted when listed in the console code editor. If you enabled encryption helpers for encryption in transit, then those settings remain unchanged. For more information, see Securing Lambda environment variables.
The environment variables list is read-only and is available only on the Lambda console. This file is not included when you download the function's .zip file archive, and you can't add environment variables by uploading this file.
     
   AWS CLI
       The following example sets two environment variables on a function named my-function.
       aws lambda update-function-configuration \
  --function-name my-function \
  --environment "Variables={BUCKET=amzn-s3-demo-bucket,KEY=file.txt}"
       When you apply environment variables with the update-function-configuration command, the entire
         contents of the Variables structure is replaced. To retain existing environment variables when you
         add a new one, include all existing values in your request.
       To get the current configuration, use the get-function-configuration command.
       aws lambda get-function-configuration \
  --function-name my-function
       You should see the following output:
       {
    "FunctionName": "my-function",
    "FunctionArn": "arn:aws:lambda:us-east-2:111122223333:function:my-function",
    "Runtime": "nodejs22.x",
    "Role": "arn:aws:iam::111122223333:role/lambda-role",
    "Environment": {
        "Variables": {
            "BUCKET": "amzn-s3-demo-bucket",
            "KEY": "file.txt"
        }
    },
    "RevisionId": "0894d3c1-2a3d-4d48-bf7f-abade99f3c15",
    ...
}
       You can pass the revision ID from the output of get-function-configuration as a parameter to
         update-function-configuration. This ensures that the values don't change between when you read the
         configuration and when you update it.
       
       To configure a function's encryption key, set the KMSKeyARN option.
       aws lambda update-function-configuration \
  --function-name my-function \
  --kms-key-arn arn:aws:kms:us-east-2:111122223333:key/055efbb4-xmpl-4336-ba9c-538c7d31f599
     
   AWS SAM
       You can use the  AWS Serverless Application Model to configure environment variables for your function. Update the Environment and Variables properties in your template.yaml file and then run sam deploy.
       Example template.yamlAWSTemplateFormatVersion: '2010-09-09'
Transform: AWS::Serverless-2016-10-31
Description: An AWS Serverless Application Model template describing your function.
Resources:
  my-function:
    Type: AWS::Serverless::Function
    Properties:
      CodeUri: .
      Description: ''
      MemorySize: 128
      Timeout: 120
      Handler: index.handler
      Runtime: nodejs22.x
      Architectures:
        - x86_64
      EphemeralStorage:
        Size: 10240
      Environment:
        Variables:
          BUCKET: amzn-s3-demo-bucket
          KEY: file.txt
      # Other function properties...   
     
   AWS SDKs
       To manage environment variables using an AWS SDK, use the following API operations.
         
         
       
       
       
    UpdateFunctionConfigurationGetFunctionConfigurationCreateFunction
       To learn more, refer to the AWS SDK documentation for your preferred programming language.
     
 
   
    Example scenario for environment variables
    
    You can use environment variables to customize function behavior in your test environment and production
      environment. For example, you can create two functions with the same code but different configurations. One
      function connects to a test database, and the other connects to a production database. In this situation, you use
      environment variables to pass the hostname and other connection details for the database to the function. 
    The following example shows how to define the database host and database name as environment variables.
    
       
        
       
       
    
    If you want your test environment to generate more debug information than the production environment, you
      could set an environment variable to configure your test environment to use more verbose logging or more detailed
      tracing.
    For example, in your test environment, you could set an environment variable with the key LOG_LEVEL and a value indicating a log level of 
      debug or trace. In your Lambda function's code, you can then use this environment variable to set the log level.
    The following code examples in Python and Node.js illustrate how you can achieve this. These examples assume your environment variable has a 
      value of DEBUG in Python or debug in Node.js.
    
      Python
          Example Python code to set log levelimport os
import logging

# Initialize the logger
logger = logging.getLogger()

# Get the log level from the environment variable and default to INFO if not set
log_level = os.environ.get('LOG_LEVEL', 'INFO')

# Set the log level
logger.setLevel(log_level)

def lambda_handler(event, context):
    # Produce some example log outputs
    logger.debug('This is a log with detailed debug information - shown only in test environment')
    logger.info('This is a log with standard information - shown in production and test environments')
    

        
      Node.js (ES module format)
          Example Node.js code to set log levelThis example uses the winston logging library. Use npm to add this library to your function's deployment package. For more information, see
              Creating a .zip deployment package with dependencies.import winston from 'winston';

// Initialize the logger using the log level from environment variables, defaulting to INFO if not set
const logger = winston.createLogger({
   level: process.env.LOG_LEVEL || 'info',
   format: winston.format.json(),
   transports: [new winston.transports.Console()]
});

export const handler = async (event) => {
   // Produce some example log outputs
   logger.debug('This is a log with detailed debug information - shown only in test environment');
   logger.info('This is a log with standard information - shown in production and test environment');
   
};
        
    
   
    Retrieving Lambda environment variables
    To retrieve environment variables in your function code, use the standard method for your programming
      language.
    
      Node.js
          let region = process.env.AWS_REGION
        
      Python
          import os
  region = os.environ['AWS_REGION']
          NoteIn some cases, you may need to use the following format:region = os.environ.get('AWS_REGION')
        
      Ruby
          region = ENV["AWS_REGION"]
        
      Java
          String region = System.getenv("AWS_REGION");
        
      Go
          var region = os.Getenv("AWS_REGION")
        
      C#
          string region = Environment.GetEnvironmentVariable("AWS_REGION");
        
      PowerShell
          $region = $env:AWS_REGION
        
    
    
    Lambda stores environment variables securely by encrypting them at rest. You can configure Lambda to use a different encryption key, encrypt
      environment variable values on the client side, or set environment variables in an AWS CloudFormation template with
      AWS Secrets Manager.
   
    Defined runtime environment variables
    Lambda runtimes set several environment variables during initialization.
      Most of the environment variables provide information about the function or runtime. The keys for these
      environment variables are reserved and cannot be set in your function configuration.
    
      Reserved environment variables
       
       
       
       
       
       
       
       
       
       
       
       
       
       
    
        _HANDLER – The handler location configured on the function.
      
        _X_AMZN_TRACE_ID – The X-Ray tracing
          header. This environment variable changes with each invocation.
        
           
           
        
            This environment variable is not defined for OS-only runtimes (the provided runtime family).
              You can set _X_AMZN_TRACE_ID for custom runtimes using the
              Lambda-Runtime-Trace-Id response header from the
              Next invocation.
          
            For Java runtime versions 17 and later, this environment variable is not used.
              Instead, Lambda stores tracing information in the com.amazonaws.xray.traceHeader
              system property.
          
      
        AWS_DEFAULT_REGION – The default AWS Region where the Lambda function is executed.
      
        AWS_REGION – The AWS Region where the Lambda function is executed. If defined, this value overrides the AWS_DEFAULT_REGION.
        
           
        
            For more information about using the AWS Region environment variables with AWS SDKs, see AWS Region 
              in the AWS SDKs and Tools Reference Guide.
          
      
        AWS_EXECUTION_ENV – The runtime identifier,
          prefixed by AWS_Lambda_ (for example, AWS_Lambda_java8). This environment variable is not defined for OS-only runtimes (the provided runtime family).
      
        AWS_LAMBDA_FUNCTION_NAME – The name of the function.
      
        AWS_LAMBDA_FUNCTION_MEMORY_SIZE – The amount of memory available to the function in
          MB.
      
        AWS_LAMBDA_FUNCTION_VERSION – The version of the function being
          executed.
      
        AWS_LAMBDA_INITIALIZATION_TYPE – The initialization type of the function, which is on-demand, provisioned-concurrency, or snap-start. For information, see  Configuring provisioned concurrency or Improving startup performance with Lambda SnapStart.
      
        AWS_LAMBDA_LOG_GROUP_NAME, AWS_LAMBDA_LOG_STREAM_NAME – The name of the
          Amazon CloudWatch Logs group and stream for the function. The AWS_LAMBDA_LOG_GROUP_NAME and AWS_LAMBDA_LOG_STREAM_NAME environment variables are not available in Lambda SnapStart functions.
      
        AWS_ACCESS_KEY, AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY, AWS_SESSION_TOKEN
          – The access keys obtained from the function's execution
            role.
      
        AWS_LAMBDA_RUNTIME_API – (Custom runtime) The
          host and port of the runtime API.
      
        LAMBDA_TASK_ROOT – The path to your Lambda function code.
      
        LAMBDA_RUNTIME_DIR – The path to runtime libraries.
      
    The following additional environment variables aren't reserved and can be extended in your function
      configuration.
    
      Unreserved environment variables
       
       
       
       
       
       
       
       
       
       
    
        LANG – The locale of the runtime (en_US.UTF-8).
      
        PATH – The execution path
          (/usr/local/bin:/usr/bin/:/bin:/opt/bin).
      
        LD_LIBRARY_PATH – The system library path
          (/var/lang/lib:/lib64:/usr/lib64:$LAMBDA_RUNTIME_DIR:$LAMBDA_RUNTIME_DIR/lib:$LAMBDA_TASK_ROOT:$LAMBDA_TASK_ROOT/lib:/opt/lib).
      
        NODE_PATH – (Node.js) The Node.js library path
          (/opt/nodejs/node12/node_modules/:/opt/nodejs/node_modules:$LAMBDA_RUNTIME_DIR/node_modules).
      
        PYTHONPATH – (Python) The Python
          library path ($LAMBDA_RUNTIME_DIR).
      
        GEM_PATH – (Ruby) The Ruby library path
          ($LAMBDA_TASK_ROOT/vendor/bundle/ruby/3.3.0:/opt/ruby/gems/3.3.0).
      
        AWS_XRAY_CONTEXT_MISSING – For X-Ray tracing, Lambda sets this to
          LOG_ERROR to avoid throwing runtime errors from the X-Ray SDK.
      
        AWS_XRAY_DAEMON_ADDRESS – For X-Ray tracing, the IP address and port of the X-Ray
          daemon.
      
        AWS_LAMBDA_DOTNET_PREJIT – (.NET) Set this variable to enable or
          disable .NET specific runtime optimizations. Values include always, never, and
          provisioned-concurrency. For more information, see Configuring provisioned concurrency for a function.
      
        TZ – The environment's time zone (:UTC). The execution environment uses
          NTP to synchronize the system clock.
      
    The sample values shown reflect the latest runtimes. The presence of specific variables or their values can
      vary on earlier runtimes.
  Document ConventionsTimeoutSecuring environment variablesDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideCreate environment variablesExample scenario for environment variablesRetrieve environment variablesDefined runtime environment variablesWorking with Lambda environment variablesYou can use environment variables to adjust your function's behavior without updating code. An environment
    variable is a pair of strings that is stored in a function's version-specific configuration. The Lambda runtime makes
    environment variables available to your code and sets additional environment variables that contain information
    about the function and invocation request.NoteTo increase security, we recommend that you use AWS Secrets Manager instead of environment variables to store
      database credentials and other sensitive information like API keys or authorization tokens. For more information, see Use Secrets Manager secrets in Lambda functions.Environment variables are not evaluated before the function invocation. Any value you define is considered a
    literal string and not expanded. Perform the variable evaluation in your function code.
    Creating Lambda environment variables
  You can configure environment variables in Lambda using the Lambda console, the AWS Command Line Interface (AWS CLI), AWS Serverless Application Model (AWS SAM), or using an AWS SDK.
 
   Console
       You define environment variables on the unpublished version of your function. When you publish a version, the
         environment variables are locked for that version along with other version-specific configuration settings.
       You create an environment variable for your function by defining a key and a value. Your function uses the
         name of the key to retrieve the value of the environment variable.
       To set environment variables in the Lambda consoleOpen the Functions page of the Lambda console.
           Choose a function.
         
           Choose the Configuration tab, then choose Environment variables.
         
           Under Environment variables, choose Edit.
         
           Choose Add environment variable.
         
           Enter a key and value.
           
             Requirements
              
              
              
              
           
               Keys start with a letter and are at least two characters.
             
               Keys only contain letters, numbers, and the underscore character (_).
             
               Keys aren't reserved by Lambda.
             
               The total size of all environment variables doesn't exceed 4 KB.
             
         
           Choose Save.
         
       To generate a list of environment variables in the console code editorYou can generate a list of environment variables in the Lambda code editor. This is a quick way to reference
           your environment variables while you code.
           Choose the Code tab.
         
           Scroll down to the ENVIRONMENT VARIABLES section of the code editor. Existing environment variables are listed here:
           
              
               
              
              
           
         
           To create new environment variables, choose the choose the plus sign (
                
                 
                
                
             ):
           
              
               
              
              
           
         
       Environment variables remain encrypted when listed in the console code editor. If you enabled encryption helpers for encryption in transit, then those settings remain unchanged. For more information, see Securing Lambda environment variables.
The environment variables list is read-only and is available only on the Lambda console. This file is not included when you download the function's .zip file archive, and you can't add environment variables by uploading this file.
     
   AWS CLI
       The following example sets two environment variables on a function named my-function.
       aws lambda update-function-configuration \
  --function-name my-function \
  --environment "Variables={BUCKET=amzn-s3-demo-bucket,KEY=file.txt}"
       When you apply environment variables with the update-function-configuration command, the entire
         contents of the Variables structure is replaced. To retain existing environment variables when you
         add a new one, include all existing values in your request.
       To get the current configuration, use the get-function-configuration command.
       aws lambda get-function-configuration \
  --function-name my-function
       You should see the following output:
       {
    "FunctionName": "my-function",
    "FunctionArn": "arn:aws:lambda:us-east-2:111122223333:function:my-function",
    "Runtime": "nodejs22.x",
    "Role": "arn:aws:iam::111122223333:role/lambda-role",
    "Environment": {
        "Variables": {
            "BUCKET": "amzn-s3-demo-bucket",
            "KEY": "file.txt"
        }
    },
    "RevisionId": "0894d3c1-2a3d-4d48-bf7f-abade99f3c15",
    ...
}
       You can pass the revision ID from the output of get-function-configuration as a parameter to
         update-function-configuration. This ensures that the values don't change between when you read the
         configuration and when you update it.
       
       To configure a function's encryption key, set the KMSKeyARN option.
       aws lambda update-function-configuration \
  --function-name my-function \
  --kms-key-arn arn:aws:kms:us-east-2:111122223333:key/055efbb4-xmpl-4336-ba9c-538c7d31f599
     
   AWS SAM
       You can use the  AWS Serverless Application Model to configure environment variables for your function. Update the Environment and Variables properties in your template.yaml file and then run sam deploy.
       Example template.yamlAWSTemplateFormatVersion: '2010-09-09'
Transform: AWS::Serverless-2016-10-31
Description: An AWS Serverless Application Model template describing your function.
Resources:
  my-function:
    Type: AWS::Serverless::Function
    Properties:
      CodeUri: .
      Description: ''
      MemorySize: 128
      Timeout: 120
      Handler: index.handler
      Runtime: nodejs22.x
      Architectures:
        - x86_64
      EphemeralStorage:
        Size: 10240
      Environment:
        Variables:
          BUCKET: amzn-s3-demo-bucket
          KEY: file.txt
      # Other function properties...   
     
   AWS SDKs
       To manage environment variables using an AWS SDK, use the following API operations.
         
         
       
       
       
    UpdateFunctionConfigurationGetFunctionConfigurationCreateFunction
       To learn more, refer to the AWS SDK documentation for your preferred programming language.
     
 
   
    Example scenario for environment variables
    
    You can use environment variables to customize function behavior in your test environment and production
      environment. For example, you can create two functions with the same code but different configurations. One
      function connects to a test database, and the other connects to a production database. In this situation, you use
      environment variables to pass the hostname and other connection details for the database to the function. 
    The following example shows how to define the database host and database name as environment variables.
    
       
        
       
       
    
    If you want your test environment to generate more debug information than the production environment, you
      could set an environment variable to configure your test environment to use more verbose logging or more detailed
      tracing.
    For example, in your test environment, you could set an environment variable with the key LOG_LEVEL and a value indicating a log level of 
      debug or trace. In your Lambda function's code, you can then use this environment variable to set the log level.
    The following code examples in Python and Node.js illustrate how you can achieve this. These examples assume your environment variable has a 
      value of DEBUG in Python or debug in Node.js.
    
      Python
          Example Python code to set log levelimport os
import logging

# Initialize the logger
logger = logging.getLogger()

# Get the log level from the environment variable and default to INFO if not set
log_level = os.environ.get('LOG_LEVEL', 'INFO')

# Set the log level
logger.setLevel(log_level)

def lambda_handler(event, context):
    # Produce some example log outputs
    logger.debug('This is a log with detailed debug information - shown only in test environment')
    logger.info('This is a log with standard information - shown in production and test environments')
    

        
      Node.js (ES module format)
          Example Node.js code to set log levelThis example uses the winston logging library. Use npm to add this library to your function's deployment package. For more information, see
              Creating a .zip deployment package with dependencies.import winston from 'winston';

// Initialize the logger using the log level from environment variables, defaulting to INFO if not set
const logger = winston.createLogger({
   level: process.env.LOG_LEVEL || 'info',
   format: winston.format.json(),
   transports: [new winston.transports.Console()]
});

export const handler = async (event) => {
   // Produce some example log outputs
   logger.debug('This is a log with detailed debug information - shown only in test environment');
   logger.info('This is a log with standard information - shown in production and test environment');
   
};
        
    
   
    Retrieving Lambda environment variables
    To retrieve environment variables in your function code, use the standard method for your programming
      language.
    
      Node.js
          let region = process.env.AWS_REGION
        
      Python
          import os
  region = os.environ['AWS_REGION']
          NoteIn some cases, you may need to use the following format:region = os.environ.get('AWS_REGION')
        
      Ruby
          region = ENV["AWS_REGION"]
        
      Java
          String region = System.getenv("AWS_REGION");
        
      Go
          var region = os.Getenv("AWS_REGION")
        
      C#
          string region = Environment.GetEnvironmentVariable("AWS_REGION");
        
      PowerShell
          $region = $env:AWS_REGION
        
    
    
    Lambda stores environment variables securely by encrypting them at rest. You can configure Lambda to use a different encryption key, encrypt
      environment variable values on the client side, or set environment variables in an AWS CloudFormation template with
      AWS Secrets Manager.
   
    Defined runtime environment variables
    Lambda runtimes set several environment variables during initialization.
      Most of the environment variables provide information about the function or runtime. The keys for these
      environment variables are reserved and cannot be set in your function configuration.
    
      Reserved environment variables
       
       
       
       
       
       
       
       
       
       
       
       
       
       
    
        _HANDLER – The handler location configured on the function.
      
        _X_AMZN_TRACE_ID – The X-Ray tracing
          header. This environment variable changes with each invocation.
        
           
           
        
            This environment variable is not defined for OS-only runtimes (the provided runtime family).
              You can set _X_AMZN_TRACE_ID for custom runtimes using the
              Lambda-Runtime-Trace-Id response header from the
              Next invocation.
          
            For Java runtime versions 17 and later, this environment variable is not used.
              Instead, Lambda stores tracing information in the com.amazonaws.xray.traceHeader
              system property.
          
      
        AWS_DEFAULT_REGION – The default AWS Region where the Lambda function is executed.
      
        AWS_REGION – The AWS Region where the Lambda function is executed. If defined, this value overrides the AWS_DEFAULT_REGION.
        
           
        
            For more information about using the AWS Region environment variables with AWS SDKs, see AWS Region 
              in the AWS SDKs and Tools Reference Guide.
          
      
        AWS_EXECUTION_ENV – The runtime identifier,
          prefixed by AWS_Lambda_ (for example, AWS_Lambda_java8). This environment variable is not defined for OS-only runtimes (the provided runtime family).
      
        AWS_LAMBDA_FUNCTION_NAME – The name of the function.
      
        AWS_LAMBDA_FUNCTION_MEMORY_SIZE – The amount of memory available to the function in
          MB.
      
        AWS_LAMBDA_FUNCTION_VERSION – The version of the function being
          executed.
      
        AWS_LAMBDA_INITIALIZATION_TYPE – The initialization type of the function, which is on-demand, provisioned-concurrency, or snap-start. For information, see  Configuring provisioned concurrency or Improving startup performance with Lambda SnapStart.
      
        AWS_LAMBDA_LOG_GROUP_NAME, AWS_LAMBDA_LOG_STREAM_NAME – The name of the
          Amazon CloudWatch Logs group and stream for the function. The AWS_LAMBDA_LOG_GROUP_NAME and AWS_LAMBDA_LOG_STREAM_NAME environment variables are not available in Lambda SnapStart functions.
      
        AWS_ACCESS_KEY, AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY, AWS_SESSION_TOKEN
          – The access keys obtained from the function's execution
            role.
      
        AWS_LAMBDA_RUNTIME_API – (Custom runtime) The
          host and port of the runtime API.
      
        LAMBDA_TASK_ROOT – The path to your Lambda function code.
      
        LAMBDA_RUNTIME_DIR – The path to runtime libraries.
      
    The following additional environment variables aren't reserved and can be extended in your function
      configuration.
    
      Unreserved environment variables
       
       
       
       
       
       
       
       
       
       
    
        LANG – The locale of the runtime (en_US.UTF-8).
      
        PATH – The execution path
          (/usr/local/bin:/usr/bin/:/bin:/opt/bin).
      
        LD_LIBRARY_PATH – The system library path
          (/var/lang/lib:/lib64:/usr/lib64:$LAMBDA_RUNTIME_DIR:$LAMBDA_RUNTIME_DIR/lib:$LAMBDA_TASK_ROOT:$LAMBDA_TASK_ROOT/lib:/opt/lib).
      
        NODE_PATH – (Node.js) The Node.js library path
          (/opt/nodejs/node12/node_modules/:/opt/nodejs/node_modules:$LAMBDA_RUNTIME_DIR/node_modules).
      
        PYTHONPATH – (Python) The Python
          library path ($LAMBDA_RUNTIME_DIR).
      
        GEM_PATH – (Ruby) The Ruby library path
          ($LAMBDA_TASK_ROOT/vendor/bundle/ruby/3.3.0:/opt/ruby/gems/3.3.0).
      
        AWS_XRAY_CONTEXT_MISSING – For X-Ray tracing, Lambda sets this to
          LOG_ERROR to avoid throwing runtime errors from the X-Ray SDK.
      
        AWS_XRAY_DAEMON_ADDRESS – For X-Ray tracing, the IP address and port of the X-Ray
          daemon.
      
        AWS_LAMBDA_DOTNET_PREJIT – (.NET) Set this variable to enable or
          disable .NET specific runtime optimizations. Values include always, never, and
          provisioned-concurrency. For more information, see Configuring provisioned concurrency for a function.
      
        TZ – The environment's time zone (:UTC). The execution environment uses
          NTP to synchronize the system clock.
      
    The sample values shown reflect the latest runtimes. The presence of specific variables or their values can
      vary on earlier runtimes.
  Document ConventionsTimeoutSecuring environment variablesDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideCreate environment variablesExample scenario for environment variablesRetrieve environment variablesDefined runtime environment variablesWorking with Lambda environment variablesYou can use environment variables to adjust your function's behavior without updating code. An environment
    variable is a pair of strings that is stored in a function's version-specific configuration. The Lambda runtime makes
    environment variables available to your code and sets additional environment variables that contain information
    about the function and invocation request.NoteTo increase security, we recommend that you use AWS Secrets Manager instead of environment variables to store
      database credentials and other sensitive information like API keys or authorization tokens. For more information, see Use Secrets Manager secrets in Lambda functions.Environment variables are not evaluated before the function invocation. Any value you define is considered a
    literal string and not expanded. Perform the variable evaluation in your function code.
    Creating Lambda environment variables
  You can configure environment variables in Lambda using the Lambda console, the AWS Command Line Interface (AWS CLI), AWS Serverless Application Model (AWS SAM), or using an AWS SDK.
 
   Console
       You define environment variables on the unpublished version of your function. When you publish a version, the
         environment variables are locked for that version along with other version-specific configuration settings.
       You create an environment variable for your function by defining a key and a value. Your function uses the
         name of the key to retrieve the value of the environment variable.
       To set environment variables in the Lambda consoleOpen the Functions page of the Lambda console.
           Choose a function.
         
           Choose the Configuration tab, then choose Environment variables.
         
           Under Environment variables, choose Edit.
         
           Choose Add environment variable.
         
           Enter a key and value.
           
             Requirements
              
              
              
              
           
               Keys start with a letter and are at least two characters.
             
               Keys only contain letters, numbers, and the underscore character (_).
             
               Keys aren't reserved by Lambda.
             
               The total size of all environment variables doesn't exceed 4 KB.
             
         
           Choose Save.
         
       To generate a list of environment variables in the console code editorYou can generate a list of environment variables in the Lambda code editor. This is a quick way to reference
           your environment variables while you code.
           Choose the Code tab.
         
           Scroll down to the ENVIRONMENT VARIABLES section of the code editor. Existing environment variables are listed here:
           
              
               
              
              
           
         
           To create new environment variables, choose the choose the plus sign (
                
                 
                
                
             ):
           
              
               
              
              
           
         
       Environment variables remain encrypted when listed in the console code editor. If you enabled encryption helpers for encryption in transit, then those settings remain unchanged. For more information, see Securing Lambda environment variables.
The environment variables list is read-only and is available only on the Lambda console. This file is not included when you download the function's .zip file archive, and you can't add environment variables by uploading this file.
     
   AWS CLI
       The following example sets two environment variables on a function named my-function.
       aws lambda update-function-configuration \
  --function-name my-function \
  --environment "Variables={BUCKET=amzn-s3-demo-bucket,KEY=file.txt}"
       When you apply environment variables with the update-function-configuration command, the entire
         contents of the Variables structure is replaced. To retain existing environment variables when you
         add a new one, include all existing values in your request.
       To get the current configuration, use the get-function-configuration command.
       aws lambda get-function-configuration \
  --function-name my-function
       You should see the following output:
       {
    "FunctionName": "my-function",
    "FunctionArn": "arn:aws:lambda:us-east-2:111122223333:function:my-function",
    "Runtime": "nodejs22.x",
    "Role": "arn:aws:iam::111122223333:role/lambda-role",
    "Environment": {
        "Variables": {
            "BUCKET": "amzn-s3-demo-bucket",
            "KEY": "file.txt"
        }
    },
    "RevisionId": "0894d3c1-2a3d-4d48-bf7f-abade99f3c15",
    ...
}
       You can pass the revision ID from the output of get-function-configuration as a parameter to
         update-function-configuration. This ensures that the values don't change between when you read the
         configuration and when you update it.
       
       To configure a function's encryption key, set the KMSKeyARN option.
       aws lambda update-function-configuration \
  --function-name my-function \
  --kms-key-arn arn:aws:kms:us-east-2:111122223333:key/055efbb4-xmpl-4336-ba9c-538c7d31f599
     
   AWS SAM
       You can use the  AWS Serverless Application Model to configure environment variables for your function. Update the Environment and Variables properties in your template.yaml file and then run sam deploy.
       Example template.yamlAWSTemplateFormatVersion: '2010-09-09'
Transform: AWS::Serverless-2016-10-31
Description: An AWS Serverless Application Model template describing your function.
Resources:
  my-function:
    Type: AWS::Serverless::Function
    Properties:
      CodeUri: .
      Description: ''
      MemorySize: 128
      Timeout: 120
      Handler: index.handler
      Runtime: nodejs22.x
      Architectures:
        - x86_64
      EphemeralStorage:
        Size: 10240
      Environment:
        Variables:
          BUCKET: amzn-s3-demo-bucket
          KEY: file.txt
      # Other function properties...   
     
   AWS SDKs
       To manage environment variables using an AWS SDK, use the following API operations.
         
         
       
       
       
    UpdateFunctionConfigurationGetFunctionConfigurationCreateFunction
       To learn more, refer to the AWS SDK documentation for your preferred programming language.
     
 
   
    Example scenario for environment variables
    
    You can use environment variables to customize function behavior in your test environment and production
      environment. For example, you can create two functions with the same code but different configurations. One
      function connects to a test database, and the other connects to a production database. In this situation, you use
      environment variables to pass the hostname and other connection details for the database to the function. 
    The following example shows how to define the database host and database name as environment variables.
    
       
        
       
       
    
    If you want your test environment to generate more debug information than the production environment, you
      could set an environment variable to configure your test environment to use more verbose logging or more detailed
      tracing.
    For example, in your test environment, you could set an environment variable with the key LOG_LEVEL and a value indicating a log level of 
      debug or trace. In your Lambda function's code, you can then use this environment variable to set the log level.
    The following code examples in Python and Node.js illustrate how you can achieve this. These examples assume your environment variable has a 
      value of DEBUG in Python or debug in Node.js.
    
      Python
          Example Python code to set log levelimport os
import logging

# Initialize the logger
logger = logging.getLogger()

# Get the log level from the environment variable and default to INFO if not set
log_level = os.environ.get('LOG_LEVEL', 'INFO')

# Set the log level
logger.setLevel(log_level)

def lambda_handler(event, context):
    # Produce some example log outputs
    logger.debug('This is a log with detailed debug information - shown only in test environment')
    logger.info('This is a log with standard information - shown in production and test environments')
    

        
      Node.js (ES module format)
          Example Node.js code to set log levelThis example uses the winston logging library. Use npm to add this library to your function's deployment package. For more information, see
              Creating a .zip deployment package with dependencies.import winston from 'winston';

// Initialize the logger using the log level from environment variables, defaulting to INFO if not set
const logger = winston.createLogger({
   level: process.env.LOG_LEVEL || 'info',
   format: winston.format.json(),
   transports: [new winston.transports.Console()]
});

export const handler = async (event) => {
   // Produce some example log outputs
   logger.debug('This is a log with detailed debug information - shown only in test environment');
   logger.info('This is a log with standard information - shown in production and test environment');
   
};
        
    
   
    Retrieving Lambda environment variables
    To retrieve environment variables in your function code, use the standard method for your programming
      language.
    
      Node.js
          let region = process.env.AWS_REGION
        
      Python
          import os
  region = os.environ['AWS_REGION']
          NoteIn some cases, you may need to use the following format:region = os.environ.get('AWS_REGION')
        
      Ruby
          region = ENV["AWS_REGION"]
        
      Java
          String region = System.getenv("AWS_REGION");
        
      Go
          var region = os.Getenv("AWS_REGION")
        
      C#
          string region = Environment.GetEnvironmentVariable("AWS_REGION");
        
      PowerShell
          $region = $env:AWS_REGION
        
    
    
    Lambda stores environment variables securely by encrypting them at rest. You can configure Lambda to use a different encryption key, encrypt
      environment variable values on the client side, or set environment variables in an AWS CloudFormation template with
      AWS Secrets Manager.
   
    Defined runtime environment variables
    Lambda runtimes set several environment variables during initialization.
      Most of the environment variables provide information about the function or runtime. The keys for these
      environment variables are reserved and cannot be set in your function configuration.
    
      Reserved environment variables
       
       
       
       
       
       
       
       
       
       
       
       
       
       
    
        _HANDLER – The handler location configured on the function.
      
        _X_AMZN_TRACE_ID – The X-Ray tracing
          header. This environment variable changes with each invocation.
        
           
           
        
            This environment variable is not defined for OS-only runtimes (the provided runtime family).
              You can set _X_AMZN_TRACE_ID for custom runtimes using the
              Lambda-Runtime-Trace-Id response header from the
              Next invocation.
          
            For Java runtime versions 17 and later, this environment variable is not used.
              Instead, Lambda stores tracing information in the com.amazonaws.xray.traceHeader
              system property.
          
      
        AWS_DEFAULT_REGION – The default AWS Region where the Lambda function is executed.
      
        AWS_REGION – The AWS Region where the Lambda function is executed. If defined, this value overrides the AWS_DEFAULT_REGION.
        
           
        
            For more information about using the AWS Region environment variables with AWS SDKs, see AWS Region 
              in the AWS SDKs and Tools Reference Guide.
          
      
        AWS_EXECUTION_ENV – The runtime identifier,
          prefixed by AWS_Lambda_ (for example, AWS_Lambda_java8). This environment variable is not defined for OS-only runtimes (the provided runtime family).
      
        AWS_LAMBDA_FUNCTION_NAME – The name of the function.
      
        AWS_LAMBDA_FUNCTION_MEMORY_SIZE – The amount of memory available to the function in
          MB.
      
        AWS_LAMBDA_FUNCTION_VERSION – The version of the function being
          executed.
      
        AWS_LAMBDA_INITIALIZATION_TYPE – The initialization type of the function, which is on-demand, provisioned-concurrency, or snap-start. For information, see  Configuring provisioned concurrency or Improving startup performance with Lambda SnapStart.
      
        AWS_LAMBDA_LOG_GROUP_NAME, AWS_LAMBDA_LOG_STREAM_NAME – The name of the
          Amazon CloudWatch Logs group and stream for the function. The AWS_LAMBDA_LOG_GROUP_NAME and AWS_LAMBDA_LOG_STREAM_NAME environment variables are not available in Lambda SnapStart functions.
      
        AWS_ACCESS_KEY, AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY, AWS_SESSION_TOKEN
          – The access keys obtained from the function's execution
            role.
      
        AWS_LAMBDA_RUNTIME_API – (Custom runtime) The
          host and port of the runtime API.
      
        LAMBDA_TASK_ROOT – The path to your Lambda function code.
      
        LAMBDA_RUNTIME_DIR – The path to runtime libraries.
      
    The following additional environment variables aren't reserved and can be extended in your function
      configuration.
    
      Unreserved environment variables
       
       
       
       
       
       
       
       
       
       
    
        LANG – The locale of the runtime (en_US.UTF-8).
      
        PATH – The execution path
          (/usr/local/bin:/usr/bin/:/bin:/opt/bin).
      
        LD_LIBRARY_PATH – The system library path
          (/var/lang/lib:/lib64:/usr/lib64:$LAMBDA_RUNTIME_DIR:$LAMBDA_RUNTIME_DIR/lib:$LAMBDA_TASK_ROOT:$LAMBDA_TASK_ROOT/lib:/opt/lib).
      
        NODE_PATH – (Node.js) The Node.js library path
          (/opt/nodejs/node12/node_modules/:/opt/nodejs/node_modules:$LAMBDA_RUNTIME_DIR/node_modules).
      
        PYTHONPATH – (Python) The Python
          library path ($LAMBDA_RUNTIME_DIR).
      
        GEM_PATH – (Ruby) The Ruby library path
          ($LAMBDA_TASK_ROOT/vendor/bundle/ruby/3.3.0:/opt/ruby/gems/3.3.0).
      
        AWS_XRAY_CONTEXT_MISSING – For X-Ray tracing, Lambda sets this to
          LOG_ERROR to avoid throwing runtime errors from the X-Ray SDK.
      
        AWS_XRAY_DAEMON_ADDRESS – For X-Ray tracing, the IP address and port of the X-Ray
          daemon.
      
        AWS_LAMBDA_DOTNET_PREJIT – (.NET) Set this variable to enable or
          disable .NET specific runtime optimizations. Values include always, never, and
          provisioned-concurrency. For more information, see Configuring provisioned concurrency for a function.
      
        TZ – The environment's time zone (:UTC). The execution environment uses
          NTP to synchronize the system clock.
      
    The sample values shown reflect the latest runtimes. The presence of specific variables or their values can
      vary on earlier runtimes.
  Document ConventionsTimeoutSecuring environment variablesDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideWhen to use Secrets ManagerUse Secrets Manager in a functionEnvironment variablesSecret rotationUse Secrets Manager secrets in Lambda functionsAWS Secrets Manager helps you manage credentials, API keys, and other secrets that your Lambda functions need. We recommend that you use the AWS Parameters and Secrets Lambda extension to retrieve secrets in your Lambda functions. The extension offers better performance and lower costs compared to retrieving secrets directly using the AWS SDK.The AWS Parameters and Secrets Lambda extension maintains a local cache of secrets, eliminating the need for your function to call Secrets Manager for every invocation. When your function requests a secret, the extension first checks its cache. If the secret is available and hasn't expired, it's returned immediately. Otherwise, the extension retrieves it from Secrets Manager, caches it, and then returns it to your function. This caching mechanism results in faster response times and reduced costs by minimizing API calls to Secrets Manager.The extension uses a simple HTTP interface compatible with any Lambda runtime. By default, it caches secrets for 300 seconds (5 minutes) and can hold up to 1,000 secrets. You can customize these settings with environment variables.
        When to use Secrets Manager with Lambda
        Common scenarios for using Secrets Manager with Lambda include:
        
             
             
             
             
        
                Storing database credentials that your function uses to connect to Amazon RDS or other databases
            
                Managing API keys for external services your function calls
            
                Storing encryption keys or other sensitive configuration data
            
                Rotating credentials automatically without needing to update your function code
            
     
        Use Secrets Manager in a Lambda function
        This section assumes that you already have a Secrets Manager secret. To create a secret, see Create an AWS Secrets Manager secret.
        Choose your preferred runtime and follow the steps to create a function that retrieves secrets from Secrets Manager. The example function retrieves a secret from Secrets Manager and can be used to access database credentials, API keys, or other sensitive configuration data in your applications.
                    Python
                            To create a Python function
                                    Create and navigate to a new project directory. Example:
                                    mkdir my_function
cd my_function
                                
                                    Create a file named lambda_function.py with the following code. For secret_name, use the name or Amazon Resource Name (ARN) of your secret.
                                    import json
import os
import requests

def lambda_handler(event, context):
    try:
        # Replace with the name or ARN of your secret
        secret_name = "arn:aws:secretsmanager:us-east-1:111122223333:secret:SECRET_NAME"
        
        secrets_extension_endpoint = f"http://localhost:2773/secretsmanager/get?secretId={secret_name}"
        headers = {"X-Aws-Parameters-Secrets-Token": os.environ.get('AWS_SESSION_TOKEN')}
        
        response = requests.get(secrets_extension_endpoint, headers=headers)
        print(f"Response status code: {response.status_code}")
        
        secret = json.loads(response.text)["SecretString"]
        print(f"Retrieved secret: {secret}")
        
        return {
            'statusCode': response.status_code,
            'body': json.dumps({
                'message': 'Successfully retrieved secret',
                'secretRetrieved': True
            })
        }
    
    except Exception as e:
        print(f"Error: {str(e)}")
        return {
            'statusCode': 500,
            'body': json.dumps({
                'message': 'Error retrieving secret',
                'error': str(e)
            })
        }
                                
                                    Create a file named requirements.txt with this content:
                                    requests
                                
                                    Install the dependencies:
                                    pip install -r requirements.txt -t .
                                
                                    Create a .zip file containing all files:
                                    zip -r function.zip .
                                
                        
                    Node.js
                            To create a Node.js function
                                    Create and navigate to a new project directory. Example:
                                    mkdir my_function
cd my_function
                                
                                    Create a file named index.mjs with the following code. For secret_name, use the name or Amazon Resource Name (ARN) of your secret.
                                    import http from 'http';

export const handler = async (event) => {
    try {
        // Replace with the name or ARN of your secret
        const secretName = "arn:aws:secretsmanager:us-east-1:111122223333:secret:SECRET_NAME";
        const options = {
            hostname: 'localhost',
            port: 2773,
            path: `/secretsmanager/get?secretId=${secretName}`,
            headers: {
                'X-Aws-Parameters-Secrets-Token': process.env.AWS_SESSION_TOKEN
            }
        };

        const response = await new Promise((resolve, reject) => {
            http.get(options, (res) => {
                let data = '';
                res.on('data', (chunk) => { data += chunk; });
                res.on('end', () => {
                    resolve({ 
                        statusCode: res.statusCode, 
                        body: data 
                    });
                });
            }).on('error', reject);
        });

        const secret = JSON.parse(response.body).SecretString;
        console.log('Retrieved secret:', secret);

        return {
            statusCode: response.statusCode,
            body: JSON.stringify({
                message: 'Successfully retrieved secret',
                secretRetrieved: true
            })
        };
    } catch (error) {
        console.error('Error:', error);
        return {
            statusCode: 500,
            body: JSON.stringify({
                message: 'Error retrieving secret',
                error: error.message
            })
        };
    }
};
                                
                                    Create a .zip file containing the index.mjs file:
                                    zip -r function.zip index.mjs
                                
                        
                    Java
                            To create a Java function
                                    Create a Maven project:
                                    mvn archetype:generate \
    -DgroupId=example \
    -DartifactId=lambda-secrets-demo \
    -DarchetypeArtifactId=maven-archetype-quickstart \
    -DarchetypeVersion=1.4 \
    -DinteractiveMode=false
                                
                                    Navigate to the project directory:
                                    cd lambda-secrets-demo
                                
                                    Open the pom.xml and replace the contents with the following:
                                    <project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>example</groupId>
    <artifactId>lambda-secrets-demo</artifactId>
    <version>1.0-SNAPSHOT</version>

    <properties>
        <maven.compiler.source>11</maven.compiler.source>
        <maven.compiler.target>11</maven.compiler.target>
    </properties>

    <dependencies>
        <dependency>
            <groupId>com.amazonaws</groupId>
            <artifactId>aws-lambda-java-core</artifactId>
            <version>1.2.1</version>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-shade-plugin</artifactId>
                <version>3.2.4</version>
                <executions>
                    <execution>
                        <phase>package</phase>
                        <goals>
                            <goal>shade</goal>
                        </goals>
                        <configuration>
                            <createDependencyReducedPom>false</createDependencyReducedPom>
                            <finalName>function</finalName>
                        </configuration>
                    </execution>
                </executions>
            </plugin>
        </plugins>
    </build>
</project>
                                
                                    Rename the /lambda-secrets-demo/src/main/java/example/App.java to Hello.java to match Lambda's default Java handler name (example.Hello::handleRequest):
                                    mv src/main/java/example/App.java src/main/java/example/Hello.java
                                
                                    Open the Hello.java file and replace its contents with the following. For secretName, use the name or Amazon Resource Name (ARN) of your secret.
                                    
                                    package example;

import com.amazonaws.services.lambda.runtime.Context;
import com.amazonaws.services.lambda.runtime.RequestHandler;
import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;

public class Hello implements RequestHandler<Object, String> {
    private final HttpClient client = HttpClient.newHttpClient();

    @Override
    public String handleRequest(Object input, Context context) {
        try {
            // Replace with the name or ARN of your secret
            String secretName = "arn:aws:secretsmanager:us-east-1:111122223333:secret:SECRET_NAME";
            String endpoint = "http://localhost:2773/secretsmanager/get?secretId=" + secretName;

            HttpRequest request = HttpRequest.newBuilder()
                .uri(URI.create(endpoint))
                .header("X-Aws-Parameters-Secrets-Token", System.getenv("AWS_SESSION_TOKEN"))
                .GET()
                .build();

            HttpResponse<String> response = client.send(request, 
                HttpResponse.BodyHandlers.ofString());

            String secret = response.body();
            secret = secret.substring(secret.indexOf("SecretString") + 15);
            secret = secret.substring(0, secret.indexOf("\""));

            System.out.println("Retrieved secret: " + secret);
            return String.format(
                "{\"statusCode\": %d, \"body\": \"%s\"}",
                response.statusCode(), "Successfully retrieved secret"
            );

        } catch (Exception e) {
            e.printStackTrace();
            return String.format(
                "{\"body\": \"Error retrieving secret: %s\"}", 
                e.getMessage()
            );
        }
    }
}
                                
                                    Remove the test directory. Maven creates this by default, but we don't need it for this example.
                                    rm -rf src/test
                                
                                    Build the project:
                                    mvn package
                                
                                    Download the JAR file (target/function.jar) for later use.
                                
                        
                Open the Functions page of the Lambda console.
                        Choose Create function.
                    
                        Select Author from scratch.
                    
                        For Function name, enter secret-retrieval-demo.
                    
                        Choose your preferred Runtime.
                    
                        Choose Create function.
                    To upload the deployment package
                        In the function's Code tab, choose Upload from and select .zip file (for Python and Node.js) or .jar file (for Java).
                    
                        Upload the deployment package you created earlier.
                    
                        Choose Save.
                    To add the AWS Parameters and Secrets Lambda extension as a layer
                        In the function's Code tab, scroll down to Layers.
                    
                        Choose Add a layer.
                    
                        Select AWS layers.
                    
                        Choose AWS-Parameters-and-Secrets-Lambda-Extension.
                    
                        Select the latest version.
                    
                        Choose Add.
                    To add Secrets Manager permissions to your execution role
                        Choose the Configuration tab, and then choose Permissions.
                    
                        Under Role name, choose the link to your execution role. This link opens the role in the IAM console.
                        
                             
                                 
                             
                             
                                
                    
                        Choose Add permissions, and then choose Create inline policy.
                        
                             
                                 
                             
                             
                                  
                    
                        Choose the JSON tab and add the following policy. For Resource, enter the ARN of your secret.
                        {
    "Version": "2012-10-17",
    "Statement": [
        {
            "Effect": "Allow",
            "Action": "secretsmanager:GetSecretValue",
            "Resource": "arn:aws:secretsmanager:us-east-1:111122223333:secret:SECRET_NAME"
        }
    ]
}
                    
                        Choose Next.
                    
                        Enter a name for the policy.
                    
                        Choose Create policy.
                    To test the function
                        Return to the Lambda console.
                    
                        Select the Test tab.
                    
                        Choose Test. You should see the following response:
                        
                             
                                 
                             
                             
                          
                    
     
            Environment variables
            The AWS Parameters and Secrets Lambda extension uses the following default settings. You can override these settings by creating the corresponding environment variables. To view the current settings for a function, set PARAMETERS_SECRETS_EXTENSION_LOG_LEVEL to DEBUG. The extension will log its configuration information to CloudWatch Logs at the start of each function invocation.
            
            
                        
                            Setting
                            Default value
                            Valid values
                            Environment variable
                            Details
                        
                    
                        
                            HTTP port
                            2773
                            1 - 65535
                            PARAMETERS_SECRETS_EXTENSION_HTTP_PORT
                            Port for the local HTTP server
                        
                        
                            Cache enabled
                            TRUE
                            TRUE | FALSE
                            PARAMETERS_SECRETS_EXTENSION_CACHE_ENABLED
                            Enable or disable the cache
                        
                        
                            Cache size
                            1000
                            0 - 1000
                            PARAMETERS_SECRETS_EXTENSION_CACHE_SIZE
                            Set to 0 to disable caching
                        
                        
                            Secrets Manager TTL
                            300 seconds
                            0 - 300 seconds
                            SECRETS_MANAGER_TTL
                            Time-to-live for cached secrets. Set to 0 to disable caching. This variable is ignored if the value for PARAMETERS_SECRETS_EXTENSION_CACHE_SIZE is 0.
                        
                        
                            Parameter Store TTL
                            300 seconds
                            0 - 300 seconds
                            SSM_PARAMETER_STORE_TTL
                            Time-to-live for cached parameters. Set to 0 to disable caching. This variable is ignored if the value for PARAMETERS_SECRETS_EXTENSION_CACHE_SIZE is 0.
                        
                        
                            Log level
                            INFO
                            DEBUG | INFO | WARN | ERROR | NONE
                            PARAMETERS_SECRETS_EXTENSION_LOG_LEVEL
                            The level of detail reported in logs for the extension
                        
                        
                            Max connections
                            3
                            1 or greater
                            PARAMETERS_SECRETS_EXTENSION_MAX_CONNECTIONS
                            Maximum number of HTTP connections for requests to Parameter Store or Secrets Manager
                        
                        
                            Secrets Manager timeout
                            0 (no timeout)
                            All whole numbers
                            SECRETS_MANAGER_TIMEOUT_MILLIS
                            Timeout for requests to Secrets Manager (in milliseconds)
                        
                        
                            Parameter Store timeout
                            0 (no timeout)
                            All whole numbers
                            SSM_PARAMETER_STORE_TIMEOUT_MILLIS
                            Timeout for requests to Parameter Store (in milliseconds)
                        
                    
         
        Working with secret rotation
        If you rotate secrets frequently, the default 300-second cache duration might cause your function to use outdated secrets. You have two options to ensure your function uses the latest secret value:
        
             
             
        
                Reduce the cache TTL by setting the SECRETS_MANAGER_TTL environment variable to a lower value (in seconds). For example, setting it to 60 ensures your function will never use a secret that's more than one minute old.
            
                Use the AWSCURRENT or AWSPREVIOUS staging labels in your secret request to ensure you get the specific version you want:
                secretsmanager/get?secretId=YOUR_SECRET_NAME&versionStage=AWSCURRENT
            
        Choose the approach that best balances your needs for performance and freshness. A lower TTL means more frequent calls to Secrets Manager but ensures you're working with the most recent secret values.
    Document ConventionsTutorial: Use an Amazon S3 trigger to create thumbnailsSQSDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideManaging permissions to your server-side
        encryption KMS keySecuring Lambda environment variablesFor securing your environment variables, you can use server-side encryption to protect your data at rest and
    client-side encryption to protect your data in transit.NoteTo increase database security, we recommend that you use AWS Secrets Manager instead of environment variables to store
      database credentials. For more information, see Use Secrets Manager secrets in Lambda functions.
    Security at rest
    Lambda always provides server-side encryption at rest with an AWS KMS key. By default, Lambda uses an
      AWS managed key. If this default behavior suits your workflow, you don't need to set up anything else. Lambda
      creates the AWS managed key in your account and manages the permissions for you. AWS doesn't charge you to
      use this key.
  If you prefer, you can provide an AWS KMS customer managed key instead. You might do this to have control over rotation of
    the KMS key or to meet the requirements of your organization for managing KMS keys. When you use a customer managed key,
    only users in your account with access to the KMS key can view or manage environment variables on the
    function.Customer managed keys incur standard AWS KMS charges. For more information, see AWS Key Management Service pricing.
    Security in transit
    For additional security, you can enable helpers for encryption in transit, which ensures that your
      environment variables are encrypted client-side for protection in transit.
  To configure encryption for your environment variables
      Use the AWS Key Management Service (AWS KMS) to create any customer managed keys for Lambda to use for server-side and client-side
        encryption. For more information, see Creating keys in the
        AWS Key Management Service Developer Guide.
    
      Using the Lambda console, navigate to the Edit environment variables page.
      Open the Functions page of the Lambda console.
          Choose a function.
        
          Choose Configuration, then choose Environment variables from
            the left navigation bar.
        
          In the Environment variables section, choose Edit.
        
          Expand Encryption configuration.
        
    
      (Optional) Enable console encryption helpers to use client-side encryption to protect your data in
        transit.
      
          Under Encryption in transit, choose Enable helpers for encryption in
            transit.
        
          For each environment variable that you want to enable console encryption helpers for, choose
            Encrypt next to the environment variable.
        
           Under AWS KMS key to encrypt in transit, choose a customer managed key that you created at the beginning of
            this procedure.
        
          Choose Execution role policy and copy the policy. This policy grants permission
            to your function's execution role to decrypt the environment variables.
          Save this policy to use in the last step of this procedure.
        
          Add code to your function that decrypts the environment variables. To see an example, choose
            Decrypt secrets snippet.
        
    
      (Optional) Specify your customer managed key for encryption at rest.
      
          Choose Use a customer master key.
        
          Choose a customer managed key that you created at the beginning of this procedure.
        
    
      Choose Save.
    
      Set up permissions.
      If you're using a customer managed key with server-side encryption, grant permissions to any users or roles that you
        want to be able to view or manage environment variables on the function. For more information, see Managing permissions to your server-side
        encryption KMS key.
      If you're enabling client-side encryption for security in transit, your function needs permission to call
        the kms:Decrypt API operation. Add the policy that you saved previously in this procedure to the
        function's execution role.
    
    Managing permissions to your server-side
        encryption KMS key
    
    No AWS KMS permissions are required for your user or the function's execution role to use the default
      encryption key. To use a customer managed key, you need permission to use the key. Lambda uses your permissions
      to create a grant on the key. This allows Lambda to use it for encryption.
    
       
       
       
    
        kms:ListAliases – To view keys in the Lambda console.
      
        kms:CreateGrant, kms:Encrypt – To configure a customer managed key on a
          function.
      
        kms:Decrypt – To view and manage environment variables that are encrypted with a
          customer managed key.
      
    You can get these permissions from your AWS account or from a key's resource-based permissions policy.
      ListAliases is provided by the managed policies for
        Lambda. Key policies grant the remaining permissions to users in the Key users
      group.
    
    Users without Decrypt permissions can still manage functions, but they can't view environment
      variables or manage them in the Lambda console. To prevent a user from viewing environment variables, add a
      statement to the user's permissions that denies access to the default key, a customer managed key, or all keys.
    Example IAM policy – Deny access by key ARN{
    "Version": "2012-10-17",
    "Statement": [
        {
            "Sid": "VisualEditor0",
            "Effect": "Deny",
            "Action": [
                "kms:Decrypt"
            ],
            "Resource": "arn:aws:kms:us-east-2:111122223333:key/3be10e2d-xmpl-4be4-bc9d-0405a71945cc"
        }
    ]
}
    For details on managing key permissions, see Key policies in AWS KMS in the
      AWS Key Management Service Developer Guide.
  Document ConventionsEnvironment variablesAttaching functions to a VPCDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS Serverless Application ModelDeveloper GuideGetting started with AWS SAMGet started with AWS SAM by reviewing and completing the topics in this section. AWS SAM prerequisites provides detailed instructions 
    on setting up an AWS account, creating IAM users, creating key access, and installing and configuring the AWS SAM CLI. After completing the prequisites, 
    you’ll be ready to Install the AWS SAM CLI, which you can do on Linux, Windows, and macOS operating systems. 
    After installation is complete, you can optionally walk through the AWS SAM Hello World tutorial. Following this tutorial will walk you through the process of creating 
    a basic serverless application with AWS SAM. After completing the tutorial, you’ll be ready to review the concepts detailed in How to use AWS Serverless Application Model (AWS SAM).TopicsAWS SAM prerequisitesInstall the AWS SAM CLITutorial: Deploy a Hello World application with AWS SAMDocument ConventionsServerless conceptsPrerequisitesDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS Serverless Application ModelDeveloper GuideSyntaxPropertiesReturn ValuesExamplesAWS::Serverless::FunctionCreates an AWS Lambda function, an AWS Identity and Access Management (IAM) execution role, and event source
		mappings that trigger the function.The AWS::Serverless::Function resource
		also supports the Metadata resource attribute, so you can instruct AWS SAM to build
		custom runtimes that your application requires. For more information about building custom
		runtimes, see Building Lambda functions with custom runtimes in AWS SAM.NoteWhen you deploy to AWS CloudFormation, AWS SAM transforms your AWS SAM resources into AWS CloudFormation resources.
			For more information, see Generated AWS CloudFormation resources for AWS SAM.
		Syntax
		To declare this entity in your AWS Serverless Application Model (AWS SAM) template, use the following
			syntax.
		
			YAML
			Type: AWS::Serverless::Function
Properties:
  Architectures: List
  AssumeRolePolicyDocument: JSON
  AutoPublishAlias: String
  AutoPublishAliasAllProperties: Boolean
  AutoPublishCodeSha256: String
  CodeSigningConfigArn: String
  CodeUri: String | FunctionCode
  DeadLetterQueue: Map | DeadLetterQueue
  DeploymentPreference: DeploymentPreference
  Description: String
  Environment: Environment
  EphemeralStorage: EphemeralStorage
  EventInvokeConfig: EventInvokeConfiguration
  Events: EventSource
  FileSystemConfigs: List
  FunctionName: String
  FunctionUrlConfig: FunctionUrlConfig
  Handler: String
  ImageConfig: ImageConfig
  ImageUri: String
  InlineCode: String
  KmsKeyArn: String
  Layers: List
  LoggingConfig: LoggingConfig
  MemorySize: Integer
  PackageType: String
  PermissionsBoundary: String
  Policies: String | List | Map
  PropagateTags: Boolean
  ProvisionedConcurrencyConfig: ProvisionedConcurrencyConfig
  RecursiveLoop: String
  ReservedConcurrentExecutions: Integer
  Role: String
  RolePath: String
  Runtime: String
  RuntimeManagementConfig: RuntimeManagementConfig
  SnapStart: SnapStart
  SourceKMSKeyArn: String
  Tags: Map
  Timeout: Integer
  Tracing: String
  VersionDescription: String
  VpcConfig: VpcConfig

		
	 
		Properties
		

			 

			 

			 

			 

			 

			 

			 

			 

			 

			 

			 

			 

			 

			 
			 

			 

			 

			 

			 

			 

			 

			 

			 
			
			
			 

			 

			 

			 

			
			 

			
			 
			
			
			 
			
			 

			 

			 

			 

			 

			 

			 
			
			 

			 

			 

			 

			 

			 

		
				
					Architectures
				
				
					The instruction set architecture for the function.
					For more information about this property, see Lambda instruction set architectures in
						the AWS Lambda Developer Guide.
					Valid values: One of x86_64 or
							arm64

					Type: List
					Required: No
					Default: x86_64

					AWS CloudFormation compatibility: This property is passed directly to the
								Architectures property of an AWS::Lambda::Function
						resource.

				
			 
				
					AssumeRolePolicyDocument
				
				
					Adds an AssumeRolePolicyDocument for the default created Role for this
						function. If this property isn't specified, AWS SAM adds a default assume role for this
						function.

					Type: JSON
					Required: No

					AWS CloudFormation compatibility: This property is similar to the
								AssumeRolePolicyDocument property of an AWS::IAM::Role
						resource. AWS SAM adds this property to the generated IAM role for this function. If a
						role's Amazon Resource Name (ARN) is provided for this function, this property does
						nothing.

				
			 
				
					AutoPublishAlias
				
				
					The name of the Lambda alias. For more information about Lambda aliases, see Lambda function aliases in the
							AWS Lambda Developer Guide. For examples that use this
						property, see Deploying serverless applications
      gradually with AWS SAM.
					AWS SAM generates AWS::Lambda::Version and AWS::Lambda::Alias resources when this property is set. For
						information about this scenario, see AutoPublishAlias property is specified. For
						general information about generated AWS CloudFormation resources, see Generated AWS CloudFormation resources for AWS SAM.

					Type: String
					Required: No

					AWS CloudFormation compatibility: This property is unique to AWS SAM and
						doesn't have an AWS CloudFormation equivalent.

				
			 
				
					AutoPublishAliasAllProperties
				
				
					Specifies when a new AWS::Lambda::Version is created. When true, a new
						Lambda version is created when any property in the Lambda function is modified. When
							false, a new Lambda version is created only when any of the following
						properties are modified:
					
						 
						 
					
							Environment, MemorySize, or
								SnapStart.
						
							Any change that results in an update to the Code property, such as
									CodeDict, ImageUri, or InlineCode.
						
					This property requires AutoPublishAlias to be defined.
					If AutoPublishCodeSha256 is also specified, its behavior takes precedence
						over AutoPublishAliasAllProperties: true.
					Type: Boolean
					Required: No
					Default value: false
					AWS CloudFormation compatibility: This property is unique to AWS SAM and
						doesn't have an AWS CloudFormation equivalent.
				

			 
				
					AutoPublishCodeSha256
				
				
					When used, this string works with the CodeUri value to determine if a new Lambda version needs to be published. 
						This property is often used to resolve the following deployment issue: A deployment package is stored in an Amazon S3 location 
						and is replaced by a new deployment package with updated Lambda function code but the CodeUri property remains unchanged
						(as opposed to the new deployment package being uploaded to a new Amazon S3 location and the CodeUri
						being changed to the new location).
					
					This problem is marked by an AWS SAM template having the following characteristics:
					
					
						 
						 
						 
					The DeploymentPreference object is configured for gradual deployments (as described in Deploying serverless applications
      gradually with AWS SAM)The AutoPublishAlias property is set and doesn't change between deploymentsThe CodeUri property is set and doesn't change between deployments.
					
					In this scenario, updating AutoPublishCodeSha256 results in a new Lambda version being created successfully. 
						However, new function code deployed to Amazon S3 will not be recognized. To recognize new function code, consider using versioning in your Amazon S3 bucket. 
						Specify the Version property for your Lambda function and configure your bucket to always use the latest deployment package.
					
					In this scenario, to trigger the gradual deployment successfully, you must provide a unique value for AutoPublishCodeSha256.

					Type: String
					Required: No

					AWS CloudFormation compatibility: This property is unique to AWS SAM and
						doesn't have an AWS CloudFormation equivalent.

				
			 
				
					CodeSigningConfigArn
				
				
					The ARN of the AWS::Lambda::CodeSigningConfig resource, used to enable code
						signing for this function. For more information about code signing, see Set up code signing for your AWS SAM application.

					Type: String
					Required: No

					AWS CloudFormation compatibility: This property is passed directly to the
								CodeSigningConfigArn property of an
							AWS::Lambda::Function resource.

				
			 
				
					CodeUri
				
				
					The code for the function. Accepted values include:
					
						 
						 
						 
					
							The function's Amazon S3 URI. For example, s3://bucket-123456789/sam-app/1234567890abcdefg.
						
							The local path to the function. For example, hello_world/.
						
							A FunctionCode object.
						
					NoteIf you provide a function's Amazon S3 URI or FunctionCode object, 
						you must reference a valid Lambda deployment package.If you provide a local file path, use the AWS SAM CLI to upload the local file at deployment. To learn more, see How AWS SAM uploads local files at deployment.If you use intrinsic functions in CodeUri property, AWS SAM will not be able to correctly parse the values. Consider using 
						AWS::LanguageExtensions transform instead.
					Type: [ String | FunctionCode ]
					Required: Conditional. When PackageType is set to Zip, one of CodeUri or InlineCode is 
						required.
					AWS CloudFormation compatibility: This property is similar to the 
						Code property of an AWS::Lambda::Function resource. The nested Amazon S3 properties are named differently.
				
			 
				
					DeadLetterQueue
				
				
					Configures an Amazon Simple Notification Service (Amazon SNS) topic or Amazon Simple Queue Service (Amazon SQS) queue where Lambda sends
						events that it can't process. For more information about dead-letter queue
						functionality, see Dead-letter queues in the AWS Lambda Developer Guide.
					NoteIf your Lambda function's event source is an Amazon SQS queue, configure a dead-letter
							queue for the source queue, not for the Lambda function. The dead-letter queue that you
							configure for a function is used for the function's asynchronous invocation queue, not
							for event source queues.

					Type: Map | DeadLetterQueue
					Required: No

					AWS CloudFormation compatibility: This property is similar to the
								DeadLetterConfig property of an AWS::Lambda::Function
						resource. In AWS CloudFormation the type is derived from the TargetArn, whereas in AWS SAM
						you must pass the type along with the TargetArn.

				
			 
				
					DeploymentPreference
				
				
					The settings to enable gradual Lambda deployments.
					If a DeploymentPreference object is specified, AWS SAM creates an AWS::CodeDeploy::Application called
							ServerlessDeploymentApplication (one per stack), an AWS::CodeDeploy::DeploymentGroup called
								<function-logical-id>DeploymentGroup,
						and an AWS::IAM::Role called
						CodeDeployServiceRole.

					Type: DeploymentPreference
					Required: No

					AWS CloudFormation compatibility: This property is unique to AWS SAM and
						doesn't have an AWS CloudFormation equivalent.
					See also: For more information about this property, see Deploying serverless applications
      gradually with AWS SAM.

				
			 
				
					Description
				
				
					A description of the function.

					Type: String
					Required: No

					AWS CloudFormation compatibility: This property is passed directly to the
								Description property of an AWS::Lambda::Function
						resource.

				
			 
				
					Environment
				
				
					The configuration for the runtime environment.

					Type: Environment
					Required: No

					AWS CloudFormation compatibility: This property is passed directly to the
								Environment property of an AWS::Lambda::Function
						resource.

				
			 
				
					EphemeralStorage
				
				
					An object that specifies the disk space, in MB, available to your Lambda function in
							/tmp.
					For more information about this property, see Lambda execution environment in the
							AWS Lambda Developer Guide.

					Type: EphemeralStorage
					Required: No

					AWS CloudFormation compatibility: This property is passed directly to the
								EphemeralStorage property of an AWS::Lambda::Function
						resource.

				
			 
				
					EventInvokeConfig
				
				
					The object that describes event invoke configuration on a Lambda function.

					Type: EventInvokeConfiguration
					Required: No

					AWS CloudFormation compatibility: This property is unique to AWS SAM and
						doesn't have an AWS CloudFormation equivalent.

				
			 
				
					Events
				
				
					Specifies the events that trigger this function. Events consist of a type and a set
						of properties that depend on the type.

					Type: EventSource
					Required: No

					AWS CloudFormation compatibility: This property is unique to AWS SAM and
						doesn't have an AWS CloudFormation equivalent.

				
			 
				
					FileSystemConfigs
				
				
					List of FileSystemConfig objects that specify the connection settings for an
						Amazon Elastic File System (Amazon EFS) file system.
					If your template contains an AWS::EFS::MountTarget resource, you must also specify a
							DependsOn resource attribute to ensure that the mount target is created
						or updated before the function.

					Type: List
					Required: No

					AWS CloudFormation compatibility: This property is passed directly to the
								FileSystemConfigs property of an AWS::Lambda::Function
						resource.

				
			 
				
					FunctionName
				
				
					A name for the function. If you don't specify a name, a unique name is generated for
						you.

					Type: String
					Required: No

					AWS CloudFormation compatibility: This property is passed directly to the
								FunctionName property of an AWS::Lambda::Function
						resource.

				
			 
				
					FunctionUrlConfig
				
				
					The object that describes a function URL. A function URL is an HTTPS endpoint that
						you can use to invoke your function.
					For more information, see Function
							URLs in the AWS Lambda Developer Guide.

					Type: FunctionUrlConfig
					Required: No

					AWS CloudFormation compatibility: This property is unique to AWS SAM and
						doesn't have an AWS CloudFormation equivalent.

				
			 
				
					Handler
				
				
					The function within your code that is called to begin execution. This property is
						only required if the PackageType property is set to
						Zip.

					Type: String
					Required: Conditional

					AWS CloudFormation compatibility: This property is passed directly to the
								Handler property of an AWS::Lambda::Function
						resource.

				
			 
				
					ImageConfig
				
				
					The object used to configure Lambda container image settings. For more information,
						see Using container images with
							Lambda in the AWS Lambda Developer Guide.

					Type: ImageConfig
					Required: No

					AWS CloudFormation compatibility: This property is passed directly to the
								ImageConfig property of an AWS::Lambda::Function
						resource.

				
			 
				
					ImageUri
				
				
					The URI of the Amazon Elastic Container Registry (Amazon ECR) repository for the Lambda function's container
						image. This property only applies if the PackageType property is set to
							Image, otherwise it is ignored. For more information, see Using container images with Lambda in the
							AWS Lambda Developer Guide.
					NoteIf the PackageType property is set to Image, then either
								ImageUri is required, or you must build your application with necessary
								Metadata entries in the AWS SAM template file. For more information, see
								Default build with AWS SAM.
					Building your application with necessary Metadata entries takes
						precedence over ImageUri, so if you specify both then ImageUri
						is ignored.

					Type: String
					Required: No

					AWS CloudFormation compatibility: This property is passed directly to the
								ImageUri property of the AWS::Lambda::Function
						Code data type.

				
			 
				
					InlineCode
				
				
					The Lambda function code that is written directly in the template. This property only
						applies if the PackageType property is set to Zip, otherwise
						it is ignored.
					NoteIf the PackageType property is set to Zip (default),
							then one of CodeUri or InlineCode is required.

					Type: String
					Required: Conditional

					AWS CloudFormation compatibility: This property is passed directly to the
								ZipFile property of the AWS::Lambda::Function
						Code data type.

				
			 
				
					KmsKeyArn
				
				
					The ARN of an AWS Key Management Service (AWS KMS) key that Lambda uses to encrypt and decrypt your
						function's environment variables.

					Type: String
					Required: No

					AWS CloudFormation compatibility: This property is passed directly to the
								KmsKeyArn property of an AWS::Lambda::Function
						resource.

				
			 
				
					Layers
				
				
					The list of LayerVersion ARNs that this function should use. The order
						specified here is the order in which they will be imported when running the Lambda
						function. The version is either a full ARN including the version or a reference to a LayerVersion resource. For example, a reference to a LayerVersion will be !Ref MyLayer 
						while a full ARN including the version will be 
						arn:aws:lambda:region:account-id:layer:layer-name:version.

					Type: List
					Required: No

					AWS CloudFormation compatibility: This property is passed directly to the
								Layers property of an AWS::Lambda::Function
						resource.

				
			 
				
					LoggingConfig
				
				
					The function's Amazon CloudWatch Logs configuration settings.
					Type: LoggingConfig
					Required: No
					AWS CloudFormation compatibility: This property is passed directly to the 
						LoggingConfig property of an AWS::Lambda::Function resource.
				
			 
				
					MemorySize
				
				
					The size of the memory in MB allocated per invocation of the function.

					Type: Integer
					Required: No

					AWS CloudFormation compatibility: This property is passed directly to the
								MemorySize property of an AWS::Lambda::Function
						resource.

				
			 
				
					PackageType
				
				
					The deployment package type of the Lambda function. For more information, see Lambda deployment packages in
						the AWS Lambda Developer Guide.
					Notes:
					1. If this property is set to Zip (default), then either
							CodeUri or InlineCode applies, and ImageUri is
						ignored.
					2. If this property is set to Image, then only ImageUri
						applies, and both CodeUri and InlineCode are ignored. The
						Amazon ECR repository required to store the function's container image can be auto created by
						the AWS SAM CLI. For more information, see sam deploy.
					Valid values: Zip or
							Image

					Type: String
					Required: No
					Default: Zip

					AWS CloudFormation compatibility: This property is passed directly to the
								PackageType property of an AWS::Lambda::Function
						resource.

				
			 
				
					PermissionsBoundary
				
				
					The ARN of a permissions boundary to use for this function's execution role. This
						property works only if the role is generated for you.

					Type: String
					Required: No

					AWS CloudFormation compatibility: This property is passed directly to the
								PermissionsBoundary property of an AWS::IAM::Role
						resource.

				
			 
				
					Policies
				
				
					Permission policies for this function. Policies will be appended to the function's
						default AWS Identity and Access Management (IAM) execution role.
					This property accepts a single value or list of values. Allowed values
						include:
					
						 
						 
						 
						 
					
							AWS SAM policy templates.
						
							The ARN of an AWS managed policy or  customer managed policy.
						
							The name of an AWS managed policy from the following  list.
						
							An 
									inline IAM policy formatted in YAML as a map.
						
					NoteIf you set the Role property, this property is ignored.
					Type: String | List | Map
					Required: No

					AWS CloudFormation compatibility: This property is similar to the
								Policies property of an AWS::IAM::Role resource.
				
			 
				PropagateTags
				
					Indicate whether or not to pass tags from the Tags property to your
							AWS::Serverless::Function generated
						resources. Specify True to propagate tags in your generated
						resources.
					Type: Boolean
					Required: No
					Default: False
					AWS CloudFormation compatibility: This property is unique to AWS SAM and
						doesn't have an AWS CloudFormation equivalent.
				
			 
				
					ProvisionedConcurrencyConfig
				
				
					The provisioned concurrency configuration of a function's alias.
					NoteProvisionedConcurrencyConfig can be specified only if the
							AutoPublishAlias is set. Otherwise, an error results.
					
					Type: ProvisionedConcurrencyConfig
					Required: No
					
					AWS CloudFormation compatibility: This property is passed directly to the
						ProvisionedConcurrencyConfig property of an
						AWS::Lambda::Alias resource.
					
				
			 
				
					RecursiveLoop
				
				
					The status of your function's recursive loop detection configuration.
					
					When this value is set to Allow and Lambda detects your function being invoked as part of a recursive loop, it doesn't take any action.
					
					When this value is set to Terminate and Lambda detects your function being invoked as part of a recursive loop, it stops your function being invoked and notifies you. 
					
					Type: String
					Required: No
					
					AWS CloudFormation compatibility: This property is passed directly to the 
						RecursiveLoop 
						property of the AWS::Lambda::Function resource.
					
				
			 
				
					ReservedConcurrentExecutions
				
				
					The maximum number of concurrent executions that you want to reserve for the
						function.
					For more information about this property, see Lambda Function Scaling in the AWS Lambda Developer Guide.

					Type: Integer
					Required: No

					AWS CloudFormation compatibility: This property is passed directly to the
								ReservedConcurrentExecutions property of an
							AWS::Lambda::Function resource.

				
			 
				
					Role
				
				
					The ARN of an IAM role to use as this function's execution role.

					Type: String
					Required: No

					AWS CloudFormation compatibility: This property is similar to the
								Role property of an AWS::Lambda::Function resource.
						This is required in AWS CloudFormation but not in AWS SAM. If a role isn't specified, one is created
						for you with a logical ID of
								<function-logical-id>Role.

				
			 
				
					RolePath
				
				
					The path to the function's IAM execution role.
					Use this property when the role is generated for you. Do not use when the role is
						specified with the Role property.
					Type: String
					Required: Conditional
					AWS CloudFormation compatibility: This property is passed directly to the
								Path property of an AWS::IAM::Role resource.

				
			 
				
					Runtime
				
				
					The identifier of the function's runtime. This property is only required if the PackageType
						property is set to Zip.
					NoteIf you specify the provided identifier for this property, you can use
							the Metadata resource attribute to instruct AWS SAM to build the custom
							runtime that this function requires. For more information about building custom
							runtimes, see Building Lambda functions with custom runtimes in AWS SAM.

					Type: String
					Required: Conditional

					AWS CloudFormation compatibility: This property is passed directly to the
								Runtime property of an AWS::Lambda::Function
						resource.

				
			 
				
					RuntimeManagementConfig
				
				
					Configure runtime management options for your Lambda functions such as runtime
						environment updates, rollback behavior, and selecting a specific runtime version. To
						learn more, see Lambda runtime updates in the AWS Lambda Developer Guide.
					Type: RuntimeManagementConfig
					Required: No
					AWS CloudFormation compatibility: This property is passed directly to the
								 RuntimeManagementConfig property of an
							AWS::Lambda::Function resource.
				
			 
				
					SnapStart
				
				
					Create a snapshot of any new Lambda function version. A snapshot is a cached state of
						your initialized function, including all of its dependencies. The function is
						initialized just once and the cached state is reused for all future invocations,
						improving application performance by reducing the number of times your function must be
						initialized. To learn more, see Improving startup performance with Lambda
							SnapStart in the AWS Lambda Developer Guide.

					Type: SnapStart
					Required: No

					AWS CloudFormation compatibility: This property is passed directly to the
								SnapStart property of an AWS::Lambda::Function
						resource.

				
			 
				
					SourceKmsKeyArn
				
				
					Represents a KMS key ARN that is used to encrypt the customer's ZIP function code.
					
					Type: String
					Required: No
					
					AWS CloudFormation compatibility: This property is passed directly to the
						SourceKmsKeyArn property of an AWS::Lambda::Function Code data type.
					
				
			 
				
					Tags
				
				
					A map (string to string) that specifies the tags added to this function. For details
						about valid keys and values for tags, see Tag Key and
							Value Requirements in the AWS Lambda Developer Guide.
					When the stack is created, AWS SAM automatically adds a
							lambda:createdBy:SAM tag to this Lambda function, and to the default roles
						that are generated for this function.

					Type: Map
					Required: No

					AWS CloudFormation compatibility: This property is similar to the
								Tags property of an AWS::Lambda::Function resource. The
							Tags property in AWS SAM consists of key-value pairs (whereas in AWS CloudFormation this
						property consists of a list of Tag objects). Also, AWS SAM automatically adds
						a lambda:createdBy:SAM tag to this Lambda function, and to the default roles
						that are generated for this function.

				
			 
				
					Timeout
				
				
					The maximum time in seconds that the function can run before it is stopped.

					Type: Integer
					Required: No
					Default: 3

					AWS CloudFormation compatibility: This property is passed directly to the
								Timeout property of an AWS::Lambda::Function
						resource.

				
			 
				
					Tracing
				
				
					The string that specifies the function's X-Ray tracing mode.
					
						 
						 
						 
					
							Active – Activates X-Ray tracing for the function.
						
							Disabled – Deactivates X-Ray for the function.
						
							PassThrough – Activates X-Ray tracing for the function. Sampling decision is delegated
								to the downstream services.
						
					If specified as Active or PassThrough and the Role property is not set, 
						AWS SAM adds the arn:aws:iam::aws:policy/AWSXrayWriteOnlyAccess policy to the Lambda execution role that 
						it creates for you.
					For more information about X-Ray, see Using AWS Lambda with
							AWS X-Ray in the AWS Lambda Developer Guide.
					Valid values: [Active|Disabled|PassThrough]
					Type: String
					Required: No

					AWS CloudFormation compatibility: This property is similar to the TracingConfig property of an AWS::Lambda::Function resource.
				
			 
				
					VersionDescription
				
				
					Specifies the Description field that is added on the new Lambda version
						resource.

					Type: String
					Required: No

					AWS CloudFormation compatibility: This property is passed directly to the
								Description property of an AWS::Lambda::Version
						resource.

				
			 
				
					VpcConfig
				
				
					The configuration that enables this function to access private resources within your
						virtual private cloud (VPC).

					Type: VpcConfig
					Required: No

					AWS CloudFormation compatibility: This property is passed directly to the
								VpcConfig property of an AWS::Lambda::Function
						resource.

				
			
	 
		Return Values

		
		 
			Ref
			When the logical ID of this resource is provided to the Ref intrinsic
				function, it returns the resource name of the underlying Lambda function.
			For more information about using the Ref function, see Ref in the AWS CloudFormation User Guide. 
		 


		
		 
			Fn::GetAtt
			Fn::GetAtt returns a value for a specified attribute of this type. The
				following are the available attributes and sample return values. 
			For more information about using Fn::GetAtt, see Fn::GetAtt in the AWS CloudFormation User Guide. 
			

				 

			
					Arn
					
						The ARN of the underlying Lambda function.
					
				
		 

	 
		Examples
		
		 
			Simple function
			The following is a basic example of an AWS::Serverless::Function resource of package type Zip
				(default) and function code in an Amazon S3 bucket.

			
				YAML
				Type: AWS::Serverless::Function
Properties:
  Handler: index.handler
  Runtime: python3.9
  CodeUri: s3://bucket-name/key-name

			
		 

		 
			Function
					properties example
			The following is an example of an AWS::Serverless::Function of package type Zip (default) that
				uses InlineCode, Layers, Tracing,
					Policies, Amazon EFS, and an Api event source.

			
				YAML
				Type: AWS::Serverless::Function
DependsOn: MyMountTarget        # This is needed if an AWS::EFS::MountTarget resource is declared for EFS
Properties:
  Handler: index.handler
  Runtime: python3.9
  InlineCode: |
    def handler(event, context):
      print("Hello, world!")
  ReservedConcurrentExecutions: 30
  Layers:
    - Ref: MyLayer
  Tracing: Active
  Timeout: 120
  FileSystemConfigs:
    - Arn: !Ref MyEfsFileSystem
      LocalMountPath: /mnt/EFS
  Policies:
    - AWSLambdaExecute
    - Version: '2012-10-17' 
      Statement:
        - Effect: Allow
          Action:
            - s3:GetObject
            - s3:GetObjectACL
          Resource: 'arn:aws:s3:::sam-s3-demo-bucket/*'
  Events:
    ApiEvent:
      Type: Api
      Properties:
        Path: /path
        Method: get

			
		 

		 
			ImageConfig
					example
			The following is an example of an ImageConfig for a Lambda function of
				package type Image.

			
				YAML
				HelloWorldFunction:
  Type: AWS::Serverless::Function
  Properties:
    PackageType: Image
    ImageUri: account-id.dkr.ecr.region.amazonaws.com/ecr-repo-name:image-name
    ImageConfig:
      Command:
        - "app.lambda_handler"
      EntryPoint:
        - "entrypoint1"
      WorkingDirectory: "workDir"

			
		 

		 
			
					RuntimeManagementConfig examples

			A Lambda function configured to update its runtime environment according to current
				behavior:
			TestFunction
  Type: AWS::Serverless::Function
  Properties:
    ...
    Runtime: python3.9
    RuntimeManagementConfig:
      UpdateRuntimeOn: Auto

			A Lambda function configured to update its runtime environment when the function is
				updated:
			TestFunction
  Type: AWS::Serverless::Function
  Properties:
    ...
    Runtime: python3.9
    RuntimeManagementConfig:
      UpdateRuntimeOn: FunctionUpdate

			A Lambda function configured to update its runtime environment manually:
			TestFunction
  Type: AWS::Serverless::Function
  Properties:
    ...
    Runtime: python3.9
    RuntimeManagementConfig:
      RuntimeVersionArn: arn:aws:lambda:us-east-1::runtime:4c459dd0104ee29ec65dcad056c0b3ddbe20d6db76b265ade7eda9a066859b1e
      UpdateRuntimeOn: Manual

		 

		 
			SnapStart
					examples

			Example of a Lambda function with SnapStart turned on for future versions:
			TestFunc
  Type: AWS::Serverless::Function
  Properties:
    ...
    SnapStart:
      ApplyOn: PublishedVersions
		 

	Document ConventionsSourceReferenceDeadLetterQueueDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS CloudFormationUser GuideSyntaxPropertiesExamplesAWS::Lambda::Function EnvironmentA function's environment variable settings. You can use environment variables to adjust your function's
      behavior without updating code. An environment variable is a pair of strings that are stored in a function's
      version-specific configuration.SyntaxTo declare this entity in your AWS CloudFormation template, use the following syntax:JSON{
  "Variables" : {Key: Value, ...}
}
YAML  Variables: 
    Key: Value
PropertiesVariables
               Environment variable key-value pairs. For more information, see Using Lambda environment variables.
               If the value of the environment variable is a time or a duration, enclose the value in quotes.
            Required: NoType: Object of StringPattern: [a-zA-Z][a-zA-Z0-9_]+Update requires: No interruptionExamples
         Environment VariablesAdd environment variables to a function. Each variable is a key-value pair. 
        This example specifies values for a databaseName and a databaseUser.YAML      Environment:
        Variables:
          databaseName: lambdadb
          databaseUser: admin
      Document ConventionsDeadLetterConfigEphemeralStorageDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS Serverless Application ModelDeveloper GuideUsageEnvironment variablesOptionsExamplesam deployThis page provides reference information for the AWS Serverless Application Model Command Line Interface (AWS SAM CLI) 
		sam deploy command.
		 
		 
	
			For an introduction to the AWS SAM CLI, see What is the AWS SAM CLI?
		
			For documentation on using the AWS SAM CLI sam deploy command, see Introduction to deploying with AWS SAM.
		The sam deploy command deploys an application to the AWS Cloud using AWS CloudFormation.
		Usage
		$ <environment variables> sam deploy <options>
	 
		Environment variables
		
			
			 
		
				SAM_CLI_POLL_DELAY
				
					Set the SAM_CLI_POLL_DELAY environment variable with a value of seconds in your shell
						to configure how often the AWS SAM CLI checks the AWS CloudFormation stack state, which is useful when seeing throttling from AWS CloudFormation.
						This env variable is used for polling describe_stack API calls, which are made while running sam deploy.
					
					The following is an example of this variable:
					$ SAM_CLI_POLL_DELAY=5 sam deploy
				
			
	 
		Options
		
			
			
			 
			
			
			 
			
			
			 
			
			
			 
			
			
			 
			
			
			 
			
			
			 
			
			
			 
			
			
			 
			
			
			 
			
			
			 
			
			
			 
			
			
			 
			
			
			 
			
			
			 
			
			
			 
			
			
			 
			
			
			 
			
			
			 
			
			
			 
			
			
			 
			
			
			 
			
			
			 
			
			
			 
			
			
			 
			
			
			 
			
			
			 
			
			
			 
			
			
			 
			
			
			 
			
			
			 
			
			
			 
			
		
				--capabilities LIST
				
					A list of capabilities that you must specify to allow AWS CloudFormation to create certain
						stacks. Some stack templates might include resources that affect permissions in your
						AWS account, for example, by creating new AWS Identity and Access Management (IAM) users. For those stacks,
						you must explicitly acknowledge their capabilities by specifying this option. The only
						valid values are CAPABILITY_IAM and CAPABILITY_NAMED_IAM. If
						you have IAM resources, then you can specify either capability. If you have IAM
						resources with custom names, then you must specify CAPABILITY_NAMED_IAM. If
						you don't specify this option, then the operation returns an
						InsufficientCapabilities error.
					When you deploy an application that contains nested applications, you must use CAPABILITY_AUTO_EXPAND
						to acknowledge the application contains nested applications. For more information, 
						see Deploying
                nested applications.
				
			 
				--config-env TEXT
				
					The environment name specifying the default parameter values in the configuration
						file to use. The default value is default. For more information about
						configuration files, see AWS SAM CLI configuration file.
				
			 
				--config-file PATH
				
					The path and file name of the configuration file containing default parameter
						values to use. The default value is samconfig.toml in the root of
						the project directory. For more information about configuration files, see AWS SAM CLI configuration file.
				
			 
				--confirm-changeset | --no-confirm-changeset
				
					Prompt to confirm whether the AWS SAM CLI deploys the computed changeset.
				
			 
				--debug
				
					Turn on debug logging to print the debug message that the AWS SAM CLI generates and
						to display timestamps.
				
			 
				--disable-rollback | --no-disable-rollback
				
					Specify whether to roll back your AWS CloudFormation stack if an error occurs during a
						deployment. By default, if there's an error during a deployment, your AWS CloudFormation stack rolls
						back to the last stable state. If you specify --disable-rollback and an
						error occurs during a deployment, then resources that were created or updated before the
						error occurred aren't rolled back.
				
			 
				--fail-on-empty-changeset | --no-fail-on-empty-changeset
				
					Specify whether to return a non-zero exit code if there are no changes to make to
						the stack. The default behavior is to return a non-zero exit code.
				
			 
				--force-upload
				
					Specify this option to upload artifacts even if they match existing artifacts in
						the Amazon S3 bucket. Matching artifacts are overwritten.
				
			 
				--guided, -g
				
					Specify this option to have the AWS SAM CLI use prompts to guide you through the
						deployment.
				
			 
				--help
				
					Show this message and exit.
				
			 
				--image-repositories TEXT
				
					A mapping of functions to their Amazon ECR repository URI. Reference functions by their logical ID. The following 
						is an example:
					$ sam deploy --image-repositories Function1=123456789012.dkr.ecr.us-east-1.amazonaws.com/my-repo
					You can specify this option multiple times in a single command.
				
			 
				--image-repository TEXT
				
					The name of the Amazon ECR repository where this command uploads your function's image.
						This option is required for functions declared with the Image package
						type.
				
			 
				--kms-key-id TEXT
				
					The ID of an AWS Key Management Service (AWS KMS) key used to encrypt artifacts that are at rest in
						the Amazon S3 bucket. If you don't specify this option, then AWS SAM uses Amazon S3-managed
						encryption keys.
				
			 
				--metadata
				
					A map of metadata to attach to all artifacts that are referenced in your
						template.
				
			 
				--no-execute-changeset
				
					Indicates whether to apply the changeset. Specify this option if you want to view
						your stack changes before applying the changeset. This command creates an AWS CloudFormation
						changeset and then exits without applying the changeset. To apply the changeset, run the
						same command without this option.
				
			 
				--no-progressbar
				
					Do not display a progress bar when uploading artifacts to Amazon S3.
				
			 
				--notification-arns LIST
				
					A list of Amazon Simple Notification Service (Amazon SNS) topic ARNs that AWS CloudFormation associates with the
						stack.
				
			 
				--on-failure [ROLLBACK | DELETE | DO_NOTHING]
				
					Specify the action to take when a stack fails to create.
					The following options are available:
					
						 
						 
						 
					
							ROLLBACK – Rolls back the stack to a previous known
								good state.
						
							DELETE – Rolls back the stack to a previous known
								good state, if one exists. Otherwise, deletes the stack.
						
							DO_NOTHING – Neither rolls back nor deletes the
								stack. The effect is the same as that of --disable-rollback.
						
					The default behavior is ROLLBACK.
					NoteYou can specify either the
							--disable-rollback option or the --on-failure option, but
							not both.
				
			 
				--parameter-overrides LIST
				
					A string that contains AWS CloudFormation parameter overrides encoded as key-value pairs. Use
						the same format as the AWS Command Line Interface (AWS CLI). The AWS SAM CLI format is explicit key and value keywords, each override is separated by a space. Here are two examples:

					$ sam deploy --parameter-overrides ParameterKey=value1,ParameterValue=value2
					$ sam deploy --parameter-overrides ParameterKey=value1,ParameterValue=value2 ParameterKey=hello,ParameterValue=world ParameterKey=apple,ParameterValue=banana
					
				
			 
				--profile TEXT
				
					The specific profile from your credential file that gets AWS credentials.
				
			 
				--region TEXT
				
					The AWS Region to deploy to. For example, us-east-1.
				
			 
				--resolve-image-repos
				
					Automatically create Amazon ECR repositories to use for packaging and deploying for
						non-guided deployments. This option applies only to functions and layers with
						PackageType: Image specified. If you specify the --guided
						option, then the AWS SAM CLI ignores --resolve-image-repos.
					NoteIf AWS SAM automatically creates any Amazon ECR repositories for
							functions or layers with this option, and you later delete those functions or layers
							from your AWS SAM template, then the corresponding Amazon ECR repositories are automatically
							deleted.
				
			 
				--resolve-s3
				
					Automatically create an Amazon S3 bucket to use for packaging and deploying for
						non-guided deployments. If you specify the --guided option, then the AWS SAM
						CLI ignores --resolve-s3. If you specify both the --s3-bucket
						and --resolve-s3 options, then an error occurs.
				
			 
				--role-arn TEXT
				
					The Amazon Resource Name (ARN) of an IAM role that AWS CloudFormation assumes when applying
						the changeset.
				
			 
				--s3-bucket TEXT
				
					The name of the Amazon S3 bucket where this command uploads your AWS CloudFormation template. If your
						template is larger than 51,200 bytes, then either the --s3-bucket option or
						the --resolve-s3 option is required. If you specify both the
						--s3-bucket and --resolve-s3 options, then an error
						occurs.
				
			 
				--s3-prefix TEXT
				
					The prefix added to the names of the artifacts that are uploaded to the Amazon S3
						bucket. The prefix name is a path name (folder name) for the Amazon S3 bucket.
				
			 
				--save-params
				
					Save the parameters that you provide at the command line to the AWS SAM configuration file.
				
			 
				--signing-profiles LIST
				
					The list of signing profiles to sign your deployment packages with. This option
						takes a list of key-value pairs, where the key is the name of the function or layer to
						sign, and the value is the signing profile, with an optional profile owner delimited
						with :. For example, FunctionNameToSign=SigningProfileName1
							LayerNameToSign=SigningProfileName2:SigningProfileOwner.
				
			 
				--stack-name TEXT
				
					(Required) The name of the AWS CloudFormation stack that you're deploying to. If you specify an
						existing stack, then the command updates the stack. If you specify a new stack, then the
						command creates it.
				
			 
				--tags LIST
				
					A list of tags to associate with the stack that is created or updated. AWS CloudFormation also
						propagates these tags to resources in the stack that support it.
				
			 
				--template-file, --template, -t PATH
				
					The path and file name where your AWS SAM template is located.
					NoteIf you specify this option, then AWS SAM deploys only the
							template and the local resources that it points to.
				
			 
				--use-json
				
					Output JSON for the AWS CloudFormation template. The default output is YAML.
				
			
	 
		Example
		
		For a detailed example and in-depth walkthrough on using the sam deploy subcommand, refer to Introduction to deploying with AWS SAM.
	Document Conventionssam deletesam initDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaAPI ReferenceRequest SyntaxURI Request ParametersRequest BodyResponse SyntaxResponse ElementsErrorsSee AlsoUpdateFunctionConfigurationModify the version-specific settings of a Lambda function.When you update a function, Lambda provisions an instance of the function and its supporting
      resources. If your function connects to a VPC, this process can take a minute. During this time, you can't modify
      the function, but you can still invoke it. The LastUpdateStatus, LastUpdateStatusReason,
      and LastUpdateStatusReasonCode fields in the response from GetFunctionConfiguration
      indicate when the update is complete and the function is processing events with the new configuration. For more
      information, see Lambda
        function states.These settings can vary between versions of a function and are locked when you publish a version. You can't
      modify the configuration of a published version, only the unpublished version.To configure function concurrency, use PutFunctionConcurrency. To grant invoke permissions
      to an AWS account or AWS service, use AddPermission.
      Request Syntax
      PUT /2015-03-31/functions/FunctionName/configuration HTTP/1.1
Content-type: application/json

{
   "DeadLetterConfig": { 
      "TargetArn": "string"
   },
   "Description": "string",
   "Environment": { 
      "Variables": { 
         "string" : "string" 
      }
   },
   "EphemeralStorage": { 
      "Size": number
   },
   "FileSystemConfigs": [ 
      { 
         "Arn": "string",
         "LocalMountPath": "string"
      }
   ],
   "Handler": "string",
   "ImageConfig": { 
      "Command": [ "string" ],
      "EntryPoint": [ "string" ],
      "WorkingDirectory": "string"
   },
   "KMSKeyArn": "string",
   "Layers": [ "string" ],
   "LoggingConfig": { 
      "ApplicationLogLevel": "string",
      "LogFormat": "string",
      "LogGroup": "string",
      "SystemLogLevel": "string"
   },
   "MemorySize": number,
   "RevisionId": "string",
   "Role": "string",
   "Runtime": "string",
   "SnapStart": { 
      "ApplyOn": "string"
   },
   "Timeout": number,
   "TracingConfig": { 
      "Mode": "string"
   },
   "VpcConfig": { 
      "Ipv6AllowedForDualStack": boolean,
      "SecurityGroupIds": [ "string" ],
      "SubnetIds": [ "string" ]
   }
}
    
      URI Request Parameters
      The request uses the following URI parameters.
      
          
      
            
               
                  FunctionName
               
            
            
               The name or ARN of the Lambda function.
               
                  Name formats
                   
                   
                   
               
                     
                        Function name – my-function.
                  
                     
                        Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function.
                  
                     
                        Partial ARN – 123456789012:function:my-function.
                  
               The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64
      characters in length.
               Length Constraints: Minimum length of 1. Maximum length of 140.
               Pattern: (arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\d{1}:)?(\d{12}:)?(function:)?([a-zA-Z0-9-_]+)(:(\$LATEST|[a-zA-Z0-9-_]+))?
               
               Required: Yes
            
         
    
      Request Body
      The request accepts the following data in JSON format.
      
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
      
            
               
                  DeadLetterConfig
               
            
            
               A dead-letter queue configuration that specifies the queue or topic where Lambda sends asynchronous events
      when they fail processing. For more information, see Dead-letter queues.
               Type: DeadLetterConfig object
               Required: No
            
          
            
               
                  Description
               
            
            
               A description of the function.
               Type: String
               Length Constraints: Minimum length of 0. Maximum length of 256.
               Required: No
            
          
            
               
                  Environment
               
            
            
               Environment variables that are accessible from function code during execution.
               Type: Environment object
               Required: No
            
          
            
               
                  EphemeralStorage
               
            
            
               The size of the function's /tmp directory in MB. The default value is 512, but can be any whole
      number between 512 and 10,240 MB. For more information, see Configuring ephemeral storage (console).
               Type: EphemeralStorage object
               Required: No
            
          
            
               
                  FileSystemConfigs
               
            
            
               Connection settings for an Amazon EFS file system.
               Type: Array of FileSystemConfig objects
               Array Members: Maximum number of 1 item.
               Required: No
            
          
            
               
                  Handler
               
            
            
               The name of the method within your code that Lambda calls to run your function. 
Handler is required if the deployment package is a .zip file archive. The format includes the
      file name. It can also include namespaces and other qualifiers, depending on the runtime. For more information,
      see Lambda programming model.
               Type: String
               Length Constraints: Maximum length of 128.
               Pattern: [^ ]+
               
               Required: No
            
          
            
               
                  ImageConfig
               
            
            
               
                  Container image configuration
        values that override the values in the container image Docker file.
               Type: ImageConfig object
               Required: No
            
          
            
               
                  KMSKeyArn
               
            
            
               The ARN of the AWS Key Management Service (AWS KMS) customer managed key that's used to encrypt the following resources:
               
                   
                   
                   
                   
               
                     The function's environment variables.
                  
                     The function's Lambda SnapStart snapshots.
                  
                     When used with SourceKMSKeyArn, the unzipped version of the .zip deployment package that's used for function invocations. For more information, see 
Specifying a customer managed key for Lambda.
                  
                     The optimized version of the container image that's used for function invocations. Note that this is not the same key that's used to protect your container image in the Amazon Elastic Container Registry (Amazon ECR). For more information, see Function lifecycle.
                  
               If you don't provide a customer managed key, Lambda uses an AWS owned key or an AWS managed key.
               Type: String
               Pattern: (arn:(aws[a-zA-Z-]*)?:[a-z0-9-.]+:.*)|()
               
               Required: No
            
          
            
               
                  Layers
               
            
            
               A list of function layers
      to add to the function's execution environment. Specify each layer by its ARN, including the version.
               Type: Array of strings
               Length Constraints: Minimum length of 1. Maximum length of 140.
               Pattern: arn:[a-zA-Z0-9-]+:lambda:[a-zA-Z0-9-]+:\d{12}:layer:[a-zA-Z0-9-_]+:[0-9]+
               
               Required: No
            
          
            
               
                  LoggingConfig
               
            
            
               The function's Amazon CloudWatch Logs configuration settings.
               Type: LoggingConfig object
               Required: No
            
          
            
               
                  MemorySize
               
            
            
               The amount of memory available to the function at runtime.
      Increasing the function memory also increases its CPU allocation. The default value is 128 MB. The value can be any multiple of 1 MB.
               Type: Integer
               Valid Range: Minimum value of 128. Maximum value of 10240.
               Required: No
            
          
            
               
                  RevisionId
               
            
            
               Update the function only if the revision ID matches the ID that's specified. Use this option to avoid modifying a
      function that has changed since you last read it.
               Type: String
               Required: No
            
          
            
               
                  Role
               
            
            
               The Amazon Resource Name (ARN) of the function's execution role.
               Type: String
               Pattern: arn:(aws[a-zA-Z-]*)?:iam::\d{12}:role/?[a-zA-Z_0-9+=,.@\-_/]+
               
               Required: No
            
          
            
               
                  Runtime
               
            
            
               The identifier of the function's 
          runtime. Runtime is required if the deployment package is a .zip file archive. Specifying a runtime results in
          an error if you're deploying a function using a container image.
               The following list includes deprecated runtimes. Lambda blocks creating new functions and updating existing
          functions shortly after each runtime is deprecated. For more information, see
          Runtime use after deprecation.
               For a list of all currently supported runtimes, see
          Supported runtimes.
               Type: String
               Valid Values: nodejs | nodejs4.3 | nodejs6.10 | nodejs8.10 | nodejs10.x | nodejs12.x | nodejs14.x | nodejs16.x | java8 | java8.al2 | java11 | python2.7 | python3.6 | python3.7 | python3.8 | python3.9 | dotnetcore1.0 | dotnetcore2.0 | dotnetcore2.1 | dotnetcore3.1 | dotnet6 | dotnet8 | nodejs4.3-edge | go1.x | ruby2.5 | ruby2.7 | provided | provided.al2 | nodejs18.x | python3.10 | java17 | ruby3.2 | ruby3.3 | ruby3.4 | python3.11 | nodejs20.x | provided.al2023 | python3.12 | java21 | python3.13 | nodejs22.x
               
               Required: No
            
          
            
               
                  SnapStart
               
            
            
               The function's SnapStart setting.
               Type: SnapStart object
               Required: No
            
          
            
               
                  Timeout
               
            
            
               The amount of time (in seconds) that Lambda allows a function to run before stopping it. The default is 3 seconds. The
      maximum allowed value is 900 seconds. For more information, see Lambda execution environment.
               Type: Integer
               Valid Range: Minimum value of 1.
               Required: No
            
          
            
               
                  TracingConfig
               
            
            
               Set Mode to Active to sample and trace a subset of incoming requests with
X-Ray.
               Type: TracingConfig object
               Required: No
            
          
            
               
                  VpcConfig
               
            
            
               For network connectivity to AWS resources in a VPC, specify a list of security groups and subnets in the VPC.
      When you connect a function to a VPC, it can access resources and the internet only through that VPC. For more
      information, see Configuring a Lambda function to access resources in a VPC.
               Type: VpcConfig object
               Required: No
            
         
    
      Response Syntax
      HTTP/1.1 200
Content-type: application/json

{
   "Architectures": [ "string" ],
   "CodeSha256": "string",
   "CodeSize": number,
   "DeadLetterConfig": { 
      "TargetArn": "string"
   },
   "Description": "string",
   "Environment": { 
      "Error": { 
         "ErrorCode": "string",
         "Message": "string"
      },
      "Variables": { 
         "string" : "string" 
      }
   },
   "EphemeralStorage": { 
      "Size": number
   },
   "FileSystemConfigs": [ 
      { 
         "Arn": "string",
         "LocalMountPath": "string"
      }
   ],
   "FunctionArn": "string",
   "FunctionName": "string",
   "Handler": "string",
   "ImageConfigResponse": { 
      "Error": { 
         "ErrorCode": "string",
         "Message": "string"
      },
      "ImageConfig": { 
         "Command": [ "string" ],
         "EntryPoint": [ "string" ],
         "WorkingDirectory": "string"
      }
   },
   "KMSKeyArn": "string",
   "LastModified": "string",
   "LastUpdateStatus": "string",
   "LastUpdateStatusReason": "string",
   "LastUpdateStatusReasonCode": "string",
   "Layers": [ 
      { 
         "Arn": "string",
         "CodeSize": number,
         "SigningJobArn": "string",
         "SigningProfileVersionArn": "string"
      }
   ],
   "LoggingConfig": { 
      "ApplicationLogLevel": "string",
      "LogFormat": "string",
      "LogGroup": "string",
      "SystemLogLevel": "string"
   },
   "MasterArn": "string",
   "MemorySize": number,
   "PackageType": "string",
   "RevisionId": "string",
   "Role": "string",
   "Runtime": "string",
   "RuntimeVersionConfig": { 
      "Error": { 
         "ErrorCode": "string",
         "Message": "string"
      },
      "RuntimeVersionArn": "string"
   },
   "SigningJobArn": "string",
   "SigningProfileVersionArn": "string",
   "SnapStart": { 
      "ApplyOn": "string",
      "OptimizationStatus": "string"
   },
   "State": "string",
   "StateReason": "string",
   "StateReasonCode": "string",
   "Timeout": number,
   "TracingConfig": { 
      "Mode": "string"
   },
   "Version": "string",
   "VpcConfig": { 
      "Ipv6AllowedForDualStack": boolean,
      "SecurityGroupIds": [ "string" ],
      "SubnetIds": [ "string" ],
      "VpcId": "string"
   }
}
    
      Response Elements
      If the action is successful, the service sends back an HTTP 200 response.
      The following data is returned in JSON format by the service.
      
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
      
            
               
                  Architectures
               
            
            
               The instruction set architecture that the function supports. Architecture is a string array with one of the 
      valid values. The default architecture value is x86_64.
               Type: Array of strings
               Array Members: Fixed number of 1 item.
               Valid Values: x86_64 | arm64
               
            
          
            
               
                  CodeSha256
               
            
            
               The SHA256 hash of the function's deployment package.
               Type: String
            
          
            
               
                  CodeSize
               
            
            
               The size of the function's deployment package, in bytes.
               Type: Long
            
          
            
               
                  DeadLetterConfig
               
            
            
               The function's dead letter queue.
               Type: DeadLetterConfig object
            
          
            
               
                  Description
               
            
            
               The function's description.
               Type: String
               Length Constraints: Minimum length of 0. Maximum length of 256.
            
          
            
               
                  Environment
               
            
            
               The function's environment variables. Omitted from AWS CloudTrail logs.
               Type: EnvironmentResponse object
            
          
            
               
                  EphemeralStorage
               
            
            
               The size of the function's /tmp directory in MB. The default value is 512, but can be any whole
  number between 512 and 10,240 MB. For more information, see Configuring ephemeral storage (console).
               Type: EphemeralStorage object
            
          
            
               
                  FileSystemConfigs
               
            
            
               Connection settings for an Amazon EFS file system.
               Type: Array of FileSystemConfig objects
               Array Members: Maximum number of 1 item.
            
          
            
               
                  FunctionArn
               
            
            
               The function's Amazon Resource Name (ARN).
               Type: String
               Pattern: arn:(aws[a-zA-Z-]*)?:lambda:[a-z]{2}(-gov)?-[a-z]+-\d{1}:\d{12}:function:[a-zA-Z0-9-_\.]+(:(\$LATEST|[a-zA-Z0-9-_]+))?
               
            
          
            
               
                  FunctionName
               
            
            
               The name of the function.
               Type: String
               Length Constraints: Minimum length of 1. Maximum length of 170.
               Pattern: (arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\d{1}:)?(\d{12}:)?(function:)?([a-zA-Z0-9-_\.]+)(:(\$LATEST|[a-zA-Z0-9-_]+))?
               
            
          
            
               
                  Handler
               
            
            
               The function that Lambda calls to begin running your function.
               Type: String
               Length Constraints: Maximum length of 128.
               Pattern: [^ ]+
               
            
          
            
               
                  ImageConfigResponse
               
            
            
               The function's image configuration values.
               Type: ImageConfigResponse object
            
          
            
               
                  KMSKeyArn
               
            
            
               The ARN of the AWS Key Management Service (AWS KMS) customer managed key that's used to encrypt the following resources:
               
                   
                   
                   
                   
               
                     The function's environment variables.
                  
                     The function's Lambda SnapStart snapshots.
                  
                     When used with SourceKMSKeyArn, the unzipped version of the .zip deployment package that's used for function invocations. For more information, see 
          Specifying a customer managed key for Lambda.
                  
                     The optimized version of the container image that's used for function invocations. Note that this is not the same key that's used to protect your container image in the Amazon Elastic Container Registry (Amazon ECR). For more information, see Function lifecycle.
                  
               If you don't provide a customer managed key, Lambda uses an AWS owned key or an AWS managed key.
               Type: String
               Pattern: (arn:(aws[a-zA-Z-]*)?:[a-z0-9-.]+:.*)|()
               
            
          
            
               
                  LastModified
               
            
            
               The date and time that the function was last updated, in ISO-8601 format (YYYY-MM-DDThh:mm:ss.sTZD).
               Type: String
            
          
            
               
                  LastUpdateStatus
               
            
            
               The status of the last update that was performed on the function. This is first set to Successful
      after function creation completes.
               Type: String
               Valid Values: Successful | Failed | InProgress
               
            
          
            
               
                  LastUpdateStatusReason
               
            
            
               The reason for the last update that was performed on the function.
               Type: String
            
          
            
               
                  LastUpdateStatusReasonCode
               
            
            
               The reason code for the last update that was performed on the function.
               Type: String
               Valid Values: EniLimitExceeded | InsufficientRolePermissions | InvalidConfiguration | InternalError | SubnetOutOfIPAddresses | InvalidSubnet | InvalidSecurityGroup | ImageDeleted | ImageAccessDenied | InvalidImage | KMSKeyAccessDenied | KMSKeyNotFound | InvalidStateKMSKey | DisabledKMSKey | EFSIOError | EFSMountConnectivityError | EFSMountFailure | EFSMountTimeout | InvalidRuntime | InvalidZipFileException | FunctionError
               
            
          
            
               
                  Layers
               
            
            
               The function's layers.
               Type: Array of Layer objects
            
          
            
               
                  LoggingConfig
               
            
            
               The function's Amazon CloudWatch Logs configuration settings.
               Type: LoggingConfig object
            
          
            
               
                  MasterArn
               
            
            
               For Lambda@Edge functions, the ARN of the main function.
               Type: String
               Pattern: arn:(aws[a-zA-Z-]*)?:lambda:[a-z]{2}(-gov)?-[a-z]+-\d{1}:\d{12}:function:[a-zA-Z0-9-_]+(:(\$LATEST|[a-zA-Z0-9-_]+))?
               
            
          
            
               
                  MemorySize
               
            
            
               The amount of memory available to the function at runtime.
               Type: Integer
               Valid Range: Minimum value of 128. Maximum value of 10240.
            
          
            
               
                  PackageType
               
            
            
               The type of deployment package. Set to Image for container image and set Zip for .zip file archive.
               Type: String
               Valid Values: Zip | Image
               
            
          
            
               
                  RevisionId
               
            
            
               The latest updated revision of the function or alias.
               Type: String
            
          
            
               
                  Role
               
            
            
               The function's execution role.
               Type: String
               Pattern: arn:(aws[a-zA-Z-]*)?:iam::\d{12}:role/?[a-zA-Z_0-9+=,.@\-_/]+
               
            
          
            
               
                  Runtime
               
            
            
               The identifier of the function's 
          runtime. Runtime is required if the deployment package is a .zip file archive. Specifying a runtime results in
          an error if you're deploying a function using a container image.
               The following list includes deprecated runtimes. Lambda blocks creating new functions and updating existing
          functions shortly after each runtime is deprecated. For more information, see
          Runtime use after deprecation.
               For a list of all currently supported runtimes, see
          Supported runtimes.
               Type: String
               Valid Values: nodejs | nodejs4.3 | nodejs6.10 | nodejs8.10 | nodejs10.x | nodejs12.x | nodejs14.x | nodejs16.x | java8 | java8.al2 | java11 | python2.7 | python3.6 | python3.7 | python3.8 | python3.9 | dotnetcore1.0 | dotnetcore2.0 | dotnetcore2.1 | dotnetcore3.1 | dotnet6 | dotnet8 | nodejs4.3-edge | go1.x | ruby2.5 | ruby2.7 | provided | provided.al2 | nodejs18.x | python3.10 | java17 | ruby3.2 | ruby3.3 | ruby3.4 | python3.11 | nodejs20.x | provided.al2023 | python3.12 | java21 | python3.13 | nodejs22.x
               
            
          
            
               
                  RuntimeVersionConfig
               
            
            
               The ARN of the runtime and any errors that occured.
               Type: RuntimeVersionConfig object
            
          
            
               
                  SigningJobArn
               
            
            
               The ARN of the signing job.
               Type: String
               Pattern: arn:(aws[a-zA-Z0-9-]*):([a-zA-Z0-9\-])+:([a-z]{2}(-gov)?-[a-z]+-\d{1})?:(\d{12})?:(.*)
               
            
          
            
               
                  SigningProfileVersionArn
               
            
            
               The ARN of the signing profile version.
               Type: String
               Pattern: arn:(aws[a-zA-Z0-9-]*):([a-zA-Z0-9\-])+:([a-z]{2}(-gov)?-[a-z]+-\d{1})?:(\d{12})?:(.*)
               
            
          
            
               
                  SnapStart
               
            
            
               Set ApplyOn to PublishedVersions to create a snapshot of the initialized execution
      environment when you publish a function version. For more information, see Improving startup performance with Lambda SnapStart.
               Type: SnapStartResponse object
            
          
            
               
                  State
               
            
            
               The current state of the function. When the state is Inactive, you can reactivate the function by
      invoking it.
               Type: String
               Valid Values: Pending | Active | Inactive | Failed
               
            
          
            
               
                  StateReason
               
            
            
               The reason for the function's current state.
               Type: String
            
          
            
               
                  StateReasonCode
               
            
            
               The reason code for the function's current state. When the code is Creating, you can't invoke or
      modify the function.
               Type: String
               Valid Values: Idle | Creating | Restoring | EniLimitExceeded | InsufficientRolePermissions | InvalidConfiguration | InternalError | SubnetOutOfIPAddresses | InvalidSubnet | InvalidSecurityGroup | ImageDeleted | ImageAccessDenied | InvalidImage | KMSKeyAccessDenied | KMSKeyNotFound | InvalidStateKMSKey | DisabledKMSKey | EFSIOError | EFSMountConnectivityError | EFSMountFailure | EFSMountTimeout | InvalidRuntime | InvalidZipFileException | FunctionError
               
            
          
            
               
                  Timeout
               
            
            
               The amount of time in seconds that Lambda allows a function to run before stopping it.
               Type: Integer
               Valid Range: Minimum value of 1.
            
          
            
               
                  TracingConfig
               
            
            
               The function's AWS X-Ray tracing configuration.
               Type: TracingConfigResponse object
            
          
            
               
                  Version
               
            
            
               The version of the Lambda function.
               Type: String
               Length Constraints: Minimum length of 1. Maximum length of 1024.
               Pattern: (\$LATEST|[0-9]+)
               
            
          
            
               
                  VpcConfig
               
            
            
               The function's networking configuration.
               Type: VpcConfigResponse object
            
         
    
      Errors
      For information about the errors that are common to all actions, see Common Errors.
      
          
          
          
          
          
          
          
          
          
      
            
               
                  CodeSigningConfigNotFoundException
               
            
            
               The specified code signing configuration does not exist.
               HTTP Status Code: 404
            
          
            
               
                  CodeVerificationFailedException
               
            
            
               The code signature failed one or more of the validation checks for signature mismatch or expiry, and the code
      signing policy is set to ENFORCE. Lambda blocks the deployment.
               HTTP Status Code: 400
            
          
            
               
                  InvalidCodeSignatureException
               
            
            
               The code signature failed the integrity check. If the integrity check fails, then Lambda blocks
      deployment, even if the code signing policy is set to WARN.
               HTTP Status Code: 400
            
          
            
               
                  InvalidParameterValueException
               
            
            
               One of the parameters in the request is not valid.
               HTTP Status Code: 400
            
          
            
               
                  PreconditionFailedException
               
            
            
               The RevisionId provided does not match the latest RevisionId for the Lambda function or alias.
               
                   
                   
               
                     
                        For AddPermission and RemovePermission API operations: Call GetPolicy to retrieve the latest RevisionId for your resource.
                  
                     
                        For all other API operations: Call GetFunction or GetAlias to retrieve the latest RevisionId for your resource.
                  
               HTTP Status Code: 412
            
          
            
               
                  ResourceConflictException
               
            
            
               The resource already exists, or another operation is in progress.
               HTTP Status Code: 409
            
          
            
               
                  ResourceNotFoundException
               
            
            
               The resource specified in the request does not exist.
               HTTP Status Code: 404
            
          
            
               
                  ServiceException
               
            
            
               The AWS Lambda service encountered an internal error.
               HTTP Status Code: 500
            
          
            
               
                  TooManyRequestsException
               
            
            
               The request throughput limit was exceeded. For more information, see Lambda quotas.
               HTTP Status Code: 429
            
         
    
      See Also
      For more information about using this API in one of the language-specific AWS SDKs, see the following:
      
          
          
          
          
          
          
          
          
          
      
            
               AWS Command Line Interface
            
         
            
               AWS SDK for .NET
            
         
            
               AWS SDK for C++
            
         
            
               AWS SDK for Go v2
            
         
            
               AWS SDK for Java V2
            
         
            
               AWS SDK for JavaScript V3
            
         
            
               AWS SDK for PHP V3
            
         
            
               AWS SDK for Python
            
         
            
               AWS SDK for Ruby V3
            
         
   Document ConventionsUpdateFunctionCodeUpdateFunctionEventInvokeConfigDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaAPI ReferenceRequest SyntaxURI Request ParametersRequest BodyResponse SyntaxResponse ElementsErrorsSee AlsoGetFunctionConfigurationReturns the version-specific settings of a Lambda function or version. The output includes only options that
      can vary between versions of a function. To modify these settings, use UpdateFunctionConfiguration.To get all of a function's details, including function-level settings, use GetFunction.
      Request Syntax
      GET /2015-03-31/functions/FunctionName/configuration?Qualifier=Qualifier HTTP/1.1

    
      URI Request Parameters
      The request uses the following URI parameters.
      
          
          
      
            
               
                  FunctionName
               
            
            
               The name or ARN of the Lambda function, version, or alias.
               
                  Name formats
                   
                   
                   
               
                     
                        Function name – my-function (name-only), my-function:v1 (with alias).
                  
                     
                        Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function.
                  
                     
                        Partial ARN – 123456789012:function:my-function.
                  
               You can append a version number or alias to any of the formats. The length constraint applies only to the full ARN.
      If you specify only the function name, it is limited to 64 characters in length.
               Length Constraints: Minimum length of 1. Maximum length of 170.
               Pattern: (arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\d{1}:)?(\d{12}:)?(function:)?([a-zA-Z0-9-_\.]+)(:(\$LATEST|[a-zA-Z0-9-_]+))?
               
               Required: Yes
            
          
            
               
                  Qualifier
               
            
            
               Specify a version or alias to get details about a published version of the function.
               Length Constraints: Minimum length of 1. Maximum length of 128.
               Pattern: (|[a-zA-Z0-9$_-]+)
               
            
         
    
      Request Body
      The request does not have a request body.
    
      Response Syntax
      HTTP/1.1 200
Content-type: application/json

{
   "Architectures": [ "string" ],
   "CodeSha256": "string",
   "CodeSize": number,
   "DeadLetterConfig": { 
      "TargetArn": "string"
   },
   "Description": "string",
   "Environment": { 
      "Error": { 
         "ErrorCode": "string",
         "Message": "string"
      },
      "Variables": { 
         "string" : "string" 
      }
   },
   "EphemeralStorage": { 
      "Size": number
   },
   "FileSystemConfigs": [ 
      { 
         "Arn": "string",
         "LocalMountPath": "string"
      }
   ],
   "FunctionArn": "string",
   "FunctionName": "string",
   "Handler": "string",
   "ImageConfigResponse": { 
      "Error": { 
         "ErrorCode": "string",
         "Message": "string"
      },
      "ImageConfig": { 
         "Command": [ "string" ],
         "EntryPoint": [ "string" ],
         "WorkingDirectory": "string"
      }
   },
   "KMSKeyArn": "string",
   "LastModified": "string",
   "LastUpdateStatus": "string",
   "LastUpdateStatusReason": "string",
   "LastUpdateStatusReasonCode": "string",
   "Layers": [ 
      { 
         "Arn": "string",
         "CodeSize": number,
         "SigningJobArn": "string",
         "SigningProfileVersionArn": "string"
      }
   ],
   "LoggingConfig": { 
      "ApplicationLogLevel": "string",
      "LogFormat": "string",
      "LogGroup": "string",
      "SystemLogLevel": "string"
   },
   "MasterArn": "string",
   "MemorySize": number,
   "PackageType": "string",
   "RevisionId": "string",
   "Role": "string",
   "Runtime": "string",
   "RuntimeVersionConfig": { 
      "Error": { 
         "ErrorCode": "string",
         "Message": "string"
      },
      "RuntimeVersionArn": "string"
   },
   "SigningJobArn": "string",
   "SigningProfileVersionArn": "string",
   "SnapStart": { 
      "ApplyOn": "string",
      "OptimizationStatus": "string"
   },
   "State": "string",
   "StateReason": "string",
   "StateReasonCode": "string",
   "Timeout": number,
   "TracingConfig": { 
      "Mode": "string"
   },
   "Version": "string",
   "VpcConfig": { 
      "Ipv6AllowedForDualStack": boolean,
      "SecurityGroupIds": [ "string" ],
      "SubnetIds": [ "string" ],
      "VpcId": "string"
   }
}
    
      Response Elements
      If the action is successful, the service sends back an HTTP 200 response.
      The following data is returned in JSON format by the service.
      
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
      
            
               
                  Architectures
               
            
            
               The instruction set architecture that the function supports. Architecture is a string array with one of the 
      valid values. The default architecture value is x86_64.
               Type: Array of strings
               Array Members: Fixed number of 1 item.
               Valid Values: x86_64 | arm64
               
            
          
            
               
                  CodeSha256
               
            
            
               The SHA256 hash of the function's deployment package.
               Type: String
            
          
            
               
                  CodeSize
               
            
            
               The size of the function's deployment package, in bytes.
               Type: Long
            
          
            
               
                  DeadLetterConfig
               
            
            
               The function's dead letter queue.
               Type: DeadLetterConfig object
            
          
            
               
                  Description
               
            
            
               The function's description.
               Type: String
               Length Constraints: Minimum length of 0. Maximum length of 256.
            
          
            
               
                  Environment
               
            
            
               The function's environment variables. Omitted from AWS CloudTrail logs.
               Type: EnvironmentResponse object
            
          
            
               
                  EphemeralStorage
               
            
            
               The size of the function's /tmp directory in MB. The default value is 512, but can be any whole
  number between 512 and 10,240 MB. For more information, see Configuring ephemeral storage (console).
               Type: EphemeralStorage object
            
          
            
               
                  FileSystemConfigs
               
            
            
               Connection settings for an Amazon EFS file system.
               Type: Array of FileSystemConfig objects
               Array Members: Maximum number of 1 item.
            
          
            
               
                  FunctionArn
               
            
            
               The function's Amazon Resource Name (ARN).
               Type: String
               Pattern: arn:(aws[a-zA-Z-]*)?:lambda:[a-z]{2}(-gov)?-[a-z]+-\d{1}:\d{12}:function:[a-zA-Z0-9-_\.]+(:(\$LATEST|[a-zA-Z0-9-_]+))?
               
            
          
            
               
                  FunctionName
               
            
            
               The name of the function.
               Type: String
               Length Constraints: Minimum length of 1. Maximum length of 170.
               Pattern: (arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\d{1}:)?(\d{12}:)?(function:)?([a-zA-Z0-9-_\.]+)(:(\$LATEST|[a-zA-Z0-9-_]+))?
               
            
          
            
               
                  Handler
               
            
            
               The function that Lambda calls to begin running your function.
               Type: String
               Length Constraints: Maximum length of 128.
               Pattern: [^ ]+
               
            
          
            
               
                  ImageConfigResponse
               
            
            
               The function's image configuration values.
               Type: ImageConfigResponse object
            
          
            
               
                  KMSKeyArn
               
            
            
               The ARN of the AWS Key Management Service (AWS KMS) customer managed key that's used to encrypt the following resources:
               
                   
                   
                   
                   
               
                     The function's environment variables.
                  
                     The function's Lambda SnapStart snapshots.
                  
                     When used with SourceKMSKeyArn, the unzipped version of the .zip deployment package that's used for function invocations. For more information, see 
          Specifying a customer managed key for Lambda.
                  
                     The optimized version of the container image that's used for function invocations. Note that this is not the same key that's used to protect your container image in the Amazon Elastic Container Registry (Amazon ECR). For more information, see Function lifecycle.
                  
               If you don't provide a customer managed key, Lambda uses an AWS owned key or an AWS managed key.
               Type: String
               Pattern: (arn:(aws[a-zA-Z-]*)?:[a-z0-9-.]+:.*)|()
               
            
          
            
               
                  LastModified
               
            
            
               The date and time that the function was last updated, in ISO-8601 format (YYYY-MM-DDThh:mm:ss.sTZD).
               Type: String
            
          
            
               
                  LastUpdateStatus
               
            
            
               The status of the last update that was performed on the function. This is first set to Successful
      after function creation completes.
               Type: String
               Valid Values: Successful | Failed | InProgress
               
            
          
            
               
                  LastUpdateStatusReason
               
            
            
               The reason for the last update that was performed on the function.
               Type: String
            
          
            
               
                  LastUpdateStatusReasonCode
               
            
            
               The reason code for the last update that was performed on the function.
               Type: String
               Valid Values: EniLimitExceeded | InsufficientRolePermissions | InvalidConfiguration | InternalError | SubnetOutOfIPAddresses | InvalidSubnet | InvalidSecurityGroup | ImageDeleted | ImageAccessDenied | InvalidImage | KMSKeyAccessDenied | KMSKeyNotFound | InvalidStateKMSKey | DisabledKMSKey | EFSIOError | EFSMountConnectivityError | EFSMountFailure | EFSMountTimeout | InvalidRuntime | InvalidZipFileException | FunctionError
               
            
          
            
               
                  Layers
               
            
            
               The function's layers.
               Type: Array of Layer objects
            
          
            
               
                  LoggingConfig
               
            
            
               The function's Amazon CloudWatch Logs configuration settings.
               Type: LoggingConfig object
            
          
            
               
                  MasterArn
               
            
            
               For Lambda@Edge functions, the ARN of the main function.
               Type: String
               Pattern: arn:(aws[a-zA-Z-]*)?:lambda:[a-z]{2}(-gov)?-[a-z]+-\d{1}:\d{12}:function:[a-zA-Z0-9-_]+(:(\$LATEST|[a-zA-Z0-9-_]+))?
               
            
          
            
               
                  MemorySize
               
            
            
               The amount of memory available to the function at runtime.
               Type: Integer
               Valid Range: Minimum value of 128. Maximum value of 10240.
            
          
            
               
                  PackageType
               
            
            
               The type of deployment package. Set to Image for container image and set Zip for .zip file archive.
               Type: String
               Valid Values: Zip | Image
               
            
          
            
               
                  RevisionId
               
            
            
               The latest updated revision of the function or alias.
               Type: String
            
          
            
               
                  Role
               
            
            
               The function's execution role.
               Type: String
               Pattern: arn:(aws[a-zA-Z-]*)?:iam::\d{12}:role/?[a-zA-Z_0-9+=,.@\-_/]+
               
            
          
            
               
                  Runtime
               
            
            
               The identifier of the function's 
          runtime. Runtime is required if the deployment package is a .zip file archive. Specifying a runtime results in
          an error if you're deploying a function using a container image.
               The following list includes deprecated runtimes. Lambda blocks creating new functions and updating existing
          functions shortly after each runtime is deprecated. For more information, see
          Runtime use after deprecation.
               For a list of all currently supported runtimes, see
          Supported runtimes.
               Type: String
               Valid Values: nodejs | nodejs4.3 | nodejs6.10 | nodejs8.10 | nodejs10.x | nodejs12.x | nodejs14.x | nodejs16.x | java8 | java8.al2 | java11 | python2.7 | python3.6 | python3.7 | python3.8 | python3.9 | dotnetcore1.0 | dotnetcore2.0 | dotnetcore2.1 | dotnetcore3.1 | dotnet6 | dotnet8 | nodejs4.3-edge | go1.x | ruby2.5 | ruby2.7 | provided | provided.al2 | nodejs18.x | python3.10 | java17 | ruby3.2 | ruby3.3 | ruby3.4 | python3.11 | nodejs20.x | provided.al2023 | python3.12 | java21 | python3.13 | nodejs22.x
               
            
          
            
               
                  RuntimeVersionConfig
               
            
            
               The ARN of the runtime and any errors that occured.
               Type: RuntimeVersionConfig object
            
          
            
               
                  SigningJobArn
               
            
            
               The ARN of the signing job.
               Type: String
               Pattern: arn:(aws[a-zA-Z0-9-]*):([a-zA-Z0-9\-])+:([a-z]{2}(-gov)?-[a-z]+-\d{1})?:(\d{12})?:(.*)
               
            
          
            
               
                  SigningProfileVersionArn
               
            
            
               The ARN of the signing profile version.
               Type: String
               Pattern: arn:(aws[a-zA-Z0-9-]*):([a-zA-Z0-9\-])+:([a-z]{2}(-gov)?-[a-z]+-\d{1})?:(\d{12})?:(.*)
               
            
          
            
               
                  SnapStart
               
            
            
               Set ApplyOn to PublishedVersions to create a snapshot of the initialized execution
      environment when you publish a function version. For more information, see Improving startup performance with Lambda SnapStart.
               Type: SnapStartResponse object
            
          
            
               
                  State
               
            
            
               The current state of the function. When the state is Inactive, you can reactivate the function by
      invoking it.
               Type: String
               Valid Values: Pending | Active | Inactive | Failed
               
            
          
            
               
                  StateReason
               
            
            
               The reason for the function's current state.
               Type: String
            
          
            
               
                  StateReasonCode
               
            
            
               The reason code for the function's current state. When the code is Creating, you can't invoke or
      modify the function.
               Type: String
               Valid Values: Idle | Creating | Restoring | EniLimitExceeded | InsufficientRolePermissions | InvalidConfiguration | InternalError | SubnetOutOfIPAddresses | InvalidSubnet | InvalidSecurityGroup | ImageDeleted | ImageAccessDenied | InvalidImage | KMSKeyAccessDenied | KMSKeyNotFound | InvalidStateKMSKey | DisabledKMSKey | EFSIOError | EFSMountConnectivityError | EFSMountFailure | EFSMountTimeout | InvalidRuntime | InvalidZipFileException | FunctionError
               
            
          
            
               
                  Timeout
               
            
            
               The amount of time in seconds that Lambda allows a function to run before stopping it.
               Type: Integer
               Valid Range: Minimum value of 1.
            
          
            
               
                  TracingConfig
               
            
            
               The function's AWS X-Ray tracing configuration.
               Type: TracingConfigResponse object
            
          
            
               
                  Version
               
            
            
               The version of the Lambda function.
               Type: String
               Length Constraints: Minimum length of 1. Maximum length of 1024.
               Pattern: (\$LATEST|[0-9]+)
               
            
          
            
               
                  VpcConfig
               
            
            
               The function's networking configuration.
               Type: VpcConfigResponse object
            
         
    
      Errors
      For information about the errors that are common to all actions, see Common Errors.
      
          
          
          
          
      
            
               
                  InvalidParameterValueException
               
            
            
               One of the parameters in the request is not valid.
               HTTP Status Code: 400
            
          
            
               
                  ResourceNotFoundException
               
            
            
               The resource specified in the request does not exist.
               HTTP Status Code: 404
            
          
            
               
                  ServiceException
               
            
            
               The AWS Lambda service encountered an internal error.
               HTTP Status Code: 500
            
          
            
               
                  TooManyRequestsException
               
            
            
               The request throughput limit was exceeded. For more information, see Lambda quotas.
               HTTP Status Code: 429
            
         
    
      See Also
      For more information about using this API in one of the language-specific AWS SDKs, see the following:
      
          
          
          
          
          
          
          
          
          
      
            
               AWS Command Line Interface
            
         
            
               AWS SDK for .NET
            
         
            
               AWS SDK for C++
            
         
            
               AWS SDK for Go v2
            
         
            
               AWS SDK for Java V2
            
         
            
               AWS SDK for JavaScript V3
            
         
            
               AWS SDK for PHP V3
            
         
            
               AWS SDK for Python
            
         
            
               AWS SDK for Ruby V3
            
         
   Document ConventionsGetFunctionConcurrencyGetFunctionEventInvokeConfigDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaAPI ReferenceRequest SyntaxURI Request ParametersRequest BodyResponse SyntaxResponse ElementsErrorsSee AlsoCreateFunctionCreates a Lambda function. To create a function, you need a deployment package and an execution role. The
      deployment package is a .zip file archive or container image that contains your function code. The execution role
      grants the function permission to use AWS services, such as Amazon CloudWatch Logs for log
      streaming and AWS X-Ray for request tracing.If the deployment package is a container
        image, then you set the package type to Image. For a container image, the code property
      must include the URI of a container image in the Amazon ECR registry. You do not need to specify the
      handler and runtime properties.If the deployment package is a .zip file archive, then
      you set the package type to Zip. For a .zip file archive, the code property specifies the location of
      the .zip file. You must also specify the handler and runtime properties. The code in the deployment package must
      be compatible with the target instruction set architecture of the function (x86-64 or
        arm64). If you do not specify the architecture, then the default value is
      x86-64.When you create a function, Lambda provisions an instance of the function and its supporting
      resources. If your function connects to a VPC, this process can take a minute or so. During this time, you can't
      invoke or modify the function. The State, StateReason, and StateReasonCode
      fields in the response from GetFunctionConfiguration indicate when the function is ready to
      invoke. For more information, see Lambda function states.A function has an unpublished version, and can have published versions and aliases. The unpublished version
      changes when you update your function's code and configuration. A published version is a snapshot of your function
      code and configuration that can't be changed. An alias is a named resource that maps to a version, and can be
      changed to map to a different version. Use the Publish parameter to create version 1 of
      your function from its initial configuration.The other parameters let you configure version-specific and function-level settings. You can modify
      version-specific settings later with UpdateFunctionConfiguration. Function-level settings apply
      to both the unpublished and published versions of the function, and include tags (TagResource)
      and per-function concurrency limits (PutFunctionConcurrency).You can use code signing if your deployment package is a .zip file archive. To enable code signing for this
      function, specify the ARN of a code-signing configuration. When a user attempts to deploy a code package with
        UpdateFunctionCode, Lambda checks that the code package has a valid signature from
      a trusted publisher. The code-signing configuration includes set of signing profiles, which define the trusted
      publishers for this function.If another AWS account or an AWS service invokes your function, use AddPermission to grant permission by creating a resource-based AWS Identity and Access Management (IAM) policy. You can grant permissions at the function level, on a version, or on an alias.To invoke your function directly, use Invoke. To invoke your function in response to events
      in other AWS services, create an event source mapping (CreateEventSourceMapping),
      or configure a function trigger in the other service. For more information, see Invoking Lambda
      functions.
      Request Syntax
      POST /2015-03-31/functions HTTP/1.1
Content-type: application/json

{
   "Architectures": [ "string" ],
   "Code": { 
      "ImageUri": "string",
      "S3Bucket": "string",
      "S3Key": "string",
      "S3ObjectVersion": "string",
      "SourceKMSKeyArn": "string",
      "ZipFile": blob
   },
   "CodeSigningConfigArn": "string",
   "DeadLetterConfig": { 
      "TargetArn": "string"
   },
   "Description": "string",
   "Environment": { 
      "Variables": { 
         "string" : "string" 
      }
   },
   "EphemeralStorage": { 
      "Size": number
   },
   "FileSystemConfigs": [ 
      { 
         "Arn": "string",
         "LocalMountPath": "string"
      }
   ],
   "FunctionName": "string",
   "Handler": "string",
   "ImageConfig": { 
      "Command": [ "string" ],
      "EntryPoint": [ "string" ],
      "WorkingDirectory": "string"
   },
   "KMSKeyArn": "string",
   "Layers": [ "string" ],
   "LoggingConfig": { 
      "ApplicationLogLevel": "string",
      "LogFormat": "string",
      "LogGroup": "string",
      "SystemLogLevel": "string"
   },
   "MemorySize": number,
   "PackageType": "string",
   "Publish": boolean,
   "Role": "string",
   "Runtime": "string",
   "SnapStart": { 
      "ApplyOn": "string"
   },
   "Tags": { 
      "string" : "string" 
   },
   "Timeout": number,
   "TracingConfig": { 
      "Mode": "string"
   },
   "VpcConfig": { 
      "Ipv6AllowedForDualStack": boolean,
      "SecurityGroupIds": [ "string" ],
      "SubnetIds": [ "string" ]
   }
}
    
      URI Request Parameters
      The request does not use any URI parameters.
    
      Request Body
      The request accepts the following data in JSON format.
      
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
      
            
               
                  Architectures
               
            
            
               The instruction set architecture that the function supports. Enter a string array with one of the valid values (arm64 or x86_64).
     The default value is x86_64.
               Type: Array of strings
               Array Members: Fixed number of 1 item.
               Valid Values: x86_64 | arm64
               
               Required: No
            
          
            
               
                  Code
               
            
            
               The code for the function.
               Type: FunctionCode object
               Required: Yes
            
          
            
               
                  CodeSigningConfigArn
               
            
            
               To enable code signing for this function, specify the ARN of a code-signing configuration. A code-signing configuration
includes a set of signing profiles, which define the trusted publishers for this function.
               Type: String
               Length Constraints: Maximum length of 200.
               Pattern: arn:(aws[a-zA-Z-]*)?:lambda:[a-z]{2}((-gov)|(-iso(b?)))?-[a-z]+-\d{1}:\d{12}:code-signing-config:csc-[a-z0-9]{17}
               
               Required: No
            
          
            
               
                  DeadLetterConfig
               
            
            
               A dead-letter queue configuration that specifies the queue or topic where Lambda sends asynchronous events
      when they fail processing. For more information, see Dead-letter queues.
               Type: DeadLetterConfig object
               Required: No
            
          
            
               
                  Description
               
            
            
               A description of the function.
               Type: String
               Length Constraints: Minimum length of 0. Maximum length of 256.
               Required: No
            
          
            
               
                  Environment
               
            
            
               Environment variables that are accessible from function code during execution.
               Type: Environment object
               Required: No
            
          
            
               
                  EphemeralStorage
               
            
            
               The size of the function's /tmp directory in MB. The default value is 512, but can be any whole
      number between 512 and 10,240 MB. For more information, see Configuring ephemeral storage (console).
               Type: EphemeralStorage object
               Required: No
            
          
            
               
                  FileSystemConfigs
               
            
            
               Connection settings for an Amazon EFS file system.
               Type: Array of FileSystemConfig objects
               Array Members: Maximum number of 1 item.
               Required: No
            
          
            
               
                  FunctionName
               
            
            
               The name or ARN of the Lambda function.
               
                  Name formats
                   
                   
                   
               
                     
                        Function name – my-function.
                  
                     
                        Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function.
                  
                     
                        Partial ARN – 123456789012:function:my-function.
                  
               The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64
      characters in length.
               Type: String
               Length Constraints: Minimum length of 1. Maximum length of 140.
               Pattern: (arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\d{1}:)?(\d{12}:)?(function:)?([a-zA-Z0-9-_]+)(:(\$LATEST|[a-zA-Z0-9-_]+))?
               
               Required: Yes
            
          
            
               
                  Handler
               
            
            
               The name of the method within your code that Lambda calls to run your function. 
Handler is required if the deployment package is a .zip file archive. The format includes the
      file name. It can also include namespaces and other qualifiers, depending on the runtime. For more information,
      see Lambda programming model.
               Type: String
               Length Constraints: Maximum length of 128.
               Pattern: [^ ]+
               
               Required: No
            
          
            
               
                  ImageConfig
               
            
            
               Container image configuration
      values that override the values in the container image Dockerfile.
               Type: ImageConfig object
               Required: No
            
          
            
               
                  KMSKeyArn
               
            
            
               The ARN of the AWS Key Management Service (AWS KMS) customer managed key that's used to encrypt the following resources:
               
                   
                   
                   
                   
               
                     The function's environment variables.
                  
                     The function's Lambda SnapStart snapshots.
                  
                     When used with SourceKMSKeyArn, the unzipped version of the .zip deployment package that's used for function invocations. For more information, see 
Specifying a customer managed key for Lambda.
                  
                     The optimized version of the container image that's used for function invocations. Note that this is not the same key that's used to protect your container image in the Amazon Elastic Container Registry (Amazon ECR). For more information, see Function lifecycle.
                  
               If you don't provide a customer managed key, Lambda uses an AWS owned key or an AWS managed key.
               Type: String
               Pattern: (arn:(aws[a-zA-Z-]*)?:[a-z0-9-.]+:.*)|()
               
               Required: No
            
          
            
               
                  Layers
               
            
            
               A list of function layers
      to add to the function's execution environment. Specify each layer by its ARN, including the version.
               Type: Array of strings
               Length Constraints: Minimum length of 1. Maximum length of 140.
               Pattern: arn:[a-zA-Z0-9-]+:lambda:[a-zA-Z0-9-]+:\d{12}:layer:[a-zA-Z0-9-_]+:[0-9]+
               
               Required: No
            
          
            
               
                  LoggingConfig
               
            
            
               The function's Amazon CloudWatch Logs configuration settings.
               Type: LoggingConfig object
               Required: No
            
          
            
               
                  MemorySize
               
            
            
               The amount of memory available to the function at runtime.
      Increasing the function memory also increases its CPU allocation. The default value is 128 MB. The value can be any multiple of 1 MB.
               Type: Integer
               Valid Range: Minimum value of 128. Maximum value of 10240.
               Required: No
            
          
            
               
                  PackageType
               
            
            
               The type of deployment package. Set to Image for container image and set to Zip for .zip file archive.
               Type: String
               Valid Values: Zip | Image
               
               Required: No
            
          
            
               
                  Publish
               
            
            
               Set to true to publish the first version of the function during creation.
               Type: Boolean
               Required: No
            
          
            
               
                  Role
               
            
            
               The Amazon Resource Name (ARN) of the function's execution role.
               Type: String
               Pattern: arn:(aws[a-zA-Z-]*)?:iam::\d{12}:role/?[a-zA-Z_0-9+=,.@\-_/]+
               
               Required: Yes
            
          
            
               
                  Runtime
               
            
            
               The identifier of the function's 
          runtime. Runtime is required if the deployment package is a .zip file archive. Specifying a runtime results in
          an error if you're deploying a function using a container image.
               The following list includes deprecated runtimes. Lambda blocks creating new functions and updating existing
          functions shortly after each runtime is deprecated. For more information, see
          Runtime use after deprecation.
               For a list of all currently supported runtimes, see
          Supported runtimes.
               Type: String
               Valid Values: nodejs | nodejs4.3 | nodejs6.10 | nodejs8.10 | nodejs10.x | nodejs12.x | nodejs14.x | nodejs16.x | java8 | java8.al2 | java11 | python2.7 | python3.6 | python3.7 | python3.8 | python3.9 | dotnetcore1.0 | dotnetcore2.0 | dotnetcore2.1 | dotnetcore3.1 | dotnet6 | dotnet8 | nodejs4.3-edge | go1.x | ruby2.5 | ruby2.7 | provided | provided.al2 | nodejs18.x | python3.10 | java17 | ruby3.2 | ruby3.3 | ruby3.4 | python3.11 | nodejs20.x | provided.al2023 | python3.12 | java21 | python3.13 | nodejs22.x
               
               Required: No
            
          
            
               
                  SnapStart
               
            
            
               The function's SnapStart setting.
               Type: SnapStart object
               Required: No
            
          
            
               
                  Tags
               
            
            
               A list of tags to apply to the
      function.
               Type: String to string map
               Required: No
            
          
            
               
                  Timeout
               
            
            
               The amount of time (in seconds) that Lambda allows a function to run before stopping it. The default is 3 seconds. The
      maximum allowed value is 900 seconds. For more information, see Lambda execution environment.
               Type: Integer
               Valid Range: Minimum value of 1.
               Required: No
            
          
            
               
                  TracingConfig
               
            
            
               Set Mode to Active to sample and trace a subset of incoming requests with
X-Ray.
               Type: TracingConfig object
               Required: No
            
          
            
               
                  VpcConfig
               
            
            
               For network connectivity to AWS resources in a VPC, specify a list of security groups and subnets in the VPC.
      When you connect a function to a VPC, it can access resources and the internet only through that VPC. For more
      information, see Configuring a Lambda function to access resources in a VPC.
               Type: VpcConfig object
               Required: No
            
         
    
      Response Syntax
      HTTP/1.1 201
Content-type: application/json

{
   "Architectures": [ "string" ],
   "CodeSha256": "string",
   "CodeSize": number,
   "DeadLetterConfig": { 
      "TargetArn": "string"
   },
   "Description": "string",
   "Environment": { 
      "Error": { 
         "ErrorCode": "string",
         "Message": "string"
      },
      "Variables": { 
         "string" : "string" 
      }
   },
   "EphemeralStorage": { 
      "Size": number
   },
   "FileSystemConfigs": [ 
      { 
         "Arn": "string",
         "LocalMountPath": "string"
      }
   ],
   "FunctionArn": "string",
   "FunctionName": "string",
   "Handler": "string",
   "ImageConfigResponse": { 
      "Error": { 
         "ErrorCode": "string",
         "Message": "string"
      },
      "ImageConfig": { 
         "Command": [ "string" ],
         "EntryPoint": [ "string" ],
         "WorkingDirectory": "string"
      }
   },
   "KMSKeyArn": "string",
   "LastModified": "string",
   "LastUpdateStatus": "string",
   "LastUpdateStatusReason": "string",
   "LastUpdateStatusReasonCode": "string",
   "Layers": [ 
      { 
         "Arn": "string",
         "CodeSize": number,
         "SigningJobArn": "string",
         "SigningProfileVersionArn": "string"
      }
   ],
   "LoggingConfig": { 
      "ApplicationLogLevel": "string",
      "LogFormat": "string",
      "LogGroup": "string",
      "SystemLogLevel": "string"
   },
   "MasterArn": "string",
   "MemorySize": number,
   "PackageType": "string",
   "RevisionId": "string",
   "Role": "string",
   "Runtime": "string",
   "RuntimeVersionConfig": { 
      "Error": { 
         "ErrorCode": "string",
         "Message": "string"
      },
      "RuntimeVersionArn": "string"
   },
   "SigningJobArn": "string",
   "SigningProfileVersionArn": "string",
   "SnapStart": { 
      "ApplyOn": "string",
      "OptimizationStatus": "string"
   },
   "State": "string",
   "StateReason": "string",
   "StateReasonCode": "string",
   "Timeout": number,
   "TracingConfig": { 
      "Mode": "string"
   },
   "Version": "string",
   "VpcConfig": { 
      "Ipv6AllowedForDualStack": boolean,
      "SecurityGroupIds": [ "string" ],
      "SubnetIds": [ "string" ],
      "VpcId": "string"
   }
}
    
      Response Elements
      If the action is successful, the service sends back an HTTP 201 response.
      The following data is returned in JSON format by the service.
      
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
      
            
               
                  Architectures
               
            
            
               The instruction set architecture that the function supports. Architecture is a string array with one of the 
      valid values. The default architecture value is x86_64.
               Type: Array of strings
               Array Members: Fixed number of 1 item.
               Valid Values: x86_64 | arm64
               
            
          
            
               
                  CodeSha256
               
            
            
               The SHA256 hash of the function's deployment package.
               Type: String
            
          
            
               
                  CodeSize
               
            
            
               The size of the function's deployment package, in bytes.
               Type: Long
            
          
            
               
                  DeadLetterConfig
               
            
            
               The function's dead letter queue.
               Type: DeadLetterConfig object
            
          
            
               
                  Description
               
            
            
               The function's description.
               Type: String
               Length Constraints: Minimum length of 0. Maximum length of 256.
            
          
            
               
                  Environment
               
            
            
               The function's environment variables. Omitted from AWS CloudTrail logs.
               Type: EnvironmentResponse object
            
          
            
               
                  EphemeralStorage
               
            
            
               The size of the function's /tmp directory in MB. The default value is 512, but can be any whole
  number between 512 and 10,240 MB. For more information, see Configuring ephemeral storage (console).
               Type: EphemeralStorage object
            
          
            
               
                  FileSystemConfigs
               
            
            
               Connection settings for an Amazon EFS file system.
               Type: Array of FileSystemConfig objects
               Array Members: Maximum number of 1 item.
            
          
            
               
                  FunctionArn
               
            
            
               The function's Amazon Resource Name (ARN).
               Type: String
               Pattern: arn:(aws[a-zA-Z-]*)?:lambda:[a-z]{2}(-gov)?-[a-z]+-\d{1}:\d{12}:function:[a-zA-Z0-9-_\.]+(:(\$LATEST|[a-zA-Z0-9-_]+))?
               
            
          
            
               
                  FunctionName
               
            
            
               The name of the function.
               Type: String
               Length Constraints: Minimum length of 1. Maximum length of 170.
               Pattern: (arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\d{1}:)?(\d{12}:)?(function:)?([a-zA-Z0-9-_\.]+)(:(\$LATEST|[a-zA-Z0-9-_]+))?
               
            
          
            
               
                  Handler
               
            
            
               The function that Lambda calls to begin running your function.
               Type: String
               Length Constraints: Maximum length of 128.
               Pattern: [^ ]+
               
            
          
            
               
                  ImageConfigResponse
               
            
            
               The function's image configuration values.
               Type: ImageConfigResponse object
            
          
            
               
                  KMSKeyArn
               
            
            
               The ARN of the AWS Key Management Service (AWS KMS) customer managed key that's used to encrypt the following resources:
               
                   
                   
                   
                   
               
                     The function's environment variables.
                  
                     The function's Lambda SnapStart snapshots.
                  
                     When used with SourceKMSKeyArn, the unzipped version of the .zip deployment package that's used for function invocations. For more information, see 
          Specifying a customer managed key for Lambda.
                  
                     The optimized version of the container image that's used for function invocations. Note that this is not the same key that's used to protect your container image in the Amazon Elastic Container Registry (Amazon ECR). For more information, see Function lifecycle.
                  
               If you don't provide a customer managed key, Lambda uses an AWS owned key or an AWS managed key.
               Type: String
               Pattern: (arn:(aws[a-zA-Z-]*)?:[a-z0-9-.]+:.*)|()
               
            
          
            
               
                  LastModified
               
            
            
               The date and time that the function was last updated, in ISO-8601 format (YYYY-MM-DDThh:mm:ss.sTZD).
               Type: String
            
          
            
               
                  LastUpdateStatus
               
            
            
               The status of the last update that was performed on the function. This is first set to Successful
      after function creation completes.
               Type: String
               Valid Values: Successful | Failed | InProgress
               
            
          
            
               
                  LastUpdateStatusReason
               
            
            
               The reason for the last update that was performed on the function.
               Type: String
            
          
            
               
                  LastUpdateStatusReasonCode
               
            
            
               The reason code for the last update that was performed on the function.
               Type: String
               Valid Values: EniLimitExceeded | InsufficientRolePermissions | InvalidConfiguration | InternalError | SubnetOutOfIPAddresses | InvalidSubnet | InvalidSecurityGroup | ImageDeleted | ImageAccessDenied | InvalidImage | KMSKeyAccessDenied | KMSKeyNotFound | InvalidStateKMSKey | DisabledKMSKey | EFSIOError | EFSMountConnectivityError | EFSMountFailure | EFSMountTimeout | InvalidRuntime | InvalidZipFileException | FunctionError
               
            
          
            
               
                  Layers
               
            
            
               The function's layers.
               Type: Array of Layer objects
            
          
            
               
                  LoggingConfig
               
            
            
               The function's Amazon CloudWatch Logs configuration settings.
               Type: LoggingConfig object
            
          
            
               
                  MasterArn
               
            
            
               For Lambda@Edge functions, the ARN of the main function.
               Type: String
               Pattern: arn:(aws[a-zA-Z-]*)?:lambda:[a-z]{2}(-gov)?-[a-z]+-\d{1}:\d{12}:function:[a-zA-Z0-9-_]+(:(\$LATEST|[a-zA-Z0-9-_]+))?
               
            
          
            
               
                  MemorySize
               
            
            
               The amount of memory available to the function at runtime.
               Type: Integer
               Valid Range: Minimum value of 128. Maximum value of 10240.
            
          
            
               
                  PackageType
               
            
            
               The type of deployment package. Set to Image for container image and set Zip for .zip file archive.
               Type: String
               Valid Values: Zip | Image
               
            
          
            
               
                  RevisionId
               
            
            
               The latest updated revision of the function or alias.
               Type: String
            
          
            
               
                  Role
               
            
            
               The function's execution role.
               Type: String
               Pattern: arn:(aws[a-zA-Z-]*)?:iam::\d{12}:role/?[a-zA-Z_0-9+=,.@\-_/]+
               
            
          
            
               
                  Runtime
               
            
            
               The identifier of the function's 
          runtime. Runtime is required if the deployment package is a .zip file archive. Specifying a runtime results in
          an error if you're deploying a function using a container image.
               The following list includes deprecated runtimes. Lambda blocks creating new functions and updating existing
          functions shortly after each runtime is deprecated. For more information, see
          Runtime use after deprecation.
               For a list of all currently supported runtimes, see
          Supported runtimes.
               Type: String
               Valid Values: nodejs | nodejs4.3 | nodejs6.10 | nodejs8.10 | nodejs10.x | nodejs12.x | nodejs14.x | nodejs16.x | java8 | java8.al2 | java11 | python2.7 | python3.6 | python3.7 | python3.8 | python3.9 | dotnetcore1.0 | dotnetcore2.0 | dotnetcore2.1 | dotnetcore3.1 | dotnet6 | dotnet8 | nodejs4.3-edge | go1.x | ruby2.5 | ruby2.7 | provided | provided.al2 | nodejs18.x | python3.10 | java17 | ruby3.2 | ruby3.3 | ruby3.4 | python3.11 | nodejs20.x | provided.al2023 | python3.12 | java21 | python3.13 | nodejs22.x
               
            
          
            
               
                  RuntimeVersionConfig
               
            
            
               The ARN of the runtime and any errors that occured.
               Type: RuntimeVersionConfig object
            
          
            
               
                  SigningJobArn
               
            
            
               The ARN of the signing job.
               Type: String
               Pattern: arn:(aws[a-zA-Z0-9-]*):([a-zA-Z0-9\-])+:([a-z]{2}(-gov)?-[a-z]+-\d{1})?:(\d{12})?:(.*)
               
            
          
            
               
                  SigningProfileVersionArn
               
            
            
               The ARN of the signing profile version.
               Type: String
               Pattern: arn:(aws[a-zA-Z0-9-]*):([a-zA-Z0-9\-])+:([a-z]{2}(-gov)?-[a-z]+-\d{1})?:(\d{12})?:(.*)
               
            
          
            
               
                  SnapStart
               
            
            
               Set ApplyOn to PublishedVersions to create a snapshot of the initialized execution
      environment when you publish a function version. For more information, see Improving startup performance with Lambda SnapStart.
               Type: SnapStartResponse object
            
          
            
               
                  State
               
            
            
               The current state of the function. When the state is Inactive, you can reactivate the function by
      invoking it.
               Type: String
               Valid Values: Pending | Active | Inactive | Failed
               
            
          
            
               
                  StateReason
               
            
            
               The reason for the function's current state.
               Type: String
            
          
            
               
                  StateReasonCode
               
            
            
               The reason code for the function's current state. When the code is Creating, you can't invoke or
      modify the function.
               Type: String
               Valid Values: Idle | Creating | Restoring | EniLimitExceeded | InsufficientRolePermissions | InvalidConfiguration | InternalError | SubnetOutOfIPAddresses | InvalidSubnet | InvalidSecurityGroup | ImageDeleted | ImageAccessDenied | InvalidImage | KMSKeyAccessDenied | KMSKeyNotFound | InvalidStateKMSKey | DisabledKMSKey | EFSIOError | EFSMountConnectivityError | EFSMountFailure | EFSMountTimeout | InvalidRuntime | InvalidZipFileException | FunctionError
               
            
          
            
               
                  Timeout
               
            
            
               The amount of time in seconds that Lambda allows a function to run before stopping it.
               Type: Integer
               Valid Range: Minimum value of 1.
            
          
            
               
                  TracingConfig
               
            
            
               The function's AWS X-Ray tracing configuration.
               Type: TracingConfigResponse object
            
          
            
               
                  Version
               
            
            
               The version of the Lambda function.
               Type: String
               Length Constraints: Minimum length of 1. Maximum length of 1024.
               Pattern: (\$LATEST|[0-9]+)
               
            
          
            
               
                  VpcConfig
               
            
            
               The function's networking configuration.
               Type: VpcConfigResponse object
            
         
    
      Errors
      For information about the errors that are common to all actions, see Common Errors.
      
          
          
          
          
          
          
          
          
          
      
            
               
                  CodeSigningConfigNotFoundException
               
            
            
               The specified code signing configuration does not exist.
               HTTP Status Code: 404
            
          
            
               
                  CodeStorageExceededException
               
            
            
               Your AWS account has exceeded its maximum total code size. For more information, see Lambda quotas.
               HTTP Status Code: 400
            
          
            
               
                  CodeVerificationFailedException
               
            
            
               The code signature failed one or more of the validation checks for signature mismatch or expiry, and the code
      signing policy is set to ENFORCE. Lambda blocks the deployment.
               HTTP Status Code: 400
            
          
            
               
                  InvalidCodeSignatureException
               
            
            
               The code signature failed the integrity check. If the integrity check fails, then Lambda blocks
      deployment, even if the code signing policy is set to WARN.
               HTTP Status Code: 400
            
          
            
               
                  InvalidParameterValueException
               
            
            
               One of the parameters in the request is not valid.
               HTTP Status Code: 400
            
          
            
               
                  ResourceConflictException
               
            
            
               The resource already exists, or another operation is in progress.
               HTTP Status Code: 409
            
          
            
               
                  ResourceNotFoundException
               
            
            
               The resource specified in the request does not exist.
               HTTP Status Code: 404
            
          
            
               
                  ServiceException
               
            
            
               The AWS Lambda service encountered an internal error.
               HTTP Status Code: 500
            
          
            
               
                  TooManyRequestsException
               
            
            
               The request throughput limit was exceeded. For more information, see Lambda quotas.
               HTTP Status Code: 429
            
         
    
      See Also
      For more information about using this API in one of the language-specific AWS SDKs, see the following:
      
          
          
          
          
          
          
          
          
          
      
            
               AWS Command Line Interface
            
         
            
               AWS SDK for .NET
            
         
            
               AWS SDK for C++
            
         
            
               AWS SDK for Go v2
            
         
            
               AWS SDK for Java V2
            
         
            
               AWS SDK for JavaScript V3
            
         
            
               AWS SDK for PHP V3
            
         
            
               AWS SDK for Python
            
         
            
               AWS SDK for Ruby V3
            
         
   Document ConventionsCreateEventSourceMappingCreateFunctionUrlConfigDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideRuntime dependencies in Node.jsCreating a .zip deployment package with no dependenciesCreating a .zip deployment package with dependenciesCreating a Node.js layer for your dependenciesDependency search path and runtime-included librariesCreating and updating Node.js Lambda functions using .zip filesDeploy Node.js Lambda functions with .zip file archives
    Your AWS Lambda function’s code comprises a .js or .mjs file containing your function’s handler code, together with any additional packages and modules 
    your code depends on. To deploy this function code to Lambda, you use a deployment package. This package may either be a 
  .zip file archive or a container image.  
  For more information about using container images with Node.js, see Deploy Node.js Lambda functions with container images.
  
    To create your deployment package as .zip file archive, you can use your command-line tool’s built-in .zip file archive utility, or any other 
    .zip file utility such as 7zip. The examples shown in the following sections assume 
  you’re using a command-line zip tool in a Linux or MacOS environment. To use the same commands in Windows, you can 
  install the Windows Subsystem for Linux to get a Windows-integrated 
  version of Ubuntu and Bash.
  
    Note that Lambda uses POSIX file permissions, so you may need to set permissions for the deployment package folder before you create the .zip file archive.
  TopicsRuntime dependencies in Node.jsCreating a .zip deployment package with no dependenciesCreating a .zip deployment package with dependenciesCreating a Node.js layer for your dependenciesDependency search path and runtime-included librariesCreating and updating Node.js Lambda functions using .zip files
    Runtime dependencies in Node.js
    
      For Lambda functions that use the Node.js runtime, a dependency can be any Node.js module. The Node.js runtime includes a number of common 
      libraries, as well as a version of the AWS SDK for JavaScript. The nodejs16.x Lambda runtime includes version 2.x of the SDK. Runtime versions nodejs18.x and later include version 3 of the SDK. To use version 2 of the SDK with runtime versions nodejs18.x and later, add the SDK to your 
      .zip file deployment package. If your chosen runtime includes the version of the SDK you are using, you don't need to include the SDK library 
      in your .zip file. To find out which version of the SDK is included in the runtime you're using, see Runtime-included SDK versions.
    
    
      Lambda periodically updates the SDK libraries in the Node.js runtime to include the latest features and security upgrades. Lambda also applies 
      security patches and updates to the other libraries included in the runtime. To have full control of the dependencies in your package, you can 
      add your preferred version of any runtime-included dependency to your deployment package. For example, if you want to use a particular version of 
      the SDK for JavaScript, you can include it in your .zip file as a dependency. For more information on adding runtime-included dependencies to your .zip 
      file, see Dependency search path and runtime-included libraries.
    
    
      Under the AWS shared responsibility model, 
      you are responsible for the management of any dependencies in your functions' deployment packages. This includes applying updates and security 
      patches. To update dependencies in your function's deployment package, first create a new .zip file and then upload it to Lambda. See Creating a .zip deployment package with dependencies 
      and Creating and updating Node.js Lambda functions using .zip files for more information.
    
   
    Creating a .zip deployment package with no dependencies
    
      If your function code has no dependencies except for libraries included in the Lambda runtime, your .zip file contains only the index.js or 
      index.mjs file with your function’s handler code. Use your preferred zip utility to create a .zip file with your index.js or 
      index.mjs file at the root. If the file containing your handler code isn't at the root of your .zip file, Lambda won’t be able to run your code.
    
    
      To learn how to deploy your .zip file to create a new Lambda function or update an existing one, see Creating and updating Node.js Lambda functions using .zip files.
    
   
    Creating a .zip deployment package with dependencies
    If your function code depends on packages or modules that aren't included in the Lambda Node.js runtime,
      you can either add these dependencies to your .zip file with your function code or use a
      Lambda layer. The instructions in this section show you how to
      include your dependencies in your .zip deployment package. For instructions on how to include your
      dependencies in a layer, see Creating a Node.js layer for your dependencies.
    The following example CLI commands create a .zip file named my_deployment_package.zip containing the index.js 
      or index.mjs file with your function's handler code and its dependencies. In the example, you install dependencies using the 
      npm package manager.
    To create the deployment package
        Navigate to the project directory containing your index.js or index.mjs source code file. In this example, 
          the directory is named my_function.
        cd my_function
      
        Install your function's required libraries in the node_modules directory using the npm install command. In this 
          example you install the AWS X-Ray SDK for Node.js.
        npm install aws-xray-sdk
        This creates a folder structure similar to the following:
        ~/my_function
├── index.mjs
└── node_modules
    ├── async
    ├── async-listener
    ├── atomic-batcher
    ├── aws-sdk
    ├── aws-xray-sdk
    ├── aws-xray-sdk-core
        You can also add custom modules that you create yourself to your deployment package. Create a directory under node_modules 
          with the name of your module and save your custom written packages there.
      
        Create a .zip file that contains the contents of your project folder at the root. Use the r (recursive) option to 
          ensure that zip compresses the subfolders.
        zip -r my_deployment_package.zip .
      
   
    Creating a Node.js layer for your dependencies
    The instructions in this section show you how to include your dependencies in a layer. For instructions
      on how to include your dependencies in your deployment package, see
      Creating a .zip deployment package with dependencies.
    When you add a layer to a function, Lambda loads the layer content into the
      /opt directory of that execution environment. For each Lambda runtime,
      the PATH variable already includes specific folder paths within the
      /opt directory. To ensure that Lambda picks up your layer content, 
      your layer .zip file should have its dependencies
      in the following folder paths:
    
       
       
       
          
    
        nodejs/node_modules
      
        nodejs/node16/node_modules (NODE_PATH)
      
        nodejs/node18/node_modules (NODE_PATH)
      
        nodejs/node20/node_modules (NODE_PATH)
      
    For example, your layer .zip file structure might look like the following:
    xray-sdk.zip
└ nodejs/node_modules/aws-xray-sdk
    In addition, Lambda automatically detects any libraries in the /opt/lib
      directory, and any binaries in the /opt/bin directory. To ensure
      that Lambda properly finds your layer content, you can also create a layer
      with the following structure:
      custom-layer.zip
└ lib
    | lib_1
    | lib_2
└ bin
    | bin_1
    | bin_2
    After you package your layer, see Creating and deleting layers in Lambda
      and Adding layers to functions to complete your layer setup.
   
    Dependency search path and runtime-included libraries
    The Node.js runtime includes a number of common libraries, as well as a version of the AWS SDK for JavaScript. If you want to use a different version of a runtime-included library, you can do this by bundling it with your function or by adding it as a 
      dependency in your deployment package. For example, you can use a different version of the SDK by adding it to your .zip deployment package. 
      You can also include it in a Lambda layer for your function.
    When you use an import or require statement in your code, the Node.js runtime searches the directories in the NODE_PATH 
      path until it finds the module. By default, the first location the runtime searches is the directory into which your .zip deployment package is 
      decompressed and mounted (/var/task). If you include a version of a runtime-included library in your deployment package, this 
      version will take precedence over the version included in the runtime. Dependencies in your deployment package also have precedence over 
      dependencies in layers.
    When you add a dependency to a layer, Lambda extracts this to /opt/nodejs/nodexx/node_modules where nodexx 
      represents the version of the runtime you are using. In the search path, this directory has precedence over the directory containing the 
      runtime-included libraries (/var/lang/lib/node_modules). Libraries in function layers therefore have precedence over versions 
      included in the runtime.
    You can see the full search path for your Lambda function by adding the following line of code.
    console.log(process.env.NODE_PATH)
    You can also add dependencies in a separate folder inside your .zip package. For example, you might add a custom module to a folder in 
      your .zip package called common. When your .zip package is decompressed and mounted, this folder is placed inside the /var/task directory. 
      To use a dependency from a folder in your .zip deployment package in your code, use an import { } from or const { } = require() statement, 
      depending on whether you are using CJS or ESM module resolution. For example:
    import { myModule } from './common'
    If you bundle your code with esbuild, rollup, or similar, the dependencies used by your function are bundled together in one 
      or more files. We recommend using this method to vend dependencies whenever possible. Compared to adding dependencies to your deployment package, 
      bundling your code results in improved performance due to the reduction in I/O operations.
   
    Creating and updating Node.js Lambda functions using .zip files
    
      After you have created your .zip deployment package, you can use it to create a new Lambda function or update an existing one. You can deploy 
      your .zip package using the Lambda console, the AWS Command Line Interface, and the Lambda API. You can also create and update Lambda functions using 
      AWS Serverless Application Model (AWS SAM) and AWS CloudFormation.
    
    The maximum size for a .zip deployment package for Lambda is 250 MB (unzipped). Note that this limit applies to the combined size of all the files you upload, 
    including any Lambda layers.
    The Lambda runtime needs permission to read the files in your deployment package. In Linux permissions octal notation, Lambda needs 644 permissions 
      for non-executable files (rw-r--r--) and 755 permissions (rwxr-xr-x) for directories and executable files.
    In Linux and MacOS, use the chmod command to change file permissions on files and directories in your deployment package. For 
      example, to give a non-executable file the correct permissions, run the following command.
    chmod 644 <filepath>
    To change file permissions in Windows, see Set, View, Change, or Remove Permissions on an Object 
    in the Microsoft Windows documentation.
    NoteIf you don't grant Lambda the permissions it needs to access directories in your deployment package, Lambda sets the permissions for those directories to 755 (rwxr-xr-x).
     
      Creating and updating functions with .zip files using the console
      
      To create a new function, you must first create the function in the console, then upload your .zip archive. To update an existing function, open the page for your function, then follow the same procedure to add your updated .zip file.
    

      If your .zip file is less than 50MB, you can create or update a function by uploading the file directly from your local machine. For .zip files greater than 50MB, you must upload your package to an Amazon S3 bucket first. For instructions on how to upload a file to an Amazon S3 bucket using the AWS Management Console, see Getting started with Amazon S3. To upload files using the AWS CLI, see Move objects in the AWS CLI User Guide.
    
      NoteYou cannot change the deployment package type (.zip or container image) for an existing function. For example, you cannot convert a container image function to use a .zip file archive. You must create a new function.
  To create a new function (console)
      Open the Functions page of the Lambda console and choose Create Function.
    
      Choose Author from scratch.
    
      Under Basic information, do the following:
      
          For Function name, enter the name for your function.
          
              For Runtime, select the runtime you want to use.
            
              (Optional) For Architecture, choose the instruction set architecture for your function. The default architecture is x86_64. Ensure that the .zip deployment package for your function is compatible with the instruction set architecture you select.
            
    
      (Optional) Under Permissions, expand Change default execution role. You can create a new Execution role or use an existing one.
    
      Choose Create function. Lambda creates a basic 'Hello world' function using your chosen runtime.
    
  To upload a .zip archive from your local machine (console)
      In the Functions page of the Lambda console, choose the function you want to upload the .zip file for.
    
      Select the Code tab.
    
      In the Code source pane, choose Upload from.
    
      Choose .zip file.
    
      To upload the .zip file, do the following:
      
          Select Upload, then select your .zip file in the file chooser.
        
          Choose Open.
        
          Choose Save.
        
    
  
  To upload a .zip archive from an Amazon S3 bucket (console)
      In the Functions page of the Lambda console, choose the function you want to upload a new .zip file for.
    
      Select the Code tab.
    
      In the Code source pane, choose Upload from.
    
      Choose Amazon S3 location.
    
      Paste the Amazon S3 link URL of your .zip file and choose Save.
    
     
     
      Updating .zip file functions using the console code editor
      
     
    
      For some functions with .zip deployment packages, you can use the Lambda console’s built-in code editor to update your function code directly. To use this feature, your function must meet the following criteria:
    
    
       
       
    
        Your function must use one of the interpreted language runtimes (Python, Node.js, or Ruby)
      
        Your function’s deployment package must be smaller than 50 MB (unzipped).
      
    Function code for functions with container image deployment packages cannot be edited directly in the console.
    To update function code using the console code editor
        Open the Functions page of the Lambda console and select your function.
      
        Select the Code tab.
      
        In the Code source pane, select your source code file and edit it in the integrated code editor.
      
        In the DEPLOY section, choose Deploy to update your function's code:

   
    
   
   

      
     
      Creating and updating functions with .zip files using the AWS CLI
      
      You can can use the AWS CLI to create a new function or to update an existing one using a .zip file. Use the create-function 
      and update-function-code commands to deploy your .zip 
      package. If your .zip file is smaller than 50MB, you can upload the .zip package from a file location on your local build machine. For larger files, 
      you must upload your .zip package from an Amazon S3 bucket. For instructions on how to upload a file to an Amazon S3 bucket using the AWS CLI, see Move objects in the AWS CLI User Guide.
    
    NoteIf you upload your .zip file from an Amazon S3 bucket using the AWS CLI, the bucket must be located in the same AWS Region as your function.
    
      To create a new function using a .zip file with the AWS CLI, you must specify the following:
    
    
       
       
       
       
    
        The name of your function (--function-name)
      
        Your function’s runtime (--runtime)
      
        The Amazon Resource Name (ARN) of your function’s execution role (--role)
      
        The name of the handler method in your function code (--handler)
      
    
      You must also specify the location of your .zip file. If your .zip file is located in a folder on your local build machine, use the --zip-file option to specify the file path, as shown in the following example command.
    
    aws lambda create-function --function-name myFunction \
--runtime nodejs22.x --handler index.handler \
--role arn:aws:iam::111122223333:role/service-role/my-lambda-role \
--zip-file fileb://myFunction.zip
    
      To specify the location of .zip file in an Amazon S3 bucket, use the --code option as shown in the following example command. You only 
      need to use the S3ObjectVersion parameter for versioned objects.
    
    aws lambda create-function --function-name myFunction \
--runtime nodejs22.x --handler index.handler \
--role arn:aws:iam::111122223333:role/service-role/my-lambda-role \
--code S3Bucket=amzn-s3-demo-bucket,S3Key=myFileName.zip,S3ObjectVersion=myObjectVersion
    
      To update an existing function using the CLI, you specify the the name of your function using the --function-name parameter. You 
      must also specify the location of the .zip file you want to use to update your function code. If your .zip file is located in a folder on your 
      local build machine, use the --zip-file option to specify the file path, as shown in the following example command.
    
    aws lambda update-function-code --function-name myFunction \
--zip-file fileb://myFunction.zip
    
      To specify the location of .zip file in an Amazon S3 bucket, use the --s3-bucket and --s3-key options as shown in the 
      following example command. You only need to use the --s3-object-version parameter for versioned objects.
    
    aws lambda update-function-code --function-name myFunction \
--s3-bucket amzn-s3-demo-bucket --s3-key myFileName.zip --s3-object-version myObject Version
     
    
     
      Creating and updating functions with .zip files using the Lambda API
      
      To create and update functions using a .zip file archive, use the following API operations:
    

 
 

CreateFunction

UpdateFunctionCode

     
     
      Creating and updating functions with .zip files using AWS SAM
      
      The AWS Serverless Application Model (AWS SAM) is a toolkit that helps streamline the process of building and running serverless applications on AWS. You define the resources for your application in a 
      YAML or JSON template and use the AWS SAM command line interface (AWS SAM CLI) to build, package, and deploy your applications. When you build a Lambda function from an AWS SAM template, 
      AWS SAM automatically creates a .zip deployment package or container image with your function code and any dependencies you specify. To learn more about using AWS SAM to build and deploy 
      Lambda functions, see Getting started with AWS SAM in the
      AWS Serverless Application Model Developer Guide.

      You can also use AWS SAM to create a Lambda function using an existing .zip file archive. To create a Lambda function using AWS SAM, you can save your .zip file in 
      an Amazon S3 bucket or in a local folder on your build machine. For instructions on how to upload a file to an Amazon S3 bucket using the AWS CLI, 
      see Move objects in the AWS CLI User Guide.
    

      In your AWS SAM template, the AWS::Serverless::Function resource specifies your Lambda function. In this resource, set the following 
  properties to create a function using a .zip file archive:
    

 
 
 

PackageType - set to Zip

CodeUri - set to the  function code's Amazon S3 URI, path to local folder, or FunctionCode object

Runtime - Set to your chosen runtime


      With AWS SAM, if your .zip file is larger than 50MB, you don’t need to upload it to an Amazon S3 bucket first. AWS SAM can upload .zip packages up to 
      the maximum allowed size of 250MB (unzipped) from a location on your local build machine.
    

      To learn more about deploying functions using .zip file in AWS SAM, see AWS::Serverless::Function in the AWS SAM Developer Guide.
    
     
     
      Creating and updating functions with .zip files using AWS CloudFormation
      
      You can use AWS CloudFormation to create a Lambda function using a .zip file archive. To create a Lambda function from a .zip file, you must first upload 
      your file to an Amazon S3 bucket. For instructions on how to upload a file to an Amazon S3 bucket using the AWS CLI, see Move objects 
  in the AWS CLI User Guide. 
  In your AWS CloudFormation template, the AWS::Lambda::Function resource specifies your Lambda function. In this resource, set the following 
    properties to create a function using a .zip file archive:

 
 
 

PackageType - Set to Zip

Code - Enter the Amazon S3 bucket name and the .zip file name in the S3Bucket and S3Key fields

Runtime - Set to your chosen runtime


      The .zip file that AWS CloudFormation generates cannot exceed 4MB. To learn more about deploying functions using .zip file in AWS CloudFormation, see AWS::Lambda::Function 
  in the AWS CloudFormation User Guide.
    
     
  Document ConventionsHandlerDeploy container imagesDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideSupported runtimesNew runtime releasesRuntime deprecation policyShared responsibility modelRuntime use after deprecationReceiving runtime deprecation notificationsDeprecated runtimesLambda runtimesLambda supports multiple languages through the use of runtimes. A runtime provides a language-specific environment that relays invocation events, context information, and responses between Lambda and the function. You can use runtimes that Lambda provides, or build your own.   
  Each major programming language release has a separate runtime, with a unique runtime identifier, such as nodejs22.x or python3.13. To configure a function to use a new major language version, you need to change the runtime identifier. Since AWS Lambda cannot guarantee backward compatibility between major versions, this is a customer-driven operation.
    For a function defined as a container image,
    you choose a runtime and the Linux distribution when you create the container image.  To change the runtime, you create a new container image.When you use a .zip file archive for the deployment package, you choose a runtime when you create the function.
    To change the runtime, you can update your function's configuration.
    The runtime is paired with one of the Amazon Linux distributions. The underlying execution environment provides
    additional libraries and environment variables that you can access from
    your function code.Lambda invokes your function in an execution environment. The execution
    environment provides a secure and isolated runtime environment that manages the resources required to run your
    function. Lambda re-uses the execution environment from a previous invocation if one is available, or it can create a
    new execution environment.  To use other languages in Lambda, such as Go or Rust, use an OS-only runtime. The
    Lambda execution environment provides a runtime interface for getting invocation
    events and sending responses. You can deploy other languages by implementing a custom runtime alongside your function code, or in a layer.
    Supported runtimes
  The following table lists the supported Lambda runtimes and projected deprecation dates. After a runtime is deprecated, you're 
    still able to create and update functions for a limited period. For more information, see Runtime use after deprecation. 
    The table provides the currently forecasted dates for runtime deprecation, based on our Runtime deprecation policy. These dates are provided for planning purposes and are 
    subject to change.
  
  
  
      
        Name
        Identifier
        Operating system
        Deprecation date
        Block function create
        Block function update
      
    
                  
        
          Node.js 22
        
        
          nodejs22.x
        
        
          Amazon Linux 2023
        
        
                      Apr 30, 2027
            
        
        
                      Jun 1, 2027
                      
        
        
                      Jul 1, 2027
                      
        
      
            
        
          Node.js 20
        
        
          nodejs20.x
        
        
          Amazon Linux 2023
        
        
                      Apr 30, 2026
            
        
        
                      Jun 1, 2026
                      
        
        
                      Jul 1, 2026
                      
        
      
            
        
          Node.js 18
        
        
          nodejs18.x
        
        
          Amazon Linux 2
        
        
                      Sep 1, 2025
            
        
        
                      Oct 1, 2025
                      
        
        
                      Nov 1, 2025
                      
        
      
                        
        
          Python 3.13
        
        
          python3.13
        
        
          Amazon Linux 2023
        
        
                      Jun 30, 2029
            
        
        
                      Jul 31, 2029
                      
        
        
                      Aug 31, 2029
                      
        
      
            
        
          Python 3.12
        
        
          python3.12
        
        
          Amazon Linux 2023
        
        
                      Oct 31, 2028
            
        
        
                      Nov 30, 2028
                      
        
        
                      Jan 10, 2029
                      
        
      
            
        
          Python 3.11
        
        
          python3.11
        
        
          Amazon Linux 2
        
        
                      Jun 30, 2026
            
        
        
                      Jul 31, 2026
                      
        
        
                      Aug 31, 2026
                      
        
      
            
        
          Python 3.10
        
        
          python3.10
        
        
          Amazon Linux 2
        
        
                      Jun 30, 2026
            
        
        
                      Jul 31, 2026
                      
        
        
                      Aug 31, 2026
                      
        
      
            
        
          Python 3.9
        
        
          python3.9
        
        
          Amazon Linux 2
        
        
                      Nov 3, 2025
            
        
        
                      Dec 8, 2025
                      
        
        
                      Jan 8, 2026
                      
        
      
                        
        
          Java 21
        
        
          java21
        
        
          Amazon Linux 2023
        
        
                      Jun 30, 2029
            
        
        
                      Jul 31, 2029
                      
        
        
                      Aug 31, 2029
                      
        
      
            
        
          Java 17
        
        
          java17
        
        
          Amazon Linux 2
        
        
                      Jun 30, 2026
            
        
        
                      Jul 31, 2026
                      
        
        
                      Aug 31, 2026
                      
        
      
            
        
          Java 11
        
        
          java11
        
        
          Amazon Linux 2
        
        
                      Jun 30, 2026
            
        
        
                      Jul 31, 2026
                      
        
        
                      Aug 31, 2026
                      
        
      
            
        
          Java 8
        
        
          java8.al2
        
        
          Amazon Linux 2
        
        
                      Jun 30, 2026
            
        
        
                      Jul 31, 2026
                      
        
        
                      Aug 31, 2026
                      
        
      
                        
        
          .NET 9 (container only)
        
        
          dotnet9
        
        
          Amazon Linux 2023
        
        
          
            Not scheduled
            
        
        
          
            Not scheduled
                      
        
        
          
            Not scheduled
                      
        
      
            
        
          .NET 8
        
        
          dotnet8
        
        
          Amazon Linux 2023
        
        
                      Nov 10, 2026
            
        
        
                      Dec 10, 2026
                      
        
        
                      Jan 11, 2027
                      
        
      
                                    
        
          Ruby 3.4
        
        
          ruby3.4
        
        
          Amazon Linux 2023
        
        
          
            Not scheduled
            
        
        
          
            Not scheduled
                      
        
        
          
            Not scheduled
                      
        
      
            
        
          Ruby 3.3
        
        
          ruby3.3
        
        
          Amazon Linux 2023
        
        
                      Mar 31, 2027
            
        
        
                      Apr 30, 2027
                      
        
        
                      May 31, 2027
                      
        
      
            
        
          Ruby 3.2
        
        
          ruby3.2
        
        
          Amazon Linux 2
        
        
                      Mar 31, 2026
            
        
        
                      Apr 30, 2026
                      
        
        
                      May 31, 2026
                      
        
      
                        
        
          OS-only Runtime
        
        
          provided.al2023
        
        
          Amazon Linux 2023
        
        
                      Jun 30, 2029
            
        
        
                      Jul 31, 2029
                      
        
        
                      Aug 31, 2029
                      
        
      
            
        
          OS-only Runtime
        
        
          provided.al2
        
        
          Amazon Linux 2
        
        
                      Jun 30, 2026
            
        
        
                      Jul 31, 2026
                      
        
        
                      Aug 31, 2026
                      
        
      
                
  NoteFor new regions, Lambda will not support runtimes that are set to be deprecated within the next 6 months.
  
  Lambda keeps managed runtimes and their corresponding container base images up to date with patches and support for minor version releases. 
    For more information see Lambda runtime updates.
    To programmatically interact with other AWS services and resources from your Lambda function, you can use one of AWS SDKs. The Node.js, Python, 
      and Ruby runtimes include a version of the AWS SDK. However, to maintain full control of your dependencies, and to maximize backward compatibility 
      during automatic runtime updates, we recommend that you always include the SDK modules your code uses (along with any dependencies) in your 
      function's deployment package or in a Lambda layer.
    We recommend that you use the runtime-included SDK version only when you can't include additional packages in your deployment. For example, 
      when you create your function using the Lambda console code editor or using inline function code in an AWS CloudFormation template.
    Lambda periodically updates the versions of the AWS SDKs included in the Node.js, Python, and Ruby runtimes. To determine the version of the 
      AWS SDK included in the runtime you're using, see the following sections:
    
       
       
       
    
        Runtime-included SDK versions (Node.js)
      
        Runtime-included SDK versions (Python)
      
        Runtime-included SDK versions (Ruby)
      
  
    
  Lambda continues to support the Go programming language after deprecation of the Go 1.x runtime. For more information, see 
    
    Migrating AWS Lambda functions from the Go1.x runtime to the custom runtime on Amazon Linux 2 
    on the AWS Compute Blog.

  All supported Lambda runtimes support both x86_64 and arm64 architectures.
   
    New runtime releases
    Lambda provides managed runtimes for new language versions only when the release reaches the long-term support (LTS) phase of the language's release 
      cycle. For example, for the Node.js release cycle, when the release reaches the 
      Active LTS phase.
    Before the release reaches the long-term support phase, it remains in development and can still be subject to breaking changes. Lambda applies runtime updates 
      automatically by default, so breaking changes to a runtime version could stop your functions from working as expected.
    Lambda doesn't provide managed runtimes for language versions which aren't scheduled for LTS release.
    The following list shows the target launch month for upcoming Lambda runtimes. These dates are indicative only and subject to change.
    
       
       
       
       
    
        Java 25 - October 2025
      
        Python 3.14 - November 2025
      
        Node.js 24 - November 2025
      
        .NET 10 - December 2025
      
   
    Runtime deprecation policy
    
    Lambda runtimes for .zip file archives are built around a combination of operating system, 
      programming language, and software libraries that are subject to maintenance and security updates. Lambda’s standard deprecation policy is to 
      deprecate a runtime when any major component of the runtime reaches the end of community long-term support (LTS) and security updates are no 
      longer available. Most usually, this is the language runtime, though in some cases, a runtime can be deprecated because the operating system 
      (OS) reaches end of LTS.
    After a runtime is deprecated, AWS may no longer apply security patches or updates to that runtime, and functions using that runtime are no 
      longer eligible for technical support. Such deprecated runtimes are provided ‘as-is’, without any warranties, and may contain bugs, errors, 
      defects, or other vulnerabilities.
    To learn more about managing runtime upgrades and deprecation, see the following sections and Managing AWS Lambda runtime upgrades 
      on the AWS Compute Blog.
    ImportantLambda occasionally delays deprecation of a Lambda runtime for a limited period beyond the end of support date of the language version 
        that the runtime supports. During this period, Lambda only applies security patches to the runtime OS. Lambda doesn’t apply security patches 
        to programming language runtimes after they reach their end of support date.
    
   
    Shared responsibility model
    
      Lambda is responsible for curating and publishing security updates for all supported managed runtimes and container base images. By default, Lambda will apply these 
      updates automatically to functions using managed runtimes. Where the default automatic runtime update setting has been changed, see the runtime management controls shared responsibility model. 
      For functions deployed using container images, you're responsible for rebuilding your function's container image from the latest base image and redeploying the container image.
    
    
      When a runtime is deprecated, Lambda’s responsibility for updating the managed runtime and container base images ceases. You are responsible for upgrading your functions to 
      use a supported runtime or base image.
    
    
     In all cases, you are responsible for applying updates to your function code, including its dependencies. Your responsibilities under the shared responsibility model are 
     summarized in the following table.
    
          
            Runtime lifecycle phase
            Lambda's responsibilities
            Your responsibilities
          
        
          
            Supported managed runtime
            
              Provide regular runtime updates with security patches and other updates.
              Apply runtime updates automatically by default (see Runtime update modes for non-default behaviors).
            
            Update your function code, including dependencies, to address any security vulnerabilities.
          
          
            Supported container image
            Provide regular updates to container base image with security patches and other updates.
            
              Update your function code, including dependencies, to address any security vulnerabilities.
              Regularly re-build and re-deploy your container image using the latest base image.
            
          
          
            Managed runtime approaching deprecation
            
              Notify customers prior to runtime deprecation via documentation, AWS Health Dashboard, email, and Trusted Advisor.
              Responsibility for runtime updates ends at deprecation.
            
            
              Monitor Lambda documentation, AWS Health Dashboard, email, or Trusted Advisor for runtime deprecation information.
              Upgrade functions to a supported runtime before the previous runtime is deprecated.
            
          
          
            Container image approaching deprecation
            
              Deprecation notifications are not available for functions using container images.
              Responsibility for container base image updates ends at deprecation.
            
            Be aware of deprecation schedules and upgrade functions to a supported base image before the previous image is deprecated.
          
        
    
   
      Runtime use after deprecation
      After a runtime is deprecated, AWS may no longer apply security patches or updates to that runtime, and functions using that runtime are no 
        longer eligible for technical support. Such deprecated runtimes are provided ‘as-is’, without any warranties, and may contain bugs, errors, defects, 
        or other vulnerabilities. Functions that use a deprecated runtime may also experience degraded performance or other issues, such as a certificate expiry, 
        that can cause them to stop working properly.
      For at least 30 days after a runtime is deprecated, you’re still able to create new Lambda functions using that runtime. Starting from 30 days 
        after deprecation, Lambda begins blocking the creation of new functions.
      For at least 60 days after a runtime is deprecated, you’re still able to update function code and configuration for existing functions. Starting 
        from 60 days after deprecation, Lambda begins blocking the update of function code and configuration for existing functions.
      NoteFor some runtimes, AWS is delaying the block-function-create and block-function-update dates beyond the usual 30 and 60 days 
        after deprecation. AWS has made this change in response to customer feedback to give you more time to upgrade your functions. Refer to the 
        tables in Supported runtimes and Deprecated runtimes to see the dates for your runtime.
      You can update a function to use a newer supported runtime indefinitely after a runtime is deprecated. You should test that your 
        function works with the new runtime before applying the runtime change in production environments, since you will not be able to revert to the 
        deprecated runtime once the 60-day period has passed. We recommend using function versions and 
        aliases to enable safe deployment with rollback.
      Note that the exact length of time for which you can continue to create and update functions isn’t fixed. This period can vary 
        for each deprecation and for different AWS Regions. Nominal dates for the blocking of function creates and updates are provided in the 
        Supported Runtimes table in the first section of this page. Lambda will not start blocking function creates or updates before the dates given in this table.
      You can continue to invoke your functions indefinitely after the runtime is deprecated. However, AWS strongly recommends that you migrate functions 
        to a supported runtime so that your functions continue to receive security patches and remain eligible for technical support.
     
      Receiving runtime deprecation notifications
      When a runtime approaches its deprecation date, Lambda sends you an email alert if any functions in your AWS account use that runtime. 
        Notifications are also displayed in the AWS Health Dashboard and in AWS Trusted Advisor.
      
         
         
         
      
          Receiving email notifications:
          Lambda sends you an email alert at least 180 days before a runtime is deprecated. This email lists 
            the $LATEST versions of all functions using the runtime. To see a full list of affected function versions, use Trusted Advisor or see Retrieve data about Lambda functions that use a deprecated runtime. 
          Lambda sends email notification to your AWS account's primary account contact. For information about 
            viewing or updating the email addresses in your account, see Updating contact information in the AWS General Reference.
        
          Receiving notifications through the AWS Health Dashboard:
          The AWS Health Dashboard displays a notification at least 180 days before a runtime is deprecated. Notifications 
            appear on the Your account health page under Other notifications. 
            The Affected resources tab of the notification lists the $LATEST versions of all functions using the runtime.
          NoteTo see a full and up-to-date list of affected function versions, use Trusted Advisor or see Retrieve data about Lambda functions that use a deprecated runtime.
          AWS Health Dashboard notifications expire 90 days after the affected runtime is deprecated.
        
          Using AWS Trusted Advisor
          Trusted Advisor displays a notification at least 180 days before a runtime is deprecated. Notifications appear on the 
            Security page. A list of your affected functions is displayed under 
            AWS Lambda Functions Using Deprecated Runtimes. This list of functions shows both $LATEST and published versions and 
            updates automatically to reflect your functions' current status.
          You can turn on weekly email notifications from Trusted Advisor in the Preferences 
            page of the Trusted Advisor console.
        
     
      Deprecated runtimes
      The following runtimes have reached end of support:
      
      
        Name
        Identifier
        Operating system
        Deprecation date
        Block function create
        Block function update
      
    
            
        
          .NET 6
        
        
          dotnet6
        
        
          Amazon Linux 2
        
        
                      Dec 20, 2024
            
        
        
                      Oct 1, 2025
            
        
        
                      Nov 1, 2025
            
        
      
            
        
          Python 3.8
        
        
          python3.8
        
        
          Amazon Linux 2
        
        
                      Oct 14, 2024
            
        
        
                      Oct 1, 2025
            
        
        
                      Nov 1, 2025
            
        
      
            
        
          Node.js 16
        
        
          nodejs16.x
        
        
          Amazon Linux 2
        
        
                      Jun 12, 2024
            
        
        
                      Oct 1, 2025
            
        
        
                      Nov 1, 2025
            
        
      
            
        
          .NET 7 (container only)
        
        
          dotnet7
        
        
          Amazon Linux 2
        
        
                      May 14, 2024
            
        
        
          
            N/A
            
        
        
          
            N/A
            
        
      
            
        
          Java 8
        
        
          java8
        
        
          Amazon Linux
        
        
                      Jan 8, 2024
            
        
        
                      Feb 8, 2024
            
        
        
                      Nov 1, 2025
            
        
      
            
        
          Go 1.x
        
        
          go1.x
        
        
          Amazon Linux
        
        
                      Jan 8, 2024
            
        
        
                      Feb 8, 2024
            
        
        
                      Nov 1, 2025
            
        
      
            
        
          OS-only Runtime
        
        
          provided
        
        
          Amazon Linux
        
        
                      Jan 8, 2024
            
        
        
                      Feb 8, 2024
            
        
        
                      Nov 1, 2025
            
        
      
            
        
          Ruby 2.7
        
        
          ruby2.7
        
        
          Amazon Linux 2
        
        
                      Dec 7, 2023
            
        
        
                      Jan 9, 2024
            
        
        
                      Nov 1, 2025
            
        
      
            
        
          Node.js 14
        
        
          nodejs14.x
        
        
          Amazon Linux 2
        
        
                      Dec 4, 2023
            
        
        
                      Jan 9, 2024
            
        
        
                      Nov 1, 2025
            
        
      
            
        
          Python 3.7
        
        
          python3.7
        
        
          Amazon Linux
        
        
                      Dec 4, 2023
            
        
        
                      Jan 9, 2024
            
        
        
                      Nov 1, 2025
            
        
      
            
        
          .NET Core 3.1
        
        
          dotnetcore3.1
        
        
          Amazon Linux 2
        
        
                      Apr 3, 2023
            
        
        
                      Apr 3, 2023
            
        
        
                      May 3, 2023
            
        
      
            
        
          Node.js 12
        
        
          nodejs12.x
        
        
          Amazon Linux 2
        
        
                      Mar 31, 2023
            
        
        
                      Mar 31, 2023
            
        
        
                      Apr 30, 2023
            
        
      
            
        
          Python 3.6
        
        
          python3.6
        
        
          Amazon Linux
        
        
                      Jul 18, 2022
            
        
        
                      Jul 18, 2022
            
        
        
                      Aug 29, 2022
            
        
      
            
        
          .NET 5 (container only)
        
        
          dotnet5.0
        
        
          Amazon Linux 2
        
        
                      May 10, 2022
            
        
        
          
            N/A
            
        
        
          
            N/A
            
        
      
            
        
          .NET Core 2.1
        
        
          dotnetcore2.1
        
        
          Amazon Linux
        
        
                      Jan 5, 2022
            
        
        
                      Jan 5, 2022
            
        
        
                      Apr 13, 2022
            
        
      
            
        
          Node.js 10
        
        
          nodejs10.x
        
        
          Amazon Linux 2
        
        
                      Jul 30, 2021
            
        
        
                      Jul 30, 2021
            
        
        
                      Feb 14, 2022
            
        
      
            
        
          Ruby 2.5
        
        
          ruby2.5
        
        
          Amazon Linux
        
        
                      Jul 30, 2021
            
        
        
                      Jul 30, 2021
            
        
        
                      Mar 31, 2022
            
        
      
            
        
          Python 2.7
        
        
          python2.7
        
        
          Amazon Linux
        
        
                      Jul 15, 2021
            
        
        
                      Jul 15, 2021
            
        
        
                      May 30, 2022
            
        
      
            
        
          Node.js 8.10
        
        
          nodejs8.10
        
        
          Amazon Linux
        
        
                      Mar 6, 2020
            
        
        
                      Feb 4, 2020
            
        
        
                      Mar 6, 2020
            
        
      
            
        
          Node.js 4.3
        
        
          nodejs4.3
        
        
          Amazon Linux
        
        
                      Mar 5, 2020
            
        
        
                      Feb 3, 2020
            
        
        
                      Mar 5, 2020
            
        
      
            
        
          Node.js 4.3 edge
        
        
          nodejs4.3-edge
        
        
          Amazon Linux
        
        
                      Mar 5, 2020
            
        
        
                      Mar 31, 2019
            
        
        
                      Apr 30, 2019
            
        
      
            
        
          Node.js 6.10
        
        
          nodejs6.10
        
        
          Amazon Linux
        
        
                      Aug 12, 2019
            
        
        
                      Jul 12, 2019
            
        
        
                      Aug 12, 2019
            
        
      
            
        
          .NET Core 1.0
        
        
          dotnetcore1.0
        
        
          Amazon Linux
        
        
                      Jun 27, 2019
            
        
        
                      Jun 30, 2019
            
        
        
                      Jul 30, 2019
            
        
      
            
        
          .NET Core 2.0
        
        
          dotnetcore2.0
        
        
          Amazon Linux
        
        
                      May 30, 2019
            
        
        
                      Apr 30, 2019
            
        
        
                      May 30, 2019
            
        
      
            
        
          Node.js 0.10
        
        
          nodejs
        
        
          Amazon Linux
        
        
                      Aug 30, 2016
            
        
        
                      Sep 30, 2016
            
        
        
                      Oct 31, 2016
            
        
      
          
      
      In almost all cases, the end-of-life date of a language version or operating system is known well in advance.
        The following links give end-of-life schedules for each language that Lambda supports as a managed runtime.
      
      
        Language and framework support policies
         
         
         
         
         
         
      
          Node.js – github.com
        
          Python – devguide.python.org
        
          Ruby – www.ruby-lang.org
        
          Java – www.oracle.com and Corretto FAQs
        
          Go – golang.org
        
          .NET – dotnet.microsoft.com
        
    Document ConventionsUsing the AWS CDKRuntime version updatesDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideUnderstanding X-Ray tracesDefault tracing behavior in LambdaExecution role permissionsEnabling Active tracing with the Lambda APIEnabling Active tracing with AWS CloudFormationVisualize Lambda function invocations using AWS X-RayYou can use AWS X-Ray to visualize the components of your application, identify performance
    bottlenecks, and troubleshoot requests that resulted in an error. Your Lambda functions send
    trace data to X-Ray, and X-Ray processes the data to generate a service map and searchable
    trace summaries.Lambda supports two tracing modes for X-Ray: Active and
      PassThrough. With Active tracing, Lambda automatically creates trace
    segments for function invocations and sends them to X-Ray. PassThrough mode, on
    the other hand, simply propagates the tracing context to downstream services. If you've enabled
      Active tracing for your function, Lambda automatically sends traces to X-Ray for
    sampled requests. Typically, an upstream service, such as Amazon API Gateway or an application hosted on
    Amazon EC2 that is instrumented with the X-Ray SDK, decides whether incoming requests should be
    traced, then adds that sampling decision as a tracing header. Lambda uses that header to decide
    to send traces or not. Traces from upstream message producers, such as Amazon SQS, are automatically
    linked to traces from downstream Lambda functions, creating an end-to-end view of the entire
    application. For more information, see Tracing event-driven applications
    in the AWS X-Ray Developer Guide.NoteX-Ray tracing is currently not supported for Lambda functions with Amazon Managed Streaming for Apache Kafka (Amazon MSK), self-managed Apache Kafka, Amazon MQ
    with ActiveMQ and RabbitMQ, or Amazon DocumentDB event source mappings.To toggle active tracing on your Lambda function with the console, follow these steps:To turn on active tracingOpen the Functions page of the Lambda console.
      Choose a function.
    Choose Configuration and then choose Monitoring and operations tools.Under Additional monitoring tools, choose Edit.
      Under CloudWatch Application Signals and AWS X-Ray, choose Enable for Lambda service traces.
    
      Choose Save.
    Your function needs permission to upload trace data to X-Ray. When you activate tracing in the Lambda
    console, Lambda adds the required permissions to your function's execution role. Otherwise, add the AWSXRayDaemonWriteAccess policy to the execution role.X-Ray doesn't trace all requests to your application. X-Ray applies a sampling algorithm
    to ensure that tracing is efficient, while still providing a representative sample of all requests. The sampling rate is
    1 request per second and 5 percent of additional requests. You can't configure the X-Ray sampling rate for your functions.
    Understanding X-Ray traces
    In X-Ray, a trace records information about a request that is processed by one or more 
      services. Lambda records 2 segments per trace, which creates
      two nodes on the service graph. The following image highlights these two nodes:
    
       
        
       
       
    
    The first node on the left represents the Lambda service, which receives the invocation request. The second
      node represents your specific Lambda function.
    The segment recorded for the Lambda service, AWS::Lambda, covers all the steps required to prepare the Lambda execution 
      environment. This includes scheduling the MicroVM, creating or unfreezing an execution environment with the resources you have configured,
      as well as downloading your function code and all layers.
    The AWS::Lambda::Function segment is for the work done by the function.
    NoteAWS is currently implementing changes to the Lambda service. Due to these changes, you may see minor differences between the structure and content 
of system log messages and trace segments emitted by different Lambda functions in your AWS account.This change affects the subsegments of the function segment. The  following paragraphs describe both the old and new formats for these subsegments.These changes will be implemented during the coming weeks, and all functions in all 
AWS Regions except the China and GovCloud regions will transition to use the new-format log messages and trace segments. 
     
      Old-style AWS X-Ray Lambda segment structure 
      The old-style X-Ray structure for the AWS::Lambda segment looks like the following:
     
    
       
         
       
       
    
    In this format, the function segment has subsegments for Initialization, Invocation, and 
      Overhead. For Lambda SnapStart only, there is also a Restore subsegment 
      (not shown on this diagram). 
    The Initialization subsegment represents the init phase of the Lambda execution environment lifecycle. 
      During this phase, Lambda initializes extensions, initializes the runtime, and runs the function's initialization code.
    The Invocation subsegment represents the invoke phase where Lambda invokes the function handler. This begins 
      with runtime and extension registration and it ends when the runtime is ready to send the response.
    (Lambda SnapStart only) The Restore subsegment shows the time it takes for Lambda to restore a snapshot, load the 
      runtime, and run any after-restore runtime hooks. The process of restoring snapshots can include time spent on 
      activities outside the MicroVM. This time is reported in the Restore subsegment. You aren't charged for the time spent 
      outside the microVM to restore a snapshot.
    The Overhead subsegment represents the phase that occurs between the time when the runtime sends the response and 
      the signal for the next invoke. During this time, the runtime finishes all tasks related to an invoke and prepares to freeze the sandbox.
    ImportantYou can use the X-Ray SDK to extend the Invocation subsegment with additional
        subsegments for downstream calls, annotations, and metadata. You can't access the function segment directly or
        record work done outside of the handler invocation scope.
    
    For more information about Lambda execution environment phases, see Understanding the Lambda execution environment lifecycle.
    An example trace using the old-style X-Ray structure is shown in the following diagram.
    
       
         
       
       
    
    Note the two segments in the example. Both are named my-function, but one has an origin of AWS::Lambda 
      and the other has an origin of AWS::Lambda::Function. If the AWS::Lambda segment shows an error, the Lambda service 
      had an issue. If the AWS::Lambda::Function segment shows an error, your function had an issue.
    NoteOccasionally, you may notice a large gap between the function initialization and invocation phases
      in your X-Ray traces. For functions using provisioned concurrency,
      this is because Lambda initializes your function instances well in advance of invocation. For functions using
      unreserved (on-demand) concurrency, Lambda may proactively initialize
      a function instance, even if there's no invocation. Visually, both of these cases show up as a time gap between
      the initialization and invocation phases.
    
     
      New-style AWS X-Ray Lambda segment structure 
      The new-style X-Ray structure for the AWS::Lambda segment looks like the following:
     
    
       
         
       
       
    
    In this new format, The Init subsegment represents the init phase of the Lambda execution 
      environment lifecycle as before.
    There is no invocation segment in the new format. Instead, customer subsegments are attached directly to the 
      AWS::Lambda::Function segment. This segment contains the following metrics as annotations:
    
       
       
       
       
    
        aws.responseLatency - the time taken for the function to run
      
        aws.responseDuration - the time taken to transfer the response to the customer
      
        aws.runtimeOverhead - the amount of additional time the runtime needed to finish
      
        aws.extensionOverhead - the amount of additional time the extensions needed to finish
      
    An example trace using the new-style X-Ray structure is shown in the following diagram.
    
       
         
       
       
    
    Note the two segments in the example. Both are named my-function, but one has an origin of AWS::Lambda 
      and the other has an origin of AWS::Lambda::Function. If the AWS::Lambda segment shows an error, the Lambda service 
      had an issue. If the AWS::Lambda::Function segment shows an error, your function had an issue.
    
    
    
    
    See the following topics for a language-specific introduction to tracing in Lambda:
    
      
       
      
       
      
       
      
       
      
       
      
       
    
        Instrumenting Node.js code in AWS Lambda
      
        Instrumenting Python code in AWS Lambda
      
        Instrumenting Ruby code in AWS Lambda
      
        Instrumenting Java code in AWS Lambda
      
        Instrumenting Go code in AWS Lambda
      
        Instrumenting C# code in AWS Lambda
      
    For a full list of services that support active instrumentation, see Supported AWS services in the
      AWS X-Ray Developer Guide.
   
    Default tracing behavior in Lambda
    If you do not have Active tracing turned on, Lambda defaults to PassThrough
      tracing mode.
    In PassThrough mode, Lambda forwards the X-Ray tracing header to downstream
      services, but does not send traces automatically. This is true even if the tracing header
      contains a decision to sample the request. If the upstream service does not provide an X-Ray
      tracing header, Lambda generates a header and makes the decision not to sample. However, you
      can send your own traces by calling tracing libraries from your function code. 
    Note Previously, Lambda would send traces automatically when upstream services, such as Amazon API Gateway, added a
        tracing header. By not sending traces automatically, Lambda gives you the control to trace the functions that are
        important to you. If your solution depends on this passive tracing behavior, switch to Active tracing. 
   
    Execution role permissions
    Lambda needs the following permissions to send trace data to X-Ray. Add them to your function's execution role.
    
       
       
    
        xray:PutTraceSegments
      
        xray:PutTelemetryRecords
      
    These permissions are included in the AWSXRayDaemonWriteAccess managed policy.
   
    Enabling Active tracing with the Lambda API
    
    To manage tracing configuration with the AWS CLI or AWS SDK, use the following API operations:
     
       
       
       
    UpdateFunctionConfigurationGetFunctionConfigurationCreateFunction
     The following example AWS CLI command enables active tracing on a function named
    my-function.
    aws lambda update-function-configuration --function-name my-function \
--tracing-config Mode=Active
    Tracing mode is part of the version-specific configuration when you publish a version of your function.
    You can't change the tracing mode on a published version.
    
   
    Enabling Active tracing with AWS CloudFormation
     To activate tracing on an AWS::Lambda::Function resource in an AWS CloudFormation template, use the
        TracingConfig property.
    Example function-inline.yml –
        Tracing configurationResources:
  function:
    Type: AWS::Lambda::Function
    Properties:
      TracingConfig:
        Mode: Active
      ...
    For an AWS Serverless Application Model (AWS SAM) AWS::Serverless::Function resource, use the Tracing
      property.
    Example template.yml – Tracing
        configurationResources:
  function:
    Type: AWS::Serverless::Function
    Properties:
      Tracing: Active
      ...
    
  Document ConventionsCloudTrail logsFunction insightsDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideNext invocationInvocation responseInitialization errorInvocation errorUsing the Lambda runtime API for custom runtimesAWS Lambda provides an HTTP API for custom runtimes to receive invocation
    events from Lambda and send response data back within the Lambda execution
      environment. This section contains the API reference for the Lambda runtime API.
     
      
     
     
  The OpenAPI specification for the runtime API version 2018-06-01 is available
    in runtime-api.zipTo create an API request URL, runtimes get the API endpoint from the AWS_LAMBDA_RUNTIME_API environment variable, add the API version,
    and add the desired resource path.Example Requestcurl "http://${AWS_LAMBDA_RUNTIME_API}/2018-06-01/runtime/invocation/next"API methodsNext invocationInvocation responseInitialization errorInvocation error
    Next invocation
    Path – /runtime/invocation/next
    Method – GET
    The runtime sends this message to Lambda to request an invocation event. The response body contains the payload
      from the invocation, which is a JSON document that contains event data from the function trigger. The response
      headers contain additional data about the invocation.
    
      Response headers
       
       
       
       
       
       
    
        Lambda-Runtime-Aws-Request-Id – The request ID, which identifies the request that
          triggered the function invocation.
        For example, 8476a536-e9f4-11e8-9739-2dfe598c3fcd.
      
        Lambda-Runtime-Deadline-Ms – The date that the function times out in Unix time
          milliseconds. 
        For example, 1542409706888.
      
        Lambda-Runtime-Invoked-Function-Arn – The ARN of the Lambda function, version, or alias
          that's specified in the invocation. 
        For example, arn:aws:lambda:us-east-2:123456789012:function:custom-runtime.
      
        Lambda-Runtime-Trace-Id – The AWS X-Ray tracing header. 
        For example,
          Root=1-5bef4de7-ad49b0e87f6ef6c87fc2e700;Parent=9a9197af755a6419;Sampled=1.
      
        Lambda-Runtime-Client-Context – For invocations from the AWS Mobile SDK, data about
          the client application and device.
      
        Lambda-Runtime-Cognito-Identity – For invocations from the AWS Mobile SDK, data about
          the Amazon Cognito identity provider.
      
    
    Do not set a timeout on the GET request as the response may be delayed. Between when Lambda bootstraps the runtime and
      when the runtime has an event to return, the runtime process may be frozen for several seconds.
    
    The request ID tracks the invocation within Lambda. Use it to specify the invocation when you send the
      response.
    
    The tracing header contains the trace ID, parent ID, and sampling decision. If the request is sampled, the
      request was sampled by Lambda or an upstream service. The runtime should set the _X_AMZN_TRACE_ID with
      the value of the header. The X-Ray SDK reads this to get the IDs and determine whether to trace the
      request.
   
    Invocation response
    Path –
          /runtime/invocation/AwsRequestId/response
    Method – POST
    After the function has run to completion, the runtime sends an invocation response to Lambda.  For synchronous
      invocations, Lambda sends the response to the client.
    Example success requestREQUEST_ID=156cb537-e2d4-11e8-9b34-d36013741fb9
curl "http://${AWS_LAMBDA_RUNTIME_API}/2018-06-01/runtime/invocation/$REQUEST_ID/response"  -d "SUCCESS"
   
    Initialization error
    If the function returns an error or the runtime encounters an error during initialization, the runtime uses
      this method to report the error to Lambda.
    Path – /runtime/init/error
    Method – POST
    Headers
    Lambda-Runtime-Function-Error-Type – Error type that the runtime encountered. Required:
      no. 
    
  This header consists of a string value. Lambda accepts any string, but we recommend a format of
    <category.reason>. For example:
    
       
       
       
       
    Runtime.NoSuchHandlerRuntime.APIKeyNotFoundRuntime.ConfigInvalidRuntime.UnknownReason   

    Body parameters
    ErrorRequest – Information about the error.
      Required: no. 
    
    This field is a JSON object with the following structure:
    {
      errorMessage: string (text description of the error),
      errorType: string,
      stackTrace: array of strings
}    
Note that Lambda accepts any value for errorType.  
 The following example shows a Lambda function error message in which the function could not parse the event data
    provided in the invocation.
    Example Function error{
      "errorMessage" : "Error parsing event data.",
      "errorType" : "InvalidEventDataException",
      "stackTrace": [ ]
}      

    
        Response body parameters
         
         
    StatusResponse – String. Status information, sent with 202 response codes. ErrorResponse – Additional error information, sent with the error response codes.
          ErrorResponse contains an error type and an error message.
    
      Response codes
       
       
       
    
        202 – Accepted
      
        403 – Forbidden
      
        500 – Container error. Non-recoverable state. Runtime should exit promptly.
      
    Example initialization error requestERROR="{\"errorMessage\" : \"Failed to load function.\", \"errorType\" : \"InvalidFunctionException\"}"
curl "http://${AWS_LAMBDA_RUNTIME_API}/2018-06-01/runtime/init/error" -d "$ERROR" --header "Lambda-Runtime-Function-Error-Type: Unhandled"
   
    Invocation error
    If the function returns an error or the runtime encounters an error, the runtime uses this method to report
      the error to Lambda.
    Path –
      /runtime/invocation/AwsRequestId/error
    Method – POST
    Headers
    Lambda-Runtime-Function-Error-Type – Error type that the runtime encountered. Required:
      no. 
    
  This header consists of a string value. Lambda accepts any string, but we recommend a format of
    <category.reason>. For example:
    
       
       
       
       
    Runtime.NoSuchHandlerRuntime.APIKeyNotFoundRuntime.ConfigInvalidRuntime.UnknownReason   

    Body parameters
    ErrorRequest – Information about the error.
      Required: no. 
    
    This field is a JSON object with the following structure:
    {
      errorMessage: string (text description of the error),
      errorType: string,
      stackTrace: array of strings
}    
Note that Lambda accepts any value for errorType.  
 The following example shows a Lambda function error message in which the function could not parse the event data
    provided in the invocation.
    Example Function error{
      "errorMessage" : "Error parsing event data.",
      "errorType" : "InvalidEventDataException",
      "stackTrace": [ ]
}      

    
      Response body parameters
       
       
    StatusResponse – String. Status information, sent with 202 response codes. ErrorResponse – Additional error information, sent with the error response codes.
       ErrorResponse contains an error type and an error message.
    
      Response codes
       
       
       
       
    
        202 – Accepted
      
        400 – Bad Request
      
        403 – Forbidden
      
        500 – Container error. Non-recoverable state. Runtime should exit promptly.
      
    Example error requestREQUEST_ID=156cb537-e2d4-11e8-9b34-d36013741fb9
ERROR="{\"errorMessage\" : \"Error parsing event data.\", \"errorType\" : \"InvalidEventDataException\"}"
curl "http://${AWS_LAMBDA_RUNTIME_API}/2018-06-01/runtime/invocation/$REQUEST_ID/error" -d "$ERROR" --header "Lambda-Runtime-Function-Error-Type: Unhandled"
  Document ConventionsRuntime modificationsOS-only runtimesDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationReference GuideSupport by AWS SDKs and toolsAWS RegionNoteFor help in understanding the layout of settings pages, or in interpreting the Support by AWS SDKs and tools
            table that follows, see Understanding the settings pages of this guide.AWS Regions are an important concept to understand when working with AWS services. With AWS Regions, you can access AWS services that physically reside in a specific
        geographic area. This can be useful to keep your data and applications running close to
        where you and your users will access them. Regions provide fault tolerance, stability, and
        resilience, and can also reduce latency. With Regions, you can create redundant resources
        that remain available and unaffected by a Regional outage.Most AWS service requests are associated with a particular geographic region. The
        resources that you create in one Region do not exist in any other Region unless you
        explicitly use a replication feature offered by an AWS service. For example, Amazon S3 and
        Amazon EC2 support cross-Region replication. Some services, such as IAM, do not have Regional
        resources.The AWS General Reference contains information on the following:
         
         


    
             To understand the relationship between Regions and endpoints, and to view a list
                of existing Regional endpoints, see AWS
                    service endpoints.
        
            To view the current list of all supported Regions and endpoints for each
                AWS service, see Service
                    endpoints and quotas.
        Creating service clientsTo programmatically access AWS services, SDKs use a client class/object for each
        AWS service. If your application needs to access Amazon EC2, for example, your application
        would create an Amazon EC2 client object to interface with that service.If no Region is explicitly specified for the client in the code itself, the client
        defaults to using the Region that is set through the following region setting.
        However, the active Region for a client can be explicitly set for any individual client
        object. Setting the Region in this way takes precedence over any global setting for that
        particular service client. The alternative Region is specified during instantiation of that
        client, specific to your SDK (check your specific SDK Guide or your SDK's code base).Configure this functionality by using the following:
         
    

            region - shared AWS config file setting
            AWS_REGION - environment variable
            aws.region - JVM system property: Java/Kotlin only
            

                Specifies the default AWS Region to use for AWS requests. This Region is
                    used for SDK service requests that aren't provided with a specific Region to
                    use.


                Default value: None. You must specify this
                    value explicitly.
                Valid values:
                
                
                     
                     
                
                        Any of the Region codes available for the chosen service, as listed in
                                AWS service endpoints
                            in the AWS General Reference. For
                            example, the value us-east-1 sets the endpoint to the
                            AWS Region US East (N. Virginia).
                    
                        aws-global specifies the global endpoint for services
                            that support a separate global endpoint in addition to Regional
                            endpoints, such as AWS Security Token Service (AWS STS) and Amazon Simple Storage Service (Amazon S3).
                    
            
        Example of setting this value in the config file:[default]
region = us-west-2Linux/macOS example of setting environment variables via command line:export AWS_REGION=us-west-2Windows example of setting environment variables via command line:setx AWS_REGION us-west-2Most SDKs have a "configuration" object that is available for setting the default Region
        from within the application code. For details, see your specific AWS SDK developer
        guide.
        Support by AWS SDKs and tools
        The following SDKs support the features and settings described in this topic. Any partial exceptions are noted. Any JVM system property settings are supported by the AWS SDK for Java and the AWS SDK for Kotlin only.
        
                    
                        SDK
                        Supported
                        Notes or more information
                    
                
                    
                        AWS CLI v2
                        Yes
                        AWS CLI v2 uses any value in AWS_REGION before any value
                            in AWS_DEFAULT_REGION (both variables are checked).
                    
                    
                        AWS CLI v1
                        Yes
                        AWS CLI v1 uses environment variable named
                                AWS_DEFAULT_REGION for this purpose.
                    
                    
                        SDK for C++
                        Yes
                        
                    
                    
                        SDK for Go V2 (1.x)
                        Yes
                        
                    
                    
                        SDK for Go 1.x (V1)
                        Yes
                        To use shared config file settings, you must turn on loading from the config file; see Sessions.
                    
                    
                        SDK for Java 2.x
                        Yes
                        
                    
                    
                        SDK for Java 1.x
                        Yes
                        
                    
                    
                        SDK for JavaScript 3.x
                        Yes
                        
                    
                    
                        SDK for JavaScript 2.x
                        Yes
                        
                    
                    
                        SDK for Kotlin
                        Yes
                        
                    
                    
                        SDK for .NET 3.x
                        Yes
                        
                    
                    
                        SDK for PHP 3.x
                        Yes
                        
                    
                    
                        SDK for Python (Boto3)
                        Yes
                        This SDK uses environment variable named
                                AWS_DEFAULT_REGION for this purpose.
                    
                    
                        SDK for Ruby 3.x
                        Yes
                        
                    
                    
                        SDK for Rust
                        Yes
                        
                    
                    
                        SDK for Swift
                        Yes
                        
                    
                    
                        Tools for PowerShell
                        Yes
                        
                    
                
    Document ConventionsAmazon S3 Multi-Region Access PointsAWS STS Regional
            endpointsDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideConfiguring provisioned concurrencyAccurately estimating required provisioned concurrency for a functionOptimizing function code when using provisioned concurrencyUsing environment variables to view and control provisioned concurrency behaviorUnderstanding logging and billing behavior with provisioned concurrencyUsing Application Auto Scaling to automate provisioned concurrency managementConfiguring provisioned concurrency for a functionIn Lambda, concurrency is the number of
    in-flight requests that your function is currently handling. There are two types
    of concurrency controls available:
     
     
  
      Reserved concurrency – This represents the maximum number of
        concurrent instances allocated to your function. When a function 
        has reserved concurrency, no other function can use that concurrency.
        Reserved concurrency is useful for ensuring that your most critical
        functions always have enough concurrency to handle incoming requests.
        Configuring reserved concurrency for a function incurs no additional charges.
    
      Provisioned concurrency – This is the number of pre-initialized
        execution environments allocated to your function. These execution environments
        are ready to respond immediately to incoming function requests. Provisioned
        concurrency is useful for reducing cold start latencies for functions. Configuring
        provisioned concurrency incurs additional charges to your AWS account.
    This topic details how to manage and configure provisioned concurrency. For a
    conceptual overview of these two types of concurrency controls, see
    
    Reserved concurrency and provisioned concurrency. For more information on
    configuring reserved concurrency, see Configuring reserved concurrency for a function.NoteLambda functions linked to an Amazon MQ event source mapping have a default maximum concurrency. For Apache Active MQ, 
the maximum number of concurrent instances is 5. For Rabbit MQ, the maximum number of concurrent instances is 1. Setting reserved or provisioned concurrency for your 
function doesn't change these limits. To request an increase in the default maximum concurrency when using Amazon MQ, contact Support.SectionsConfiguring provisioned concurrencyAccurately estimating required provisioned concurrency for a functionOptimizing function code when using provisioned concurrencyUsing environment variables to view and control provisioned concurrency behaviorUnderstanding logging and billing behavior with provisioned concurrencyUsing Application Auto Scaling to automate provisioned concurrency management
    Configuring provisioned concurrency
    You can configure provisioned concurrency settings for a function using the Lambda
      console or the Lambda API.
    To allocate provisioned concurrency for a function (console)Open the Functions page of the Lambda console.
        Choose the function you want to allocate provisioned concurrency for.
      
        Choose Configuration and then choose Concurrency.
      
        Under Provisioned concurrency configurations, choose
          Add configuration.
      
        Choose the qualifier type, and alias or version.
        NoteYou cannot use provisioned concurrency with the $LATEST version of any function.If your function has an event source, make sure that event source points to the correct
            function alias or version. Otherwise, your function won't use provisioned concurrency environments.
      
        Enter a number under Provisioned concurrency.
      
        Choose Save.
      
    You can configure up to the Unreserved account concurrency in your
      account, minus 100. The remaining 100 units of concurrency are for functions that aren't using
      reserved concurrency. For example, if your account has a concurrency limit of 1,000, and you
      haven't assigned any reserved or provisioned concurrency to any of your other functions, you can
      configure a maximum of 900 provisioned concurrency units for a single function.
    
       
        
       
       
    
    Configuring provisioned concurrency for a function has an impact on the concurrency pool
      available to other functions. For instance, if you configure 100 units of provisioned concurrency
      for function-a, other functions in your account must share the remaining 900 units
      of concurrency. This is true even if function-a doesn't use all 100 units.
    It's possible to allocate both reserved concurrency and provisioned concurrency for the
      same function. In such cases, the provisioned concurrency cannot exceed the reserved
      concurrency.
    This limitation extends to function versions. The maximum provisioned concurrency you can
      assign to a specific function version is the function's reserved concurrency minus the
      provisioned concurrency on other function versions.
    To configure provisioned concurrency with the Lambda API, use the following API operations.
    
       
       
       
       
    
        PutProvisionedConcurrencyConfig
      
        GetProvisionedConcurrencyConfig
      
        ListProvisionedConcurrencyConfigs
      
        DeleteProvisionedConcurrencyConfig
      
    For example, to configure provisioned concurrency with the AWS Command Line Interface (CLI), use the
      put-provisioned-concurrency-config command. The following command allocates
      100 units of provisioned concurrency for the BLUE alias of a function named
      my-function:
    aws lambda put-provisioned-concurrency-config --function-name my-function \
  --qualifier BLUE \
  --provisioned-concurrent-executions 100
    You should see output that looks like the following:
    {
  "Requested ProvisionedConcurrentExecutions": 100,
  "Allocated ProvisionedConcurrentExecutions": 0,
  "Status": "IN_PROGRESS",
  "LastModified": "2023-01-21T11:30:00+0000"
}
   
    Accurately estimating required provisioned concurrency for a function
    You can view any active function's concurrency metrics using CloudWatch metrics.
      Specifically, the ConcurrentExecutions metric shows you the number of
      concurrent invocations for functions in your account.
    
       
        
       
       
    
    The previous graph suggests that this function serves an average of 5 to 10
      concurrent requests at any given time, and peaks at 20 requests.
      Suppose that there are many other functions in your account. 
      If this function is critical to your application and you need a low-latency response
      on every invocation, configure at least 20 units of provisioned concurrency.
    Recall that you can also 
      calculate concurrency using the following formula:
    Concurrency = (average requests per second) * (average request duration in seconds)
    To estimate how much concurrency you need, multiply average requests per
      second with the average request duration in seconds. You can estimate average
      requests per second using the Invocation metric, and the average
      request duration in seconds using the Duration
      metric.
    When configuring provisioned concurrency, Lambda suggests adding a 10% buffer
      on top of the amount of concurrency your function typically needs. For example,
      if your function usually peaks at 200 concurrent requests, set the provisioned
      concurrency to 220 (200 concurrent requests + 10% = 220 provisioned concurrency).
   
    Optimizing function code when using provisioned concurrency
    If you're using provisioned concurrency, consider restructuring your function
      code to optimize for low latency. For functions using provisioned concurrency,
      Lambda runs any initialization code, such as loading libraries and instantiating
      clients, during allocation time. Therefore, it's advisable to move as much
      initialization outside of the main function handler to avoid impacting latency
      during actual function invocations. In contrast, initializing libraries or
      instantiating clients within your main handler code means your function must run
      this each time it's invoked (this occurs regardless of whether you're using
      provisioned concurrency).
    For on-demand invocations, Lambda may need to rerun your initialization code every time
      your function experiences a cold start. For such functions, you may choose to defer
      initialization of a specific capability until your function needs it. For example,
      consider the following control flow for a Lambda handler:
    def handler(event, context):
    ...
    if ( some_condition ):
        // Initialize CLIENT_A to perform a task
    else:
        // Do nothing
    In the previous example, instead of initializing CLIENT_A outside
      of the main handler, the developer initialized it within the if
      statement. By doing this, Lambda runs this code only if some_condition is
      met. If you initialize CLIENT_A outside the main handler,
      Lambda runs that code on every cold start. This can increase overall latency.
   
    Using environment variables to view and control provisioned concurrency behavior
    It's possible for your function to use up all of its provisioned concurrency.
      Lambda uses on-demand instances to handle any excess traffic. To determine the type
      of initialization Lambda used for a specific environment, check
      the value of the AWS_LAMBDA_INITIALIZATION_TYPE environment variable.
      This variable has two possible values: provisioned-concurrency or
      on-demand. The value of AWS_LAMBDA_INITIALIZATION_TYPE is
      immutable and remains constant throughout the lifetime of the environment. To check
      the value of an environment variable in your function code, see
      Retrieving Lambda environment variables.
    If you're using the .NET 8 runtime, you can configure the
      AWS_LAMBDA_DOTNET_PREJIT environment variable to improve the latency for
      functions, even if they don't use provisioned concurrency. The .NET runtime employs lazy
      compilation and initialization for each library that your code calls for the first time.
      As a result, the first invocation of a Lambda function may take longer than subsequent
      ones. To mitigate this, you can choose one of three values for
      AWS_LAMBDA_DOTNET_PREJIT:
    
       
       
       
    
        ProvisionedConcurrency: Lambda performs ahead-of-time JIT
          compilation for all environments using provisioned concurrency. This is the
          default value.
      
        Always: Lambda performs ahead-of-time JIT compilation for every
          environment, even if the function doesn't use provisioned concurrency.
      
        Never: Lambda disables ahead-of-time JIT compilation for all
          environments.
      
   
    Understanding logging and billing behavior with provisioned concurrency
    For provisioned concurrency environments, your function's initialization code
      runs during allocation, and periodically as Lambda recycles instances
      of your environment. Lambda bills you for initialization even if the environment
      instance never processes a request. Provisioned concurrency runs continually
      and incurs separate billing from initialization and invocation costs. For more
      details, see AWS Lambda Pricing.
    When you configure a Lambda function with provisioned concurrency, Lambda
      pre-initializes that execution environment so that it's available ahead of
      invocation requests. Lambda logs the 
      Init Duration field of the function in a 
      platform-initReport log event in JSON logging format every time the environment
      is initialized. To see this log event, configure your
      JSON log level to at least
      INFO. You can also use the Telemetry
      API to consume platform events where the Init Duration field is reported.
   
    Using Application Auto Scaling to automate provisioned concurrency management
    You can use Application Auto Scaling to manage provisioned concurrency on a schedule or based
      on utilization. If your function receives predictable traffic patterns, use scheduled
      scaling. If you want your function to maintain a specific utilization
      percentage, use a target tracking scaling policy.
    NoteIf you use Application Auto Scaling to manage your function's provisioned concurrency, ensure
        that you configure an initial
        provisioned concurrency value first. If your function doesn't have an initial
        provisioned concurrency value, Application Auto Scaling may not handle function scaling properly.
     
      Scheduled scaling
      With Application Auto Scaling, you can set your own scaling schedule according to predictable
        load changes. For more information and examples, see 
        Scheduled scaling for Application Auto Scaling in the Application Auto Scaling User Guide, and
        
        Scheduling AWS Lambda Provisioned Concurrency for recurring peak usage on the
        AWS Compute Blog.
     
     
      Target tracking
      With target tracking, Application Auto Scaling creates and manages a set of CloudWatch alarms
        based on how you define your scaling policy. When these alarms activate,
        Application Auto Scaling automatically adjusts the amount of environments allocated using
        provisioned concurrency. Use target tracking for applications that don't have
        predictable traffic patterns.
      To scale provisioned concurrency using target tracking, use the
        RegisterScalableTarget and PutScalingPolicy
        Application Auto Scaling API operations. For example, if you're using the AWS Command Line Interface (CLI),
        follow these steps:
      
          Register a function's alias as a scaling target. The following example
            registers the BLUE alias of a function named my-function:
            aws application-autoscaling register-scalable-target --service-namespace lambda \
    --resource-id function:my-function:BLUE --min-capacity 1 --max-capacity 100 \
    --scalable-dimension lambda:function:ProvisionedConcurrency
        
          Apply a scaling policy to the target. The following example configures
            Application Auto Scaling to adjust the provisioned concurrency configuration for an alias
            to keep utilization near 70 percent, but you can apply any value between
            10% and 90%.
          aws application-autoscaling put-scaling-policy \
    --service-namespace lambda \
    --scalable-dimension lambda:function:ProvisionedConcurrency \
    --resource-id function:my-function:BLUE \
    --policy-name my-policy \
    --policy-type TargetTrackingScaling \
    --target-tracking-scaling-policy-configuration '{ "TargetValue": 0.7, "PredefinedMetricSpecification": { "PredefinedMetricType": "LambdaProvisionedConcurrencyUtilization" }}'
        
      You should see output that looks like this:
      {
    "PolicyARN": "arn:aws:autoscaling:us-east-2:123456789012:scalingPolicy:12266dbb-1524-xmpl-a64e-9a0a34b996fa:resource/lambda/function:my-function:BLUE:policyName/my-policy",
    "Alarms": [
        {
            "AlarmName": "TargetTracking-function:my-function:BLUE-AlarmHigh-aed0e274-xmpl-40fe-8cba-2e78f000c0a7",
            "AlarmARN": "arn:aws:cloudwatch:us-east-2:123456789012:alarm:TargetTracking-function:my-function:BLUE-AlarmHigh-aed0e274-xmpl-40fe-8cba-2e78f000c0a7"
        },
        {
            "AlarmName": "TargetTracking-function:my-function:BLUE-AlarmLow-7e1a928e-xmpl-4d2b-8c01-782321bc6f66",
            "AlarmARN": "arn:aws:cloudwatch:us-east-2:123456789012:alarm:TargetTracking-function:my-function:BLUE-AlarmLow-7e1a928e-xmpl-4d2b-8c01-782321bc6f66"
        }
    ]
}
      Application Auto Scaling creates two alarms in CloudWatch. The first alarm triggers when the
        utilization of provisioned concurrency consistently exceeds 70%. When this
        happens, Application Auto Scaling allocates more provisioned concurrency to reduce
        utilization. The second alarm triggers when utilization is consistently
        less than 63% (90 percent of the 70% target). When this happens, Application Auto Scaling
        reduces the alias's provisioned concurrency.
      NoteLambda emits the ProvisionedConcurrencyUtilization metric only
          when your function is active and receiving requests. During periods of inactivity,
          no metrics are emitted, and your auto-scaling alarms will enter the
          INSUFFICIENT_DATA state. As a result, Application Auto Scaling won't be able
          to adjust your function's provisioned concurrency. This may lead to unexpected
          billing.
      In the following example, a function scales between a minimum and
        maximum amount of provisioned concurrency based on utilization.
      
         
          
         
         
      
      
        Legend
         
         
         
         
      
          
             
              
             
             
           Function instances
        
          
             
              
             
             
           Open requests
        
          
             
              
             
             
           Provisioned concurrency
        
          
             
              
             
             
           Standard concurrency
        
      When the number of open requests increase, Application Auto Scaling increases provisioned
        concurrency in large steps until it reaches the configured maximum. After this,
        the function can continue to scale on standard, unreserved concurrency if you
        haven't reached your account concurrency limit. When utilization drops and stays
        low, Application Auto Scaling decreases provisioned concurrency in smaller periodic steps.
      Both of the Application Auto Scaling alarms use the average statistic by default.
        Functions that experience quick bursts of traffic may not trigger
        these alarms. For example, suppose your Lambda function executes quickly
        (i.e. 20-100 ms) and your traffic comes in quick bursts. In this case,
        the number of requests exceeds the allocated provisioned concurrency during the
        burst. However, Application Auto Scaling requires the burst load to sustain for at least 3 minutes
        in order to provision additional environments. Additionally, both CloudWatch alarms require 3
        data points that hit the target average to activate the auto scaling policy. If your
        function experiences quick bursts of traffic, using the
        Maximum statistic instead of the
        Average statistic can be more effective at
        scaling provisioned concurrency to minimize cold starts.
      For more information on target tracking scaling policies, see
        
        Target tracking scaling policies for Application Auto Scaling.
     
  Document ConventionsConfiguring reserved concurrencyScaling behaviorDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideCreating an execution role in the IAM consoleCreating and managing roles with the AWS CLIGrant least privilege access to your Lambda execution roleDefining Lambda function permissions with an execution roleA Lambda function's execution role is an AWS Identity and Access Management (IAM) role that grants the function permission to access
    AWS services and resources. For example, you might create an execution role that has permission to send logs to
    Amazon CloudWatch and upload trace data to AWS X-Ray. This page provides information on how to create, view, and manage a
    Lambda function's execution role.Lambda automatically assumes your execution role when you invoke your function. You should avoid manually
    calling sts:AssumeRole to assume the execution role in your function code. If your use case requires
    that the role assumes itself, you must include the role itself as a trusted principal in your role's trust policy.
    For more information on how to modify a role trust policy, see 
    Modifying a role trust policy (console) in the IAM User Guide.In order for Lambda to properly assume your execution role, the role's
    trust policy must specify the Lambda service principal
    (lambda.amazonaws.com) as a trusted service.TopicsCreating an execution role in the IAM consoleCreating and managing roles with the AWS CLIGrant least privilege access to your Lambda execution roleViewing and updating permissions in the execution roleWorking with AWS managed policies in the execution roleUsing source function ARN to control function access behavior
    Creating an execution role in the IAM console
    
    By default, Lambda creates an execution role with minimal permissions when you create a function in the Lambda console. Specifically,
      this execution role includes the AWSLambdaBasicExecutionRole managed policy, which gives your function
      basic permissions to log events to Amazon CloudWatch Logs.
    Your functions typically need additional permissions to perform more meaningful
      tasks. For example, you might have a Lambda function that responds to an event by updating
      entries in an Amazon DynamoDB database. You can create an execution role with the necessary
      permissions using the IAM console.
    To create an execution role in the IAM console
        Open the Roles page in the IAM console.
      
        Choose Create role.
      
        Under Trusted entity type, choose AWS service.
      
        Under Use case, choose Lambda.
      
        Choose Next.
      
        Select the AWS managed policies that you want to attach to your role.
          For example, if your function needs to access DynamoDB, select the
          AWSLambdaDynamoDBExecutionRole managed policy.
      
        Choose Next.
      
        Enter a Role name and then choose Create role.
      
    For detailed instructions, see Creating a role
      for an AWS service (console) in the IAM User Guide.
    After you create your execution role, attach it to your function. When you
      create a function in the Lambda console,
      you can attach any execution role that you previously created to the function. If you want
      to attach a new execution role to an existing function, follow the steps in Updating a function's execution role.
   
    Creating and managing roles with the AWS CLI
    To create an execution role with the AWS Command Line Interface (AWS CLI), use the create-role
      command. When using this command, you can specify the trust policy inline.
      A role's trust policy gives the specified principals permission to assume the role. In the
      following example, you grant the Lambda service principal permission to assume your role. Note that
      requirements for escaping quotes in the JSON string may vary depending on your shell.
    aws iam create-role \
  --role-name lambda-ex \
  --assume-role-policy-document '{"Version": "2012-10-17","Statement": [{ "Effect": "Allow", "Principal": {"Service": "lambda.amazonaws.com"}, "Action": "sts:AssumeRole"}]}'
    You can also define the trust policy for the role using a separate JSON file. In the following example,
      trust-policy.json is a file in the current directory.
    Example trust-policy.json{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Principal": {
        "Service": "lambda.amazonaws.com"
      },
      "Action": "sts:AssumeRole"
    }
  ]
}aws iam create-role \
  --role-name lambda-ex \
  --assume-role-policy-document file://trust-policy.json
    You should see the following output:
    {
    "Role": {
        "Path": "/",
        "RoleName": "lambda-ex",
        "RoleId": "AROAQFOXMPL6TZ6ITKWND",
        "Arn": "arn:aws:iam::123456789012:role/lambda-ex",
        "CreateDate": "2020-01-17T23:19:12Z",
        "AssumeRolePolicyDocument": {
            "Version": "2012-10-17",
            "Statement": [
                {
                    "Effect": "Allow",
                    "Principal": {
                        "Service": "lambda.amazonaws.com"
                    },
                    "Action": "sts:AssumeRole"
                }
            ]
        }
    }
}
    To add permissions to the role, use the attach-policy-to-role command. The following
      command adds the AWSLambdaBasicExecutionRole managed policy to the lambda-ex
      execution role.
    aws iam attach-role-policy --role-name lambda-ex --policy-arn arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
    After you create your execution role, attach it to your function. When you
      create a function in the Lambda console,
      you can attach any execution role that you previously created to the function. If you want
      to attach a new execution role to an existing function, follow the steps in Updating a function's execution role.
   
    Grant least privilege access to your Lambda execution role
    When you first create an IAM role for your Lambda function during the development phase, you might sometimes
      grant permissions beyond what is required. Before publishing your function in the production environment, as a
      best practice, adjust the policy to include only the required permissions. For more information, see Apply least-privilege
        permissions in the IAM User Guide.
    Use IAM Access Analyzer to help identify the required permissions for the IAM execution role policy. IAM Access Analyzer
      reviews your AWS CloudTrail logs over the date range that you specify and generates a policy template with only the
      permissions that the function used during that time. You can use the template to create a managed policy with
      fine-grained permissions, and then attach it to the IAM role. That way, you grant only the permissions that the
      role needs to interact with AWS resources for your specific use case.
    For more information, see Generate policies based on access
      activity in the IAM User Guide.
  Document ConventionsLambda permissionsUpdate execution roleDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideRequirementsImplementing response streaming in a custom
        runtimeBuilding a custom runtime for AWS LambdaYou can implement an AWS Lambda runtime in any programming language. A runtime is a program
    that runs a Lambda function's handler method when the function is invoked. You can include the
    runtime in your function's deployment package or distribute it in a layer. When you create the Lambda function, choose an OS-only runtime (the provided runtime family).NoteCreating a custom runtime is an advanced use case. If you're looking for information about compiling to a native binary or using a third-party off-the-shelf runtime, see When to use Lambda's OS-only runtimes.For a walkthrough of the custom runtime deployment process, see Tutorial: Building a custom runtime.TopicsRequirementsImplementing response streaming in a custom
        runtime
    Requirements
    Custom runtimes must complete certain initialization and processing tasks. A runtime runs the function's setup code, reads the handler name from an environment
      variable, and reads invocation events from the Lambda runtime API. The runtime passes the event
      data to the function handler, and posts the response from the handler back to Lambda.
    
     
      Initialization tasks
    The initialization tasks run once
        per instance of the function to prepare
      the environment to handle invocations.
    
       
       
       
    
        Retrieve settings – Read environment variables to get details
          about the function and environment.
        
           
           
           
        
            _HANDLER – The location to the handler, from the function's configuration. The
              standard format is file.method, where
                file is the name of the file without an extension, and method is the name of a
              method or function that's defined in the file.
          
            LAMBDA_TASK_ROOT – The directory that contains the function code.
          
            AWS_LAMBDA_RUNTIME_API – The host and port of the runtime API.
          
        For a full list of available variables, see Defined runtime environment variables.
      
        Initialize the function – Load the handler file and run any global
          or static code that it contains. Functions should create static resources like SDK clients and database
          connections once, and reuse them for multiple invocations.
      
        Handle errors – If an error occurs, call the initialization error API and exit immediately.
      
    
    Initialization counts towards billed execution time and timeout. When an execution triggers the initialization
      of a new instance of your function, you can see the initialization time in the logs and AWS X-Ray trace.
    Example logREPORT RequestId: f8ac1208... Init Duration: 48.26 ms   Duration: 237.17 ms   Billed Duration: 300 ms   Memory Size: 128 MB   Max Memory Used: 26 MB
     
   
    Processing tasks
    
    While it runs, a runtime uses the Lambda runtime interface to manage
      incoming events and report errors. After completing initialization tasks, the runtime processes incoming events in
      a loop. In your runtime code, perform the following steps in order.
    
       
       
       
       
       
       
       
    
        Get an event – Call the next
            invocation API to get the next event. The response body contains the event data. Response headers
          contain the request ID and other information.
      
        Propagate the tracing header – Get the X-Ray tracing header from
          the Lambda-Runtime-Trace-Id header in the API response. Set the _X_AMZN_TRACE_ID
          environment variable locally with the same value. The X-Ray SDK uses this value to connect trace data between
          services.
      
        Create a context object – Create an object with context
          information from environment variables and headers in the API response.
      
        Invoke the function handler – Pass the event and context object to
          the handler.
      
        Handle the response – Call the invocation response API to post the response from the handler.
      
        Handle errors – If an error occurs, call the invocation error API.
      
        Cleanup – Release unused resources, send data to other services,
          or perform additional tasks before getting the next event.
      
     
     
      Entrypoint
          A custom runtime's entry point is an executable file named bootstrap. The bootstrap file
          can be the runtime, or it can invoke another file that creates the runtime. If the root of your deployment package doesn't contain a file named bootstrap, Lambda looks for the file in the function's layers. If the bootstrap file doesn't exist or isn't executable, your function returns a Runtime.InvalidEntrypoint error upon invocation.
          Here's an example bootstrap file that uses a bundled
          version of Node.js to run a JavaScript runtime in a separate file named
          runtime.js.
        Example bootstrap#!/bin/sh
    cd $LAMBDA_TASK_ROOT
    ./node-v11.1.0-linux-x64/bin/node runtime.js
       
   
    Implementing response streaming in a custom
        runtime
    For response streaming functions, the response and error
      endpoints have slightly modified behavior that lets the runtime stream partial responses to
      the client and return payloads in chunks. For more information about the specific behavior,
      see the following:
    
       
       
       
    
        /runtime/invocation/AwsRequestId/response – Propagates the
            Content-Type header from the runtime to send to the client. Lambda returns
          the response payload in chunks via HTTP/1.1 chunked transfer encoding. The response stream can be a maximum 
          size of 20 MiB. To stream the response to Lambda, the runtime must:
        
           
           
           
           
        
            Set the Lambda-Runtime-Function-Response-Mode HTTP header to
                streaming.
          
            Set the Transfer-Encoding header to chunked.
          
            Write the response conforming to the HTTP/1.1 chunked transfer encoding
              specification.
          
            Close the underlying connection after it has successfully written the
              response.
          
      
        /runtime/invocation/AwsRequestId/error – The runtime can use this
          endpoint to report function or runtime errors to Lambda, which also accepts the
            Transfer-Encoding header. This endpoint can only be called before the
          runtime begins sending an invocation response.
      
        Report midstream errors using error trailers in
            /runtime/invocation/AwsRequestId/response – To report errors that
          occur after the runtime starts writing the invocation response, the runtime can optionally
          attach HTTP trailing headers named Lambda-Runtime-Function-Error-Type and
            Lambda-Runtime-Function-Error-Body. Lambda treats this as a successful
          response and forwards the error metadata that the runtime provides to the client. 
        NoteTo attach trailing headers, the runtime must set the Trailer header
            value at the beginning of the HTTP request. This is a requirement of the HTTP/1.1
            chunked transfer encoding specification.
        
           
           
        
            Lambda-Runtime-Function-Error-Type – The error type that the
              runtime encountered. This header consists of a string value. Lambda accepts any string,
              but we recommend a format of <category.reason>. For
              example, Runtime.APIKeyNotFound.
          
            Lambda-Runtime-Function-Error-Body – Base64-encoded
              information about the error.
          
      
  Document ConventionsOS-only runtimesCustom runtime tutorialDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideNext invocationInvocation responseInitialization errorInvocation errorUsing the Lambda runtime API for custom runtimesAWS Lambda provides an HTTP API for custom runtimes to receive invocation
    events from Lambda and send response data back within the Lambda execution
      environment. This section contains the API reference for the Lambda runtime API.
     
      
     
     
  The OpenAPI specification for the runtime API version 2018-06-01 is available
    in runtime-api.zipTo create an API request URL, runtimes get the API endpoint from the AWS_LAMBDA_RUNTIME_API environment variable, add the API version,
    and add the desired resource path.Example Requestcurl "http://${AWS_LAMBDA_RUNTIME_API}/2018-06-01/runtime/invocation/next"API methodsNext invocationInvocation responseInitialization errorInvocation error
    Next invocation
    Path – /runtime/invocation/next
    Method – GET
    The runtime sends this message to Lambda to request an invocation event. The response body contains the payload
      from the invocation, which is a JSON document that contains event data from the function trigger. The response
      headers contain additional data about the invocation.
    
      Response headers
       
       
       
       
       
       
    
        Lambda-Runtime-Aws-Request-Id – The request ID, which identifies the request that
          triggered the function invocation.
        For example, 8476a536-e9f4-11e8-9739-2dfe598c3fcd.
      
        Lambda-Runtime-Deadline-Ms – The date that the function times out in Unix time
          milliseconds. 
        For example, 1542409706888.
      
        Lambda-Runtime-Invoked-Function-Arn – The ARN of the Lambda function, version, or alias
          that's specified in the invocation. 
        For example, arn:aws:lambda:us-east-2:123456789012:function:custom-runtime.
      
        Lambda-Runtime-Trace-Id – The AWS X-Ray tracing header. 
        For example,
          Root=1-5bef4de7-ad49b0e87f6ef6c87fc2e700;Parent=9a9197af755a6419;Sampled=1.
      
        Lambda-Runtime-Client-Context – For invocations from the AWS Mobile SDK, data about
          the client application and device.
      
        Lambda-Runtime-Cognito-Identity – For invocations from the AWS Mobile SDK, data about
          the Amazon Cognito identity provider.
      
    
    Do not set a timeout on the GET request as the response may be delayed. Between when Lambda bootstraps the runtime and
      when the runtime has an event to return, the runtime process may be frozen for several seconds.
    
    The request ID tracks the invocation within Lambda. Use it to specify the invocation when you send the
      response.
    
    The tracing header contains the trace ID, parent ID, and sampling decision. If the request is sampled, the
      request was sampled by Lambda or an upstream service. The runtime should set the _X_AMZN_TRACE_ID with
      the value of the header. The X-Ray SDK reads this to get the IDs and determine whether to trace the
      request.
   
    Invocation response
    Path –
          /runtime/invocation/AwsRequestId/response
    Method – POST
    After the function has run to completion, the runtime sends an invocation response to Lambda.  For synchronous
      invocations, Lambda sends the response to the client.
    Example success requestREQUEST_ID=156cb537-e2d4-11e8-9b34-d36013741fb9
curl "http://${AWS_LAMBDA_RUNTIME_API}/2018-06-01/runtime/invocation/$REQUEST_ID/response"  -d "SUCCESS"
   
    Initialization error
    If the function returns an error or the runtime encounters an error during initialization, the runtime uses
      this method to report the error to Lambda.
    Path – /runtime/init/error
    Method – POST
    Headers
    Lambda-Runtime-Function-Error-Type – Error type that the runtime encountered. Required:
      no. 
    
  This header consists of a string value. Lambda accepts any string, but we recommend a format of
    <category.reason>. For example:
    
       
       
       
       
    Runtime.NoSuchHandlerRuntime.APIKeyNotFoundRuntime.ConfigInvalidRuntime.UnknownReason   

    Body parameters
    ErrorRequest – Information about the error.
      Required: no. 
    
    This field is a JSON object with the following structure:
    {
      errorMessage: string (text description of the error),
      errorType: string,
      stackTrace: array of strings
}    
Note that Lambda accepts any value for errorType.  
 The following example shows a Lambda function error message in which the function could not parse the event data
    provided in the invocation.
    Example Function error{
      "errorMessage" : "Error parsing event data.",
      "errorType" : "InvalidEventDataException",
      "stackTrace": [ ]
}      

    
        Response body parameters
         
         
    StatusResponse – String. Status information, sent with 202 response codes. ErrorResponse – Additional error information, sent with the error response codes.
          ErrorResponse contains an error type and an error message.
    
      Response codes
       
       
       
    
        202 – Accepted
      
        403 – Forbidden
      
        500 – Container error. Non-recoverable state. Runtime should exit promptly.
      
    Example initialization error requestERROR="{\"errorMessage\" : \"Failed to load function.\", \"errorType\" : \"InvalidFunctionException\"}"
curl "http://${AWS_LAMBDA_RUNTIME_API}/2018-06-01/runtime/init/error" -d "$ERROR" --header "Lambda-Runtime-Function-Error-Type: Unhandled"
   
    Invocation error
    If the function returns an error or the runtime encounters an error, the runtime uses this method to report
      the error to Lambda.
    Path –
      /runtime/invocation/AwsRequestId/error
    Method – POST
    Headers
    Lambda-Runtime-Function-Error-Type – Error type that the runtime encountered. Required:
      no. 
    
  This header consists of a string value. Lambda accepts any string, but we recommend a format of
    <category.reason>. For example:
    
       
       
       
       
    Runtime.NoSuchHandlerRuntime.APIKeyNotFoundRuntime.ConfigInvalidRuntime.UnknownReason   

    Body parameters
    ErrorRequest – Information about the error.
      Required: no. 
    
    This field is a JSON object with the following structure:
    {
      errorMessage: string (text description of the error),
      errorType: string,
      stackTrace: array of strings
}    
Note that Lambda accepts any value for errorType.  
 The following example shows a Lambda function error message in which the function could not parse the event data
    provided in the invocation.
    Example Function error{
      "errorMessage" : "Error parsing event data.",
      "errorType" : "InvalidEventDataException",
      "stackTrace": [ ]
}      

    
      Response body parameters
       
       
    StatusResponse – String. Status information, sent with 202 response codes. ErrorResponse – Additional error information, sent with the error response codes.
       ErrorResponse contains an error type and an error message.
    
      Response codes
       
       
       
       
    
        202 – Accepted
      
        400 – Bad Request
      
        403 – Forbidden
      
        500 – Container error. Non-recoverable state. Runtime should exit promptly.
      
    Example error requestREQUEST_ID=156cb537-e2d4-11e8-9b34-d36013741fb9
ERROR="{\"errorMessage\" : \"Error parsing event data.\", \"errorType\" : \"InvalidEventDataException\"}"
curl "http://${AWS_LAMBDA_RUNTIME_API}/2018-06-01/runtime/invocation/$REQUEST_ID/error" -d "$ERROR" --header "Lambda-Runtime-Function-Error-Type: Unhandled"
  Document ConventionsRuntime modificationsOS-only runtimesDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideNode.js initializationRuntime-included SDK versionsUsing keep-aliveCA certificate loadingBuilding Lambda functions with Node.jsYou can run JavaScript code with Node.js in AWS Lambda. Lambda provides runtimes for Node.js that run your code to process events. Your code runs
    in an environment that includes the AWS SDK for JavaScript, with credentials from an AWS Identity and Access Management (IAM) role that you manage. To learn more 
    about the SDK versions included with the Node.js runtimes, see Runtime-included SDK versions.Lambda supports the following Node.js runtimes.
      
        Name
        Identifier
        Operating system
        Deprecation date
        Block function create
        Block function update
      
    
      
        
          Node.js 22
        
        
          nodejs22.x
        
        
          Amazon Linux 2023
        

        
                      Apr 30, 2027
            
        
        
                      Jun 1, 2027
            
        
        
                      Jul 1, 2027
            
        

      
      
        
          Node.js 20
        
        
          nodejs20.x
        
        
          Amazon Linux 2023
        

        
                      Apr 30, 2026
            
        
        
                      Jun 1, 2026
            
        
        
                      Jul 1, 2026
            
        

      
      
        
          Node.js 18
        
        
          nodejs18.x
        
        
          Amazon Linux 2
        

        
                      Sep 1, 2025
            
        
        
                      Oct 1, 2025
            
        
        
                      Nov 1, 2025
            
        

      
    To create a Node.js function
      Open the Lambda console.
    
      Choose Create function.
    
      Configure the following settings:
      
         
         
      
          Function name: Enter a name for the function.
        
          Runtime: Choose Node.js 22.x.
        
    
      Choose Create function.
    The console creates a Lambda function with a single source file named index.mjs. You can edit this file and add more files in the built-in code editor. In the DEPLOY section, choose Deploy to update your function's code. Then, to run your code, choose Create test event in the TEST EVENTS section.The index.mjs file exports a function named handler that takes an event object and a
    context object. This is the handler function that Lambda calls when the
    function is invoked. The Node.js function runtime gets invocation events from Lambda and passes them to the
    handler. In the function configuration, the handler value is index.handler.When you save your function code, the Lambda console creates a .zip file archive deployment package. 
   When you develop your function code outside of the console (using an IDE) you need to create a
      deployment package to upload your code to the Lambda function.The function runtime passes a context object to the handler, in addition to the invocation event. The context object contains additional information about the invocation, the
    function, and the execution environment. More information is available from environment variables.Your Lambda function comes with a CloudWatch Logs log group. The function runtime sends details about each invocation to
    CloudWatch Logs. It relays any logs that your function outputs during invocation. If
    your function returns an error, Lambda formats the error and returns it to the
    invoker.TopicsNode.js initializationRuntime-included SDK versionsUsing keep-alive for TCP connectionsCA certificate loadingDefine Lambda function handler in Node.jsDeploy Node.js Lambda functions with .zip file archivesDeploy Node.js Lambda functions with container imagesWorking with layers for Node.js Lambda functionsUsing the Lambda context object to retrieve Node.js function informationLog and monitor Node.js Lambda functionsInstrumenting Node.js code in AWS Lambda
    Node.js initialization
    Node.js has a unique event loop model that causes its initialization behavior to be different from other runtimes. 
      Specifically, Node.js uses a non-blocking I/O model that supports asynchronous operations. 
      This model allows Node.js to perform efficiently for most workloads. 
      For example, if a Node.js function makes a network call, that request may be designated as an asynchronous operation and placed into a callback queue. 
      The function may continue to process other operations within the main call stack without getting blocked by waiting for the network call to return. 
      Once the network call is completed, its callback is executed and then removed from the callback queue.
    
    
      Some initialization tasks may run asynchronously. These asynchronous tasks are not guaranteed to complete execution prior to an invocation. 
      For example, code that makes a network call to fetch a parameter from AWS Parameter Store may not be complete by the time Lambda executes the handler function. 
      As a result, the variable may be null during an invocation. 
      To avoid this, ensure that variables and other asynchronous code are fully initialized before continuing with the rest of the function's core business logic.
    
    Alternatively, you can designate your function code as an ES module, allowing you to use await at the top level
      of the file, outside the scope of your function handler. When you await every Promise, the asynchronous
      initialization code completes before handler invocations, maximizing the effectiveness of
      provisioned concurrency in reducing cold start latency. For more information and an example,
      see Using Node.js ES modules and top-level await in AWS Lambda.
     
      Designating a function handler as an ES module
      By default, Lambda treats files with the .js suffix as CommonJS modules. Optionally, you can designate your
        code as an ES module. You can do this in two ways: specifying the type as module in the function's
        package.json file, or by using the .mjs file name extension. In the first approach, your function
        code treats all .js files as ES modules, while in the second scenario, only the file you specify with .mjs
        is an ES module. You can mix ES modules and CommonJS modules by naming them .mjs and .cjs respectively,
        as .mjs files are always ES modules and .cjs files are always CommonJS modules.
      Lambda searches folders in the NODE_PATH environment variable when loading
        ES modules. You can load the AWS SDK that's included in the runtime using ES module import
        statements. You can also load ES modules from layers.
      
        ES module example
            Example  – ES module handlerconst url = "https://aws.amazon.com/";

export const handler = async(event) => {
    try {
        const res = await fetch(url);
        console.info("status", res.status);
        return res.status;
    }
    catch (e) {
        console.error(e);
        return 500;
    }
};
          
        CommonJS module example
            Example  – CommonJS module handlerconst https = require("https");
let url = "https://aws.amazon.com/";

exports.handler = async function (event) {
  let statusCode;
  await new Promise(function (resolve, reject) {
    https.get(url, (res) => {
        statusCode = res.statusCode;
        resolve(statusCode);
      }).on("error", (e) => {
        reject(Error(e));
      });
  });
  console.log(statusCode);
  return statusCode;
};
          
      
        
   
    Runtime-included SDK versions
    All supported Lambda Node.js runtimes include a specific minor version of the AWS SDK for JavaScript v3, not the latest version. The specific minor version that's included in the runtime depends on the runtime version and your AWS Region. To find the specific version of the SDK included in the runtime that you're using, create a Lambda function with the following code.
    Example index.mjsimport packageJson from '@aws-sdk/client-s3/package.json' with { type: 'json' };

export const handler = async () => ({ version: packageJson.version });This returns a response in the following format:{
  "version": "3.632.0"
}
    For more information, see Using the SDK for JavaScript v3 in your handler.
   
    Using keep-alive for TCP connections
    The default Node.js HTTP/HTTPS agent creates a new TCP connection for every new request. To avoid the cost of
      establishing new connections, keep-alive is enabled by default in nodejs18.x and later Lambda runtimes. Keep-alive can reduce request times for Lambda functions that make multiple API calls using the SDK.
    To disable keep-alive, see
      Reusing connections with keep-alive in Node.js in the AWS SDK for JavaScript 3.x Developer Guide. For more information about using keep-alive, see
      HTTP keep-alive is on by default in modular AWS SDK for JavaScript
      on the AWS Developer Tools Blog.
   
    CA certificate loading
    For Node.js runtime versions up to Node.js 18, Lambda automatically loads Amazon-specific CA (certificate
      authority) certificates to make it easier for you to create functions that interact with other AWS services.
      For example, Lambda includes the Amazon RDS certificates necessary for validating the
      server identity certificate
      installed on your Amazon RDS database. This behavior can have a performance impact during cold starts.
    Starting with Node.js 20, Lambda no longer loads additional CA certificates by default. The Node.js 20 runtime
      contains a certificate file with all Amazon CA certificates located at /var/runtime/ca-cert.pem. To
      restore the same behavior from Node.js 18 and earlier runtimes, set the NODE_EXTRA_CA_CERTS
      environment variable to /var/runtime/ca-cert.pem.
    For optimal performance, we recommend bundling only the certificates that you need with your deployment package
      and loading them via the NODE_EXTRA_CA_CERTS environment variable. The certificates file should
      consist of one or more trusted root or intermediate CA certificates in PEM format. For example, for RDS, include
      the required certificates alongside your code as certificates/rds.pem. Then, load the certificates
      by setting NODE_EXTRA_CA_CERTS to /var/task/certificates/rds.pem.
  Document ConventionsMonitoring concurrencyHandlerDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideRuntime-included SDK versionsExperimental features in Python 3.13Response formatGraceful shutdown for extensionsBuilding Lambda functions with PythonYou can run Python code in AWS Lambda. Lambda provides runtimes for Python that run your code to process events. Your code runs
    in an environment that includes the SDK for Python (Boto3), with credentials from an AWS Identity and Access Management (IAM) role that you manage. To learn more 
    about the SDK versions included with the Python runtimes, see Runtime-included SDK versions.Lambda supports the following Python runtimes.
      
        Name
        Identifier
        Operating system
        Deprecation date
        Block function create
        Block function update
      
    
      
        
          Python 3.13
        
        
          python3.13
        
        
          Amazon Linux 2023
        

        
                      Jun 30, 2029
            
        
        
                      Jul 31, 2029
            
        
        
                      Aug 31, 2029
            
        

      
      
        
          Python 3.12
        
        
          python3.12
        
        
          Amazon Linux 2023
        

        
                      Oct 31, 2028
            
        
        
                      Nov 30, 2028
            
        
        
                      Jan 10, 2029
            
        

      
      
        
          Python 3.11
        
        
          python3.11
        
        
          Amazon Linux 2
        

        
                      Jun 30, 2026
            
        
        
                      Jul 31, 2026
            
        
        
                      Aug 31, 2026
            
        

      
      
        
          Python 3.10
        
        
          python3.10
        
        
          Amazon Linux 2
        

        
                      Jun 30, 2026
            
        
        
                      Jul 31, 2026
            
        
        
                      Aug 31, 2026
            
        

      
      
        
          Python 3.9
        
        
          python3.9
        
        
          Amazon Linux 2
        

        
                      Nov 3, 2025
            
        
        
                      Dec 8, 2025
            
        
        
                      Jan 8, 2026
            
        

      
    To create a Python function
      Open the Lambda console.
    
      Choose Create function.
    
      Configure the following settings:
      
         
         
      
          Function name: Enter a name for the function.
        
          Runtime: Choose Python 3.13.
        
    
      Choose Create function.
    The console creates a Lambda function with a single source file named lambda_function. You can edit this file and add more files in the built-in code editor. In the DEPLOY section, choose Deploy to update your function's code. Then, to run your code, choose Create test event in the TEST EVENTS section.Your Lambda function comes with a CloudWatch Logs log group. The function runtime sends details about each invocation to
    CloudWatch Logs. It relays any logs that your function outputs during invocation. If
    your function returns an error, Lambda formats the error and returns it to the
    invoker.TopicsRuntime-included SDK versionsExperimental features in Python 3.13Response formatGraceful shutdown for extensionsDefine Lambda function handler in PythonWorking with .zip file archives for Python Lambda functionsDeploy Python Lambda functions with container imagesWorking with layers for Python Lambda functionsUsing the Lambda context object to retrieve Python function informationLog and monitor Python Lambda functionsAWS Lambda function testing in PythonInstrumenting Python code in AWS Lambda
    Runtime-included SDK versions
    The version of the AWS SDK included in the Python runtime depends on the runtime version and your AWS Region. To find the version of the SDK included in the runtime 
      you're using, create a Lambda function with the following code.
    import boto3
import botocore

def lambda_handler(event, context):
   print(f'boto3 version: {boto3.__version__}')
   print(f'botocore version: {botocore.__version__}')
   
    Experimental features in Python 3.13  
    The Python 3.13 managed runtime and base images do not support the following experimental features. You cannot enable these features using runtime flags. To use these features in a Lambda function, you must deploy a custom runtime or container image containing your own build of Python 3.13.
    
       
       
    
        Free-threaded CPython: You cannot disable the global interpreter lock.
      
        Just-in-time (JIT) compiler: You cannot enable the JIT compiler.
      
   
    Response format  
  In Python 3.12 and later Python runtimes, functions return Unicode characters as part of their JSON response. Earlier Python runtimes return escaped sequences for Unicode characters in responses. For example, in Python 3.11, if you return a Unicode string such as "こんにちは", it escapes the Unicode characters and returns "\u3053\u3093\u306b\u3061\u306f". The Python 3.12 runtime returns the original "こんにちは".
  Using Unicode responses reduces the size of Lambda responses, making it easier to fit larger responses into the 6 MB maximum payload size for synchronous functions. In the previous example, the escaped version is 32 bytes—compared to 17 bytes with the Unicode string.
    When you upgrade to Python 3.12 or later Python runtimes, you might need to adjust your code to account for the new response format. If the caller expects escaped Unicode, you must either add code to the returning function to escape the Unicode manually, or adjust the caller to handle the Unicode return.
   
    Graceful shutdown for extensions  
  Python 3.12 and later Python runtimes offer improved graceful shutdown capabilities for functions with external extensions. When Lambda shuts down an execution environment, it sends a SIGTERM signal to the runtime and then a SHUTDOWN event to each registered external extension. You can catch the SIGTERM signal in your Lambda function and clean up resources such as database connections that were created by the function.
  To learn more about the execution environment lifecycle, see Understanding the Lambda execution environment lifecycle. For examples of how to use graceful shutdown with extensions, see the AWS Samples GitHub repository.
  Document ConventionsTracingHandlerDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideRuntime-included SDK versionsEnabling Yet Another Ruby JIT (YJIT)Building Lambda functions with RubyYou can run Ruby code in AWS Lambda. Lambda provides runtimes for Ruby that run your code to process events. Your code runs
    in an environment that includes the AWS SDK for Ruby, with credentials from an AWS Identity and Access Management (IAM) role that you manage. To learn more 
    about the SDK versions included with the Ruby runtimes, see Runtime-included SDK versions.Lambda supports the following Ruby runtimes.
      
        Name
        Identifier
        Operating system
        Deprecation date
        Block function create
        Block function update
      
    
      
        
          Ruby 3.4
        
        
          ruby3.4
        
        
          Amazon Linux 2023
        

        
          
            Not scheduled
            
        
        
          
            Not scheduled
            
        
        
          
            Not scheduled
            
        

      
      
        
          Ruby 3.3
        
        
          ruby3.3
        
        
          Amazon Linux 2023
        

        
                      Mar 31, 2027
            
        
        
                      Apr 30, 2027
            
        
        
                      May 31, 2027
            
        

      
      
        
          Ruby 3.2
        
        
          ruby3.2
        
        
          Amazon Linux 2
        

        
                      Mar 31, 2026
            
        
        
                      Apr 30, 2026
            
        
        
                      May 31, 2026
            
        

      
    To create a Ruby function
      Open the Lambda console.
    
      Choose Create function.
    
      Configure the following settings:
      
         
         
      
          Function name: Enter a name for the function.
        
          Runtime: Choose Ruby 3.4.
        
    
      Choose Create function.
    The console creates a Lambda function with a single source file named lambda_function.rb. You can edit this file and add more files in the built-in code editor. In the DEPLOY section, choose Deploy to update your function's code. Then, to run your code, choose Create test event in the TEST EVENTS section.The lambda_function.rb file exports a function named lambda_handler that takes an event object and a
    context object. This is the handler function that Lambda calls when the
    function is invoked. The Ruby function runtime gets invocation events from Lambda and passes them to the
    handler. In the function configuration, the handler value is lambda_function.lambda_handler.When you save your function code, the Lambda console creates a .zip file archive deployment package. 
   When you develop your function code outside of the console (using an IDE) you need to create a
      deployment package to upload your code to the Lambda function.The function runtime passes a context object to the handler, in addition to the invocation event. The context object contains additional information about the invocation, the
    function, and the execution environment. More information is available from environment variables.Your Lambda function comes with a CloudWatch Logs log group. The function runtime sends details about each invocation to
    CloudWatch Logs. It relays any logs that your function outputs during invocation. If
    your function returns an error, Lambda formats the error and returns it to the
    invoker.TopicsRuntime-included SDK versionsEnabling Yet Another Ruby JIT (YJIT)Define Lambda function handler in RubyDeploy Ruby Lambda functions with .zip file archivesDeploy Ruby Lambda functions with container imagesWorking with layers for Ruby Lambda functionsUsing the Lambda context object to retrieve Ruby function informationLog and monitor Ruby Lambda functionsInstrumenting Ruby code in AWS Lambda
    Runtime-included SDK versions
    The version of the AWS SDK included in the Ruby runtime depends on the runtime version and your AWS Region. The AWS SDK for Ruby is designed to be modular and is 
      separated by AWS service. To find the version number of a particular service gem included in the runtime you're using, create a Lambda function with code in the following 
      format. Replace aws-sdk-s3 and Aws::S3with the name of the service gems your code uses.
    require 'aws-sdk-s3'

def lambda_handler(event:, context:)
  puts "Service gem version: #{Aws::S3::GEM_VERSION}"
  puts "Core version: #{Aws::CORE_GEM_VERSION}"
end
   
 Enabling Yet Another Ruby JIT (YJIT)
    The Ruby 3.2 runtime supports YJIT, a lightweight, minimalistic Ruby JIT compiler. YJIT provides significantly higher performance, but also uses more memory than the Ruby interpreter. YJIT is recommended for Ruby on Rails workloads.
    YJIT is not enabled by default. To enable YJIT for a Ruby 3.2 function, set the RUBY_YJIT_ENABLE environment variable to 1. To confirm that YJIT is enabled, print the result of the RubyVM::YJIT.enabled? method.
    Example — Confirm that YJIT is enabledputs(RubyVM::YJIT.enabled?())
# => true
  Document ConventionsTracingHandlerDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideDevelopment environmentBuilding Lambda functions with C#You can run your .NET application in Lambda using the managed .NET 8 runtime, a custom runtime, or a container image. After your application 
    code is compiled, you can deploy it to Lambda either as a .zip file or a container image. Lambda provides the following runtimes for .NET languages:
      
        Name
        Identifier
        Operating system
        Deprecation date
        Block function create
        Block function update
      
    
      
        
          .NET 9 (container only)
        
        
          dotnet9
        
        
          Amazon Linux 2023
        

        
          
            Not scheduled
            
        
        
          
            Not scheduled
            
        
        
          
            Not scheduled
            
        

      
      
        
          .NET 8
        
        
          dotnet8
        
        
          Amazon Linux 2023
        

        
                      Nov 10, 2026
            
        
        
                      Dec 10, 2026
            
        
        
                      Jan 11, 2027
            
        

      
    
    Setting up your .NET development environment
    To develop and build your Lambda functions, you can use any of the commonly available .NET integrated development environments (IDEs), 
      including Microsoft Visual Studio, Visual Studio Code, and JetBrains Rider. To simplify your development experience, AWS provides a set of 
      .NET project templates, as well as the Amazon.Lambda.Tools command line interface (CLI).
    Run the following .NET CLI commands to install these project templates and command line tools.
     
      Installing the .NET project templates
      To install the project templates, run the following command:
      dotnet new install Amazon.Lambda.Templates
     
     
      Installing and updating the CLI tools
      Run the following commands to install, update, and uninstall the Amazon.Lambda.Tools CLI.
      
      To install the command line tools:
      dotnet tool install -g Amazon.Lambda.Tools
      To update the command line tools:
      dotnet tool update -g Amazon.Lambda.Tools   
      To uninstall the command line tools:
      dotnet tool uninstall -g Amazon.Lambda.Tools
     
  Document ConventionsTracingHandlerDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideCreating function versionsUsing versionsGranting permissionsManage Lambda function versionsYou can use versions to manage the deployment of your functions. For example, you can publish a new version of a
    function for beta testing without affecting users of the stable production version. Lambda creates a new version of
    your function each time that you publish the function. The new version is a copy of the unpublished version of the
    function. The unpublished version is named $LATEST.Importantly, any time you deploy your function code, you overwrite the current code in $LATEST.
    To save the current iteration of $LATEST, create a new function version. If $LATEST
    is identical to a previously published version, you won't be able to create a new version until you deploy changes
    to $LATEST. These changes can include updating the code, or modifying the function configuration settings.After you publish a function version, its code, runtime, architecture, memory, layers, and
    most other configuration settings are immutable. This means that you can't change these settings
    without publishing a new version from $LATEST. You can configure the following items for a
    published function version:
     
     
     
     
     
  TriggersDestinationsProvisioned concurrencyAsynchronous invocationDatabase connections and proxiesNoteWhen using runtime management controls with Auto
      mode, the runtime version used by the function version is updated automatically. 
      When using Function update or Manual mode, the runtime version is not updated.
      For more information, see Understanding how Lambda manages runtime version updates.SectionsCreating function versionsUsing versionsGranting permissions
    Creating function versions
    You can change the function code and settings only on the unpublished version of a function. When you publish
      a version, Lambda locks the code and most of the settings to maintain a consistent experience for users of that
      version.
    You can create a function version using the Lambda console.
    To create a new function versionOpen the Functions page of the Lambda console.
        Choose a function and then choose the Versions tab.
      
        On the versions configuration page, choose Publish new
          version.
      
        (Optional) Enter a version description.
      
        Choose Publish.
      
    Alternatively, you can publish a version of a function using the PublishVersion API operation.
    The following AWS CLI command publishes a new version of a function. The response returns configuration information
      about the new version, including the version number and the function ARN with the version suffix.
    aws lambda publish-version --function-name my-function
    You should see the following output:
{
  "FunctionName": "my-function",
  "FunctionArn": "arn:aws:lambda:us-east-2:123456789012:function:my-function:1",
  "Version": "1",
  "Role": "arn:aws:iam::123456789012:role/lambda-role",
  "Handler": "function.handler",
  "Runtime": "nodejs22.x",
  ...
}
    NoteLambda assigns monotonically increasing sequence numbers for versioning. Lambda never reuses version
      numbers, even after you delete and recreate a function.
   
    Using versions
    You can reference your Lambda function using either a qualified ARN or an unqualified ARN.
    
       
       
    
        Qualified ARN – The function ARN with a version suffix. The
          following example refers to version 42 of the helloworld function.
        arn:aws:lambda:aws-region:acct-id:function:helloworld:42       
      
        Unqualified ARN – The function ARN without a version suffix.
        arn:aws:lambda:aws-region:acct-id:function:helloworld
      
    You can use a qualified or an unqualified ARN in all relevant API operations. However, you can't use an
      unqualified ARN to create an alias.
    If you decide not to publish function versions, you can invoke the function using either the qualified or
      unqualified ARN in your event source mapping. When you invoke
      a function using an unqualified ARN, Lambda implicitly invokes $LATEST.
    Lambda publishes a new function version only if the code has never been published, or if
      the code has changed from the last published version. If there is no change, the function
      version remains at the last published version.
    The qualified ARN for each Lambda function version is unique. After you publish a version, you can't change the
      ARN or the function code.
   
    Granting permissions
    You can use a resource-based policy or an identity-based policy to grant access to your function. The scope
      of the permission depends on whether you apply the policy to a function or to one version of a function. For more
      information about function resource names in policies, see Fine-tuning the Resources and Conditions sections of policies. 
    You can simplify the management of event sources and AWS Identity and Access Management (IAM) policies by using function aliases. For
      more information, see Create an alias for a Lambda function.
  Document ConventionsWeighted aliasesTagsDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideCreating function versionsUsing versionsGranting permissionsManage Lambda function versionsYou can use versions to manage the deployment of your functions. For example, you can publish a new version of a
    function for beta testing without affecting users of the stable production version. Lambda creates a new version of
    your function each time that you publish the function. The new version is a copy of the unpublished version of the
    function. The unpublished version is named $LATEST.Importantly, any time you deploy your function code, you overwrite the current code in $LATEST.
    To save the current iteration of $LATEST, create a new function version. If $LATEST
    is identical to a previously published version, you won't be able to create a new version until you deploy changes
    to $LATEST. These changes can include updating the code, or modifying the function configuration settings.After you publish a function version, its code, runtime, architecture, memory, layers, and
    most other configuration settings are immutable. This means that you can't change these settings
    without publishing a new version from $LATEST. You can configure the following items for a
    published function version:
     
     
     
     
     
  TriggersDestinationsProvisioned concurrencyAsynchronous invocationDatabase connections and proxiesNoteWhen using runtime management controls with Auto
      mode, the runtime version used by the function version is updated automatically. 
      When using Function update or Manual mode, the runtime version is not updated.
      For more information, see Understanding how Lambda manages runtime version updates.SectionsCreating function versionsUsing versionsGranting permissions
    Creating function versions
    You can change the function code and settings only on the unpublished version of a function. When you publish
      a version, Lambda locks the code and most of the settings to maintain a consistent experience for users of that
      version.
    You can create a function version using the Lambda console.
    To create a new function versionOpen the Functions page of the Lambda console.
        Choose a function and then choose the Versions tab.
      
        On the versions configuration page, choose Publish new
          version.
      
        (Optional) Enter a version description.
      
        Choose Publish.
      
    Alternatively, you can publish a version of a function using the PublishVersion API operation.
    The following AWS CLI command publishes a new version of a function. The response returns configuration information
      about the new version, including the version number and the function ARN with the version suffix.
    aws lambda publish-version --function-name my-function
    You should see the following output:
{
  "FunctionName": "my-function",
  "FunctionArn": "arn:aws:lambda:us-east-2:123456789012:function:my-function:1",
  "Version": "1",
  "Role": "arn:aws:iam::123456789012:role/lambda-role",
  "Handler": "function.handler",
  "Runtime": "nodejs22.x",
  ...
}
    NoteLambda assigns monotonically increasing sequence numbers for versioning. Lambda never reuses version
      numbers, even after you delete and recreate a function.
   
    Using versions
    You can reference your Lambda function using either a qualified ARN or an unqualified ARN.
    
       
       
    
        Qualified ARN – The function ARN with a version suffix. The
          following example refers to version 42 of the helloworld function.
        arn:aws:lambda:aws-region:acct-id:function:helloworld:42       
      
        Unqualified ARN – The function ARN without a version suffix.
        arn:aws:lambda:aws-region:acct-id:function:helloworld
      
    You can use a qualified or an unqualified ARN in all relevant API operations. However, you can't use an
      unqualified ARN to create an alias.
    If you decide not to publish function versions, you can invoke the function using either the qualified or
      unqualified ARN in your event source mapping. When you invoke
      a function using an unqualified ARN, Lambda implicitly invokes $LATEST.
    Lambda publishes a new function version only if the code has never been published, or if
      the code has changed from the last published version. If there is no change, the function
      version remains at the last published version.
    The qualified ARN for each Lambda function version is unique. After you publish a version, you can't change the
      ARN or the function code.
   
    Granting permissions
    You can use a resource-based policy or an identity-based policy to grant access to your function. The scope
      of the permission depends on whether you apply the policy to a function or to one version of a function. For more
      information about function resource names in policies, see Fine-tuning the Resources and Conditions sections of policies. 
    You can simplify the management of event sources and AWS Identity and Access Management (IAM) policies by using function aliases. For
      more information, see Create an alias for a Lambda function.
  Document ConventionsWeighted aliasesTagsDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideCreating function versionsUsing versionsGranting permissionsManage Lambda function versionsYou can use versions to manage the deployment of your functions. For example, you can publish a new version of a
    function for beta testing without affecting users of the stable production version. Lambda creates a new version of
    your function each time that you publish the function. The new version is a copy of the unpublished version of the
    function. The unpublished version is named $LATEST.Importantly, any time you deploy your function code, you overwrite the current code in $LATEST.
    To save the current iteration of $LATEST, create a new function version. If $LATEST
    is identical to a previously published version, you won't be able to create a new version until you deploy changes
    to $LATEST. These changes can include updating the code, or modifying the function configuration settings.After you publish a function version, its code, runtime, architecture, memory, layers, and
    most other configuration settings are immutable. This means that you can't change these settings
    without publishing a new version from $LATEST. You can configure the following items for a
    published function version:
     
     
     
     
     
  TriggersDestinationsProvisioned concurrencyAsynchronous invocationDatabase connections and proxiesNoteWhen using runtime management controls with Auto
      mode, the runtime version used by the function version is updated automatically. 
      When using Function update or Manual mode, the runtime version is not updated.
      For more information, see Understanding how Lambda manages runtime version updates.SectionsCreating function versionsUsing versionsGranting permissions
    Creating function versions
    You can change the function code and settings only on the unpublished version of a function. When you publish
      a version, Lambda locks the code and most of the settings to maintain a consistent experience for users of that
      version.
    You can create a function version using the Lambda console.
    To create a new function versionOpen the Functions page of the Lambda console.
        Choose a function and then choose the Versions tab.
      
        On the versions configuration page, choose Publish new
          version.
      
        (Optional) Enter a version description.
      
        Choose Publish.
      
    Alternatively, you can publish a version of a function using the PublishVersion API operation.
    The following AWS CLI command publishes a new version of a function. The response returns configuration information
      about the new version, including the version number and the function ARN with the version suffix.
    aws lambda publish-version --function-name my-function
    You should see the following output:
{
  "FunctionName": "my-function",
  "FunctionArn": "arn:aws:lambda:us-east-2:123456789012:function:my-function:1",
  "Version": "1",
  "Role": "arn:aws:iam::123456789012:role/lambda-role",
  "Handler": "function.handler",
  "Runtime": "nodejs22.x",
  ...
}
    NoteLambda assigns monotonically increasing sequence numbers for versioning. Lambda never reuses version
      numbers, even after you delete and recreate a function.
   
    Using versions
    You can reference your Lambda function using either a qualified ARN or an unqualified ARN.
    
       
       
    
        Qualified ARN – The function ARN with a version suffix. The
          following example refers to version 42 of the helloworld function.
        arn:aws:lambda:aws-region:acct-id:function:helloworld:42       
      
        Unqualified ARN – The function ARN without a version suffix.
        arn:aws:lambda:aws-region:acct-id:function:helloworld
      
    You can use a qualified or an unqualified ARN in all relevant API operations. However, you can't use an
      unqualified ARN to create an alias.
    If you decide not to publish function versions, you can invoke the function using either the qualified or
      unqualified ARN in your event source mapping. When you invoke
      a function using an unqualified ARN, Lambda implicitly invokes $LATEST.
    Lambda publishes a new function version only if the code has never been published, or if
      the code has changed from the last published version. If there is no change, the function
      version remains at the last published version.
    The qualified ARN for each Lambda function version is unique. After you publish a version, you can't change the
      ARN or the function code.
   
    Granting permissions
    You can use a resource-based policy or an identity-based policy to grant access to your function. The scope
      of the permission depends on whether you apply the policy to a function or to one version of a function. For more
      information about function resource names in policies, see Fine-tuning the Resources and Conditions sections of policies. 
    You can simplify the management of event sources and AWS Identity and Access Management (IAM) policies by using function aliases. For
      more information, see Create an alias for a Lambda function.
  Document ConventionsWeighted aliasesTagsDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideCreating a triggerServices listInvoking Lambda with events from other AWS servicesSome AWS services can directly invoke Lambda functions using triggers. These services push events to Lambda, and the function is invoked immediately when the specified event occurs. Triggers are suitable for discrete events and real-time processing. When you create a trigger using the Lambda console, the console interacts with the corresponding AWS service to configure the event notification on that service. The trigger is actually stored and managed by the service that generates the events, not by Lambda.The events are data structured in JSON format. The JSON structure varies depending on the service that
    generates it and the event type, but they all contain the data that the function needs to process the
    event.A function can have multiple triggers. Each trigger acts as a client invoking your function independently, and each event that
    Lambda passes to your function has data from only one trigger. Lambda converts the event document into an object and passes it to your function handler.Depending on the service, the event-driven invocation can be synchronous or asynchronous.
     
     
  
      For synchronous invocation, the service that generates the event waits for the response from your
        function. That service defines the data that the function needs to return in the response. The service
        controls the error strategy, such as whether to retry on errors.
    
      For asynchronous invocation, Lambda queues the event before passing it to your function. When Lambda
        queues the event, it immediately sends a success response to the service that generated the event. After the
        function processes the event, Lambda doesn’t return a response to the event-generating service.
    
    Creating a trigger
    The easiest way to create a trigger is to use the Lambda console. When you create a trigger using the console, Lambda automatically adds the required permissions to the function's resource-based policy.
    To create a trigger using the Lambda console
        Open the Functions page of the Lambda console.
      
        Select the function you want to create a trigger for.
      
        In the Function overview pane, choose
          Add trigger.
      
        Select the AWS service you want to invoke your function.
      
        Fill out the options in the Trigger configuration pane
          and choose Add. Depending on the AWS service you choose to
          invoke your function, the trigger configuration options will be different.
      
   
    Services that can invoke Lambda functions
    The following table lists services that can invoke Lambda functions.
    
          
            Service
            Method of invocation
          
        

          
            
              Amazon Managed Streaming for Apache Kafka
            
            
              Event source mapping
            
          
          
            
              Self-managed Apache Kafka
            
            
              Event source mapping
            
          
          
            
              Amazon API Gateway
            
            
              Event-driven; synchronous invocation
            
          
          
            
              AWS CloudFormation
            
            
              Event-driven; asynchronous invocation
            
          
          
            
              Amazon CloudWatch Logs
            
            
              Event-driven; asynchronous invocation
            
          
          
            
              AWS CodeCommit
            
            
              Event-driven; asynchronous invocation
            
          
          
            
              AWS CodePipeline
            
            
              Event-driven; asynchronous invocation
            
          
          
            
              Amazon Cognito
            
            
              Event-driven; synchronous invocation
            
          
          
            
              AWS Config
            
            
              Event-driven; asynchronous invocation
            
          
          
            
              Amazon Connect
            
            
              Event-driven; synchronous invocation
            
          
          
            
              Amazon DocumentDB
            
            
              Event source mapping
            
          
          
            
              Amazon DynamoDB
            
            
              Event source mapping
            
          
          
            
              Elastic Load Balancing (Application Load Balancer)
            
            
              Event-driven; synchronous invocation
            
          
          
            
              Amazon EventBridge (CloudWatch Events)
            
            
              Event-driven; asynchronous invocation (event buses), synchronous or asynchronous invocation (pipes and schedules)
            
          
          
            
              AWS IoT
            
            
              Event-driven; asynchronous invocation
            
          
          
            
              Amazon Kinesis
            
            
              Event source mapping
            
          
          
            
              Amazon Data Firehose
            
            
              Event-driven; synchronous invocation
            
          
          
            
              Amazon Lex
            
            
              Event-driven; synchronous invocation
            
          
          
            
              Amazon MQ
            
            
              Event source mapping
            
          
          
            
              Amazon Simple Email Service
            
            
              Event-driven; asynchronous invocation
            
          
          
            
              Amazon Simple Notification Service
            
            
              Event-driven; asynchronous invocation
            
          
          
            
              Amazon Simple Queue Service
            
            
              Event source mapping
            
          
          
            
              Amazon Simple Storage Service (Amazon S3)
            
            
              Event-driven; asynchronous invocation
            
          
          
            
              Amazon Simple Storage Service Batch
            
            
              Event-driven; synchronous invocation
            
          
          
            
              Secrets Manager
            
            
              Secret rotation
            
          
          
            
              AWS Step Functions
            
            
              Event-driven; synchronous or asynchronous invocation
            
          
          
            
              Amazon VPC Lattice
            
            
              Event-driven; synchronous invocation
            
          
        
  Document ConventionsTroubleshootingApache KafkaDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideDestinationsDead-letter queuesCapturing records of Lambda asynchronous invocationsLambda can send records of asynchronous invocations to one of the following AWS services.
     
     
     
     
     
  
      Amazon SQS – A standard SQS queue
    
      Amazon SNS – A standard SNS topic
    
      Amazon S3 – An Amazon S3 bucket (on failure only)
    
      AWS Lambda – A Lambda function
    
      Amazon EventBridge – An EventBridge event bus
    The invocation record contains details about the request and response in JSON format. You can configure
    separate destinations for events that are processed successfully, and events that fail all processing attempts.
    Alternatively, you can configure a standard Amazon SQS queue or standard Amazon SNS topic as a dead-letter
      queue for discarded events. For dead-letter queues, Lambda only sends the content of the event, without
    details about the response.If Lambda can't send a record to a destination you have configured, it sends a DestinationDeliveryFailures metric to 
    Amazon CloudWatch. This can happen if your configuration includes an unsupported destination type, such as an Amazon SQS FIFO queue or an Amazon SNS FIFO 
    topic. Delivery errors can also occur due to permissions errors and size limits. For more information on Lambda invocation metrics, 
    see Invocation metrics.NoteTo prevent a function from triggering, you can set the function's reserved concurrency to zero. When you set
      reserved concurrency to zero for an asynchronously invoked function, Lambda begins sending new events to the
      configured dead-letter queue or the on-failure event destination, without any retries. To process events that
      were sent while reserved concurrency was set to zero, you must consume the events from the dead-letter queue or
      the on-failure event destination.
    Adding a destination
    To retain records of asynchronous invocations, add a destination to your function. You can choose to send
      either successful or failed invocations to a destination. Each function can have multiple destinations, so
      you can configure separate destinations for successful and failed events. Each record sent to the
      destination is a JSON document with details about the invocation. Like error handling settings, you can
      configure destinations on a function, function version, or alias.
    TipYou can also retain records of failed invocations for the following event source mapping types:
        Amazon Kinesis,
        Amazon DynamoDB,
        self-managed Apache Kafka,
        and Amazon MSK.
    
    The following table lists supported destinations for asynchronous invocation records. For Lambda to
      successfully send records to your chosen destination, ensure that your function's
      execution role also contains the relevant permissions.
      The table also describes how each destination type receives the JSON invocation record.
    
          
            Destination type
            Required permission
            Destination-specific JSON format
          
        
          
            
              Amazon SQS queue
            
            
              sqs:SendMessage
            
            
              Lambda passes the invocation record as the Message to the destination.
            
          
          
            
              Amazon SNS topic
            
            
              sns:Publish
            
            
              Lambda passes the invocation record as the Message to the destination.
            
          
          
            
              Amazon S3 bucket (on failure only)
            
            
              s3:PutObject
              s3:ListBucket
            
            
              
                 
                 
              
                  Lambda stores the invocation record as a JSON object in the destination bucket.
                
                  The S3 object name uses the following naming convention:
                  aws/lambda/async/<function-name>/YYYY/MM/DD/YYYY-MM-DDTHH.MM.SS-<Random UUID>
                
            
          
          
            
              Lambda function
            
            
              lambda:InvokeFunction
            
            
              Lambda passes the invocation record as the payload to the function.
            
          
          
            
              EventBridge
            
            
              events:PutEvents
            
            
              
                 
                 
                 
                 
                 
              
                  Lambda passes the invocation record as the detail in the PutEvents call.
                
                  The value for the source event field is lambda.
                
                  The value for the detail-type event field is either "Lambda Function
                    Invocation Result - Success" or "Lambda Function Invocation Result - Failure".
                
                  The resource event field contains the function and destination
                    Amazon Resource Names (ARNs).
                
                  For other event fields, see Amazon EventBridge events.
                
            
          
        
    NoteFor Amazon S3 destinations, if you have enabled encryption on the bucket using a KMS key, your function also needs the 
        kms:GenerateDataKey permission.
    The following steps describe how to configure a destination for a function using the Lambda console and the AWS CLI.
    
      Console
          Open the Functions page of the Lambda console.
              Choose a function.
            
              Under Function overview, choose Add destination.
            
              For Source, choose Asynchronous invocation.
            
              For Condition, choose from the following options:
              
                 
                 
              
                  On failure – Send a record when the event fails all processing attempts or
                    exceeds the maximum age.
                
                  On success – Send a record when the function successfully processes an
                    asynchronous invocation.
                
            
              For Destination type, choose the type of resource that receives the invocation
                record.
            
              For Destination, choose a resource.
            
              Choose Save.
            
        
      AWS CLI
          To configure a destination using the AWS CLI, run the update-function-event-invoke-config command. The following example configures Lambda to send a record to a standard
            SQS queue named destination when an event can't be processed.
          aws lambda update-function-event-invoke-config \
  --function-name my-function \
  --destination-config '{"OnFailure":{"Destination": "arn:aws:sqs:us-east-1:123456789012:destination"}}'
        
    
     
      Security best practices for Amazon S3 destinations
       Deleting an S3 bucket that's configured as a destination without removing the destination from your function's configuration can create a security risk. If another 
      user knows your destination bucket's name, they can recreate the bucket in their AWS account. Records of failed invocations will be sent to their bucket, potentially 
      exposing data from your function.
      WarningTo ensure that invocation records from your function can't be sent to an S3 bucket in another AWS account, add a condition to your function's execution role 
        that limits s3:PutObject permissions to buckets in your account. 
      The following example shows an IAM policy that limits your function's s3:PutObject permissions to buckets in your account. This policy also gives Lambda
        the s3:ListBucket permission it needs to use an S3 bucket as a destination.
      {
    "Version": "2012-10-17",
    "Statement": [
        {
            "Sid": "S3BucketResourceAccountWrite",
            "Effect": "Allow",
            "Action": [
                "s3:PutObject",
                "s3:ListBucket"
            ],
            "Resource": [
                "arn:aws:s3:::*/*",
                "arn:aws:s3:::*"
            ],
            "Condition": {
                "StringEquals": {
                    "s3:ResourceAccount": "111122223333"
                }
            }
        }
    ]
}
      To add a permissions policy to your funcion's execution role using the AWS Management Console or AWS CLI, refer to the instructions in the following procedures:
      
        Console
            To add a permissions policy to a function's execution role (console)Open the Functions page of the Lambda console.
                Select the Lambda function whose execution role you want to modify.
              
                In the Configuration tab, select Permissions.
              
                In the Execution role tab, select your function's Role name to open the role's IAM console page.
              
                Add a permissions policy to the role by doing the following:
                
                    In the Permissions policies pane, choose Add permissions and select Create inline policy. 
                  
                    In Policy editor, select JSON.
                  
                    Paste the policy you want to add into the editor (replacing the existing JSON), and then choose Next.
                  
                    Under Policy details, enter a Policy name.
                  
                    Choose Create policy.
                  
              
          
        AWS CLI
            To add a permissions policy to a function's execution role (CLI)
                Create a JSON policy document with the required permissions and save it in a local directory.
              
                Use the IAM put-role-policy CLI command to add the permissions to your function's execution role. Run the following command from the 
                directory you saved your JSON policy document in and replace the role name, policy name, and policy document with your own values.
                aws iam put-role-policy \
--role-name my_lambda_role \
--policy-name LambdaS3DestinationPolicy \
--policy-document file://my_policy.json
              
          
      
     
     
      Example invocation record
    When an invocation matches the condition, Lambda sends a JSON document with details about the invocation to the destination. The following example shows an invocation record for an event that failed three processing attempts due to a function error.
    {
    "version": "1.0",
    "timestamp": "2019-11-14T18:16:05.568Z",
    "requestContext": {
        "requestId": "e4b46cbf-b738-xmpl-8880-a18cdf61200e",
        "functionArn": "arn:aws:lambda:us-east-1:123456789012:function:my-function:$LATEST",
        "condition": "RetriesExhausted",
        "approximateInvokeCount": 3
    },
    "requestPayload": {
        "ORDER_IDS": [
            "9e07af03-ce31-4ff3-xmpl-36dce652cb4f",
            "637de236-e7b2-464e-xmpl-baf57f86bb53",
            "a81ddca6-2c35-45c7-xmpl-c3a03a31ed15"
        ]
    },
    "responseContext": {
        "statusCode": 200,
        "executedVersion": "$LATEST",
        "functionError": "Unhandled"
    },
    "responsePayload": {
        "errorMessage": "RequestId: e4b46cbf-b738-xmpl-8880-a18cdf61200e Process exited before completing request"
    }
}
    The invocation record contains details about the event, the response, and the reason that the record was
      sent.
     
       
        Tracing requests to destinations
        You can use AWS X-Ray
        to see a connected view of each request as it's queued, processed by a Lambda function, and passed to the
        destination service. When you activate X-Ray tracing for a function or a service that invokes a function, Lambda
        adds an X-Ray header to the request and passes the header to the destination service. Traces from upstream
        services are automatically linked to traces from downstream Lambda functions and destination services, creating
        an end-to-end view of the entire application. For more information about tracing, see Visualize Lambda function invocations using AWS X-Ray.
       
   
    Adding a dead-letter queue
    
    As an alternative to an on-failure destination, you can
      configure your function with a dead-letter queue to save discarded events for further processing. A dead-letter
      queue acts the same as an on-failure destination in that it is used when an event fails all processing attempts or
      expires without being processed. However, you can only add or remove a dead-letter queue at the function level. Function versions use the same dead-letter queue settings as the unpublished version ($LATEST). On-failure destinations also support additional
      targets and include details about the function's response in the invocation record.
    
    To reprocess events in a dead-letter queue, you can set it as an event source for your Lambda function.
      Alternatively, you can manually retrieve the events.
    
    You can choose an Amazon SQS standard queue or Amazon SNS standard topic for your dead-letter queue. FIFO queues and 
      Amazon SNS FIFO topics are not supported.
    
       
       
    
        Amazon SQS queue – A queue holds failed events
          until they're retrieved. Choose an Amazon SQS standard queue if you expect a single entity, such as a Lambda function or CloudWatch
          alarm, to process the failed event. For more information, see Using Lambda with Amazon SQS.
      
        Amazon SNS topic – A topic relays failed events to
          one or more destinations. Choose an Amazon SNS standard topic if you expect multiple entities to act on a failed event. For
          example, you can configure a topic to send events to an email address, a Lambda function, and/or an HTTP
          endpoint. For more information, see Invoking Lambda functions with Amazon SNS notifications.
      
    
    To send events to a queue or topic, your function needs additional permissions. Add a policy with the
       required permissions to your function's
      execution role. If the target queue or topic
      is encrypted with a customer managed AWS KMS key, ensure that both your function's execution role and the key's
      resource-based policy contains the relevant permissions.
    
    After creating the target and updating your function's execution role, add the dead-letter queue to your
      function. You can configure multiple functions to send events to the same target.
    
      Console
           Open the Functions page of the Lambda console. 
              Choose a function.
            
              Choose Configuration and then choose Asynchronous
                invocation.
            
              Under Asynchronous invocation, choose Edit.
            
              Set Dead-letter queue service to Amazon SQS or Amazon SNS.
            
              Choose the target queue or topic.
            
              Choose Save.
            
        
      AWS CLI
          To configure a dead-letter queue with the AWS CLI, use the update-function-configuration command.
          aws lambda update-function-configuration \
  --function-name my-function \
  --dead-letter-config TargetArn=arn:aws:sns:us-east-1:123456789012:my-topic
        
    
    
    Lambda sends the event to the dead-letter queue as-is, with additional information in attributes. You can use
      this information to identify the error that the function returned, or to correlate the event with logs or an
      AWS X-Ray trace.
    
      Dead-letter queue message attributes
       
       
       
    
        RequestID (String) – The ID of the invocation request. Request IDs
          appear in function logs. You can also use the X-Ray SDK to record the request ID on an attribute in the
          trace. You can then search for traces by request ID in the X-Ray console.
      
        ErrorCode (Number) – The HTTP status code.
      
        ErrorMessage (String) – The first 1 KB of the error
          message.
      
    
    If Lambda can't send a message to the dead-letter queue, it deletes the event and emits the DeadLetterErrors metric. This can happen because of lack of permissions, or
      if the total size of the message exceeds the limit for the target queue or topic. For example, say that an Amazon SNS
      notification with a body close to 256 KB in size triggers a function that results in an error. In
      that case, the event data that Amazon SNS adds, combined with the attributes that Lambda adds, can cause the message to
      exceed the maximum size allowed in the dead-letter queue.
    If you're using Amazon SQS as an event source, configure a dead-letter queue on the Amazon SQS queue itself and not on
      the Lambda function. For more information, see Using Lambda with Amazon SQS.
  Document ConventionsConfigurationEvent source mappingsDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideInvoking a Lambda function asynchronouslySeveral AWS services, such as Amazon Simple Storage Service (Amazon S3) and Amazon Simple Notification Service (Amazon SNS), invoke functions asynchronously to
    process events. You can also invoke a Lambda function asynchronously using the AWS Command Line Interface (AWS CLI) or one of the AWS SDKs. 
    When you invoke a function asynchronously, you don't wait for a response from the function code. You
    hand off the event to Lambda and Lambda handles the rest. You can configure how Lambda handles errors, and can send
    invocation records to a downstream resource such as Amazon Simple Queue Service (Amazon SQS) or Amazon EventBridge (EventBridge) to chain together
    components of your application.The following diagram shows clients invoking a Lambda function asynchronously. Lambda queues the events before
    sending them to the function.
     
      
     
     
  For asynchronous invocation, Lambda places the event in a queue and returns a success response without
    additional information. A separate process reads events from the queue and sends them to your function. To invoke a Lambda function asynchronously using the AWS Command Line Interface (AWS CLI) or one of the AWS SDKs, set the InvocationType parameter to Event. The 
    following example shows an AWS CLI command to invoke a function.aws lambda invoke \
  --function-name my-function  \
  --invocation-type Event \
  --cli-binary-format raw-in-base64-out \
  --payload '{ "key": "value" }' response.json
  You should see the following output:{
    "StatusCode": 202
}The cli-binary-format option is required if you're using AWS CLI version 2. To make this the default setting, run aws configure set cli-binary-format raw-in-base64-out. For more information, see AWS CLI supported global command line options in the AWS Command Line Interface User Guide for Version 2.The output file (response.json) doesn't contain any information, but is still created when you
      run this command. If Lambda isn't able to add the event to the queue, the error message appears in the command
      output.Document ConventionsInvoke a function synchronouslyError handlingDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideConfiguring your function to work with RDS resourcesConnecting to an Amazon RDS database in a Lambda functionProcessing event notifications from Amazon RDSComplete Lambda and Amazon RDS tutorialUsing AWS Lambda with Amazon RDSYou can connect a Lambda function to an Amazon Relational Database Service (Amazon RDS) database directly and through
    an Amazon RDS Proxy. Direct connections are useful in simple scenarios, and proxies are recommended
    for production. A database proxy manages a pool of shared database connections which enables
    your function to reach high concurrency levels without exhausting database connections.We recommend using Amazon RDS Proxy for Lambda functions that make frequent short database
    connections, or open and close large numbers of database connections. For more information,
    see 
      Automatically connecting a Lambda function and a DB instance in the Amazon Relational Database Service Developer Guide.TipTo quickly connect a Lambda function to an Amazon RDS database, you can use the in-console guided wizard. To open the wizard, do the following:Open the Functions page of the Lambda console.
        Select the function you want to connect a database to.
      
        On the Configuration tab, select RDS databases.
      
        Choose Connect to RDS database.
      After you've connected your function to a database, you can create a proxy by choosing Add proxy.
    Configuring your function to work with RDS resources
    In the Lambda console, you can provision, and configure, Amazon RDS database instances and
      proxy resources. You can do this by navigating to RDS databases under
      the Configuration tab. Alternatively, you can also create and configure
      connections to Lambda functions in the Amazon RDS console. When configuring an RDS database
      instance to use with Lambda, note the following criteria:
    
       
       
       
             
       
       
    
        To connect to a database, your function must be in the same Amazon VPC where your
          database runs.
      
        You can use Amazon RDS databases with MySQL, MariaDB, PostgreSQL, or Microsoft SQL Server
          engines. 
      
        You can also use Aurora DB clusters with MySQL or PostgreSQL engines.
      
        You need to provide a Secrets Manager secret for database authentication.
      
        An IAM role must provide permission to use the secret, and a trust policy must
          allow Amazon RDS to assume the role.
      
        
          The IAM principal that uses the console to configure the Amazon RDS resource, and connect
          it to your function must have the following permissions:
      
    Note
          You need the Amazon RDS Proxy permissions only if you configure an Amazon RDS Proxy to 
          manage a pool of your database connections.
        {
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Action": [
        "ec2:CreateSecurityGroup",
        "ec2:DescribeSecurityGroups",
        "ec2:DescribeSubnets",
        "ec2:DescribeVpcs",
        "ec2:AuthorizeSecurityGroupIngress",
        "ec2:AuthorizeSecurityGroupEgress",
        "ec2:RevokeSecurityGroupEgress",
        "ec2:CreateNetworkInterface",
        "ec2:DeleteNetworkInterface",
        "ec2:DescribeNetworkInterfaces"
      ],
      "Resource": "*"
    },
    {
      "Effect": "Allow",
      "Action": [
        "rds-db:connect",
        "rds:CreateDBProxy",
        "rds:CreateDBInstance",
        "rds:CreateDBSubnetGroup",
        "rds:DescribeDBClusters",
        "rds:DescribeDBInstances",
        "rds:DescribeDBSubnetGroups",
        "rds:DescribeDBProxies",
        "rds:DescribeDBProxyTargets",
        "rds:DescribeDBProxyTargetGroups",
        "rds:RegisterDBProxyTargets",
        "rds:ModifyDBInstance",
        "rds:ModifyDBProxy"
      ],
      "Resource": "*"
    },
    {
      "Effect": "Allow",
      "Action": [
        "lambda:CreateFunction",
        "lambda:ListFunctions",
        "lambda:UpdateFunctionConfiguration"
      ],
      "Resource": "*"
    },
    {
      "Effect": "Allow",
      "Action": [
        "iam:AttachRolePolicy",
        "iam:AttachPolicy",
        "iam:CreateRole",
        "iam:CreatePolicy"
      ],
      "Resource": "*"
    },
    {
      "Effect": "Allow",
      "Action": [
        "secretsmanager:GetResourcePolicy",
        "secretsmanager:GetSecretValue",
        "secretsmanager:DescribeSecret",
        "secretsmanager:ListSecretVersionIds",
        "secretsmanager:CreateSecret"
      ],
      "Resource": "*"
    }
  ]
}Amazon RDS charges an hourly rate for proxies based on the database instance size, see RDS Proxy pricing for details.
        For more information on proxy connections in general, see Using Amazon RDS Proxy in the Amazon RDS User Guide.
     
      SSL/TLS requirements for Amazon RDS connections
      To make secure SSL/TLS connections to an Amazon RDS database instance, your Lambda function must verify the database server's identity using a trusted certificate. Lambda handles these certificates differently depending on your deployment package type:
      
         
         
      
          .zip file archives: Lambda's managed runtimes include both Certificate Authority (CA) certificates and the  certificates required for connections to Amazon RDS database instances. It might take up to 4 weeks for Amazon RDS certificates for new AWS Regions to be added to the Lambda managed runtimes.
        
          Container images: AWS base images include only CA certificates. If your function connects to an Amazon RDS database instance, you must include the appropriate certificates in your container image. In your Dockerfile, download the certificate bundle that corresponds with the AWS Region where you host your database. Example:
          RUN curl https://truststore.pki.rds.amazonaws.com/us-east-1/us-east-1-bundle.pem -o /us-east-1-bundle.pem
        
      This command downloads the Amazon RDS certificate bundle and saves it at the absolute path /us-east-1-bundle.pem in your container's root directory. When configuring the database connection in your function code, you must reference this exact path. Example:
      
        Node.js
            The readFileSync function is required because Node.js database clients need the actual certificate content in memory, not just the path to the certificate file. Without readFileSync, the client interprets the path string as certificate content, resulting in a "self-signed certificate in certificate chain" error.
            Example Node.js connection config for OCI functionimport { readFileSync } from 'fs';

// ...

let connectionConfig = {
    host: process.env.ProxyHostName,
    user: process.env.DBUserName,
    password: token,
    database: process.env.DBName,
    ssl: {
        ca: readFileSync('/us-east-1-bundle.pem') // Load RDS certificate content from file into memory
    }
};
          
        Python
            Example Python connection config for OCI functionconnection = pymysql.connect(
    host=proxy_host_name,
    user=db_username,
    password=token,
    db=db_name,
    port=port,
    ssl={'ca': '/us-east-1-bundle.pem'}  #Path to the certificate in container
)
          
        Java
            For Java functions using JDBC connections, the connection string must include:
            
               
               
               
            
                useSSL=true
              
                requireSSL=true
              
                An sslCA parameter that points to the location of the Amazon RDS certificate in the container image
              
            Example Java connection string for OCI function// Define connection string
String connectionString = String.format("jdbc:mysql://%s:%s/%s?useSSL=true&requireSSL=true&sslCA=/us-east-1-bundle.pem", // Path to the certificate in container
        System.getenv("ProxyHostName"),
        System.getenv("Port"),
        System.getenv("DBName"));
          
        .NET
            Example .NET connection string for MySQL connection in OCI function/// Build the Connection String with the Token 
string connectionString = $"Server={Environment.GetEnvironmentVariable("RDS_ENDPOINT")};" +
                         $"Port={Environment.GetEnvironmentVariable("RDS_PORT")};" +
                         $"Uid={Environment.GetEnvironmentVariable("RDS_USERNAME")};" +
                         $"Pwd={authToken};" +
                         "SslMode=Required;" +
                         "SslCa=/us-east-1-bundle.pem";  // Path to the certificate in container
          
        Go
            For Go functions using MySQL connections, load the Amazon RDS certificate into a certificate pool and register it with the MySQL driver. The connection string must then reference this configuration using the tls parameter.
            Example Go code for MySQL connection in OCI functionimport (
    "crypto/tls"
    "crypto/x509"
    "os"
    "github.com/go-sql-driver/mysql"
)

...

// Create certificate pool and register TLS config
rootCertPool := x509.NewCertPool()
pem, err := os.ReadFile("/us-east-1-bundle.pem")  // Path to the certificate in container
if err != nil {
    panic("failed to read certificate file: " + err.Error())
}
if ok := rootCertPool.AppendCertsFromPEM(pem); !ok {
    panic("failed to append PEM")
}

mysql.RegisterTLSConfig("custom", &tls.Config{
    RootCAs: rootCertPool,
})

dsn := fmt.Sprintf("%s:%s@tcp(%s)/%s?allowCleartextPasswords=true&tls=custom",
    dbUser, authenticationToken, dbEndpoint, dbName,
)
          
        Ruby
            Example Ruby connection config for OCI functionconn = Mysql2::Client.new(
    host: endpoint,
    username: user,
    password: token,
    port: port,
    database: db_name,
    sslca: '/us-east-1-bundle.pem',  # Path to the certificate in container
    sslverify: true
)
           
      
         
   
    Connecting to an Amazon RDS database in a Lambda function
    The following code examples shows how to implement a Lambda function that connects
      to an Amazon RDS database. The function makes a simple database request and returns the result.
    NoteThese code examples are valid for .zip deployment packages only. If you're deploying your function using a container image, you must specify the Amazon RDS certificate file in your function code, as explained in the preceding section.
    
    .NET
            
     

        SDK for .NET
        
Note
        There's more on GitHub. Find the complete example and learn how to set up and run in the
        Serverless examples
        repository.
    
             
                    Connecting to an Amazon RDS database in a Lambda function using .NET.
                
                using System.Data;
using System.Text.Json;
using Amazon.Lambda.APIGatewayEvents;
using Amazon.Lambda.Core;
using MySql.Data.MySqlClient;

// Assembly attribute to enable the Lambda function's JSON input to be converted into a .NET class.
[assembly: LambdaSerializer(typeof(Amazon.Lambda.Serialization.SystemTextJson.DefaultLambdaJsonSerializer))]

namespace aws_rds;

public class InputModel
{
    public string key1 { get; set; }
    public string key2 { get; set; }
}

public class Function
{
    /// <summary>
    // Handles the Lambda function execution for connecting to RDS using IAM authentication.
    /// </summary>
    /// <param name="input">The input event data passed to the Lambda function</param>
    /// <param name="context">The Lambda execution context that provides runtime information</param>
    /// <returns>A response object containing the execution result</returns>

    public async Task<APIGatewayProxyResponse> FunctionHandler(APIGatewayProxyRequest request, ILambdaContext context)
    {
        // Sample Input: {"body": "{\"key1\":\"20\", \"key2\":\"25\"}"}
        var input = JsonSerializer.Deserialize<InputModel>(request.Body);

        /// Obtain authentication token
        var authToken = RDSAuthTokenGenerator.GenerateAuthToken(
            Environment.GetEnvironmentVariable("RDS_ENDPOINT"),
            Convert.ToInt32(Environment.GetEnvironmentVariable("RDS_PORT")),
            Environment.GetEnvironmentVariable("RDS_USERNAME")
        );

        /// Build the Connection String with the Token 
        string connectionString = $"Server={Environment.GetEnvironmentVariable("RDS_ENDPOINT")};" +
                                  $"Port={Environment.GetEnvironmentVariable("RDS_PORT")};" +
                                  $"Uid={Environment.GetEnvironmentVariable("RDS_USERNAME")};" +
                                  $"Pwd={authToken};";


        try
        {
            await using var connection = new MySqlConnection(connectionString);
            await connection.OpenAsync();

            const string sql = "SELECT @param1 + @param2 AS Sum";

            await using var command = new MySqlCommand(sql, connection);
            command.Parameters.AddWithValue("@param1", int.Parse(input.key1 ?? "0"));
            command.Parameters.AddWithValue("@param2", int.Parse(input.key2 ?? "0"));

            await using var reader = await command.ExecuteReaderAsync();
            if (await reader.ReadAsync())
            {
                int result = reader.GetInt32("Sum");

                //Sample Response: {"statusCode":200,"body":"{\"message\":\"The sum is: 45\"}","isBase64Encoded":false}
                return new APIGatewayProxyResponse
                {
                    StatusCode = 200,
                    Body = JsonSerializer.Serialize(new { message = $"The sum is: {result}" })
                };
            }

        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error: {ex.Message}");
        }

        return new APIGatewayProxyResponse
        {
            StatusCode = 500,
            Body = JsonSerializer.Serialize(new { error = "Internal server error" })
        };
    }
}


             
        
    
        
    Go
            
     

        SDK for Go V2
        
Note
        There's more on GitHub. Find the complete example and learn how to set up and run in the
        Serverless examples
        repository.
    
             
                    Connecting to an Amazon RDS database in a Lambda function using Go.
                
                /*
Golang v2 code here.
*/

package main

import (
	"context"
	"database/sql"
	"encoding/json"
	"fmt"
	"os"

	"github.com/aws/aws-lambda-go/lambda"
	"github.com/aws/aws-sdk-go-v2/config"
	"github.com/aws/aws-sdk-go-v2/feature/rds/auth"
	_ "github.com/go-sql-driver/mysql"
)

type MyEvent struct {
	Name string `json:"name"`
}

func HandleRequest(event *MyEvent) (map[string]interface{}, error) {

	var dbName string = os.Getenv("DatabaseName")
	var dbUser string = os.Getenv("DatabaseUser")
	var dbHost string = os.Getenv("DBHost") // Add hostname without https
	var dbPort int = os.Getenv("Port")      // Add port number
	var dbEndpoint string = fmt.Sprintf("%s:%d", dbHost, dbPort)
	var region string = os.Getenv("AWS_REGION")

	cfg, err := config.LoadDefaultConfig(context.TODO())
	if err != nil {
		panic("configuration error: " + err.Error())
	}

	authenticationToken, err := auth.BuildAuthToken(
		context.TODO(), dbEndpoint, region, dbUser, cfg.Credentials)
	if err != nil {
		panic("failed to create authentication token: " + err.Error())
	}

	dsn := fmt.Sprintf("%s:%s@tcp(%s)/%s?tls=true&allowCleartextPasswords=true",
		dbUser, authenticationToken, dbEndpoint, dbName,
	)

	db, err := sql.Open("mysql", dsn)
	if err != nil {
		panic(err)
	}

	defer db.Close()

	var sum int
	err = db.QueryRow("SELECT ?+? AS sum", 3, 2).Scan(&sum)
	if err != nil {
		panic(err)
	}
	s := fmt.Sprint(sum)
	message := fmt.Sprintf("The selected sum is: %s", s)

	messageBytes, err := json.Marshal(message)
	if err != nil {
		return nil, err
	}

	messageString := string(messageBytes)
	return map[string]interface{}{
		"statusCode": 200,
		"headers":    map[string]string{"Content-Type": "application/json"},
		"body":       messageString,
	}, nil
}

func main() {
	lambda.Start(HandleRequest)
}


             
        
    
        
    Java
            
     

        SDK for Java 2.x
        
Note
        There's more on GitHub. Find the complete example and learn how to set up and run in the
        Serverless examples
        repository.
    
             
                    Connecting to an Amazon RDS database in a Lambda function using Java.
                
                import com.amazonaws.services.lambda.runtime.Context;
import com.amazonaws.services.lambda.runtime.RequestHandler;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyRequestEvent;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyResponseEvent;
import software.amazon.awssdk.auth.credentials.DefaultCredentialsProvider;
import software.amazon.awssdk.regions.Region;
import software.amazon.awssdk.services.rdsdata.RdsDataClient;
import software.amazon.awssdk.services.rdsdata.model.ExecuteStatementRequest;
import software.amazon.awssdk.services.rdsdata.model.ExecuteStatementResponse;
import software.amazon.awssdk.services.rdsdata.model.Field;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;

public class RdsLambdaHandler implements RequestHandler<APIGatewayProxyRequestEvent, APIGatewayProxyResponseEvent> {

    @Override
    public APIGatewayProxyResponseEvent handleRequest(APIGatewayProxyRequestEvent event, Context context) {
        APIGatewayProxyResponseEvent response = new APIGatewayProxyResponseEvent();

        try {
            // Obtain auth token
            String token = createAuthToken();

            // Define connection configuration
            String connectionString = String.format("jdbc:mysql://%s:%s/%s?useSSL=true&requireSSL=true",
                    System.getenv("ProxyHostName"),
                    System.getenv("Port"),
                    System.getenv("DBName"));

            // Establish a connection to the database
            try (Connection connection = DriverManager.getConnection(connectionString, System.getenv("DBUserName"), token);
                 PreparedStatement statement = connection.prepareStatement("SELECT ? + ? AS sum")) {

                statement.setInt(1, 3);
                statement.setInt(2, 2);

                try (ResultSet resultSet = statement.executeQuery()) {
                    if (resultSet.next()) {
                        int sum = resultSet.getInt("sum");
                        response.setStatusCode(200);
                        response.setBody("The selected sum is: " + sum);
                    }
                }
            }

        } catch (Exception e) {
            response.setStatusCode(500);
            response.setBody("Error: " + e.getMessage());
        }

        return response;
    }

    private String createAuthToken() {
        // Create RDS Data Service client
        RdsDataClient rdsDataClient = RdsDataClient.builder()
                .region(Region.of(System.getenv("AWS_REGION")))
                .credentialsProvider(DefaultCredentialsProvider.create())
                .build();

        // Define authentication request
        ExecuteStatementRequest request = ExecuteStatementRequest.builder()
                .resourceArn(System.getenv("ProxyHostName"))
                .secretArn(System.getenv("DBUserName"))
                .database(System.getenv("DBName"))
                .sql("SELECT 'RDS IAM Authentication'")
                .build();

        // Execute request and obtain authentication token
        ExecuteStatementResponse response = rdsDataClient.executeStatement(request);
        Field tokenField = response.records().get(0).get(0);

        return tokenField.stringValue();
    }
}


             
        
    
        
    JavaScript
            
     

        SDK for JavaScript (v3)
        
Note
        There's more on GitHub. Find the complete example and learn how to set up and run in the
        Serverless examples
        repository.
    
             
                    Connecting to an Amazon RDS database in a Lambda function using JavaScript.
                
                // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
/* 
Node.js code here.
*/
// ES6+ example
import { Signer } from "@aws-sdk/rds-signer";
import mysql from 'mysql2/promise';

async function createAuthToken() {
  // Define connection authentication parameters
  const dbinfo = {

    hostname: process.env.ProxyHostName,
    port: process.env.Port,
    username: process.env.DBUserName,
    region: process.env.AWS_REGION,

  }

  // Create RDS Signer object
  const signer = new Signer(dbinfo);

  // Request authorization token from RDS, specifying the username
  const token = await signer.getAuthToken();
  return token;
}

async function dbOps() {

  // Obtain auth token
  const token = await createAuthToken();
  // Define connection configuration
  let connectionConfig = {
    host: process.env.ProxyHostName,
    user: process.env.DBUserName,
    password: token,
    database: process.env.DBName,
    ssl: 'Amazon RDS'
  }
  // Create the connection to the DB
  const conn = await mysql.createConnection(connectionConfig);
  // Obtain the result of the query
  const [res,] = await conn.execute('select ?+? as sum', [3, 2]);
  return res;

}

export const handler = async (event) => {
  // Execute database flow
  const result = await dbOps();
  // Return result
  return {
    statusCode: 200,
    body: JSON.stringify("The selected sum is: " + result[0].sum)
  }
};


             
             
                    Connecting to an Amazon RDS database in a Lambda function using TypeScript.
                
                
import { Signer } from "@aws-sdk/rds-signer";
import mysql from 'mysql2/promise';

// RDS settings
// Using '!' (non-null assertion operator) to tell the TypeScript compiler that the DB settings are not null or undefined,
const proxy_host_name = process.env.PROXY_HOST_NAME!
const port = parseInt(process.env.PORT!)
const db_name = process.env.DB_NAME!
const db_user_name = process.env.DB_USER_NAME!
const aws_region = process.env.AWS_REGION!


async function createAuthToken(): Promise<string> {

    // Create RDS Signer object
    const signer = new Signer({
        hostname: proxy_host_name,
        port: port,
        region: aws_region,
        username: db_user_name
    });

    // Request authorization token from RDS, specifying the username
    const token = await signer.getAuthToken();
    return token;
}

async function dbOps(): Promise<mysql.QueryResult | undefined> {
    try {
        // Obtain auth token
        const token = await createAuthToken();
        const conn = await mysql.createConnection({
            host: proxy_host_name,
            user: db_user_name,
            password: token,
            database: db_name,
            ssl: 'Amazon RDS' // Ensure you have the CA bundle for SSL connection
        });
        const [rows, fields] = await conn.execute('SELECT ? + ? AS sum', [3, 2]);
        console.log('result:', rows);
        return rows;
    }
    catch (err) {
        console.log(err);
    }
}

export const lambdaHandler = async (event: any): Promise<{ statusCode: number; body: string }> => {
    // Execute database flow
    const result = await dbOps();

    // Return error is result is undefined
    if (result == undefined)
        return {
            statusCode: 500,
            body: JSON.stringify(`Error with connection to DB host`)
        }

    // Return result
    return {
        statusCode: 200,
        body: JSON.stringify(`The selected sum is: ${result[0].sum}`)
    };
};

             
        
    
        
    PHP
            
     

        SDK for PHP
        
Note
        There's more on GitHub. Find the complete example and learn how to set up and run in the
        Serverless examples
        repository.
    
             
                    Connecting to an Amazon RDS database in a Lambda function using PHP.
                
                <?php
# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
# SPDX-License-Identifier: Apache-2.0

# using bref/bref and bref/logger for simplicity

use Bref\Context\Context;
use Bref\Event\Handler as StdHandler;
use Bref\Logger\StderrLogger;
use Aws\Rds\AuthTokenGenerator;
use Aws\Credentials\CredentialProvider;

require __DIR__ . '/vendor/autoload.php';

class Handler implements StdHandler
{
    private StderrLogger $logger;
    public function __construct(StderrLogger $logger)
    {
        $this->logger = $logger;
    }


    private function getAuthToken(): string {
        // Define connection authentication parameters
        $dbConnection = [
            'hostname' => getenv('DB_HOSTNAME'),
            'port' => getenv('DB_PORT'),
            'username' => getenv('DB_USERNAME'),
            'region' => getenv('AWS_REGION'),
        ];

        // Create RDS AuthTokenGenerator object
        $generator = new AuthTokenGenerator(CredentialProvider::defaultProvider());

        // Request authorization token from RDS, specifying the username
        return $generator->createToken(
            $dbConnection['hostname'] . ':' . $dbConnection['port'],
            $dbConnection['region'],
            $dbConnection['username']
        );
    }

    private function getQueryResults() {
        // Obtain auth token
        $token = $this->getAuthToken();

        // Define connection configuration
        $connectionConfig = [
            'host' => getenv('DB_HOSTNAME'),
            'user' => getenv('DB_USERNAME'),
            'password' => $token,
            'database' => getenv('DB_NAME'),
        ];

        // Create the connection to the DB
        $conn = new PDO(
            "mysql:host={$connectionConfig['host']};dbname={$connectionConfig['database']}",
            $connectionConfig['user'],
            $connectionConfig['password'],
            [
                PDO::MYSQL_ATTR_SSL_CA => '/path/to/rds-ca-2019-root.pem',
                PDO::MYSQL_ATTR_SSL_VERIFY_SERVER_CERT => true,
            ]
        );

        // Obtain the result of the query
        $stmt = $conn->prepare('SELECT ?+? AS sum');
        $stmt->execute([3, 2]);

        return $stmt->fetch(PDO::FETCH_ASSOC);
    }

    /**
     * @param mixed $event
     * @param Context $context
     * @return array
     */
    public function handle(mixed $event, Context $context): array
    {
        $this->logger->info("Processing query");

        // Execute database flow
        $result = $this->getQueryResults();

        return [
            'sum' => $result['sum']
        ];
    }
}

$logger = new StderrLogger();
return new Handler($logger);

             
        
    
        
    Python
            
     

        SDK for Python (Boto3)
        
Note
        There's more on GitHub. Find the complete example and learn how to set up and run in the
        Serverless examples
        repository.
    
             
                    Connecting to an Amazon RDS database in a Lambda function using Python.
                
                import json
import os
import boto3
import pymysql

# RDS settings
proxy_host_name = os.environ['PROXY_HOST_NAME']
port = int(os.environ['PORT'])
db_name = os.environ['DB_NAME']
db_user_name = os.environ['DB_USER_NAME']
aws_region = os.environ['AWS_REGION']


# Fetch RDS Auth Token
def get_auth_token():
    client = boto3.client('rds')
    token = client.generate_db_auth_token(
        DBHostname=proxy_host_name,
        Port=port
        DBUsername=db_user_name
        Region=aws_region
    )
    return token

def lambda_handler(event, context):
    token = get_auth_token()
    try:
        connection = pymysql.connect(
            host=proxy_host_name,
            user=db_user_name,
            password=token,
            db=db_name,
            port=port,
            ssl={'ca': 'Amazon RDS'}  # Ensure you have the CA bundle for SSL connection
        )
        
        with connection.cursor() as cursor:
            cursor.execute('SELECT %s + %s AS sum', (3, 2))
            result = cursor.fetchone()

        return result
        
    except Exception as e:
        return (f"Error: {str(e)}")  # Return an error message if an exception occurs 
    

             
        
    
        
    Ruby
            
     

        SDK for Ruby
        
Note
        There's more on GitHub. Find the complete example and learn how to set up and run in the
        Serverless examples
        repository.
    
             
                    Connecting to an Amazon RDS database in a Lambda function using Ruby.
                
                # Ruby code here.

require 'aws-sdk-rds'
require 'json'
require 'mysql2'

def lambda_handler(event:, context:)
  endpoint = ENV['DBEndpoint'] # Add the endpoint without https"
  port = ENV['Port']           # 3306
  user = ENV['DBUser']
  region = ENV['DBRegion']     # 'us-east-1'
  db_name = ENV['DBName']

  credentials = Aws::Credentials.new(
    ENV['AWS_ACCESS_KEY_ID'],
    ENV['AWS_SECRET_ACCESS_KEY'],
    ENV['AWS_SESSION_TOKEN']
  )
  rds_client = Aws::RDS::AuthTokenGenerator.new(
    region: region, 
    credentials: credentials
  )

  token = rds_client.auth_token(
    endpoint: endpoint+ ':' + port,
    user_name: user,
    region: region
  )

  begin
    conn = Mysql2::Client.new(
      host: endpoint,
      username: user,
      password: token,
      port: port,
      database: db_name,
      sslca: '/var/task/global-bundle.pem', 
      sslverify: true,
      enable_cleartext_plugin: true
    )
    a = 3
    b = 2
    result = conn.query("SELECT #{a} + #{b} AS sum").first['sum']
    puts result
    conn.close
    {
      statusCode: 200,
      body: result.to_json
    }
  rescue => e
    puts "Database connection failed due to #{e}"
  end
end

             
        
    
        
    Rust
            
     

        SDK for Rust
        
Note
        There's more on GitHub. Find the complete example and learn how to set up and run in the
        Serverless examples
        repository.
    
             
                    Connecting to an Amazon RDS database in a Lambda function using Rust.
                
                use aws_config::BehaviorVersion;
use aws_credential_types::provider::ProvideCredentials;
use aws_sigv4::{
    http_request::{sign, SignableBody, SignableRequest, SigningSettings},
    sign::v4,
};
use lambda_runtime::{run, service_fn, Error, LambdaEvent};
use serde_json::{json, Value};
use sqlx::postgres::PgConnectOptions;
use std::env;
use std::time::{Duration, SystemTime};

const RDS_CERTS: &[u8] = include_bytes!("global-bundle.pem");

async fn generate_rds_iam_token(
    db_hostname: &str,
    port: u16,
    db_username: &str,
) -> Result<String, Error> {
    let config = aws_config::load_defaults(BehaviorVersion::v2024_03_28()).await;

    let credentials = config
        .credentials_provider()
        .expect("no credentials provider found")
        .provide_credentials()
        .await
        .expect("unable to load credentials");
    let identity = credentials.into();
    let region = config.region().unwrap().to_string();

    let mut signing_settings = SigningSettings::default();
    signing_settings.expires_in = Some(Duration::from_secs(900));
    signing_settings.signature_location = aws_sigv4::http_request::SignatureLocation::QueryParams;

    let signing_params = v4::SigningParams::builder()
        .identity(&identity)
        .region(&region)
        .name("rds-db")
        .time(SystemTime::now())
        .settings(signing_settings)
        .build()?;

    let url = format!(
        "https://{db_hostname}:{port}/?Action=connect&DBUser={db_user}",
        db_hostname = db_hostname,
        port = port,
        db_user = db_username
    );

    let signable_request =
        SignableRequest::new("GET", &url, std::iter::empty(), SignableBody::Bytes(&[]))
            .expect("signable request");

    let (signing_instructions, _signature) =
        sign(signable_request, &signing_params.into())?.into_parts();

    let mut url = url::Url::parse(&url).unwrap();
    for (name, value) in signing_instructions.params() {
        url.query_pairs_mut().append_pair(name, &value);
    }

    let response = url.to_string().split_off("https://".len());

    Ok(response)
}

#[tokio::main]
async fn main() -> Result<(), Error> {
    run(service_fn(handler)).await
}

async fn handler(_event: LambdaEvent<Value>) -> Result<Value, Error> {
    let db_host = env::var("DB_HOSTNAME").expect("DB_HOSTNAME must be set");
    let db_port = env::var("DB_PORT")
        .expect("DB_PORT must be set")
        .parse::<u16>()
        .expect("PORT must be a valid number");
    let db_name = env::var("DB_NAME").expect("DB_NAME must be set");
    let db_user_name = env::var("DB_USERNAME").expect("DB_USERNAME must be set");

    let token = generate_rds_iam_token(&db_host, db_port, &db_user_name).await?;

    let opts = PgConnectOptions::new()
        .host(&db_host)
        .port(db_port)
        .username(&db_user_name)
        .password(&token)
        .database(&db_name)
        .ssl_root_cert_from_pem(RDS_CERTS.to_vec())
        .ssl_mode(sqlx::postgres::PgSslMode::Require);

    let pool = sqlx::postgres::PgPoolOptions::new()
        .connect_with(opts)
        .await?;

    let result: i32 = sqlx::query_scalar("SELECT $1 + $2")
        .bind(3)
        .bind(2)
        .fetch_one(&pool)
        .await?;

    println!("Result: {:?}", result);

    Ok(json!({
        "statusCode": 200,
        "content-type": "text/plain",
        "body": format!("The selected sum is: {result}")
    }))
}


             
        
    
        

   
    Processing event notifications from Amazon RDS
    
    You can use Lambda to process event notifications from an Amazon RDS database. Amazon RDS sends
      notifications to an Amazon Simple Notification Service (Amazon SNS) topic, which you can configure to invoke a Lambda function.
      Amazon SNS wraps the message from Amazon RDS in its own event document and sends it to your function.
    For more information about configuring an Amazon RDS database to send notifications, see
      Using Amazon RDS
        event notifications.
    
    
    
    Example Amazon RDS message in an Amazon SNS event{
        "Records": [
          {
            "EventVersion": "1.0",
            "EventSubscriptionArn": "arn:aws:sns:us-east-2:123456789012:rds-lambda:21be56ed-a058-49f5-8c98-aedd2564c486",
            "EventSource": "aws:sns",
            "Sns": {
              "SignatureVersion": "1",
              "Timestamp": "2023-01-02T12:45:07.000Z",
              "Signature": "tcc6faL2yUC6dgZdmrwh1Y4cGa/ebXEkAi6RibDsvpi+tE/1+82j...65r==",
              "SigningCertUrl": "https://sns.us-east-2.amazonaws.com/SimpleNotificationService-ac565b8b1a6c5d002d285f9598aa1d9b.pem",
              "MessageId": "95df01b4-ee98-5cb9-9903-4c221d41eb5e",
              "Message": "{\"Event Source\":\"db-instance\",\"Event Time\":\"2023-01-02 12:45:06.000\",\"Identifier Link\":\"https://console.aws.amazon.com/rds/home?region=eu-west-1#dbinstance:id=dbinstanceid\",\"Source ID\":\"dbinstanceid\",\"Event ID\":\"http://docs.amazonwebservices.com/AmazonRDS/latest/UserGuide/USER_Events.html#RDS-EVENT-0002\",\"Event Message\":\"Finished DB Instance backup\"}",
              "MessageAttributes": {},
              "Type": "Notification",
              "UnsubscribeUrl": "https://sns.us-east-2.amazonaws.com/?Action=Unsubscribe&amp;SubscriptionArn=arn:aws:sns:us-east-2:123456789012:test-lambda:21be56ed-a058-49f5-8c98-aedd2564c486",
              "TopicArn":"arn:aws:sns:us-east-2:123456789012:sns-lambda",
              "Subject": "RDS Notification Message"
            }
          }
        ]
      }
    
    
   
    Complete Lambda and Amazon RDS tutorial
    
       
    
        
          Using a Lambda function to access an Amazon RDS database –
          From the Amazon RDS User Guide, learn how to use a Lambda function to write data to an Amazon RDS
          database through an Amazon RDS Proxy. Your Lambda function will read records from an Amazon SQS
          queue and write new items to a table in your database whenever a message is added.
      
  Document ConventionsTutorialAmazon RDS vs DynamoDBDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideBackward compatibilityRuntime update modesTwo-phase runtime version rolloutUnderstanding how Lambda manages runtime version updatesLambda keeps each managed runtime up to date with security updates, bug fixes, new features,
    performance enhancements, and support for minor version releases. These runtime updates are
    published as runtime versions. Lambda applies runtime updates to functions
    by migrating the function from an earlier runtime version to a new runtime version.By default, for functions using managed runtimes, Lambda applies runtime updates automatically. 
    With automatic runtime updates, Lambda takes on the operational burden of patching the
    runtime versions. For most customers, automatic updates are the right choice. You can change
    this default behavior by configuring
      runtime management settings.Lambda also publishes each new runtime version as a container image. To update runtime
    versions for container-based functions, you must create a new
      container image from the updated base image and redeploy your function.Each runtime version is associated with a version number and an ARN (Amazon Resource Name).
    Runtime version numbers use a numbering scheme that Lambda defines, independent of the version
    numbers that the programming language uses. Runtime version numbers are not always sequential. For example, version 42 might be followed by version 45. The runtime version ARN is a unique identifier for
    each runtime version. You can view the ARN of your function's current runtime version in the
    Lambda console, or the INIT_START
      line of your function logs.Runtime versions should not be confused with runtime identifiers. Each runtime has a unique
    runtime identifier, such as python3.13 or 
    nodejs22.x. These correspond to each major programming language release. Runtime
    versions describe the patch version of an individual runtime.NoteThe ARN for the same runtime version number can vary between AWS Regions and CPU
    architectures.TopicsBackward compatibilityRuntime update modesTwo-phase runtime version rolloutConfiguring Lambda runtime management settingsRolling back a Lambda runtime versionIdentifying Lambda runtime version changesUnderstanding the shared responsibility model for Lambda runtime managementControlling Lambda runtime update permissions for high-compliance applications
    Backward compatibility
    Lambda strives to provide runtime updates that are backward compatible with existing functions. However, as with software patching, there are rare cases in which a runtime update can negatively impact an existing function. For example, security patches can expose an underlying issue with an existing function that depends on the previous, insecure behavior.
    When building and deploying your function, it is important to understand how to manage your dependencies to avoid potential incompatibilities with a future runtime update. For example, suppose your function has a dependency on package A, which in turn depends on package B. Both packages are included in the Lambda runtime (for example, they could be parts of the SDK or its dependencies, or parts of the runtime system libraries).
    Consider the following scenarios:
    
          
            Deployment
            Patching compatible
            Reason
          
        
          
            
              
                 
                 
              
                  Package A: Use from runtime
                
                  Package B: Use from runtime
                
            
            Yes
            Future runtime updates to packages A and B are backward compatible.
          
          
            
              
                 
                 
              
                  Package A: In deployment package
                
                  Package B: In deployment package
                
            
            Yes
            Your deployment takes precedence, so future runtime updates to packages A and B
              have no effect.
          
          
            
              
                 
                 
              
                  Package A: In deployment package
                
                  Package B: Use from runtime
                
            
            Yes*
            
              Future runtime updates to package B are backward compatible.
              *If A and B are tightly coupled, compatibility issues can occur. For example, the
                boto3 and botocore packages in the AWS SDK for Python should be deployed
                together.
            
          
          
            
              
                 
                 
              
                  Package A: Use from runtime
                
                  Package B: In deployment package
                
            
            No
            Future runtime updates to package A might require an updated version of package B.
              However, the deployed version of package B takes precedence, and might not be
              forward compatible with the updated version of package A.
          
        
    To maintain compatibility with future runtime updates, follow these best practices:
    
       
       
       
    
        When possible, package all dependencies: Include all required libraries, including the AWS SDK and its dependencies, in your deployment package. This ensures a stable, compatible set of components.
      
        Use runtime-provided SDKs sparingly: Only rely on the runtime-provided SDK when you can't include additional packages (for example, when using the Lambda console code editor or inline code in an AWS CloudFormation template).
      
        Avoid overriding system libraries: Don't deploy custom operating system libraries that may conflict with future runtime updates.
      
   
    Runtime update modes
    Lambda strives to provide runtime updates that are backward compatible with existing
      functions. However, as with software patching, there are rare cases in which a runtime update
      can negatively impact an existing function. For example, security patches can expose an
      underlying issue with an existing function that depends on the previous, insecure behavior.
      Lambda runtime management controls help reduce the risk of impact to your workloads in the rare
      event of a runtime version incompatibility. For each function version ($LATEST or published version), you can choose one of
      the following runtime update modes:
    
       
       
       
    Auto (default) – Automatically update to the most recent
        and secure runtime version using Two-phase runtime version rollout. We recommend this mode for most
        customers so that you always benefit from runtime updates.Function update – Update to the most recent and secure runtime version when you update your function. When you update your function, Lambda
        updates the runtime of your function to the most recent and secure runtime version. This
        approach synchronizes runtime updates with function deployments, giving you control over
        when Lambda applies runtime updates. With this mode, you can detect and mitigate rare
        runtime update incompatibilities early. When using this mode, you must regularly update
        your functions to keep their runtime up to date.Manual – Manually update your runtime version. You specify a runtime version in your function
        configuration. The function uses this runtime version indefinitely. In the rare case in
        which a new runtime version is incompatible with an existing function, you can use this
        mode to roll back your function to an earlier runtime version. We recommend against using
        Manual mode to try to achieve runtime consistency across
        deployments. For more information, see
        Rolling back a Lambda runtime version.
    Responsibility for applying runtime updates to your functions varies according to which runtime update mode you choose. For more information, see 
      Understanding the shared responsibility model for Lambda runtime management.
   
    Two-phase runtime version rollout
    Lambda introduces new runtime versions in the following order:
    
       
       
    In the first
        phase, Lambda applies the new runtime version whenever you create or update a function. A function gets updated when you call the 
        UpdateFunctionCode or UpdateFunctionConfiguration API operations.In the second phase, Lambda updates any function that uses the Auto runtime update mode and that hasn't already
        been updated to the new runtime version. 
    The overall duration of the rollout process varies
      according to multiple factors, including the severity of any security patches included in the
      runtime update.
    If you're actively developing and deploying your functions, you will most likely pick up
      new runtime versions during the first phase. This synchronizes runtime updates with function
      updates. In the rare event that the latest runtime version negatively impacts your
      application, this approach lets you take prompt corrective action. Functions that aren't
      in active development still receive the operational benefit of automatic runtime updates
      during the second phase.
    This approach doesn't affect functions set to Function update or
      Manual mode. Functions using Function update mode
      receive the latest runtime updates only when you create or update them. Functions using
      Manual mode don't receive runtime updates.
    Lambda publishes new runtime versions in a gradual, rolling fashion across AWS Regions.
      If your functions are set to Auto or Function update
      modes, it's possible that functions deployed at the same time to different Regions, or at
      different times in the same Region, will pick up different runtime versions. Customers who
      require guaranteed runtime version consistency across their environments should use container images to deploy their Lambda functions.
      The Manual mode is designed as a temporary mitigation to enable runtime version 
      rollback in the rare event that a runtime version is incompatible with your function.
  Document ConventionsLambda runtimesConfiguring runtime managementDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideBackward compatibilityRuntime update modesTwo-phase runtime version rolloutUnderstanding how Lambda manages runtime version updatesLambda keeps each managed runtime up to date with security updates, bug fixes, new features,
    performance enhancements, and support for minor version releases. These runtime updates are
    published as runtime versions. Lambda applies runtime updates to functions
    by migrating the function from an earlier runtime version to a new runtime version.By default, for functions using managed runtimes, Lambda applies runtime updates automatically. 
    With automatic runtime updates, Lambda takes on the operational burden of patching the
    runtime versions. For most customers, automatic updates are the right choice. You can change
    this default behavior by configuring
      runtime management settings.Lambda also publishes each new runtime version as a container image. To update runtime
    versions for container-based functions, you must create a new
      container image from the updated base image and redeploy your function.Each runtime version is associated with a version number and an ARN (Amazon Resource Name).
    Runtime version numbers use a numbering scheme that Lambda defines, independent of the version
    numbers that the programming language uses. Runtime version numbers are not always sequential. For example, version 42 might be followed by version 45. The runtime version ARN is a unique identifier for
    each runtime version. You can view the ARN of your function's current runtime version in the
    Lambda console, or the INIT_START
      line of your function logs.Runtime versions should not be confused with runtime identifiers. Each runtime has a unique
    runtime identifier, such as python3.13 or 
    nodejs22.x. These correspond to each major programming language release. Runtime
    versions describe the patch version of an individual runtime.NoteThe ARN for the same runtime version number can vary between AWS Regions and CPU
    architectures.TopicsBackward compatibilityRuntime update modesTwo-phase runtime version rolloutConfiguring Lambda runtime management settingsRolling back a Lambda runtime versionIdentifying Lambda runtime version changesUnderstanding the shared responsibility model for Lambda runtime managementControlling Lambda runtime update permissions for high-compliance applications
    Backward compatibility
    Lambda strives to provide runtime updates that are backward compatible with existing functions. However, as with software patching, there are rare cases in which a runtime update can negatively impact an existing function. For example, security patches can expose an underlying issue with an existing function that depends on the previous, insecure behavior.
    When building and deploying your function, it is important to understand how to manage your dependencies to avoid potential incompatibilities with a future runtime update. For example, suppose your function has a dependency on package A, which in turn depends on package B. Both packages are included in the Lambda runtime (for example, they could be parts of the SDK or its dependencies, or parts of the runtime system libraries).
    Consider the following scenarios:
    
          
            Deployment
            Patching compatible
            Reason
          
        
          
            
              
                 
                 
              
                  Package A: Use from runtime
                
                  Package B: Use from runtime
                
            
            Yes
            Future runtime updates to packages A and B are backward compatible.
          
          
            
              
                 
                 
              
                  Package A: In deployment package
                
                  Package B: In deployment package
                
            
            Yes
            Your deployment takes precedence, so future runtime updates to packages A and B
              have no effect.
          
          
            
              
                 
                 
              
                  Package A: In deployment package
                
                  Package B: Use from runtime
                
            
            Yes*
            
              Future runtime updates to package B are backward compatible.
              *If A and B are tightly coupled, compatibility issues can occur. For example, the
                boto3 and botocore packages in the AWS SDK for Python should be deployed
                together.
            
          
          
            
              
                 
                 
              
                  Package A: Use from runtime
                
                  Package B: In deployment package
                
            
            No
            Future runtime updates to package A might require an updated version of package B.
              However, the deployed version of package B takes precedence, and might not be
              forward compatible with the updated version of package A.
          
        
    To maintain compatibility with future runtime updates, follow these best practices:
    
       
       
       
    
        When possible, package all dependencies: Include all required libraries, including the AWS SDK and its dependencies, in your deployment package. This ensures a stable, compatible set of components.
      
        Use runtime-provided SDKs sparingly: Only rely on the runtime-provided SDK when you can't include additional packages (for example, when using the Lambda console code editor or inline code in an AWS CloudFormation template).
      
        Avoid overriding system libraries: Don't deploy custom operating system libraries that may conflict with future runtime updates.
      
   
    Runtime update modes
    Lambda strives to provide runtime updates that are backward compatible with existing
      functions. However, as with software patching, there are rare cases in which a runtime update
      can negatively impact an existing function. For example, security patches can expose an
      underlying issue with an existing function that depends on the previous, insecure behavior.
      Lambda runtime management controls help reduce the risk of impact to your workloads in the rare
      event of a runtime version incompatibility. For each function version ($LATEST or published version), you can choose one of
      the following runtime update modes:
    
       
       
       
    Auto (default) – Automatically update to the most recent
        and secure runtime version using Two-phase runtime version rollout. We recommend this mode for most
        customers so that you always benefit from runtime updates.Function update – Update to the most recent and secure runtime version when you update your function. When you update your function, Lambda
        updates the runtime of your function to the most recent and secure runtime version. This
        approach synchronizes runtime updates with function deployments, giving you control over
        when Lambda applies runtime updates. With this mode, you can detect and mitigate rare
        runtime update incompatibilities early. When using this mode, you must regularly update
        your functions to keep their runtime up to date.Manual – Manually update your runtime version. You specify a runtime version in your function
        configuration. The function uses this runtime version indefinitely. In the rare case in
        which a new runtime version is incompatible with an existing function, you can use this
        mode to roll back your function to an earlier runtime version. We recommend against using
        Manual mode to try to achieve runtime consistency across
        deployments. For more information, see
        Rolling back a Lambda runtime version.
    Responsibility for applying runtime updates to your functions varies according to which runtime update mode you choose. For more information, see 
      Understanding the shared responsibility model for Lambda runtime management.
   
    Two-phase runtime version rollout
    Lambda introduces new runtime versions in the following order:
    
       
       
    In the first
        phase, Lambda applies the new runtime version whenever you create or update a function. A function gets updated when you call the 
        UpdateFunctionCode or UpdateFunctionConfiguration API operations.In the second phase, Lambda updates any function that uses the Auto runtime update mode and that hasn't already
        been updated to the new runtime version. 
    The overall duration of the rollout process varies
      according to multiple factors, including the severity of any security patches included in the
      runtime update.
    If you're actively developing and deploying your functions, you will most likely pick up
      new runtime versions during the first phase. This synchronizes runtime updates with function
      updates. In the rare event that the latest runtime version negatively impacts your
      application, this approach lets you take prompt corrective action. Functions that aren't
      in active development still receive the operational benefit of automatic runtime updates
      during the second phase.
    This approach doesn't affect functions set to Function update or
      Manual mode. Functions using Function update mode
      receive the latest runtime updates only when you create or update them. Functions using
      Manual mode don't receive runtime updates.
    Lambda publishes new runtime versions in a gradual, rolling fashion across AWS Regions.
      If your functions are set to Auto or Function update
      modes, it's possible that functions deployed at the same time to different Regions, or at
      different times in the same Region, will pick up different runtime versions. Customers who
      require guaranteed runtime version consistency across their environments should use container images to deploy their Lambda functions.
      The Manual mode is designed as a temporary mitigation to enable runtime version 
      rollback in the rare event that a runtime version is incompatible with your function.
  Document ConventionsLambda runtimesConfiguring runtime managementDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaAPI ReferenceRequest SyntaxURI Request ParametersRequest BodyResponse SyntaxResponse ElementsErrorsSee AlsoPublishVersionCreates a version from the
      current code and configuration of a function. Use versions to create a snapshot of your function code and
      configuration that doesn't change.
      AWS Lambda doesn't publish a version if the function's configuration and code haven't changed since the last
      version. Use UpdateFunctionCode or UpdateFunctionConfiguration to update the
      function before publishing a version.Clients can invoke versions directly or with an alias. To create an alias, use CreateAlias.
      Request Syntax
      POST /2015-03-31/functions/FunctionName/versions HTTP/1.1
Content-type: application/json

{
   "CodeSha256": "string",
   "Description": "string",
   "RevisionId": "string"
}
    
      URI Request Parameters
      The request uses the following URI parameters.
      
          
      
            
               
                  FunctionName
               
            
            
               The name or ARN of the Lambda function.
               
                  Name formats
                   
                   
                   
               
                     
                        Function name - MyFunction.
                  
                     
                        Function ARN - arn:aws:lambda:us-west-2:123456789012:function:MyFunction.
                  
                     
                        Partial ARN - 123456789012:function:MyFunction.
                  
               The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64
      characters in length.
               Length Constraints: Minimum length of 1. Maximum length of 140.
               Pattern: (arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\d{1}:)?(\d{12}:)?(function:)?([a-zA-Z0-9-_]+)(:(\$LATEST|[a-zA-Z0-9-_]+))?
               
               Required: Yes
            
         
    
      Request Body
      The request accepts the following data in JSON format.
      
          
          
          
      
            
               
                  CodeSha256
               
            
            
               Only publish a version if the hash value matches the value that's specified. Use this option to avoid
      publishing a version if the function code has changed since you last updated it. You can get the hash for the
      version that you uploaded from the output of UpdateFunctionCode.
               Type: String
               Required: No
            
          
            
               
                  Description
               
            
            
               A description for the version to override the description in the function configuration.
               Type: String
               Length Constraints: Minimum length of 0. Maximum length of 256.
               Required: No
            
          
            
               
                  RevisionId
               
            
            
               Only update the function if the revision ID matches the ID that's specified. Use this option to avoid
      publishing a version if the function configuration has changed since you last updated it.
               Type: String
               Required: No
            
         
    
      Response Syntax
      HTTP/1.1 201
Content-type: application/json

{
   "Architectures": [ "string" ],
   "CodeSha256": "string",
   "CodeSize": number,
   "DeadLetterConfig": { 
      "TargetArn": "string"
   },
   "Description": "string",
   "Environment": { 
      "Error": { 
         "ErrorCode": "string",
         "Message": "string"
      },
      "Variables": { 
         "string" : "string" 
      }
   },
   "EphemeralStorage": { 
      "Size": number
   },
   "FileSystemConfigs": [ 
      { 
         "Arn": "string",
         "LocalMountPath": "string"
      }
   ],
   "FunctionArn": "string",
   "FunctionName": "string",
   "Handler": "string",
   "ImageConfigResponse": { 
      "Error": { 
         "ErrorCode": "string",
         "Message": "string"
      },
      "ImageConfig": { 
         "Command": [ "string" ],
         "EntryPoint": [ "string" ],
         "WorkingDirectory": "string"
      }
   },
   "KMSKeyArn": "string",
   "LastModified": "string",
   "LastUpdateStatus": "string",
   "LastUpdateStatusReason": "string",
   "LastUpdateStatusReasonCode": "string",
   "Layers": [ 
      { 
         "Arn": "string",
         "CodeSize": number,
         "SigningJobArn": "string",
         "SigningProfileVersionArn": "string"
      }
   ],
   "LoggingConfig": { 
      "ApplicationLogLevel": "string",
      "LogFormat": "string",
      "LogGroup": "string",
      "SystemLogLevel": "string"
   },
   "MasterArn": "string",
   "MemorySize": number,
   "PackageType": "string",
   "RevisionId": "string",
   "Role": "string",
   "Runtime": "string",
   "RuntimeVersionConfig": { 
      "Error": { 
         "ErrorCode": "string",
         "Message": "string"
      },
      "RuntimeVersionArn": "string"
   },
   "SigningJobArn": "string",
   "SigningProfileVersionArn": "string",
   "SnapStart": { 
      "ApplyOn": "string",
      "OptimizationStatus": "string"
   },
   "State": "string",
   "StateReason": "string",
   "StateReasonCode": "string",
   "Timeout": number,
   "TracingConfig": { 
      "Mode": "string"
   },
   "Version": "string",
   "VpcConfig": { 
      "Ipv6AllowedForDualStack": boolean,
      "SecurityGroupIds": [ "string" ],
      "SubnetIds": [ "string" ],
      "VpcId": "string"
   }
}
    
      Response Elements
      If the action is successful, the service sends back an HTTP 201 response.
      The following data is returned in JSON format by the service.
      
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
      
            
               
                  Architectures
               
            
            
               The instruction set architecture that the function supports. Architecture is a string array with one of the 
      valid values. The default architecture value is x86_64.
               Type: Array of strings
               Array Members: Fixed number of 1 item.
               Valid Values: x86_64 | arm64
               
            
          
            
               
                  CodeSha256
               
            
            
               The SHA256 hash of the function's deployment package.
               Type: String
            
          
            
               
                  CodeSize
               
            
            
               The size of the function's deployment package, in bytes.
               Type: Long
            
          
            
               
                  DeadLetterConfig
               
            
            
               The function's dead letter queue.
               Type: DeadLetterConfig object
            
          
            
               
                  Description
               
            
            
               The function's description.
               Type: String
               Length Constraints: Minimum length of 0. Maximum length of 256.
            
          
            
               
                  Environment
               
            
            
               The function's environment variables. Omitted from AWS CloudTrail logs.
               Type: EnvironmentResponse object
            
          
            
               
                  EphemeralStorage
               
            
            
               The size of the function's /tmp directory in MB. The default value is 512, but can be any whole
  number between 512 and 10,240 MB. For more information, see Configuring ephemeral storage (console).
               Type: EphemeralStorage object
            
          
            
               
                  FileSystemConfigs
               
            
            
               Connection settings for an Amazon EFS file system.
               Type: Array of FileSystemConfig objects
               Array Members: Maximum number of 1 item.
            
          
            
               
                  FunctionArn
               
            
            
               The function's Amazon Resource Name (ARN).
               Type: String
               Pattern: arn:(aws[a-zA-Z-]*)?:lambda:[a-z]{2}(-gov)?-[a-z]+-\d{1}:\d{12}:function:[a-zA-Z0-9-_\.]+(:(\$LATEST|[a-zA-Z0-9-_]+))?
               
            
          
            
               
                  FunctionName
               
            
            
               The name of the function.
               Type: String
               Length Constraints: Minimum length of 1. Maximum length of 170.
               Pattern: (arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\d{1}:)?(\d{12}:)?(function:)?([a-zA-Z0-9-_\.]+)(:(\$LATEST|[a-zA-Z0-9-_]+))?
               
            
          
            
               
                  Handler
               
            
            
               The function that Lambda calls to begin running your function.
               Type: String
               Length Constraints: Maximum length of 128.
               Pattern: [^ ]+
               
            
          
            
               
                  ImageConfigResponse
               
            
            
               The function's image configuration values.
               Type: ImageConfigResponse object
            
          
            
               
                  KMSKeyArn
               
            
            
               The ARN of the AWS Key Management Service (AWS KMS) customer managed key that's used to encrypt the following resources:
               
                   
                   
                   
                   
               
                     The function's environment variables.
                  
                     The function's Lambda SnapStart snapshots.
                  
                     When used with SourceKMSKeyArn, the unzipped version of the .zip deployment package that's used for function invocations. For more information, see 
          Specifying a customer managed key for Lambda.
                  
                     The optimized version of the container image that's used for function invocations. Note that this is not the same key that's used to protect your container image in the Amazon Elastic Container Registry (Amazon ECR). For more information, see Function lifecycle.
                  
               If you don't provide a customer managed key, Lambda uses an AWS owned key or an AWS managed key.
               Type: String
               Pattern: (arn:(aws[a-zA-Z-]*)?:[a-z0-9-.]+:.*)|()
               
            
          
            
               
                  LastModified
               
            
            
               The date and time that the function was last updated, in ISO-8601 format (YYYY-MM-DDThh:mm:ss.sTZD).
               Type: String
            
          
            
               
                  LastUpdateStatus
               
            
            
               The status of the last update that was performed on the function. This is first set to Successful
      after function creation completes.
               Type: String
               Valid Values: Successful | Failed | InProgress
               
            
          
            
               
                  LastUpdateStatusReason
               
            
            
               The reason for the last update that was performed on the function.
               Type: String
            
          
            
               
                  LastUpdateStatusReasonCode
               
            
            
               The reason code for the last update that was performed on the function.
               Type: String
               Valid Values: EniLimitExceeded | InsufficientRolePermissions | InvalidConfiguration | InternalError | SubnetOutOfIPAddresses | InvalidSubnet | InvalidSecurityGroup | ImageDeleted | ImageAccessDenied | InvalidImage | KMSKeyAccessDenied | KMSKeyNotFound | InvalidStateKMSKey | DisabledKMSKey | EFSIOError | EFSMountConnectivityError | EFSMountFailure | EFSMountTimeout | InvalidRuntime | InvalidZipFileException | FunctionError
               
            
          
            
               
                  Layers
               
            
            
               The function's layers.
               Type: Array of Layer objects
            
          
            
               
                  LoggingConfig
               
            
            
               The function's Amazon CloudWatch Logs configuration settings.
               Type: LoggingConfig object
            
          
            
               
                  MasterArn
               
            
            
               For Lambda@Edge functions, the ARN of the main function.
               Type: String
               Pattern: arn:(aws[a-zA-Z-]*)?:lambda:[a-z]{2}(-gov)?-[a-z]+-\d{1}:\d{12}:function:[a-zA-Z0-9-_]+(:(\$LATEST|[a-zA-Z0-9-_]+))?
               
            
          
            
               
                  MemorySize
               
            
            
               The amount of memory available to the function at runtime.
               Type: Integer
               Valid Range: Minimum value of 128. Maximum value of 10240.
            
          
            
               
                  PackageType
               
            
            
               The type of deployment package. Set to Image for container image and set Zip for .zip file archive.
               Type: String
               Valid Values: Zip | Image
               
            
          
            
               
                  RevisionId
               
            
            
               The latest updated revision of the function or alias.
               Type: String
            
          
            
               
                  Role
               
            
            
               The function's execution role.
               Type: String
               Pattern: arn:(aws[a-zA-Z-]*)?:iam::\d{12}:role/?[a-zA-Z_0-9+=,.@\-_/]+
               
            
          
            
               
                  Runtime
               
            
            
               The identifier of the function's 
          runtime. Runtime is required if the deployment package is a .zip file archive. Specifying a runtime results in
          an error if you're deploying a function using a container image.
               The following list includes deprecated runtimes. Lambda blocks creating new functions and updating existing
          functions shortly after each runtime is deprecated. For more information, see
          Runtime use after deprecation.
               For a list of all currently supported runtimes, see
          Supported runtimes.
               Type: String
               Valid Values: nodejs | nodejs4.3 | nodejs6.10 | nodejs8.10 | nodejs10.x | nodejs12.x | nodejs14.x | nodejs16.x | java8 | java8.al2 | java11 | python2.7 | python3.6 | python3.7 | python3.8 | python3.9 | dotnetcore1.0 | dotnetcore2.0 | dotnetcore2.1 | dotnetcore3.1 | dotnet6 | dotnet8 | nodejs4.3-edge | go1.x | ruby2.5 | ruby2.7 | provided | provided.al2 | nodejs18.x | python3.10 | java17 | ruby3.2 | ruby3.3 | ruby3.4 | python3.11 | nodejs20.x | provided.al2023 | python3.12 | java21 | python3.13 | nodejs22.x
               
            
          
            
               
                  RuntimeVersionConfig
               
            
            
               The ARN of the runtime and any errors that occured.
               Type: RuntimeVersionConfig object
            
          
            
               
                  SigningJobArn
               
            
            
               The ARN of the signing job.
               Type: String
               Pattern: arn:(aws[a-zA-Z0-9-]*):([a-zA-Z0-9\-])+:([a-z]{2}(-gov)?-[a-z]+-\d{1})?:(\d{12})?:(.*)
               
            
          
            
               
                  SigningProfileVersionArn
               
            
            
               The ARN of the signing profile version.
               Type: String
               Pattern: arn:(aws[a-zA-Z0-9-]*):([a-zA-Z0-9\-])+:([a-z]{2}(-gov)?-[a-z]+-\d{1})?:(\d{12})?:(.*)
               
            
          
            
               
                  SnapStart
               
            
            
               Set ApplyOn to PublishedVersions to create a snapshot of the initialized execution
      environment when you publish a function version. For more information, see Improving startup performance with Lambda SnapStart.
               Type: SnapStartResponse object
            
          
            
               
                  State
               
            
            
               The current state of the function. When the state is Inactive, you can reactivate the function by
      invoking it.
               Type: String
               Valid Values: Pending | Active | Inactive | Failed
               
            
          
            
               
                  StateReason
               
            
            
               The reason for the function's current state.
               Type: String
            
          
            
               
                  StateReasonCode
               
            
            
               The reason code for the function's current state. When the code is Creating, you can't invoke or
      modify the function.
               Type: String
               Valid Values: Idle | Creating | Restoring | EniLimitExceeded | InsufficientRolePermissions | InvalidConfiguration | InternalError | SubnetOutOfIPAddresses | InvalidSubnet | InvalidSecurityGroup | ImageDeleted | ImageAccessDenied | InvalidImage | KMSKeyAccessDenied | KMSKeyNotFound | InvalidStateKMSKey | DisabledKMSKey | EFSIOError | EFSMountConnectivityError | EFSMountFailure | EFSMountTimeout | InvalidRuntime | InvalidZipFileException | FunctionError
               
            
          
            
               
                  Timeout
               
            
            
               The amount of time in seconds that Lambda allows a function to run before stopping it.
               Type: Integer
               Valid Range: Minimum value of 1.
            
          
            
               
                  TracingConfig
               
            
            
               The function's AWS X-Ray tracing configuration.
               Type: TracingConfigResponse object
            
          
            
               
                  Version
               
            
            
               The version of the Lambda function.
               Type: String
               Length Constraints: Minimum length of 1. Maximum length of 1024.
               Pattern: (\$LATEST|[0-9]+)
               
            
          
            
               
                  VpcConfig
               
            
            
               The function's networking configuration.
               Type: VpcConfigResponse object
            
         
    
      Errors
      For information about the errors that are common to all actions, see Common Errors.
      
          
          
          
          
          
          
          
      
            
               
                  CodeStorageExceededException
               
            
            
               Your AWS account has exceeded its maximum total code size. For more information, see Lambda quotas.
               HTTP Status Code: 400
            
          
            
               
                  InvalidParameterValueException
               
            
            
               One of the parameters in the request is not valid.
               HTTP Status Code: 400
            
          
            
               
                  PreconditionFailedException
               
            
            
               The RevisionId provided does not match the latest RevisionId for the Lambda function or alias.
               
                   
                   
               
                     
                        For AddPermission and RemovePermission API operations: Call GetPolicy to retrieve the latest RevisionId for your resource.
                  
                     
                        For all other API operations: Call GetFunction or GetAlias to retrieve the latest RevisionId for your resource.
                  
               HTTP Status Code: 412
            
          
            
               
                  ResourceConflictException
               
            
            
               The resource already exists, or another operation is in progress.
               HTTP Status Code: 409
            
          
            
               
                  ResourceNotFoundException
               
            
            
               The resource specified in the request does not exist.
               HTTP Status Code: 404
            
          
            
               
                  ServiceException
               
            
            
               The AWS Lambda service encountered an internal error.
               HTTP Status Code: 500
            
          
            
               
                  TooManyRequestsException
               
            
            
               The request throughput limit was exceeded. For more information, see Lambda quotas.
               HTTP Status Code: 429
            
         
    
      See Also
      For more information about using this API in one of the language-specific AWS SDKs, see the following:
      
          
          
          
          
          
          
          
          
          
      
            
               AWS Command Line Interface
            
         
            
               AWS SDK for .NET
            
         
            
               AWS SDK for C++
            
         
            
               AWS SDK for Go v2
            
         
            
               AWS SDK for Java V2
            
         
            
               AWS SDK for JavaScript V3
            
         
            
               AWS SDK for PHP V3
            
         
            
               AWS SDK for Python
            
         
            
               AWS SDK for Ruby V3
            
         
   Document ConventionsPublishLayerVersionPutFunctionCodeSigningConfigDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideEvent source mappings and triggersBatching behaviorProvisioned modeEvent source mapping APIHow Lambda processes records from stream and queue-based event sourcesAn event source mapping is a Lambda resource that reads items from stream and queue-based
    services and invokes a function with batches of records. Within an event source mapping, resources called
    event pollers actively poll for new messages and invoke functions. By default, Lambda automatically
    scales event pollers, but for certain event source types, you can use 
    provisioned mode to control the minimum and maximum number of event pollers dedicated to your event source mapping.The following services use event source mappings to invoke Lambda functions:
     
     
     
     
     
     
     
  
      Amazon DocumentDB (with MongoDB compatibility) (Amazon DocumentDB)
    
      Amazon DynamoDB
    
      Amazon Kinesis
    
      Amazon MQ
    
      Amazon Managed Streaming for Apache Kafka (Amazon MSK)
    
      Self-managed Apache Kafka
    
      Amazon Simple Queue Service (Amazon SQS)
    WarningLambda event source mappings process each event at least once, and duplicate processing of records can occur. To avoid potential issues 
related to duplicate events, we strongly recommend that you make your function code idempotent. To learn more, see How do I make my Lambda function idempotent 
in the AWS Knowledge Center.
    How event source mappings differ from direct triggers
    Some AWS services can directly invoke Lambda functions using triggers. These services push events to Lambda, and the function is invoked immediately when the specified event occurs. Triggers are suitable for discrete events and real-time processing. When you create a trigger using the Lambda console, the console interacts with the corresponding AWS service to configure the event notification on that service. The trigger is actually stored and managed by the service that generates the events, not by Lambda. Here are some examples of services that use triggers to invoke Lambda
      functions:
    
       
       
       
    
        Amazon Simple Storage Service (Amazon S3): Invokes a function when an object is created, deleted, or modified in a bucket. For more information, see Tutorial: Using an Amazon S3 trigger to invoke a Lambda function.
      
        Amazon Simple Notification Service (Amazon SNS): Invokes a function when a message is published to an SNS topic. For more information, see Tutorial: Using AWS Lambda with Amazon Simple Notification Service.
      
        Amazon API Gateway: Invokes a function when an API request is made to a specific endpoint. For more information, see Invoking a Lambda function using an Amazon API Gateway endpoint.
      
    Event source mappings are Lambda resources created and managed within the Lambda service.
      Event source mappings are designed for processing high-volume streaming data or messages from
      queues. Processing records from a stream or queue in batches is more efficient than processing
      records individually. 
   
    Batching behavior
    By default, an event source mapping batches
      records together into a single payload that Lambda sends to your function. To fine-tune batching behavior, you can
      configure a batching window (MaximumBatchingWindowInSeconds) and a batch size
      (BatchSize). A batching window is the maximum amount of time to gather records into a single payload.
      A batch size is the maximum number of records in a single batch. Lambda invokes your function when one of the
      following three criteria is met:
    
       
       
       
    
        The batching window reaches its maximum value. Default batching window behavior 
          varies depending on the specific event source.
        
           
           
        For Kinesis, DynamoDB, and Amazon SQS event sources: The default batching
            window is 0 seconds. This means that Lambda invokes your function as soon as records are available. To set a batching window, configure MaximumBatchingWindowInSeconds. You can 
            set this parameter to any value from 0 to 300 seconds in increments of 1 second. If you configure a batching window, the 
            next window begins as soon as the previous function invocation completes.For Amazon MSK, self-managed Apache Kafka, Amazon MQ, and Amazon DocumentDB event sources: The default batching
            window is 500 ms. You can configure MaximumBatchingWindowInSeconds to any value from 0 seconds to
            300 seconds in increments of seconds. A batching window begins as soon as the first record arrives.
            NoteBecause you can only change MaximumBatchingWindowInSeconds in increments of seconds, you
                cannot revert to the 500 ms default batching window after you have changed it. To restore the default
                batching window, you must create a new event source mapping.
          
      
        The batch size is met. The minimum batch size is 1. The default and
          maximum batch size depend on the event source. For details about these values, see the BatchSize specification for the CreateEventSourceMapping API
          operation.
      
        The payload size reaches 6 MB. You cannot modify this limit.
      
    The following diagram illustrates these three conditions. Suppose a batching window begins at t = 7
      seconds. In the first scenario, the batching window reaches its 40 second maximum at t = 47 seconds after
      accumulating 5 records. In the second scenario, the batch size reaches 10 before the batching window expires,
      so the batching window ends early. In the third scenario, the maximum payload size is reached before the batching
      window expires, so the batching window ends early.
    
       
        
       
       
    
    We recommend that you test with different batch and record sizes so that the polling frequency
      of each event source is tuned to how quickly your function is able to complete its task. The
      CreateEventSourceMapping BatchSize parameter controls the maximum number of
      records that can be sent to your function with each invoke. A larger batch size can often more efficiently
      absorb the invoke overhead across a larger set of records, increasing your throughput.
    Lambda doesn't wait for any configured extensions to complete
      before sending the next batch for processing. In other words, your extensions may continue to run as Lambda
      processes the next batch of records. This can cause throttling issues if you breach any of your account's 
      concurrency settings or limits. To detect whether this is a
      potential issue, monitor your functions and check whether you're seeing higher
      concurrency metrics than expected for your event
      source mapping. Due to short times in between invokes, Lambda may briefly report higher concurrency usage
      than the number of shards. This can be true even for Lambda functions without extensions.
    By default, if your function returns an error, the event source mapping reprocesses the entire batch until the
      function succeeds, or the items in the batch expire. To ensure in-order processing, the event source mapping
      pauses processing for the affected shard until the error is resolved. For stream sources (DynamoDB and Kinesis),
      you can configure the maximum number of times that Lambda retries when your function returns an error.
      Service errors or throttles where the batch does not reach your function do not count toward retry
      attempts. You can also configure the event source mapping to send an invocation record to a
      destination when it discards an event batch.
   
    Provisioned mode
    Lambda event source mappings use event pollers to poll your event source for new messages. By default,
      Lambda manages the autoscaling of these pollers depending on message volume. When message traffic increases,
      Lambda automatically increases the number of event pollers to handle the load, and reduces them when
      traffic decreases.
    In provisioned mode, you can fine-tune the throughput of your event source mapping by defining
      minimum and maximum limits for the number of provisioned event pollers. Lambda then scales your event
      source mapping between the minimum and maximum number of event pollers in a responsive manner. These
      provisioned event pollers are dedicated to your event source mapping, enhancing your ability to handle
      unpredictable spikes in events.
    In Lambda, an event poller is a compute unit capable of handling up to 5 MBps of throughput.
    For reference, suppose your event source produces an average payload of 1MB, and the average function duration is 1 sec.
    If the payload doesn’t undergo any transformation (such as filtering), a single poller can support 5 MBps throughput,
    and 5 concurrent Lambda invocations. Using provisioned mode incurs additional costs. For pricing estimates,
    see AWS Lambda pricing.
    Provisioned mode is supported only for Amazon MSK and self-managed Apache Kafka event sources. While concurrency settings
      give you control over the scaling of your function, provisioned mode gives you control over the
      throughput of your event source mapping. To ensure maximum performance, you may need to adjust both
      settings independently. For details about configuring provisioned mode, see the following sections:
    
       
       
    
        Configuring provisioned mode for Amazon MSK
          event source mappings
      
        Configuring provisioned mode for self-managed Apache Kafka
          event source mappings
      
    After configuring provisioned mode, you can observe the usage of event pollers for your workload by monitoring
    the ProvisionedPollers metric. For more information, see Event source mapping metrics.
   
    Event source mapping API
     To manage an event source with the AWS Command Line Interface (AWS CLI) or an AWS SDK, you can use the following API operations:
    
        
       
       
       
       
    
        CreateEventSourceMapping
      
        ListEventSourceMappings
      
        GetEventSourceMapping
      
        UpdateEventSourceMapping
      
        DeleteEventSourceMapping
      
  Document ConventionsRetaining recordsEvent source mapping tagsDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideSupported API actionsViewing resource-based IAM policies in LambdaLambda supports resource-based permissions policies for Lambda functions and layers. You can use resource-based policies to grant access to other AWS accounts, organizations, or services. Resource-based policies apply to a single function, version, alias, or layer version. 
    Console
        To view a function's resource-based policyOpen the Functions page of the Lambda console.
            Choose a function.
          
            Choose Configuration and then choose Permissions.
          
            Scroll down to Resource-based policy and then choose View policy document. The resource-based policy shows the permissions that are applied when another account or AWS service
              attempts to access the function. The following example shows a statement that allows Amazon S3 to invoke a function
              named my-function for a bucket named amzn-s3-demo-bucket in account
              123456789012.
            Example Resource-based policy{
    "Version": "2012-10-17",
    "Id": "default",
    "Statement": [
        {
            "Sid": "lambda-allow-s3-my-function",
            "Effect": "Allow",
            "Principal": {
              "Service": "s3.amazonaws.com"
            },
            "Action": "lambda:InvokeFunction",
            "Resource":  "arn:aws:lambda:us-east-2:123456789012:function:my-function",
            "Condition": {
              "StringEquals": {
                "AWS:SourceAccount": "123456789012"
              },
              "ArnLike": {
                "AWS:SourceArn": "arn:aws:s3:::amzn-s3-demo-bucket"
              }
            }
        }
     ]
}
          
      
    AWS CLI
        To view a function's resource-based policy, use the get-policy command.
        aws lambda get-policy \
  --function-name my-function \
  --output text
        You should see the following output:
        {"Version":"2012-10-17","Id":"default","Statement":[{"Sid":"sns","Effect":"Allow","Principal":{"Service":"s3.amazonaws.com"},"Action":"lambda:InvokeFunction","Resource":"arn:aws:lambda:us-east-2:123456789012:function:my-function","Condition":{"ArnLike":{"AWS:SourceArn":"arn:aws:sns:us-east-2:123456789012:lambda*"}}}]}      7c681fc9-b791-4e91-acdf-eb847fdaa0f0
        
        For versions and aliases, append the version number or alias to the function name.
        aws lambda get-policy --function-name my-function:PROD
        
        To remove permissions from your function, use remove-permission.
        aws lambda remove-permission \
  --function-name example \
  --statement-id sns
        
        Use the get-layer-version-policy command to view the permissions on a layer.
        aws lambda get-layer-version-policy \
  --layer-name my-layer \
  --version-number 3 \
  --output text
        You should see the following output:
        b0cd9796-d4eb-4564-939f-de7fe0b42236    {"Sid":"engineering-org","Effect":"Allow","Principal":"*","Action":"lambda:GetLayerVersion","Resource":"arn:aws:lambda:us-west-2:123456789012:layer:my-layer:3","Condition":{"StringEquals":{"aws:PrincipalOrgID":"o-t194hfs8cz"}}}"
        Use remove-layer-version-permission to remove statements from the policy.
        aws lambda remove-layer-version-permission --layer-name my-layer --version-number 3 --statement-id engineering-org
      
  
    Supported API actions
      The following Lambda API actions support resource-based policies:
      
         
       	  
       
	     
       
         	  
       	  
       
        	  
       
       	  
       
       	  
	     	  
       
        
        	  
       	  
       
	           
       	
       
         	  
       
       
       	  
	     
       	  
    
        CreateAlias
      
        DeleteAlias
      
        DeleteFunction
      
        DeleteFunctionConcurrency
      
        DeleteFunctionEventInvokeConfig
      
        DeleteProvisionedConcurrencyConfig
      
        GetAlias
      
        GetFunction
      
        GetFunctionConcurrency
      
        GetFunctionConfiguration
      
        GetFunctionEventInvokeConfig
      
        GetPolicy
      
        GetProvisionedConcurrencyConfig
      
        Invoke
      
        ListAliases
      
        ListFunctionEventInvokeConfigs
      
        ListProvisionedConcurrencyConfigs
      
        ListTags
      
        ListVersionsByFunction
      
        PublishVersion
      
        PutFunctionConcurrency
      
        PutFunctionEventInvokeConfig
      
        PutProvisionedConcurrencyConfig
      
        TagResource
      
        UntagResource
      
        UpdateAlias
      
        UpdateFunctionCode
      
        UpdateFunctionEventInvokeConfig
      
  Document ConventionsLayer accessFunction access for AWS servicesDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideIdentity-based IAM policies for LambdaYou can use identity-based policies in AWS Identity and Access Management (IAM) to grant users in your account access to Lambda.
    Identity-based policies can apply to users, user groups, or roles. You can
    also grant users in another account permission to assume a role in your account and access your Lambda
    resources.Lambda provides AWS managed policies that grant access to Lambda API actions and, in some cases, access to other
    AWS services used to develop and manage Lambda resources. Lambda updates these managed policies as needed to ensure
    that your users have access to new features when they're released.
     
     
     
  
      AWSLambda_FullAccess – Grants full access to Lambda actions and other
        AWS services used to develop and maintain Lambda resources.
    
      AWSLambda_ReadOnlyAccess – Grants read-only access to Lambda
        resources.
    
      AWSLambdaRole – Grants permissions to invoke Lambda functions.
    AWS managed policies grant permission to API actions without restricting the Lambda functions or layers that a
    user can modify. For finer-grained control, you can create your own policies that limit the scope of a user's
    permissions.TopicsGranting users access to a Lambda functionGranting users access to a Lambda layerDocument ConventionsAccess permissions (permissions for other entities to access your functions)Function accessDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideUnderstanding the Condition section in policiesReferencing functions in the Resource section of policiesSupported IAM actions and function behaviorsFine-tuning the Resources and Conditions sections of policiesYou can restrict the scope of a user's permissions by specifying resources and conditions in an AWS Identity and Access Management
    (IAM) policy. Each action in a policy supports a combination of resource and condition types that varies depending
    on the behavior of the action.Every IAM policy statement grants permission to an action that's performed on a resource. When the action
    doesn't act on a named resource, or when you grant permission to perform the action on all resources, the value of
    the resource in the policy is a wildcard (*). For many actions, you can restrict the resources that a
    user can modify by specifying the Amazon Resource Name (ARN) of a resource, or an ARN pattern that matches multiple
    resources.By resource type, the general design of how to restrict the scope of an action is the following:
     
     
     
     
     
  Functions–Actions that operate on a function can be restricted to a specific function by function, version, or alias ARN.
      Event source mappings–Actions can be restricted to specific event source mapping resources by ARN. Event source
        mappings are always associated with a function. You can also use the lambda:FunctionArn condition to restrict
        actions by associated function.
    Layers–Actions related to layer usage and permissions act on a version of a layer.Code signing configuration–Actions can be restricted to specific code signing configuration resources by ARN.Tags–Use standard tag conditions. For more information, see Using attribute-based access control in Lambda.To restrict permissions by resource, specify the resource by ARN.
    Lambda resource ARN format
     
     
     
     
     
     
     
  
      Function –
            arn:aws:lambda:us-west-2:123456789012:function:my-function
    
      Function version –
            arn:aws:lambda:us-west-2:123456789012:function:my-function:1
    
      Function alias –
            arn:aws:lambda:us-west-2:123456789012:function:my-function:TEST
    
      Event source mapping –
            arn:aws:lambda:us-west-2:123456789012:event-source-mapping:fa123456-14a1-4fd2-9fec-83de64ad683de6d47
    
      Layer –
            arn:aws:lambda:us-west-2:123456789012:layer:my-layer
    
      Layer version –
            arn:aws:lambda:us-west-2:123456789012:layer:my-layer:1
    
      Code signing configuration –
            arn:aws:lambda:us-west-2:123456789012:code-signing-config:my-csc
    For example, the following policy allows a user in AWS account 123456789012 to invoke a function
    named my-function in the US West (Oregon) AWS Region.Example invoke function policy{
    "Version": "2012-10-17",
    "Statement": [
        {
            "Sid": "Invoke",
            "Effect": "Allow",
            "Action": [
                "lambda:InvokeFunction"
            ],
            "Resource": "arn:aws:lambda:us-west-2:123456789012:function:my-function"
        }
    ]
}This is a special case where the action identifier (lambda:InvokeFunction) differs from the API
    operation (Invoke). For other actions, the action identifier is the operation name prefixed by
      lambda:.SectionsUnderstanding the Condition section in policiesReferencing functions in the Resource section of policiesSupported IAM actions and function behaviors
    Understanding the Condition section in policies
    Conditions are an optional policy element that applies additional logic to determine if an action is allowed.
      In addition to common conditions
      that all actions support, Lambda defines condition types that you can use to restrict the values of additional
      parameters on some actions.
    For example, the lambda:Principal condition lets you restrict the service or account that a user
      can grant invocation access to on a function's resource-based
        policy. The following policy lets a user grant permission to Amazon Simple Notification Service (Amazon SNS) topics to invoke a
      function named test.
    Example manage function policy permissions{
    "Version": "2012-10-17",
    "Statement": [
        {
            "Sid": "ManageFunctionPolicy",
            "Effect": "Allow",
            "Action": [
                "lambda:AddPermission",
                "lambda:RemovePermission"
            ],
            "Resource": "arn:aws:lambda:us-west-2:123456789012:function:test:*",
            "Condition": {
                "StringEquals": {
                    "lambda:Principal": "sns.amazonaws.com"
                }
            }
        }
    ]
}
    The condition requires that the principal is Amazon SNS and not another service or account. The resource pattern
      requires that the function name is test and includes a version number or alias. For example,
      test:v1.
    
    For more information on resources and conditions for Lambda and other AWS services, see Actions,
        resources, and condition keys for AWS services in the Service Authorization Reference.
   
  Referencing functions in the Resource section of policies
  You reference a Lambda function in a policy statement using an Amazon Resource Name (ARN). The format of a
      function ARN depends on whether you are referencing the whole function (unqualified) or a function version or alias (qualified).
  
    When making Lambda API calls, users can specify a version or alias by passing a version ARN or alias ARN in the
      GetFunction FunctionName parameter, or by setting a value in the GetFunction
        Qualifier parameter. Lambda makes authorization decisions by comparing the resource element in the
      IAM policy with both the FunctionName and Qualifier passed in API calls. If there is a
      mismatch, Lambda denies the request.
    Whether you are allowing or denying an action on your function, you must use the correct function ARN types in your policy statement to achieve the results that you expect. For example, 
    if your policy references the unqualified ARN, Lambda accepts requests that reference the unqualified ARN but denies requests that reference a qualified ARN.
    NoteYou can't use a wildcard character (*) to match the account ID. For more information on accepted syntax, see
          IAM JSON policy reference in the
          IAM User Guide.
    Example allowing invocation of an unqualified ARN{
    "Version": "2012-10-17",
    "Statement": [
        {
            "Effect": "Allow",
            "Action": "lambda:InvokeFunction",
            "Resource": "arn:aws:lambda:us-west-2:123456789012:function:myFunction"
        }
    ]
}
    If your policy references a specific qualified ARN, Lambda accepts requests that reference that ARN but denies requests that reference the unqualified ARN or a different qualified ARN, for example, myFunction:2.
    Example allowing invocation of a specific qualified ARN{
    "Version": "2012-10-17",
    "Statement": [
        {
            "Effect": "Allow",
            "Action": "lambda:InvokeFunction",
            "Resource": "arn:aws:lambda:us-west-2:123456789012:function:myFunction:1"
        }
    ]
}
    If your policy references any qualified ARN using :*, Lambda accepts any qualified ARN but denies requests that reference the unqualified ARN.
    Example allowing invocation of any qualified ARN{
    "Version": "2012-10-17",
    "Statement": [
        {
            "Effect": "Allow",
            "Action": "lambda:InvokeFunction",
            "Resource": "arn:aws:lambda:us-west-2:123456789012:function:myFunction:*"
        }
    ]
}
    If your policy references any ARN using *, Lambda accepts any qualified or unqualified ARN.
    Example allowing invocation of any qualified or unqualified ARN{
    "Version": "2012-10-17",
    "Statement": [
        {
            "Effect": "Allow",
            "Action": "lambda:InvokeFunction",
            "Resource": "arn:aws:lambda:us-west-2:123456789012:function:myFunction*"
        }
    ]
}
    
 
    Supported IAM actions and function behaviors
     Actions define what can be permitted through IAM policies. For a list of actions supported in Lambda, see
      Actions, resources,
      and condition keys for AWS Lambda in the Service Authorization Reference. In most cases, when an IAM action permits an Lambda API action, 
      the name of the IAM action is the same as the name of the Lambda API action, with the following exceptions: 
    
          
            API action
            IAM action
          
        
          
            Invoke
            lambda:InvokeFunction
          
          
            GetLayerVersion
              GetLayerVersionByArn
            lambda:GetLayerVersion
          
        
    
    In addition to the resources and conditions defined in the Service Authorization Reference, Lambda
      supports the following resources and conditions for certain actions. Many of these are related to referencing
      functions in the resource section of policies. Actions that operate on a function can be restricted to a specific
      function by function, version, or alias ARN, as described in the following table.
    
          
            Action
            Resource
            Condition
          
        
          
            
              
              AddPermission
              
              RemovePermission
              
              Invoke–Permission:
                lambda:InvokeFunction
            
            
              Function version
              Function alias
            
            
              N/A
            
          
          
            
              
              UpdateFunctionConfiguration
            
            
              N/A
            
            
              lambda:CodeSigningConfigArn
            
          
          
            
              
              CreateFunctionUrlConfig
              
              DeleteFunctionUrlConfig
              
              GetFunctionUrlConfig
              
              UpdateFunctionUrlConfig
            
            
              Function alias
            
            
              N/A
            
          
        
  Document ConventionsSecure your functions by tagSecurity, governance, and complianceDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideCreate an alias for a Lambda functionYou can create aliases for your Lambda function. A Lambda alias is a pointer to a
    function version that you can update. The function's users can access the function version 
    using the alias Amazon Resource Name (ARN). When you deploy a new version, you can update the
    alias to use the new version, or split traffic between two versions.
    Console
        To create an alias using the consoleOpen the Functions page of the Lambda console.
            Choose a function.
          
            Choose Aliases and then choose Create alias.
          
            On the Create alias page, do the following:
            
                Enter a Name for the alias.
              
                (Optional) Enter a Description for the alias.
              
                For Version, choose a function version that you want the alias to point to.
              
                (Optional) To configure routing on the alias, expand Weighted alias. For more
                  information, see Implement Lambda canary deployments using a weighted alias.
              
                Choose Save.
              
          
      
    AWS CLI
        To create an alias using the AWS Command Line Interface (AWS CLI), use the create-alias command.
        aws lambda create-alias \
  --function-name my-function \
  --name alias-name \
  --function-version version-number \
  --description " "
        To change an alias to point a new version of the function, use the update-alias command.
        aws lambda update-alias \
  --function-name my-function \
  --name alias-name \
  --function-version version-number
        To delete an alias, use the delete-alias command.
        aws lambda delete-alias \
  --function-name my-function \
  --name alias-name
         The AWS CLI commands in the preceding steps correspond to the following Lambda API operations:
        
           
           
           
        
            CreateAlias
          
            UpdateAlias
          
            DeleteAlias
          
      
  Document ConventionsFile systemUsing aliasesDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideRequirementsUsing an AWS base imageUsing an AWS OS-only base imageUsing a non-AWS base imageRuntime interface clientsAmazon ECR permissionsFunction lifecycleCreate a Lambda function using a container imageYour AWS Lambda function's code consists of scripts or compiled programs and their dependencies. 
You use a deployment package to deploy your function code to Lambda. Lambda supports two types of deployment packages: 
container images and .zip file archives. There are three ways to build a container image for a Lambda function:
     
	 
     
  
      Using an AWS base image for Lambda
      The AWS base images are preloaded with a language runtime, a runtime interface client to manage the interaction between Lambda and your function code, and a runtime interface emulator for local testing.
    
      Using an AWS OS-only base image
      AWS OS-only base images contain an Amazon Linux distribution and the runtime interface emulator. These images are commonly used to create container images for compiled languages, such as Go and Rust, and for a language or language version that Lambda doesn't provide a base image for, such as Node.js 19. You can also use OS-only base images to implement a custom runtime. To make the image compatible with Lambda, you must include a runtime interface client for your language in the image.
    
      Using a non-AWS base image
      You can use an alternative base image from another container registry, such as Alpine Linux or Debian. You can also use a custom image created by your organization. To make the image compatible with Lambda, you must include a runtime interface client for your language in the image.
    TipTo reduce the time it takes for Lambda container functions to become active, see Use multi-stage builds in the Docker documentation. To build efficient container images, follow the Best practices for writing Dockerfiles.To create a Lambda function from a container image, build your image locally and upload it to an Amazon Elastic Container Registry (Amazon ECR) repository. Then, specify the repository URI when you create the function. The Amazon ECR repository must be in the same AWS Region as the Lambda function. You can create a function using an image in a different AWS account, as long as the image is in the same Region as the Lambda function. For more information, see  Amazon ECR cross-account permissions.NoteLambda does not support Amazon ECR FIPS endpoints for container images. If your repository URI includes
      ecr-fips, you are using a FIPS endpoint. Example: 111122223333.dkr.ecr-fips.us-east-1.amazonaws.com.This page explains the base image types and requirements for creating Lambda-compatible container images.NoteYou cannot change the deployment package type (.zip or container image) for an existing function. For example, you cannot convert a container image function to use a .zip file archive. You must create a new function.TopicsRequirementsUsing an AWS base image for LambdaUsing an AWS OS-only base imageUsing a non-AWS base imageRuntime interface clientsAmazon ECR permissionsFunction lifecycle
    Requirements
    Install the AWS CLI version 2 and the Docker CLI. 
      Additionally, note the following requirements:
    
       
       
       
       
       
    
        The container image must implement the Using the Lambda runtime API for custom runtimes. The AWS
          open-source runtime interface clients implement the API. You can
          add a runtime interface client to your preferred base image to make it compatible with Lambda.
      
        The container image must be able to run on a read-only file system. Your function code can access a
          writable /tmp directory with between 512 MB and 10,240 MB, in 1-MB increments, of storage.  
      
        The default Lambda user must be able to read all the files required to run your function code. Lambda
          follows security best practices by defining a default Linux user with least-privileged permissions. This means that you don't need to specify a USER  in your Dockerfile. Verify
          that your application code does not rely on files that other Linux users are restricted from running.
      
        Lambda supports only Linux-based container images.
      
        Lambda provides multi-architecture base images. However, the image you build for your function must target
          only one of the architectures. Lambda does not support functions that use multi-architecture container
          images.
      
   
    Using an AWS base image for Lambda
    You can use one of the AWS base images for Lambda to build the container image for your
      function code. The base images are preloaded with a language runtime and other components
      required to run a container image on Lambda. You add your function code and dependencies to the
      base image and then package it as a container image.
    AWS periodically provides updates to the AWS base images for Lambda. If your Dockerfile includes the
      image name in the FROM property, your Docker client pulls the latest version of the image from the Amazon ECR repository. To
      use the updated base image, you must rebuild your container image and update the function code.
      The Node.js 20, Python 3.12, Java 21, .NET 8, Ruby 3.3, and later base images are based on the Amazon Linux 2023 minimal container image. Earlier base images use Amazon Linux 2. AL2023 provides several advantages over Amazon Linux 2, including a smaller deployment footprint and updated versions of libraries such as glibc.
    AL2023-based images use microdnf (symlinked as dnf) as the package manager instead of yum, which is the default package manager in Amazon Linux 2. microdnf is a standalone implementation of dnf. For a list of packages that are included in AL2023-based images, refer to the Minimal Container columns in Comparing packages installed on Amazon Linux 2023 Container Images. For more information about the differences between AL2023 and Amazon Linux 2, see Introducing the Amazon Linux 2023 runtime for AWS Lambda on the AWS
      Compute Blog.    
    NoteTo run AL2023-based images locally, including with AWS Serverless Application Model (AWS SAM), you must use Docker version 20.10.10 or later.  
    To build a container image using an AWS base image, choose the instructions for your preferred language:
    
       
       
       
       
       
       
       
    
        Node.js
      
        TypeScript (uses a Node.js base image) 
      
        Python
      
        Java 
      
        Go
      
        .NET
      
        Ruby
      
   
    Using an AWS OS-only base image
    AWS OS-only base images contain an Amazon Linux distribution and the runtime interface emulator. These images are commonly used to create container images for compiled languages, such as Go and Rust, and for a language or language version that Lambda doesn't provide a base image for, such as Node.js 19. You can also use OS-only base images to implement a custom runtime. To make the image compatible with Lambda, you must include a runtime interface client for your language in the image.
    
          
            Tags
            Runtime
            Operating system
            Dockerfile
            Deprecation
          
        
      
            al2023
            OS-only Runtime
            Amazon Linux 2023
            Dockerfile
                for OS-only Runtime on GitHub
            
                          Jun 30, 2029
            
              
          
      
            al2
            OS-only Runtime
            Amazon Linux 2
            Dockerfile
                for OS-only Runtime on GitHub
            
                          Jun 30, 2026
            
              
          
    
    Amazon Elastic Container Registry Public Gallery: gallery.ecr.aws/lambda/provided
     
    Using a non-AWS base image
    Lambda
      supports any image that conforms to one of the following image manifest formats:
    
       
       
    Docker image manifest V2, schema 2 (used with Docker version 1.10 and newer)Open Container Initiative (OCI) Specifications (v1.0.0 and up)
    Lambda supports a maximum uncompressed image size of 10 GB, including all layers.
    NoteTo make the image compatible with Lambda, you must include a runtime interface client for your language in the image.
   
    Runtime interface clients
    If you use an OS-only base image or an alternative base image, you must include a runtime interface client in your image. The runtime interface client must extend the Using the Lambda runtime API for custom runtimes, which manages the interaction between Lambda and your function code. AWS provides open-source runtime interface clients for the following languages:
    
  
   
  
   
  
   
  
   
  
   
  
   
  
     

    
      Node.js
    
  
    
      Python
    
  
    
      Java
    
  
    
      .NET
    
  
    
      Go
    
  
    
      Ruby
    
  
    
      Rust – The Rust runtime client is an experimental package. It is subject to change and intended only for evaluation purposes.
    
  
    If you're using a language that doesn't have an AWS-provided runtime interface client, you must create your own.
   
    Amazon ECR permissions
    Before you create a Lambda function from a container image, you must build the image locally and upload it to an Amazon ECR repository. When you create the function, specify the Amazon ECR repository URI.
    Make sure that the permissions for the user or role that creates the function includes GetRepositoryPolicy and SetRepositoryPolicy.
    For example, use the IAM console to create a role with the following policy:
    {
  "Version": "2012-10-17",
  "Statement": [
    {
      "Sid": "VisualEditor0",
      "Effect": "Allow",
      "Action": [
        "ecr:SetRepositoryPolicy",
        "ecr:GetRepositoryPolicy"
      ],
      "Resource": "arn:aws:ecr:us-east-1:111122223333:repository/hello-world"
    }
  ]
}
     
      Amazon ECR repository policies
      For a function in the same account as the container image in Amazon ECR, you can add ecr:BatchGetImage
        and ecr:GetDownloadUrlForLayer permissions to your Amazon ECR repository policy. The following example shows the
        minimum policy:
      {
        "Sid": "LambdaECRImageRetrievalPolicy",
        "Effect": "Allow",
        "Principal": {
          "Service": "lambda.amazonaws.com"
        },
        "Action": [
          "ecr:BatchGetImage",
          "ecr:GetDownloadUrlForLayer"
        ]
    }   
      For more information about Amazon ECR
        repository permissions, see Private repository policies in the
        Amazon Elastic Container Registry User Guide.
      If the Amazon ECR repository does not include these permissions, Lambda attempts to add them automatically. Lambda can add
        permissions only if the principal calling Lambda has ecr:getRepositoryPolicy and
          ecr:setRepositoryPolicy permissions. 
      To view or edit your Amazon ECR repository permissions, follow the directions in Setting a private repository policy statement in the
          Amazon Elastic Container Registry User Guide.
       
         Amazon ECR cross-account permissions
        A different account in the same region can create a function that uses a container image owned by your
          account. In the following example, your Amazon ECR repository permissions policy needs the following statements to
          grant access to account number 123456789012.
        
           
           
        CrossAccountPermission – Allows account 123456789012 to create and update Lambda
              functions that use images from this ECR repository.LambdaECRImageCrossAccountRetrievalPolicy – Lambda will eventually set a
              function's state to inactive if it is not invoked for an extended period. This statement is required so that
              Lambda can retrieve the container image for optimization and caching on behalf of the function owned by
              123456789012.  
        Example — Add cross-account permission to your repository{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Sid": "CrossAccountPermission",
      "Effect": "Allow",
      "Action": [
        "ecr:BatchGetImage",
        "ecr:GetDownloadUrlForLayer"
      ],
      "Principal": {
        "AWS": "arn:aws:iam::123456789012:root"
      }
    },
    {
      "Sid": "LambdaECRImageCrossAccountRetrievalPolicy",
      "Effect": "Allow",
      "Action": [
        "ecr:BatchGetImage",
        "ecr:GetDownloadUrlForLayer"
      ],
      "Principal": {
        "Service": "lambda.amazonaws.com"
      },
      "Condition": {
        "StringLike": {
          "aws:sourceARN": "arn:aws:lambda:us-east-1:123456789012:function:*"
        }
      }
    }
  ]
}
        To give access to multiple accounts, you add the account IDs to the Principal list in the
            CrossAccountPermission policy and to the Condition evaluation list in the
            LambdaECRImageCrossAccountRetrievalPolicy.
        If you are working with multiple accounts in an AWS Organization, we recommend that you enumerate each
          account ID in the ECR permissions policy. This approach aligns with the AWS security best practice of setting
          narrow permissions in IAM policies.
        In addition to Lambda permissions, the user or role that creates the function must also have BatchGetImage and GetDownloadUrlForLayer permissions.
       
     
   
    Function lifecycle
    After you upload a new or updated container image, Lambda optimizes the image before the function can process invocations. The
      optimization process can take a few seconds. The function remains in the Pending state until the
      process completes, when the state transitions to Active. You can't invoke the function until it reaches the Active state. 
    If a function is not invoked for multiple weeks, Lambda reclaims its optimized version, and the function
      transitions to the Inactive state. To reactivate the function, you must invoke it. Lambda rejects the
      first invocation and the function enters the Pending state until Lambda re-optimizes the image. The
      function then returns to the Active state.
    Lambda periodically fetches the associated container image from the Amazon ECR repository. If the
      corresponding container image no longer exists on Amazon ECR or permissions are revoked, the function enters the Failed state, and
      Lambda returns a failure for any function invocations.
    You can use the Lambda API to get information about a function's state. For more information, see Lambda function states.
  Document ConventionsEncryptionMemoryDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideRequirementsUsing an AWS base imageUsing an AWS OS-only base imageUsing a non-AWS base imageRuntime interface clientsAmazon ECR permissionsFunction lifecycleCreate a Lambda function using a container imageYour AWS Lambda function's code consists of scripts or compiled programs and their dependencies. 
You use a deployment package to deploy your function code to Lambda. Lambda supports two types of deployment packages: 
container images and .zip file archives. There are three ways to build a container image for a Lambda function:
     
	 
     
  
      Using an AWS base image for Lambda
      The AWS base images are preloaded with a language runtime, a runtime interface client to manage the interaction between Lambda and your function code, and a runtime interface emulator for local testing.
    
      Using an AWS OS-only base image
      AWS OS-only base images contain an Amazon Linux distribution and the runtime interface emulator. These images are commonly used to create container images for compiled languages, such as Go and Rust, and for a language or language version that Lambda doesn't provide a base image for, such as Node.js 19. You can also use OS-only base images to implement a custom runtime. To make the image compatible with Lambda, you must include a runtime interface client for your language in the image.
    
      Using a non-AWS base image
      You can use an alternative base image from another container registry, such as Alpine Linux or Debian. You can also use a custom image created by your organization. To make the image compatible with Lambda, you must include a runtime interface client for your language in the image.
    TipTo reduce the time it takes for Lambda container functions to become active, see Use multi-stage builds in the Docker documentation. To build efficient container images, follow the Best practices for writing Dockerfiles.To create a Lambda function from a container image, build your image locally and upload it to an Amazon Elastic Container Registry (Amazon ECR) repository. Then, specify the repository URI when you create the function. The Amazon ECR repository must be in the same AWS Region as the Lambda function. You can create a function using an image in a different AWS account, as long as the image is in the same Region as the Lambda function. For more information, see  Amazon ECR cross-account permissions.NoteLambda does not support Amazon ECR FIPS endpoints for container images. If your repository URI includes
      ecr-fips, you are using a FIPS endpoint. Example: 111122223333.dkr.ecr-fips.us-east-1.amazonaws.com.This page explains the base image types and requirements for creating Lambda-compatible container images.NoteYou cannot change the deployment package type (.zip or container image) for an existing function. For example, you cannot convert a container image function to use a .zip file archive. You must create a new function.TopicsRequirementsUsing an AWS base image for LambdaUsing an AWS OS-only base imageUsing a non-AWS base imageRuntime interface clientsAmazon ECR permissionsFunction lifecycle
    Requirements
    Install the AWS CLI version 2 and the Docker CLI. 
      Additionally, note the following requirements:
    
       
       
       
       
       
    
        The container image must implement the Using the Lambda runtime API for custom runtimes. The AWS
          open-source runtime interface clients implement the API. You can
          add a runtime interface client to your preferred base image to make it compatible with Lambda.
      
        The container image must be able to run on a read-only file system. Your function code can access a
          writable /tmp directory with between 512 MB and 10,240 MB, in 1-MB increments, of storage.  
      
        The default Lambda user must be able to read all the files required to run your function code. Lambda
          follows security best practices by defining a default Linux user with least-privileged permissions. This means that you don't need to specify a USER  in your Dockerfile. Verify
          that your application code does not rely on files that other Linux users are restricted from running.
      
        Lambda supports only Linux-based container images.
      
        Lambda provides multi-architecture base images. However, the image you build for your function must target
          only one of the architectures. Lambda does not support functions that use multi-architecture container
          images.
      
   
    Using an AWS base image for Lambda
    You can use one of the AWS base images for Lambda to build the container image for your
      function code. The base images are preloaded with a language runtime and other components
      required to run a container image on Lambda. You add your function code and dependencies to the
      base image and then package it as a container image.
    AWS periodically provides updates to the AWS base images for Lambda. If your Dockerfile includes the
      image name in the FROM property, your Docker client pulls the latest version of the image from the Amazon ECR repository. To
      use the updated base image, you must rebuild your container image and update the function code.
      The Node.js 20, Python 3.12, Java 21, .NET 8, Ruby 3.3, and later base images are based on the Amazon Linux 2023 minimal container image. Earlier base images use Amazon Linux 2. AL2023 provides several advantages over Amazon Linux 2, including a smaller deployment footprint and updated versions of libraries such as glibc.
    AL2023-based images use microdnf (symlinked as dnf) as the package manager instead of yum, which is the default package manager in Amazon Linux 2. microdnf is a standalone implementation of dnf. For a list of packages that are included in AL2023-based images, refer to the Minimal Container columns in Comparing packages installed on Amazon Linux 2023 Container Images. For more information about the differences between AL2023 and Amazon Linux 2, see Introducing the Amazon Linux 2023 runtime for AWS Lambda on the AWS
      Compute Blog.    
    NoteTo run AL2023-based images locally, including with AWS Serverless Application Model (AWS SAM), you must use Docker version 20.10.10 or later.  
    To build a container image using an AWS base image, choose the instructions for your preferred language:
    
       
       
       
       
       
       
       
    
        Node.js
      
        TypeScript (uses a Node.js base image) 
      
        Python
      
        Java 
      
        Go
      
        .NET
      
        Ruby
      
   
    Using an AWS OS-only base image
    AWS OS-only base images contain an Amazon Linux distribution and the runtime interface emulator. These images are commonly used to create container images for compiled languages, such as Go and Rust, and for a language or language version that Lambda doesn't provide a base image for, such as Node.js 19. You can also use OS-only base images to implement a custom runtime. To make the image compatible with Lambda, you must include a runtime interface client for your language in the image.
    
          
            Tags
            Runtime
            Operating system
            Dockerfile
            Deprecation
          
        
      
            al2023
            OS-only Runtime
            Amazon Linux 2023
            Dockerfile
                for OS-only Runtime on GitHub
            
                          Jun 30, 2029
            
              
          
      
            al2
            OS-only Runtime
            Amazon Linux 2
            Dockerfile
                for OS-only Runtime on GitHub
            
                          Jun 30, 2026
            
              
          
    
    Amazon Elastic Container Registry Public Gallery: gallery.ecr.aws/lambda/provided
     
    Using a non-AWS base image
    Lambda
      supports any image that conforms to one of the following image manifest formats:
    
       
       
    Docker image manifest V2, schema 2 (used with Docker version 1.10 and newer)Open Container Initiative (OCI) Specifications (v1.0.0 and up)
    Lambda supports a maximum uncompressed image size of 10 GB, including all layers.
    NoteTo make the image compatible with Lambda, you must include a runtime interface client for your language in the image.
   
    Runtime interface clients
    If you use an OS-only base image or an alternative base image, you must include a runtime interface client in your image. The runtime interface client must extend the Using the Lambda runtime API for custom runtimes, which manages the interaction between Lambda and your function code. AWS provides open-source runtime interface clients for the following languages:
    
  
   
  
   
  
   
  
   
  
   
  
   
  
     

    
      Node.js
    
  
    
      Python
    
  
    
      Java
    
  
    
      .NET
    
  
    
      Go
    
  
    
      Ruby
    
  
    
      Rust – The Rust runtime client is an experimental package. It is subject to change and intended only for evaluation purposes.
    
  
    If you're using a language that doesn't have an AWS-provided runtime interface client, you must create your own.
   
    Amazon ECR permissions
    Before you create a Lambda function from a container image, you must build the image locally and upload it to an Amazon ECR repository. When you create the function, specify the Amazon ECR repository URI.
    Make sure that the permissions for the user or role that creates the function includes GetRepositoryPolicy and SetRepositoryPolicy.
    For example, use the IAM console to create a role with the following policy:
    {
  "Version": "2012-10-17",
  "Statement": [
    {
      "Sid": "VisualEditor0",
      "Effect": "Allow",
      "Action": [
        "ecr:SetRepositoryPolicy",
        "ecr:GetRepositoryPolicy"
      ],
      "Resource": "arn:aws:ecr:us-east-1:111122223333:repository/hello-world"
    }
  ]
}
     
      Amazon ECR repository policies
      For a function in the same account as the container image in Amazon ECR, you can add ecr:BatchGetImage
        and ecr:GetDownloadUrlForLayer permissions to your Amazon ECR repository policy. The following example shows the
        minimum policy:
      {
        "Sid": "LambdaECRImageRetrievalPolicy",
        "Effect": "Allow",
        "Principal": {
          "Service": "lambda.amazonaws.com"
        },
        "Action": [
          "ecr:BatchGetImage",
          "ecr:GetDownloadUrlForLayer"
        ]
    }   
      For more information about Amazon ECR
        repository permissions, see Private repository policies in the
        Amazon Elastic Container Registry User Guide.
      If the Amazon ECR repository does not include these permissions, Lambda attempts to add them automatically. Lambda can add
        permissions only if the principal calling Lambda has ecr:getRepositoryPolicy and
          ecr:setRepositoryPolicy permissions. 
      To view or edit your Amazon ECR repository permissions, follow the directions in Setting a private repository policy statement in the
          Amazon Elastic Container Registry User Guide.
       
         Amazon ECR cross-account permissions
        A different account in the same region can create a function that uses a container image owned by your
          account. In the following example, your Amazon ECR repository permissions policy needs the following statements to
          grant access to account number 123456789012.
        
           
           
        CrossAccountPermission – Allows account 123456789012 to create and update Lambda
              functions that use images from this ECR repository.LambdaECRImageCrossAccountRetrievalPolicy – Lambda will eventually set a
              function's state to inactive if it is not invoked for an extended period. This statement is required so that
              Lambda can retrieve the container image for optimization and caching on behalf of the function owned by
              123456789012.  
        Example — Add cross-account permission to your repository{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Sid": "CrossAccountPermission",
      "Effect": "Allow",
      "Action": [
        "ecr:BatchGetImage",
        "ecr:GetDownloadUrlForLayer"
      ],
      "Principal": {
        "AWS": "arn:aws:iam::123456789012:root"
      }
    },
    {
      "Sid": "LambdaECRImageCrossAccountRetrievalPolicy",
      "Effect": "Allow",
      "Action": [
        "ecr:BatchGetImage",
        "ecr:GetDownloadUrlForLayer"
      ],
      "Principal": {
        "Service": "lambda.amazonaws.com"
      },
      "Condition": {
        "StringLike": {
          "aws:sourceARN": "arn:aws:lambda:us-east-1:123456789012:function:*"
        }
      }
    }
  ]
}
        To give access to multiple accounts, you add the account IDs to the Principal list in the
            CrossAccountPermission policy and to the Condition evaluation list in the
            LambdaECRImageCrossAccountRetrievalPolicy.
        If you are working with multiple accounts in an AWS Organization, we recommend that you enumerate each
          account ID in the ECR permissions policy. This approach aligns with the AWS security best practice of setting
          narrow permissions in IAM policies.
        In addition to Lambda permissions, the user or role that creates the function must also have BatchGetImage and GetDownloadUrlForLayer permissions.
       
     
   
    Function lifecycle
    After you upload a new or updated container image, Lambda optimizes the image before the function can process invocations. The
      optimization process can take a few seconds. The function remains in the Pending state until the
      process completes, when the state transitions to Active. You can't invoke the function until it reaches the Active state. 
    If a function is not invoked for multiple weeks, Lambda reclaims its optimized version, and the function
      transitions to the Inactive state. To reactivate the function, you must invoke it. Lambda rejects the
      first invocation and the function enters the Pending state until Lambda re-optimizes the image. The
      function then returns to the Active state.
    Lambda periodically fetches the associated container image from the Amazon ECR repository. If the
      corresponding container image no longer exists on Amazon ECR or permissions are revoked, the function enters the Failed state, and
      Lambda returns a failure for any function invocations.
    You can use the Lambda API to get information about a function's state. For more information, see Lambda function states.
  Document ConventionsEncryptionMemoryDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideRequirementsUsing an AWS base imageUsing an AWS OS-only base imageUsing a non-AWS base imageRuntime interface clientsAmazon ECR permissionsFunction lifecycleCreate a Lambda function using a container imageYour AWS Lambda function's code consists of scripts or compiled programs and their dependencies. 
You use a deployment package to deploy your function code to Lambda. Lambda supports two types of deployment packages: 
container images and .zip file archives. There are three ways to build a container image for a Lambda function:
     
	 
     
  
      Using an AWS base image for Lambda
      The AWS base images are preloaded with a language runtime, a runtime interface client to manage the interaction between Lambda and your function code, and a runtime interface emulator for local testing.
    
      Using an AWS OS-only base image
      AWS OS-only base images contain an Amazon Linux distribution and the runtime interface emulator. These images are commonly used to create container images for compiled languages, such as Go and Rust, and for a language or language version that Lambda doesn't provide a base image for, such as Node.js 19. You can also use OS-only base images to implement a custom runtime. To make the image compatible with Lambda, you must include a runtime interface client for your language in the image.
    
      Using a non-AWS base image
      You can use an alternative base image from another container registry, such as Alpine Linux or Debian. You can also use a custom image created by your organization. To make the image compatible with Lambda, you must include a runtime interface client for your language in the image.
    TipTo reduce the time it takes for Lambda container functions to become active, see Use multi-stage builds in the Docker documentation. To build efficient container images, follow the Best practices for writing Dockerfiles.To create a Lambda function from a container image, build your image locally and upload it to an Amazon Elastic Container Registry (Amazon ECR) repository. Then, specify the repository URI when you create the function. The Amazon ECR repository must be in the same AWS Region as the Lambda function. You can create a function using an image in a different AWS account, as long as the image is in the same Region as the Lambda function. For more information, see  Amazon ECR cross-account permissions.NoteLambda does not support Amazon ECR FIPS endpoints for container images. If your repository URI includes
      ecr-fips, you are using a FIPS endpoint. Example: 111122223333.dkr.ecr-fips.us-east-1.amazonaws.com.This page explains the base image types and requirements for creating Lambda-compatible container images.NoteYou cannot change the deployment package type (.zip or container image) for an existing function. For example, you cannot convert a container image function to use a .zip file archive. You must create a new function.TopicsRequirementsUsing an AWS base image for LambdaUsing an AWS OS-only base imageUsing a non-AWS base imageRuntime interface clientsAmazon ECR permissionsFunction lifecycle
    Requirements
    Install the AWS CLI version 2 and the Docker CLI. 
      Additionally, note the following requirements:
    
       
       
       
       
       
    
        The container image must implement the Using the Lambda runtime API for custom runtimes. The AWS
          open-source runtime interface clients implement the API. You can
          add a runtime interface client to your preferred base image to make it compatible with Lambda.
      
        The container image must be able to run on a read-only file system. Your function code can access a
          writable /tmp directory with between 512 MB and 10,240 MB, in 1-MB increments, of storage.  
      
        The default Lambda user must be able to read all the files required to run your function code. Lambda
          follows security best practices by defining a default Linux user with least-privileged permissions. This means that you don't need to specify a USER  in your Dockerfile. Verify
          that your application code does not rely on files that other Linux users are restricted from running.
      
        Lambda supports only Linux-based container images.
      
        Lambda provides multi-architecture base images. However, the image you build for your function must target
          only one of the architectures. Lambda does not support functions that use multi-architecture container
          images.
      
   
    Using an AWS base image for Lambda
    You can use one of the AWS base images for Lambda to build the container image for your
      function code. The base images are preloaded with a language runtime and other components
      required to run a container image on Lambda. You add your function code and dependencies to the
      base image and then package it as a container image.
    AWS periodically provides updates to the AWS base images for Lambda. If your Dockerfile includes the
      image name in the FROM property, your Docker client pulls the latest version of the image from the Amazon ECR repository. To
      use the updated base image, you must rebuild your container image and update the function code.
      The Node.js 20, Python 3.12, Java 21, .NET 8, Ruby 3.3, and later base images are based on the Amazon Linux 2023 minimal container image. Earlier base images use Amazon Linux 2. AL2023 provides several advantages over Amazon Linux 2, including a smaller deployment footprint and updated versions of libraries such as glibc.
    AL2023-based images use microdnf (symlinked as dnf) as the package manager instead of yum, which is the default package manager in Amazon Linux 2. microdnf is a standalone implementation of dnf. For a list of packages that are included in AL2023-based images, refer to the Minimal Container columns in Comparing packages installed on Amazon Linux 2023 Container Images. For more information about the differences between AL2023 and Amazon Linux 2, see Introducing the Amazon Linux 2023 runtime for AWS Lambda on the AWS
      Compute Blog.    
    NoteTo run AL2023-based images locally, including with AWS Serverless Application Model (AWS SAM), you must use Docker version 20.10.10 or later.  
    To build a container image using an AWS base image, choose the instructions for your preferred language:
    
       
       
       
       
       
       
       
    
        Node.js
      
        TypeScript (uses a Node.js base image) 
      
        Python
      
        Java 
      
        Go
      
        .NET
      
        Ruby
      
   
    Using an AWS OS-only base image
    AWS OS-only base images contain an Amazon Linux distribution and the runtime interface emulator. These images are commonly used to create container images for compiled languages, such as Go and Rust, and for a language or language version that Lambda doesn't provide a base image for, such as Node.js 19. You can also use OS-only base images to implement a custom runtime. To make the image compatible with Lambda, you must include a runtime interface client for your language in the image.
    
          
            Tags
            Runtime
            Operating system
            Dockerfile
            Deprecation
          
        
      
            al2023
            OS-only Runtime
            Amazon Linux 2023
            Dockerfile
                for OS-only Runtime on GitHub
            
                          Jun 30, 2029
            
              
          
      
            al2
            OS-only Runtime
            Amazon Linux 2
            Dockerfile
                for OS-only Runtime on GitHub
            
                          Jun 30, 2026
            
              
          
    
    Amazon Elastic Container Registry Public Gallery: gallery.ecr.aws/lambda/provided
     
    Using a non-AWS base image
    Lambda
      supports any image that conforms to one of the following image manifest formats:
    
       
       
    Docker image manifest V2, schema 2 (used with Docker version 1.10 and newer)Open Container Initiative (OCI) Specifications (v1.0.0 and up)
    Lambda supports a maximum uncompressed image size of 10 GB, including all layers.
    NoteTo make the image compatible with Lambda, you must include a runtime interface client for your language in the image.
   
    Runtime interface clients
    If you use an OS-only base image or an alternative base image, you must include a runtime interface client in your image. The runtime interface client must extend the Using the Lambda runtime API for custom runtimes, which manages the interaction between Lambda and your function code. AWS provides open-source runtime interface clients for the following languages:
    
  
   
  
   
  
   
  
   
  
   
  
   
  
     

    
      Node.js
    
  
    
      Python
    
  
    
      Java
    
  
    
      .NET
    
  
    
      Go
    
  
    
      Ruby
    
  
    
      Rust – The Rust runtime client is an experimental package. It is subject to change and intended only for evaluation purposes.
    
  
    If you're using a language that doesn't have an AWS-provided runtime interface client, you must create your own.
   
    Amazon ECR permissions
    Before you create a Lambda function from a container image, you must build the image locally and upload it to an Amazon ECR repository. When you create the function, specify the Amazon ECR repository URI.
    Make sure that the permissions for the user or role that creates the function includes GetRepositoryPolicy and SetRepositoryPolicy.
    For example, use the IAM console to create a role with the following policy:
    {
  "Version": "2012-10-17",
  "Statement": [
    {
      "Sid": "VisualEditor0",
      "Effect": "Allow",
      "Action": [
        "ecr:SetRepositoryPolicy",
        "ecr:GetRepositoryPolicy"
      ],
      "Resource": "arn:aws:ecr:us-east-1:111122223333:repository/hello-world"
    }
  ]
}
     
      Amazon ECR repository policies
      For a function in the same account as the container image in Amazon ECR, you can add ecr:BatchGetImage
        and ecr:GetDownloadUrlForLayer permissions to your Amazon ECR repository policy. The following example shows the
        minimum policy:
      {
        "Sid": "LambdaECRImageRetrievalPolicy",
        "Effect": "Allow",
        "Principal": {
          "Service": "lambda.amazonaws.com"
        },
        "Action": [
          "ecr:BatchGetImage",
          "ecr:GetDownloadUrlForLayer"
        ]
    }   
      For more information about Amazon ECR
        repository permissions, see Private repository policies in the
        Amazon Elastic Container Registry User Guide.
      If the Amazon ECR repository does not include these permissions, Lambda attempts to add them automatically. Lambda can add
        permissions only if the principal calling Lambda has ecr:getRepositoryPolicy and
          ecr:setRepositoryPolicy permissions. 
      To view or edit your Amazon ECR repository permissions, follow the directions in Setting a private repository policy statement in the
          Amazon Elastic Container Registry User Guide.
       
         Amazon ECR cross-account permissions
        A different account in the same region can create a function that uses a container image owned by your
          account. In the following example, your Amazon ECR repository permissions policy needs the following statements to
          grant access to account number 123456789012.
        
           
           
        CrossAccountPermission – Allows account 123456789012 to create and update Lambda
              functions that use images from this ECR repository.LambdaECRImageCrossAccountRetrievalPolicy – Lambda will eventually set a
              function's state to inactive if it is not invoked for an extended period. This statement is required so that
              Lambda can retrieve the container image for optimization and caching on behalf of the function owned by
              123456789012.  
        Example — Add cross-account permission to your repository{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Sid": "CrossAccountPermission",
      "Effect": "Allow",
      "Action": [
        "ecr:BatchGetImage",
        "ecr:GetDownloadUrlForLayer"
      ],
      "Principal": {
        "AWS": "arn:aws:iam::123456789012:root"
      }
    },
    {
      "Sid": "LambdaECRImageCrossAccountRetrievalPolicy",
      "Effect": "Allow",
      "Action": [
        "ecr:BatchGetImage",
        "ecr:GetDownloadUrlForLayer"
      ],
      "Principal": {
        "Service": "lambda.amazonaws.com"
      },
      "Condition": {
        "StringLike": {
          "aws:sourceARN": "arn:aws:lambda:us-east-1:123456789012:function:*"
        }
      }
    }
  ]
}
        To give access to multiple accounts, you add the account IDs to the Principal list in the
            CrossAccountPermission policy and to the Condition evaluation list in the
            LambdaECRImageCrossAccountRetrievalPolicy.
        If you are working with multiple accounts in an AWS Organization, we recommend that you enumerate each
          account ID in the ECR permissions policy. This approach aligns with the AWS security best practice of setting
          narrow permissions in IAM policies.
        In addition to Lambda permissions, the user or role that creates the function must also have BatchGetImage and GetDownloadUrlForLayer permissions.
       
     
   
    Function lifecycle
    After you upload a new or updated container image, Lambda optimizes the image before the function can process invocations. The
      optimization process can take a few seconds. The function remains in the Pending state until the
      process completes, when the state transitions to Active. You can't invoke the function until it reaches the Active state. 
    If a function is not invoked for multiple weeks, Lambda reclaims its optimized version, and the function
      transitions to the Inactive state. To reactivate the function, you must invoke it. Lambda rejects the
      first invocation and the function enters the Pending state until Lambda re-optimizes the image. The
      function then returns to the Active state.
    Lambda periodically fetches the associated container image from the Amazon ECR repository. If the
      corresponding container image no longer exists on Amazon ECR or permissions are revoked, the function enters the Failed state, and
      Lambda returns a failure for any function invocations.
    You can use the Lambda API to get information about a function's state. For more information, see Lambda function states.
  Document ConventionsEncryptionMemoryDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideRequirementsUsing an AWS base imageUsing an AWS OS-only base imageUsing a non-AWS base imageRuntime interface clientsAmazon ECR permissionsFunction lifecycleCreate a Lambda function using a container imageYour AWS Lambda function's code consists of scripts or compiled programs and their dependencies. 
You use a deployment package to deploy your function code to Lambda. Lambda supports two types of deployment packages: 
container images and .zip file archives. There are three ways to build a container image for a Lambda function:
     
	 
     
  
      Using an AWS base image for Lambda
      The AWS base images are preloaded with a language runtime, a runtime interface client to manage the interaction between Lambda and your function code, and a runtime interface emulator for local testing.
    
      Using an AWS OS-only base image
      AWS OS-only base images contain an Amazon Linux distribution and the runtime interface emulator. These images are commonly used to create container images for compiled languages, such as Go and Rust, and for a language or language version that Lambda doesn't provide a base image for, such as Node.js 19. You can also use OS-only base images to implement a custom runtime. To make the image compatible with Lambda, you must include a runtime interface client for your language in the image.
    
      Using a non-AWS base image
      You can use an alternative base image from another container registry, such as Alpine Linux or Debian. You can also use a custom image created by your organization. To make the image compatible with Lambda, you must include a runtime interface client for your language in the image.
    TipTo reduce the time it takes for Lambda container functions to become active, see Use multi-stage builds in the Docker documentation. To build efficient container images, follow the Best practices for writing Dockerfiles.To create a Lambda function from a container image, build your image locally and upload it to an Amazon Elastic Container Registry (Amazon ECR) repository. Then, specify the repository URI when you create the function. The Amazon ECR repository must be in the same AWS Region as the Lambda function. You can create a function using an image in a different AWS account, as long as the image is in the same Region as the Lambda function. For more information, see  Amazon ECR cross-account permissions.NoteLambda does not support Amazon ECR FIPS endpoints for container images. If your repository URI includes
      ecr-fips, you are using a FIPS endpoint. Example: 111122223333.dkr.ecr-fips.us-east-1.amazonaws.com.This page explains the base image types and requirements for creating Lambda-compatible container images.NoteYou cannot change the deployment package type (.zip or container image) for an existing function. For example, you cannot convert a container image function to use a .zip file archive. You must create a new function.TopicsRequirementsUsing an AWS base image for LambdaUsing an AWS OS-only base imageUsing a non-AWS base imageRuntime interface clientsAmazon ECR permissionsFunction lifecycle
    Requirements
    Install the AWS CLI version 2 and the Docker CLI. 
      Additionally, note the following requirements:
    
       
       
       
       
       
    
        The container image must implement the Using the Lambda runtime API for custom runtimes. The AWS
          open-source runtime interface clients implement the API. You can
          add a runtime interface client to your preferred base image to make it compatible with Lambda.
      
        The container image must be able to run on a read-only file system. Your function code can access a
          writable /tmp directory with between 512 MB and 10,240 MB, in 1-MB increments, of storage.  
      
        The default Lambda user must be able to read all the files required to run your function code. Lambda
          follows security best practices by defining a default Linux user with least-privileged permissions. This means that you don't need to specify a USER  in your Dockerfile. Verify
          that your application code does not rely on files that other Linux users are restricted from running.
      
        Lambda supports only Linux-based container images.
      
        Lambda provides multi-architecture base images. However, the image you build for your function must target
          only one of the architectures. Lambda does not support functions that use multi-architecture container
          images.
      
   
    Using an AWS base image for Lambda
    You can use one of the AWS base images for Lambda to build the container image for your
      function code. The base images are preloaded with a language runtime and other components
      required to run a container image on Lambda. You add your function code and dependencies to the
      base image and then package it as a container image.
    AWS periodically provides updates to the AWS base images for Lambda. If your Dockerfile includes the
      image name in the FROM property, your Docker client pulls the latest version of the image from the Amazon ECR repository. To
      use the updated base image, you must rebuild your container image and update the function code.
      The Node.js 20, Python 3.12, Java 21, .NET 8, Ruby 3.3, and later base images are based on the Amazon Linux 2023 minimal container image. Earlier base images use Amazon Linux 2. AL2023 provides several advantages over Amazon Linux 2, including a smaller deployment footprint and updated versions of libraries such as glibc.
    AL2023-based images use microdnf (symlinked as dnf) as the package manager instead of yum, which is the default package manager in Amazon Linux 2. microdnf is a standalone implementation of dnf. For a list of packages that are included in AL2023-based images, refer to the Minimal Container columns in Comparing packages installed on Amazon Linux 2023 Container Images. For more information about the differences between AL2023 and Amazon Linux 2, see Introducing the Amazon Linux 2023 runtime for AWS Lambda on the AWS
      Compute Blog.    
    NoteTo run AL2023-based images locally, including with AWS Serverless Application Model (AWS SAM), you must use Docker version 20.10.10 or later.  
    To build a container image using an AWS base image, choose the instructions for your preferred language:
    
       
       
       
       
       
       
       
    
        Node.js
      
        TypeScript (uses a Node.js base image) 
      
        Python
      
        Java 
      
        Go
      
        .NET
      
        Ruby
      
   
    Using an AWS OS-only base image
    AWS OS-only base images contain an Amazon Linux distribution and the runtime interface emulator. These images are commonly used to create container images for compiled languages, such as Go and Rust, and for a language or language version that Lambda doesn't provide a base image for, such as Node.js 19. You can also use OS-only base images to implement a custom runtime. To make the image compatible with Lambda, you must include a runtime interface client for your language in the image.
    
          
            Tags
            Runtime
            Operating system
            Dockerfile
            Deprecation
          
        
      
            al2023
            OS-only Runtime
            Amazon Linux 2023
            Dockerfile
                for OS-only Runtime on GitHub
            
                          Jun 30, 2029
            
              
          
      
            al2
            OS-only Runtime
            Amazon Linux 2
            Dockerfile
                for OS-only Runtime on GitHub
            
                          Jun 30, 2026
            
              
          
    
    Amazon Elastic Container Registry Public Gallery: gallery.ecr.aws/lambda/provided
     
    Using a non-AWS base image
    Lambda
      supports any image that conforms to one of the following image manifest formats:
    
       
       
    Docker image manifest V2, schema 2 (used with Docker version 1.10 and newer)Open Container Initiative (OCI) Specifications (v1.0.0 and up)
    Lambda supports a maximum uncompressed image size of 10 GB, including all layers.
    NoteTo make the image compatible with Lambda, you must include a runtime interface client for your language in the image.
   
    Runtime interface clients
    If you use an OS-only base image or an alternative base image, you must include a runtime interface client in your image. The runtime interface client must extend the Using the Lambda runtime API for custom runtimes, which manages the interaction between Lambda and your function code. AWS provides open-source runtime interface clients for the following languages:
    
  
   
  
   
  
   
  
   
  
   
  
   
  
     

    
      Node.js
    
  
    
      Python
    
  
    
      Java
    
  
    
      .NET
    
  
    
      Go
    
  
    
      Ruby
    
  
    
      Rust – The Rust runtime client is an experimental package. It is subject to change and intended only for evaluation purposes.
    
  
    If you're using a language that doesn't have an AWS-provided runtime interface client, you must create your own.
   
    Amazon ECR permissions
    Before you create a Lambda function from a container image, you must build the image locally and upload it to an Amazon ECR repository. When you create the function, specify the Amazon ECR repository URI.
    Make sure that the permissions for the user or role that creates the function includes GetRepositoryPolicy and SetRepositoryPolicy.
    For example, use the IAM console to create a role with the following policy:
    {
  "Version": "2012-10-17",
  "Statement": [
    {
      "Sid": "VisualEditor0",
      "Effect": "Allow",
      "Action": [
        "ecr:SetRepositoryPolicy",
        "ecr:GetRepositoryPolicy"
      ],
      "Resource": "arn:aws:ecr:us-east-1:111122223333:repository/hello-world"
    }
  ]
}
     
      Amazon ECR repository policies
      For a function in the same account as the container image in Amazon ECR, you can add ecr:BatchGetImage
        and ecr:GetDownloadUrlForLayer permissions to your Amazon ECR repository policy. The following example shows the
        minimum policy:
      {
        "Sid": "LambdaECRImageRetrievalPolicy",
        "Effect": "Allow",
        "Principal": {
          "Service": "lambda.amazonaws.com"
        },
        "Action": [
          "ecr:BatchGetImage",
          "ecr:GetDownloadUrlForLayer"
        ]
    }   
      For more information about Amazon ECR
        repository permissions, see Private repository policies in the
        Amazon Elastic Container Registry User Guide.
      If the Amazon ECR repository does not include these permissions, Lambda attempts to add them automatically. Lambda can add
        permissions only if the principal calling Lambda has ecr:getRepositoryPolicy and
          ecr:setRepositoryPolicy permissions. 
      To view or edit your Amazon ECR repository permissions, follow the directions in Setting a private repository policy statement in the
          Amazon Elastic Container Registry User Guide.
       
         Amazon ECR cross-account permissions
        A different account in the same region can create a function that uses a container image owned by your
          account. In the following example, your Amazon ECR repository permissions policy needs the following statements to
          grant access to account number 123456789012.
        
           
           
        CrossAccountPermission – Allows account 123456789012 to create and update Lambda
              functions that use images from this ECR repository.LambdaECRImageCrossAccountRetrievalPolicy – Lambda will eventually set a
              function's state to inactive if it is not invoked for an extended period. This statement is required so that
              Lambda can retrieve the container image for optimization and caching on behalf of the function owned by
              123456789012.  
        Example — Add cross-account permission to your repository{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Sid": "CrossAccountPermission",
      "Effect": "Allow",
      "Action": [
        "ecr:BatchGetImage",
        "ecr:GetDownloadUrlForLayer"
      ],
      "Principal": {
        "AWS": "arn:aws:iam::123456789012:root"
      }
    },
    {
      "Sid": "LambdaECRImageCrossAccountRetrievalPolicy",
      "Effect": "Allow",
      "Action": [
        "ecr:BatchGetImage",
        "ecr:GetDownloadUrlForLayer"
      ],
      "Principal": {
        "Service": "lambda.amazonaws.com"
      },
      "Condition": {
        "StringLike": {
          "aws:sourceARN": "arn:aws:lambda:us-east-1:123456789012:function:*"
        }
      }
    }
  ]
}
        To give access to multiple accounts, you add the account IDs to the Principal list in the
            CrossAccountPermission policy and to the Condition evaluation list in the
            LambdaECRImageCrossAccountRetrievalPolicy.
        If you are working with multiple accounts in an AWS Organization, we recommend that you enumerate each
          account ID in the ECR permissions policy. This approach aligns with the AWS security best practice of setting
          narrow permissions in IAM policies.
        In addition to Lambda permissions, the user or role that creates the function must also have BatchGetImage and GetDownloadUrlForLayer permissions.
       
     
   
    Function lifecycle
    After you upload a new or updated container image, Lambda optimizes the image before the function can process invocations. The
      optimization process can take a few seconds. The function remains in the Pending state until the
      process completes, when the state transitions to Active. You can't invoke the function until it reaches the Active state. 
    If a function is not invoked for multiple weeks, Lambda reclaims its optimized version, and the function
      transitions to the Inactive state. To reactivate the function, you must invoke it. Lambda rejects the
      first invocation and the function enters the Pending state until Lambda re-optimizes the image. The
      function then returns to the Active state.
    Lambda periodically fetches the associated container image from the Amazon ECR repository. If the
      corresponding container image no longer exists on Amazon ECR or permissions are revoked, the function enters the Failed state, and
      Lambda returns a failure for any function invocations.
    You can use the Lambda API to get information about a function's state. For more information, see Lambda function states.
  Document ConventionsEncryptionMemoryDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideRequirementsUsing an AWS base imageUsing an AWS OS-only base imageUsing a non-AWS base imageRuntime interface clientsAmazon ECR permissionsFunction lifecycleCreate a Lambda function using a container imageYour AWS Lambda function's code consists of scripts or compiled programs and their dependencies. 
You use a deployment package to deploy your function code to Lambda. Lambda supports two types of deployment packages: 
container images and .zip file archives. There are three ways to build a container image for a Lambda function:
     
	 
     
  
      Using an AWS base image for Lambda
      The AWS base images are preloaded with a language runtime, a runtime interface client to manage the interaction between Lambda and your function code, and a runtime interface emulator for local testing.
    
      Using an AWS OS-only base image
      AWS OS-only base images contain an Amazon Linux distribution and the runtime interface emulator. These images are commonly used to create container images for compiled languages, such as Go and Rust, and for a language or language version that Lambda doesn't provide a base image for, such as Node.js 19. You can also use OS-only base images to implement a custom runtime. To make the image compatible with Lambda, you must include a runtime interface client for your language in the image.
    
      Using a non-AWS base image
      You can use an alternative base image from another container registry, such as Alpine Linux or Debian. You can also use a custom image created by your organization. To make the image compatible with Lambda, you must include a runtime interface client for your language in the image.
    TipTo reduce the time it takes for Lambda container functions to become active, see Use multi-stage builds in the Docker documentation. To build efficient container images, follow the Best practices for writing Dockerfiles.To create a Lambda function from a container image, build your image locally and upload it to an Amazon Elastic Container Registry (Amazon ECR) repository. Then, specify the repository URI when you create the function. The Amazon ECR repository must be in the same AWS Region as the Lambda function. You can create a function using an image in a different AWS account, as long as the image is in the same Region as the Lambda function. For more information, see  Amazon ECR cross-account permissions.NoteLambda does not support Amazon ECR FIPS endpoints for container images. If your repository URI includes
      ecr-fips, you are using a FIPS endpoint. Example: 111122223333.dkr.ecr-fips.us-east-1.amazonaws.com.This page explains the base image types and requirements for creating Lambda-compatible container images.NoteYou cannot change the deployment package type (.zip or container image) for an existing function. For example, you cannot convert a container image function to use a .zip file archive. You must create a new function.TopicsRequirementsUsing an AWS base image for LambdaUsing an AWS OS-only base imageUsing a non-AWS base imageRuntime interface clientsAmazon ECR permissionsFunction lifecycle
    Requirements
    Install the AWS CLI version 2 and the Docker CLI. 
      Additionally, note the following requirements:
    
       
       
       
       
       
    
        The container image must implement the Using the Lambda runtime API for custom runtimes. The AWS
          open-source runtime interface clients implement the API. You can
          add a runtime interface client to your preferred base image to make it compatible with Lambda.
      
        The container image must be able to run on a read-only file system. Your function code can access a
          writable /tmp directory with between 512 MB and 10,240 MB, in 1-MB increments, of storage.  
      
        The default Lambda user must be able to read all the files required to run your function code. Lambda
          follows security best practices by defining a default Linux user with least-privileged permissions. This means that you don't need to specify a USER  in your Dockerfile. Verify
          that your application code does not rely on files that other Linux users are restricted from running.
      
        Lambda supports only Linux-based container images.
      
        Lambda provides multi-architecture base images. However, the image you build for your function must target
          only one of the architectures. Lambda does not support functions that use multi-architecture container
          images.
      
   
    Using an AWS base image for Lambda
    You can use one of the AWS base images for Lambda to build the container image for your
      function code. The base images are preloaded with a language runtime and other components
      required to run a container image on Lambda. You add your function code and dependencies to the
      base image and then package it as a container image.
    AWS periodically provides updates to the AWS base images for Lambda. If your Dockerfile includes the
      image name in the FROM property, your Docker client pulls the latest version of the image from the Amazon ECR repository. To
      use the updated base image, you must rebuild your container image and update the function code.
      The Node.js 20, Python 3.12, Java 21, .NET 8, Ruby 3.3, and later base images are based on the Amazon Linux 2023 minimal container image. Earlier base images use Amazon Linux 2. AL2023 provides several advantages over Amazon Linux 2, including a smaller deployment footprint and updated versions of libraries such as glibc.
    AL2023-based images use microdnf (symlinked as dnf) as the package manager instead of yum, which is the default package manager in Amazon Linux 2. microdnf is a standalone implementation of dnf. For a list of packages that are included in AL2023-based images, refer to the Minimal Container columns in Comparing packages installed on Amazon Linux 2023 Container Images. For more information about the differences between AL2023 and Amazon Linux 2, see Introducing the Amazon Linux 2023 runtime for AWS Lambda on the AWS
      Compute Blog.    
    NoteTo run AL2023-based images locally, including with AWS Serverless Application Model (AWS SAM), you must use Docker version 20.10.10 or later.  
    To build a container image using an AWS base image, choose the instructions for your preferred language:
    
       
       
       
       
       
       
       
    
        Node.js
      
        TypeScript (uses a Node.js base image) 
      
        Python
      
        Java 
      
        Go
      
        .NET
      
        Ruby
      
   
    Using an AWS OS-only base image
    AWS OS-only base images contain an Amazon Linux distribution and the runtime interface emulator. These images are commonly used to create container images for compiled languages, such as Go and Rust, and for a language or language version that Lambda doesn't provide a base image for, such as Node.js 19. You can also use OS-only base images to implement a custom runtime. To make the image compatible with Lambda, you must include a runtime interface client for your language in the image.
    
          
            Tags
            Runtime
            Operating system
            Dockerfile
            Deprecation
          
        
      
            al2023
            OS-only Runtime
            Amazon Linux 2023
            Dockerfile
                for OS-only Runtime on GitHub
            
                          Jun 30, 2029
            
              
          
      
            al2
            OS-only Runtime
            Amazon Linux 2
            Dockerfile
                for OS-only Runtime on GitHub
            
                          Jun 30, 2026
            
              
          
    
    Amazon Elastic Container Registry Public Gallery: gallery.ecr.aws/lambda/provided
     
    Using a non-AWS base image
    Lambda
      supports any image that conforms to one of the following image manifest formats:
    
       
       
    Docker image manifest V2, schema 2 (used with Docker version 1.10 and newer)Open Container Initiative (OCI) Specifications (v1.0.0 and up)
    Lambda supports a maximum uncompressed image size of 10 GB, including all layers.
    NoteTo make the image compatible with Lambda, you must include a runtime interface client for your language in the image.
   
    Runtime interface clients
    If you use an OS-only base image or an alternative base image, you must include a runtime interface client in your image. The runtime interface client must extend the Using the Lambda runtime API for custom runtimes, which manages the interaction between Lambda and your function code. AWS provides open-source runtime interface clients for the following languages:
    
  
   
  
   
  
   
  
   
  
   
  
   
  
     

    
      Node.js
    
  
    
      Python
    
  
    
      Java
    
  
    
      .NET
    
  
    
      Go
    
  
    
      Ruby
    
  
    
      Rust – The Rust runtime client is an experimental package. It is subject to change and intended only for evaluation purposes.
    
  
    If you're using a language that doesn't have an AWS-provided runtime interface client, you must create your own.
   
    Amazon ECR permissions
    Before you create a Lambda function from a container image, you must build the image locally and upload it to an Amazon ECR repository. When you create the function, specify the Amazon ECR repository URI.
    Make sure that the permissions for the user or role that creates the function includes GetRepositoryPolicy and SetRepositoryPolicy.
    For example, use the IAM console to create a role with the following policy:
    {
  "Version": "2012-10-17",
  "Statement": [
    {
      "Sid": "VisualEditor0",
      "Effect": "Allow",
      "Action": [
        "ecr:SetRepositoryPolicy",
        "ecr:GetRepositoryPolicy"
      ],
      "Resource": "arn:aws:ecr:us-east-1:111122223333:repository/hello-world"
    }
  ]
}
     
      Amazon ECR repository policies
      For a function in the same account as the container image in Amazon ECR, you can add ecr:BatchGetImage
        and ecr:GetDownloadUrlForLayer permissions to your Amazon ECR repository policy. The following example shows the
        minimum policy:
      {
        "Sid": "LambdaECRImageRetrievalPolicy",
        "Effect": "Allow",
        "Principal": {
          "Service": "lambda.amazonaws.com"
        },
        "Action": [
          "ecr:BatchGetImage",
          "ecr:GetDownloadUrlForLayer"
        ]
    }   
      For more information about Amazon ECR
        repository permissions, see Private repository policies in the
        Amazon Elastic Container Registry User Guide.
      If the Amazon ECR repository does not include these permissions, Lambda attempts to add them automatically. Lambda can add
        permissions only if the principal calling Lambda has ecr:getRepositoryPolicy and
          ecr:setRepositoryPolicy permissions. 
      To view or edit your Amazon ECR repository permissions, follow the directions in Setting a private repository policy statement in the
          Amazon Elastic Container Registry User Guide.
       
         Amazon ECR cross-account permissions
        A different account in the same region can create a function that uses a container image owned by your
          account. In the following example, your Amazon ECR repository permissions policy needs the following statements to
          grant access to account number 123456789012.
        
           
           
        CrossAccountPermission – Allows account 123456789012 to create and update Lambda
              functions that use images from this ECR repository.LambdaECRImageCrossAccountRetrievalPolicy – Lambda will eventually set a
              function's state to inactive if it is not invoked for an extended period. This statement is required so that
              Lambda can retrieve the container image for optimization and caching on behalf of the function owned by
              123456789012.  
        Example — Add cross-account permission to your repository{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Sid": "CrossAccountPermission",
      "Effect": "Allow",
      "Action": [
        "ecr:BatchGetImage",
        "ecr:GetDownloadUrlForLayer"
      ],
      "Principal": {
        "AWS": "arn:aws:iam::123456789012:root"
      }
    },
    {
      "Sid": "LambdaECRImageCrossAccountRetrievalPolicy",
      "Effect": "Allow",
      "Action": [
        "ecr:BatchGetImage",
        "ecr:GetDownloadUrlForLayer"
      ],
      "Principal": {
        "Service": "lambda.amazonaws.com"
      },
      "Condition": {
        "StringLike": {
          "aws:sourceARN": "arn:aws:lambda:us-east-1:123456789012:function:*"
        }
      }
    }
  ]
}
        To give access to multiple accounts, you add the account IDs to the Principal list in the
            CrossAccountPermission policy and to the Condition evaluation list in the
            LambdaECRImageCrossAccountRetrievalPolicy.
        If you are working with multiple accounts in an AWS Organization, we recommend that you enumerate each
          account ID in the ECR permissions policy. This approach aligns with the AWS security best practice of setting
          narrow permissions in IAM policies.
        In addition to Lambda permissions, the user or role that creates the function must also have BatchGetImage and GetDownloadUrlForLayer permissions.
       
     
   
    Function lifecycle
    After you upload a new or updated container image, Lambda optimizes the image before the function can process invocations. The
      optimization process can take a few seconds. The function remains in the Pending state until the
      process completes, when the state transitions to Active. You can't invoke the function until it reaches the Active state. 
    If a function is not invoked for multiple weeks, Lambda reclaims its optimized version, and the function
      transitions to the Inactive state. To reactivate the function, you must invoke it. Lambda rejects the
      first invocation and the function enters the Pending state until Lambda re-optimizes the image. The
      function then returns to the Active state.
    Lambda periodically fetches the associated container image from the Amazon ECR repository. If the
      corresponding container image no longer exists on Amazon ECR or permissions are revoked, the function enters the Failed state, and
      Lambda returns a failure for any function invocations.
    You can use the Lambda API to get information about a function's state. For more information, see Lambda function states.
  Document ConventionsEncryptionMemoryDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideRequirementsUsing an AWS base imageUsing an AWS OS-only base imageUsing a non-AWS base imageRuntime interface clientsAmazon ECR permissionsFunction lifecycleCreate a Lambda function using a container imageYour AWS Lambda function's code consists of scripts or compiled programs and their dependencies. 
You use a deployment package to deploy your function code to Lambda. Lambda supports two types of deployment packages: 
container images and .zip file archives. There are three ways to build a container image for a Lambda function:
     
	 
     
  
      Using an AWS base image for Lambda
      The AWS base images are preloaded with a language runtime, a runtime interface client to manage the interaction between Lambda and your function code, and a runtime interface emulator for local testing.
    
      Using an AWS OS-only base image
      AWS OS-only base images contain an Amazon Linux distribution and the runtime interface emulator. These images are commonly used to create container images for compiled languages, such as Go and Rust, and for a language or language version that Lambda doesn't provide a base image for, such as Node.js 19. You can also use OS-only base images to implement a custom runtime. To make the image compatible with Lambda, you must include a runtime interface client for your language in the image.
    
      Using a non-AWS base image
      You can use an alternative base image from another container registry, such as Alpine Linux or Debian. You can also use a custom image created by your organization. To make the image compatible with Lambda, you must include a runtime interface client for your language in the image.
    TipTo reduce the time it takes for Lambda container functions to become active, see Use multi-stage builds in the Docker documentation. To build efficient container images, follow the Best practices for writing Dockerfiles.To create a Lambda function from a container image, build your image locally and upload it to an Amazon Elastic Container Registry (Amazon ECR) repository. Then, specify the repository URI when you create the function. The Amazon ECR repository must be in the same AWS Region as the Lambda function. You can create a function using an image in a different AWS account, as long as the image is in the same Region as the Lambda function. For more information, see  Amazon ECR cross-account permissions.NoteLambda does not support Amazon ECR FIPS endpoints for container images. If your repository URI includes
      ecr-fips, you are using a FIPS endpoint. Example: 111122223333.dkr.ecr-fips.us-east-1.amazonaws.com.This page explains the base image types and requirements for creating Lambda-compatible container images.NoteYou cannot change the deployment package type (.zip or container image) for an existing function. For example, you cannot convert a container image function to use a .zip file archive. You must create a new function.TopicsRequirementsUsing an AWS base image for LambdaUsing an AWS OS-only base imageUsing a non-AWS base imageRuntime interface clientsAmazon ECR permissionsFunction lifecycle
    Requirements
    Install the AWS CLI version 2 and the Docker CLI. 
      Additionally, note the following requirements:
    
       
       
       
       
       
    
        The container image must implement the Using the Lambda runtime API for custom runtimes. The AWS
          open-source runtime interface clients implement the API. You can
          add a runtime interface client to your preferred base image to make it compatible with Lambda.
      
        The container image must be able to run on a read-only file system. Your function code can access a
          writable /tmp directory with between 512 MB and 10,240 MB, in 1-MB increments, of storage.  
      
        The default Lambda user must be able to read all the files required to run your function code. Lambda
          follows security best practices by defining a default Linux user with least-privileged permissions. This means that you don't need to specify a USER  in your Dockerfile. Verify
          that your application code does not rely on files that other Linux users are restricted from running.
      
        Lambda supports only Linux-based container images.
      
        Lambda provides multi-architecture base images. However, the image you build for your function must target
          only one of the architectures. Lambda does not support functions that use multi-architecture container
          images.
      
   
    Using an AWS base image for Lambda
    You can use one of the AWS base images for Lambda to build the container image for your
      function code. The base images are preloaded with a language runtime and other components
      required to run a container image on Lambda. You add your function code and dependencies to the
      base image and then package it as a container image.
    AWS periodically provides updates to the AWS base images for Lambda. If your Dockerfile includes the
      image name in the FROM property, your Docker client pulls the latest version of the image from the Amazon ECR repository. To
      use the updated base image, you must rebuild your container image and update the function code.
      The Node.js 20, Python 3.12, Java 21, .NET 8, Ruby 3.3, and later base images are based on the Amazon Linux 2023 minimal container image. Earlier base images use Amazon Linux 2. AL2023 provides several advantages over Amazon Linux 2, including a smaller deployment footprint and updated versions of libraries such as glibc.
    AL2023-based images use microdnf (symlinked as dnf) as the package manager instead of yum, which is the default package manager in Amazon Linux 2. microdnf is a standalone implementation of dnf. For a list of packages that are included in AL2023-based images, refer to the Minimal Container columns in Comparing packages installed on Amazon Linux 2023 Container Images. For more information about the differences between AL2023 and Amazon Linux 2, see Introducing the Amazon Linux 2023 runtime for AWS Lambda on the AWS
      Compute Blog.    
    NoteTo run AL2023-based images locally, including with AWS Serverless Application Model (AWS SAM), you must use Docker version 20.10.10 or later.  
    To build a container image using an AWS base image, choose the instructions for your preferred language:
    
       
       
       
       
       
       
       
    
        Node.js
      
        TypeScript (uses a Node.js base image) 
      
        Python
      
        Java 
      
        Go
      
        .NET
      
        Ruby
      
   
    Using an AWS OS-only base image
    AWS OS-only base images contain an Amazon Linux distribution and the runtime interface emulator. These images are commonly used to create container images for compiled languages, such as Go and Rust, and for a language or language version that Lambda doesn't provide a base image for, such as Node.js 19. You can also use OS-only base images to implement a custom runtime. To make the image compatible with Lambda, you must include a runtime interface client for your language in the image.
    
          
            Tags
            Runtime
            Operating system
            Dockerfile
            Deprecation
          
        
      
            al2023
            OS-only Runtime
            Amazon Linux 2023
            Dockerfile
                for OS-only Runtime on GitHub
            
                          Jun 30, 2029
            
              
          
      
            al2
            OS-only Runtime
            Amazon Linux 2
            Dockerfile
                for OS-only Runtime on GitHub
            
                          Jun 30, 2026
            
              
          
    
    Amazon Elastic Container Registry Public Gallery: gallery.ecr.aws/lambda/provided
     
    Using a non-AWS base image
    Lambda
      supports any image that conforms to one of the following image manifest formats:
    
       
       
    Docker image manifest V2, schema 2 (used with Docker version 1.10 and newer)Open Container Initiative (OCI) Specifications (v1.0.0 and up)
    Lambda supports a maximum uncompressed image size of 10 GB, including all layers.
    NoteTo make the image compatible with Lambda, you must include a runtime interface client for your language in the image.
   
    Runtime interface clients
    If you use an OS-only base image or an alternative base image, you must include a runtime interface client in your image. The runtime interface client must extend the Using the Lambda runtime API for custom runtimes, which manages the interaction between Lambda and your function code. AWS provides open-source runtime interface clients for the following languages:
    
  
   
  
   
  
   
  
   
  
   
  
   
  
     

    
      Node.js
    
  
    
      Python
    
  
    
      Java
    
  
    
      .NET
    
  
    
      Go
    
  
    
      Ruby
    
  
    
      Rust – The Rust runtime client is an experimental package. It is subject to change and intended only for evaluation purposes.
    
  
    If you're using a language that doesn't have an AWS-provided runtime interface client, you must create your own.
   
    Amazon ECR permissions
    Before you create a Lambda function from a container image, you must build the image locally and upload it to an Amazon ECR repository. When you create the function, specify the Amazon ECR repository URI.
    Make sure that the permissions for the user or role that creates the function includes GetRepositoryPolicy and SetRepositoryPolicy.
    For example, use the IAM console to create a role with the following policy:
    {
  "Version": "2012-10-17",
  "Statement": [
    {
      "Sid": "VisualEditor0",
      "Effect": "Allow",
      "Action": [
        "ecr:SetRepositoryPolicy",
        "ecr:GetRepositoryPolicy"
      ],
      "Resource": "arn:aws:ecr:us-east-1:111122223333:repository/hello-world"
    }
  ]
}
     
      Amazon ECR repository policies
      For a function in the same account as the container image in Amazon ECR, you can add ecr:BatchGetImage
        and ecr:GetDownloadUrlForLayer permissions to your Amazon ECR repository policy. The following example shows the
        minimum policy:
      {
        "Sid": "LambdaECRImageRetrievalPolicy",
        "Effect": "Allow",
        "Principal": {
          "Service": "lambda.amazonaws.com"
        },
        "Action": [
          "ecr:BatchGetImage",
          "ecr:GetDownloadUrlForLayer"
        ]
    }   
      For more information about Amazon ECR
        repository permissions, see Private repository policies in the
        Amazon Elastic Container Registry User Guide.
      If the Amazon ECR repository does not include these permissions, Lambda attempts to add them automatically. Lambda can add
        permissions only if the principal calling Lambda has ecr:getRepositoryPolicy and
          ecr:setRepositoryPolicy permissions. 
      To view or edit your Amazon ECR repository permissions, follow the directions in Setting a private repository policy statement in the
          Amazon Elastic Container Registry User Guide.
       
         Amazon ECR cross-account permissions
        A different account in the same region can create a function that uses a container image owned by your
          account. In the following example, your Amazon ECR repository permissions policy needs the following statements to
          grant access to account number 123456789012.
        
           
           
        CrossAccountPermission – Allows account 123456789012 to create and update Lambda
              functions that use images from this ECR repository.LambdaECRImageCrossAccountRetrievalPolicy – Lambda will eventually set a
              function's state to inactive if it is not invoked for an extended period. This statement is required so that
              Lambda can retrieve the container image for optimization and caching on behalf of the function owned by
              123456789012.  
        Example — Add cross-account permission to your repository{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Sid": "CrossAccountPermission",
      "Effect": "Allow",
      "Action": [
        "ecr:BatchGetImage",
        "ecr:GetDownloadUrlForLayer"
      ],
      "Principal": {
        "AWS": "arn:aws:iam::123456789012:root"
      }
    },
    {
      "Sid": "LambdaECRImageCrossAccountRetrievalPolicy",
      "Effect": "Allow",
      "Action": [
        "ecr:BatchGetImage",
        "ecr:GetDownloadUrlForLayer"
      ],
      "Principal": {
        "Service": "lambda.amazonaws.com"
      },
      "Condition": {
        "StringLike": {
          "aws:sourceARN": "arn:aws:lambda:us-east-1:123456789012:function:*"
        }
      }
    }
  ]
}
        To give access to multiple accounts, you add the account IDs to the Principal list in the
            CrossAccountPermission policy and to the Condition evaluation list in the
            LambdaECRImageCrossAccountRetrievalPolicy.
        If you are working with multiple accounts in an AWS Organization, we recommend that you enumerate each
          account ID in the ECR permissions policy. This approach aligns with the AWS security best practice of setting
          narrow permissions in IAM policies.
        In addition to Lambda permissions, the user or role that creates the function must also have BatchGetImage and GetDownloadUrlForLayer permissions.
       
     
   
    Function lifecycle
    After you upload a new or updated container image, Lambda optimizes the image before the function can process invocations. The
      optimization process can take a few seconds. The function remains in the Pending state until the
      process completes, when the state transitions to Active. You can't invoke the function until it reaches the Active state. 
    If a function is not invoked for multiple weeks, Lambda reclaims its optimized version, and the function
      transitions to the Inactive state. To reactivate the function, you must invoke it. Lambda rejects the
      first invocation and the function enters the Pending state until Lambda re-optimizes the image. The
      function then returns to the Active state.
    Lambda periodically fetches the associated container image from the Amazon ECR repository. If the
      corresponding container image no longer exists on Amazon ECR or permissions are revoked, the function enters the Failed state, and
      Lambda returns a failure for any function invocations.
    You can use the Lambda API to get information about a function's state. For more information, see Lambda function states.
  Document ConventionsEncryptionMemoryDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideRequirementsUsing an AWS base imageUsing an AWS OS-only base imageUsing a non-AWS base imageRuntime interface clientsAmazon ECR permissionsFunction lifecycleCreate a Lambda function using a container imageYour AWS Lambda function's code consists of scripts or compiled programs and their dependencies. 
You use a deployment package to deploy your function code to Lambda. Lambda supports two types of deployment packages: 
container images and .zip file archives. There are three ways to build a container image for a Lambda function:
     
	 
     
  
      Using an AWS base image for Lambda
      The AWS base images are preloaded with a language runtime, a runtime interface client to manage the interaction between Lambda and your function code, and a runtime interface emulator for local testing.
    
      Using an AWS OS-only base image
      AWS OS-only base images contain an Amazon Linux distribution and the runtime interface emulator. These images are commonly used to create container images for compiled languages, such as Go and Rust, and for a language or language version that Lambda doesn't provide a base image for, such as Node.js 19. You can also use OS-only base images to implement a custom runtime. To make the image compatible with Lambda, you must include a runtime interface client for your language in the image.
    
      Using a non-AWS base image
      You can use an alternative base image from another container registry, such as Alpine Linux or Debian. You can also use a custom image created by your organization. To make the image compatible with Lambda, you must include a runtime interface client for your language in the image.
    TipTo reduce the time it takes for Lambda container functions to become active, see Use multi-stage builds in the Docker documentation. To build efficient container images, follow the Best practices for writing Dockerfiles.To create a Lambda function from a container image, build your image locally and upload it to an Amazon Elastic Container Registry (Amazon ECR) repository. Then, specify the repository URI when you create the function. The Amazon ECR repository must be in the same AWS Region as the Lambda function. You can create a function using an image in a different AWS account, as long as the image is in the same Region as the Lambda function. For more information, see  Amazon ECR cross-account permissions.NoteLambda does not support Amazon ECR FIPS endpoints for container images. If your repository URI includes
      ecr-fips, you are using a FIPS endpoint. Example: 111122223333.dkr.ecr-fips.us-east-1.amazonaws.com.This page explains the base image types and requirements for creating Lambda-compatible container images.NoteYou cannot change the deployment package type (.zip or container image) for an existing function. For example, you cannot convert a container image function to use a .zip file archive. You must create a new function.TopicsRequirementsUsing an AWS base image for LambdaUsing an AWS OS-only base imageUsing a non-AWS base imageRuntime interface clientsAmazon ECR permissionsFunction lifecycle
    Requirements
    Install the AWS CLI version 2 and the Docker CLI. 
      Additionally, note the following requirements:
    
       
       
       
       
       
    
        The container image must implement the Using the Lambda runtime API for custom runtimes. The AWS
          open-source runtime interface clients implement the API. You can
          add a runtime interface client to your preferred base image to make it compatible with Lambda.
      
        The container image must be able to run on a read-only file system. Your function code can access a
          writable /tmp directory with between 512 MB and 10,240 MB, in 1-MB increments, of storage.  
      
        The default Lambda user must be able to read all the files required to run your function code. Lambda
          follows security best practices by defining a default Linux user with least-privileged permissions. This means that you don't need to specify a USER  in your Dockerfile. Verify
          that your application code does not rely on files that other Linux users are restricted from running.
      
        Lambda supports only Linux-based container images.
      
        Lambda provides multi-architecture base images. However, the image you build for your function must target
          only one of the architectures. Lambda does not support functions that use multi-architecture container
          images.
      
   
    Using an AWS base image for Lambda
    You can use one of the AWS base images for Lambda to build the container image for your
      function code. The base images are preloaded with a language runtime and other components
      required to run a container image on Lambda. You add your function code and dependencies to the
      base image and then package it as a container image.
    AWS periodically provides updates to the AWS base images for Lambda. If your Dockerfile includes the
      image name in the FROM property, your Docker client pulls the latest version of the image from the Amazon ECR repository. To
      use the updated base image, you must rebuild your container image and update the function code.
      The Node.js 20, Python 3.12, Java 21, .NET 8, Ruby 3.3, and later base images are based on the Amazon Linux 2023 minimal container image. Earlier base images use Amazon Linux 2. AL2023 provides several advantages over Amazon Linux 2, including a smaller deployment footprint and updated versions of libraries such as glibc.
    AL2023-based images use microdnf (symlinked as dnf) as the package manager instead of yum, which is the default package manager in Amazon Linux 2. microdnf is a standalone implementation of dnf. For a list of packages that are included in AL2023-based images, refer to the Minimal Container columns in Comparing packages installed on Amazon Linux 2023 Container Images. For more information about the differences between AL2023 and Amazon Linux 2, see Introducing the Amazon Linux 2023 runtime for AWS Lambda on the AWS
      Compute Blog.    
    NoteTo run AL2023-based images locally, including with AWS Serverless Application Model (AWS SAM), you must use Docker version 20.10.10 or later.  
    To build a container image using an AWS base image, choose the instructions for your preferred language:
    
       
       
       
       
       
       
       
    
        Node.js
      
        TypeScript (uses a Node.js base image) 
      
        Python
      
        Java 
      
        Go
      
        .NET
      
        Ruby
      
   
    Using an AWS OS-only base image
    AWS OS-only base images contain an Amazon Linux distribution and the runtime interface emulator. These images are commonly used to create container images for compiled languages, such as Go and Rust, and for a language or language version that Lambda doesn't provide a base image for, such as Node.js 19. You can also use OS-only base images to implement a custom runtime. To make the image compatible with Lambda, you must include a runtime interface client for your language in the image.
    
          
            Tags
            Runtime
            Operating system
            Dockerfile
            Deprecation
          
        
      
            al2023
            OS-only Runtime
            Amazon Linux 2023
            Dockerfile
                for OS-only Runtime on GitHub
            
                          Jun 30, 2029
            
              
          
      
            al2
            OS-only Runtime
            Amazon Linux 2
            Dockerfile
                for OS-only Runtime on GitHub
            
                          Jun 30, 2026
            
              
          
    
    Amazon Elastic Container Registry Public Gallery: gallery.ecr.aws/lambda/provided
     
    Using a non-AWS base image
    Lambda
      supports any image that conforms to one of the following image manifest formats:
    
       
       
    Docker image manifest V2, schema 2 (used with Docker version 1.10 and newer)Open Container Initiative (OCI) Specifications (v1.0.0 and up)
    Lambda supports a maximum uncompressed image size of 10 GB, including all layers.
    NoteTo make the image compatible with Lambda, you must include a runtime interface client for your language in the image.
   
    Runtime interface clients
    If you use an OS-only base image or an alternative base image, you must include a runtime interface client in your image. The runtime interface client must extend the Using the Lambda runtime API for custom runtimes, which manages the interaction between Lambda and your function code. AWS provides open-source runtime interface clients for the following languages:
    
  
   
  
   
  
   
  
   
  
   
  
   
  
     

    
      Node.js
    
  
    
      Python
    
  
    
      Java
    
  
    
      .NET
    
  
    
      Go
    
  
    
      Ruby
    
  
    
      Rust – The Rust runtime client is an experimental package. It is subject to change and intended only for evaluation purposes.
    
  
    If you're using a language that doesn't have an AWS-provided runtime interface client, you must create your own.
   
    Amazon ECR permissions
    Before you create a Lambda function from a container image, you must build the image locally and upload it to an Amazon ECR repository. When you create the function, specify the Amazon ECR repository URI.
    Make sure that the permissions for the user or role that creates the function includes GetRepositoryPolicy and SetRepositoryPolicy.
    For example, use the IAM console to create a role with the following policy:
    {
  "Version": "2012-10-17",
  "Statement": [
    {
      "Sid": "VisualEditor0",
      "Effect": "Allow",
      "Action": [
        "ecr:SetRepositoryPolicy",
        "ecr:GetRepositoryPolicy"
      ],
      "Resource": "arn:aws:ecr:us-east-1:111122223333:repository/hello-world"
    }
  ]
}
     
      Amazon ECR repository policies
      For a function in the same account as the container image in Amazon ECR, you can add ecr:BatchGetImage
        and ecr:GetDownloadUrlForLayer permissions to your Amazon ECR repository policy. The following example shows the
        minimum policy:
      {
        "Sid": "LambdaECRImageRetrievalPolicy",
        "Effect": "Allow",
        "Principal": {
          "Service": "lambda.amazonaws.com"
        },
        "Action": [
          "ecr:BatchGetImage",
          "ecr:GetDownloadUrlForLayer"
        ]
    }   
      For more information about Amazon ECR
        repository permissions, see Private repository policies in the
        Amazon Elastic Container Registry User Guide.
      If the Amazon ECR repository does not include these permissions, Lambda attempts to add them automatically. Lambda can add
        permissions only if the principal calling Lambda has ecr:getRepositoryPolicy and
          ecr:setRepositoryPolicy permissions. 
      To view or edit your Amazon ECR repository permissions, follow the directions in Setting a private repository policy statement in the
          Amazon Elastic Container Registry User Guide.
       
         Amazon ECR cross-account permissions
        A different account in the same region can create a function that uses a container image owned by your
          account. In the following example, your Amazon ECR repository permissions policy needs the following statements to
          grant access to account number 123456789012.
        
           
           
        CrossAccountPermission – Allows account 123456789012 to create and update Lambda
              functions that use images from this ECR repository.LambdaECRImageCrossAccountRetrievalPolicy – Lambda will eventually set a
              function's state to inactive if it is not invoked for an extended period. This statement is required so that
              Lambda can retrieve the container image for optimization and caching on behalf of the function owned by
              123456789012.  
        Example — Add cross-account permission to your repository{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Sid": "CrossAccountPermission",
      "Effect": "Allow",
      "Action": [
        "ecr:BatchGetImage",
        "ecr:GetDownloadUrlForLayer"
      ],
      "Principal": {
        "AWS": "arn:aws:iam::123456789012:root"
      }
    },
    {
      "Sid": "LambdaECRImageCrossAccountRetrievalPolicy",
      "Effect": "Allow",
      "Action": [
        "ecr:BatchGetImage",
        "ecr:GetDownloadUrlForLayer"
      ],
      "Principal": {
        "Service": "lambda.amazonaws.com"
      },
      "Condition": {
        "StringLike": {
          "aws:sourceARN": "arn:aws:lambda:us-east-1:123456789012:function:*"
        }
      }
    }
  ]
}
        To give access to multiple accounts, you add the account IDs to the Principal list in the
            CrossAccountPermission policy and to the Condition evaluation list in the
            LambdaECRImageCrossAccountRetrievalPolicy.
        If you are working with multiple accounts in an AWS Organization, we recommend that you enumerate each
          account ID in the ECR permissions policy. This approach aligns with the AWS security best practice of setting
          narrow permissions in IAM policies.
        In addition to Lambda permissions, the user or role that creates the function must also have BatchGetImage and GetDownloadUrlForLayer permissions.
       
     
   
    Function lifecycle
    After you upload a new or updated container image, Lambda optimizes the image before the function can process invocations. The
      optimization process can take a few seconds. The function remains in the Pending state until the
      process completes, when the state transitions to Active. You can't invoke the function until it reaches the Active state. 
    If a function is not invoked for multiple weeks, Lambda reclaims its optimized version, and the function
      transitions to the Inactive state. To reactivate the function, you must invoke it. Lambda rejects the
      first invocation and the function enters the Pending state until Lambda re-optimizes the image. The
      function then returns to the Active state.
    Lambda periodically fetches the associated container image from the Amazon ECR repository. If the
      corresponding container image no longer exists on Amazon ECR or permissions are revoked, the function enters the Failed state, and
      Lambda returns a failure for any function invocations.
    You can use the Lambda API to get information about a function's state. For more information, see Lambda function states.
  Document ConventionsEncryptionMemoryDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideAWS base images for deploying Go functionsGo runtime interface clientUsing an AWS OS-only base imageUsing a non-AWS base imageDeploy Go Lambda functions with container imagesThere are two ways to build a container image for a Go Lambda function:
	 
     
  
      Using an AWS OS-only base image
      Go is implemented differently than other managed runtimes. Because Go compiles natively to an executable binary, it doesn't require a dedicated language runtime. Use an OS-only base image to build Go images for Lambda. To make the image compatible with Lambda, you must include the aws-lambda-go/lambda package in the image.
    
      Using a non-AWS base image
      You can use an alternative base image from another container registry, such as Alpine Linux or Debian. You can also use a custom image created by your organization. To make the image compatible with Lambda, you must include the aws-lambda-go/lambda package in the image.
    TipTo reduce the time it takes for Lambda container functions to become active, see Use multi-stage builds in the Docker documentation. To build efficient container images, follow the Best practices for writing Dockerfiles.This page explains how to build, test, and deploy container images for Lambda.
    AWS base images for deploying Go functions
    Go is implemented differently than other managed runtimes. Because Go compiles natively to an executable binary, it doesn't require a dedicated language runtime. Use an OS-only base image to deploy Go functions to Lambda.
    
      
        Name
        Identifier
        Operating system
        Deprecation date
        Block function create
        Block function update
      
    
      
        
          OS-only Runtime
        
        
          provided.al2023
        
        
          Amazon Linux 2023
        

        
                      Jun 30, 2029
            
        
        
                      Jul 31, 2029
            
        
        
                      Aug 31, 2029
            
        

      
      
        
          OS-only Runtime
        
        
          provided.al2
        
        
          Amazon Linux 2
        

        
                      Jun 30, 2026
            
        
        
                      Jul 31, 2026
            
        
        
                      Aug 31, 2026
            
        

      
    
    Amazon Elastic Container Registry Public Gallery: gallery.ecr.aws/lambda/provided
   
    Go runtime interface client
    The aws-lambda-go/lambda
      package includes an implementation of the runtime interface. For examples of how to use aws-lambda-go/lambda in your image, see Using an AWS OS-only base image or Using a non-AWS base image.
   
    Using an AWS OS-only base image
    Go is implemented differently than other managed runtimes. Because Go compiles natively to an executable binary, it doesn't require a dedicated language runtime. Use an OS-only base image to
      build container images for Go functions.
    
          
            Tags
            Runtime
            Operating system
            Dockerfile
            Deprecation
          
        
      
            al2023
            OS-only Runtime
            Amazon Linux 2023
            Dockerfile
                for OS-only Runtime on GitHub
            
                          Jun 30, 2029
            
              
          
      
            al2
            OS-only Runtime
            Amazon Linux 2
            Dockerfile
                for OS-only Runtime on GitHub
            
                          Jun 30, 2026
            
              
          
    
    For more information
      about these base images, see provided in the Amazon ECR
      public gallery.
      You must include the aws-lambda-go/lambda package with your Go handler. This package implements the
      programming model for Go, including the runtime interface.
    
      To complete the steps in this section, you must have the following:
	     
           
           
       
    
            AWS CLI version 2
          
            Docker (minimum version 25.0.0)
          
            The Docker buildx plugin.
          
        Go
      To build and deploy a Go function with the provided.al2023 base image
          Create a directory for the project, and then switch to that directory.
          mkdir hello
cd hello
        
          Initialize a new Go module.
          go mod init example.com/hello-world
        
          Add the lambda library as a dependency of your new module.
          go get github.com/aws/aws-lambda-go/lambda
        
            Create a file named main.go and then open it in a text editor. This is the code for the Lambda function. You can use the following sample code for testing, or replace it with your own.
          package main

import (
	"context"
	"github.com/aws/aws-lambda-go/events"
	"github.com/aws/aws-lambda-go/lambda"
)

func handler(ctx context.Context, event events.APIGatewayProxyRequest) (events.APIGatewayProxyResponse, error) {
	response := events.APIGatewayProxyResponse{
		StatusCode: 200,
		Body:       "\"Hello from Lambda!\"",
	}
	return response, nil
}

func main() {
	lambda.Start(handler)
}
          
        Use a text editor to create a Dockerfile in your project directory.
        
           
           
           
        
            The following example Dockerfile uses a multi-stage build. This allows you to use a different base image in each step. You can use one image, such as a Go base image, to compile your code and build the executable binary. You can then use a different image, such as provided.al2023, in the final FROM statement to define the image that you deploy to Lambda. The build process is separated from the final deployment image, so the final image only contains the files needed to run the application.
          
            You can use the optional lambda.norpc tag to exclude the Remote Procedure Call (RPC) component of the lambda 
      library. The RPC component is only required if you are using the deprecated Go 1.x runtime. Excluding the RPC reduces the size of the deployment package.
          
            Note that the example Dockerfile does not include a USER instruction. When you deploy a container image to Lambda, Lambda automatically defines a default Linux user with least-privileged permissions. This is different from standard Docker behavior which defaults to the root user when no USER instruction is provided.
          
        Example — Multi-stage build DockerfileNoteMake sure that the version of Go that you specify in your Dockerfile (for example, golang:1.20) is the same version of Go that you used to create your application.
        FROM golang:1.20 as build
WORKDIR /helloworld
# Copy dependencies list
COPY go.mod go.sum ./
# Build with optional lambda.norpc tag
COPY main.go .
RUN go build -tags lambda.norpc -o main main.go
# Copy artifacts to a clean image
FROM public.ecr.aws/lambda/provided:al2023
COPY --from=build /helloworld/main ./main
ENTRYPOINT [ "./main" ]
      
        Build the Docker image with the docker build command. The
          following example names the image docker-image and gives it the test tag. To make your 
          image compatible with Lambda, you must use the --provenance=false option.
        docker buildx build --platform linux/amd64 --provenance=false -t docker-image:test .
        NoteThe command specifies the --platform linux/amd64 option to ensure that your container is compatible with the Lambda execution environment regardless of the  
       architecture of your build machine. If you intend to create a Lambda function using the ARM64 instruction set architecture, be sure to change the command to use the --platform linux/arm64 
       option instead.
      Use the runtime interface emulator to locally test your image. The runtime interface emulator is included in the provided.al2023 base image.To run the runtime interface emulator on your local machine
      Start the Docker image with the docker run command. Note the following:
      
         
         
      
        docker-image is the image name and test is the tag.
        
        ./main is the ENTRYPOINT from your Dockerfile.
        
      docker run -d -p 9000:8080 \
--entrypoint /usr/local/bin/aws-lambda-rie \
docker-image:test ./main
      This command runs the image as a container and creates a local endpoint at
        localhost:9000/2015-03-31/functions/function/invocations.
    
      From a new terminal window, post an event to the following endpoint using a curl
        command:
      curl "http://localhost:9000/2015-03-31/functions/function/invocations" -d '{}'
      This command invokes the function with an empty event and returns a response. Some functions might require a JSON payload. Example:
      curl "http://localhost:9000/2015-03-31/functions/function/invocations" -d '{"payload":"hello world!"}'
    
      Get the container ID.
      docker ps
    
      Use the docker kill command to stop the container. In this command, replace 3766c4ab331c with the container ID from the previous step.
      docker kill 3766c4ab331c
    To upload the image to Amazon ECR and create the Lambda function
          Run the get-login-password command to authenticate the Docker CLI to your Amazon ECR registry.
        
         
         
        
          Set the --region value to the AWS Region where you want to create the Amazon ECR repository.
        
          Replace 111122223333 with your AWS account ID.
        
          aws ecr get-login-password --region us-east-1 | docker login --username AWS --password-stdin 111122223333.dkr.ecr.us-east-1.amazonaws.com
          
        
        Create a repository in Amazon ECR using the create-repository command.
        aws ecr create-repository --repository-name hello-world --region us-east-1 --image-scanning-configuration scanOnPush=true --image-tag-mutability MUTABLE
        
        NoteThe Amazon ECR repository must be in the same AWS Region as the Lambda function.
        If successful, you see a response like this:
        {
    "repository": {
        "repositoryArn": "arn:aws:ecr:us-east-1:111122223333:repository/hello-world",
        "registryId": "111122223333",
        "repositoryName": "hello-world",
        "repositoryUri": "111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world",
        "createdAt": "2023-03-09T10:39:01+00:00",
        "imageTagMutability": "MUTABLE",
        "imageScanningConfiguration": {
            "scanOnPush": true
        },
        "encryptionConfiguration": {
            "encryptionType": "AES256"
        }
    }
}
        
      
        Copy the repositoryUri from the output in the previous step.
      
        Run the docker tag command to tag your local image into your Amazon ECR repository as the latest version. In this command: 
        
         
         
        
          docker-image:test is the name and tag of your Docker image. This is the image name and tag that you specified in the docker build command.
        
          Replace <ECRrepositoryUri> with the repositoryUri that you copied. Make sure to include :latest at the end of the URI.
        
        docker tag docker-image:test <ECRrepositoryUri>:latest
      Example:
      docker tag docker-image:test 111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest
      
      
      Run the docker push command to deploy your local image to the Amazon ECR repository. Make sure to include :latest at the end of the repository URI.
docker push 111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest

      
      Create an execution role for the function, if you don't already have one. You need the Amazon Resource Name (ARN) of the role in the next step.
      
        Create the Lambda function. For ImageUri, specify the repository URI from earlier. Make sure to include :latest at the end of the URI.
		aws lambda create-function \
  --function-name hello-world \
  --package-type Image \
  --code ImageUri=111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest \
  --role arn:aws:iam::111122223333:role/lambda-ex
  		
      NoteYou can create a function using an image in a different AWS account, as long as the image is in the same Region as the Lambda function. For more information, see  Amazon ECR cross-account permissions.  
      
      Invoke the function.
      aws lambda invoke --function-name hello-world response.json
      You should see a response like this:
{
  "ExecutedVersion": "$LATEST", 
  "StatusCode": 200
}
    
    To see the output of the function, check the response.json file.
    To update the function code, you must build the image again, upload the new image to the Amazon ECR repository, and then use the update-function-code command to deploy the image to the Lambda function.Lambda resolves the image tag to a specific image digest. This means that if you point the image tag that was used to deploy the function to a new image in Amazon ECR, Lambda doesn't automatically update the function to use the new image.To deploy the new image to the same Lambda function, you must use the update-function-code command, even if the image tag in Amazon ECR remains the same. In the following example, the --publish option creates a new version of the function using the updated container image.aws lambda update-function-code \
  --function-name hello-world \
  --image-uri 111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest \
  --publish
   
    Using a non-AWS base image
    You can build a container image for Go from a non-AWS base image. The example Dockerfile in the following steps uses an
      Alpine base image.
    You must include the aws-lambda-go/lambda package with your Go handler. This package implements the
      programming model for Go, including the runtime interface.
   
      To complete the steps in this section, you must have the following:
	     
           
           
       
    
            AWS CLI version 2
          
            Docker (minimum version 25.0.0)
          
            The Docker buildx plugin.
          
        Go
      To build and deploy a Go function with an Alpine base image
          Create a directory for the project, and then switch to that directory.
          mkdir hello
cd hello
        
          Initialize a new Go module.
          go mod init example.com/hello-world
        
          Add the lambda library as a dependency of your new module.
          go get github.com/aws/aws-lambda-go/lambda
        
            Create a file named main.go and then open it in a text editor. This is the code for the Lambda function. You can use the following sample code for testing, or replace it with your own.
          package main

import (
	"context"
	"github.com/aws/aws-lambda-go/events"
	"github.com/aws/aws-lambda-go/lambda"
)

func handler(ctx context.Context, event events.APIGatewayProxyRequest) (events.APIGatewayProxyResponse, error) {
	response := events.APIGatewayProxyResponse{
		StatusCode: 200,
		Body:       "\"Hello from Lambda!\"",
	}
	return response, nil
}

func main() {
	lambda.Start(handler)
}
          
        Use a text editor to create a Dockerfile in your project directory. The following example Dockerfile uses an
          Alpine base image. Note that the example Dockerfile does not include a USER instruction. When you deploy a container image to Lambda, Lambda automatically defines a default Linux user with least-privileged permissions. This is different from standard Docker behavior which defaults to the root user when no USER instruction is provided.
        Example DockerfileNoteMake sure that the version of Go that you specify in your Dockerfile (for example, golang:1.20) is the same version of Go that you used to create your application.
        FROM golang:1.20.2-alpine3.16 as build
WORKDIR /helloworld
# Copy dependencies list
COPY go.mod go.sum ./
# Build
COPY main.go .
RUN go build -o main main.go
# Copy artifacts to a clean image
FROM alpine:3.16
COPY --from=build /helloworld/main /main
ENTRYPOINT [ "/main" ]
      
        Build the Docker image with the docker build command. The
          following example names the image docker-image and gives it the test tag. To make your 
          image compatible with Lambda, you must use the --provenance=false option.
        docker buildx build --platform linux/amd64 --provenance=false -t docker-image:test .
        NoteThe command specifies the --platform linux/amd64 option to ensure that your container is compatible with the Lambda execution environment regardless of the  
       architecture of your build machine. If you intend to create a Lambda function using the ARM64 instruction set architecture, be sure to change the command to use the --platform linux/arm64 
       option instead.
      Use the runtime interface emulator to locally test the image. You can build the emulator into your image or use the following procedure to install it on your local machine.To install and run the runtime interface emulator on your local machine
          From your project directory, run the following command to download the runtime interface emulator (x86-64 architecture) from GitHub and install it on your local machine.
          
            Linux/macOS
          mkdir -p ~/.aws-lambda-rie && \
    curl -Lo ~/.aws-lambda-rie/aws-lambda-rie https://github.com/aws/aws-lambda-runtime-interface-emulator/releases/latest/download/aws-lambda-rie && \
    chmod +x ~/.aws-lambda-rie/aws-lambda-rie
      			  To install the arm64 emulator, replace the GitHub repository URL in the previous command with the following:
      			https://github.com/aws/aws-lambda-runtime-interface-emulator/releases/latest/download/aws-lambda-rie-arm64
      		
            PowerShell
      				  $dirPath = "$HOME\.aws-lambda-rie"
if (-not (Test-Path $dirPath)) {
    New-Item -Path $dirPath -ItemType Directory
}
      
$downloadLink = "https://github.com/aws/aws-lambda-runtime-interface-emulator/releases/latest/download/aws-lambda-rie"
$destinationPath = "$HOME\.aws-lambda-rie\aws-lambda-rie"
Invoke-WebRequest -Uri $downloadLink -OutFile $destinationPath
      				  To install the arm64 emulator, replace the $downloadLink with the following:
      				https://github.com/aws/aws-lambda-runtime-interface-emulator/releases/latest/download/aws-lambda-rie-arm64
              
          
        
          Start the Docker image with the docker run command. Note the following:
          
             
             
          
            docker-image is the image name and test is the tag.
            
            /main is the ENTRYPOINT from your Dockerfile.
            
          
            Linux/macOS
				    docker run --platform linux/amd64 -d -v ~/.aws-lambda-rie:/aws-lambda -p 9000:8080 \
    --entrypoint /aws-lambda/aws-lambda-rie \
    docker-image:test \
        /main
      		
            PowerShell
				        docker run --platform linux/amd64 -d -v "$HOME\.aws-lambda-rie:/aws-lambda" -p 9000:8080 `
--entrypoint /aws-lambda/aws-lambda-rie `
docker-image:test `
    /main
				    
          
          This command runs the image as a container and creates a local endpoint at
            localhost:9000/2015-03-31/functions/function/invocations.
         NoteIf you built the Docker image for the ARM64 instruction set architecture, be sure to use the --platform linux/arm64 option instead of --platform linux/amd64.   
        
          Post an event to the local endpoint.
          
            Linux/macOS
      		      In Linux and macOS, run the following curl command:
                curl "http://localhost:9000/2015-03-31/functions/function/invocations" -d '{}'
                This command invokes the function with an empty event and returns a response. If you're using your own function code rather than the sample function code, you might want to invoke the function with a JSON payload. Example:
                curl "http://localhost:9000/2015-03-31/functions/function/invocations" -d '{"payload":"hello world!"}'
      		
            PowerShell
                In PowerShell, run the following Invoke-WebRequest command:
                Invoke-WebRequest -Uri "http://localhost:9000/2015-03-31/functions/function/invocations" -Method Post -Body '{}' -ContentType "application/json"
                This command invokes the function with an empty event and returns a response. If you're using your own function code rather than the sample function code, you might want to invoke the function with a JSON payload. Example:
                Invoke-WebRequest -Uri "http://localhost:9000/2015-03-31/functions/function/invocations" -Method Post -Body '{"payload":"hello world!"}' -ContentType "application/json"
              
          
        
          Get the container ID.
          docker ps
        
          Use the docker kill command to stop the container. In this command, replace 3766c4ab331c with the container ID from the previous step.
          docker kill 3766c4ab331c
        To upload the image to Amazon ECR and create the Lambda function
          Run the get-login-password command to authenticate the Docker CLI to your Amazon ECR registry.
        
         
         
        
          Set the --region value to the AWS Region where you want to create the Amazon ECR repository.
        
          Replace 111122223333 with your AWS account ID.
        
          aws ecr get-login-password --region us-east-1 | docker login --username AWS --password-stdin 111122223333.dkr.ecr.us-east-1.amazonaws.com
          
        
        Create a repository in Amazon ECR using the create-repository command.
        aws ecr create-repository --repository-name hello-world --region us-east-1 --image-scanning-configuration scanOnPush=true --image-tag-mutability MUTABLE
        
        NoteThe Amazon ECR repository must be in the same AWS Region as the Lambda function.
        If successful, you see a response like this:
        {
    "repository": {
        "repositoryArn": "arn:aws:ecr:us-east-1:111122223333:repository/hello-world",
        "registryId": "111122223333",
        "repositoryName": "hello-world",
        "repositoryUri": "111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world",
        "createdAt": "2023-03-09T10:39:01+00:00",
        "imageTagMutability": "MUTABLE",
        "imageScanningConfiguration": {
            "scanOnPush": true
        },
        "encryptionConfiguration": {
            "encryptionType": "AES256"
        }
    }
}
        
      
        Copy the repositoryUri from the output in the previous step.
      
        Run the docker tag command to tag your local image into your Amazon ECR repository as the latest version. In this command: 
        
         
         
        
          docker-image:test is the name and tag of your Docker image. This is the image name and tag that you specified in the docker build command.
        
          Replace <ECRrepositoryUri> with the repositoryUri that you copied. Make sure to include :latest at the end of the URI.
        
        docker tag docker-image:test <ECRrepositoryUri>:latest
      Example:
      docker tag docker-image:test 111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest
      
      
      Run the docker push command to deploy your local image to the Amazon ECR repository. Make sure to include :latest at the end of the repository URI.
docker push 111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest

      
      Create an execution role for the function, if you don't already have one. You need the Amazon Resource Name (ARN) of the role in the next step.
      
        Create the Lambda function. For ImageUri, specify the repository URI from earlier. Make sure to include :latest at the end of the URI.
		aws lambda create-function \
  --function-name hello-world \
  --package-type Image \
  --code ImageUri=111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest \
  --role arn:aws:iam::111122223333:role/lambda-ex
  		
      NoteYou can create a function using an image in a different AWS account, as long as the image is in the same Region as the Lambda function. For more information, see  Amazon ECR cross-account permissions.  
      
      Invoke the function.
      aws lambda invoke --function-name hello-world response.json
      You should see a response like this:
{
  "ExecutedVersion": "$LATEST", 
  "StatusCode": 200
}
    
    To see the output of the function, check the response.json file.
    To update the function code, you must build the image again, upload the new image to the Amazon ECR repository, and then use the update-function-code command to deploy the image to the Lambda function.Lambda resolves the image tag to a specific image digest. This means that if you point the image tag that was used to deploy the function to a new image in Amazon ECR, Lambda doesn't automatically update the function to use the new image.To deploy the new image to the same Lambda function, you must use the update-function-code command, even if the image tag in Amazon ECR remains the same. In the following example, the --publish option creates a new version of the function using the updated container image.aws lambda update-function-code \
  --function-name hello-world \
  --image-uri 111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest \
  --publish
  Document ConventionsDeploy .zip file archivesLayersDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideBuilding Lambda functions with RustBecause Rust compiles to native code, you don't need a dedicated runtime to run Rust code on Lambda. Instead, use the Rust runtime client to build your project locally, and then deploy it to Lambda using the provided.al2023 or provided.al2 runtime. When you use provided.al2023 or provided.al2, Lambda automatically keeps the operating system up to date with the latest patches.NoteThe Rust runtime client is an experimental package. It is subject to change and intended only for evaluation purposes.
    Tools and libraries for Rust
     
     
     
     
     
     
  
      AWS SDK for Rust: The AWS SDK for Rust
        provides Rust APIs to interact with Amazon Web Services infrastructure services.
    
      
        Rust runtime client for Lambda: The Rust runtime client is an experimental package. It is subject to breaking changes and not recommended for production.
    
      Cargo
        Lambda: This library provides a command line application to work with Lambda
        functions built with Rust.
    
      Lambda
        HTTP: This library provides a wrapper to work with HTTP events.
    
      
        Lambda
        Extension: This library provides support to write Lambda Extensions with Rust.
      
    
      AWS Lambda Events:
        This library provides type definitions for common event source integrations.
    
    Sample Lambda applications for Rust
     
     
     
     
     
     
     
     
     
  
      Basic
        Lambda function: A Rust function that shows how to process basic events.
    
      Lambda
        function with error handling: A Rust function that shows how to handle custom Rust
        errors in Lambda.
    
      Lambda
        function with shared resources: A Rust project that initializes shared resources
        before creating the Lambda function.
    
      Lambda
        HTTP events: A Rust function that handles HTTP events.
    
      Lambda
        HTTP events with CORS headers: A Rust function that uses Tower to inject CORS headers.
    
      Lambda REST API: A REST API that uses Axum and Diesel to connect to a PostgreSQL database.
    
      Serverless Rust
        demo: A Rust project that shows the use of Lambda's Rust libraries, logging,
        environment variables, and the AWS SDK.
    
      Basic
        Lambda Extension: A Rust extension that shows how to process basic extension events.
    
      Lambda
        Logs Amazon Data Firehose Extension: A Rust extension that shows how to send Lambda logs
        to Firehose.
    TopicsDefine Lambda function handlers in RustUsing the Lambda context object to retrieve Rust function informationProcessing HTTP events with RustDeploy Rust Lambda functions with .zip file archivesLog and monitor Rust Lambda functionsDocument ConventionsLoggingHandlerDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideRequirementsUsing an AWS base imageUsing an AWS OS-only base imageUsing a non-AWS base imageRuntime interface clientsAmazon ECR permissionsFunction lifecycleCreate a Lambda function using a container imageYour AWS Lambda function's code consists of scripts or compiled programs and their dependencies. 
You use a deployment package to deploy your function code to Lambda. Lambda supports two types of deployment packages: 
container images and .zip file archives. There are three ways to build a container image for a Lambda function:
     
	 
     
  
      Using an AWS base image for Lambda
      The AWS base images are preloaded with a language runtime, a runtime interface client to manage the interaction between Lambda and your function code, and a runtime interface emulator for local testing.
    
      Using an AWS OS-only base image
      AWS OS-only base images contain an Amazon Linux distribution and the runtime interface emulator. These images are commonly used to create container images for compiled languages, such as Go and Rust, and for a language or language version that Lambda doesn't provide a base image for, such as Node.js 19. You can also use OS-only base images to implement a custom runtime. To make the image compatible with Lambda, you must include a runtime interface client for your language in the image.
    
      Using a non-AWS base image
      You can use an alternative base image from another container registry, such as Alpine Linux or Debian. You can also use a custom image created by your organization. To make the image compatible with Lambda, you must include a runtime interface client for your language in the image.
    TipTo reduce the time it takes for Lambda container functions to become active, see Use multi-stage builds in the Docker documentation. To build efficient container images, follow the Best practices for writing Dockerfiles.To create a Lambda function from a container image, build your image locally and upload it to an Amazon Elastic Container Registry (Amazon ECR) repository. Then, specify the repository URI when you create the function. The Amazon ECR repository must be in the same AWS Region as the Lambda function. You can create a function using an image in a different AWS account, as long as the image is in the same Region as the Lambda function. For more information, see  Amazon ECR cross-account permissions.NoteLambda does not support Amazon ECR FIPS endpoints for container images. If your repository URI includes
      ecr-fips, you are using a FIPS endpoint. Example: 111122223333.dkr.ecr-fips.us-east-1.amazonaws.com.This page explains the base image types and requirements for creating Lambda-compatible container images.NoteYou cannot change the deployment package type (.zip or container image) for an existing function. For example, you cannot convert a container image function to use a .zip file archive. You must create a new function.TopicsRequirementsUsing an AWS base image for LambdaUsing an AWS OS-only base imageUsing a non-AWS base imageRuntime interface clientsAmazon ECR permissionsFunction lifecycle
    Requirements
    Install the AWS CLI version 2 and the Docker CLI. 
      Additionally, note the following requirements:
    
       
       
       
       
       
    
        The container image must implement the Using the Lambda runtime API for custom runtimes. The AWS
          open-source runtime interface clients implement the API. You can
          add a runtime interface client to your preferred base image to make it compatible with Lambda.
      
        The container image must be able to run on a read-only file system. Your function code can access a
          writable /tmp directory with between 512 MB and 10,240 MB, in 1-MB increments, of storage.  
      
        The default Lambda user must be able to read all the files required to run your function code. Lambda
          follows security best practices by defining a default Linux user with least-privileged permissions. This means that you don't need to specify a USER  in your Dockerfile. Verify
          that your application code does not rely on files that other Linux users are restricted from running.
      
        Lambda supports only Linux-based container images.
      
        Lambda provides multi-architecture base images. However, the image you build for your function must target
          only one of the architectures. Lambda does not support functions that use multi-architecture container
          images.
      
   
    Using an AWS base image for Lambda
    You can use one of the AWS base images for Lambda to build the container image for your
      function code. The base images are preloaded with a language runtime and other components
      required to run a container image on Lambda. You add your function code and dependencies to the
      base image and then package it as a container image.
    AWS periodically provides updates to the AWS base images for Lambda. If your Dockerfile includes the
      image name in the FROM property, your Docker client pulls the latest version of the image from the Amazon ECR repository. To
      use the updated base image, you must rebuild your container image and update the function code.
      The Node.js 20, Python 3.12, Java 21, .NET 8, Ruby 3.3, and later base images are based on the Amazon Linux 2023 minimal container image. Earlier base images use Amazon Linux 2. AL2023 provides several advantages over Amazon Linux 2, including a smaller deployment footprint and updated versions of libraries such as glibc.
    AL2023-based images use microdnf (symlinked as dnf) as the package manager instead of yum, which is the default package manager in Amazon Linux 2. microdnf is a standalone implementation of dnf. For a list of packages that are included in AL2023-based images, refer to the Minimal Container columns in Comparing packages installed on Amazon Linux 2023 Container Images. For more information about the differences between AL2023 and Amazon Linux 2, see Introducing the Amazon Linux 2023 runtime for AWS Lambda on the AWS
      Compute Blog.    
    NoteTo run AL2023-based images locally, including with AWS Serverless Application Model (AWS SAM), you must use Docker version 20.10.10 or later.  
    To build a container image using an AWS base image, choose the instructions for your preferred language:
    
       
       
       
       
       
       
       
    
        Node.js
      
        TypeScript (uses a Node.js base image) 
      
        Python
      
        Java 
      
        Go
      
        .NET
      
        Ruby
      
   
    Using an AWS OS-only base image
    AWS OS-only base images contain an Amazon Linux distribution and the runtime interface emulator. These images are commonly used to create container images for compiled languages, such as Go and Rust, and for a language or language version that Lambda doesn't provide a base image for, such as Node.js 19. You can also use OS-only base images to implement a custom runtime. To make the image compatible with Lambda, you must include a runtime interface client for your language in the image.
    
          
            Tags
            Runtime
            Operating system
            Dockerfile
            Deprecation
          
        
      
            al2023
            OS-only Runtime
            Amazon Linux 2023
            Dockerfile
                for OS-only Runtime on GitHub
            
                          Jun 30, 2029
            
              
          
      
            al2
            OS-only Runtime
            Amazon Linux 2
            Dockerfile
                for OS-only Runtime on GitHub
            
                          Jun 30, 2026
            
              
          
    
    Amazon Elastic Container Registry Public Gallery: gallery.ecr.aws/lambda/provided
     
    Using a non-AWS base image
    Lambda
      supports any image that conforms to one of the following image manifest formats:
    
       
       
    Docker image manifest V2, schema 2 (used with Docker version 1.10 and newer)Open Container Initiative (OCI) Specifications (v1.0.0 and up)
    Lambda supports a maximum uncompressed image size of 10 GB, including all layers.
    NoteTo make the image compatible with Lambda, you must include a runtime interface client for your language in the image.
   
    Runtime interface clients
    If you use an OS-only base image or an alternative base image, you must include a runtime interface client in your image. The runtime interface client must extend the Using the Lambda runtime API for custom runtimes, which manages the interaction between Lambda and your function code. AWS provides open-source runtime interface clients for the following languages:
    
  
   
  
   
  
   
  
   
  
   
  
   
  
     

    
      Node.js
    
  
    
      Python
    
  
    
      Java
    
  
    
      .NET
    
  
    
      Go
    
  
    
      Ruby
    
  
    
      Rust – The Rust runtime client is an experimental package. It is subject to change and intended only for evaluation purposes.
    
  
    If you're using a language that doesn't have an AWS-provided runtime interface client, you must create your own.
   
    Amazon ECR permissions
    Before you create a Lambda function from a container image, you must build the image locally and upload it to an Amazon ECR repository. When you create the function, specify the Amazon ECR repository URI.
    Make sure that the permissions for the user or role that creates the function includes GetRepositoryPolicy and SetRepositoryPolicy.
    For example, use the IAM console to create a role with the following policy:
    {
  "Version": "2012-10-17",
  "Statement": [
    {
      "Sid": "VisualEditor0",
      "Effect": "Allow",
      "Action": [
        "ecr:SetRepositoryPolicy",
        "ecr:GetRepositoryPolicy"
      ],
      "Resource": "arn:aws:ecr:us-east-1:111122223333:repository/hello-world"
    }
  ]
}
     
      Amazon ECR repository policies
      For a function in the same account as the container image in Amazon ECR, you can add ecr:BatchGetImage
        and ecr:GetDownloadUrlForLayer permissions to your Amazon ECR repository policy. The following example shows the
        minimum policy:
      {
        "Sid": "LambdaECRImageRetrievalPolicy",
        "Effect": "Allow",
        "Principal": {
          "Service": "lambda.amazonaws.com"
        },
        "Action": [
          "ecr:BatchGetImage",
          "ecr:GetDownloadUrlForLayer"
        ]
    }   
      For more information about Amazon ECR
        repository permissions, see Private repository policies in the
        Amazon Elastic Container Registry User Guide.
      If the Amazon ECR repository does not include these permissions, Lambda attempts to add them automatically. Lambda can add
        permissions only if the principal calling Lambda has ecr:getRepositoryPolicy and
          ecr:setRepositoryPolicy permissions. 
      To view or edit your Amazon ECR repository permissions, follow the directions in Setting a private repository policy statement in the
          Amazon Elastic Container Registry User Guide.
       
         Amazon ECR cross-account permissions
        A different account in the same region can create a function that uses a container image owned by your
          account. In the following example, your Amazon ECR repository permissions policy needs the following statements to
          grant access to account number 123456789012.
        
           
           
        CrossAccountPermission – Allows account 123456789012 to create and update Lambda
              functions that use images from this ECR repository.LambdaECRImageCrossAccountRetrievalPolicy – Lambda will eventually set a
              function's state to inactive if it is not invoked for an extended period. This statement is required so that
              Lambda can retrieve the container image for optimization and caching on behalf of the function owned by
              123456789012.  
        Example — Add cross-account permission to your repository{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Sid": "CrossAccountPermission",
      "Effect": "Allow",
      "Action": [
        "ecr:BatchGetImage",
        "ecr:GetDownloadUrlForLayer"
      ],
      "Principal": {
        "AWS": "arn:aws:iam::123456789012:root"
      }
    },
    {
      "Sid": "LambdaECRImageCrossAccountRetrievalPolicy",
      "Effect": "Allow",
      "Action": [
        "ecr:BatchGetImage",
        "ecr:GetDownloadUrlForLayer"
      ],
      "Principal": {
        "Service": "lambda.amazonaws.com"
      },
      "Condition": {
        "StringLike": {
          "aws:sourceARN": "arn:aws:lambda:us-east-1:123456789012:function:*"
        }
      }
    }
  ]
}
        To give access to multiple accounts, you add the account IDs to the Principal list in the
            CrossAccountPermission policy and to the Condition evaluation list in the
            LambdaECRImageCrossAccountRetrievalPolicy.
        If you are working with multiple accounts in an AWS Organization, we recommend that you enumerate each
          account ID in the ECR permissions policy. This approach aligns with the AWS security best practice of setting
          narrow permissions in IAM policies.
        In addition to Lambda permissions, the user or role that creates the function must also have BatchGetImage and GetDownloadUrlForLayer permissions.
       
     
   
    Function lifecycle
    After you upload a new or updated container image, Lambda optimizes the image before the function can process invocations. The
      optimization process can take a few seconds. The function remains in the Pending state until the
      process completes, when the state transitions to Active. You can't invoke the function until it reaches the Active state. 
    If a function is not invoked for multiple weeks, Lambda reclaims its optimized version, and the function
      transitions to the Inactive state. To reactivate the function, you must invoke it. Lambda rejects the
      first invocation and the function enters the Pending state until Lambda re-optimizes the image. The
      function then returns to the Active state.
    Lambda periodically fetches the associated container image from the Amazon ECR repository. If the
      corresponding container image no longer exists on Amazon ECR or permissions are revoked, the function enters the Failed state, and
      Lambda returns a failure for any function invocations.
    You can use the Lambda API to get information about a function's state. For more information, see Lambda function states.
  Document ConventionsEncryptionMemoryDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaAPI ReferenceRequest SyntaxURI Request ParametersRequest BodyResponse SyntaxResponse ElementsErrorsSee AlsoCreateFunctionCreates a Lambda function. To create a function, you need a deployment package and an execution role. The
      deployment package is a .zip file archive or container image that contains your function code. The execution role
      grants the function permission to use AWS services, such as Amazon CloudWatch Logs for log
      streaming and AWS X-Ray for request tracing.If the deployment package is a container
        image, then you set the package type to Image. For a container image, the code property
      must include the URI of a container image in the Amazon ECR registry. You do not need to specify the
      handler and runtime properties.If the deployment package is a .zip file archive, then
      you set the package type to Zip. For a .zip file archive, the code property specifies the location of
      the .zip file. You must also specify the handler and runtime properties. The code in the deployment package must
      be compatible with the target instruction set architecture of the function (x86-64 or
        arm64). If you do not specify the architecture, then the default value is
      x86-64.When you create a function, Lambda provisions an instance of the function and its supporting
      resources. If your function connects to a VPC, this process can take a minute or so. During this time, you can't
      invoke or modify the function. The State, StateReason, and StateReasonCode
      fields in the response from GetFunctionConfiguration indicate when the function is ready to
      invoke. For more information, see Lambda function states.A function has an unpublished version, and can have published versions and aliases. The unpublished version
      changes when you update your function's code and configuration. A published version is a snapshot of your function
      code and configuration that can't be changed. An alias is a named resource that maps to a version, and can be
      changed to map to a different version. Use the Publish parameter to create version 1 of
      your function from its initial configuration.The other parameters let you configure version-specific and function-level settings. You can modify
      version-specific settings later with UpdateFunctionConfiguration. Function-level settings apply
      to both the unpublished and published versions of the function, and include tags (TagResource)
      and per-function concurrency limits (PutFunctionConcurrency).You can use code signing if your deployment package is a .zip file archive. To enable code signing for this
      function, specify the ARN of a code-signing configuration. When a user attempts to deploy a code package with
        UpdateFunctionCode, Lambda checks that the code package has a valid signature from
      a trusted publisher. The code-signing configuration includes set of signing profiles, which define the trusted
      publishers for this function.If another AWS account or an AWS service invokes your function, use AddPermission to grant permission by creating a resource-based AWS Identity and Access Management (IAM) policy. You can grant permissions at the function level, on a version, or on an alias.To invoke your function directly, use Invoke. To invoke your function in response to events
      in other AWS services, create an event source mapping (CreateEventSourceMapping),
      or configure a function trigger in the other service. For more information, see Invoking Lambda
      functions.
      Request Syntax
      POST /2015-03-31/functions HTTP/1.1
Content-type: application/json

{
   "Architectures": [ "string" ],
   "Code": { 
      "ImageUri": "string",
      "S3Bucket": "string",
      "S3Key": "string",
      "S3ObjectVersion": "string",
      "SourceKMSKeyArn": "string",
      "ZipFile": blob
   },
   "CodeSigningConfigArn": "string",
   "DeadLetterConfig": { 
      "TargetArn": "string"
   },
   "Description": "string",
   "Environment": { 
      "Variables": { 
         "string" : "string" 
      }
   },
   "EphemeralStorage": { 
      "Size": number
   },
   "FileSystemConfigs": [ 
      { 
         "Arn": "string",
         "LocalMountPath": "string"
      }
   ],
   "FunctionName": "string",
   "Handler": "string",
   "ImageConfig": { 
      "Command": [ "string" ],
      "EntryPoint": [ "string" ],
      "WorkingDirectory": "string"
   },
   "KMSKeyArn": "string",
   "Layers": [ "string" ],
   "LoggingConfig": { 
      "ApplicationLogLevel": "string",
      "LogFormat": "string",
      "LogGroup": "string",
      "SystemLogLevel": "string"
   },
   "MemorySize": number,
   "PackageType": "string",
   "Publish": boolean,
   "Role": "string",
   "Runtime": "string",
   "SnapStart": { 
      "ApplyOn": "string"
   },
   "Tags": { 
      "string" : "string" 
   },
   "Timeout": number,
   "TracingConfig": { 
      "Mode": "string"
   },
   "VpcConfig": { 
      "Ipv6AllowedForDualStack": boolean,
      "SecurityGroupIds": [ "string" ],
      "SubnetIds": [ "string" ]
   }
}
    
      URI Request Parameters
      The request does not use any URI parameters.
    
      Request Body
      The request accepts the following data in JSON format.
      
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
      
            
               
                  Architectures
               
            
            
               The instruction set architecture that the function supports. Enter a string array with one of the valid values (arm64 or x86_64).
     The default value is x86_64.
               Type: Array of strings
               Array Members: Fixed number of 1 item.
               Valid Values: x86_64 | arm64
               
               Required: No
            
          
            
               
                  Code
               
            
            
               The code for the function.
               Type: FunctionCode object
               Required: Yes
            
          
            
               
                  CodeSigningConfigArn
               
            
            
               To enable code signing for this function, specify the ARN of a code-signing configuration. A code-signing configuration
includes a set of signing profiles, which define the trusted publishers for this function.
               Type: String
               Length Constraints: Maximum length of 200.
               Pattern: arn:(aws[a-zA-Z-]*)?:lambda:[a-z]{2}((-gov)|(-iso(b?)))?-[a-z]+-\d{1}:\d{12}:code-signing-config:csc-[a-z0-9]{17}
               
               Required: No
            
          
            
               
                  DeadLetterConfig
               
            
            
               A dead-letter queue configuration that specifies the queue or topic where Lambda sends asynchronous events
      when they fail processing. For more information, see Dead-letter queues.
               Type: DeadLetterConfig object
               Required: No
            
          
            
               
                  Description
               
            
            
               A description of the function.
               Type: String
               Length Constraints: Minimum length of 0. Maximum length of 256.
               Required: No
            
          
            
               
                  Environment
               
            
            
               Environment variables that are accessible from function code during execution.
               Type: Environment object
               Required: No
            
          
            
               
                  EphemeralStorage
               
            
            
               The size of the function's /tmp directory in MB. The default value is 512, but can be any whole
      number between 512 and 10,240 MB. For more information, see Configuring ephemeral storage (console).
               Type: EphemeralStorage object
               Required: No
            
          
            
               
                  FileSystemConfigs
               
            
            
               Connection settings for an Amazon EFS file system.
               Type: Array of FileSystemConfig objects
               Array Members: Maximum number of 1 item.
               Required: No
            
          
            
               
                  FunctionName
               
            
            
               The name or ARN of the Lambda function.
               
                  Name formats
                   
                   
                   
               
                     
                        Function name – my-function.
                  
                     
                        Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function.
                  
                     
                        Partial ARN – 123456789012:function:my-function.
                  
               The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64
      characters in length.
               Type: String
               Length Constraints: Minimum length of 1. Maximum length of 140.
               Pattern: (arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\d{1}:)?(\d{12}:)?(function:)?([a-zA-Z0-9-_]+)(:(\$LATEST|[a-zA-Z0-9-_]+))?
               
               Required: Yes
            
          
            
               
                  Handler
               
            
            
               The name of the method within your code that Lambda calls to run your function. 
Handler is required if the deployment package is a .zip file archive. The format includes the
      file name. It can also include namespaces and other qualifiers, depending on the runtime. For more information,
      see Lambda programming model.
               Type: String
               Length Constraints: Maximum length of 128.
               Pattern: [^ ]+
               
               Required: No
            
          
            
               
                  ImageConfig
               
            
            
               Container image configuration
      values that override the values in the container image Dockerfile.
               Type: ImageConfig object
               Required: No
            
          
            
               
                  KMSKeyArn
               
            
            
               The ARN of the AWS Key Management Service (AWS KMS) customer managed key that's used to encrypt the following resources:
               
                   
                   
                   
                   
               
                     The function's environment variables.
                  
                     The function's Lambda SnapStart snapshots.
                  
                     When used with SourceKMSKeyArn, the unzipped version of the .zip deployment package that's used for function invocations. For more information, see 
Specifying a customer managed key for Lambda.
                  
                     The optimized version of the container image that's used for function invocations. Note that this is not the same key that's used to protect your container image in the Amazon Elastic Container Registry (Amazon ECR). For more information, see Function lifecycle.
                  
               If you don't provide a customer managed key, Lambda uses an AWS owned key or an AWS managed key.
               Type: String
               Pattern: (arn:(aws[a-zA-Z-]*)?:[a-z0-9-.]+:.*)|()
               
               Required: No
            
          
            
               
                  Layers
               
            
            
               A list of function layers
      to add to the function's execution environment. Specify each layer by its ARN, including the version.
               Type: Array of strings
               Length Constraints: Minimum length of 1. Maximum length of 140.
               Pattern: arn:[a-zA-Z0-9-]+:lambda:[a-zA-Z0-9-]+:\d{12}:layer:[a-zA-Z0-9-_]+:[0-9]+
               
               Required: No
            
          
            
               
                  LoggingConfig
               
            
            
               The function's Amazon CloudWatch Logs configuration settings.
               Type: LoggingConfig object
               Required: No
            
          
            
               
                  MemorySize
               
            
            
               The amount of memory available to the function at runtime.
      Increasing the function memory also increases its CPU allocation. The default value is 128 MB. The value can be any multiple of 1 MB.
               Type: Integer
               Valid Range: Minimum value of 128. Maximum value of 10240.
               Required: No
            
          
            
               
                  PackageType
               
            
            
               The type of deployment package. Set to Image for container image and set to Zip for .zip file archive.
               Type: String
               Valid Values: Zip | Image
               
               Required: No
            
          
            
               
                  Publish
               
            
            
               Set to true to publish the first version of the function during creation.
               Type: Boolean
               Required: No
            
          
            
               
                  Role
               
            
            
               The Amazon Resource Name (ARN) of the function's execution role.
               Type: String
               Pattern: arn:(aws[a-zA-Z-]*)?:iam::\d{12}:role/?[a-zA-Z_0-9+=,.@\-_/]+
               
               Required: Yes
            
          
            
               
                  Runtime
               
            
            
               The identifier of the function's 
          runtime. Runtime is required if the deployment package is a .zip file archive. Specifying a runtime results in
          an error if you're deploying a function using a container image.
               The following list includes deprecated runtimes. Lambda blocks creating new functions and updating existing
          functions shortly after each runtime is deprecated. For more information, see
          Runtime use after deprecation.
               For a list of all currently supported runtimes, see
          Supported runtimes.
               Type: String
               Valid Values: nodejs | nodejs4.3 | nodejs6.10 | nodejs8.10 | nodejs10.x | nodejs12.x | nodejs14.x | nodejs16.x | java8 | java8.al2 | java11 | python2.7 | python3.6 | python3.7 | python3.8 | python3.9 | dotnetcore1.0 | dotnetcore2.0 | dotnetcore2.1 | dotnetcore3.1 | dotnet6 | dotnet8 | nodejs4.3-edge | go1.x | ruby2.5 | ruby2.7 | provided | provided.al2 | nodejs18.x | python3.10 | java17 | ruby3.2 | ruby3.3 | ruby3.4 | python3.11 | nodejs20.x | provided.al2023 | python3.12 | java21 | python3.13 | nodejs22.x
               
               Required: No
            
          
            
               
                  SnapStart
               
            
            
               The function's SnapStart setting.
               Type: SnapStart object
               Required: No
            
          
            
               
                  Tags
               
            
            
               A list of tags to apply to the
      function.
               Type: String to string map
               Required: No
            
          
            
               
                  Timeout
               
            
            
               The amount of time (in seconds) that Lambda allows a function to run before stopping it. The default is 3 seconds. The
      maximum allowed value is 900 seconds. For more information, see Lambda execution environment.
               Type: Integer
               Valid Range: Minimum value of 1.
               Required: No
            
          
            
               
                  TracingConfig
               
            
            
               Set Mode to Active to sample and trace a subset of incoming requests with
X-Ray.
               Type: TracingConfig object
               Required: No
            
          
            
               
                  VpcConfig
               
            
            
               For network connectivity to AWS resources in a VPC, specify a list of security groups and subnets in the VPC.
      When you connect a function to a VPC, it can access resources and the internet only through that VPC. For more
      information, see Configuring a Lambda function to access resources in a VPC.
               Type: VpcConfig object
               Required: No
            
         
    
      Response Syntax
      HTTP/1.1 201
Content-type: application/json

{
   "Architectures": [ "string" ],
   "CodeSha256": "string",
   "CodeSize": number,
   "DeadLetterConfig": { 
      "TargetArn": "string"
   },
   "Description": "string",
   "Environment": { 
      "Error": { 
         "ErrorCode": "string",
         "Message": "string"
      },
      "Variables": { 
         "string" : "string" 
      }
   },
   "EphemeralStorage": { 
      "Size": number
   },
   "FileSystemConfigs": [ 
      { 
         "Arn": "string",
         "LocalMountPath": "string"
      }
   ],
   "FunctionArn": "string",
   "FunctionName": "string",
   "Handler": "string",
   "ImageConfigResponse": { 
      "Error": { 
         "ErrorCode": "string",
         "Message": "string"
      },
      "ImageConfig": { 
         "Command": [ "string" ],
         "EntryPoint": [ "string" ],
         "WorkingDirectory": "string"
      }
   },
   "KMSKeyArn": "string",
   "LastModified": "string",
   "LastUpdateStatus": "string",
   "LastUpdateStatusReason": "string",
   "LastUpdateStatusReasonCode": "string",
   "Layers": [ 
      { 
         "Arn": "string",
         "CodeSize": number,
         "SigningJobArn": "string",
         "SigningProfileVersionArn": "string"
      }
   ],
   "LoggingConfig": { 
      "ApplicationLogLevel": "string",
      "LogFormat": "string",
      "LogGroup": "string",
      "SystemLogLevel": "string"
   },
   "MasterArn": "string",
   "MemorySize": number,
   "PackageType": "string",
   "RevisionId": "string",
   "Role": "string",
   "Runtime": "string",
   "RuntimeVersionConfig": { 
      "Error": { 
         "ErrorCode": "string",
         "Message": "string"
      },
      "RuntimeVersionArn": "string"
   },
   "SigningJobArn": "string",
   "SigningProfileVersionArn": "string",
   "SnapStart": { 
      "ApplyOn": "string",
      "OptimizationStatus": "string"
   },
   "State": "string",
   "StateReason": "string",
   "StateReasonCode": "string",
   "Timeout": number,
   "TracingConfig": { 
      "Mode": "string"
   },
   "Version": "string",
   "VpcConfig": { 
      "Ipv6AllowedForDualStack": boolean,
      "SecurityGroupIds": [ "string" ],
      "SubnetIds": [ "string" ],
      "VpcId": "string"
   }
}
    
      Response Elements
      If the action is successful, the service sends back an HTTP 201 response.
      The following data is returned in JSON format by the service.
      
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
      
            
               
                  Architectures
               
            
            
               The instruction set architecture that the function supports. Architecture is a string array with one of the 
      valid values. The default architecture value is x86_64.
               Type: Array of strings
               Array Members: Fixed number of 1 item.
               Valid Values: x86_64 | arm64
               
            
          
            
               
                  CodeSha256
               
            
            
               The SHA256 hash of the function's deployment package.
               Type: String
            
          
            
               
                  CodeSize
               
            
            
               The size of the function's deployment package, in bytes.
               Type: Long
            
          
            
               
                  DeadLetterConfig
               
            
            
               The function's dead letter queue.
               Type: DeadLetterConfig object
            
          
            
               
                  Description
               
            
            
               The function's description.
               Type: String
               Length Constraints: Minimum length of 0. Maximum length of 256.
            
          
            
               
                  Environment
               
            
            
               The function's environment variables. Omitted from AWS CloudTrail logs.
               Type: EnvironmentResponse object
            
          
            
               
                  EphemeralStorage
               
            
            
               The size of the function's /tmp directory in MB. The default value is 512, but can be any whole
  number between 512 and 10,240 MB. For more information, see Configuring ephemeral storage (console).
               Type: EphemeralStorage object
            
          
            
               
                  FileSystemConfigs
               
            
            
               Connection settings for an Amazon EFS file system.
               Type: Array of FileSystemConfig objects
               Array Members: Maximum number of 1 item.
            
          
            
               
                  FunctionArn
               
            
            
               The function's Amazon Resource Name (ARN).
               Type: String
               Pattern: arn:(aws[a-zA-Z-]*)?:lambda:[a-z]{2}(-gov)?-[a-z]+-\d{1}:\d{12}:function:[a-zA-Z0-9-_\.]+(:(\$LATEST|[a-zA-Z0-9-_]+))?
               
            
          
            
               
                  FunctionName
               
            
            
               The name of the function.
               Type: String
               Length Constraints: Minimum length of 1. Maximum length of 170.
               Pattern: (arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\d{1}:)?(\d{12}:)?(function:)?([a-zA-Z0-9-_\.]+)(:(\$LATEST|[a-zA-Z0-9-_]+))?
               
            
          
            
               
                  Handler
               
            
            
               The function that Lambda calls to begin running your function.
               Type: String
               Length Constraints: Maximum length of 128.
               Pattern: [^ ]+
               
            
          
            
               
                  ImageConfigResponse
               
            
            
               The function's image configuration values.
               Type: ImageConfigResponse object
            
          
            
               
                  KMSKeyArn
               
            
            
               The ARN of the AWS Key Management Service (AWS KMS) customer managed key that's used to encrypt the following resources:
               
                   
                   
                   
                   
               
                     The function's environment variables.
                  
                     The function's Lambda SnapStart snapshots.
                  
                     When used with SourceKMSKeyArn, the unzipped version of the .zip deployment package that's used for function invocations. For more information, see 
          Specifying a customer managed key for Lambda.
                  
                     The optimized version of the container image that's used for function invocations. Note that this is not the same key that's used to protect your container image in the Amazon Elastic Container Registry (Amazon ECR). For more information, see Function lifecycle.
                  
               If you don't provide a customer managed key, Lambda uses an AWS owned key or an AWS managed key.
               Type: String
               Pattern: (arn:(aws[a-zA-Z-]*)?:[a-z0-9-.]+:.*)|()
               
            
          
            
               
                  LastModified
               
            
            
               The date and time that the function was last updated, in ISO-8601 format (YYYY-MM-DDThh:mm:ss.sTZD).
               Type: String
            
          
            
               
                  LastUpdateStatus
               
            
            
               The status of the last update that was performed on the function. This is first set to Successful
      after function creation completes.
               Type: String
               Valid Values: Successful | Failed | InProgress
               
            
          
            
               
                  LastUpdateStatusReason
               
            
            
               The reason for the last update that was performed on the function.
               Type: String
            
          
            
               
                  LastUpdateStatusReasonCode
               
            
            
               The reason code for the last update that was performed on the function.
               Type: String
               Valid Values: EniLimitExceeded | InsufficientRolePermissions | InvalidConfiguration | InternalError | SubnetOutOfIPAddresses | InvalidSubnet | InvalidSecurityGroup | ImageDeleted | ImageAccessDenied | InvalidImage | KMSKeyAccessDenied | KMSKeyNotFound | InvalidStateKMSKey | DisabledKMSKey | EFSIOError | EFSMountConnectivityError | EFSMountFailure | EFSMountTimeout | InvalidRuntime | InvalidZipFileException | FunctionError
               
            
          
            
               
                  Layers
               
            
            
               The function's layers.
               Type: Array of Layer objects
            
          
            
               
                  LoggingConfig
               
            
            
               The function's Amazon CloudWatch Logs configuration settings.
               Type: LoggingConfig object
            
          
            
               
                  MasterArn
               
            
            
               For Lambda@Edge functions, the ARN of the main function.
               Type: String
               Pattern: arn:(aws[a-zA-Z-]*)?:lambda:[a-z]{2}(-gov)?-[a-z]+-\d{1}:\d{12}:function:[a-zA-Z0-9-_]+(:(\$LATEST|[a-zA-Z0-9-_]+))?
               
            
          
            
               
                  MemorySize
               
            
            
               The amount of memory available to the function at runtime.
               Type: Integer
               Valid Range: Minimum value of 128. Maximum value of 10240.
            
          
            
               
                  PackageType
               
            
            
               The type of deployment package. Set to Image for container image and set Zip for .zip file archive.
               Type: String
               Valid Values: Zip | Image
               
            
          
            
               
                  RevisionId
               
            
            
               The latest updated revision of the function or alias.
               Type: String
            
          
            
               
                  Role
               
            
            
               The function's execution role.
               Type: String
               Pattern: arn:(aws[a-zA-Z-]*)?:iam::\d{12}:role/?[a-zA-Z_0-9+=,.@\-_/]+
               
            
          
            
               
                  Runtime
               
            
            
               The identifier of the function's 
          runtime. Runtime is required if the deployment package is a .zip file archive. Specifying a runtime results in
          an error if you're deploying a function using a container image.
               The following list includes deprecated runtimes. Lambda blocks creating new functions and updating existing
          functions shortly after each runtime is deprecated. For more information, see
          Runtime use after deprecation.
               For a list of all currently supported runtimes, see
          Supported runtimes.
               Type: String
               Valid Values: nodejs | nodejs4.3 | nodejs6.10 | nodejs8.10 | nodejs10.x | nodejs12.x | nodejs14.x | nodejs16.x | java8 | java8.al2 | java11 | python2.7 | python3.6 | python3.7 | python3.8 | python3.9 | dotnetcore1.0 | dotnetcore2.0 | dotnetcore2.1 | dotnetcore3.1 | dotnet6 | dotnet8 | nodejs4.3-edge | go1.x | ruby2.5 | ruby2.7 | provided | provided.al2 | nodejs18.x | python3.10 | java17 | ruby3.2 | ruby3.3 | ruby3.4 | python3.11 | nodejs20.x | provided.al2023 | python3.12 | java21 | python3.13 | nodejs22.x
               
            
          
            
               
                  RuntimeVersionConfig
               
            
            
               The ARN of the runtime and any errors that occured.
               Type: RuntimeVersionConfig object
            
          
            
               
                  SigningJobArn
               
            
            
               The ARN of the signing job.
               Type: String
               Pattern: arn:(aws[a-zA-Z0-9-]*):([a-zA-Z0-9\-])+:([a-z]{2}(-gov)?-[a-z]+-\d{1})?:(\d{12})?:(.*)
               
            
          
            
               
                  SigningProfileVersionArn
               
            
            
               The ARN of the signing profile version.
               Type: String
               Pattern: arn:(aws[a-zA-Z0-9-]*):([a-zA-Z0-9\-])+:([a-z]{2}(-gov)?-[a-z]+-\d{1})?:(\d{12})?:(.*)
               
            
          
            
               
                  SnapStart
               
            
            
               Set ApplyOn to PublishedVersions to create a snapshot of the initialized execution
      environment when you publish a function version. For more information, see Improving startup performance with Lambda SnapStart.
               Type: SnapStartResponse object
            
          
            
               
                  State
               
            
            
               The current state of the function. When the state is Inactive, you can reactivate the function by
      invoking it.
               Type: String
               Valid Values: Pending | Active | Inactive | Failed
               
            
          
            
               
                  StateReason
               
            
            
               The reason for the function's current state.
               Type: String
            
          
            
               
                  StateReasonCode
               
            
            
               The reason code for the function's current state. When the code is Creating, you can't invoke or
      modify the function.
               Type: String
               Valid Values: Idle | Creating | Restoring | EniLimitExceeded | InsufficientRolePermissions | InvalidConfiguration | InternalError | SubnetOutOfIPAddresses | InvalidSubnet | InvalidSecurityGroup | ImageDeleted | ImageAccessDenied | InvalidImage | KMSKeyAccessDenied | KMSKeyNotFound | InvalidStateKMSKey | DisabledKMSKey | EFSIOError | EFSMountConnectivityError | EFSMountFailure | EFSMountTimeout | InvalidRuntime | InvalidZipFileException | FunctionError
               
            
          
            
               
                  Timeout
               
            
            
               The amount of time in seconds that Lambda allows a function to run before stopping it.
               Type: Integer
               Valid Range: Minimum value of 1.
            
          
            
               
                  TracingConfig
               
            
            
               The function's AWS X-Ray tracing configuration.
               Type: TracingConfigResponse object
            
          
            
               
                  Version
               
            
            
               The version of the Lambda function.
               Type: String
               Length Constraints: Minimum length of 1. Maximum length of 1024.
               Pattern: (\$LATEST|[0-9]+)
               
            
          
            
               
                  VpcConfig
               
            
            
               The function's networking configuration.
               Type: VpcConfigResponse object
            
         
    
      Errors
      For information about the errors that are common to all actions, see Common Errors.
      
          
          
          
          
          
          
          
          
          
      
            
               
                  CodeSigningConfigNotFoundException
               
            
            
               The specified code signing configuration does not exist.
               HTTP Status Code: 404
            
          
            
               
                  CodeStorageExceededException
               
            
            
               Your AWS account has exceeded its maximum total code size. For more information, see Lambda quotas.
               HTTP Status Code: 400
            
          
            
               
                  CodeVerificationFailedException
               
            
            
               The code signature failed one or more of the validation checks for signature mismatch or expiry, and the code
      signing policy is set to ENFORCE. Lambda blocks the deployment.
               HTTP Status Code: 400
            
          
            
               
                  InvalidCodeSignatureException
               
            
            
               The code signature failed the integrity check. If the integrity check fails, then Lambda blocks
      deployment, even if the code signing policy is set to WARN.
               HTTP Status Code: 400
            
          
            
               
                  InvalidParameterValueException
               
            
            
               One of the parameters in the request is not valid.
               HTTP Status Code: 400
            
          
            
               
                  ResourceConflictException
               
            
            
               The resource already exists, or another operation is in progress.
               HTTP Status Code: 409
            
          
            
               
                  ResourceNotFoundException
               
            
            
               The resource specified in the request does not exist.
               HTTP Status Code: 404
            
          
            
               
                  ServiceException
               
            
            
               The AWS Lambda service encountered an internal error.
               HTTP Status Code: 500
            
          
            
               
                  TooManyRequestsException
               
            
            
               The request throughput limit was exceeded. For more information, see Lambda quotas.
               HTTP Status Code: 429
            
         
    
      See Also
      For more information about using this API in one of the language-specific AWS SDKs, see the following:
      
          
          
          
          
          
          
          
          
          
      
            
               AWS Command Line Interface
            
         
            
               AWS SDK for .NET
            
         
            
               AWS SDK for C++
            
         
            
               AWS SDK for Go v2
            
         
            
               AWS SDK for Java V2
            
         
            
               AWS SDK for JavaScript V3
            
         
            
               AWS SDK for PHP V3
            
         
            
               AWS SDK for Python
            
         
            
               AWS SDK for Ruby V3
            
         
   Document ConventionsCreateEventSourceMappingCreateFunctionUrlConfigDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS Command Line InterfaceUser Guide for Version 2AWS CLI install and update
                instructionsTroubleshooting AWS CLI install and uninstall
                errorsNext stepsInstalling or updating to the latest version of
            the AWS CLIThis topic describes how to install or update the latest release of the AWS Command Line Interface (AWS CLI)
        on supported operating systems. For information on the latest releases of AWS CLI, see the
            AWS CLI version 2
            Changelog on GitHub.To install a past release of the AWS CLI, see Installing past releases of the AWS CLI version 2. For
        uninstall instructions, see Uninstalling the AWS CLI version 2.ImportantAWS CLI versions 1 and 2 use the same aws command name. If you previously
            installed AWS CLI version 1, see Migration guide for the AWS CLI version 2.TopicsAWS CLI install and update
                instructionsTroubleshooting AWS CLI install and uninstall
                errorsNext steps
        AWS CLI install and update
                instructions
        For installation instructions, expand the section for your operating system.
        
                    Install and update requirements
                
                    
                     
                     
                     
                     
                
                        You must be able to extract or "unzip" the downloaded package. If
                            your operating system doesn't have the built-in unzip
                            command, use an equivalent.
                    
                        The AWS CLI uses glibc, groff, and
                            less. These are included by default in most major
                            distributions of Linux.
                    
                        We support the AWS CLI on 64-bit versions of recent distributions of
                            CentOS, Fedora, Ubuntu, Amazon Linux 1, Amazon Linux 2, Amazon Linux 2023, and Linux
                            ARM.
                    
                        Because AWS doesn't maintain third-party repositories other than
                                snap, we can’t guarantee that they contain the latest
                            version of the AWS CLI.
                    
                    Install or
                        update the AWS CLI
                WarningIf this is your first time updating on Amazon Linux, to install the latest
                        version of the AWS CLI, you must uninstall the pre-installed
                        yum version using the following command:$ sudo yum remove awscliAfter the yum installation of the AWS CLI is removed,
                        follow the below Linux install instructions.
                You can install the AWS CLI by using one of the following methods:
                    
                         
                         
                    
                            The command line installer is
                                good option for version control, as you can specify the version to
                                install. This option does not auto-update and you must download a
                                new installer each time you update to overwrite previous
                                version.
                        
                            The officially supported snap
                                    package is a good option to always have the latest
                                version of the AWS CLI as snap packages automatically refresh. There
                                is no built-in support for selecting minor versions of AWS CLI and
                                therefore is not an optimal install method if your team needs to pin
                                versions.
                        
                
                    Command line installer - Linux x86 (64-bit)
                                To update your current installation of AWS CLI, download a new
                                    installer each time you update to overwrite previous versions.
                                    Follow these steps from the command line to install the AWS CLI on
                                    Linux.
                                The following are quick installation steps in a single copy
                                    and paste group that provide a basic installation. For guided
                                    instructions, see the steps that follow.
                                            Note(Optional)
                                                  The following command block downloads and installs
                                                  the AWS CLI without first verifying the integrity of
                                                  your download. To verify the integrity of your
                                                  download, use the below step by step
                                                  instructions.
                                            To install the
                                                AWS CLI, run the following commands.
                                            $ curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
unzip awscliv2.zip
sudo ./aws/install
                                            To update your current
                                        installation of the AWS CLI, add your existing
                                    symlink and installer information to construct the
                                        install command using the
                                        --bin-dir, --install-dir, and
                                        --update parameters. The following command
                                    block uses an example symlink of
                                        /usr/local/bin and example
                                    installer location of
                                        /usr/local/aws-cli to install the
                                    AWS CLI locally for the current user.
                                            $ curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
unzip awscliv2.zip
sudo ./aws/install --bin-dir /usr/local/bin --install-dir /usr/local/aws-cli --update
                                Guided installation steps
                                        Download the installation file in one of the following
                                            ways:
                                                  
                                                   
                                                   
                                                  
                                                  Use the
                                                  curl command – The
                                                  -o option specifies the file name
                                                  that the downloaded package is written to. The
                                                  options on the following example command write the
                                                  downloaded file to the current directory with the
                                                  local name awscliv2.zip. 
                                                  $ curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
                                                  
                                                  Downloading from the
                                                  URL – To download the installer
                                                  with your browser, use the following URL: https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip
                                                  
                                    
                                        (Optional) Verifying the
                                                integrity of your downloaded zip
                                            file
                                        If you chose to manually download the AWS CLI installer
                                            package .zip in the above steps,
                                            you can use the following steps to verify the signatures
                                            by using the GnuPG tool.
                                        The AWS CLI installer package .zip
                                            files are cryptographically signed using PGP signatures.
                                            If there is any damage or alteration of the files, this
                                            verification fails and you should not proceed with
                                            installation.
                                        
                                                Download and install the gpg
                                                  command using your package manager. For more
                                                  information about GnuPG, see the
                                                  GnuPG
                                                  website. 
                                            
                                                To create the public key file, create a text
                                                  file and paste in the following text.
                                                -----BEGIN PGP PUBLIC KEY BLOCK-----

mQINBF2Cr7UBEADJZHcgusOJl7ENSyumXh85z0TRV0xJorM2B/JL0kHOyigQluUG
ZMLhENaG0bYatdrKP+3H91lvK050pXwnO/R7fB/FSTouki4ciIx5OuLlnJZIxSzx
PqGl0mkxImLNbGWoi6Lto0LYxqHN2iQtzlwTVmq9733zd3XfcXrZ3+LblHAgEt5G
TfNxEKJ8soPLyWmwDH6HWCnjZ/aIQRBTIQ05uVeEoYxSh6wOai7ss/KveoSNBbYz
gbdzoqI2Y8cgH2nbfgp3DSasaLZEdCSsIsK1u05CinE7k2qZ7KgKAUIcT/cR/grk
C6VwsnDU0OUCideXcQ8WeHutqvgZH1JgKDbznoIzeQHJD238GEu+eKhRHcz8/jeG
94zkcgJOz3KbZGYMiTh277Fvj9zzvZsbMBCedV1BTg3TqgvdX4bdkhf5cH+7NtWO
lrFj6UwAsGukBTAOxC0l/dnSmZhJ7Z1KmEWilro/gOrjtOxqRQutlIqG22TaqoPG
fYVN+en3Zwbt97kcgZDwqbuykNt64oZWc4XKCa3mprEGC3IbJTBFqglXmZ7l9ywG
EEUJYOlb2XrSuPWml39beWdKM8kzr1OjnlOm6+lpTRCBfo0wa9F8YZRhHPAkwKkX
XDeOGpWRj4ohOx0d2GWkyV5xyN14p2tQOCdOODmz80yUTgRpPVQUtOEhXQARAQAB
tCFBV1MgQ0xJIFRlYW0gPGF3cy1jbGlAYW1hem9uLmNvbT6JAlQEEwEIAD4CGwMF
CwkIBwIGFQoJCAsCBBYCAwECHgECF4AWIQT7Xbd/1cEYuAURraimMQrMRnJHXAUC
ZqFYbwUJCv/cOgAKCRCmMQrMRnJHXKYuEAC+wtZ611qQtOl0t5spM9SWZuszbcyA
0xBAJq2pncnp6wdCOkuAPu4/R3UCIoD2C49MkLj9Y0Yvue8CCF6OIJ8L+fKBv2DI
yWZGmHL0p9wa/X8NCKQrKxK1gq5PuCzi3f3SqwfbZuZGeK/ubnmtttWXpUtuU/Iz
VR0u/0sAy3j4uTGKh2cX7XnZbSqgJhUk9H324mIJiSwzvw1Ker6xtH/LwdBeJCck
bVBdh3LZis4zuD4IZeBO1vRvjot3Oq4xadUv5RSPATg7T1kivrtLCnwvqc6L4LnF
0OkNysk94L3LQSHyQW2kQS1cVwr+yGUSiSp+VvMbAobAapmMJWP6e/dKyAUGIX6+
2waLdbBs2U7MXznx/2ayCLPH7qCY9cenbdj5JhG9ibVvFWqqhSo22B/URQE/CMrG
+3xXwtHEBoMyWEATr1tWwn2yyQGbkUGANneSDFiTFeoQvKNyyCFTFO1F2XKCcuDs
19nj34PE2TJilTG2QRlMr4D0NgwLLAMg2Los1CK6nXWnImYHKuaKS9LVaCoC8vu7
IRBik1NX6SjrQnftk0M9dY+s0ZbAN1gbdjZ8H3qlbl/4TxMdr87m8LP4FZIIo261
Eycv34pVkCePZiP+dgamEiQJ7IL4ZArio9mv6HbDGV6mLY45+l6/0EzCwkI5IyIf
BfWC9s/USgxchg==
=ptgS
-----END PGP PUBLIC KEY BLOCK-----
                                                For reference, the following are the details
                                                  of the public key.
                                                Key ID:           A6310ACC4672475C
Type:             RSA
Size:             4096/4096
Created:          2019-09-18
Expires:          2025-07-24
User ID:          AWS CLI Team <aws-cli@amazon.com>
Key fingerprint:  FB5D B77F D5C1 18B8 0511  ADA8 A631 0ACC 4672 475C
                                            
                                                Import the AWS CLI public key with the following
                                                  command, substituting
                                                  public-key-file-name
                                                  with the file name of the public key you
                                                  created.
                                                $ gpg --import public-key-file-name
gpg: /home/username/.gnupg/trustdb.gpg: trustdb created
gpg: key A6310ACC4672475C: public key "AWS CLI Team <aws-cli@amazon.com>" imported
gpg: Total number processed: 1
gpg:               imported: 1
                                            
                                                Download the AWS CLI signature file for the
                                                  package you downloaded. It has the same path and
                                                  name as the .zip file it corresponds
                                                  to, but has the extension .sig. In
                                                  the following examples, we save it to the current
                                                  directory as a file named
                                                  awscliv2.sig.
                                                  For the latest version
                                                  of the AWS CLI, use the following command
                                                  block:
                                                  $ curl -o awscliv2.sig https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip.sig
                                                  For a specific version
                                                  of the AWS CLI, append a hyphen and the
                                                  version number to the filename. For this example
                                                  the filename for version
                                                  2.0.30 would be
                                                  awscli-exe-linux-x86_64-2.0.30.zip.sig
                                                  resulting in the following command:
                                                  $ curl -o awscliv2.sig https://awscli.amazonaws.com/awscli-exe-linux-x86_64-2.0.30.zip.sig
                                                   For a list of versions, see the AWS CLI version 2 Changelog on GitHub.
                                            
                                                Verify the signature, passing both the
                                                  downloaded .sig and
                                                  .zip file names as parameters to the
                                                  gpg command.
                                                $ gpg --verify awscliv2.sig awscliv2.zip
                                                The output should look similar to the
                                                  following.
                                                gpg: Signature made Mon Nov  4 19:00:01 2019 PST
gpg:                using RSA key FB5D B77F D5C1 18B8 0511 ADA8 A631 0ACC 4672 475C
gpg: Good signature from "AWS CLI Team <aws-cli@amazon.com>" [unknown]
gpg: WARNING: This key is not certified with a trusted signature!
gpg:          There is no indication that the signature belongs to the owner.
Primary key fingerprint: FB5D B77F D5C1 18B8 0511  ADA8 A631 0ACC 4672 475C
                                                ImportantThe warning in the output is expected and
                                                  doesn't indicate a problem. It occurs because
                                                  there isn't a chain of trust between your personal
                                                  PGP key (if you have one) and the AWS CLI PGP key.
                                                  For more information, see Web of trust.
                                            
                                    
                                        Unzip the installer. If your Linux distribution
                                            doesn't have a built-in unzip command, use
                                            an equivalent to unzip it. The following example command
                                            unzips the package and creates a directory named
                                                aws under the current
                                            directory.
                                        $ unzip awscliv2.zip
                                        NoteWhen updating from a previous version, the
                                                  unzip command prompts to overwrite
                                                existing files. To skip these prompts, such as with
                                                script automation, use the -u update
                                                flag for unzip. This flag automatically
                                                updates existing files and creates new ones as
                                                needed.$ unzip -u awscliv2.zip
                                    
                                        Run the install program. The installation command uses
                                            a file named install in the newly
                                            unzipped aws directory. By default,
                                            the files are all installed to
                                                /usr/local/aws-cli, and a
                                            symbolic link is created in
                                                /usr/local/bin. The command
                                            includes sudo to grant write permissions to
                                            those directories. 
                                        $ sudo ./aws/install
                                        You can install without sudo if you
                                            specify directories that you already have write
                                            permissions to. Use the following instructions for the
                                                install command to specify the
                                            installation location:
                                        
                                             
                                             
                                             
                                        
                                                Ensure that the paths you provide to the
                                                  -i and -b parameters
                                                  contain no volume name or directory names that
                                                  contain any space characters or other white space
                                                  characters. If there is a space, the installation
                                                  fails.
                                            
                                                --install-dir or -i
                                                  – This option specifies the directory to
                                                  copy all of the files to.
                                                The default value is
                                                  /usr/local/aws-cli.
                                            
                                                --bin-dir or -b
                                                  – This option specifies that the main
                                                  aws program in the install directory
                                                  is symbolically linked to the file
                                                  aws in the specified path.
                                                  You must have write permissions to the specified
                                                  directory. Creating a symlink to a directory that
                                                  is already in your path eliminates the need to add
                                                  the install directory to the user's
                                                  $PATH variable. 
                                                The default value is
                                                  /usr/local/bin.
                                            
                                        $ ./aws/install -i /usr/local/aws-cli -b /usr/local/bin
                                        NoteTo update your current installation of the AWS CLI,
                                                add your existing symlink and installer information
                                                to construct the install command with
                                                the --update parameter.$ sudo ./aws/install --bin-dir /usr/local/bin --install-dir /usr/local/aws-cli --updateTo locate the existing symlink and installation
                                                directory, use the following steps:
                                                 
                                                 
                                            
                                                  Use the which command to find
                                                  your symlink. This gives you the path to use with
                                                  the --bin-dir parameter.
                                                  $ which aws
/usr/local/bin/aws
                                                
                                                  Use the ls command to find the
                                                  directory that your symlink points to. This gives
                                                  you the path to use with the
                                                  --install-dir parameter.
                                                  $ ls -l /usr/local/bin/aws
lrwxrwxrwx 1 ec2-user ec2-user 49 Oct 22 09:49 /usr/local/bin/aws -> /usr/local/aws-cli/v2/current/bin/aws
                                                
                                    
                                        Confirm the installation with the following command. 
                                        $ aws --version
aws-cli/2.19.1 Python/3.11.6 Linux/5.10.205-195.807.amzn2.x86_64 botocore/2.4.5
                                        If the aws command cannot be found, you
                                            might need to restart your terminal or follow the
                                            troubleshooting in Troubleshooting errors for the AWS CLI.
                                    
                            
                        Command line - Linux ARM
                                To update your current installation of AWS CLI, download a new
                                    installer each time you update to overwrite previous versions.
                                    Follow these steps from the command line to install the AWS CLI on
                                    Linux.
                                The following are quick installation steps in a single copy
                                    and paste group that provide a basic installation. For guided
                                    instructions, see the steps that follow.
                                Note(Optional) The following
                                        command block downloads and installs the AWS CLI without first
                                        verifying the integrity of your download. To verify the
                                        integrity of your download, use the below step by step
                                        instructions.
                                To install the AWS CLI, run the
                                    following commands.
                                $ curl "https://awscli.amazonaws.com/awscli-exe-linux-aarch64.zip" -o "awscliv2.zip"
unzip awscliv2.zip
sudo ./aws/install
                                To update your current
                                        installation of the AWS CLI, add your existing
                                    symlink and installer information to construct the
                                        install command using the
                                        --bin-dir, --install-dir, and
                                        --update parameters. The following command
                                    block uses an example symlink of
                                        /usr/local/bin and example
                                    installer location of
                                        /usr/local/aws-cli.
                                $ curl "https://awscli.amazonaws.com/awscli-exe-linux-aarch64.zip" -o "awscliv2.zip"
unzip awscliv2.zip
sudo ./aws/install --bin-dir /usr/local/bin --install-dir /usr/local/aws-cli --update
                                Guided installation steps
                                        Download the installation file in one of the following
                                            ways:
                                        
                                             
                                             
                                        
                                                Use the
                                                  curl command – The
                                                  -o option specifies the file name
                                                  that the downloaded package is written to. The
                                                  options on the following example command write the
                                                  downloaded file to the current directory with the
                                                  local name awscliv2.zip. 
                                                $ curl "https://awscli.amazonaws.com/awscli-exe-linux-aarch64.zip" -o "awscliv2.zip"
                                            
                                                Downloading from the
                                                  URL – To download the installer
                                                  with your browser, use the following URL: https://awscli.amazonaws.com/awscli-exe-linux-aarch64.zip
                                            
                                    
                                        (Optional) Verifying the
                                                integrity of your downloaded zip
                                            file
                                        If you chose to manually download the AWS CLI installer
                                            package .zip in the above steps,
                                            you can use the following steps to verify the signatures
                                            by using the GnuPG tool.
                                        The AWS CLI installer package .zip
                                            files are cryptographically signed using PGP signatures.
                                            If there is any damage or alteration of the files, this
                                            verification fails and you should not proceed with
                                            installation.
                                        
                                                Download and install the gpg
                                                  command using your package manager. For more
                                                  information about GnuPG, see the
                                                  GnuPG
                                                  website. 
                                            
                                                To create the public key file, create a text
                                                  file and paste in the following text.
                                                -----BEGIN PGP PUBLIC KEY BLOCK-----

mQINBF2Cr7UBEADJZHcgusOJl7ENSyumXh85z0TRV0xJorM2B/JL0kHOyigQluUG
ZMLhENaG0bYatdrKP+3H91lvK050pXwnO/R7fB/FSTouki4ciIx5OuLlnJZIxSzx
PqGl0mkxImLNbGWoi6Lto0LYxqHN2iQtzlwTVmq9733zd3XfcXrZ3+LblHAgEt5G
TfNxEKJ8soPLyWmwDH6HWCnjZ/aIQRBTIQ05uVeEoYxSh6wOai7ss/KveoSNBbYz
gbdzoqI2Y8cgH2nbfgp3DSasaLZEdCSsIsK1u05CinE7k2qZ7KgKAUIcT/cR/grk
C6VwsnDU0OUCideXcQ8WeHutqvgZH1JgKDbznoIzeQHJD238GEu+eKhRHcz8/jeG
94zkcgJOz3KbZGYMiTh277Fvj9zzvZsbMBCedV1BTg3TqgvdX4bdkhf5cH+7NtWO
lrFj6UwAsGukBTAOxC0l/dnSmZhJ7Z1KmEWilro/gOrjtOxqRQutlIqG22TaqoPG
fYVN+en3Zwbt97kcgZDwqbuykNt64oZWc4XKCa3mprEGC3IbJTBFqglXmZ7l9ywG
EEUJYOlb2XrSuPWml39beWdKM8kzr1OjnlOm6+lpTRCBfo0wa9F8YZRhHPAkwKkX
XDeOGpWRj4ohOx0d2GWkyV5xyN14p2tQOCdOODmz80yUTgRpPVQUtOEhXQARAQAB
tCFBV1MgQ0xJIFRlYW0gPGF3cy1jbGlAYW1hem9uLmNvbT6JAlQEEwEIAD4CGwMF
CwkIBwIGFQoJCAsCBBYCAwECHgECF4AWIQT7Xbd/1cEYuAURraimMQrMRnJHXAUC
ZqFYbwUJCv/cOgAKCRCmMQrMRnJHXKYuEAC+wtZ611qQtOl0t5spM9SWZuszbcyA
0xBAJq2pncnp6wdCOkuAPu4/R3UCIoD2C49MkLj9Y0Yvue8CCF6OIJ8L+fKBv2DI
yWZGmHL0p9wa/X8NCKQrKxK1gq5PuCzi3f3SqwfbZuZGeK/ubnmtttWXpUtuU/Iz
VR0u/0sAy3j4uTGKh2cX7XnZbSqgJhUk9H324mIJiSwzvw1Ker6xtH/LwdBeJCck
bVBdh3LZis4zuD4IZeBO1vRvjot3Oq4xadUv5RSPATg7T1kivrtLCnwvqc6L4LnF
0OkNysk94L3LQSHyQW2kQS1cVwr+yGUSiSp+VvMbAobAapmMJWP6e/dKyAUGIX6+
2waLdbBs2U7MXznx/2ayCLPH7qCY9cenbdj5JhG9ibVvFWqqhSo22B/URQE/CMrG
+3xXwtHEBoMyWEATr1tWwn2yyQGbkUGANneSDFiTFeoQvKNyyCFTFO1F2XKCcuDs
19nj34PE2TJilTG2QRlMr4D0NgwLLAMg2Los1CK6nXWnImYHKuaKS9LVaCoC8vu7
IRBik1NX6SjrQnftk0M9dY+s0ZbAN1gbdjZ8H3qlbl/4TxMdr87m8LP4FZIIo261
Eycv34pVkCePZiP+dgamEiQJ7IL4ZArio9mv6HbDGV6mLY45+l6/0EzCwkI5IyIf
BfWC9s/USgxchg==
=ptgS
-----END PGP PUBLIC KEY BLOCK-----
                                                For reference, the following are the details
                                                  of the public key.
                                                Key ID:           A6310ACC4672475C
Type:             RSA
Size:             4096/4096
Created:          2019-09-18
Expires:          2025-07-24
User ID:          AWS CLI Team <aws-cli@amazon.com>
Key fingerprint:  FB5D B77F D5C1 18B8 0511  ADA8 A631 0ACC 4672 475C
                                            
                                                Import the AWS CLI public key with the following
                                                  command, substituting
                                                  public-key-file-name
                                                  with the file name of the public key you
                                                  created.
                                                $ gpg --import public-key-file-name
gpg: /home/username/.gnupg/trustdb.gpg: trustdb created
gpg: key A6310ACC4672475C: public key "AWS CLI Team <aws-cli@amazon.com>" imported
gpg: Total number processed: 1
gpg:               imported: 1
                                            
                                                Download the AWS CLI signature file for the
                                                  package you downloaded. It has the same path and
                                                  name as the .zip file it corresponds
                                                  to, but has the extension .sig. In
                                                  the following examples, we save it to the current
                                                  directory as a file named
                                                  awscliv2.sig.
                                                For the latest version
                                                  of the AWS CLI, use the following command
                                                  block:
                                                $ curl -o awscliv2.sig https://awscli.amazonaws.com/awscli-exe-linux-aarch64.zip.sig
                                                For a specific version
                                                  of the AWS CLI, append a hyphen and the
                                                  version number to the filename. For this example
                                                  the filename for version
                                                  2.0.30 would be
                                                  awscli-exe-linux-aarch64-2.0.30.zip.sig
                                                  resulting in the following command:
                                                $ curl -o awscliv2.sig https://awscli.amazonaws.com/awscli-exe-linux-aarch64-2.0.30.zip.sig
                                                 For a list of versions, see the AWS CLI version 2 Changelog on GitHub.
                                            
                                                Verify the signature, passing both the
                                                  downloaded .sig and
                                                  .zip file names as parameters to the
                                                  gpg command.
                                                $ gpg --verify awscliv2.sig awscliv2.zip
                                                The output should look similar to the
                                                  following.
                                                gpg: Signature made Mon Nov  4 19:00:01 2019 PST
gpg:                using RSA key FB5D B77F D5C1 18B8 0511 ADA8 A631 0ACC 4672 475C
gpg: Good signature from "AWS CLI Team <aws-cli@amazon.com>" [unknown]
gpg: WARNING: This key is not certified with a trusted signature!
gpg:          There is no indication that the signature belongs to the owner.
Primary key fingerprint: FB5D B77F D5C1 18B8 0511  ADA8 A631 0ACC 4672 475C
                                                ImportantThe warning in the output is expected and
                                                  doesn't indicate a problem. It occurs because
                                                  there isn't a chain of trust between your personal
                                                  PGP key (if you have one) and the AWS CLI PGP key.
                                                  For more information, see Web of trust.
                                            
                                    
                                        Unzip the installer. If your Linux distribution
                                            doesn't have a built-in unzip command, use
                                            an equivalent to unzip it. The following example command
                                            unzips the package and creates a directory named
                                                aws under the current
                                            directory.
                                        $ unzip awscliv2.zip
                                        NoteWhen updating from a previous version, the
                                                  unzip command prompts to overwrite
                                                existing files. To skip these prompts, such as with
                                                script automation, use the -u update
                                                flag for unzip. This flag automatically
                                                updates existing files and creates new ones as
                                                needed.$ unzip -u awscliv2.zip
                                    
                                        Run the install program. The installation command uses
                                            a file named install in the newly
                                            unzipped aws directory. By default,
                                            the files are all installed to
                                                /usr/local/aws-cli, and a
                                            symbolic link is created in
                                                /usr/local/bin. The command
                                            includes sudo to grant write permissions to
                                            those directories. 
                                        $ sudo ./aws/install
                                        You can install without sudo if you
                                            specify directories that you already have write
                                            permissions to. Use the following instructions for the
                                                install command to specify the
                                            installation location:
                                        
                                             
                                             
                                             
                                        
                                                Ensure that the paths you provide to the
                                                  -i and -b parameters
                                                  contain no volume name or directory names that
                                                  contain any space characters or other white space
                                                  characters. If there is a space, the installation
                                                  fails.
                                            
                                                --install-dir or -i
                                                  – This option specifies the directory to
                                                  copy all of the files to.
                                                The default value is
                                                  /usr/local/aws-cli.
                                            
                                                --bin-dir or -b
                                                  – This option specifies that the main
                                                  aws program in the install directory
                                                  is symbolically linked to the file
                                                  aws in the specified path.
                                                  You must have write permissions to the specified
                                                  directory. Creating a symlink to a directory that
                                                  is already in your path eliminates the need to add
                                                  the install directory to the user's
                                                  $PATH variable. 
                                                The default value is
                                                  /usr/local/bin.
                                            
                                        $ ./aws/install -i /usr/local/aws-cli -b /usr/local/bin
                                        NoteTo update your current installation of the AWS CLI,
                                                add your existing symlink and installer information
                                                to construct the install command with
                                                the --update parameter.$ sudo ./aws/install --bin-dir /usr/local/bin --install-dir /usr/local/aws-cli --updateTo locate the existing symlink and installation
                                                directory, use the following steps:
                                                 
                                                 
                                            
                                                  Use the which command to find
                                                  your symlink. This gives you the path to use with
                                                  the --bin-dir parameter.
                                                  $ which aws
/usr/local/bin/aws
                                                
                                                  Use the ls command to find the
                                                  directory that your symlink points to. This gives
                                                  you the path to use with the
                                                  --install-dir parameter.
                                                  $ ls -l /usr/local/bin/aws
lrwxrwxrwx 1 ec2-user ec2-user 49 Oct 22 09:49 /usr/local/bin/aws -> /usr/local/aws-cli/v2/current/bin/aws
                                                
                                    
                                        Confirm the installation with the following command. 
                                        $ aws --version
aws-cli/2.19.1 Python/3.11.6 Linux/5.10.205-195.807.amzn2.x86_64 botocore/2.4.5
                                        If the aws command cannot be found, you
                                            might need to restart your terminal or follow the
                                            troubleshooting in Troubleshooting errors for the AWS CLI.
                                    
                            
                    Snap package
                                We provide an official AWS supported version of the AWS CLI on
                                        snap. If you want to always have the latest
                                    version of the AWS CLI installed on your system, a snap package
                                    provides this for you as it auto-updates. There is no built-in
                                    support for selecting minor versions of AWS CLI and therefore it
                                    is not an optimal install method if your team needs to pin
                                    versions. If you want to install a specific minor version of the
                                    AWS CLI, we suggest you use the command line installer.
                                
                                        If your Linux platform does not already have
                                                snap installed, install
                                                snap on your platform. 
                                        
                                                For information on installing
                                                  snap, see Installing the daemon in the Snap
                                                  documentation.
                                            
                                                You may need to restart your system so that
                                                  your PATH variables are updated
                                                  correctly. If you are having installation issues,
                                                  follow steps in Fix common issues in the Snap
                                                  documentation.
                                            
                                                To verify that snap is installed
                                                  correctly, run the following command.
                                                $ snap version
                                            
                                    
                                        Run the following snap install command
                                            for the AWS CLI.
                                        $ snap install aws-cli --classic
                                        Depending on your permissions, you may need to add
                                                sudo to the command.
                                        $ sudo snap install aws-cli --classic
                                        NoteTo view the snap repository for the AWS CLI,
                                                including additional snap instructions,
                                                see the aws-cli page in the
                                                  Canonical Snapcraft
                                                  website.
                                    
                                        Verify that the AWS CLI installed correctly.
                                        $ aws --version
aws-cli/2.19.1 Python/3.11.6 Linux/5.10.205-195.807.amzn2.x86_64 botocore/2.4.5
                                        If you get an error, see Troubleshooting errors for the AWS CLI.
                                    
                            
                
                
        
                    Install and update
                            requirements
                    
                         
                         
                    
                            We support the AWS CLI on macOS versions 11 and later. For more
                                information, see macOS support policy updates for the AWS CLI v2 on the
                                    AWS Developer Tools
                                Blog.
                        
                            Because AWS doesn't maintain third-party repositories, we can’t
                                guarantee that they contain the latest version of the AWS CLI.
                        
                    
                    
    macOS version support matrix
    
                
                    AWS CLI version
                    Supported macOS version
                
            
                
                    2.21.0 – current
                    11+
                
                
                    2.17.0 –2.20.0
                    10.15+
                
                
                    2.0.0 – 2.16.12
                    10.14 and below
                
            

                 
                    Install or update the
                            AWS CLI
                    If you are updating to the latest version, use the same installation
                        method that you used in your current version. You can install the AWS CLI on
                        macOS in the following ways.
                    
                        GUI installer
                                The following steps show how to install the latest version
                                        of the AWS CLI by using the standard macOS user interface and
                                        your browser.
                                        In your browser, download the macOS
                                                pkg file: https://awscli.amazonaws.com/AWSCLIV2.pkg
                                    
                                        Run your downloaded file and follow the on-screen
                                            instructions. You can choose to install the AWS CLI in the
                                            following ways:
                                        
                                             
                                             
                                        
                                                For all users on the
                                                  computer (requires
                                                  sudo)
                                                
                                                   
                                                   
                                                
                                                  You can install to any folder, or choose the
                                                  recommended default folder of
                                                  /usr/local/aws-cli.
                                                  
                                                  The installer automatically creates a
                                                  symlink at /usr/local/bin/aws that
                                                  links to the main program in the installation
                                                  folder you chose.
                                                  
                                            
                                                For only the current
                                                  user (doesn't require
                                                  sudo)
                                                
                                                   
                                                   
                                                
                                                  You can install to any folder to which you
                                                  have write permission.
                                                  
                                                  Due to standard user permissions, after the
                                                  installer finishes, you must manually create a
                                                  symlink file in your $PATH that
                                                  points to the aws and
                                                  aws_completer programs by using the
                                                  following commands at the command prompt. If your
                                                  $PATH includes a folder you can write
                                                  to, you can run the following command without
                                                  sudo if you specify that folder as
                                                  the target's path. If you don't have a writable
                                                  folder in your $PATH, you must use
                                                  sudo in the commands to get
                                                  permissions to write to the specified target
                                                  folder. The default location for a symlink is
                                                  /usr/local/bin/.
                                                  $ sudo ln -s /folder/installed/aws-cli/aws /usr/local/bin/aws
$ sudo ln -s /folder/installed/aws-cli/aws_completer /usr/local/bin/aws_completer
                                                  
                                            
                                        NoteYou can view debug logs for the installation by
                                                pressing Cmd+L
                                                anywhere in the installer. This opens a log pane
                                                that enables you to filter and save the log. The log
                                                file is also automatically saved to
                                                  /var/log/install.log.
                                    
                                        To verify that the shell can find and run the
                                                aws command in your $PATH,
                                            use the following commands. 
                                        $ which aws
/usr/local/bin/aws 
$ aws --version
aws-cli/2.19.1 Python/3.11.6 Darwin/23.3.0 botocore/2.4.5
                                        If the aws command cannot be found, you
                                            might need to restart your terminal or follow the
                                            troubleshooting in Troubleshooting errors for the AWS CLI.
                                    
                            
                        Command line installer - All users
                                If you have sudo permissions, you can install the
                                    AWS CLI for all users on the computer. We provide the steps in one
                                    easy to copy and paste group. See the descriptions of each line
                                    in the following steps. 
                                $ curl "https://awscli.amazonaws.com/AWSCLIV2.pkg" -o "AWSCLIV2.pkg"
$ sudo installer -pkg AWSCLIV2.pkg -target /
                                Guided installation instructions
                                        Download the file using the curl command.
                                            The -o option specifies the file name that
                                            the downloaded package is written to. In this example,
                                            the file is written to
                                                AWSCLIV2.pkg in the
                                            current folder.
                                        $ curl "https://awscli.amazonaws.com/AWSCLIV2.pkg" -o "AWSCLIV2.pkg"
                                    
                                        Run the standard macOS installer program,
                                            specifying the downloaded .pkg file
                                            as the source. Use the -pkg parameter to
                                            specify the name of the package to install, and the
                                                -target / parameter for which drive to
                                            install the package to. The files are installed to
                                                /usr/local/aws-cli, and a
                                            symlink is automatically created in
                                                /usr/local/bin. You must
                                            include sudo on the command to grant write
                                            permissions to those folders. 
                                        $ sudo installer -pkg ./AWSCLIV2.pkg -target /
                                        After installation is complete, debug logs are written
                                            to /var/log/install.log.
                                    
                                        To verify that the shell can find and run the
                                                aws command in your $PATH,
                                            use the following commands. 
                                        $ which aws
/usr/local/bin/aws 
$ aws --version
aws-cli/2.19.1 Python/3.11.6 Darwin/23.3.0 botocore/2.4.5
                                        If the aws command cannot be found, you
                                            might need to restart your terminal or follow the
                                            troubleshooting in Troubleshooting errors for the AWS CLI.
                                    
                            
                        Command line - Current user
                                
                                        To specify which folder the AWS CLI is installed to, you
                                            must create an XML file with any file name. This file is
                                            an XML-formatted file that looks like the following
                                            example. Leave all values as shown, except you must
                                            replace the path
                                                /Users/myusername in line
                                            9 with the path to the folder you want the AWS CLI
                                            installed to. The folder must
                                                already exist, or the command fails. The
                                            following XML example, named
                                                choices.xml, specifies
                                            the installer to install the AWS CLI in the folder
                                                /Users/myusername, where it
                                            creates a folder named
                                            aws-cli.
                                        <?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
  <array>
    <dict>
      <key>choiceAttribute</key>
      <string>customLocation</string>
      <key>attributeSetting</key>
      <string>/Users/myusername</string>
      <key>choiceIdentifier</key>
      <string>default</string>
    </dict>
  </array>
</plist>
                                    
                                        Download the pkg installer using
                                            the curl command. The -o
                                            option specifies the file name that the downloaded
                                            package is written to. In this example, the file is
                                            written to AWSCLIV2.pkg
                                            in the current folder.
                                        $ curl "https://awscli.amazonaws.com/AWSCLIV2.pkg" -o "AWSCLIV2.pkg"
                                    
                                        Run the standard macOS installer program
                                            with the following options:
                                        
                                             
                                             
                                             
                                        
                                                Specify the name of the package to install by
                                                  using the -pkg parameter.
                                            
                                                Specify installing to a current user only by
                                                  setting the -target parameter to
                                                  CurrentUserHomeDirectory.
                                            
                                                Specify the path (relative to the current
                                                  folder) and name of the XML file that you created
                                                  in the -applyChoiceChangesXML
                                                  parameter.
                                            
                                        The following example installs the AWS CLI in the folder
                                                /Users/myusername/aws-cli.
                                        $ installer -pkg AWSCLIV2.pkg \
            -target CurrentUserHomeDirectory \
            -applyChoiceChangesXML choices.xml
                                    
                                        Because standard user permissions typically don't
                                            allow writing to folders in your $PATH, the
                                            installer in this mode doesn't try to add the symlinks
                                            to the aws and aws_completer
                                            programs. For the AWS CLI to run correctly, you must
                                            manually create the symlinks after the installer
                                            finishes. If your $PATH includes a folder
                                            you can write to and you specify the folder as the
                                            target's path, you can run the following command without
                                                sudo. If you don't have a writable
                                            folder in your $PATH, you must use
                                                sudo for permissions to write to the
                                            specified target folder. The default location for a
                                            symlink is /usr/local/bin/. Replace
                                                folder/installed with the path to your
                                            AWS CLI installation.
                                        $ sudo ln -s /folder/installed/aws-cli/aws /usr/local/bin/aws
$ sudo ln -s /folder/installed/aws-cli/aws_completer /usr/local/bin/aws_completer
                                        After installation is complete, debug logs are written
                                            to /var/log/install.log.
                                    
                                        To verify that the shell can find and run the
                                                aws command in your $PATH,
                                            use the following commands. 
                                        $ which aws
/usr/local/bin/aws 
$ aws --version
aws-cli/2.19.1 Python/3.11.6 Darwin/23.3.0 botocore/2.4.5
                                        If the aws command cannot be found, you
                                            might need to restart your terminal or follow the
                                            troubleshooting in Troubleshooting errors for the AWS CLI.
                                    
                            
                    
                
        
                    Install and update
                            requirements
                    
                         
                         
                    
                            We support the AWS CLI on Microsoft-supported versions of 64-bit
                                Windows.
                        
                            Admin rights to install software
                        
                 
                    Install or update the
                            AWS CLI
                    To update your current installation of AWS CLI on Windows, download a new
                        installer each time you update to overwrite previous versions. AWS CLI is
                        updated regularly. To see when the latest version was released, see the
                            AWS CLI version 2 Changelog on GitHub. 
                    
                            Download and run the AWS CLI MSI installer for Windows
                                (64-bit):
                            https://awscli.amazonaws.com/AWSCLIV2.msi
                            Alternatively, you can run the msiexec command to run
                                the MSI installer.
                            C:\> msiexec.exe /i https://awscli.amazonaws.com/AWSCLIV2.msi
                            For various parameters that can be used with msiexec,
                                see msiexec on the Microsoft
                                    Docs website. For example, you can use the
                                    /qn flag for a silent installation.
                            C:\> msiexec.exe /i https://awscli.amazonaws.com/AWSCLIV2.msi /qn
                        
                            To confirm the installation, open the Start
                                menu, search for cmd to open a command prompt window,
                                and at the command prompt use the aws --version
                                command. 
                            C:\> aws --version
aws-cli/2.19.1 Python/3.11.6 Windows/10 exe/AMD64 prompt/off
                            If Windows is unable to find the program, you might need to close
                                and reopen the command prompt window to refresh the path, or follow
                                the troubleshooting in Troubleshooting errors for the AWS CLI.
                        
                
     
        Troubleshooting AWS CLI install and uninstall
                errors
        If you come across issues after installing or uninstalling the AWS CLI, see Troubleshooting errors for the AWS CLI for troubleshooting steps. For the most
            relevant troubleshooting steps, see Command not found errors, The "aws --version" command
                returns a different version than you installed, and The "aws --version" command returns a
                version after uninstalling the AWS CLI.
     
        Next steps
        After you successfully install the AWS CLI, you can safely delete your downloaded
            installer files. After completing the steps in Prerequisites to use the AWS CLI version 2
            and installing the AWS CLI, you should perform a Setting up the AWS CLI.
    Document ConventionsPrerequisitesPast releasesDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAmazon LinuxUser GuideMinimal Container image sizeUsing the AL2023 Minimal Container imageAL2023 Minimal container imageNote
       The standard AL2023 container images are suitable for most use cases,
       and adapting to the minimal container image is likely to be more work
       than adapting to the AL2023 base container image.
      The AL2023 minimal container image, introduced in AL2023.2, differs from the base container image because it contains only the bare
     minimum  packages needed to install other packages. The minimal container image is designed to be a minimal set of packages, not a convenient set of packages .  The AL2023 minimal container image is built from software components already available
    in AL2023. The key difference in the minimal container image is using microdnf to
    provide the dnf package manager rather than the fully featured
      Python based dnf. This enables the minimal container image to be
    smaller with the trade-off of not having the full feature set of the dnf package
    manager which is included in the AL2023 AMIs and base container image. 
     The AL2023 minimal container image forms the base of the
     provided.al2023 AWS Lambda runtime environment.
   
     For a detailed list of packages included in the minimal container image, see Comparing packages installed on Amazon Linux 2023 Container Images.
   
     Minimal Container image size
      Because the AL2023 minimal container image contains fewer packages than the AL2023
      base container image, it is also significantly smaller. The following table compares the
      container image options of current and past releases of Amazon Linux. 
     Note
	 Image Size is as-shown on
	 
	   Amazon Linux on Amazon ECR Public Gallery.
       
     
	   
	     Image
	     Version
	     Image Size
	     Note
	   
	 
	   
	     Amazon Linux 1 (AL1)
	     2018.03.0.20230918.0
	     62.3MB
	     x86-64 only
	   
	   
	     Amazon Linux 2
	     2.0.20230926.0
	     64.2MB
	     aarch64 is 1.6MB larger than x86-64
	   
	   
	     Amazon Linux 2023 base container image
	     2023.2.20231002.0
	     52.4MB
	     
	   
	   
	     Amazon Linux 2023 minimal container image
	     2023.2.20231002.0-minimal
	     35.2MB
	     
	   
	 
    
     Using the AL2023 Minimal Container image
      The AL2023 minimal container image is available on ECR and the
        2023-minimal tag will always point to the latest AL2023 based minimal
      container image, while the minimal tag may be updated to a newer version of Amazon Linux
      than AL2023. 
      You can pull these tags using docker with the following example: 
       $ docker pull public.ecr.aws/amazonlinux/amazonlinux:minimal
       $ docker pull public.ecr.aws/amazonlinux/amazonlinux:2023-minimal
    
     The following example shows a Dockerfile that takes the minimal container
      image and installs GCC on top of it :
	
FROM public.ecr.aws/amazonlinux/amazonlinux:2023-minimal
RUN dnf install -y gcc && dnf clean all
	
     
   Document ConventionsAL2023 Base Container ImageBuilding bare-bones AL2023 container imagesDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAmazon LinuxUser GuideComparing packages installed on Amazon Linux 2023 Container ImagesA comparison of the RPMs present on the AL2023 base container image compared with the RPMs present on the AL2023 minimal container image.
            
               Package
               Container
               Minimal Container
            
         
            
               
                  alternatives
               
               1.15
               1.15
            
            
               
                  amazon-linux-repo-cdn
               
               2023.6.20241031
               2023.6.20241031
            
            
               
                  audit-libs
               
               3.0.6
               3.0.6
            
            
               
                  basesystem
               
               11
               11
            
            
               
                  bash
               
               5.2.15
               5.2.15
            
            
               
                  bzip2-libs
               
               1.0.8
               1.0.8
            
            
               
                  ca-certificates
               
               2023.2.68
               2023.2.68
            
            
               
                  coreutils-single
               
               8.32
               8.32
            
            
               
                  crypto-policies
               
               20220428
               20220428
            
            
               
                  curl-minimal
               
               8.5.0
               8.5.0
            
            
               
                  dnf
               
               4.14.0
               
            
            
               
                  dnf-data
               
               4.14.0
               4.14.0
            
            
               
                  elfutils-default-yama-scope
               
               0.188
               
            
            
               
                  elfutils-libelf
               
               0.188
               
            
            
               
                  elfutils-libs
               
               0.188
               
            
            
               
                  expat
               
               2.5.0
               
            
            
               
                  file-libs
               
               5.39
               5.39
            
            
               
                  filesystem
               
               3.14
               3.14
            
            
               
                  gawk
               
               5.1.0
               5.1.0
            
            
               
                  gdbm-libs
               
               1.19
               
            
            
               
                  glib2
               
               2.74.7
               2.74.7
            
            
               
                  glibc
               
               2.34
               2.34
            
            
               
                  glibc-common
               
               2.34
               2.34
            
            
               
                  glibc-minimal-langpack
               
               2.34
               2.34
            
            
               
                  gmp
               
               6.2.1
               6.2.1
            
            
               
                  gnupg2-minimal
               
               2.3.7
               2.3.7
            
            
               
                  gobject-introspection
               
               
               1.73.0
            
            
               
                  gpgme
               
               1.15.1
               1.15.1
            
            
               
                  grep
               
               3.8
               3.8
            
            
               
                  json-c
               
               0.14
               0.14
            
            
               
                  keyutils-libs
               
               1.6.3
               1.6.3
            
            
               
                  krb5-libs
               
               1.21.3
               1.21.3
            
            
               
                  libacl
               
               2.3.1
               2.3.1
            
            
               
                  libarchive
               
               3.7.4
               3.7.4
            
            
               
                  libassuan
               
               2.5.5
               2.5.5
            
            
               
                  libattr
               
               2.5.1
               2.5.1
            
            
               
                  libblkid
               
               2.37.4
               2.37.4
            
            
               
                  libcap
               
               2.48
               2.48
            
            
               
                  libcap-ng
               
               0.8.2
               0.8.2
            
            
               
                  libcom_err
               
               1.46.5
               1.46.5
            
            
               
                  libcomps
               
               0.1.20
               
            
            
               
                  libcurl-minimal
               
               8.5.0
               8.5.0
            
            
               
                  libdnf
               
               0.69.0
               0.69.0
            
            
               
                  libffi
               
               3.4.4
               3.4.4
            
            
               
                  libgcc
               
               11.4.1
               11.4.1
            
            
               
                  libgcrypt
               
               1.10.2
               1.10.2
            
            
               
                  libgomp
               
               11.4.1
               
            
            
               
                  libgpg-error
               
               1.42
               1.42
            
            
               
                  libidn2
               
               2.3.2
               2.3.2
            
            
               
                  libmodulemd
               
               2.13.0
               2.13.0
            
            
               
                  libmount
               
               2.37.4
               2.37.4
            
            
               
                  libnghttp2
               
               1.59.0
               1.59.0
            
            
               
                  libpeas
               
               
               1.32.0
            
            
               
                  libpsl
               
               0.21.1
               0.21.1
            
            
               
                  librepo
               
               1.14.5
               1.14.5
            
            
               
                  libreport-filesystem
               
               2.15.2
               2.15.2
            
            
               
                  libselinux
               
               3.4
               3.4
            
            
               
                  libsepol
               
               3.4
               3.4
            
            
               
                  libsigsegv
               
               2.13
               2.13
            
            
               
                  libsmartcols
               
               2.37.4
               2.37.4
            
            
               
                  libsolv
               
               0.7.22
               0.7.22
            
            
               
                  libstdc++
               
               11.4.1
               11.4.1
            
            
               
                  libtasn1
               
               4.19.0
               4.19.0
            
            
               
                  libunistring
               
               0.9.10
               0.9.10
            
            
               
                  libuuid
               
               2.37.4
               2.37.4
            
            
               
                  libverto
               
               0.3.2
               0.3.2
            
            
               
                  libxcrypt
               
               4.4.33
               
            
            
               
                  libxml2
               
               2.10.4
               2.10.4
            
            
               
                  libyaml
               
               0.2.5
               0.2.5
            
            
               
                  libzstd
               
               1.5.5
               1.5.5
            
            
               
                  lua-libs
               
               5.4.4
               5.4.4
            
            
               
                  lz4-libs
               
               1.9.4
               1.9.4
            
            
               
                  microdnf
               
               
               3.10.0
            
            
               
                  microdnf-dnf
               
               
               3.10.0
            
            
               
                  mpfr
               
               4.1.0
               4.1.0
            
            
               
                  ncurses-base
               
               6.2
               6.2
            
            
               
                  ncurses-libs
               
               6.2
               6.2
            
            
               
                  npth
               
               1.6
               1.6
            
            
               
                  openssl-libs
               
               3.0.8
               3.0.8
            
            
               
                  p11-kit
               
               0.24.1
               0.24.1
            
            
               
                  p11-kit-trust
               
               0.24.1
               0.24.1
            
            
               
                  pcre2
               
               10.40
               10.40
            
            
               
                  pcre2-syntax
               
               10.40
               10.40
            
            
               
                  popt
               
               1.18
               1.18
            
            
               
                  publicsuffix-list-dafsa
               
               20240212
               20240212
            
            
               
                  python3
               
               3.9.16
               
            
            
               
                  python3-dnf
               
               4.14.0
               
            
            
               
                  python3-gpg
               
               1.15.1
               
            
            
               
                  python3-hawkey
               
               0.69.0
               
            
            
               
                  python3-libcomps
               
               0.1.20
               
            
            
               
                  python3-libdnf
               
               0.69.0
               
            
            
               
                  python3-libs
               
               3.9.16
               
            
            
               
                  python3-pip-wheel
               
               21.3.1
               
            
            
               
                  python3-rpm
               
               4.16.1.3
               
            
            
               
                  python3-setuptools-wheel
               
               59.6.0
               
            
            
               
                  readline
               
               8.1
               8.1
            
            
               
                  rpm
               
               4.16.1.3
               4.16.1.3
            
            
               
                  rpm-build-libs
               
               4.16.1.3
               
            
            
               
                  rpm-libs
               
               4.16.1.3
               4.16.1.3
            
            
               
                  rpm-sign-libs
               
               4.16.1.3
               
            
            
               
                  sed
               
               4.8
               4.8
            
            
               
                  setup
               
               2.13.7
               2.13.7
            
            
               
                  sqlite-libs
               
               3.40.0
               3.40.0
            
            
               
                  system-release
               
               2023.6.20241031
               2023.6.20241031
            
            
               
                  tzdata
               
               2024a
               
            
            
               
                  xz-libs
               
               5.2.5
               5.2.5
            
            
               
                  yum
               
               4.14.0
               
            
            
               
                  zlib
               
               1.2.11
               1.2.11
            
         Document ConventionsBuilding bare-bones AL2023 container imagesAL2023 Minimal AMI compared to container imagesDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideAWS base images for Node.jsUsing an AWS base imageUsing a non-AWS base imageDeploy Node.js Lambda functions with container imagesThere are three ways to build a container image for a Node.js Lambda function:
     
	 
     
  
      Using an AWS base image for Node.js
      The AWS base images are preloaded with a language runtime, a runtime interface client to manage the interaction between Lambda and your function code, and a runtime interface emulator for local testing.
    
      Using an AWS OS-only base image
      AWS OS-only base images contain an Amazon Linux distribution and the runtime interface emulator. These images are commonly used to create container images for compiled languages, such as Go and Rust, and for a language or language version that Lambda doesn't provide a base image for, such as Node.js 19. You can also use OS-only base images to implement a custom runtime. To make the image compatible with Lambda, you must include the runtime interface client for Node.js in the image.
    
      Using a non-AWS base image
      You can use an alternative base image from another container registry, such as Alpine Linux or Debian. You can also use a custom image created by your organization. To make the image compatible with Lambda, you must include the runtime interface client for Node.js in the image.
    TipTo reduce the time it takes for Lambda container functions to become active, see Use multi-stage builds in the Docker documentation. To build efficient container images, follow the Best practices for writing Dockerfiles.This page explains how to build, test, and deploy container images for Lambda.TopicsAWS base images for Node.jsUsing an AWS base image for Node.jsUsing an alternative base image with the runtime interface client
    AWS base images for Node.js
    AWS provides the following base images for Node.js:
      
    
    
          
            Tags
            Runtime
            Operating system
            Dockerfile
            Deprecation
          
        
      
            22
            Node.js 22
            Amazon Linux 2023
            Dockerfile
                for Node.js 22 on GitHub
            
                          Apr 30, 2027
            
              
          
      
            20
            Node.js 20
            Amazon Linux 2023
            Dockerfile
                for Node.js 20 on GitHub
            
                          Apr 30, 2026
            
              
          
      
            18
            Node.js 18
            Amazon Linux 2
            Dockerfile
                for Node.js 18 on GitHub
            
                          Sep 1, 2025
            
              
          
    

    Amazon ECR repository: gallery.ecr.aws/lambda/nodejs
    The Node.js 20 and later base images are based on the Amazon Linux 2023 minimal container image. Earlier base
      images use Amazon Linux 2. AL2023 provides several advantages over Amazon Linux 2, including a smaller deployment footprint
      and updated versions of libraries such as glibc.
    AL2023-based images use microdnf (symlinked as dnf) as the package manager instead of yum, which is the default package manager in Amazon Linux 2. microdnf is a standalone implementation of dnf. For a list of packages that are included in AL2023-based images, refer to the Minimal Container columns in Comparing packages installed on Amazon Linux 2023 Container Images. For more information about the differences between AL2023 and Amazon Linux 2, see Introducing the Amazon Linux 2023 runtime for AWS Lambda on the AWS
      Compute Blog.    
    NoteTo run AL2023-based images locally, including with AWS Serverless Application Model (AWS SAM), you must use Docker version 20.10.10 or later.  
   
    Using an AWS base image for Node.js
    To complete the steps in this section, you must have the following:
           
           
           
           
        
            AWS CLI version 2
          
            Docker (minimum version 25.0.0)
          
            The Docker buildx plugin.
          
              Node.js
          To create a container image from an AWS base image for Node.js
        Create a directory for the project, and then switch to that directory.
        mkdir example
cd example
      
        Create a new Node.js project with npm. To accept the default options provided in the interactive experience, press Enter.
        npm init
      
        Create a new file called index.js. You can add the following sample function code to the file for testing, or use your own.
        Example  CommonJS handlerexports.handler = async (event) => {
    const response = {
        statusCode: 200,
        body: JSON.stringify('Hello from Lambda!'),
    };
    return response;
};
      
        If your function depends on libraries other than the AWS SDK for JavaScript, use npm to add them to your package.
      
        Create a new Dockerfile with the following configuration:
        
           
           
           
        
            Set the FROM property to the URI of the base image.
          
            Use the COPY command to copy the function code and runtime dependencies to {LAMBDA_TASK_ROOT}, a Lambda-defined environment variable.
          
            Set the CMD argument to the Lambda function handler.
          
        Note that the example Dockerfile does not include a USER instruction. When you deploy a container image to Lambda, Lambda automatically defines a default Linux user with least-privileged permissions. This is different from standard Docker behavior which defaults to the root user when no USER instruction is provided.
        Example  DockerfileFROM public.ecr.aws/lambda/nodejs:22

# Copy function code
COPY index.js ${LAMBDA_TASK_ROOT}
  
# Set the CMD to your handler (could also be done as a parameter override outside of the Dockerfile)
CMD [ "index.handler" ]
      
        Build the Docker image with the docker build command. The
          following example names the image docker-image and gives it the test tag. To make your 
          image compatible with Lambda, you must use the --provenance=false option.
        docker buildx build --platform linux/amd64 --provenance=false -t docker-image:test .
        NoteThe command specifies the --platform linux/amd64 option to ensure that your container is compatible with the Lambda execution environment regardless of the  
       architecture of your build machine. If you intend to create a Lambda function using the ARM64 instruction set architecture, be sure to change the command to use the --platform linux/arm64 
       option instead.
      
          Start the Docker image with the docker run command. In this example,
              docker-image is the image name and test is the tag.
          docker run --platform linux/amd64 -p 9000:8080 docker-image:test
          This command runs the image as a container and creates a local endpoint at
            localhost:9000/2015-03-31/functions/function/invocations.
          NoteIf you built the Docker image for the ARM64 instruction set architecture, be sure to use the --platform linux/arm64 option instead of --platform linux/amd64. 
        
          From a new terminal window, post an event to the local endpoint.
          
            Linux/macOS
      		      In Linux and macOS, run the following curl command:
                curl "http://localhost:9000/2015-03-31/functions/function/invocations" -d '{}'
                This command invokes the function with an empty event and returns a response. If you're using your own function code rather than the sample function code, you might want to invoke the function with a JSON payload. Example:
                curl "http://localhost:9000/2015-03-31/functions/function/invocations" -d '{"payload":"hello world!"}'
      		
            PowerShell
                In PowerShell, run the following Invoke-WebRequest command:
                Invoke-WebRequest -Uri "http://localhost:9000/2015-03-31/functions/function/invocations" -Method Post -Body '{}' -ContentType "application/json"
                This command invokes the function with an empty event and returns a response. If you're using your own function code rather than the sample function code, you might want to invoke the function with a JSON payload. Example:
                Invoke-WebRequest -Uri "http://localhost:9000/2015-03-31/functions/function/invocations" -Method Post -Body '{"payload":"hello world!"}' -ContentType "application/json"
              
          
        
          Get the container ID.
          docker ps
        
          Use the docker kill command to stop the container. In this command, replace 3766c4ab331c with the container ID from the previous step.
          docker kill 3766c4ab331c
        To upload the image to Amazon ECR and create the Lambda function
          Run the get-login-password command to authenticate the Docker CLI to your Amazon ECR registry.
        
         
         
        
          Set the --region value to the AWS Region where you want to create the Amazon ECR repository.
        
          Replace 111122223333 with your AWS account ID.
        
          aws ecr get-login-password --region us-east-1 | docker login --username AWS --password-stdin 111122223333.dkr.ecr.us-east-1.amazonaws.com
          
        
        Create a repository in Amazon ECR using the create-repository command.
        aws ecr create-repository --repository-name hello-world --region us-east-1 --image-scanning-configuration scanOnPush=true --image-tag-mutability MUTABLE
        
        NoteThe Amazon ECR repository must be in the same AWS Region as the Lambda function.
        If successful, you see a response like this:
        {
    "repository": {
        "repositoryArn": "arn:aws:ecr:us-east-1:111122223333:repository/hello-world",
        "registryId": "111122223333",
        "repositoryName": "hello-world",
        "repositoryUri": "111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world",
        "createdAt": "2023-03-09T10:39:01+00:00",
        "imageTagMutability": "MUTABLE",
        "imageScanningConfiguration": {
            "scanOnPush": true
        },
        "encryptionConfiguration": {
            "encryptionType": "AES256"
        }
    }
}
        
      
        Copy the repositoryUri from the output in the previous step.
      
        Run the docker tag command to tag your local image into your Amazon ECR repository as the latest version. In this command: 
        
         
         
        
          docker-image:test is the name and tag of your Docker image. This is the image name and tag that you specified in the docker build command.
        
          Replace <ECRrepositoryUri> with the repositoryUri that you copied. Make sure to include :latest at the end of the URI.
        
        docker tag docker-image:test <ECRrepositoryUri>:latest
      Example:
      docker tag docker-image:test 111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest
      
      
      Run the docker push command to deploy your local image to the Amazon ECR repository. Make sure to include :latest at the end of the repository URI.
docker push 111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest

      
      Create an execution role for the function, if you don't already have one. You need the Amazon Resource Name (ARN) of the role in the next step.
      
        Create the Lambda function. For ImageUri, specify the repository URI from earlier. Make sure to include :latest at the end of the URI.
		aws lambda create-function \
  --function-name hello-world \
  --package-type Image \
  --code ImageUri=111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest \
  --role arn:aws:iam::111122223333:role/lambda-ex
  		
      NoteYou can create a function using an image in a different AWS account, as long as the image is in the same Region as the Lambda function. For more information, see  Amazon ECR cross-account permissions.  
      
      Invoke the function.
      aws lambda invoke --function-name hello-world response.json
      You should see a response like this:
{
  "ExecutedVersion": "$LATEST", 
  "StatusCode": 200
}
    
    To see the output of the function, check the response.json file.
    To update the function code, you must build the image again, upload the new image to the Amazon ECR repository, and then use the update-function-code command to deploy the image to the Lambda function.Lambda resolves the image tag to a specific image digest. This means that if you point the image tag that was used to deploy the function to a new image in Amazon ECR, Lambda doesn't automatically update the function to use the new image.To deploy the new image to the same Lambda function, you must use the update-function-code command, even if the image tag in Amazon ECR remains the same. In the following example, the --publish option creates a new version of the function using the updated container image.aws lambda update-function-code \
  --function-name hello-world \
  --image-uri 111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest \
  --publish
 
    Using an alternative base image with the runtime interface client
    If you use an OS-only base image or an alternative base image, you must include the runtime interface client in your image. The runtime interface client extends the Runtime API, which manages the interaction between Lambda and your function code.
    Install the Node.js runtime interface client using the npm package manager:
    npm install aws-lambda-ric
    You can also download the Node.js runtime interface client from GitHub. 
    The following example demonstrates how to build a container image for Node.js using a non-AWS base image. The example Dockerfile uses a buster base image. The Dockerfile includes the runtime interface client.
        To complete the steps in this section, you must have the following:
           
           
           
           
        
            AWS CLI version 2
          
            Docker (minimum version 25.0.0)
          
            The Docker buildx plugin.
          
              Node.js
          To create a container image from a non-AWS base image
        Create a directory for the project, and then switch to that directory.
        mkdir example
cd example
      
        Create a new Node.js project with npm. To accept the default options provided in the interactive experience, press Enter.
        npm init
      
        Create a new file called index.js. You can add the following sample function code to the file for testing, or use your own.
        Example  CommonJS handlerexports.handler = async (event) => {
    const response = {
        statusCode: 200,
        body: JSON.stringify('Hello from Lambda!'),
    };
    return response;
};
      
        Create a new Dockerfile. The following Dockerfile uses a buster base image instead of an AWS base image. The Dockerfile includes the runtime interface client, which makes the image compatible with Lambda. The Dockerfile uses a multi-stage build. The first stage creates a build image, which is a standard Node.js environment where the function's dependencies are installed. The second stage creates a slimmer image which includes the function code and its dependencies. This reduces the final image size.
        
           
           
          
           
        
            Set the FROM property to the base image identifier.
          
            Use the COPY command to copy the function code and runtime dependencies.
          
            Set the ENTRYPOINT to the module that you want the Docker container to run when it starts. In this case, the module is the runtime interface client.
          
            Set the CMD argument to the Lambda function handler.
          
        Note that the example Dockerfile does not include a USER instruction. When you deploy a container image to Lambda, Lambda automatically defines a default Linux user with least-privileged permissions. This is different from standard Docker behavior which defaults to the root user when no USER instruction is provided.
        Example  Dockerfile# Define custom function directory
ARG FUNCTION_DIR="/function"

FROM node:20-buster as build-image

# Include global arg in this stage of the build
ARG FUNCTION_DIR

# Install build dependencies
RUN apt-get update && \
    apt-get install -y \
    g++ \
    make \
    cmake \
    unzip \
    libcurl4-openssl-dev

# Copy function code
RUN mkdir -p ${FUNCTION_DIR}
COPY . ${FUNCTION_DIR}

WORKDIR ${FUNCTION_DIR}

# Install Node.js dependencies
RUN npm install

# Install the runtime interface client
RUN npm install aws-lambda-ric

# Grab a fresh slim copy of the image to reduce the final size
FROM node:20-buster-slim

# Required for Node runtimes which use npm@8.6.0+ because
# by default npm writes logs under /home/.npm and Lambda fs is read-only
ENV NPM_CONFIG_CACHE=/tmp/.npm

# Include global arg in this stage of the build
ARG FUNCTION_DIR

# Set working directory to function root directory
WORKDIR ${FUNCTION_DIR}

# Copy in the built dependencies
COPY --from=build-image ${FUNCTION_DIR} ${FUNCTION_DIR}

# Set runtime interface client as default command for the container runtime
ENTRYPOINT ["/usr/local/bin/npx", "aws-lambda-ric"]
# Pass the name of the function handler as an argument to the runtime
CMD ["index.handler"]
      
        Build the Docker image with the docker build command. The
          following example names the image docker-image and gives it the test tag. To make your 
          image compatible with Lambda, you must use the --provenance=false option.
        docker buildx build --platform linux/amd64 --provenance=false -t docker-image:test .
        NoteThe command specifies the --platform linux/amd64 option to ensure that your container is compatible with the Lambda execution environment regardless of the  
       architecture of your build machine. If you intend to create a Lambda function using the ARM64 instruction set architecture, be sure to change the command to use the --platform linux/arm64 
       option instead.
      Use the runtime interface emulator to locally test the image. You can build the emulator into your image or use the following procedure to install it on your local machine.To install and run the runtime interface emulator on your local machine
          From your project directory, run the following command to download the runtime interface emulator (x86-64 architecture) from GitHub and install it on your local machine.
          
            Linux/macOS
          mkdir -p ~/.aws-lambda-rie && \
    curl -Lo ~/.aws-lambda-rie/aws-lambda-rie https://github.com/aws/aws-lambda-runtime-interface-emulator/releases/latest/download/aws-lambda-rie && \
    chmod +x ~/.aws-lambda-rie/aws-lambda-rie
      			  To install the arm64 emulator, replace the GitHub repository URL in the previous command with the following:
      			https://github.com/aws/aws-lambda-runtime-interface-emulator/releases/latest/download/aws-lambda-rie-arm64
      		
            PowerShell
      				  $dirPath = "$HOME\.aws-lambda-rie"
if (-not (Test-Path $dirPath)) {
    New-Item -Path $dirPath -ItemType Directory
}
      
$downloadLink = "https://github.com/aws/aws-lambda-runtime-interface-emulator/releases/latest/download/aws-lambda-rie"
$destinationPath = "$HOME\.aws-lambda-rie\aws-lambda-rie"
Invoke-WebRequest -Uri $downloadLink -OutFile $destinationPath
      				  To install the arm64 emulator, replace the $downloadLink with the following:
      				https://github.com/aws/aws-lambda-runtime-interface-emulator/releases/latest/download/aws-lambda-rie-arm64
              
          
        
          Start the Docker image with the docker run command. Note the following:
          
             
             
          
            docker-image is the image name and test is the tag.
            
            /usr/local/bin/npx aws-lambda-ric index.handler is the ENTRYPOINT followed by the CMD from your Dockerfile.
            
          
            Linux/macOS
				    docker run --platform linux/amd64 -d -v ~/.aws-lambda-rie:/aws-lambda -p 9000:8080 \
    --entrypoint /aws-lambda/aws-lambda-rie \
    docker-image:test \
        /usr/local/bin/npx aws-lambda-ric index.handler
      		
            PowerShell
				        docker run --platform linux/amd64 -d -v "$HOME\.aws-lambda-rie:/aws-lambda" -p 9000:8080 `
--entrypoint /aws-lambda/aws-lambda-rie `
docker-image:test `
    /usr/local/bin/npx aws-lambda-ric index.handler
				    
          
          This command runs the image as a container and creates a local endpoint at
            localhost:9000/2015-03-31/functions/function/invocations.
         NoteIf you built the Docker image for the ARM64 instruction set architecture, be sure to use the --platform linux/arm64 option instead of --platform linux/amd64.   
        
          Post an event to the local endpoint.
          
            Linux/macOS
      		      In Linux and macOS, run the following curl command:
                curl "http://localhost:9000/2015-03-31/functions/function/invocations" -d '{}'
                This command invokes the function with an empty event and returns a response. If you're using your own function code rather than the sample function code, you might want to invoke the function with a JSON payload. Example:
                curl "http://localhost:9000/2015-03-31/functions/function/invocations" -d '{"payload":"hello world!"}'
      		
            PowerShell
                In PowerShell, run the following Invoke-WebRequest command:
                Invoke-WebRequest -Uri "http://localhost:9000/2015-03-31/functions/function/invocations" -Method Post -Body '{}' -ContentType "application/json"
                This command invokes the function with an empty event and returns a response. If you're using your own function code rather than the sample function code, you might want to invoke the function with a JSON payload. Example:
                Invoke-WebRequest -Uri "http://localhost:9000/2015-03-31/functions/function/invocations" -Method Post -Body '{"payload":"hello world!"}' -ContentType "application/json"
              
          
        
          Get the container ID.
          docker ps
        
          Use the docker kill command to stop the container. In this command, replace 3766c4ab331c with the container ID from the previous step.
          docker kill 3766c4ab331c
        To upload the image to Amazon ECR and create the Lambda function
          Run the get-login-password command to authenticate the Docker CLI to your Amazon ECR registry.
        
         
         
        
          Set the --region value to the AWS Region where you want to create the Amazon ECR repository.
        
          Replace 111122223333 with your AWS account ID.
        
          aws ecr get-login-password --region us-east-1 | docker login --username AWS --password-stdin 111122223333.dkr.ecr.us-east-1.amazonaws.com
          
        
        Create a repository in Amazon ECR using the create-repository command.
        aws ecr create-repository --repository-name hello-world --region us-east-1 --image-scanning-configuration scanOnPush=true --image-tag-mutability MUTABLE
        
        NoteThe Amazon ECR repository must be in the same AWS Region as the Lambda function.
        If successful, you see a response like this:
        {
    "repository": {
        "repositoryArn": "arn:aws:ecr:us-east-1:111122223333:repository/hello-world",
        "registryId": "111122223333",
        "repositoryName": "hello-world",
        "repositoryUri": "111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world",
        "createdAt": "2023-03-09T10:39:01+00:00",
        "imageTagMutability": "MUTABLE",
        "imageScanningConfiguration": {
            "scanOnPush": true
        },
        "encryptionConfiguration": {
            "encryptionType": "AES256"
        }
    }
}
        
      
        Copy the repositoryUri from the output in the previous step.
      
        Run the docker tag command to tag your local image into your Amazon ECR repository as the latest version. In this command: 
        
         
         
        
          docker-image:test is the name and tag of your Docker image. This is the image name and tag that you specified in the docker build command.
        
          Replace <ECRrepositoryUri> with the repositoryUri that you copied. Make sure to include :latest at the end of the URI.
        
        docker tag docker-image:test <ECRrepositoryUri>:latest
      Example:
      docker tag docker-image:test 111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest
      
      
      Run the docker push command to deploy your local image to the Amazon ECR repository. Make sure to include :latest at the end of the repository URI.
docker push 111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest

      
      Create an execution role for the function, if you don't already have one. You need the Amazon Resource Name (ARN) of the role in the next step.
      
        Create the Lambda function. For ImageUri, specify the repository URI from earlier. Make sure to include :latest at the end of the URI.
		aws lambda create-function \
  --function-name hello-world \
  --package-type Image \
  --code ImageUri=111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest \
  --role arn:aws:iam::111122223333:role/lambda-ex
  		
      NoteYou can create a function using an image in a different AWS account, as long as the image is in the same Region as the Lambda function. For more information, see  Amazon ECR cross-account permissions.  
      
      Invoke the function.
      aws lambda invoke --function-name hello-world response.json
      You should see a response like this:
{
  "ExecutedVersion": "$LATEST", 
  "StatusCode": 200
}
    
    To see the output of the function, check the response.json file.
    To update the function code, you must build the image again, upload the new image to the Amazon ECR repository, and then use the update-function-code command to deploy the image to the Lambda function.Lambda resolves the image tag to a specific image digest. This means that if you point the image tag that was used to deploy the function to a new image in Amazon ECR, Lambda doesn't automatically update the function to use the new image.To deploy the new image to the same Lambda function, you must use the update-function-code command, even if the image tag in Amazon ECR remains the same. In the following example, the --publish option creates a new version of the function using the updated container image.aws lambda update-function-code \
  --function-name hello-world \
  --image-uri 111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest \
  --publish
  Document ConventionsDeploy .zip file archivesLayersDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideUsing a Node.js base image to build and package TypeScript function codeDeploy transpiled TypeScript code in Lambda with container imagesYou can deploy your TypeScript code to an AWS Lambda function as a Node.js container image. AWS provides base images for Node.js to help you build the container image. These base images are preloaded with a language runtime and other components that are required to run the image on Lambda. AWS provides a Dockerfile for each of the base images to help with building your container image.If you use a community or private enterprise base image, you must add the Node.js runtime interface client (RIC) to the base image to make it compatible with Lambda.Lambda provides a runtime interface emulator for local testing. The AWS base images for Node.js include the runtime interface emulator. If you use an alternative base image, such as an Alpine Linux or Debian image, you can build the emulator into your image or install it on your local machine.
    Using a Node.js base image to build and package TypeScript function code
    To complete the steps in this section, you must have the following:
           
           
           
           
        
            AWS CLI version 2
          
            Docker (minimum version 25.0.0)
          
            The Docker buildx plugin.
          
              Node.js 22.x
          To create an image from an AWS base image for Lambda
        On your local machine, create a project directory for your new function.
      
        Create a new Node.js project with npm or a package manager of your choice.
        npm init
      
        Add the @types/aws-lambda and esbuild packages as development dependencies. The @types/aws-lambda package contains the type definitions for Lambda.
        npm install -D @types/aws-lambda esbuild
      
        Add a build script to the package.json file.
  "scripts": {
  "build": "esbuild index.ts --bundle --minify --sourcemap --platform=node --target=es2020 --outfile=dist/index.js"
}
      
        Create a new file called index.ts. Add the following sample code to the new file. This is the code for the Lambda function. The function returns a hello world message.
        NoteThe import statement imports the type definitions from @types/aws-lambda. It does not import the aws-lambda NPM package, which is an unrelated third-party tool. For more information, see aws-lambda in the DefinitelyTyped GitHub repository.
import { Context, APIGatewayProxyResult, APIGatewayEvent } from 'aws-lambda';

export const handler = async (event: APIGatewayEvent, context: Context): Promise<APIGatewayProxyResult> => {
    console.log(`Event: ${JSON.stringify(event, null, 2)}`);
    console.log(`Context: ${JSON.stringify(context, null, 2)}`);
    return {
        statusCode: 200,
        body: JSON.stringify({
            message: 'hello world',
        }),
    };
};
      
        Create a new Dockerfile with the following configuration:
        
           
           
        
            Set the FROM property to the URI of the base image.
          
            Set the CMD argument to specify the Lambda function handler.
          
        The following example Dockerfile uses a multi-stage build. The first step transpiles the TypeScript code into JavaScript. The second step produces a container image that contains only JavaScript files and production dependencies.
        Note that the example Dockerfile does not include a USER instruction. When you deploy a container image to Lambda, Lambda automatically defines a default Linux user with least-privileged permissions. This is different from standard Docker behavior which defaults to the root user when no USER instruction is provided.
        Example  DockerfileFROM public.ecr.aws/lambda/nodejs:22 as builder
WORKDIR /usr/app
COPY package.json index.ts  ./
RUN npm install
RUN npm run build
    
FROM public.ecr.aws/lambda/nodejs:22
WORKDIR ${LAMBDA_TASK_ROOT}
COPY --from=builder /usr/app/dist/* ./
CMD ["index.handler"]
      
        Build the Docker image with the docker build command. The
          following example names the image docker-image and gives it the test tag. To make your 
          image compatible with Lambda, you must use the --provenance=false option.
        docker buildx build --platform linux/amd64 --provenance=false -t docker-image:test .
        NoteThe command specifies the --platform linux/amd64 option to ensure that your container is compatible with the Lambda execution environment regardless of the  
       architecture of your build machine. If you intend to create a Lambda function using the ARM64 instruction set architecture, be sure to change the command to use the --platform linux/arm64 
       option instead.
      
          Start the Docker image with the docker run command. In this example,
              docker-image is the image name and test is the tag.
          docker run --platform linux/amd64 -p 9000:8080 docker-image:test
          This command runs the image as a container and creates a local endpoint at
            localhost:9000/2015-03-31/functions/function/invocations.
          NoteIf you built the Docker image for the ARM64 instruction set architecture, be sure to use the --platform linux/arm64 option instead of --platform linux/amd64. 
        
          From a new terminal window, post an event to the local endpoint.
          
            Linux/macOS
      		      In Linux and macOS, run the following curl command:
                curl "http://localhost:9000/2015-03-31/functions/function/invocations" -d '{}'
                This command invokes the function with an empty event and returns a response. If you're using your own function code rather than the sample function code, you might want to invoke the function with a JSON payload. Example:
                curl "http://localhost:9000/2015-03-31/functions/function/invocations" -d '{"payload":"hello world!"}'
      		
            PowerShell
                In PowerShell, run the following Invoke-WebRequest command:
                Invoke-WebRequest -Uri "http://localhost:9000/2015-03-31/functions/function/invocations" -Method Post -Body '{}' -ContentType "application/json"
                This command invokes the function with an empty event and returns a response. If you're using your own function code rather than the sample function code, you might want to invoke the function with a JSON payload. Example:
                Invoke-WebRequest -Uri "http://localhost:9000/2015-03-31/functions/function/invocations" -Method Post -Body '{"payload":"hello world!"}' -ContentType "application/json"
              
          
        
          Get the container ID.
          docker ps
        
          Use the docker kill command to stop the container. In this command, replace 3766c4ab331c with the container ID from the previous step.
          docker kill 3766c4ab331c
        To upload the image to Amazon ECR and create the Lambda function
          Run the get-login-password command to authenticate the Docker CLI to your Amazon ECR registry.
        
         
         
        
          Set the --region value to the AWS Region where you want to create the Amazon ECR repository.
        
          Replace 111122223333 with your AWS account ID.
        
          aws ecr get-login-password --region us-east-1 | docker login --username AWS --password-stdin 111122223333.dkr.ecr.us-east-1.amazonaws.com
          
        
        Create a repository in Amazon ECR using the create-repository command.
        aws ecr create-repository --repository-name hello-world --region us-east-1 --image-scanning-configuration scanOnPush=true --image-tag-mutability MUTABLE
        
        NoteThe Amazon ECR repository must be in the same AWS Region as the Lambda function.
        If successful, you see a response like this:
        {
    "repository": {
        "repositoryArn": "arn:aws:ecr:us-east-1:111122223333:repository/hello-world",
        "registryId": "111122223333",
        "repositoryName": "hello-world",
        "repositoryUri": "111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world",
        "createdAt": "2023-03-09T10:39:01+00:00",
        "imageTagMutability": "MUTABLE",
        "imageScanningConfiguration": {
            "scanOnPush": true
        },
        "encryptionConfiguration": {
            "encryptionType": "AES256"
        }
    }
}
        
      
        Copy the repositoryUri from the output in the previous step.
      
        Run the docker tag command to tag your local image into your Amazon ECR repository as the latest version. In this command: 
        
         
         
        
          docker-image:test is the name and tag of your Docker image. This is the image name and tag that you specified in the docker build command.
        
          Replace <ECRrepositoryUri> with the repositoryUri that you copied. Make sure to include :latest at the end of the URI.
        
        docker tag docker-image:test <ECRrepositoryUri>:latest
      Example:
      docker tag docker-image:test 111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest
      
      
      Run the docker push command to deploy your local image to the Amazon ECR repository. Make sure to include :latest at the end of the repository URI.
docker push 111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest

      
      Create an execution role for the function, if you don't already have one. You need the Amazon Resource Name (ARN) of the role in the next step.
      
        Create the Lambda function. For ImageUri, specify the repository URI from earlier. Make sure to include :latest at the end of the URI.
		aws lambda create-function \
  --function-name hello-world \
  --package-type Image \
  --code ImageUri=111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest \
  --role arn:aws:iam::111122223333:role/lambda-ex
  		
      NoteYou can create a function using an image in a different AWS account, as long as the image is in the same Region as the Lambda function. For more information, see  Amazon ECR cross-account permissions.  
      
      Invoke the function.
      aws lambda invoke --function-name hello-world response.json
      You should see a response like this:
{
  "ExecutedVersion": "$LATEST", 
  "StatusCode": 200
}
    
    To see the output of the function, check the response.json file.
    To update the function code, you must build the image again, upload the new image to the Amazon ECR repository, and then use the update-function-code command to deploy the image to the Lambda function.Lambda resolves the image tag to a specific image digest. This means that if you point the image tag that was used to deploy the function to a new image in Amazon ECR, Lambda doesn't automatically update the function to use the new image.To deploy the new image to the same Lambda function, you must use the update-function-code command, even if the image tag in Amazon ECR remains the same. In the following example, the --publish option creates a new version of the function using the updated container image.aws lambda update-function-code \
  --function-name hello-world \
  --image-uri 111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest \
  --publish
Document ConventionsDeploy .zip file archivesLayersDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideAWS base images for PythonUsing an AWS base imageUsing a non-AWS base imageDeploy Python Lambda functions with container imagesThere are three ways to build a container image for a Python Lambda function:
     
	 
     
  
      Using an AWS base image for Python
      The AWS base images are preloaded with a language runtime, a runtime interface client to manage the interaction between Lambda and your function code, and a runtime interface emulator for local testing.
    
      Using an AWS OS-only base image
      AWS OS-only base images contain an Amazon Linux distribution and the runtime interface emulator. These images are commonly used to create container images for compiled languages, such as Go and Rust, and for a language or language version that Lambda doesn't provide a base image for, such as Node.js 19. You can also use OS-only base images to implement a custom runtime. To make the image compatible with Lambda, you must include the runtime interface client for Python in the image.
    
      Using a non-AWS base image
      You can use an alternative base image from another container registry, such as Alpine Linux or Debian. You can also use a custom image created by your organization. To make the image compatible with Lambda, you must include the runtime interface client for Python in the image.
    TipTo reduce the time it takes for Lambda container functions to become active, see Use multi-stage builds in the Docker documentation. To build efficient container images, follow the Best practices for writing Dockerfiles.This page explains how to build, test, and deploy container images for Lambda.TopicsAWS base images for PythonUsing an AWS base image for PythonUsing an alternative base image with the runtime interface client
    AWS base images for Python
    AWS provides the following base images for Python:
    
    
    
          
            Tags
            Runtime
            Operating system
            Dockerfile
            Deprecation
          
        
      
            3.13
            Python 3.13
            Amazon Linux 2023
            Dockerfile
                for Python 3.13 on GitHub
            
                          Jun 30, 2029
            
              
          
      
            3.12
            Python 3.12
            Amazon Linux 2023
            Dockerfile
                for Python 3.12 on GitHub
            
                          Oct 31, 2028
            
              
          
      
            3.11
            Python 3.11
            Amazon Linux 2
            Dockerfile
                for Python 3.11 on GitHub
            
                          Jun 30, 2026
            
              
          
      
            3.10
            Python 3.10
            Amazon Linux 2
            Dockerfile
                for Python 3.10 on GitHub
            
                          Jun 30, 2026
            
              
          
      
            3.9
            Python 3.9
            Amazon Linux 2
            Dockerfile
                for Python 3.9 on GitHub
            
                          Nov 3, 2025
            
              
          
     
    Amazon ECR repository: gallery.ecr.aws/lambda/python
    Python 3.12 and later base images are based on the Amazon Linux 2023 minimal container image. The Python 3.8-3.11 base images are based on the Amazon Linux 2 image. AL2023-based images provide several advantages over Amazon Linux 2, including a smaller deployment footprint and updated versions of libraries such as glibc.
    AL2023-based images use microdnf (symlinked as dnf) as the package manager instead of yum, which is the default package manager in Amazon Linux 2. microdnf is a standalone implementation of dnf. For a list of packages that are included in AL2023-based images, refer to the Minimal Container columns in Comparing packages installed on Amazon Linux 2023 Container Images. For more information about the differences between AL2023 and Amazon Linux 2, see Introducing the Amazon Linux 2023 runtime for AWS Lambda on the AWS
      Compute Blog.    
    NoteTo run AL2023-based images locally, including with AWS Serverless Application Model (AWS SAM), you must use Docker version 20.10.10 or later.
     
      Dependency search path in the base images
      When you use an import statement in your code, the Python runtime searches the directories in its search path until it finds the module or package. By default, the runtime searches the {LAMBDA_TASK_ROOT} directory first. If you include a version of a runtime-included library in your image, your version will take precedence over the version that's included in the runtime.
      Other steps in the search path depend on which version of the Lambda base image for Python you're
        using:
      
         
         
      
          Python 3.11 and later: Runtime-included libraries and pip-installed libraries are installed in the /var/lang/lib/python3.11/site-packages directory. This directory has precedence over /var/runtime in the search path. You can override the SDK by using pip to install a newer version. You can use pip to verify that the runtime-included SDK and its dependencies are compatible with any packages that you install.
        
          Python 3.8-3.10: Runtime-included libraries are installed in the /var/runtime directory. Pip-installed libraries are installed in the /var/lang/lib/python3.x/site-packages directory. The /var/runtime directory has precedence over /var/lang/lib/python3.x/site-packages in the search path.
        
      You can see the full search path for your Lambda function by adding the following code snippet.
      import sys
      
search_path = sys.path
print(search_path)
      
   
    Using an AWS base image for Python
    To complete the steps in this section, you must have the following:
          
           
           
           
        
            AWS CLI version 2
          
            Docker (minimum version 25.0.0)
          
            The Docker buildx plugin.
          
              Python
          To create a container image from an AWS base image for Python
        Create a directory for the project, and then switch to that directory.
        mkdir example
cd example
      
        Create a new file called lambda_function.py. You can add the following sample function code to the file for testing, or use your own.
        Example  Python functionimport sys
def handler(event, context):
    return 'Hello from AWS Lambda using Python' + sys.version + '!'
      
        Create a new file called requirements.txt. If you're using the sample function code from the previous step, you can leave the file empty because there are no dependencies. Otherwise, list each required library. For example, here's what your requirements.txt should look like if your function uses the AWS SDK for Python (Boto3):
		Example  requirements.txtboto3
      
        Create a new Dockerfile with the following configuration:
        
           
           
           
        
            Set the FROM property to the URI of the base image.
          
            Use the COPY command to copy the function code and runtime dependencies to {LAMBDA_TASK_ROOT}, a Lambda-defined environment variable.
          
            Set the CMD argument to the Lambda function handler.
          
        Note that the example Dockerfile does not include a USER instruction. When you deploy a container image to Lambda, Lambda automatically defines a default Linux user with least-privileged permissions. This is different from standard Docker behavior which defaults to the root user when no USER instruction is provided.
        Example  DockerfileFROM public.ecr.aws/lambda/python:3.12

# Copy requirements.txt
COPY requirements.txt ${LAMBDA_TASK_ROOT}

# Install the specified packages
RUN pip install -r requirements.txt

# Copy function code
COPY lambda_function.py ${LAMBDA_TASK_ROOT}

# Set the CMD to your handler (could also be done as a parameter override outside of the Dockerfile)
CMD [ "lambda_function.handler" ]
      
        Build the Docker image with the docker build command. The
          following example names the image docker-image and gives it the test tag. To make your 
          image compatible with Lambda, you must use the --provenance=false option.
        docker buildx build --platform linux/amd64 --provenance=false -t docker-image:test .
        NoteThe command specifies the --platform linux/amd64 option to ensure that your container is compatible with the Lambda execution environment regardless of the  
       architecture of your build machine. If you intend to create a Lambda function using the ARM64 instruction set architecture, be sure to change the command to use the --platform linux/arm64 
       option instead.
      
          Start the Docker image with the docker run command. In this example,
              docker-image is the image name and test is the tag.
          docker run --platform linux/amd64 -p 9000:8080 docker-image:test
          This command runs the image as a container and creates a local endpoint at
            localhost:9000/2015-03-31/functions/function/invocations.
          NoteIf you built the Docker image for the ARM64 instruction set architecture, be sure to use the --platform linux/arm64 option instead of --platform linux/amd64. 
        
          From a new terminal window, post an event to the local endpoint.
          
            Linux/macOS
      		      In Linux and macOS, run the following curl command:
                curl "http://localhost:9000/2015-03-31/functions/function/invocations" -d '{}'
                This command invokes the function with an empty event and returns a response. If you're using your own function code rather than the sample function code, you might want to invoke the function with a JSON payload. Example:
                curl "http://localhost:9000/2015-03-31/functions/function/invocations" -d '{"payload":"hello world!"}'
      		
            PowerShell
                In PowerShell, run the following Invoke-WebRequest command:
                Invoke-WebRequest -Uri "http://localhost:9000/2015-03-31/functions/function/invocations" -Method Post -Body '{}' -ContentType "application/json"
                This command invokes the function with an empty event and returns a response. If you're using your own function code rather than the sample function code, you might want to invoke the function with a JSON payload. Example:
                Invoke-WebRequest -Uri "http://localhost:9000/2015-03-31/functions/function/invocations" -Method Post -Body '{"payload":"hello world!"}' -ContentType "application/json"
              
          
        
          Get the container ID.
          docker ps
        
          Use the docker kill command to stop the container. In this command, replace 3766c4ab331c with the container ID from the previous step.
          docker kill 3766c4ab331c
        To upload the image to Amazon ECR and create the Lambda function
          Run the get-login-password command to authenticate the Docker CLI to your Amazon ECR registry.
        
         
         
        
          Set the --region value to the AWS Region where you want to create the Amazon ECR repository.
        
          Replace 111122223333 with your AWS account ID.
        
          aws ecr get-login-password --region us-east-1 | docker login --username AWS --password-stdin 111122223333.dkr.ecr.us-east-1.amazonaws.com
          
        
        Create a repository in Amazon ECR using the create-repository command.
        aws ecr create-repository --repository-name hello-world --region us-east-1 --image-scanning-configuration scanOnPush=true --image-tag-mutability MUTABLE
        
        NoteThe Amazon ECR repository must be in the same AWS Region as the Lambda function.
        If successful, you see a response like this:
        {
    "repository": {
        "repositoryArn": "arn:aws:ecr:us-east-1:111122223333:repository/hello-world",
        "registryId": "111122223333",
        "repositoryName": "hello-world",
        "repositoryUri": "111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world",
        "createdAt": "2023-03-09T10:39:01+00:00",
        "imageTagMutability": "MUTABLE",
        "imageScanningConfiguration": {
            "scanOnPush": true
        },
        "encryptionConfiguration": {
            "encryptionType": "AES256"
        }
    }
}
        
      
        Copy the repositoryUri from the output in the previous step.
      
        Run the docker tag command to tag your local image into your Amazon ECR repository as the latest version. In this command: 
        
         
         
        
          docker-image:test is the name and tag of your Docker image. This is the image name and tag that you specified in the docker build command.
        
          Replace <ECRrepositoryUri> with the repositoryUri that you copied. Make sure to include :latest at the end of the URI.
        
        docker tag docker-image:test <ECRrepositoryUri>:latest
      Example:
      docker tag docker-image:test 111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest
      
      
      Run the docker push command to deploy your local image to the Amazon ECR repository. Make sure to include :latest at the end of the repository URI.
docker push 111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest

      
      Create an execution role for the function, if you don't already have one. You need the Amazon Resource Name (ARN) of the role in the next step.
      
        Create the Lambda function. For ImageUri, specify the repository URI from earlier. Make sure to include :latest at the end of the URI.
		aws lambda create-function \
  --function-name hello-world \
  --package-type Image \
  --code ImageUri=111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest \
  --role arn:aws:iam::111122223333:role/lambda-ex
  		
      NoteYou can create a function using an image in a different AWS account, as long as the image is in the same Region as the Lambda function. For more information, see  Amazon ECR cross-account permissions.  
      
      Invoke the function.
      aws lambda invoke --function-name hello-world response.json
      You should see a response like this:
{
  "ExecutedVersion": "$LATEST", 
  "StatusCode": 200
}
    
    To see the output of the function, check the response.json file.
    To update the function code, you must build the image again, upload the new image to the Amazon ECR repository, and then use the update-function-code command to deploy the image to the Lambda function.Lambda resolves the image tag to a specific image digest. This means that if you point the image tag that was used to deploy the function to a new image in Amazon ECR, Lambda doesn't automatically update the function to use the new image.To deploy the new image to the same Lambda function, you must use the update-function-code command, even if the image tag in Amazon ECR remains the same. In the following example, the --publish option creates a new version of the function using the updated container image.aws lambda update-function-code \
  --function-name hello-world \
  --image-uri 111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest \
  --publish 
 
    Using an alternative base image with the runtime interface client
    If you use an OS-only base image or an alternative base image, you must include the runtime interface client in your image. The runtime interface client extends the Runtime API, which manages the interaction between Lambda and your function code.
    Install the the runtime interface client for Python using the pip package manager:
    pip install awslambdaric
    You can also download the Python runtime interface client from GitHub.
    The following example demonstrates how to build a container image for Python using a non-AWS base image. The example Dockerfile uses an official Python base image. The Dockerfile includes the runtime interface client for Python.
    To complete the steps in this section, you must have the following:
          
           
           
           
        
            AWS CLI version 2
          
            Docker (minimum version 25.0.0)
          
            The Docker buildx plugin.
          
              Python
          To create a container image from a non-AWS base image
        Create a directory for the project, and then switch to that directory.
        mkdir example
cd example
      
        Create a new file called lambda_function.py. You can add the following sample function code to the file for testing, or use your own.
        Example  Python functionimport sys
def handler(event, context):
    return 'Hello from AWS Lambda using Python' + sys.version + '!'
      
        Create a new file called requirements.txt. If you're using the sample function code from the previous step, you can leave the file empty because there are no dependencies. Otherwise, list each required library. For example, here's what your requirements.txt should look like if your function uses the AWS SDK for Python (Boto3):
		Example  requirements.txtboto3
      
        Create a new Dockerfile. The following Dockerfile uses an official Python base image instead of an AWS base image. The Dockerfile includes the runtime interface client, which makes the image compatible with Lambda. The following example Dockerfile uses a multi-stage build.
        
           
           
           
        
            Set the FROM property to the base image.
          
            Set the ENTRYPOINT to the module that you want the Docker container to run when it starts. In this case, the module is the runtime interface client.
          
            Set the CMD to the Lambda function handler.
          
        Note that the example Dockerfile does not include a USER instruction. When you deploy a container image to Lambda, Lambda automatically defines a default Linux user with least-privileged permissions. This is different from standard Docker behavior which defaults to the root user when no USER instruction is provided.
        Example  Dockerfile# Define custom function directory
ARG FUNCTION_DIR="/function"

FROM python:3.12 AS build-image

# Include global arg in this stage of the build
ARG FUNCTION_DIR

# Copy function code
RUN mkdir -p ${FUNCTION_DIR}
COPY . ${FUNCTION_DIR}

# Install the function's dependencies
RUN pip install \
    --target ${FUNCTION_DIR} \
        awslambdaric

# Use a slim version of the base Python image to reduce the final image size
FROM python:3.12-slim

# Include global arg in this stage of the build
ARG FUNCTION_DIR
# Set working directory to function root directory
WORKDIR ${FUNCTION_DIR}

# Copy in the built dependencies
COPY --from=build-image ${FUNCTION_DIR} ${FUNCTION_DIR}

# Set runtime interface client as default command for the container runtime
ENTRYPOINT [ "/usr/local/bin/python", "-m", "awslambdaric" ]
# Pass the name of the function handler as an argument to the runtime
CMD [ "lambda_function.handler" ]
      
        Build the Docker image with the docker build command. The
          following example names the image docker-image and gives it the test tag. To make your 
          image compatible with Lambda, you must use the --provenance=false option.
        docker buildx build --platform linux/amd64 --provenance=false -t docker-image:test .
        NoteThe command specifies the --platform linux/amd64 option to ensure that your container is compatible with the Lambda execution environment regardless of the  
       architecture of your build machine. If you intend to create a Lambda function using the ARM64 instruction set architecture, be sure to change the command to use the --platform linux/arm64 
       option instead.
      Use the runtime interface emulator to locally test the image. You can build the emulator into your image or use the following procedure to install it on your local machine.To install and run the runtime interface emulator on your local machine
          From your project directory, run the following command to download the runtime interface emulator (x86-64 architecture) from GitHub and install it on your local machine.
          
            Linux/macOS
          mkdir -p ~/.aws-lambda-rie && \
    curl -Lo ~/.aws-lambda-rie/aws-lambda-rie https://github.com/aws/aws-lambda-runtime-interface-emulator/releases/latest/download/aws-lambda-rie && \
    chmod +x ~/.aws-lambda-rie/aws-lambda-rie
      			  To install the arm64 emulator, replace the GitHub repository URL in the previous command with the following:
      			https://github.com/aws/aws-lambda-runtime-interface-emulator/releases/latest/download/aws-lambda-rie-arm64
      		
            PowerShell
      				  $dirPath = "$HOME\.aws-lambda-rie"
if (-not (Test-Path $dirPath)) {
    New-Item -Path $dirPath -ItemType Directory
}
      
$downloadLink = "https://github.com/aws/aws-lambda-runtime-interface-emulator/releases/latest/download/aws-lambda-rie"
$destinationPath = "$HOME\.aws-lambda-rie\aws-lambda-rie"
Invoke-WebRequest -Uri $downloadLink -OutFile $destinationPath
      				  To install the arm64 emulator, replace the $downloadLink with the following:
      				https://github.com/aws/aws-lambda-runtime-interface-emulator/releases/latest/download/aws-lambda-rie-arm64
              
          
        
          Start the Docker image with the docker run command. Note the following:
          
             
             
          
            docker-image is the image name and test is the tag.
            
            /usr/local/bin/python -m awslambdaric lambda_function.handler is the ENTRYPOINT followed by the CMD from your Dockerfile.
            
          
            Linux/macOS
				    docker run --platform linux/amd64 -d -v ~/.aws-lambda-rie:/aws-lambda -p 9000:8080 \
    --entrypoint /aws-lambda/aws-lambda-rie \
    docker-image:test \
        /usr/local/bin/python -m awslambdaric lambda_function.handler
      		
            PowerShell
				        docker run --platform linux/amd64 -d -v "$HOME\.aws-lambda-rie:/aws-lambda" -p 9000:8080 `
--entrypoint /aws-lambda/aws-lambda-rie `
docker-image:test `
    /usr/local/bin/python -m awslambdaric lambda_function.handler
				    
          
          This command runs the image as a container and creates a local endpoint at
            localhost:9000/2015-03-31/functions/function/invocations.
         NoteIf you built the Docker image for the ARM64 instruction set architecture, be sure to use the --platform linux/arm64 option instead of --platform linux/amd64.   
        
          Post an event to the local endpoint.
          
            Linux/macOS
      		      In Linux and macOS, run the following curl command:
                curl "http://localhost:9000/2015-03-31/functions/function/invocations" -d '{}'
                This command invokes the function with an empty event and returns a response. If you're using your own function code rather than the sample function code, you might want to invoke the function with a JSON payload. Example:
                curl "http://localhost:9000/2015-03-31/functions/function/invocations" -d '{"payload":"hello world!"}'
      		
            PowerShell
                In PowerShell, run the following Invoke-WebRequest command:
                Invoke-WebRequest -Uri "http://localhost:9000/2015-03-31/functions/function/invocations" -Method Post -Body '{}' -ContentType "application/json"
                This command invokes the function with an empty event and returns a response. If you're using your own function code rather than the sample function code, you might want to invoke the function with a JSON payload. Example:
                Invoke-WebRequest -Uri "http://localhost:9000/2015-03-31/functions/function/invocations" -Method Post -Body '{"payload":"hello world!"}' -ContentType "application/json"
              
          
        
          Get the container ID.
          docker ps
        
          Use the docker kill command to stop the container. In this command, replace 3766c4ab331c with the container ID from the previous step.
          docker kill 3766c4ab331c
        To upload the image to Amazon ECR and create the Lambda function
          Run the get-login-password command to authenticate the Docker CLI to your Amazon ECR registry.
        
         
         
        
          Set the --region value to the AWS Region where you want to create the Amazon ECR repository.
        
          Replace 111122223333 with your AWS account ID.
        
          aws ecr get-login-password --region us-east-1 | docker login --username AWS --password-stdin 111122223333.dkr.ecr.us-east-1.amazonaws.com
          
        
        Create a repository in Amazon ECR using the create-repository command.
        aws ecr create-repository --repository-name hello-world --region us-east-1 --image-scanning-configuration scanOnPush=true --image-tag-mutability MUTABLE
        
        NoteThe Amazon ECR repository must be in the same AWS Region as the Lambda function.
        If successful, you see a response like this:
        {
    "repository": {
        "repositoryArn": "arn:aws:ecr:us-east-1:111122223333:repository/hello-world",
        "registryId": "111122223333",
        "repositoryName": "hello-world",
        "repositoryUri": "111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world",
        "createdAt": "2023-03-09T10:39:01+00:00",
        "imageTagMutability": "MUTABLE",
        "imageScanningConfiguration": {
            "scanOnPush": true
        },
        "encryptionConfiguration": {
            "encryptionType": "AES256"
        }
    }
}
        
      
        Copy the repositoryUri from the output in the previous step.
      
        Run the docker tag command to tag your local image into your Amazon ECR repository as the latest version. In this command: 
        
         
         
        
          docker-image:test is the name and tag of your Docker image. This is the image name and tag that you specified in the docker build command.
        
          Replace <ECRrepositoryUri> with the repositoryUri that you copied. Make sure to include :latest at the end of the URI.
        
        docker tag docker-image:test <ECRrepositoryUri>:latest
      Example:
      docker tag docker-image:test 111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest
      
      
      Run the docker push command to deploy your local image to the Amazon ECR repository. Make sure to include :latest at the end of the repository URI.
docker push 111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest

      
      Create an execution role for the function, if you don't already have one. You need the Amazon Resource Name (ARN) of the role in the next step.
      
        Create the Lambda function. For ImageUri, specify the repository URI from earlier. Make sure to include :latest at the end of the URI.
		aws lambda create-function \
  --function-name hello-world \
  --package-type Image \
  --code ImageUri=111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest \
  --role arn:aws:iam::111122223333:role/lambda-ex
  		
      NoteYou can create a function using an image in a different AWS account, as long as the image is in the same Region as the Lambda function. For more information, see  Amazon ECR cross-account permissions.  
      
      Invoke the function.
      aws lambda invoke --function-name hello-world response.json
      You should see a response like this:
{
  "ExecutedVersion": "$LATEST", 
  "StatusCode": 200
}
    
    To see the output of the function, check the response.json file.
    To update the function code, you must build the image again, upload the new image to the Amazon ECR repository, and then use the update-function-code command to deploy the image to the Lambda function.Lambda resolves the image tag to a specific image digest. This means that if you point the image tag that was used to deploy the function to a new image in Amazon ECR, Lambda doesn't automatically update the function to use the new image.To deploy the new image to the same Lambda function, you must use the update-function-code command, even if the image tag in Amazon ECR remains the same. In the following example, the --publish option creates a new version of the function using the updated container image.aws lambda update-function-code \
  --function-name hello-world \
  --image-uri 111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest \
  --publish
  For an example of how to create a Python image from an Alpine base image, see Container image support for Lambda on the AWS
      Blog.
  Document ConventionsDeploy .zip file archivesLayersDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideAWS base images for JavaUsing an AWS base imageUsing a non-AWS base imageDeploy Java Lambda functions with container imagesThere are three ways to build a container image for a Java Lambda function:
     
	 
     
  
      Using an AWS base image for Java
      The AWS base images are preloaded with a language runtime, a runtime interface client to manage the interaction between Lambda and your function code, and a runtime interface emulator for local testing.
    
      Using an AWS OS-only base image
      AWS OS-only base images contain an Amazon Linux distribution and the runtime interface emulator. These images are commonly used to create container images for compiled languages, such as Go and Rust, and for a language or language version that Lambda doesn't provide a base image for, such as Node.js 19. You can also use OS-only base images to implement a custom runtime. To make the image compatible with Lambda, you must include the runtime interface client for Java in the image.
    
      Using a non-AWS base image
      You can use an alternative base image from another container registry, such as Alpine Linux or Debian. You can also use a custom image created by your organization. To make the image compatible with Lambda, you must include the runtime interface client for Java in the image.
    TipTo reduce the time it takes for Lambda container functions to become active, see Use multi-stage builds in the Docker documentation. To build efficient container images, follow the Best practices for writing Dockerfiles.This page explains how to build, test, and deploy container images for Lambda.TopicsAWS base images for JavaUsing an AWS base image for JavaUsing an alternative base image with the runtime interface client
    AWS base images for Java
    AWS provides the following base images for Java:

    
    
          
            Tags
            Runtime
            Operating system
            Dockerfile
            Deprecation
          
        
      
            21
            Java 21
            Amazon Linux 2023
            Dockerfile
                for Java 21 on GitHub
            
                          Jun 30, 2029
            
              
          
      
            17
            Java 17
            Amazon Linux 2
            Dockerfile
                for Java 17 on GitHub
            
                          Jun 30, 2026
            
              
          
      
            11
            Java 11
            Amazon Linux 2
            Dockerfile
                for Java 11 on GitHub
            
                          Jun 30, 2026
            
              
          
      
            8.al2
            Java 8
            Amazon Linux 2
            Dockerfile
                for Java 8 on GitHub
            
                          Jun 30, 2026
            
              
          
    

    Amazon ECR repository: gallery.ecr.aws/lambda/java
    The Java 21 and later base images are based on the Amazon Linux 2023 minimal container image. Earlier base images use Amazon Linux 2. AL2023 provides several advantages over Amazon Linux 2, including a smaller deployment footprint and updated versions of libraries such as glibc.
    AL2023-based images use microdnf (symlinked as dnf) as the package manager instead of yum, which is the default package manager in Amazon Linux 2. microdnf is a standalone implementation of dnf. For a list of packages that are included in AL2023-based images, refer to the Minimal Container columns in Comparing packages installed on Amazon Linux 2023 Container Images. For more information about the differences between AL2023 and Amazon Linux 2, see Introducing the Amazon Linux 2023 runtime for AWS Lambda on the AWS
      Compute Blog.    
    NoteTo run AL2023-based images locally, including with AWS Serverless Application Model (AWS SAM), you must use Docker version 20.10.10 or later.  
   
    Using an AWS base image for Java
    
      To complete the steps in this section, you must have the following:
       
	     
	     
           
           
    
        Java (for example, Amazon Corretto)
      
         Apache Maven or Gradle
      
            AWS CLI version 2
          
            Docker (minimum version 25.0.0)
          
            The Docker buildx plugin.
          
      Maven
    
          Run the following command to create a Maven project using the archetype for Lambda. The following parameters are required:
          
         
             
         
             
          
              service – The AWS service client to use in the Lambda
                        function. For a list of available sources, see aws-sdk-java-v2/services on GitHub.
            
              region – The AWS Region where you want to create the Lambda
                        function.
            
              groupId – The full package namespace of your
                        application.
            
              artifactId – Your project name. This becomes the name of the
                        directory for your project.
            
        In Linux and macOS, run this command:
				mvn -B archetype:generate \
   -DarchetypeGroupId=software.amazon.awssdk \
   -DarchetypeArtifactId=archetype-lambda -Dservice=s3 -Dregion=US_WEST_2 \
   -DgroupId=com.example.myapp \
   -DartifactId=myapp
        In PowerShell, run this command:
				mvn -B archetype:generate `
   "-DarchetypeGroupId=software.amazon.awssdk" `
   "-DarchetypeArtifactId=archetype-lambda" "-Dservice=s3" "-Dregion=US_WEST_2" `
   "-DgroupId=com.example.myapp" `
   "-DartifactId=myapp"
   The Maven archetype for Lambda is preconfigured to compile with Java SE 8 and includes a dependency to the AWS SDK for Java. If you create your project with a different archetype or by using another method, you must configure the Java compiler for Maven and declare the SDK as a dependency.
        
          Open the myapp/src/main/java/com/example/myapp directory, and find the App.java file. This is the code for the Lambda function. You can use the provided sample code for testing, or replace it with your own.
        
          Navigate back to the project's root directory, and then create a new Dockerfile with the following configuration:
          
             
             
          
              Set the FROM property to the URI of the base image.
            
              Set the CMD argument to the Lambda function handler.
            
          Note that the example Dockerfile does not include a USER instruction. When you deploy a container image to Lambda, Lambda automatically defines a default Linux user with least-privileged permissions. This is different from standard Docker behavior which defaults to the root user when no USER instruction is provided.
          Example  DockerfileFROM public.ecr.aws/lambda/java:21
  
# Copy function code and runtime dependencies from Maven layout
COPY target/classes ${LAMBDA_TASK_ROOT}
COPY target/dependency/* ${LAMBDA_TASK_ROOT}/lib/
    
# Set the CMD to your handler (could also be done as a parameter override outside of the Dockerfile)
CMD [ "com.example.myapp.App::handleRequest" ]
        
          Compile the project and collect the runtime dependencies.
          mvn compile dependency:copy-dependencies -DincludeScope=runtime
        
          Build the Docker image with the docker build command. The
          following example names the image docker-image and gives it the test tag. To make your 
          image compatible with Lambda, you must use the --provenance=false option.
        docker buildx build --platform linux/amd64 --provenance=false -t docker-image:test .
        NoteThe command specifies the --platform linux/amd64 option to ensure that your container is compatible with the Lambda execution environment regardless of the  
       architecture of your build machine. If you intend to create a Lambda function using the ARM64 instruction set architecture, be sure to change the command to use the --platform linux/arm64 
       option instead.
        
    
          Gradle
        
            Create a directory for the project, and then switch to that directory.
            mkdir example
cd example
          
            Run the following command to have Gradle generate a new Java application project in
              the example directory in your environment. For Select build script DSL, choose 2: Groovy. 
            gradle init --type java-application
          
          Open the /example/app/src/main/java/example directory, and find the App.java file. This is the code for the Lambda function. You can use the following sample code for testing, or replace it with your own.
          Example App.javapackage com.example;
import com.amazonaws.services.lambda.runtime.Context;
import com.amazonaws.services.lambda.runtime.RequestHandler;
public class App implements RequestHandler<Object, String> {
    public String handleRequest(Object input, Context context) {
        return "Hello world!";
    }
}
        
            Open the build.gradle file. If you're using the sample function code from the previous step, replace the contents of build.gradle with the following. If you're using your own function code, modify your build.gradle file as needed.
            Example  build.gradle (Groovy DSL)plugins {
  id 'java'
}
group 'com.example'
version '1.0-SNAPSHOT'
sourceCompatibility = 1.8
repositories {
  mavenCentral()
}
dependencies {
  implementation 'com.amazonaws:aws-lambda-java-core:1.2.1'
}
jar {
  manifest {
      attributes 'Main-Class': 'com.example.App'
  }
}
          
            The gradle init command from step 2 also generated a dummy
              test case in the app/test directory. For the purposes of this tutorial, skip 
              running tests by deleting the /test directory.
          
        Build the project.
        gradle build
        
          In the project's root directory (/example), create a Dockerfile with the following configuration:
          
             
             
             
          
              Set the FROM property to the URI of the base image.
            
              Use the COPY command to copy the function code and runtime dependencies to {LAMBDA_TASK_ROOT}, a Lambda-defined environment variable.
            
              Set the CMD argument to the Lambda function handler.
            
        Note that the example Dockerfile does not include a USER instruction. When you deploy a container image to Lambda, Lambda automatically defines a default Linux user with least-privileged permissions. This is different from standard Docker behavior which defaults to the root user when no USER instruction is provided.
          Example  DockerfileFROM public.ecr.aws/lambda/java:21
  
# Copy function code and runtime dependencies from Gradle layout
COPY app/build/classes/java/main ${LAMBDA_TASK_ROOT}
  
# Set the CMD to your handler (could also be done as a parameter override outside of the Dockerfile)
CMD [ "com.example.App::handleRequest" ]
        
        Build the Docker image with the docker build command. The
          following example names the image docker-image and gives it the test tag. To make your 
          image compatible with Lambda, you must use the --provenance=false option.
        docker buildx build --platform linux/amd64 --provenance=false -t docker-image:test .
        NoteThe command specifies the --platform linux/amd64 option to ensure that your container is compatible with the Lambda execution environment regardless of the  
       architecture of your build machine. If you intend to create a Lambda function using the ARM64 instruction set architecture, be sure to change the command to use the --platform linux/arm64 
       option instead.
        
            
        
          Start the Docker image with the docker run command. In this example,
              docker-image is the image name and test is the tag.
          docker run --platform linux/amd64 -p 9000:8080 docker-image:test
          This command runs the image as a container and creates a local endpoint at
            localhost:9000/2015-03-31/functions/function/invocations.
          NoteIf you built the Docker image for the ARM64 instruction set architecture, be sure to use the --platform linux/arm64 option instead of --platform linux/amd64. 
        
          From a new terminal window, post an event to the local endpoint.
          
            Linux/macOS
      		      In Linux and macOS, run the following curl command:
                curl "http://localhost:9000/2015-03-31/functions/function/invocations" -d '{}'
                This command invokes the function with an empty event and returns a response. If you're using your own function code rather than the sample function code, you might want to invoke the function with a JSON payload. Example:
                curl "http://localhost:9000/2015-03-31/functions/function/invocations" -d '{"payload":"hello world!"}'
      		
            PowerShell
                In PowerShell, run the following Invoke-WebRequest command:
                Invoke-WebRequest -Uri "http://localhost:9000/2015-03-31/functions/function/invocations" -Method Post -Body '{}' -ContentType "application/json"
                This command invokes the function with an empty event and returns a response. If you're using your own function code rather than the sample function code, you might want to invoke the function with a JSON payload. Example:
                Invoke-WebRequest -Uri "http://localhost:9000/2015-03-31/functions/function/invocations" -Method Post -Body '{"payload":"hello world!"}' -ContentType "application/json"
              
          
        
          Get the container ID.
          docker ps
        
          Use the docker kill command to stop the container. In this command, replace 3766c4ab331c with the container ID from the previous step.
          docker kill 3766c4ab331c
        To upload the image to Amazon ECR and create the Lambda function
          Run the get-login-password command to authenticate the Docker CLI to your Amazon ECR registry.
        
         
         
        
          Set the --region value to the AWS Region where you want to create the Amazon ECR repository.
        
          Replace 111122223333 with your AWS account ID.
        
          aws ecr get-login-password --region us-east-1 | docker login --username AWS --password-stdin 111122223333.dkr.ecr.us-east-1.amazonaws.com
          
        
        Create a repository in Amazon ECR using the create-repository command.
        aws ecr create-repository --repository-name hello-world --region us-east-1 --image-scanning-configuration scanOnPush=true --image-tag-mutability MUTABLE
        
        NoteThe Amazon ECR repository must be in the same AWS Region as the Lambda function.
        If successful, you see a response like this:
        {
    "repository": {
        "repositoryArn": "arn:aws:ecr:us-east-1:111122223333:repository/hello-world",
        "registryId": "111122223333",
        "repositoryName": "hello-world",
        "repositoryUri": "111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world",
        "createdAt": "2023-03-09T10:39:01+00:00",
        "imageTagMutability": "MUTABLE",
        "imageScanningConfiguration": {
            "scanOnPush": true
        },
        "encryptionConfiguration": {
            "encryptionType": "AES256"
        }
    }
}
        
      
        Copy the repositoryUri from the output in the previous step.
      
        Run the docker tag command to tag your local image into your Amazon ECR repository as the latest version. In this command: 
        
         
         
        
          docker-image:test is the name and tag of your Docker image. This is the image name and tag that you specified in the docker build command.
        
          Replace <ECRrepositoryUri> with the repositoryUri that you copied. Make sure to include :latest at the end of the URI.
        
        docker tag docker-image:test <ECRrepositoryUri>:latest
      Example:
      docker tag docker-image:test 111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest
      
      
      Run the docker push command to deploy your local image to the Amazon ECR repository. Make sure to include :latest at the end of the repository URI.
docker push 111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest

      
      Create an execution role for the function, if you don't already have one. You need the Amazon Resource Name (ARN) of the role in the next step.
      
        Create the Lambda function. For ImageUri, specify the repository URI from earlier. Make sure to include :latest at the end of the URI.
		aws lambda create-function \
  --function-name hello-world \
  --package-type Image \
  --code ImageUri=111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest \
  --role arn:aws:iam::111122223333:role/lambda-ex
  		
      NoteYou can create a function using an image in a different AWS account, as long as the image is in the same Region as the Lambda function. For more information, see  Amazon ECR cross-account permissions.  
      
      Invoke the function.
      aws lambda invoke --function-name hello-world response.json
      You should see a response like this:
{
  "ExecutedVersion": "$LATEST", 
  "StatusCode": 200
}
    
    To see the output of the function, check the response.json file.
    To update the function code, you must build the image again, upload the new image to the Amazon ECR repository, and then use the update-function-code command to deploy the image to the Lambda function.Lambda resolves the image tag to a specific image digest. This means that if you point the image tag that was used to deploy the function to a new image in Amazon ECR, Lambda doesn't automatically update the function to use the new image.To deploy the new image to the same Lambda function, you must use the update-function-code command, even if the image tag in Amazon ECR remains the same. In the following example, the --publish option creates a new version of the function using the updated container image.aws lambda update-function-code \
  --function-name hello-world \
  --image-uri 111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest \
  --publish
   
    Using an alternative base image with the runtime interface client
    If you use an OS-only base image or an alternative base image, you must include the runtime interface client in your image. The runtime interface client extends the Runtime API, which manages the interaction between Lambda and your function code.
        Install the runtime interface client for Java in your Dockerfile, or as a dependency in your project. For example, to install the runtime interface client using the Maven package manager, add the following to your pom.xml file:
    <dependency>
    <groupId>com.amazonaws</groupId>
    <artifactId>aws-lambda-java-runtime-interface-client</artifactId>
    <version>2.3.2</version>
</dependency>
    For package details, see AWS Lambda Java Runtime Interface Client
      in the Maven Central Repository. You can also review the runtime interface client source code in the AWS Lambda Java Support Libraries GitHub repository.
    The following example demonstrates how to build a container image for Java using an Amazon Corretto image. Amazon Corretto is a no-cost, multiplatform, production-ready distribution of the Open Java Development Kit (OpenJDK). The Maven project includes the runtime interface client as a dependency.
  
      To complete the steps in this section, you must have the following:
       
	     
       
           
           
    
        Java (for example, Amazon Corretto)
      
         Apache Maven
      
            AWS CLI version 2
          
            Docker (minimum version 25.0.0)
          
            The Docker buildx plugin.
          
          Create a Maven project. The following parameters are required:
          
			 
             
          
              groupId – The full package namespace of your
                        application.
            
              artifactId – Your project name. This becomes the name of the
                        directory for your project.
            
          
            Linux/macOS
				mvn -B archetype:generate \
   -DarchetypeArtifactId=maven-archetype-quickstart \
   -DgroupId=example \
   -DartifactId=myapp \
   -DinteractiveMode=false
      		
            PowerShell
				mvn -B archetype:generate `
   -DarchetypeArtifactId=maven-archetype-quickstart `
   -DgroupId=example `
   -DartifactId=myapp `
   -DinteractiveMode=false
          
          
        
			Open the project directory.
			cd myapp
		
			Open the pom.xml file and replace the contents with the following. This file includes the aws-lambda-java-runtime-interface-client as a dependency. Alternatively, you can install the runtime interface client in the Dockerfile. However, the simplest approach is to include the library as a dependency.
			<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
  <modelVersion>4.0.0</modelVersion>
  <groupId>example</groupId>
  <artifactId>hello-lambda</artifactId>
  <packaging>jar</packaging>
  <version>1.0-SNAPSHOT</version>
  <name>hello-lambda</name>
  <url>http://maven.apache.org</url>
  <properties>
    <maven.compiler.source>1.8</maven.compiler.source>
    <maven.compiler.target>1.8</maven.compiler.target>
  </properties>
  <dependencies>
    <dependency>
      <groupId>com.amazonaws</groupId>
      <artifactId>aws-lambda-java-runtime-interface-client</artifactId>
      <version>2.3.2</version>
    </dependency>
  </dependencies>
  <build>
    <plugins>
      <plugin>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-dependency-plugin</artifactId>
        <version>3.1.2</version>
        <executions>
          <execution>
            <id>copy-dependencies</id>
            <phase>package</phase>
            <goals>
              <goal>copy-dependencies</goal>
            </goals>
          </execution>
        </executions>
      </plugin>
    </plugins>
  </build>
</project>
        
          Open the myapp/src/main/java/com/example/myapp directory, and find the App.java file. This is the code for the Lambda function. Replace the code with the following.
		  Example function handlerpackage example;

public class App {
    public static String sayHello() {
        return "Hello world!";
    }
}
        
          The mvn -B archetype:generate command from step 1 also generated a dummy
            test case in the src/test directory. For the purposes of this tutorial, skip over
            running tests by deleting this entire generated /test directory.
        
          Navigate back to the project's root directory, and then create a new Dockerfile. The following example Dockerfile uses an Amazon Corretto image. Amazon Corretto is a no-cost, multiplatform, production-ready distribution of the OpenJDK.
          
             
			 
             
          
              Set the FROM property to the URI of the base image.
            
				Set the ENTRYPOINT to the module that you want the Docker container to run when it starts. In this case, the module is the runtime interface client.
			
              Set the CMD argument to the Lambda function handler.
            
          Note that the example Dockerfile does not include a USER instruction. When you deploy a container image to Lambda, Lambda automatically defines a default Linux user with least-privileged permissions. This is different from standard Docker behavior which defaults to the root user when no USER instruction is provided.
          Example  DockerfileFROM public.ecr.aws/amazoncorretto/amazoncorretto:21 as base

# Configure the build environment
FROM base as build
RUN yum install -y maven
WORKDIR /src

# Cache and copy dependencies
ADD pom.xml .
RUN mvn dependency:go-offline dependency:copy-dependencies

# Compile the function
ADD . .
RUN mvn package 

# Copy the function artifact and dependencies onto a clean base
FROM base
WORKDIR /function

COPY --from=build /src/target/dependency/*.jar ./
COPY --from=build /src/target/*.jar ./

# Set runtime interface client as default command for the container runtime
ENTRYPOINT [ "/usr/bin/java", "-cp", "./*", "com.amazonaws.services.lambda.runtime.api.client.AWSLambda" ]
# Pass the name of the function handler as an argument to the runtime
CMD [ "example.App::sayHello" ]
        
          Build the Docker image with the docker build command. The
          following example names the image docker-image and gives it the test tag. To make your 
          image compatible with Lambda, you must use the --provenance=false option.
        docker buildx build --platform linux/amd64 --provenance=false -t docker-image:test .
        NoteThe command specifies the --platform linux/amd64 option to ensure that your container is compatible with the Lambda execution environment regardless of the  
       architecture of your build machine. If you intend to create a Lambda function using the ARM64 instruction set architecture, be sure to change the command to use the --platform linux/arm64 
       option instead.
        Use the runtime interface emulator to locally test the image. You can build the emulator into your image or use the following procedure to install it on your local machine.To install and run the runtime interface emulator on your local machine
          From your project directory, run the following command to download the runtime interface emulator (x86-64 architecture) from GitHub and install it on your local machine.
          
            Linux/macOS
          mkdir -p ~/.aws-lambda-rie && \
    curl -Lo ~/.aws-lambda-rie/aws-lambda-rie https://github.com/aws/aws-lambda-runtime-interface-emulator/releases/latest/download/aws-lambda-rie && \
    chmod +x ~/.aws-lambda-rie/aws-lambda-rie
      			  To install the arm64 emulator, replace the GitHub repository URL in the previous command with the following:
      			https://github.com/aws/aws-lambda-runtime-interface-emulator/releases/latest/download/aws-lambda-rie-arm64
      		
            PowerShell
      				  $dirPath = "$HOME\.aws-lambda-rie"
if (-not (Test-Path $dirPath)) {
    New-Item -Path $dirPath -ItemType Directory
}
      
$downloadLink = "https://github.com/aws/aws-lambda-runtime-interface-emulator/releases/latest/download/aws-lambda-rie"
$destinationPath = "$HOME\.aws-lambda-rie\aws-lambda-rie"
Invoke-WebRequest -Uri $downloadLink -OutFile $destinationPath
      				  To install the arm64 emulator, replace the $downloadLink with the following:
      				https://github.com/aws/aws-lambda-runtime-interface-emulator/releases/latest/download/aws-lambda-rie-arm64
              
          
        
          Start the Docker image with the docker run command. Note the following:
          
             
             
          
            docker-image is the image name and test is the tag.
            
            /usr/bin/java -cp './*' com.amazonaws.services.lambda.runtime.api.client.AWSLambda example.App::sayHello is the ENTRYPOINT followed by the CMD from your Dockerfile.
            
          
            Linux/macOS
				    docker run --platform linux/amd64 -d -v ~/.aws-lambda-rie:/aws-lambda -p 9000:8080 \
    --entrypoint /aws-lambda/aws-lambda-rie \
    docker-image:test \
        /usr/bin/java -cp './*' com.amazonaws.services.lambda.runtime.api.client.AWSLambda example.App::sayHello
      		
            PowerShell
				        docker run --platform linux/amd64 -d -v "$HOME\.aws-lambda-rie:/aws-lambda" -p 9000:8080 `
--entrypoint /aws-lambda/aws-lambda-rie `
docker-image:test `
    /usr/bin/java -cp './*' com.amazonaws.services.lambda.runtime.api.client.AWSLambda example.App::sayHello
				    
          
          This command runs the image as a container and creates a local endpoint at
            localhost:9000/2015-03-31/functions/function/invocations.
         NoteIf you built the Docker image for the ARM64 instruction set architecture, be sure to use the --platform linux/arm64 option instead of --platform linux/amd64.   
        
          Post an event to the local endpoint.
          
            Linux/macOS
      		      In Linux and macOS, run the following curl command:
                curl "http://localhost:9000/2015-03-31/functions/function/invocations" -d '{}'
                This command invokes the function with an empty event and returns a response. If you're using your own function code rather than the sample function code, you might want to invoke the function with a JSON payload. Example:
                curl "http://localhost:9000/2015-03-31/functions/function/invocations" -d '{"payload":"hello world!"}'
      		
            PowerShell
                In PowerShell, run the following Invoke-WebRequest command:
                Invoke-WebRequest -Uri "http://localhost:9000/2015-03-31/functions/function/invocations" -Method Post -Body '{}' -ContentType "application/json"
                This command invokes the function with an empty event and returns a response. If you're using your own function code rather than the sample function code, you might want to invoke the function with a JSON payload. Example:
                Invoke-WebRequest -Uri "http://localhost:9000/2015-03-31/functions/function/invocations" -Method Post -Body '{"payload":"hello world!"}' -ContentType "application/json"
              
          
        
          Get the container ID.
          docker ps
        
          Use the docker kill command to stop the container. In this command, replace 3766c4ab331c with the container ID from the previous step.
          docker kill 3766c4ab331c
        To upload the image to Amazon ECR and create the Lambda function
          Run the get-login-password command to authenticate the Docker CLI to your Amazon ECR registry.
        
         
         
        
          Set the --region value to the AWS Region where you want to create the Amazon ECR repository.
        
          Replace 111122223333 with your AWS account ID.
        
          aws ecr get-login-password --region us-east-1 | docker login --username AWS --password-stdin 111122223333.dkr.ecr.us-east-1.amazonaws.com
          
        
        Create a repository in Amazon ECR using the create-repository command.
        aws ecr create-repository --repository-name hello-world --region us-east-1 --image-scanning-configuration scanOnPush=true --image-tag-mutability MUTABLE
        
        NoteThe Amazon ECR repository must be in the same AWS Region as the Lambda function.
        If successful, you see a response like this:
        {
    "repository": {
        "repositoryArn": "arn:aws:ecr:us-east-1:111122223333:repository/hello-world",
        "registryId": "111122223333",
        "repositoryName": "hello-world",
        "repositoryUri": "111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world",
        "createdAt": "2023-03-09T10:39:01+00:00",
        "imageTagMutability": "MUTABLE",
        "imageScanningConfiguration": {
            "scanOnPush": true
        },
        "encryptionConfiguration": {
            "encryptionType": "AES256"
        }
    }
}
        
      
        Copy the repositoryUri from the output in the previous step.
      
        Run the docker tag command to tag your local image into your Amazon ECR repository as the latest version. In this command: 
        
         
         
        
          docker-image:test is the name and tag of your Docker image. This is the image name and tag that you specified in the docker build command.
        
          Replace <ECRrepositoryUri> with the repositoryUri that you copied. Make sure to include :latest at the end of the URI.
        
        docker tag docker-image:test <ECRrepositoryUri>:latest
      Example:
      docker tag docker-image:test 111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest
      
      
      Run the docker push command to deploy your local image to the Amazon ECR repository. Make sure to include :latest at the end of the repository URI.
docker push 111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest

      
      Create an execution role for the function, if you don't already have one. You need the Amazon Resource Name (ARN) of the role in the next step.
      
        Create the Lambda function. For ImageUri, specify the repository URI from earlier. Make sure to include :latest at the end of the URI.
		aws lambda create-function \
  --function-name hello-world \
  --package-type Image \
  --code ImageUri=111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest \
  --role arn:aws:iam::111122223333:role/lambda-ex
  		
      NoteYou can create a function using an image in a different AWS account, as long as the image is in the same Region as the Lambda function. For more information, see  Amazon ECR cross-account permissions.  
      
      Invoke the function.
      aws lambda invoke --function-name hello-world response.json
      You should see a response like this:
{
  "ExecutedVersion": "$LATEST", 
  "StatusCode": 200
}
    
    To see the output of the function, check the response.json file.
    To update the function code, you must build the image again, upload the new image to the Amazon ECR repository, and then use the update-function-code command to deploy the image to the Lambda function.Lambda resolves the image tag to a specific image digest. This means that if you point the image tag that was used to deploy the function to a new image in Amazon ECR, Lambda doesn't automatically update the function to use the new image.To deploy the new image to the same Lambda function, you must use the update-function-code command, even if the image tag in Amazon ECR remains the same. In the following example, the --publish option creates a new version of the function using the updated container image.aws lambda update-function-code \
  --function-name hello-world \
  --image-uri 111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest \
  --publish
  Document ConventionsDeploy .zip file archivesLayersDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideAWS base images for .NETUsing an AWS base imageUsing a non-AWS base imageDeploy .NET Lambda functions with container imagesThere are three ways to build a container image for a .NET Lambda function:
     
	 
     
  
      Using an AWS base image for .NET
      The AWS base images are preloaded with a language runtime, a runtime interface client to manage the interaction between Lambda and your function code, and a runtime interface emulator for local testing.
    
      Using an AWS OS-only base image
      AWS OS-only base images contain an Amazon Linux distribution and the runtime interface emulator. These images are commonly used to create container images for compiled languages, such as Go and Rust, and for a language or language version that Lambda doesn't provide a base image for, such as Node.js 19. You can also use OS-only base images to implement a custom runtime. To make the image compatible with Lambda, you must include the the runtime interface client for .NET in the image.
    
      Using a non-AWS base image
      You can use an alternative base image from another container registry, such as Alpine Linux or Debian. You can also use a custom image created by your organization. To make the image compatible with Lambda, you must include the the runtime interface client for .NET in the image.
    TipTo reduce the time it takes for Lambda container functions to become active, see Use multi-stage builds in the Docker documentation. To build efficient container images, follow the Best practices for writing Dockerfiles.This page explains how to build, test, and deploy container images for Lambda.TopicsAWS base images for .NETUsing an AWS base image for .NETUsing an alternative base image with the runtime interface client
    AWS base images for .NET
    AWS provides the following base images for .NET:
    
    
          
            Tags
            Runtime
            Operating system
            Dockerfile
            Deprecation
          
        
      
            9
            .NET 9
            Amazon Linux 2023
            Dockerfile
                for .NET 9 on GitHub
            
              
            Not scheduled
            
              
          
      
            8
            .NET 8
            Amazon Linux 2023
            Dockerfile
                for .NET 8 on GitHub
            
                          Nov 10, 2026
            
              
          
    
    Amazon ECR repository: gallery.ecr.aws/lambda/dotnet
   
    Using an AWS base image for .NET
     
      Prerequisites
      
        To complete the steps in this section, you must have the following:
         
         
         
      
          .NET SDK – The following steps use the
            .NET 8 base image. Make sure that your .NET version matches the version of the base image that you specify in your Dockerfile.
        
          Docker (minimum version 25.0.0)
        
          The Docker buildx plugin.
        
     
     
      Creating and deploying an image using a base image
      In the following steps, you use Amazon.Lambda.Templates and Amazon.Lambda.Tools
        to create a .NET project. Then, you build a Docker image, upload the image to Amazon ECR, and deploy it to a Lambda
        function.
      
          Install the Amazon.Lambda.Templates NuGet package.
          dotnet new install Amazon.Lambda.Templates
        
          Create a .NET project using the lambda.image.EmptyFunction template.
          dotnet new lambda.image.EmptyFunction --name MyFunction --region us-east-1
          The project files are stored in the MyFunction/src/MyFunction directory:
          
             
             
             
             
          
              aws-lambda-tools-defaults.json: Specifies the command line options for deploying your Lambda function.
            
              Function.cs: Your Lambda handler function code. This is a C#
                template that includes the default Amazon.Lambda.Core library and a default
                LambdaSerializer attribute. For more information about serialization requirements and
                options, see Serialization in C# Lambda functions. You
                can use the provided code for testing, or replace it with your own.
            
              MyFunction.csproj: A .NET project
                file, which lists the files and assemblies that comprise your application.
            
              Dockerfile: You can use the provided Dockerfile for testing, or replace it with your own. If you use your own, make sure to:
              
                 
                 
              
                  Set the FROM property to the URI of
                    the base image. The base image and the TargetFramework in the MyFunction.csproj file must both use the same .NET version. For example, to use .NET 9:
                  
                     
                     
                  
                      Dockerfile: FROM public.ecr.aws/lambda/dotnet:9
                    
                      MyFunction.csproj: <TargetFramework>net9.0</TargetFramework>
                    
                
                  Set the CMD argument to the Lambda function handler. This should match the
                    image-command in aws-lambda-tools-defaults.json.
                
            
        
          Install the Amazon.Lambda.Tools .NET
              Global Tool.
          dotnet tool install -g Amazon.Lambda.Tools
          If Amazon.Lambda.Tools is already installed, make sure that you have the latest version.
          dotnet tool update -g Amazon.Lambda.Tools
        
          Change the directory to
                MyFunction/src/MyFunction, if you're
            not there already.
          cd src/MyFunction
        
          Use Amazon.Lambda.Tools to build the Docker image, push it to a new Amazon ECR repository, and deploy the
            Lambda function.
          For --function-role, specify the role name—not the Amazon Resource Name
            (ARN)—of the execution role for the function. For
            example, lambda-role.
          dotnet lambda deploy-function MyFunction --function-role lambda-role
          For more information about the Amazon.Lambda.Tools .NET Global Tool, see the AWS Extensions for .NET CLI repository on
            GitHub.
        
          Invoke the function.
          dotnet lambda invoke-function MyFunction --payload "Testing the function"
          If everything is successful, you see a response similar to the following:
          Payload:
{"Lower":"testing the function","Upper":"TESTING THE FUNCTION"}

Log Tail:
INIT_REPORT Init Duration: 9999.81 ms   Phase: init     Status: timeout
START RequestId: 12378346-f302-419b-b1f2-deaa1e8423ed Version: $LATEST
END RequestId: 12378346-f302-419b-b1f2-deaa1e8423ed
REPORT RequestId: 12378346-f302-419b-b1f2-deaa1e8423ed  Duration: 3173.06 ms    Billed Duration: 3174 ms        Memory Size: 512 MB     Max Memory Used: 24 MB
        
          Delete the Lambda function.
          dotnet lambda delete-function MyFunction
      
     
   
    Using an alternative base image with the runtime interface client
    If you use an OS-only base image or an alternative base image, you must include the runtime interface client in your image. The runtime interface client extends the Runtime API, which manages the interaction between Lambda and your function code.
    The following example demonstrates how to build a container image for .NET using a non-AWS base image, and how to add the Amazon.Lambda.RuntimeSupport package, which is the Lambda runtime interface client for .NET. The example Dockerfile uses the Microsoft .NET 8 base image.
     
      Prerequisites
      
        To complete the steps in this section, you must have the following:
         
         
         
      
          .NET SDK – The following steps use a
            .NET 9 base image. Make sure that your .NET version matches the version of the base image that you specify in your Dockerfile.
        
          Docker (minimum version 25.0.0)
        
          The Docker buildx plugin.
        
     
     
      Creating and deploying an image using an alternative base image

      
          Install the Amazon.Lambda.Templates NuGet package.
          dotnet new install Amazon.Lambda.Templates
        
          Create a .NET project using the lambda.CustomRuntimeFunction template. This template includes the Amazon.Lambda.RuntimeSupport package.
          dotnet new lambda.CustomRuntimeFunction --name MyFunction --region us-east-1
        
          Navigate to the MyFunction/src/MyFunction directory. This is where the project files are stored. Examine the following files:
          
             
             
             
             
          
              aws-lambda-tools-defaults.json – This file is where you
                specify the command line options when deploying your Lambda function.
            
              Function.cs – The code contains a class with a Main method that initializes the Amazon.Lambda.RuntimeSupport library as the bootstrap. The Main method is the entry point for the function's process. The Main method wraps the function handler in a wrapper that the bootstrap can work with. For more information, see Using Amazon.Lambda.RuntimeSupport as a class library in the GitHub repository.
            
              MyFunction.csproj – A .NET project
                  file, which lists the files and assemblies that comprise your application.
            
              Readme.md – This file contains more information about the
                sample Lambda function.
            
        
          Open the aws-lambda-tools-defaults.json file and Add the following lines:
                        "package-type": "image",
  "docker-host-build-output-dir": "./bin/Release/lambda-publish"
          
             
             
          
              package-type: Defines the deployment package as a container image.
            
              docker-host-build-output-dir: Sets the output directory for the build process.
            
          Example  aws-lambda-tools-defaults.json{
  "Information": [
    "This file provides default values for the deployment wizard inside Visual Studio and the AWS Lambda commands added to the .NET Core CLI.",
    "To learn more about the Lambda commands with the .NET Core CLI execute the following command at the command line in the project root directory.",
    "dotnet lambda help",
    "All the command line options for the Lambda command can be specified in this file."
  ],
  "profile": "",
  "region": "us-east-1",
  "configuration": "Release",
  "function-runtime": "provided.al2023",
  "function-memory-size": 256,
  "function-timeout": 30,
  "function-handler": "bootstrap",
  "msbuild-parameters": "--self-contained true",
  "package-type": "image",
  "docker-host-build-output-dir": "./bin/Release/lambda-publish"
}
        
          Create a Dockerfile in the MyFunction/src/MyFunction directory. The following example Dockerfile uses a Microsoft .NET base image instead of an AWS base image.
          
             
			       
			       
          
              Set the FROM property to the base image identifier. The base image and the TargetFramework in the MyFunction.csproj file must both use the same .NET version.
            
              Use the COPY command to copy the function into the /var/task directory.
            
				      Set the ENTRYPOINT to the module that you want the Docker container to run when it starts. In this case, the module is the bootstrap, which initializes the Amazon.Lambda.RuntimeSupport library.
			      
          Note that the example Dockerfile does not include a USER instruction. When you deploy a container image to Lambda, Lambda automatically defines a default Linux user with least-privileged permissions. This is different from standard Docker behavior which defaults to the root user when no USER instruction is provided.
          Example  Dockerfile# You can also pull these images from DockerHub amazon/aws-lambda-dotnet:8
FROM mcr.microsoft.com/dotnet/runtime:9.0

# Set the image's internal work directory
WORKDIR /var/task
  
# Copy function code to Lambda-defined environment variable
COPY "bin/Release/net9.0/linux-x64"  .
  
# Set the entrypoint to the bootstrap
ENTRYPOINT ["/usr/bin/dotnet", "exec", "/var/task/bootstrap.dll"]
        
          Install the Amazon.Lambda.Tools .NET
              Global Tools extension.
          dotnet tool install -g Amazon.Lambda.Tools
          If Amazon.Lambda.Tools is already installed, make sure that you have the latest version.
          dotnet tool update -g Amazon.Lambda.Tools
        
          Use Amazon.Lambda.Tools to build the Docker image, push it to a new Amazon ECR repository, and deploy the
            Lambda function.
          For --function-role, specify the role name—not the Amazon Resource Name
            (ARN)—of the execution role for the function. For
            example, lambda-role.
          dotnet lambda deploy-function MyFunction --function-role lambda-role
          For more information about the Amazon.Lambda.Tools .NET CLI extension, see the AWS Extensions for .NET CLI repository on
            GitHub.
        
          Invoke the function.
          dotnet lambda invoke-function MyFunction --payload "Testing the function"
          If everything is successful, you see the following:
          Payload:
"TESTING THE FUNCTION"

Log Tail:
START RequestId: id Version: $LATEST
END RequestId: id
REPORT RequestId: id  Duration: 0.99 ms       Billed Duration: 1 ms         Memory Size: 256 MB     Max Memory Used: 12 MB
        
        Delete the Lambda function.
        dotnet lambda delete-function MyFunction
      
     
  Document ConventionsASP.NETNative AOT compilationDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideAWS base images for RubyUsing an AWS base imageUsing a non-AWS base imageDeploy Ruby Lambda functions with container imagesThere are three ways to build a container image for a Ruby Lambda function:
     
	 
     
  
      Using an AWS base image for Ruby
      The AWS base images are preloaded with a language runtime, a runtime interface client to manage the interaction between Lambda and your function code, and a runtime interface emulator for local testing.
    
      Using an AWS OS-only base image
      AWS OS-only base images contain an Amazon Linux distribution and the runtime interface emulator. These images are commonly used to create container images for compiled languages, such as Go and Rust, and for a language or language version that Lambda doesn't provide a base image for, such as Node.js 19. You can also use OS-only base images to implement a custom runtime. To make the image compatible with Lambda, you must include the runtime interface client for Ruby in the image.
    
      Using a non-AWS base image
      You can use an alternative base image from another container registry, such as Alpine Linux or Debian. You can also use a custom image created by your organization. To make the image compatible with Lambda, you must include the runtime interface client for Ruby in the image.
    TipTo reduce the time it takes for Lambda container functions to become active, see Use multi-stage builds in the Docker documentation. To build efficient container images, follow the Best practices for writing Dockerfiles.This page explains how to build, test, and deploy container images for Lambda.TopicsAWS base images for RubyUsing an AWS base image for RubyUsing an alternative base image with the runtime interface client
    AWS base images for Ruby
    AWS provides the following base images for Ruby:

    
    
          
            Tags
            Runtime
            Operating system
            Dockerfile
            Deprecation
          
        
      
            3.4
            Ruby 3.4
            Amazon Linux 2023
            Dockerfile
                for Ruby 3.4 on GitHub
            
              
            Not scheduled
            
              
          
      
            3.3
            Ruby 3.3
            Amazon Linux 2023
            Dockerfile
                for Ruby 3.3 on GitHub
            
                          Mar 31, 2027
            
              
          
      
            3.2
            Ruby 3.2
            Amazon Linux 2
            Dockerfile
                for Ruby 3.2 on GitHub
            
                          Mar 31, 2026
            
              
          
    
    
    Amazon ECR repository: gallery.ecr.aws/lambda/ruby
   
    Using an AWS base image for Ruby
    To complete the steps in this section, you must have the following:
           
           
           
           
        
            AWS CLI version 2
          
            Docker (minimum version 25.0.0)
          
            The Docker buildx plugin.
          
            Ruby
          To create a container image for Ruby
        Create a directory for the project, and then switch to that directory.
        mkdir example
cd example
      
        Create a new file called Gemfile. This is where you list your application's required RubyGems packages. The AWS SDK for Ruby is available from RubyGems. You should choose specific AWS service gems to install. For example, to use the Ruby gem for Lambda, your Gemfile should look like this:
        source 'https://rubygems.org'

gem 'aws-sdk-lambda'
Alternatively, the aws-sdk gem contains every available AWS service gem. This gem is very large. We recommend that you use it only if you depend on many AWS services.
      
        Install the dependencies specified in the Gemfile using bundle install.
        bundle install
      
        Create a new file called lambda_function.rb. You can add the following sample function code to the file for testing, or use your own.
        Example  Ruby functionmodule LambdaFunction
  class Handler
    def self.process(event:,context:)
      "Hello from Lambda!"
    end
  end
end
      
      Create a new Dockerfile. The following is an example Dockerfile that uses an AWS base image. This Dockerfiles uses the following configuration:
        
           
           
           
        
            Set the FROM property to the URI of the base image.
          
            Use the COPY command to copy the function code and runtime dependencies to {LAMBDA_TASK_ROOT}, a Lambda-defined environment variable.
          
            Set the CMD argument to the Lambda function handler.
          
        Note that the example Dockerfile does not include a USER instruction. When you deploy a container image to Lambda, Lambda automatically defines a default Linux user with least-privileged permissions. This is different from standard Docker behavior which defaults to the root user when no USER instruction is provided.
        Example  DockerfileFROM public.ecr.aws/lambda/ruby:3.2

# Copy Gemfile and Gemfile.lock
COPY Gemfile Gemfile.lock ${LAMBDA_TASK_ROOT}/

# Install Bundler and the specified gems
RUN gem install bundler:2.4.20 && \
    bundle config set --local path 'vendor/bundle' && \
    bundle install

# Copy function code
COPY lambda_function.rb ${LAMBDA_TASK_ROOT}/    

# Set the CMD to your handler (could also be done as a parameter override outside of the Dockerfile)
CMD [ "lambda_function.LambdaFunction::Handler.process" ]
      
        Build the Docker image with the docker build command. The
          following example names the image docker-image and gives it the test tag. To make your 
          image compatible with Lambda, you must use the --provenance=false option.
        docker buildx build --platform linux/amd64 --provenance=false -t docker-image:test .
        NoteThe command specifies the --platform linux/amd64 option to ensure that your container is compatible with the Lambda execution environment regardless of the  
       architecture of your build machine. If you intend to create a Lambda function using the ARM64 instruction set architecture, be sure to change the command to use the --platform linux/arm64 
       option instead.
      
          Start the Docker image with the docker run command. In this example,
              docker-image is the image name and test is the tag.
          docker run --platform linux/amd64 -p 9000:8080 docker-image:test
          This command runs the image as a container and creates a local endpoint at
            localhost:9000/2015-03-31/functions/function/invocations.
          NoteIf you built the Docker image for the ARM64 instruction set architecture, be sure to use the --platform linux/arm64 option instead of --platform linux/amd64. 
        
          From a new terminal window, post an event to the local endpoint.
          
            Linux/macOS
      		      In Linux and macOS, run the following curl command:
                curl "http://localhost:9000/2015-03-31/functions/function/invocations" -d '{}'
                This command invokes the function with an empty event and returns a response. If you're using your own function code rather than the sample function code, you might want to invoke the function with a JSON payload. Example:
                curl "http://localhost:9000/2015-03-31/functions/function/invocations" -d '{"payload":"hello world!"}'
      		
            PowerShell
                In PowerShell, run the following Invoke-WebRequest command:
                Invoke-WebRequest -Uri "http://localhost:9000/2015-03-31/functions/function/invocations" -Method Post -Body '{}' -ContentType "application/json"
                This command invokes the function with an empty event and returns a response. If you're using your own function code rather than the sample function code, you might want to invoke the function with a JSON payload. Example:
                Invoke-WebRequest -Uri "http://localhost:9000/2015-03-31/functions/function/invocations" -Method Post -Body '{"payload":"hello world!"}' -ContentType "application/json"
              
          
        
          Get the container ID.
          docker ps
        
          Use the docker kill command to stop the container. In this command, replace 3766c4ab331c with the container ID from the previous step.
          docker kill 3766c4ab331c
        To upload the image to Amazon ECR and create the Lambda function
          Run the get-login-password command to authenticate the Docker CLI to your Amazon ECR registry.
        
         
         
        
          Set the --region value to the AWS Region where you want to create the Amazon ECR repository.
        
          Replace 111122223333 with your AWS account ID.
        
          aws ecr get-login-password --region us-east-1 | docker login --username AWS --password-stdin 111122223333.dkr.ecr.us-east-1.amazonaws.com
          
        
        Create a repository in Amazon ECR using the create-repository command.
        aws ecr create-repository --repository-name hello-world --region us-east-1 --image-scanning-configuration scanOnPush=true --image-tag-mutability MUTABLE
        
        NoteThe Amazon ECR repository must be in the same AWS Region as the Lambda function.
        If successful, you see a response like this:
        {
    "repository": {
        "repositoryArn": "arn:aws:ecr:us-east-1:111122223333:repository/hello-world",
        "registryId": "111122223333",
        "repositoryName": "hello-world",
        "repositoryUri": "111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world",
        "createdAt": "2023-03-09T10:39:01+00:00",
        "imageTagMutability": "MUTABLE",
        "imageScanningConfiguration": {
            "scanOnPush": true
        },
        "encryptionConfiguration": {
            "encryptionType": "AES256"
        }
    }
}
        
      
        Copy the repositoryUri from the output in the previous step.
      
        Run the docker tag command to tag your local image into your Amazon ECR repository as the latest version. In this command: 
        
         
         
        
          docker-image:test is the name and tag of your Docker image. This is the image name and tag that you specified in the docker build command.
        
          Replace <ECRrepositoryUri> with the repositoryUri that you copied. Make sure to include :latest at the end of the URI.
        
        docker tag docker-image:test <ECRrepositoryUri>:latest
      Example:
      docker tag docker-image:test 111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest
      
      
      Run the docker push command to deploy your local image to the Amazon ECR repository. Make sure to include :latest at the end of the repository URI.
docker push 111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest

      
      Create an execution role for the function, if you don't already have one. You need the Amazon Resource Name (ARN) of the role in the next step.
      
        Create the Lambda function. For ImageUri, specify the repository URI from earlier. Make sure to include :latest at the end of the URI.
		aws lambda create-function \
  --function-name hello-world \
  --package-type Image \
  --code ImageUri=111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest \
  --role arn:aws:iam::111122223333:role/lambda-ex
  		
      NoteYou can create a function using an image in a different AWS account, as long as the image is in the same Region as the Lambda function. For more information, see  Amazon ECR cross-account permissions.  
      
      Invoke the function.
      aws lambda invoke --function-name hello-world response.json
      You should see a response like this:
{
  "ExecutedVersion": "$LATEST", 
  "StatusCode": 200
}
    
    To see the output of the function, check the response.json file.
    To update the function code, you must build the image again, upload the new image to the Amazon ECR repository, and then use the update-function-code command to deploy the image to the Lambda function.Lambda resolves the image tag to a specific image digest. This means that if you point the image tag that was used to deploy the function to a new image in Amazon ECR, Lambda doesn't automatically update the function to use the new image.To deploy the new image to the same Lambda function, you must use the update-function-code command, even if the image tag in Amazon ECR remains the same. In the following example, the --publish option creates a new version of the function using the updated container image.aws lambda update-function-code \
  --function-name hello-world \
  --image-uri 111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest \
  --publish
 
    Using an alternative base image with the runtime interface client
    If you use an OS-only base image or an alternative base image, you must include the runtime interface client in your image. The runtime interface client extends the Runtime API, which manages the interaction between Lambda and your function code.
    Install the Lambda runtime interface client for Ruby using the RubyGems.org package manager:
    gem install aws_lambda_ric
    You can also download the Ruby runtime interface client from GitHub.
    The following example demonstrates how to build a container image for Ruby using a non-AWS base image. The example Dockerfile uses an official Ruby base image. The Dockerfile includes the runtime interface client.
    To complete the steps in this section, you must have the following:
           
           
           
           
        
            AWS CLI version 2
          
            Docker (minimum version 25.0.0)
          
            The Docker buildx plugin.
          
            Ruby
          To create a container image for Ruby using an alternative base image
        Create a directory for the project, and then switch to that directory.
        mkdir example
cd example
      
        Create a new file called Gemfile. This is where you list your application's required RubyGems packages. The AWS SDK for Ruby is available from RubyGems. You should choose specific AWS service gems to install. For example, to use the Ruby gem for Lambda, your Gemfile should look like this:
        source 'https://rubygems.org'

gem 'aws-sdk-lambda'
Alternatively, the aws-sdk gem contains every available AWS service gem. This gem is very large. We recommend that you use it only if you depend on many AWS services.
      
        Install the dependencies specified in the Gemfile using bundle install.
        bundle install
      
        Create a new file called lambda_function.rb. You can add the following sample function code to the file for testing, or use your own.
        Example  Ruby functionmodule LambdaFunction
  class Handler
    def self.process(event:,context:)
      "Hello from Lambda!"
    end
  end
end
      
      Create a new Dockerfile. The following Dockerfile uses a Ruby base image instead of an AWS base image. The Dockerfile includes the runtime interface client for Ruby, which makes the image  compatible with Lambda. Alternatively, you can add the runtime interface client to your application's Gemfile.
        
           
           
		   
           
        
            Set the FROM property to the Ruby base image.
          
            Create a directory for the function code and an environment variable that points
                  to that directory. In this example, the directory is /var/task, which
                  mirrors the Lambda execution environment. However, you can choose any directory for
                  the function code because the Dockerfile doesn't use an AWS base image.
          
            Set the ENTRYPOINT to the module that you want the Docker container to run when it starts. In this case, the module is the runtime interface client.
          
            Set the CMD argument to the Lambda function handler.
          
        Note that the example Dockerfile does not include a USER instruction. When you deploy a container image to Lambda, Lambda automatically defines a default Linux user with least-privileged permissions. This is different from standard Docker behavior which defaults to the root user when no USER instruction is provided.
        Example  DockerfileFROM ruby:2.7

# Install the runtime interface client for Ruby
RUN gem install aws_lambda_ric

# Add the runtime interface client to the PATH
ENV PATH="/usr/local/bundle/bin:${PATH}"

# Create a directory for the Lambda function
ENV LAMBDA_TASK_ROOT=/var/task
RUN mkdir -p ${LAMBDA_TASK_ROOT}
WORKDIR ${LAMBDA_TASK_ROOT}

# Copy Gemfile and Gemfile.lock
COPY Gemfile Gemfile.lock ${LAMBDA_TASK_ROOT}/

# Install Bundler and the specified gems
RUN gem install bundler:2.4.20 && \
    bundle config set --local path 'vendor/bundle' && \
    bundle install

# Copy function code
COPY lambda_function.rb ${LAMBDA_TASK_ROOT}/    

# Set runtime interface client as default command for the container runtime
ENTRYPOINT [ "aws_lambda_ric" ]

# Set the CMD to your handler (could also be done as a parameter override outside of the Dockerfile)
CMD [ "lambda_function.LambdaFunction::Handler.process" ]
      
        Build the Docker image with the docker build command. The
          following example names the image docker-image and gives it the test tag. To make your 
          image compatible with Lambda, you must use the --provenance=false option.
        docker buildx build --platform linux/amd64 --provenance=false -t docker-image:test .
        NoteThe command specifies the --platform linux/amd64 option to ensure that your container is compatible with the Lambda execution environment regardless of the  
       architecture of your build machine. If you intend to create a Lambda function using the ARM64 instruction set architecture, be sure to change the command to use the --platform linux/arm64 
       option instead.
      Use the runtime interface emulator to locally test the image. You can build the emulator into your image or use the following procedure to install it on your local machine.To install and run the runtime interface emulator on your local machine
          From your project directory, run the following command to download the runtime interface emulator (x86-64 architecture) from GitHub and install it on your local machine.
          
            Linux/macOS
          mkdir -p ~/.aws-lambda-rie && \
    curl -Lo ~/.aws-lambda-rie/aws-lambda-rie https://github.com/aws/aws-lambda-runtime-interface-emulator/releases/latest/download/aws-lambda-rie && \
    chmod +x ~/.aws-lambda-rie/aws-lambda-rie
      			  To install the arm64 emulator, replace the GitHub repository URL in the previous command with the following:
      			https://github.com/aws/aws-lambda-runtime-interface-emulator/releases/latest/download/aws-lambda-rie-arm64
      		
            PowerShell
      				  $dirPath = "$HOME\.aws-lambda-rie"
if (-not (Test-Path $dirPath)) {
    New-Item -Path $dirPath -ItemType Directory
}
      
$downloadLink = "https://github.com/aws/aws-lambda-runtime-interface-emulator/releases/latest/download/aws-lambda-rie"
$destinationPath = "$HOME\.aws-lambda-rie\aws-lambda-rie"
Invoke-WebRequest -Uri $downloadLink -OutFile $destinationPath
      				  To install the arm64 emulator, replace the $downloadLink with the following:
      				https://github.com/aws/aws-lambda-runtime-interface-emulator/releases/latest/download/aws-lambda-rie-arm64
              
          
        
          Start the Docker image with the docker run command. Note the following:
          
             
             
          
            docker-image is the image name and test is the tag.
            
            aws_lambda_ric lambda_function.LambdaFunction::Handler.process is the ENTRYPOINT followed by the CMD from your Dockerfile.
            
          
            Linux/macOS
				    docker run --platform linux/amd64 -d -v ~/.aws-lambda-rie:/aws-lambda -p 9000:8080 \
    --entrypoint /aws-lambda/aws-lambda-rie \
    docker-image:test \
        aws_lambda_ric lambda_function.LambdaFunction::Handler.process
      		
            PowerShell
				        docker run --platform linux/amd64 -d -v "$HOME\.aws-lambda-rie:/aws-lambda" -p 9000:8080 `
--entrypoint /aws-lambda/aws-lambda-rie `
docker-image:test `
    aws_lambda_ric lambda_function.LambdaFunction::Handler.process
				    
          
          This command runs the image as a container and creates a local endpoint at
            localhost:9000/2015-03-31/functions/function/invocations.
         NoteIf you built the Docker image for the ARM64 instruction set architecture, be sure to use the --platform linux/arm64 option instead of --platform linux/amd64.   
        
          Post an event to the local endpoint.
          
            Linux/macOS
      		      In Linux and macOS, run the following curl command:
                curl "http://localhost:9000/2015-03-31/functions/function/invocations" -d '{}'
                This command invokes the function with an empty event and returns a response. If you're using your own function code rather than the sample function code, you might want to invoke the function with a JSON payload. Example:
                curl "http://localhost:9000/2015-03-31/functions/function/invocations" -d '{"payload":"hello world!"}'
      		
            PowerShell
                In PowerShell, run the following Invoke-WebRequest command:
                Invoke-WebRequest -Uri "http://localhost:9000/2015-03-31/functions/function/invocations" -Method Post -Body '{}' -ContentType "application/json"
                This command invokes the function with an empty event and returns a response. If you're using your own function code rather than the sample function code, you might want to invoke the function with a JSON payload. Example:
                Invoke-WebRequest -Uri "http://localhost:9000/2015-03-31/functions/function/invocations" -Method Post -Body '{"payload":"hello world!"}' -ContentType "application/json"
              
          
        
          Get the container ID.
          docker ps
        
          Use the docker kill command to stop the container. In this command, replace 3766c4ab331c with the container ID from the previous step.
          docker kill 3766c4ab331c
        To upload the image to Amazon ECR and create the Lambda function
          Run the get-login-password command to authenticate the Docker CLI to your Amazon ECR registry.
        
         
         
        
          Set the --region value to the AWS Region where you want to create the Amazon ECR repository.
        
          Replace 111122223333 with your AWS account ID.
        
          aws ecr get-login-password --region us-east-1 | docker login --username AWS --password-stdin 111122223333.dkr.ecr.us-east-1.amazonaws.com
          
        
        Create a repository in Amazon ECR using the create-repository command.
        aws ecr create-repository --repository-name hello-world --region us-east-1 --image-scanning-configuration scanOnPush=true --image-tag-mutability MUTABLE
        
        NoteThe Amazon ECR repository must be in the same AWS Region as the Lambda function.
        If successful, you see a response like this:
        {
    "repository": {
        "repositoryArn": "arn:aws:ecr:us-east-1:111122223333:repository/hello-world",
        "registryId": "111122223333",
        "repositoryName": "hello-world",
        "repositoryUri": "111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world",
        "createdAt": "2023-03-09T10:39:01+00:00",
        "imageTagMutability": "MUTABLE",
        "imageScanningConfiguration": {
            "scanOnPush": true
        },
        "encryptionConfiguration": {
            "encryptionType": "AES256"
        }
    }
}
        
      
        Copy the repositoryUri from the output in the previous step.
      
        Run the docker tag command to tag your local image into your Amazon ECR repository as the latest version. In this command: 
        
         
         
        
          docker-image:test is the name and tag of your Docker image. This is the image name and tag that you specified in the docker build command.
        
          Replace <ECRrepositoryUri> with the repositoryUri that you copied. Make sure to include :latest at the end of the URI.
        
        docker tag docker-image:test <ECRrepositoryUri>:latest
      Example:
      docker tag docker-image:test 111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest
      
      
      Run the docker push command to deploy your local image to the Amazon ECR repository. Make sure to include :latest at the end of the repository URI.
docker push 111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest

      
      Create an execution role for the function, if you don't already have one. You need the Amazon Resource Name (ARN) of the role in the next step.
      
        Create the Lambda function. For ImageUri, specify the repository URI from earlier. Make sure to include :latest at the end of the URI.
		aws lambda create-function \
  --function-name hello-world \
  --package-type Image \
  --code ImageUri=111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest \
  --role arn:aws:iam::111122223333:role/lambda-ex
  		
      NoteYou can create a function using an image in a different AWS account, as long as the image is in the same Region as the Lambda function. For more information, see  Amazon ECR cross-account permissions.  
      
      Invoke the function.
      aws lambda invoke --function-name hello-world response.json
      You should see a response like this:
{
  "ExecutedVersion": "$LATEST", 
  "StatusCode": 200
}
    
    To see the output of the function, check the response.json file.
    To update the function code, you must build the image again, upload the new image to the Amazon ECR repository, and then use the update-function-code command to deploy the image to the Lambda function.Lambda resolves the image tag to a specific image digest. This means that if you point the image tag that was used to deploy the function to a new image in Amazon ECR, Lambda doesn't automatically update the function to use the new image.To deploy the new image to the same Lambda function, you must use the update-function-code command, even if the image tag in Amazon ECR remains the same. In the following example, the --publish option creates a new version of the function using the updated container image.aws lambda update-function-code \
  --function-name hello-world \
  --image-uri 111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest \
  --publish
  Document ConventionsDeploy .zip file archivesLayersDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideAWS base images for Node.jsUsing an AWS base imageUsing a non-AWS base imageDeploy Node.js Lambda functions with container imagesThere are three ways to build a container image for a Node.js Lambda function:
     
	 
     
  
      Using an AWS base image for Node.js
      The AWS base images are preloaded with a language runtime, a runtime interface client to manage the interaction between Lambda and your function code, and a runtime interface emulator for local testing.
    
      Using an AWS OS-only base image
      AWS OS-only base images contain an Amazon Linux distribution and the runtime interface emulator. These images are commonly used to create container images for compiled languages, such as Go and Rust, and for a language or language version that Lambda doesn't provide a base image for, such as Node.js 19. You can also use OS-only base images to implement a custom runtime. To make the image compatible with Lambda, you must include the runtime interface client for Node.js in the image.
    
      Using a non-AWS base image
      You can use an alternative base image from another container registry, such as Alpine Linux or Debian. You can also use a custom image created by your organization. To make the image compatible with Lambda, you must include the runtime interface client for Node.js in the image.
    TipTo reduce the time it takes for Lambda container functions to become active, see Use multi-stage builds in the Docker documentation. To build efficient container images, follow the Best practices for writing Dockerfiles.This page explains how to build, test, and deploy container images for Lambda.TopicsAWS base images for Node.jsUsing an AWS base image for Node.jsUsing an alternative base image with the runtime interface client
    AWS base images for Node.js
    AWS provides the following base images for Node.js:
      
    
    
          
            Tags
            Runtime
            Operating system
            Dockerfile
            Deprecation
          
        
      
            22
            Node.js 22
            Amazon Linux 2023
            Dockerfile
                for Node.js 22 on GitHub
            
                          Apr 30, 2027
            
              
          
      
            20
            Node.js 20
            Amazon Linux 2023
            Dockerfile
                for Node.js 20 on GitHub
            
                          Apr 30, 2026
            
              
          
      
            18
            Node.js 18
            Amazon Linux 2
            Dockerfile
                for Node.js 18 on GitHub
            
                          Sep 1, 2025
            
              
          
    

    Amazon ECR repository: gallery.ecr.aws/lambda/nodejs
    The Node.js 20 and later base images are based on the Amazon Linux 2023 minimal container image. Earlier base
      images use Amazon Linux 2. AL2023 provides several advantages over Amazon Linux 2, including a smaller deployment footprint
      and updated versions of libraries such as glibc.
    AL2023-based images use microdnf (symlinked as dnf) as the package manager instead of yum, which is the default package manager in Amazon Linux 2. microdnf is a standalone implementation of dnf. For a list of packages that are included in AL2023-based images, refer to the Minimal Container columns in Comparing packages installed on Amazon Linux 2023 Container Images. For more information about the differences between AL2023 and Amazon Linux 2, see Introducing the Amazon Linux 2023 runtime for AWS Lambda on the AWS
      Compute Blog.    
    NoteTo run AL2023-based images locally, including with AWS Serverless Application Model (AWS SAM), you must use Docker version 20.10.10 or later.  
   
    Using an AWS base image for Node.js
    To complete the steps in this section, you must have the following:
           
           
           
           
        
            AWS CLI version 2
          
            Docker (minimum version 25.0.0)
          
            The Docker buildx plugin.
          
              Node.js
          To create a container image from an AWS base image for Node.js
        Create a directory for the project, and then switch to that directory.
        mkdir example
cd example
      
        Create a new Node.js project with npm. To accept the default options provided in the interactive experience, press Enter.
        npm init
      
        Create a new file called index.js. You can add the following sample function code to the file for testing, or use your own.
        Example  CommonJS handlerexports.handler = async (event) => {
    const response = {
        statusCode: 200,
        body: JSON.stringify('Hello from Lambda!'),
    };
    return response;
};
      
        If your function depends on libraries other than the AWS SDK for JavaScript, use npm to add them to your package.
      
        Create a new Dockerfile with the following configuration:
        
           
           
           
        
            Set the FROM property to the URI of the base image.
          
            Use the COPY command to copy the function code and runtime dependencies to {LAMBDA_TASK_ROOT}, a Lambda-defined environment variable.
          
            Set the CMD argument to the Lambda function handler.
          
        Note that the example Dockerfile does not include a USER instruction. When you deploy a container image to Lambda, Lambda automatically defines a default Linux user with least-privileged permissions. This is different from standard Docker behavior which defaults to the root user when no USER instruction is provided.
        Example  DockerfileFROM public.ecr.aws/lambda/nodejs:22

# Copy function code
COPY index.js ${LAMBDA_TASK_ROOT}
  
# Set the CMD to your handler (could also be done as a parameter override outside of the Dockerfile)
CMD [ "index.handler" ]
      
        Build the Docker image with the docker build command. The
          following example names the image docker-image and gives it the test tag. To make your 
          image compatible with Lambda, you must use the --provenance=false option.
        docker buildx build --platform linux/amd64 --provenance=false -t docker-image:test .
        NoteThe command specifies the --platform linux/amd64 option to ensure that your container is compatible with the Lambda execution environment regardless of the  
       architecture of your build machine. If you intend to create a Lambda function using the ARM64 instruction set architecture, be sure to change the command to use the --platform linux/arm64 
       option instead.
      
          Start the Docker image with the docker run command. In this example,
              docker-image is the image name and test is the tag.
          docker run --platform linux/amd64 -p 9000:8080 docker-image:test
          This command runs the image as a container and creates a local endpoint at
            localhost:9000/2015-03-31/functions/function/invocations.
          NoteIf you built the Docker image for the ARM64 instruction set architecture, be sure to use the --platform linux/arm64 option instead of --platform linux/amd64. 
        
          From a new terminal window, post an event to the local endpoint.
          
            Linux/macOS
      		      In Linux and macOS, run the following curl command:
                curl "http://localhost:9000/2015-03-31/functions/function/invocations" -d '{}'
                This command invokes the function with an empty event and returns a response. If you're using your own function code rather than the sample function code, you might want to invoke the function with a JSON payload. Example:
                curl "http://localhost:9000/2015-03-31/functions/function/invocations" -d '{"payload":"hello world!"}'
      		
            PowerShell
                In PowerShell, run the following Invoke-WebRequest command:
                Invoke-WebRequest -Uri "http://localhost:9000/2015-03-31/functions/function/invocations" -Method Post -Body '{}' -ContentType "application/json"
                This command invokes the function with an empty event and returns a response. If you're using your own function code rather than the sample function code, you might want to invoke the function with a JSON payload. Example:
                Invoke-WebRequest -Uri "http://localhost:9000/2015-03-31/functions/function/invocations" -Method Post -Body '{"payload":"hello world!"}' -ContentType "application/json"
              
          
        
          Get the container ID.
          docker ps
        
          Use the docker kill command to stop the container. In this command, replace 3766c4ab331c with the container ID from the previous step.
          docker kill 3766c4ab331c
        To upload the image to Amazon ECR and create the Lambda function
          Run the get-login-password command to authenticate the Docker CLI to your Amazon ECR registry.
        
         
         
        
          Set the --region value to the AWS Region where you want to create the Amazon ECR repository.
        
          Replace 111122223333 with your AWS account ID.
        
          aws ecr get-login-password --region us-east-1 | docker login --username AWS --password-stdin 111122223333.dkr.ecr.us-east-1.amazonaws.com
          
        
        Create a repository in Amazon ECR using the create-repository command.
        aws ecr create-repository --repository-name hello-world --region us-east-1 --image-scanning-configuration scanOnPush=true --image-tag-mutability MUTABLE
        
        NoteThe Amazon ECR repository must be in the same AWS Region as the Lambda function.
        If successful, you see a response like this:
        {
    "repository": {
        "repositoryArn": "arn:aws:ecr:us-east-1:111122223333:repository/hello-world",
        "registryId": "111122223333",
        "repositoryName": "hello-world",
        "repositoryUri": "111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world",
        "createdAt": "2023-03-09T10:39:01+00:00",
        "imageTagMutability": "MUTABLE",
        "imageScanningConfiguration": {
            "scanOnPush": true
        },
        "encryptionConfiguration": {
            "encryptionType": "AES256"
        }
    }
}
        
      
        Copy the repositoryUri from the output in the previous step.
      
        Run the docker tag command to tag your local image into your Amazon ECR repository as the latest version. In this command: 
        
         
         
        
          docker-image:test is the name and tag of your Docker image. This is the image name and tag that you specified in the docker build command.
        
          Replace <ECRrepositoryUri> with the repositoryUri that you copied. Make sure to include :latest at the end of the URI.
        
        docker tag docker-image:test <ECRrepositoryUri>:latest
      Example:
      docker tag docker-image:test 111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest
      
      
      Run the docker push command to deploy your local image to the Amazon ECR repository. Make sure to include :latest at the end of the repository URI.
docker push 111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest

      
      Create an execution role for the function, if you don't already have one. You need the Amazon Resource Name (ARN) of the role in the next step.
      
        Create the Lambda function. For ImageUri, specify the repository URI from earlier. Make sure to include :latest at the end of the URI.
		aws lambda create-function \
  --function-name hello-world \
  --package-type Image \
  --code ImageUri=111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest \
  --role arn:aws:iam::111122223333:role/lambda-ex
  		
      NoteYou can create a function using an image in a different AWS account, as long as the image is in the same Region as the Lambda function. For more information, see  Amazon ECR cross-account permissions.  
      
      Invoke the function.
      aws lambda invoke --function-name hello-world response.json
      You should see a response like this:
{
  "ExecutedVersion": "$LATEST", 
  "StatusCode": 200
}
    
    To see the output of the function, check the response.json file.
    To update the function code, you must build the image again, upload the new image to the Amazon ECR repository, and then use the update-function-code command to deploy the image to the Lambda function.Lambda resolves the image tag to a specific image digest. This means that if you point the image tag that was used to deploy the function to a new image in Amazon ECR, Lambda doesn't automatically update the function to use the new image.To deploy the new image to the same Lambda function, you must use the update-function-code command, even if the image tag in Amazon ECR remains the same. In the following example, the --publish option creates a new version of the function using the updated container image.aws lambda update-function-code \
  --function-name hello-world \
  --image-uri 111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest \
  --publish
 
    Using an alternative base image with the runtime interface client
    If you use an OS-only base image or an alternative base image, you must include the runtime interface client in your image. The runtime interface client extends the Runtime API, which manages the interaction between Lambda and your function code.
    Install the Node.js runtime interface client using the npm package manager:
    npm install aws-lambda-ric
    You can also download the Node.js runtime interface client from GitHub. 
    The following example demonstrates how to build a container image for Node.js using a non-AWS base image. The example Dockerfile uses a buster base image. The Dockerfile includes the runtime interface client.
        To complete the steps in this section, you must have the following:
           
           
           
           
        
            AWS CLI version 2
          
            Docker (minimum version 25.0.0)
          
            The Docker buildx plugin.
          
              Node.js
          To create a container image from a non-AWS base image
        Create a directory for the project, and then switch to that directory.
        mkdir example
cd example
      
        Create a new Node.js project with npm. To accept the default options provided in the interactive experience, press Enter.
        npm init
      
        Create a new file called index.js. You can add the following sample function code to the file for testing, or use your own.
        Example  CommonJS handlerexports.handler = async (event) => {
    const response = {
        statusCode: 200,
        body: JSON.stringify('Hello from Lambda!'),
    };
    return response;
};
      
        Create a new Dockerfile. The following Dockerfile uses a buster base image instead of an AWS base image. The Dockerfile includes the runtime interface client, which makes the image compatible with Lambda. The Dockerfile uses a multi-stage build. The first stage creates a build image, which is a standard Node.js environment where the function's dependencies are installed. The second stage creates a slimmer image which includes the function code and its dependencies. This reduces the final image size.
        
           
           
          
           
        
            Set the FROM property to the base image identifier.
          
            Use the COPY command to copy the function code and runtime dependencies.
          
            Set the ENTRYPOINT to the module that you want the Docker container to run when it starts. In this case, the module is the runtime interface client.
          
            Set the CMD argument to the Lambda function handler.
          
        Note that the example Dockerfile does not include a USER instruction. When you deploy a container image to Lambda, Lambda automatically defines a default Linux user with least-privileged permissions. This is different from standard Docker behavior which defaults to the root user when no USER instruction is provided.
        Example  Dockerfile# Define custom function directory
ARG FUNCTION_DIR="/function"

FROM node:20-buster as build-image

# Include global arg in this stage of the build
ARG FUNCTION_DIR

# Install build dependencies
RUN apt-get update && \
    apt-get install -y \
    g++ \
    make \
    cmake \
    unzip \
    libcurl4-openssl-dev

# Copy function code
RUN mkdir -p ${FUNCTION_DIR}
COPY . ${FUNCTION_DIR}

WORKDIR ${FUNCTION_DIR}

# Install Node.js dependencies
RUN npm install

# Install the runtime interface client
RUN npm install aws-lambda-ric

# Grab a fresh slim copy of the image to reduce the final size
FROM node:20-buster-slim

# Required for Node runtimes which use npm@8.6.0+ because
# by default npm writes logs under /home/.npm and Lambda fs is read-only
ENV NPM_CONFIG_CACHE=/tmp/.npm

# Include global arg in this stage of the build
ARG FUNCTION_DIR

# Set working directory to function root directory
WORKDIR ${FUNCTION_DIR}

# Copy in the built dependencies
COPY --from=build-image ${FUNCTION_DIR} ${FUNCTION_DIR}

# Set runtime interface client as default command for the container runtime
ENTRYPOINT ["/usr/local/bin/npx", "aws-lambda-ric"]
# Pass the name of the function handler as an argument to the runtime
CMD ["index.handler"]
      
        Build the Docker image with the docker build command. The
          following example names the image docker-image and gives it the test tag. To make your 
          image compatible with Lambda, you must use the --provenance=false option.
        docker buildx build --platform linux/amd64 --provenance=false -t docker-image:test .
        NoteThe command specifies the --platform linux/amd64 option to ensure that your container is compatible with the Lambda execution environment regardless of the  
       architecture of your build machine. If you intend to create a Lambda function using the ARM64 instruction set architecture, be sure to change the command to use the --platform linux/arm64 
       option instead.
      Use the runtime interface emulator to locally test the image. You can build the emulator into your image or use the following procedure to install it on your local machine.To install and run the runtime interface emulator on your local machine
          From your project directory, run the following command to download the runtime interface emulator (x86-64 architecture) from GitHub and install it on your local machine.
          
            Linux/macOS
          mkdir -p ~/.aws-lambda-rie && \
    curl -Lo ~/.aws-lambda-rie/aws-lambda-rie https://github.com/aws/aws-lambda-runtime-interface-emulator/releases/latest/download/aws-lambda-rie && \
    chmod +x ~/.aws-lambda-rie/aws-lambda-rie
      			  To install the arm64 emulator, replace the GitHub repository URL in the previous command with the following:
      			https://github.com/aws/aws-lambda-runtime-interface-emulator/releases/latest/download/aws-lambda-rie-arm64
      		
            PowerShell
      				  $dirPath = "$HOME\.aws-lambda-rie"
if (-not (Test-Path $dirPath)) {
    New-Item -Path $dirPath -ItemType Directory
}
      
$downloadLink = "https://github.com/aws/aws-lambda-runtime-interface-emulator/releases/latest/download/aws-lambda-rie"
$destinationPath = "$HOME\.aws-lambda-rie\aws-lambda-rie"
Invoke-WebRequest -Uri $downloadLink -OutFile $destinationPath
      				  To install the arm64 emulator, replace the $downloadLink with the following:
      				https://github.com/aws/aws-lambda-runtime-interface-emulator/releases/latest/download/aws-lambda-rie-arm64
              
          
        
          Start the Docker image with the docker run command. Note the following:
          
             
             
          
            docker-image is the image name and test is the tag.
            
            /usr/local/bin/npx aws-lambda-ric index.handler is the ENTRYPOINT followed by the CMD from your Dockerfile.
            
          
            Linux/macOS
				    docker run --platform linux/amd64 -d -v ~/.aws-lambda-rie:/aws-lambda -p 9000:8080 \
    --entrypoint /aws-lambda/aws-lambda-rie \
    docker-image:test \
        /usr/local/bin/npx aws-lambda-ric index.handler
      		
            PowerShell
				        docker run --platform linux/amd64 -d -v "$HOME\.aws-lambda-rie:/aws-lambda" -p 9000:8080 `
--entrypoint /aws-lambda/aws-lambda-rie `
docker-image:test `
    /usr/local/bin/npx aws-lambda-ric index.handler
				    
          
          This command runs the image as a container and creates a local endpoint at
            localhost:9000/2015-03-31/functions/function/invocations.
         NoteIf you built the Docker image for the ARM64 instruction set architecture, be sure to use the --platform linux/arm64 option instead of --platform linux/amd64.   
        
          Post an event to the local endpoint.
          
            Linux/macOS
      		      In Linux and macOS, run the following curl command:
                curl "http://localhost:9000/2015-03-31/functions/function/invocations" -d '{}'
                This command invokes the function with an empty event and returns a response. If you're using your own function code rather than the sample function code, you might want to invoke the function with a JSON payload. Example:
                curl "http://localhost:9000/2015-03-31/functions/function/invocations" -d '{"payload":"hello world!"}'
      		
            PowerShell
                In PowerShell, run the following Invoke-WebRequest command:
                Invoke-WebRequest -Uri "http://localhost:9000/2015-03-31/functions/function/invocations" -Method Post -Body '{}' -ContentType "application/json"
                This command invokes the function with an empty event and returns a response. If you're using your own function code rather than the sample function code, you might want to invoke the function with a JSON payload. Example:
                Invoke-WebRequest -Uri "http://localhost:9000/2015-03-31/functions/function/invocations" -Method Post -Body '{"payload":"hello world!"}' -ContentType "application/json"
              
          
        
          Get the container ID.
          docker ps
        
          Use the docker kill command to stop the container. In this command, replace 3766c4ab331c with the container ID from the previous step.
          docker kill 3766c4ab331c
        To upload the image to Amazon ECR and create the Lambda function
          Run the get-login-password command to authenticate the Docker CLI to your Amazon ECR registry.
        
         
         
        
          Set the --region value to the AWS Region where you want to create the Amazon ECR repository.
        
          Replace 111122223333 with your AWS account ID.
        
          aws ecr get-login-password --region us-east-1 | docker login --username AWS --password-stdin 111122223333.dkr.ecr.us-east-1.amazonaws.com
          
        
        Create a repository in Amazon ECR using the create-repository command.
        aws ecr create-repository --repository-name hello-world --region us-east-1 --image-scanning-configuration scanOnPush=true --image-tag-mutability MUTABLE
        
        NoteThe Amazon ECR repository must be in the same AWS Region as the Lambda function.
        If successful, you see a response like this:
        {
    "repository": {
        "repositoryArn": "arn:aws:ecr:us-east-1:111122223333:repository/hello-world",
        "registryId": "111122223333",
        "repositoryName": "hello-world",
        "repositoryUri": "111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world",
        "createdAt": "2023-03-09T10:39:01+00:00",
        "imageTagMutability": "MUTABLE",
        "imageScanningConfiguration": {
            "scanOnPush": true
        },
        "encryptionConfiguration": {
            "encryptionType": "AES256"
        }
    }
}
        
      
        Copy the repositoryUri from the output in the previous step.
      
        Run the docker tag command to tag your local image into your Amazon ECR repository as the latest version. In this command: 
        
         
         
        
          docker-image:test is the name and tag of your Docker image. This is the image name and tag that you specified in the docker build command.
        
          Replace <ECRrepositoryUri> with the repositoryUri that you copied. Make sure to include :latest at the end of the URI.
        
        docker tag docker-image:test <ECRrepositoryUri>:latest
      Example:
      docker tag docker-image:test 111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest
      
      
      Run the docker push command to deploy your local image to the Amazon ECR repository. Make sure to include :latest at the end of the repository URI.
docker push 111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest

      
      Create an execution role for the function, if you don't already have one. You need the Amazon Resource Name (ARN) of the role in the next step.
      
        Create the Lambda function. For ImageUri, specify the repository URI from earlier. Make sure to include :latest at the end of the URI.
		aws lambda create-function \
  --function-name hello-world \
  --package-type Image \
  --code ImageUri=111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest \
  --role arn:aws:iam::111122223333:role/lambda-ex
  		
      NoteYou can create a function using an image in a different AWS account, as long as the image is in the same Region as the Lambda function. For more information, see  Amazon ECR cross-account permissions.  
      
      Invoke the function.
      aws lambda invoke --function-name hello-world response.json
      You should see a response like this:
{
  "ExecutedVersion": "$LATEST", 
  "StatusCode": 200
}
    
    To see the output of the function, check the response.json file.
    To update the function code, you must build the image again, upload the new image to the Amazon ECR repository, and then use the update-function-code command to deploy the image to the Lambda function.Lambda resolves the image tag to a specific image digest. This means that if you point the image tag that was used to deploy the function to a new image in Amazon ECR, Lambda doesn't automatically update the function to use the new image.To deploy the new image to the same Lambda function, you must use the update-function-code command, even if the image tag in Amazon ECR remains the same. In the following example, the --publish option creates a new version of the function using the updated container image.aws lambda update-function-code \
  --function-name hello-world \
  --image-uri 111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest \
  --publish
  Document ConventionsDeploy .zip file archivesLayersDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideAWS base images for PythonUsing an AWS base imageUsing a non-AWS base imageDeploy Python Lambda functions with container imagesThere are three ways to build a container image for a Python Lambda function:
     
	 
     
  
      Using an AWS base image for Python
      The AWS base images are preloaded with a language runtime, a runtime interface client to manage the interaction between Lambda and your function code, and a runtime interface emulator for local testing.
    
      Using an AWS OS-only base image
      AWS OS-only base images contain an Amazon Linux distribution and the runtime interface emulator. These images are commonly used to create container images for compiled languages, such as Go and Rust, and for a language or language version that Lambda doesn't provide a base image for, such as Node.js 19. You can also use OS-only base images to implement a custom runtime. To make the image compatible with Lambda, you must include the runtime interface client for Python in the image.
    
      Using a non-AWS base image
      You can use an alternative base image from another container registry, such as Alpine Linux or Debian. You can also use a custom image created by your organization. To make the image compatible with Lambda, you must include the runtime interface client for Python in the image.
    TipTo reduce the time it takes for Lambda container functions to become active, see Use multi-stage builds in the Docker documentation. To build efficient container images, follow the Best practices for writing Dockerfiles.This page explains how to build, test, and deploy container images for Lambda.TopicsAWS base images for PythonUsing an AWS base image for PythonUsing an alternative base image with the runtime interface client
    AWS base images for Python
    AWS provides the following base images for Python:
    
    
    
          
            Tags
            Runtime
            Operating system
            Dockerfile
            Deprecation
          
        
      
            3.13
            Python 3.13
            Amazon Linux 2023
            Dockerfile
                for Python 3.13 on GitHub
            
                          Jun 30, 2029
            
              
          
      
            3.12
            Python 3.12
            Amazon Linux 2023
            Dockerfile
                for Python 3.12 on GitHub
            
                          Oct 31, 2028
            
              
          
      
            3.11
            Python 3.11
            Amazon Linux 2
            Dockerfile
                for Python 3.11 on GitHub
            
                          Jun 30, 2026
            
              
          
      
            3.10
            Python 3.10
            Amazon Linux 2
            Dockerfile
                for Python 3.10 on GitHub
            
                          Jun 30, 2026
            
              
          
      
            3.9
            Python 3.9
            Amazon Linux 2
            Dockerfile
                for Python 3.9 on GitHub
            
                          Nov 3, 2025
            
              
          
     
    Amazon ECR repository: gallery.ecr.aws/lambda/python
    Python 3.12 and later base images are based on the Amazon Linux 2023 minimal container image. The Python 3.8-3.11 base images are based on the Amazon Linux 2 image. AL2023-based images provide several advantages over Amazon Linux 2, including a smaller deployment footprint and updated versions of libraries such as glibc.
    AL2023-based images use microdnf (symlinked as dnf) as the package manager instead of yum, which is the default package manager in Amazon Linux 2. microdnf is a standalone implementation of dnf. For a list of packages that are included in AL2023-based images, refer to the Minimal Container columns in Comparing packages installed on Amazon Linux 2023 Container Images. For more information about the differences between AL2023 and Amazon Linux 2, see Introducing the Amazon Linux 2023 runtime for AWS Lambda on the AWS
      Compute Blog.    
    NoteTo run AL2023-based images locally, including with AWS Serverless Application Model (AWS SAM), you must use Docker version 20.10.10 or later.
     
      Dependency search path in the base images
      When you use an import statement in your code, the Python runtime searches the directories in its search path until it finds the module or package. By default, the runtime searches the {LAMBDA_TASK_ROOT} directory first. If you include a version of a runtime-included library in your image, your version will take precedence over the version that's included in the runtime.
      Other steps in the search path depend on which version of the Lambda base image for Python you're
        using:
      
         
         
      
          Python 3.11 and later: Runtime-included libraries and pip-installed libraries are installed in the /var/lang/lib/python3.11/site-packages directory. This directory has precedence over /var/runtime in the search path. You can override the SDK by using pip to install a newer version. You can use pip to verify that the runtime-included SDK and its dependencies are compatible with any packages that you install.
        
          Python 3.8-3.10: Runtime-included libraries are installed in the /var/runtime directory. Pip-installed libraries are installed in the /var/lang/lib/python3.x/site-packages directory. The /var/runtime directory has precedence over /var/lang/lib/python3.x/site-packages in the search path.
        
      You can see the full search path for your Lambda function by adding the following code snippet.
      import sys
      
search_path = sys.path
print(search_path)
      
   
    Using an AWS base image for Python
    To complete the steps in this section, you must have the following:
          
           
           
           
        
            AWS CLI version 2
          
            Docker (minimum version 25.0.0)
          
            The Docker buildx plugin.
          
              Python
          To create a container image from an AWS base image for Python
        Create a directory for the project, and then switch to that directory.
        mkdir example
cd example
      
        Create a new file called lambda_function.py. You can add the following sample function code to the file for testing, or use your own.
        Example  Python functionimport sys
def handler(event, context):
    return 'Hello from AWS Lambda using Python' + sys.version + '!'
      
        Create a new file called requirements.txt. If you're using the sample function code from the previous step, you can leave the file empty because there are no dependencies. Otherwise, list each required library. For example, here's what your requirements.txt should look like if your function uses the AWS SDK for Python (Boto3):
		Example  requirements.txtboto3
      
        Create a new Dockerfile with the following configuration:
        
           
           
           
        
            Set the FROM property to the URI of the base image.
          
            Use the COPY command to copy the function code and runtime dependencies to {LAMBDA_TASK_ROOT}, a Lambda-defined environment variable.
          
            Set the CMD argument to the Lambda function handler.
          
        Note that the example Dockerfile does not include a USER instruction. When you deploy a container image to Lambda, Lambda automatically defines a default Linux user with least-privileged permissions. This is different from standard Docker behavior which defaults to the root user when no USER instruction is provided.
        Example  DockerfileFROM public.ecr.aws/lambda/python:3.12

# Copy requirements.txt
COPY requirements.txt ${LAMBDA_TASK_ROOT}

# Install the specified packages
RUN pip install -r requirements.txt

# Copy function code
COPY lambda_function.py ${LAMBDA_TASK_ROOT}

# Set the CMD to your handler (could also be done as a parameter override outside of the Dockerfile)
CMD [ "lambda_function.handler" ]
      
        Build the Docker image with the docker build command. The
          following example names the image docker-image and gives it the test tag. To make your 
          image compatible with Lambda, you must use the --provenance=false option.
        docker buildx build --platform linux/amd64 --provenance=false -t docker-image:test .
        NoteThe command specifies the --platform linux/amd64 option to ensure that your container is compatible with the Lambda execution environment regardless of the  
       architecture of your build machine. If you intend to create a Lambda function using the ARM64 instruction set architecture, be sure to change the command to use the --platform linux/arm64 
       option instead.
      
          Start the Docker image with the docker run command. In this example,
              docker-image is the image name and test is the tag.
          docker run --platform linux/amd64 -p 9000:8080 docker-image:test
          This command runs the image as a container and creates a local endpoint at
            localhost:9000/2015-03-31/functions/function/invocations.
          NoteIf you built the Docker image for the ARM64 instruction set architecture, be sure to use the --platform linux/arm64 option instead of --platform linux/amd64. 
        
          From a new terminal window, post an event to the local endpoint.
          
            Linux/macOS
      		      In Linux and macOS, run the following curl command:
                curl "http://localhost:9000/2015-03-31/functions/function/invocations" -d '{}'
                This command invokes the function with an empty event and returns a response. If you're using your own function code rather than the sample function code, you might want to invoke the function with a JSON payload. Example:
                curl "http://localhost:9000/2015-03-31/functions/function/invocations" -d '{"payload":"hello world!"}'
      		
            PowerShell
                In PowerShell, run the following Invoke-WebRequest command:
                Invoke-WebRequest -Uri "http://localhost:9000/2015-03-31/functions/function/invocations" -Method Post -Body '{}' -ContentType "application/json"
                This command invokes the function with an empty event and returns a response. If you're using your own function code rather than the sample function code, you might want to invoke the function with a JSON payload. Example:
                Invoke-WebRequest -Uri "http://localhost:9000/2015-03-31/functions/function/invocations" -Method Post -Body '{"payload":"hello world!"}' -ContentType "application/json"
              
          
        
          Get the container ID.
          docker ps
        
          Use the docker kill command to stop the container. In this command, replace 3766c4ab331c with the container ID from the previous step.
          docker kill 3766c4ab331c
        To upload the image to Amazon ECR and create the Lambda function
          Run the get-login-password command to authenticate the Docker CLI to your Amazon ECR registry.
        
         
         
        
          Set the --region value to the AWS Region where you want to create the Amazon ECR repository.
        
          Replace 111122223333 with your AWS account ID.
        
          aws ecr get-login-password --region us-east-1 | docker login --username AWS --password-stdin 111122223333.dkr.ecr.us-east-1.amazonaws.com
          
        
        Create a repository in Amazon ECR using the create-repository command.
        aws ecr create-repository --repository-name hello-world --region us-east-1 --image-scanning-configuration scanOnPush=true --image-tag-mutability MUTABLE
        
        NoteThe Amazon ECR repository must be in the same AWS Region as the Lambda function.
        If successful, you see a response like this:
        {
    "repository": {
        "repositoryArn": "arn:aws:ecr:us-east-1:111122223333:repository/hello-world",
        "registryId": "111122223333",
        "repositoryName": "hello-world",
        "repositoryUri": "111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world",
        "createdAt": "2023-03-09T10:39:01+00:00",
        "imageTagMutability": "MUTABLE",
        "imageScanningConfiguration": {
            "scanOnPush": true
        },
        "encryptionConfiguration": {
            "encryptionType": "AES256"
        }
    }
}
        
      
        Copy the repositoryUri from the output in the previous step.
      
        Run the docker tag command to tag your local image into your Amazon ECR repository as the latest version. In this command: 
        
         
         
        
          docker-image:test is the name and tag of your Docker image. This is the image name and tag that you specified in the docker build command.
        
          Replace <ECRrepositoryUri> with the repositoryUri that you copied. Make sure to include :latest at the end of the URI.
        
        docker tag docker-image:test <ECRrepositoryUri>:latest
      Example:
      docker tag docker-image:test 111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest
      
      
      Run the docker push command to deploy your local image to the Amazon ECR repository. Make sure to include :latest at the end of the repository URI.
docker push 111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest

      
      Create an execution role for the function, if you don't already have one. You need the Amazon Resource Name (ARN) of the role in the next step.
      
        Create the Lambda function. For ImageUri, specify the repository URI from earlier. Make sure to include :latest at the end of the URI.
		aws lambda create-function \
  --function-name hello-world \
  --package-type Image \
  --code ImageUri=111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest \
  --role arn:aws:iam::111122223333:role/lambda-ex
  		
      NoteYou can create a function using an image in a different AWS account, as long as the image is in the same Region as the Lambda function. For more information, see  Amazon ECR cross-account permissions.  
      
      Invoke the function.
      aws lambda invoke --function-name hello-world response.json
      You should see a response like this:
{
  "ExecutedVersion": "$LATEST", 
  "StatusCode": 200
}
    
    To see the output of the function, check the response.json file.
    To update the function code, you must build the image again, upload the new image to the Amazon ECR repository, and then use the update-function-code command to deploy the image to the Lambda function.Lambda resolves the image tag to a specific image digest. This means that if you point the image tag that was used to deploy the function to a new image in Amazon ECR, Lambda doesn't automatically update the function to use the new image.To deploy the new image to the same Lambda function, you must use the update-function-code command, even if the image tag in Amazon ECR remains the same. In the following example, the --publish option creates a new version of the function using the updated container image.aws lambda update-function-code \
  --function-name hello-world \
  --image-uri 111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest \
  --publish 
 
    Using an alternative base image with the runtime interface client
    If you use an OS-only base image or an alternative base image, you must include the runtime interface client in your image. The runtime interface client extends the Runtime API, which manages the interaction between Lambda and your function code.
    Install the the runtime interface client for Python using the pip package manager:
    pip install awslambdaric
    You can also download the Python runtime interface client from GitHub.
    The following example demonstrates how to build a container image for Python using a non-AWS base image. The example Dockerfile uses an official Python base image. The Dockerfile includes the runtime interface client for Python.
    To complete the steps in this section, you must have the following:
          
           
           
           
        
            AWS CLI version 2
          
            Docker (minimum version 25.0.0)
          
            The Docker buildx plugin.
          
              Python
          To create a container image from a non-AWS base image
        Create a directory for the project, and then switch to that directory.
        mkdir example
cd example
      
        Create a new file called lambda_function.py. You can add the following sample function code to the file for testing, or use your own.
        Example  Python functionimport sys
def handler(event, context):
    return 'Hello from AWS Lambda using Python' + sys.version + '!'
      
        Create a new file called requirements.txt. If you're using the sample function code from the previous step, you can leave the file empty because there are no dependencies. Otherwise, list each required library. For example, here's what your requirements.txt should look like if your function uses the AWS SDK for Python (Boto3):
		Example  requirements.txtboto3
      
        Create a new Dockerfile. The following Dockerfile uses an official Python base image instead of an AWS base image. The Dockerfile includes the runtime interface client, which makes the image compatible with Lambda. The following example Dockerfile uses a multi-stage build.
        
           
           
           
        
            Set the FROM property to the base image.
          
            Set the ENTRYPOINT to the module that you want the Docker container to run when it starts. In this case, the module is the runtime interface client.
          
            Set the CMD to the Lambda function handler.
          
        Note that the example Dockerfile does not include a USER instruction. When you deploy a container image to Lambda, Lambda automatically defines a default Linux user with least-privileged permissions. This is different from standard Docker behavior which defaults to the root user when no USER instruction is provided.
        Example  Dockerfile# Define custom function directory
ARG FUNCTION_DIR="/function"

FROM python:3.12 AS build-image

# Include global arg in this stage of the build
ARG FUNCTION_DIR

# Copy function code
RUN mkdir -p ${FUNCTION_DIR}
COPY . ${FUNCTION_DIR}

# Install the function's dependencies
RUN pip install \
    --target ${FUNCTION_DIR} \
        awslambdaric

# Use a slim version of the base Python image to reduce the final image size
FROM python:3.12-slim

# Include global arg in this stage of the build
ARG FUNCTION_DIR
# Set working directory to function root directory
WORKDIR ${FUNCTION_DIR}

# Copy in the built dependencies
COPY --from=build-image ${FUNCTION_DIR} ${FUNCTION_DIR}

# Set runtime interface client as default command for the container runtime
ENTRYPOINT [ "/usr/local/bin/python", "-m", "awslambdaric" ]
# Pass the name of the function handler as an argument to the runtime
CMD [ "lambda_function.handler" ]
      
        Build the Docker image with the docker build command. The
          following example names the image docker-image and gives it the test tag. To make your 
          image compatible with Lambda, you must use the --provenance=false option.
        docker buildx build --platform linux/amd64 --provenance=false -t docker-image:test .
        NoteThe command specifies the --platform linux/amd64 option to ensure that your container is compatible with the Lambda execution environment regardless of the  
       architecture of your build machine. If you intend to create a Lambda function using the ARM64 instruction set architecture, be sure to change the command to use the --platform linux/arm64 
       option instead.
      Use the runtime interface emulator to locally test the image. You can build the emulator into your image or use the following procedure to install it on your local machine.To install and run the runtime interface emulator on your local machine
          From your project directory, run the following command to download the runtime interface emulator (x86-64 architecture) from GitHub and install it on your local machine.
          
            Linux/macOS
          mkdir -p ~/.aws-lambda-rie && \
    curl -Lo ~/.aws-lambda-rie/aws-lambda-rie https://github.com/aws/aws-lambda-runtime-interface-emulator/releases/latest/download/aws-lambda-rie && \
    chmod +x ~/.aws-lambda-rie/aws-lambda-rie
      			  To install the arm64 emulator, replace the GitHub repository URL in the previous command with the following:
      			https://github.com/aws/aws-lambda-runtime-interface-emulator/releases/latest/download/aws-lambda-rie-arm64
      		
            PowerShell
      				  $dirPath = "$HOME\.aws-lambda-rie"
if (-not (Test-Path $dirPath)) {
    New-Item -Path $dirPath -ItemType Directory
}
      
$downloadLink = "https://github.com/aws/aws-lambda-runtime-interface-emulator/releases/latest/download/aws-lambda-rie"
$destinationPath = "$HOME\.aws-lambda-rie\aws-lambda-rie"
Invoke-WebRequest -Uri $downloadLink -OutFile $destinationPath
      				  To install the arm64 emulator, replace the $downloadLink with the following:
      				https://github.com/aws/aws-lambda-runtime-interface-emulator/releases/latest/download/aws-lambda-rie-arm64
              
          
        
          Start the Docker image with the docker run command. Note the following:
          
             
             
          
            docker-image is the image name and test is the tag.
            
            /usr/local/bin/python -m awslambdaric lambda_function.handler is the ENTRYPOINT followed by the CMD from your Dockerfile.
            
          
            Linux/macOS
				    docker run --platform linux/amd64 -d -v ~/.aws-lambda-rie:/aws-lambda -p 9000:8080 \
    --entrypoint /aws-lambda/aws-lambda-rie \
    docker-image:test \
        /usr/local/bin/python -m awslambdaric lambda_function.handler
      		
            PowerShell
				        docker run --platform linux/amd64 -d -v "$HOME\.aws-lambda-rie:/aws-lambda" -p 9000:8080 `
--entrypoint /aws-lambda/aws-lambda-rie `
docker-image:test `
    /usr/local/bin/python -m awslambdaric lambda_function.handler
				    
          
          This command runs the image as a container and creates a local endpoint at
            localhost:9000/2015-03-31/functions/function/invocations.
         NoteIf you built the Docker image for the ARM64 instruction set architecture, be sure to use the --platform linux/arm64 option instead of --platform linux/amd64.   
        
          Post an event to the local endpoint.
          
            Linux/macOS
      		      In Linux and macOS, run the following curl command:
                curl "http://localhost:9000/2015-03-31/functions/function/invocations" -d '{}'
                This command invokes the function with an empty event and returns a response. If you're using your own function code rather than the sample function code, you might want to invoke the function with a JSON payload. Example:
                curl "http://localhost:9000/2015-03-31/functions/function/invocations" -d '{"payload":"hello world!"}'
      		
            PowerShell
                In PowerShell, run the following Invoke-WebRequest command:
                Invoke-WebRequest -Uri "http://localhost:9000/2015-03-31/functions/function/invocations" -Method Post -Body '{}' -ContentType "application/json"
                This command invokes the function with an empty event and returns a response. If you're using your own function code rather than the sample function code, you might want to invoke the function with a JSON payload. Example:
                Invoke-WebRequest -Uri "http://localhost:9000/2015-03-31/functions/function/invocations" -Method Post -Body '{"payload":"hello world!"}' -ContentType "application/json"
              
          
        
          Get the container ID.
          docker ps
        
          Use the docker kill command to stop the container. In this command, replace 3766c4ab331c with the container ID from the previous step.
          docker kill 3766c4ab331c
        To upload the image to Amazon ECR and create the Lambda function
          Run the get-login-password command to authenticate the Docker CLI to your Amazon ECR registry.
        
         
         
        
          Set the --region value to the AWS Region where you want to create the Amazon ECR repository.
        
          Replace 111122223333 with your AWS account ID.
        
          aws ecr get-login-password --region us-east-1 | docker login --username AWS --password-stdin 111122223333.dkr.ecr.us-east-1.amazonaws.com
          
        
        Create a repository in Amazon ECR using the create-repository command.
        aws ecr create-repository --repository-name hello-world --region us-east-1 --image-scanning-configuration scanOnPush=true --image-tag-mutability MUTABLE
        
        NoteThe Amazon ECR repository must be in the same AWS Region as the Lambda function.
        If successful, you see a response like this:
        {
    "repository": {
        "repositoryArn": "arn:aws:ecr:us-east-1:111122223333:repository/hello-world",
        "registryId": "111122223333",
        "repositoryName": "hello-world",
        "repositoryUri": "111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world",
        "createdAt": "2023-03-09T10:39:01+00:00",
        "imageTagMutability": "MUTABLE",
        "imageScanningConfiguration": {
            "scanOnPush": true
        },
        "encryptionConfiguration": {
            "encryptionType": "AES256"
        }
    }
}
        
      
        Copy the repositoryUri from the output in the previous step.
      
        Run the docker tag command to tag your local image into your Amazon ECR repository as the latest version. In this command: 
        
         
         
        
          docker-image:test is the name and tag of your Docker image. This is the image name and tag that you specified in the docker build command.
        
          Replace <ECRrepositoryUri> with the repositoryUri that you copied. Make sure to include :latest at the end of the URI.
        
        docker tag docker-image:test <ECRrepositoryUri>:latest
      Example:
      docker tag docker-image:test 111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest
      
      
      Run the docker push command to deploy your local image to the Amazon ECR repository. Make sure to include :latest at the end of the repository URI.
docker push 111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest

      
      Create an execution role for the function, if you don't already have one. You need the Amazon Resource Name (ARN) of the role in the next step.
      
        Create the Lambda function. For ImageUri, specify the repository URI from earlier. Make sure to include :latest at the end of the URI.
		aws lambda create-function \
  --function-name hello-world \
  --package-type Image \
  --code ImageUri=111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest \
  --role arn:aws:iam::111122223333:role/lambda-ex
  		
      NoteYou can create a function using an image in a different AWS account, as long as the image is in the same Region as the Lambda function. For more information, see  Amazon ECR cross-account permissions.  
      
      Invoke the function.
      aws lambda invoke --function-name hello-world response.json
      You should see a response like this:
{
  "ExecutedVersion": "$LATEST", 
  "StatusCode": 200
}
    
    To see the output of the function, check the response.json file.
    To update the function code, you must build the image again, upload the new image to the Amazon ECR repository, and then use the update-function-code command to deploy the image to the Lambda function.Lambda resolves the image tag to a specific image digest. This means that if you point the image tag that was used to deploy the function to a new image in Amazon ECR, Lambda doesn't automatically update the function to use the new image.To deploy the new image to the same Lambda function, you must use the update-function-code command, even if the image tag in Amazon ECR remains the same. In the following example, the --publish option creates a new version of the function using the updated container image.aws lambda update-function-code \
  --function-name hello-world \
  --image-uri 111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest \
  --publish
  For an example of how to create a Python image from an Alpine base image, see Container image support for Lambda on the AWS
      Blog.
  Document ConventionsDeploy .zip file archivesLayersDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideAWS base images for JavaUsing an AWS base imageUsing a non-AWS base imageDeploy Java Lambda functions with container imagesThere are three ways to build a container image for a Java Lambda function:
     
	 
     
  
      Using an AWS base image for Java
      The AWS base images are preloaded with a language runtime, a runtime interface client to manage the interaction between Lambda and your function code, and a runtime interface emulator for local testing.
    
      Using an AWS OS-only base image
      AWS OS-only base images contain an Amazon Linux distribution and the runtime interface emulator. These images are commonly used to create container images for compiled languages, such as Go and Rust, and for a language or language version that Lambda doesn't provide a base image for, such as Node.js 19. You can also use OS-only base images to implement a custom runtime. To make the image compatible with Lambda, you must include the runtime interface client for Java in the image.
    
      Using a non-AWS base image
      You can use an alternative base image from another container registry, such as Alpine Linux or Debian. You can also use a custom image created by your organization. To make the image compatible with Lambda, you must include the runtime interface client for Java in the image.
    TipTo reduce the time it takes for Lambda container functions to become active, see Use multi-stage builds in the Docker documentation. To build efficient container images, follow the Best practices for writing Dockerfiles.This page explains how to build, test, and deploy container images for Lambda.TopicsAWS base images for JavaUsing an AWS base image for JavaUsing an alternative base image with the runtime interface client
    AWS base images for Java
    AWS provides the following base images for Java:

    
    
          
            Tags
            Runtime
            Operating system
            Dockerfile
            Deprecation
          
        
      
            21
            Java 21
            Amazon Linux 2023
            Dockerfile
                for Java 21 on GitHub
            
                          Jun 30, 2029
            
              
          
      
            17
            Java 17
            Amazon Linux 2
            Dockerfile
                for Java 17 on GitHub
            
                          Jun 30, 2026
            
              
          
      
            11
            Java 11
            Amazon Linux 2
            Dockerfile
                for Java 11 on GitHub
            
                          Jun 30, 2026
            
              
          
      
            8.al2
            Java 8
            Amazon Linux 2
            Dockerfile
                for Java 8 on GitHub
            
                          Jun 30, 2026
            
              
          
    

    Amazon ECR repository: gallery.ecr.aws/lambda/java
    The Java 21 and later base images are based on the Amazon Linux 2023 minimal container image. Earlier base images use Amazon Linux 2. AL2023 provides several advantages over Amazon Linux 2, including a smaller deployment footprint and updated versions of libraries such as glibc.
    AL2023-based images use microdnf (symlinked as dnf) as the package manager instead of yum, which is the default package manager in Amazon Linux 2. microdnf is a standalone implementation of dnf. For a list of packages that are included in AL2023-based images, refer to the Minimal Container columns in Comparing packages installed on Amazon Linux 2023 Container Images. For more information about the differences between AL2023 and Amazon Linux 2, see Introducing the Amazon Linux 2023 runtime for AWS Lambda on the AWS
      Compute Blog.    
    NoteTo run AL2023-based images locally, including with AWS Serverless Application Model (AWS SAM), you must use Docker version 20.10.10 or later.  
   
    Using an AWS base image for Java
    
      To complete the steps in this section, you must have the following:
       
	     
	     
           
           
    
        Java (for example, Amazon Corretto)
      
         Apache Maven or Gradle
      
            AWS CLI version 2
          
            Docker (minimum version 25.0.0)
          
            The Docker buildx plugin.
          
      Maven
    
          Run the following command to create a Maven project using the archetype for Lambda. The following parameters are required:
          
         
             
         
             
          
              service – The AWS service client to use in the Lambda
                        function. For a list of available sources, see aws-sdk-java-v2/services on GitHub.
            
              region – The AWS Region where you want to create the Lambda
                        function.
            
              groupId – The full package namespace of your
                        application.
            
              artifactId – Your project name. This becomes the name of the
                        directory for your project.
            
        In Linux and macOS, run this command:
				mvn -B archetype:generate \
   -DarchetypeGroupId=software.amazon.awssdk \
   -DarchetypeArtifactId=archetype-lambda -Dservice=s3 -Dregion=US_WEST_2 \
   -DgroupId=com.example.myapp \
   -DartifactId=myapp
        In PowerShell, run this command:
				mvn -B archetype:generate `
   "-DarchetypeGroupId=software.amazon.awssdk" `
   "-DarchetypeArtifactId=archetype-lambda" "-Dservice=s3" "-Dregion=US_WEST_2" `
   "-DgroupId=com.example.myapp" `
   "-DartifactId=myapp"
   The Maven archetype for Lambda is preconfigured to compile with Java SE 8 and includes a dependency to the AWS SDK for Java. If you create your project with a different archetype or by using another method, you must configure the Java compiler for Maven and declare the SDK as a dependency.
        
          Open the myapp/src/main/java/com/example/myapp directory, and find the App.java file. This is the code for the Lambda function. You can use the provided sample code for testing, or replace it with your own.
        
          Navigate back to the project's root directory, and then create a new Dockerfile with the following configuration:
          
             
             
          
              Set the FROM property to the URI of the base image.
            
              Set the CMD argument to the Lambda function handler.
            
          Note that the example Dockerfile does not include a USER instruction. When you deploy a container image to Lambda, Lambda automatically defines a default Linux user with least-privileged permissions. This is different from standard Docker behavior which defaults to the root user when no USER instruction is provided.
          Example  DockerfileFROM public.ecr.aws/lambda/java:21
  
# Copy function code and runtime dependencies from Maven layout
COPY target/classes ${LAMBDA_TASK_ROOT}
COPY target/dependency/* ${LAMBDA_TASK_ROOT}/lib/
    
# Set the CMD to your handler (could also be done as a parameter override outside of the Dockerfile)
CMD [ "com.example.myapp.App::handleRequest" ]
        
          Compile the project and collect the runtime dependencies.
          mvn compile dependency:copy-dependencies -DincludeScope=runtime
        
          Build the Docker image with the docker build command. The
          following example names the image docker-image and gives it the test tag. To make your 
          image compatible with Lambda, you must use the --provenance=false option.
        docker buildx build --platform linux/amd64 --provenance=false -t docker-image:test .
        NoteThe command specifies the --platform linux/amd64 option to ensure that your container is compatible with the Lambda execution environment regardless of the  
       architecture of your build machine. If you intend to create a Lambda function using the ARM64 instruction set architecture, be sure to change the command to use the --platform linux/arm64 
       option instead.
        
    
          Gradle
        
            Create a directory for the project, and then switch to that directory.
            mkdir example
cd example
          
            Run the following command to have Gradle generate a new Java application project in
              the example directory in your environment. For Select build script DSL, choose 2: Groovy. 
            gradle init --type java-application
          
          Open the /example/app/src/main/java/example directory, and find the App.java file. This is the code for the Lambda function. You can use the following sample code for testing, or replace it with your own.
          Example App.javapackage com.example;
import com.amazonaws.services.lambda.runtime.Context;
import com.amazonaws.services.lambda.runtime.RequestHandler;
public class App implements RequestHandler<Object, String> {
    public String handleRequest(Object input, Context context) {
        return "Hello world!";
    }
}
        
            Open the build.gradle file. If you're using the sample function code from the previous step, replace the contents of build.gradle with the following. If you're using your own function code, modify your build.gradle file as needed.
            Example  build.gradle (Groovy DSL)plugins {
  id 'java'
}
group 'com.example'
version '1.0-SNAPSHOT'
sourceCompatibility = 1.8
repositories {
  mavenCentral()
}
dependencies {
  implementation 'com.amazonaws:aws-lambda-java-core:1.2.1'
}
jar {
  manifest {
      attributes 'Main-Class': 'com.example.App'
  }
}
          
            The gradle init command from step 2 also generated a dummy
              test case in the app/test directory. For the purposes of this tutorial, skip 
              running tests by deleting the /test directory.
          
        Build the project.
        gradle build
        
          In the project's root directory (/example), create a Dockerfile with the following configuration:
          
             
             
             
          
              Set the FROM property to the URI of the base image.
            
              Use the COPY command to copy the function code and runtime dependencies to {LAMBDA_TASK_ROOT}, a Lambda-defined environment variable.
            
              Set the CMD argument to the Lambda function handler.
            
        Note that the example Dockerfile does not include a USER instruction. When you deploy a container image to Lambda, Lambda automatically defines a default Linux user with least-privileged permissions. This is different from standard Docker behavior which defaults to the root user when no USER instruction is provided.
          Example  DockerfileFROM public.ecr.aws/lambda/java:21
  
# Copy function code and runtime dependencies from Gradle layout
COPY app/build/classes/java/main ${LAMBDA_TASK_ROOT}
  
# Set the CMD to your handler (could also be done as a parameter override outside of the Dockerfile)
CMD [ "com.example.App::handleRequest" ]
        
        Build the Docker image with the docker build command. The
          following example names the image docker-image and gives it the test tag. To make your 
          image compatible with Lambda, you must use the --provenance=false option.
        docker buildx build --platform linux/amd64 --provenance=false -t docker-image:test .
        NoteThe command specifies the --platform linux/amd64 option to ensure that your container is compatible with the Lambda execution environment regardless of the  
       architecture of your build machine. If you intend to create a Lambda function using the ARM64 instruction set architecture, be sure to change the command to use the --platform linux/arm64 
       option instead.
        
            
        
          Start the Docker image with the docker run command. In this example,
              docker-image is the image name and test is the tag.
          docker run --platform linux/amd64 -p 9000:8080 docker-image:test
          This command runs the image as a container and creates a local endpoint at
            localhost:9000/2015-03-31/functions/function/invocations.
          NoteIf you built the Docker image for the ARM64 instruction set architecture, be sure to use the --platform linux/arm64 option instead of --platform linux/amd64. 
        
          From a new terminal window, post an event to the local endpoint.
          
            Linux/macOS
      		      In Linux and macOS, run the following curl command:
                curl "http://localhost:9000/2015-03-31/functions/function/invocations" -d '{}'
                This command invokes the function with an empty event and returns a response. If you're using your own function code rather than the sample function code, you might want to invoke the function with a JSON payload. Example:
                curl "http://localhost:9000/2015-03-31/functions/function/invocations" -d '{"payload":"hello world!"}'
      		
            PowerShell
                In PowerShell, run the following Invoke-WebRequest command:
                Invoke-WebRequest -Uri "http://localhost:9000/2015-03-31/functions/function/invocations" -Method Post -Body '{}' -ContentType "application/json"
                This command invokes the function with an empty event and returns a response. If you're using your own function code rather than the sample function code, you might want to invoke the function with a JSON payload. Example:
                Invoke-WebRequest -Uri "http://localhost:9000/2015-03-31/functions/function/invocations" -Method Post -Body '{"payload":"hello world!"}' -ContentType "application/json"
              
          
        
          Get the container ID.
          docker ps
        
          Use the docker kill command to stop the container. In this command, replace 3766c4ab331c with the container ID from the previous step.
          docker kill 3766c4ab331c
        To upload the image to Amazon ECR and create the Lambda function
          Run the get-login-password command to authenticate the Docker CLI to your Amazon ECR registry.
        
         
         
        
          Set the --region value to the AWS Region where you want to create the Amazon ECR repository.
        
          Replace 111122223333 with your AWS account ID.
        
          aws ecr get-login-password --region us-east-1 | docker login --username AWS --password-stdin 111122223333.dkr.ecr.us-east-1.amazonaws.com
          
        
        Create a repository in Amazon ECR using the create-repository command.
        aws ecr create-repository --repository-name hello-world --region us-east-1 --image-scanning-configuration scanOnPush=true --image-tag-mutability MUTABLE
        
        NoteThe Amazon ECR repository must be in the same AWS Region as the Lambda function.
        If successful, you see a response like this:
        {
    "repository": {
        "repositoryArn": "arn:aws:ecr:us-east-1:111122223333:repository/hello-world",
        "registryId": "111122223333",
        "repositoryName": "hello-world",
        "repositoryUri": "111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world",
        "createdAt": "2023-03-09T10:39:01+00:00",
        "imageTagMutability": "MUTABLE",
        "imageScanningConfiguration": {
            "scanOnPush": true
        },
        "encryptionConfiguration": {
            "encryptionType": "AES256"
        }
    }
}
        
      
        Copy the repositoryUri from the output in the previous step.
      
        Run the docker tag command to tag your local image into your Amazon ECR repository as the latest version. In this command: 
        
         
         
        
          docker-image:test is the name and tag of your Docker image. This is the image name and tag that you specified in the docker build command.
        
          Replace <ECRrepositoryUri> with the repositoryUri that you copied. Make sure to include :latest at the end of the URI.
        
        docker tag docker-image:test <ECRrepositoryUri>:latest
      Example:
      docker tag docker-image:test 111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest
      
      
      Run the docker push command to deploy your local image to the Amazon ECR repository. Make sure to include :latest at the end of the repository URI.
docker push 111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest

      
      Create an execution role for the function, if you don't already have one. You need the Amazon Resource Name (ARN) of the role in the next step.
      
        Create the Lambda function. For ImageUri, specify the repository URI from earlier. Make sure to include :latest at the end of the URI.
		aws lambda create-function \
  --function-name hello-world \
  --package-type Image \
  --code ImageUri=111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest \
  --role arn:aws:iam::111122223333:role/lambda-ex
  		
      NoteYou can create a function using an image in a different AWS account, as long as the image is in the same Region as the Lambda function. For more information, see  Amazon ECR cross-account permissions.  
      
      Invoke the function.
      aws lambda invoke --function-name hello-world response.json
      You should see a response like this:
{
  "ExecutedVersion": "$LATEST", 
  "StatusCode": 200
}
    
    To see the output of the function, check the response.json file.
    To update the function code, you must build the image again, upload the new image to the Amazon ECR repository, and then use the update-function-code command to deploy the image to the Lambda function.Lambda resolves the image tag to a specific image digest. This means that if you point the image tag that was used to deploy the function to a new image in Amazon ECR, Lambda doesn't automatically update the function to use the new image.To deploy the new image to the same Lambda function, you must use the update-function-code command, even if the image tag in Amazon ECR remains the same. In the following example, the --publish option creates a new version of the function using the updated container image.aws lambda update-function-code \
  --function-name hello-world \
  --image-uri 111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest \
  --publish
   
    Using an alternative base image with the runtime interface client
    If you use an OS-only base image or an alternative base image, you must include the runtime interface client in your image. The runtime interface client extends the Runtime API, which manages the interaction between Lambda and your function code.
        Install the runtime interface client for Java in your Dockerfile, or as a dependency in your project. For example, to install the runtime interface client using the Maven package manager, add the following to your pom.xml file:
    <dependency>
    <groupId>com.amazonaws</groupId>
    <artifactId>aws-lambda-java-runtime-interface-client</artifactId>
    <version>2.3.2</version>
</dependency>
    For package details, see AWS Lambda Java Runtime Interface Client
      in the Maven Central Repository. You can also review the runtime interface client source code in the AWS Lambda Java Support Libraries GitHub repository.
    The following example demonstrates how to build a container image for Java using an Amazon Corretto image. Amazon Corretto is a no-cost, multiplatform, production-ready distribution of the Open Java Development Kit (OpenJDK). The Maven project includes the runtime interface client as a dependency.
  
      To complete the steps in this section, you must have the following:
       
	     
       
           
           
    
        Java (for example, Amazon Corretto)
      
         Apache Maven
      
            AWS CLI version 2
          
            Docker (minimum version 25.0.0)
          
            The Docker buildx plugin.
          
          Create a Maven project. The following parameters are required:
          
			 
             
          
              groupId – The full package namespace of your
                        application.
            
              artifactId – Your project name. This becomes the name of the
                        directory for your project.
            
          
            Linux/macOS
				mvn -B archetype:generate \
   -DarchetypeArtifactId=maven-archetype-quickstart \
   -DgroupId=example \
   -DartifactId=myapp \
   -DinteractiveMode=false
      		
            PowerShell
				mvn -B archetype:generate `
   -DarchetypeArtifactId=maven-archetype-quickstart `
   -DgroupId=example `
   -DartifactId=myapp `
   -DinteractiveMode=false
          
          
        
			Open the project directory.
			cd myapp
		
			Open the pom.xml file and replace the contents with the following. This file includes the aws-lambda-java-runtime-interface-client as a dependency. Alternatively, you can install the runtime interface client in the Dockerfile. However, the simplest approach is to include the library as a dependency.
			<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
  <modelVersion>4.0.0</modelVersion>
  <groupId>example</groupId>
  <artifactId>hello-lambda</artifactId>
  <packaging>jar</packaging>
  <version>1.0-SNAPSHOT</version>
  <name>hello-lambda</name>
  <url>http://maven.apache.org</url>
  <properties>
    <maven.compiler.source>1.8</maven.compiler.source>
    <maven.compiler.target>1.8</maven.compiler.target>
  </properties>
  <dependencies>
    <dependency>
      <groupId>com.amazonaws</groupId>
      <artifactId>aws-lambda-java-runtime-interface-client</artifactId>
      <version>2.3.2</version>
    </dependency>
  </dependencies>
  <build>
    <plugins>
      <plugin>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-dependency-plugin</artifactId>
        <version>3.1.2</version>
        <executions>
          <execution>
            <id>copy-dependencies</id>
            <phase>package</phase>
            <goals>
              <goal>copy-dependencies</goal>
            </goals>
          </execution>
        </executions>
      </plugin>
    </plugins>
  </build>
</project>
        
          Open the myapp/src/main/java/com/example/myapp directory, and find the App.java file. This is the code for the Lambda function. Replace the code with the following.
		  Example function handlerpackage example;

public class App {
    public static String sayHello() {
        return "Hello world!";
    }
}
        
          The mvn -B archetype:generate command from step 1 also generated a dummy
            test case in the src/test directory. For the purposes of this tutorial, skip over
            running tests by deleting this entire generated /test directory.
        
          Navigate back to the project's root directory, and then create a new Dockerfile. The following example Dockerfile uses an Amazon Corretto image. Amazon Corretto is a no-cost, multiplatform, production-ready distribution of the OpenJDK.
          
             
			 
             
          
              Set the FROM property to the URI of the base image.
            
				Set the ENTRYPOINT to the module that you want the Docker container to run when it starts. In this case, the module is the runtime interface client.
			
              Set the CMD argument to the Lambda function handler.
            
          Note that the example Dockerfile does not include a USER instruction. When you deploy a container image to Lambda, Lambda automatically defines a default Linux user with least-privileged permissions. This is different from standard Docker behavior which defaults to the root user when no USER instruction is provided.
          Example  DockerfileFROM public.ecr.aws/amazoncorretto/amazoncorretto:21 as base

# Configure the build environment
FROM base as build
RUN yum install -y maven
WORKDIR /src

# Cache and copy dependencies
ADD pom.xml .
RUN mvn dependency:go-offline dependency:copy-dependencies

# Compile the function
ADD . .
RUN mvn package 

# Copy the function artifact and dependencies onto a clean base
FROM base
WORKDIR /function

COPY --from=build /src/target/dependency/*.jar ./
COPY --from=build /src/target/*.jar ./

# Set runtime interface client as default command for the container runtime
ENTRYPOINT [ "/usr/bin/java", "-cp", "./*", "com.amazonaws.services.lambda.runtime.api.client.AWSLambda" ]
# Pass the name of the function handler as an argument to the runtime
CMD [ "example.App::sayHello" ]
        
          Build the Docker image with the docker build command. The
          following example names the image docker-image and gives it the test tag. To make your 
          image compatible with Lambda, you must use the --provenance=false option.
        docker buildx build --platform linux/amd64 --provenance=false -t docker-image:test .
        NoteThe command specifies the --platform linux/amd64 option to ensure that your container is compatible with the Lambda execution environment regardless of the  
       architecture of your build machine. If you intend to create a Lambda function using the ARM64 instruction set architecture, be sure to change the command to use the --platform linux/arm64 
       option instead.
        Use the runtime interface emulator to locally test the image. You can build the emulator into your image or use the following procedure to install it on your local machine.To install and run the runtime interface emulator on your local machine
          From your project directory, run the following command to download the runtime interface emulator (x86-64 architecture) from GitHub and install it on your local machine.
          
            Linux/macOS
          mkdir -p ~/.aws-lambda-rie && \
    curl -Lo ~/.aws-lambda-rie/aws-lambda-rie https://github.com/aws/aws-lambda-runtime-interface-emulator/releases/latest/download/aws-lambda-rie && \
    chmod +x ~/.aws-lambda-rie/aws-lambda-rie
      			  To install the arm64 emulator, replace the GitHub repository URL in the previous command with the following:
      			https://github.com/aws/aws-lambda-runtime-interface-emulator/releases/latest/download/aws-lambda-rie-arm64
      		
            PowerShell
      				  $dirPath = "$HOME\.aws-lambda-rie"
if (-not (Test-Path $dirPath)) {
    New-Item -Path $dirPath -ItemType Directory
}
      
$downloadLink = "https://github.com/aws/aws-lambda-runtime-interface-emulator/releases/latest/download/aws-lambda-rie"
$destinationPath = "$HOME\.aws-lambda-rie\aws-lambda-rie"
Invoke-WebRequest -Uri $downloadLink -OutFile $destinationPath
      				  To install the arm64 emulator, replace the $downloadLink with the following:
      				https://github.com/aws/aws-lambda-runtime-interface-emulator/releases/latest/download/aws-lambda-rie-arm64
              
          
        
          Start the Docker image with the docker run command. Note the following:
          
             
             
          
            docker-image is the image name and test is the tag.
            
            /usr/bin/java -cp './*' com.amazonaws.services.lambda.runtime.api.client.AWSLambda example.App::sayHello is the ENTRYPOINT followed by the CMD from your Dockerfile.
            
          
            Linux/macOS
				    docker run --platform linux/amd64 -d -v ~/.aws-lambda-rie:/aws-lambda -p 9000:8080 \
    --entrypoint /aws-lambda/aws-lambda-rie \
    docker-image:test \
        /usr/bin/java -cp './*' com.amazonaws.services.lambda.runtime.api.client.AWSLambda example.App::sayHello
      		
            PowerShell
				        docker run --platform linux/amd64 -d -v "$HOME\.aws-lambda-rie:/aws-lambda" -p 9000:8080 `
--entrypoint /aws-lambda/aws-lambda-rie `
docker-image:test `
    /usr/bin/java -cp './*' com.amazonaws.services.lambda.runtime.api.client.AWSLambda example.App::sayHello
				    
          
          This command runs the image as a container and creates a local endpoint at
            localhost:9000/2015-03-31/functions/function/invocations.
         NoteIf you built the Docker image for the ARM64 instruction set architecture, be sure to use the --platform linux/arm64 option instead of --platform linux/amd64.   
        
          Post an event to the local endpoint.
          
            Linux/macOS
      		      In Linux and macOS, run the following curl command:
                curl "http://localhost:9000/2015-03-31/functions/function/invocations" -d '{}'
                This command invokes the function with an empty event and returns a response. If you're using your own function code rather than the sample function code, you might want to invoke the function with a JSON payload. Example:
                curl "http://localhost:9000/2015-03-31/functions/function/invocations" -d '{"payload":"hello world!"}'
      		
            PowerShell
                In PowerShell, run the following Invoke-WebRequest command:
                Invoke-WebRequest -Uri "http://localhost:9000/2015-03-31/functions/function/invocations" -Method Post -Body '{}' -ContentType "application/json"
                This command invokes the function with an empty event and returns a response. If you're using your own function code rather than the sample function code, you might want to invoke the function with a JSON payload. Example:
                Invoke-WebRequest -Uri "http://localhost:9000/2015-03-31/functions/function/invocations" -Method Post -Body '{"payload":"hello world!"}' -ContentType "application/json"
              
          
        
          Get the container ID.
          docker ps
        
          Use the docker kill command to stop the container. In this command, replace 3766c4ab331c with the container ID from the previous step.
          docker kill 3766c4ab331c
        To upload the image to Amazon ECR and create the Lambda function
          Run the get-login-password command to authenticate the Docker CLI to your Amazon ECR registry.
        
         
         
        
          Set the --region value to the AWS Region where you want to create the Amazon ECR repository.
        
          Replace 111122223333 with your AWS account ID.
        
          aws ecr get-login-password --region us-east-1 | docker login --username AWS --password-stdin 111122223333.dkr.ecr.us-east-1.amazonaws.com
          
        
        Create a repository in Amazon ECR using the create-repository command.
        aws ecr create-repository --repository-name hello-world --region us-east-1 --image-scanning-configuration scanOnPush=true --image-tag-mutability MUTABLE
        
        NoteThe Amazon ECR repository must be in the same AWS Region as the Lambda function.
        If successful, you see a response like this:
        {
    "repository": {
        "repositoryArn": "arn:aws:ecr:us-east-1:111122223333:repository/hello-world",
        "registryId": "111122223333",
        "repositoryName": "hello-world",
        "repositoryUri": "111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world",
        "createdAt": "2023-03-09T10:39:01+00:00",
        "imageTagMutability": "MUTABLE",
        "imageScanningConfiguration": {
            "scanOnPush": true
        },
        "encryptionConfiguration": {
            "encryptionType": "AES256"
        }
    }
}
        
      
        Copy the repositoryUri from the output in the previous step.
      
        Run the docker tag command to tag your local image into your Amazon ECR repository as the latest version. In this command: 
        
         
         
        
          docker-image:test is the name and tag of your Docker image. This is the image name and tag that you specified in the docker build command.
        
          Replace <ECRrepositoryUri> with the repositoryUri that you copied. Make sure to include :latest at the end of the URI.
        
        docker tag docker-image:test <ECRrepositoryUri>:latest
      Example:
      docker tag docker-image:test 111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest
      
      
      Run the docker push command to deploy your local image to the Amazon ECR repository. Make sure to include :latest at the end of the repository URI.
docker push 111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest

      
      Create an execution role for the function, if you don't already have one. You need the Amazon Resource Name (ARN) of the role in the next step.
      
        Create the Lambda function. For ImageUri, specify the repository URI from earlier. Make sure to include :latest at the end of the URI.
		aws lambda create-function \
  --function-name hello-world \
  --package-type Image \
  --code ImageUri=111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest \
  --role arn:aws:iam::111122223333:role/lambda-ex
  		
      NoteYou can create a function using an image in a different AWS account, as long as the image is in the same Region as the Lambda function. For more information, see  Amazon ECR cross-account permissions.  
      
      Invoke the function.
      aws lambda invoke --function-name hello-world response.json
      You should see a response like this:
{
  "ExecutedVersion": "$LATEST", 
  "StatusCode": 200
}
    
    To see the output of the function, check the response.json file.
    To update the function code, you must build the image again, upload the new image to the Amazon ECR repository, and then use the update-function-code command to deploy the image to the Lambda function.Lambda resolves the image tag to a specific image digest. This means that if you point the image tag that was used to deploy the function to a new image in Amazon ECR, Lambda doesn't automatically update the function to use the new image.To deploy the new image to the same Lambda function, you must use the update-function-code command, even if the image tag in Amazon ECR remains the same. In the following example, the --publish option creates a new version of the function using the updated container image.aws lambda update-function-code \
  --function-name hello-world \
  --image-uri 111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest \
  --publish
  Document ConventionsDeploy .zip file archivesLayersDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideAWS base images for .NETUsing an AWS base imageUsing a non-AWS base imageDeploy .NET Lambda functions with container imagesThere are three ways to build a container image for a .NET Lambda function:
     
	 
     
  
      Using an AWS base image for .NET
      The AWS base images are preloaded with a language runtime, a runtime interface client to manage the interaction between Lambda and your function code, and a runtime interface emulator for local testing.
    
      Using an AWS OS-only base image
      AWS OS-only base images contain an Amazon Linux distribution and the runtime interface emulator. These images are commonly used to create container images for compiled languages, such as Go and Rust, and for a language or language version that Lambda doesn't provide a base image for, such as Node.js 19. You can also use OS-only base images to implement a custom runtime. To make the image compatible with Lambda, you must include the the runtime interface client for .NET in the image.
    
      Using a non-AWS base image
      You can use an alternative base image from another container registry, such as Alpine Linux or Debian. You can also use a custom image created by your organization. To make the image compatible with Lambda, you must include the the runtime interface client for .NET in the image.
    TipTo reduce the time it takes for Lambda container functions to become active, see Use multi-stage builds in the Docker documentation. To build efficient container images, follow the Best practices for writing Dockerfiles.This page explains how to build, test, and deploy container images for Lambda.TopicsAWS base images for .NETUsing an AWS base image for .NETUsing an alternative base image with the runtime interface client
    AWS base images for .NET
    AWS provides the following base images for .NET:
    
    
          
            Tags
            Runtime
            Operating system
            Dockerfile
            Deprecation
          
        
      
            9
            .NET 9
            Amazon Linux 2023
            Dockerfile
                for .NET 9 on GitHub
            
              
            Not scheduled
            
              
          
      
            8
            .NET 8
            Amazon Linux 2023
            Dockerfile
                for .NET 8 on GitHub
            
                          Nov 10, 2026
            
              
          
    
    Amazon ECR repository: gallery.ecr.aws/lambda/dotnet
   
    Using an AWS base image for .NET
     
      Prerequisites
      
        To complete the steps in this section, you must have the following:
         
         
         
      
          .NET SDK – The following steps use the
            .NET 8 base image. Make sure that your .NET version matches the version of the base image that you specify in your Dockerfile.
        
          Docker (minimum version 25.0.0)
        
          The Docker buildx plugin.
        
     
     
      Creating and deploying an image using a base image
      In the following steps, you use Amazon.Lambda.Templates and Amazon.Lambda.Tools
        to create a .NET project. Then, you build a Docker image, upload the image to Amazon ECR, and deploy it to a Lambda
        function.
      
          Install the Amazon.Lambda.Templates NuGet package.
          dotnet new install Amazon.Lambda.Templates
        
          Create a .NET project using the lambda.image.EmptyFunction template.
          dotnet new lambda.image.EmptyFunction --name MyFunction --region us-east-1
          The project files are stored in the MyFunction/src/MyFunction directory:
          
             
             
             
             
          
              aws-lambda-tools-defaults.json: Specifies the command line options for deploying your Lambda function.
            
              Function.cs: Your Lambda handler function code. This is a C#
                template that includes the default Amazon.Lambda.Core library and a default
                LambdaSerializer attribute. For more information about serialization requirements and
                options, see Serialization in C# Lambda functions. You
                can use the provided code for testing, or replace it with your own.
            
              MyFunction.csproj: A .NET project
                file, which lists the files and assemblies that comprise your application.
            
              Dockerfile: You can use the provided Dockerfile for testing, or replace it with your own. If you use your own, make sure to:
              
                 
                 
              
                  Set the FROM property to the URI of
                    the base image. The base image and the TargetFramework in the MyFunction.csproj file must both use the same .NET version. For example, to use .NET 9:
                  
                     
                     
                  
                      Dockerfile: FROM public.ecr.aws/lambda/dotnet:9
                    
                      MyFunction.csproj: <TargetFramework>net9.0</TargetFramework>
                    
                
                  Set the CMD argument to the Lambda function handler. This should match the
                    image-command in aws-lambda-tools-defaults.json.
                
            
        
          Install the Amazon.Lambda.Tools .NET
              Global Tool.
          dotnet tool install -g Amazon.Lambda.Tools
          If Amazon.Lambda.Tools is already installed, make sure that you have the latest version.
          dotnet tool update -g Amazon.Lambda.Tools
        
          Change the directory to
                MyFunction/src/MyFunction, if you're
            not there already.
          cd src/MyFunction
        
          Use Amazon.Lambda.Tools to build the Docker image, push it to a new Amazon ECR repository, and deploy the
            Lambda function.
          For --function-role, specify the role name—not the Amazon Resource Name
            (ARN)—of the execution role for the function. For
            example, lambda-role.
          dotnet lambda deploy-function MyFunction --function-role lambda-role
          For more information about the Amazon.Lambda.Tools .NET Global Tool, see the AWS Extensions for .NET CLI repository on
            GitHub.
        
          Invoke the function.
          dotnet lambda invoke-function MyFunction --payload "Testing the function"
          If everything is successful, you see a response similar to the following:
          Payload:
{"Lower":"testing the function","Upper":"TESTING THE FUNCTION"}

Log Tail:
INIT_REPORT Init Duration: 9999.81 ms   Phase: init     Status: timeout
START RequestId: 12378346-f302-419b-b1f2-deaa1e8423ed Version: $LATEST
END RequestId: 12378346-f302-419b-b1f2-deaa1e8423ed
REPORT RequestId: 12378346-f302-419b-b1f2-deaa1e8423ed  Duration: 3173.06 ms    Billed Duration: 3174 ms        Memory Size: 512 MB     Max Memory Used: 24 MB
        
          Delete the Lambda function.
          dotnet lambda delete-function MyFunction
      
     
   
    Using an alternative base image with the runtime interface client
    If you use an OS-only base image or an alternative base image, you must include the runtime interface client in your image. The runtime interface client extends the Runtime API, which manages the interaction between Lambda and your function code.
    The following example demonstrates how to build a container image for .NET using a non-AWS base image, and how to add the Amazon.Lambda.RuntimeSupport package, which is the Lambda runtime interface client for .NET. The example Dockerfile uses the Microsoft .NET 8 base image.
     
      Prerequisites
      
        To complete the steps in this section, you must have the following:
         
         
         
      
          .NET SDK – The following steps use a
            .NET 9 base image. Make sure that your .NET version matches the version of the base image that you specify in your Dockerfile.
        
          Docker (minimum version 25.0.0)
        
          The Docker buildx plugin.
        
     
     
      Creating and deploying an image using an alternative base image

      
          Install the Amazon.Lambda.Templates NuGet package.
          dotnet new install Amazon.Lambda.Templates
        
          Create a .NET project using the lambda.CustomRuntimeFunction template. This template includes the Amazon.Lambda.RuntimeSupport package.
          dotnet new lambda.CustomRuntimeFunction --name MyFunction --region us-east-1
        
          Navigate to the MyFunction/src/MyFunction directory. This is where the project files are stored. Examine the following files:
          
             
             
             
             
          
              aws-lambda-tools-defaults.json – This file is where you
                specify the command line options when deploying your Lambda function.
            
              Function.cs – The code contains a class with a Main method that initializes the Amazon.Lambda.RuntimeSupport library as the bootstrap. The Main method is the entry point for the function's process. The Main method wraps the function handler in a wrapper that the bootstrap can work with. For more information, see Using Amazon.Lambda.RuntimeSupport as a class library in the GitHub repository.
            
              MyFunction.csproj – A .NET project
                  file, which lists the files and assemblies that comprise your application.
            
              Readme.md – This file contains more information about the
                sample Lambda function.
            
        
          Open the aws-lambda-tools-defaults.json file and Add the following lines:
                        "package-type": "image",
  "docker-host-build-output-dir": "./bin/Release/lambda-publish"
          
             
             
          
              package-type: Defines the deployment package as a container image.
            
              docker-host-build-output-dir: Sets the output directory for the build process.
            
          Example  aws-lambda-tools-defaults.json{
  "Information": [
    "This file provides default values for the deployment wizard inside Visual Studio and the AWS Lambda commands added to the .NET Core CLI.",
    "To learn more about the Lambda commands with the .NET Core CLI execute the following command at the command line in the project root directory.",
    "dotnet lambda help",
    "All the command line options for the Lambda command can be specified in this file."
  ],
  "profile": "",
  "region": "us-east-1",
  "configuration": "Release",
  "function-runtime": "provided.al2023",
  "function-memory-size": 256,
  "function-timeout": 30,
  "function-handler": "bootstrap",
  "msbuild-parameters": "--self-contained true",
  "package-type": "image",
  "docker-host-build-output-dir": "./bin/Release/lambda-publish"
}
        
          Create a Dockerfile in the MyFunction/src/MyFunction directory. The following example Dockerfile uses a Microsoft .NET base image instead of an AWS base image.
          
             
			       
			       
          
              Set the FROM property to the base image identifier. The base image and the TargetFramework in the MyFunction.csproj file must both use the same .NET version.
            
              Use the COPY command to copy the function into the /var/task directory.
            
				      Set the ENTRYPOINT to the module that you want the Docker container to run when it starts. In this case, the module is the bootstrap, which initializes the Amazon.Lambda.RuntimeSupport library.
			      
          Note that the example Dockerfile does not include a USER instruction. When you deploy a container image to Lambda, Lambda automatically defines a default Linux user with least-privileged permissions. This is different from standard Docker behavior which defaults to the root user when no USER instruction is provided.
          Example  Dockerfile# You can also pull these images from DockerHub amazon/aws-lambda-dotnet:8
FROM mcr.microsoft.com/dotnet/runtime:9.0

# Set the image's internal work directory
WORKDIR /var/task
  
# Copy function code to Lambda-defined environment variable
COPY "bin/Release/net9.0/linux-x64"  .
  
# Set the entrypoint to the bootstrap
ENTRYPOINT ["/usr/bin/dotnet", "exec", "/var/task/bootstrap.dll"]
        
          Install the Amazon.Lambda.Tools .NET
              Global Tools extension.
          dotnet tool install -g Amazon.Lambda.Tools
          If Amazon.Lambda.Tools is already installed, make sure that you have the latest version.
          dotnet tool update -g Amazon.Lambda.Tools
        
          Use Amazon.Lambda.Tools to build the Docker image, push it to a new Amazon ECR repository, and deploy the
            Lambda function.
          For --function-role, specify the role name—not the Amazon Resource Name
            (ARN)—of the execution role for the function. For
            example, lambda-role.
          dotnet lambda deploy-function MyFunction --function-role lambda-role
          For more information about the Amazon.Lambda.Tools .NET CLI extension, see the AWS Extensions for .NET CLI repository on
            GitHub.
        
          Invoke the function.
          dotnet lambda invoke-function MyFunction --payload "Testing the function"
          If everything is successful, you see the following:
          Payload:
"TESTING THE FUNCTION"

Log Tail:
START RequestId: id Version: $LATEST
END RequestId: id
REPORT RequestId: id  Duration: 0.99 ms       Billed Duration: 1 ms         Memory Size: 256 MB     Max Memory Used: 12 MB
        
        Delete the Lambda function.
        dotnet lambda delete-function MyFunction
      
     
  Document ConventionsASP.NETNative AOT compilationDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideAWS base images for deploying Go functionsGo runtime interface clientUsing an AWS OS-only base imageUsing a non-AWS base imageDeploy Go Lambda functions with container imagesThere are two ways to build a container image for a Go Lambda function:
	 
     
  
      Using an AWS OS-only base image
      Go is implemented differently than other managed runtimes. Because Go compiles natively to an executable binary, it doesn't require a dedicated language runtime. Use an OS-only base image to build Go images for Lambda. To make the image compatible with Lambda, you must include the aws-lambda-go/lambda package in the image.
    
      Using a non-AWS base image
      You can use an alternative base image from another container registry, such as Alpine Linux or Debian. You can also use a custom image created by your organization. To make the image compatible with Lambda, you must include the aws-lambda-go/lambda package in the image.
    TipTo reduce the time it takes for Lambda container functions to become active, see Use multi-stage builds in the Docker documentation. To build efficient container images, follow the Best practices for writing Dockerfiles.This page explains how to build, test, and deploy container images for Lambda.
    AWS base images for deploying Go functions
    Go is implemented differently than other managed runtimes. Because Go compiles natively to an executable binary, it doesn't require a dedicated language runtime. Use an OS-only base image to deploy Go functions to Lambda.
    
      
        Name
        Identifier
        Operating system
        Deprecation date
        Block function create
        Block function update
      
    
      
        
          OS-only Runtime
        
        
          provided.al2023
        
        
          Amazon Linux 2023
        

        
                      Jun 30, 2029
            
        
        
                      Jul 31, 2029
            
        
        
                      Aug 31, 2029
            
        

      
      
        
          OS-only Runtime
        
        
          provided.al2
        
        
          Amazon Linux 2
        

        
                      Jun 30, 2026
            
        
        
                      Jul 31, 2026
            
        
        
                      Aug 31, 2026
            
        

      
    
    Amazon Elastic Container Registry Public Gallery: gallery.ecr.aws/lambda/provided
   
    Go runtime interface client
    The aws-lambda-go/lambda
      package includes an implementation of the runtime interface. For examples of how to use aws-lambda-go/lambda in your image, see Using an AWS OS-only base image or Using a non-AWS base image.
   
    Using an AWS OS-only base image
    Go is implemented differently than other managed runtimes. Because Go compiles natively to an executable binary, it doesn't require a dedicated language runtime. Use an OS-only base image to
      build container images for Go functions.
    
          
            Tags
            Runtime
            Operating system
            Dockerfile
            Deprecation
          
        
      
            al2023
            OS-only Runtime
            Amazon Linux 2023
            Dockerfile
                for OS-only Runtime on GitHub
            
                          Jun 30, 2029
            
              
          
      
            al2
            OS-only Runtime
            Amazon Linux 2
            Dockerfile
                for OS-only Runtime on GitHub
            
                          Jun 30, 2026
            
              
          
    
    For more information
      about these base images, see provided in the Amazon ECR
      public gallery.
      You must include the aws-lambda-go/lambda package with your Go handler. This package implements the
      programming model for Go, including the runtime interface.
    
      To complete the steps in this section, you must have the following:
	     
           
           
       
    
            AWS CLI version 2
          
            Docker (minimum version 25.0.0)
          
            The Docker buildx plugin.
          
        Go
      To build and deploy a Go function with the provided.al2023 base image
          Create a directory for the project, and then switch to that directory.
          mkdir hello
cd hello
        
          Initialize a new Go module.
          go mod init example.com/hello-world
        
          Add the lambda library as a dependency of your new module.
          go get github.com/aws/aws-lambda-go/lambda
        
            Create a file named main.go and then open it in a text editor. This is the code for the Lambda function. You can use the following sample code for testing, or replace it with your own.
          package main

import (
	"context"
	"github.com/aws/aws-lambda-go/events"
	"github.com/aws/aws-lambda-go/lambda"
)

func handler(ctx context.Context, event events.APIGatewayProxyRequest) (events.APIGatewayProxyResponse, error) {
	response := events.APIGatewayProxyResponse{
		StatusCode: 200,
		Body:       "\"Hello from Lambda!\"",
	}
	return response, nil
}

func main() {
	lambda.Start(handler)
}
          
        Use a text editor to create a Dockerfile in your project directory.
        
           
           
           
        
            The following example Dockerfile uses a multi-stage build. This allows you to use a different base image in each step. You can use one image, such as a Go base image, to compile your code and build the executable binary. You can then use a different image, such as provided.al2023, in the final FROM statement to define the image that you deploy to Lambda. The build process is separated from the final deployment image, so the final image only contains the files needed to run the application.
          
            You can use the optional lambda.norpc tag to exclude the Remote Procedure Call (RPC) component of the lambda 
      library. The RPC component is only required if you are using the deprecated Go 1.x runtime. Excluding the RPC reduces the size of the deployment package.
          
            Note that the example Dockerfile does not include a USER instruction. When you deploy a container image to Lambda, Lambda automatically defines a default Linux user with least-privileged permissions. This is different from standard Docker behavior which defaults to the root user when no USER instruction is provided.
          
        Example — Multi-stage build DockerfileNoteMake sure that the version of Go that you specify in your Dockerfile (for example, golang:1.20) is the same version of Go that you used to create your application.
        FROM golang:1.20 as build
WORKDIR /helloworld
# Copy dependencies list
COPY go.mod go.sum ./
# Build with optional lambda.norpc tag
COPY main.go .
RUN go build -tags lambda.norpc -o main main.go
# Copy artifacts to a clean image
FROM public.ecr.aws/lambda/provided:al2023
COPY --from=build /helloworld/main ./main
ENTRYPOINT [ "./main" ]
      
        Build the Docker image with the docker build command. The
          following example names the image docker-image and gives it the test tag. To make your 
          image compatible with Lambda, you must use the --provenance=false option.
        docker buildx build --platform linux/amd64 --provenance=false -t docker-image:test .
        NoteThe command specifies the --platform linux/amd64 option to ensure that your container is compatible with the Lambda execution environment regardless of the  
       architecture of your build machine. If you intend to create a Lambda function using the ARM64 instruction set architecture, be sure to change the command to use the --platform linux/arm64 
       option instead.
      Use the runtime interface emulator to locally test your image. The runtime interface emulator is included in the provided.al2023 base image.To run the runtime interface emulator on your local machine
      Start the Docker image with the docker run command. Note the following:
      
         
         
      
        docker-image is the image name and test is the tag.
        
        ./main is the ENTRYPOINT from your Dockerfile.
        
      docker run -d -p 9000:8080 \
--entrypoint /usr/local/bin/aws-lambda-rie \
docker-image:test ./main
      This command runs the image as a container and creates a local endpoint at
        localhost:9000/2015-03-31/functions/function/invocations.
    
      From a new terminal window, post an event to the following endpoint using a curl
        command:
      curl "http://localhost:9000/2015-03-31/functions/function/invocations" -d '{}'
      This command invokes the function with an empty event and returns a response. Some functions might require a JSON payload. Example:
      curl "http://localhost:9000/2015-03-31/functions/function/invocations" -d '{"payload":"hello world!"}'
    
      Get the container ID.
      docker ps
    
      Use the docker kill command to stop the container. In this command, replace 3766c4ab331c with the container ID from the previous step.
      docker kill 3766c4ab331c
    To upload the image to Amazon ECR and create the Lambda function
          Run the get-login-password command to authenticate the Docker CLI to your Amazon ECR registry.
        
         
         
        
          Set the --region value to the AWS Region where you want to create the Amazon ECR repository.
        
          Replace 111122223333 with your AWS account ID.
        
          aws ecr get-login-password --region us-east-1 | docker login --username AWS --password-stdin 111122223333.dkr.ecr.us-east-1.amazonaws.com
          
        
        Create a repository in Amazon ECR using the create-repository command.
        aws ecr create-repository --repository-name hello-world --region us-east-1 --image-scanning-configuration scanOnPush=true --image-tag-mutability MUTABLE
        
        NoteThe Amazon ECR repository must be in the same AWS Region as the Lambda function.
        If successful, you see a response like this:
        {
    "repository": {
        "repositoryArn": "arn:aws:ecr:us-east-1:111122223333:repository/hello-world",
        "registryId": "111122223333",
        "repositoryName": "hello-world",
        "repositoryUri": "111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world",
        "createdAt": "2023-03-09T10:39:01+00:00",
        "imageTagMutability": "MUTABLE",
        "imageScanningConfiguration": {
            "scanOnPush": true
        },
        "encryptionConfiguration": {
            "encryptionType": "AES256"
        }
    }
}
        
      
        Copy the repositoryUri from the output in the previous step.
      
        Run the docker tag command to tag your local image into your Amazon ECR repository as the latest version. In this command: 
        
         
         
        
          docker-image:test is the name and tag of your Docker image. This is the image name and tag that you specified in the docker build command.
        
          Replace <ECRrepositoryUri> with the repositoryUri that you copied. Make sure to include :latest at the end of the URI.
        
        docker tag docker-image:test <ECRrepositoryUri>:latest
      Example:
      docker tag docker-image:test 111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest
      
      
      Run the docker push command to deploy your local image to the Amazon ECR repository. Make sure to include :latest at the end of the repository URI.
docker push 111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest

      
      Create an execution role for the function, if you don't already have one. You need the Amazon Resource Name (ARN) of the role in the next step.
      
        Create the Lambda function. For ImageUri, specify the repository URI from earlier. Make sure to include :latest at the end of the URI.
		aws lambda create-function \
  --function-name hello-world \
  --package-type Image \
  --code ImageUri=111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest \
  --role arn:aws:iam::111122223333:role/lambda-ex
  		
      NoteYou can create a function using an image in a different AWS account, as long as the image is in the same Region as the Lambda function. For more information, see  Amazon ECR cross-account permissions.  
      
      Invoke the function.
      aws lambda invoke --function-name hello-world response.json
      You should see a response like this:
{
  "ExecutedVersion": "$LATEST", 
  "StatusCode": 200
}
    
    To see the output of the function, check the response.json file.
    To update the function code, you must build the image again, upload the new image to the Amazon ECR repository, and then use the update-function-code command to deploy the image to the Lambda function.Lambda resolves the image tag to a specific image digest. This means that if you point the image tag that was used to deploy the function to a new image in Amazon ECR, Lambda doesn't automatically update the function to use the new image.To deploy the new image to the same Lambda function, you must use the update-function-code command, even if the image tag in Amazon ECR remains the same. In the following example, the --publish option creates a new version of the function using the updated container image.aws lambda update-function-code \
  --function-name hello-world \
  --image-uri 111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest \
  --publish
   
    Using a non-AWS base image
    You can build a container image for Go from a non-AWS base image. The example Dockerfile in the following steps uses an
      Alpine base image.
    You must include the aws-lambda-go/lambda package with your Go handler. This package implements the
      programming model for Go, including the runtime interface.
   
      To complete the steps in this section, you must have the following:
	     
           
           
       
    
            AWS CLI version 2
          
            Docker (minimum version 25.0.0)
          
            The Docker buildx plugin.
          
        Go
      To build and deploy a Go function with an Alpine base image
          Create a directory for the project, and then switch to that directory.
          mkdir hello
cd hello
        
          Initialize a new Go module.
          go mod init example.com/hello-world
        
          Add the lambda library as a dependency of your new module.
          go get github.com/aws/aws-lambda-go/lambda
        
            Create a file named main.go and then open it in a text editor. This is the code for the Lambda function. You can use the following sample code for testing, or replace it with your own.
          package main

import (
	"context"
	"github.com/aws/aws-lambda-go/events"
	"github.com/aws/aws-lambda-go/lambda"
)

func handler(ctx context.Context, event events.APIGatewayProxyRequest) (events.APIGatewayProxyResponse, error) {
	response := events.APIGatewayProxyResponse{
		StatusCode: 200,
		Body:       "\"Hello from Lambda!\"",
	}
	return response, nil
}

func main() {
	lambda.Start(handler)
}
          
        Use a text editor to create a Dockerfile in your project directory. The following example Dockerfile uses an
          Alpine base image. Note that the example Dockerfile does not include a USER instruction. When you deploy a container image to Lambda, Lambda automatically defines a default Linux user with least-privileged permissions. This is different from standard Docker behavior which defaults to the root user when no USER instruction is provided.
        Example DockerfileNoteMake sure that the version of Go that you specify in your Dockerfile (for example, golang:1.20) is the same version of Go that you used to create your application.
        FROM golang:1.20.2-alpine3.16 as build
WORKDIR /helloworld
# Copy dependencies list
COPY go.mod go.sum ./
# Build
COPY main.go .
RUN go build -o main main.go
# Copy artifacts to a clean image
FROM alpine:3.16
COPY --from=build /helloworld/main /main
ENTRYPOINT [ "/main" ]
      
        Build the Docker image with the docker build command. The
          following example names the image docker-image and gives it the test tag. To make your 
          image compatible with Lambda, you must use the --provenance=false option.
        docker buildx build --platform linux/amd64 --provenance=false -t docker-image:test .
        NoteThe command specifies the --platform linux/amd64 option to ensure that your container is compatible with the Lambda execution environment regardless of the  
       architecture of your build machine. If you intend to create a Lambda function using the ARM64 instruction set architecture, be sure to change the command to use the --platform linux/arm64 
       option instead.
      Use the runtime interface emulator to locally test the image. You can build the emulator into your image or use the following procedure to install it on your local machine.To install and run the runtime interface emulator on your local machine
          From your project directory, run the following command to download the runtime interface emulator (x86-64 architecture) from GitHub and install it on your local machine.
          
            Linux/macOS
          mkdir -p ~/.aws-lambda-rie && \
    curl -Lo ~/.aws-lambda-rie/aws-lambda-rie https://github.com/aws/aws-lambda-runtime-interface-emulator/releases/latest/download/aws-lambda-rie && \
    chmod +x ~/.aws-lambda-rie/aws-lambda-rie
      			  To install the arm64 emulator, replace the GitHub repository URL in the previous command with the following:
      			https://github.com/aws/aws-lambda-runtime-interface-emulator/releases/latest/download/aws-lambda-rie-arm64
      		
            PowerShell
      				  $dirPath = "$HOME\.aws-lambda-rie"
if (-not (Test-Path $dirPath)) {
    New-Item -Path $dirPath -ItemType Directory
}
      
$downloadLink = "https://github.com/aws/aws-lambda-runtime-interface-emulator/releases/latest/download/aws-lambda-rie"
$destinationPath = "$HOME\.aws-lambda-rie\aws-lambda-rie"
Invoke-WebRequest -Uri $downloadLink -OutFile $destinationPath
      				  To install the arm64 emulator, replace the $downloadLink with the following:
      				https://github.com/aws/aws-lambda-runtime-interface-emulator/releases/latest/download/aws-lambda-rie-arm64
              
          
        
          Start the Docker image with the docker run command. Note the following:
          
             
             
          
            docker-image is the image name and test is the tag.
            
            /main is the ENTRYPOINT from your Dockerfile.
            
          
            Linux/macOS
				    docker run --platform linux/amd64 -d -v ~/.aws-lambda-rie:/aws-lambda -p 9000:8080 \
    --entrypoint /aws-lambda/aws-lambda-rie \
    docker-image:test \
        /main
      		
            PowerShell
				        docker run --platform linux/amd64 -d -v "$HOME\.aws-lambda-rie:/aws-lambda" -p 9000:8080 `
--entrypoint /aws-lambda/aws-lambda-rie `
docker-image:test `
    /main
				    
          
          This command runs the image as a container and creates a local endpoint at
            localhost:9000/2015-03-31/functions/function/invocations.
         NoteIf you built the Docker image for the ARM64 instruction set architecture, be sure to use the --platform linux/arm64 option instead of --platform linux/amd64.   
        
          Post an event to the local endpoint.
          
            Linux/macOS
      		      In Linux and macOS, run the following curl command:
                curl "http://localhost:9000/2015-03-31/functions/function/invocations" -d '{}'
                This command invokes the function with an empty event and returns a response. If you're using your own function code rather than the sample function code, you might want to invoke the function with a JSON payload. Example:
                curl "http://localhost:9000/2015-03-31/functions/function/invocations" -d '{"payload":"hello world!"}'
      		
            PowerShell
                In PowerShell, run the following Invoke-WebRequest command:
                Invoke-WebRequest -Uri "http://localhost:9000/2015-03-31/functions/function/invocations" -Method Post -Body '{}' -ContentType "application/json"
                This command invokes the function with an empty event and returns a response. If you're using your own function code rather than the sample function code, you might want to invoke the function with a JSON payload. Example:
                Invoke-WebRequest -Uri "http://localhost:9000/2015-03-31/functions/function/invocations" -Method Post -Body '{"payload":"hello world!"}' -ContentType "application/json"
              
          
        
          Get the container ID.
          docker ps
        
          Use the docker kill command to stop the container. In this command, replace 3766c4ab331c with the container ID from the previous step.
          docker kill 3766c4ab331c
        To upload the image to Amazon ECR and create the Lambda function
          Run the get-login-password command to authenticate the Docker CLI to your Amazon ECR registry.
        
         
         
        
          Set the --region value to the AWS Region where you want to create the Amazon ECR repository.
        
          Replace 111122223333 with your AWS account ID.
        
          aws ecr get-login-password --region us-east-1 | docker login --username AWS --password-stdin 111122223333.dkr.ecr.us-east-1.amazonaws.com
          
        
        Create a repository in Amazon ECR using the create-repository command.
        aws ecr create-repository --repository-name hello-world --region us-east-1 --image-scanning-configuration scanOnPush=true --image-tag-mutability MUTABLE
        
        NoteThe Amazon ECR repository must be in the same AWS Region as the Lambda function.
        If successful, you see a response like this:
        {
    "repository": {
        "repositoryArn": "arn:aws:ecr:us-east-1:111122223333:repository/hello-world",
        "registryId": "111122223333",
        "repositoryName": "hello-world",
        "repositoryUri": "111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world",
        "createdAt": "2023-03-09T10:39:01+00:00",
        "imageTagMutability": "MUTABLE",
        "imageScanningConfiguration": {
            "scanOnPush": true
        },
        "encryptionConfiguration": {
            "encryptionType": "AES256"
        }
    }
}
        
      
        Copy the repositoryUri from the output in the previous step.
      
        Run the docker tag command to tag your local image into your Amazon ECR repository as the latest version. In this command: 
        
         
         
        
          docker-image:test is the name and tag of your Docker image. This is the image name and tag that you specified in the docker build command.
        
          Replace <ECRrepositoryUri> with the repositoryUri that you copied. Make sure to include :latest at the end of the URI.
        
        docker tag docker-image:test <ECRrepositoryUri>:latest
      Example:
      docker tag docker-image:test 111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest
      
      
      Run the docker push command to deploy your local image to the Amazon ECR repository. Make sure to include :latest at the end of the repository URI.
docker push 111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest

      
      Create an execution role for the function, if you don't already have one. You need the Amazon Resource Name (ARN) of the role in the next step.
      
        Create the Lambda function. For ImageUri, specify the repository URI from earlier. Make sure to include :latest at the end of the URI.
		aws lambda create-function \
  --function-name hello-world \
  --package-type Image \
  --code ImageUri=111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest \
  --role arn:aws:iam::111122223333:role/lambda-ex
  		
      NoteYou can create a function using an image in a different AWS account, as long as the image is in the same Region as the Lambda function. For more information, see  Amazon ECR cross-account permissions.  
      
      Invoke the function.
      aws lambda invoke --function-name hello-world response.json
      You should see a response like this:
{
  "ExecutedVersion": "$LATEST", 
  "StatusCode": 200
}
    
    To see the output of the function, check the response.json file.
    To update the function code, you must build the image again, upload the new image to the Amazon ECR repository, and then use the update-function-code command to deploy the image to the Lambda function.Lambda resolves the image tag to a specific image digest. This means that if you point the image tag that was used to deploy the function to a new image in Amazon ECR, Lambda doesn't automatically update the function to use the new image.To deploy the new image to the same Lambda function, you must use the update-function-code command, even if the image tag in Amazon ECR remains the same. In the following example, the --publish option creates a new version of the function using the updated container image.aws lambda update-function-code \
  --function-name hello-world \
  --image-uri 111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest \
  --publish
  Document ConventionsDeploy .zip file archivesLayersDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideAWS base images for RubyUsing an AWS base imageUsing a non-AWS base imageDeploy Ruby Lambda functions with container imagesThere are three ways to build a container image for a Ruby Lambda function:
     
	 
     
  
      Using an AWS base image for Ruby
      The AWS base images are preloaded with a language runtime, a runtime interface client to manage the interaction between Lambda and your function code, and a runtime interface emulator for local testing.
    
      Using an AWS OS-only base image
      AWS OS-only base images contain an Amazon Linux distribution and the runtime interface emulator. These images are commonly used to create container images for compiled languages, such as Go and Rust, and for a language or language version that Lambda doesn't provide a base image for, such as Node.js 19. You can also use OS-only base images to implement a custom runtime. To make the image compatible with Lambda, you must include the runtime interface client for Ruby in the image.
    
      Using a non-AWS base image
      You can use an alternative base image from another container registry, such as Alpine Linux or Debian. You can also use a custom image created by your organization. To make the image compatible with Lambda, you must include the runtime interface client for Ruby in the image.
    TipTo reduce the time it takes for Lambda container functions to become active, see Use multi-stage builds in the Docker documentation. To build efficient container images, follow the Best practices for writing Dockerfiles.This page explains how to build, test, and deploy container images for Lambda.TopicsAWS base images for RubyUsing an AWS base image for RubyUsing an alternative base image with the runtime interface client
    AWS base images for Ruby
    AWS provides the following base images for Ruby:

    
    
          
            Tags
            Runtime
            Operating system
            Dockerfile
            Deprecation
          
        
      
            3.4
            Ruby 3.4
            Amazon Linux 2023
            Dockerfile
                for Ruby 3.4 on GitHub
            
              
            Not scheduled
            
              
          
      
            3.3
            Ruby 3.3
            Amazon Linux 2023
            Dockerfile
                for Ruby 3.3 on GitHub
            
                          Mar 31, 2027
            
              
          
      
            3.2
            Ruby 3.2
            Amazon Linux 2
            Dockerfile
                for Ruby 3.2 on GitHub
            
                          Mar 31, 2026
            
              
          
    
    
    Amazon ECR repository: gallery.ecr.aws/lambda/ruby
   
    Using an AWS base image for Ruby
    To complete the steps in this section, you must have the following:
           
           
           
           
        
            AWS CLI version 2
          
            Docker (minimum version 25.0.0)
          
            The Docker buildx plugin.
          
            Ruby
          To create a container image for Ruby
        Create a directory for the project, and then switch to that directory.
        mkdir example
cd example
      
        Create a new file called Gemfile. This is where you list your application's required RubyGems packages. The AWS SDK for Ruby is available from RubyGems. You should choose specific AWS service gems to install. For example, to use the Ruby gem for Lambda, your Gemfile should look like this:
        source 'https://rubygems.org'

gem 'aws-sdk-lambda'
Alternatively, the aws-sdk gem contains every available AWS service gem. This gem is very large. We recommend that you use it only if you depend on many AWS services.
      
        Install the dependencies specified in the Gemfile using bundle install.
        bundle install
      
        Create a new file called lambda_function.rb. You can add the following sample function code to the file for testing, or use your own.
        Example  Ruby functionmodule LambdaFunction
  class Handler
    def self.process(event:,context:)
      "Hello from Lambda!"
    end
  end
end
      
      Create a new Dockerfile. The following is an example Dockerfile that uses an AWS base image. This Dockerfiles uses the following configuration:
        
           
           
           
        
            Set the FROM property to the URI of the base image.
          
            Use the COPY command to copy the function code and runtime dependencies to {LAMBDA_TASK_ROOT}, a Lambda-defined environment variable.
          
            Set the CMD argument to the Lambda function handler.
          
        Note that the example Dockerfile does not include a USER instruction. When you deploy a container image to Lambda, Lambda automatically defines a default Linux user with least-privileged permissions. This is different from standard Docker behavior which defaults to the root user when no USER instruction is provided.
        Example  DockerfileFROM public.ecr.aws/lambda/ruby:3.2

# Copy Gemfile and Gemfile.lock
COPY Gemfile Gemfile.lock ${LAMBDA_TASK_ROOT}/

# Install Bundler and the specified gems
RUN gem install bundler:2.4.20 && \
    bundle config set --local path 'vendor/bundle' && \
    bundle install

# Copy function code
COPY lambda_function.rb ${LAMBDA_TASK_ROOT}/    

# Set the CMD to your handler (could also be done as a parameter override outside of the Dockerfile)
CMD [ "lambda_function.LambdaFunction::Handler.process" ]
      
        Build the Docker image with the docker build command. The
          following example names the image docker-image and gives it the test tag. To make your 
          image compatible with Lambda, you must use the --provenance=false option.
        docker buildx build --platform linux/amd64 --provenance=false -t docker-image:test .
        NoteThe command specifies the --platform linux/amd64 option to ensure that your container is compatible with the Lambda execution environment regardless of the  
       architecture of your build machine. If you intend to create a Lambda function using the ARM64 instruction set architecture, be sure to change the command to use the --platform linux/arm64 
       option instead.
      
          Start the Docker image with the docker run command. In this example,
              docker-image is the image name and test is the tag.
          docker run --platform linux/amd64 -p 9000:8080 docker-image:test
          This command runs the image as a container and creates a local endpoint at
            localhost:9000/2015-03-31/functions/function/invocations.
          NoteIf you built the Docker image for the ARM64 instruction set architecture, be sure to use the --platform linux/arm64 option instead of --platform linux/amd64. 
        
          From a new terminal window, post an event to the local endpoint.
          
            Linux/macOS
      		      In Linux and macOS, run the following curl command:
                curl "http://localhost:9000/2015-03-31/functions/function/invocations" -d '{}'
                This command invokes the function with an empty event and returns a response. If you're using your own function code rather than the sample function code, you might want to invoke the function with a JSON payload. Example:
                curl "http://localhost:9000/2015-03-31/functions/function/invocations" -d '{"payload":"hello world!"}'
      		
            PowerShell
                In PowerShell, run the following Invoke-WebRequest command:
                Invoke-WebRequest -Uri "http://localhost:9000/2015-03-31/functions/function/invocations" -Method Post -Body '{}' -ContentType "application/json"
                This command invokes the function with an empty event and returns a response. If you're using your own function code rather than the sample function code, you might want to invoke the function with a JSON payload. Example:
                Invoke-WebRequest -Uri "http://localhost:9000/2015-03-31/functions/function/invocations" -Method Post -Body '{"payload":"hello world!"}' -ContentType "application/json"
              
          
        
          Get the container ID.
          docker ps
        
          Use the docker kill command to stop the container. In this command, replace 3766c4ab331c with the container ID from the previous step.
          docker kill 3766c4ab331c
        To upload the image to Amazon ECR and create the Lambda function
          Run the get-login-password command to authenticate the Docker CLI to your Amazon ECR registry.
        
         
         
        
          Set the --region value to the AWS Region where you want to create the Amazon ECR repository.
        
          Replace 111122223333 with your AWS account ID.
        
          aws ecr get-login-password --region us-east-1 | docker login --username AWS --password-stdin 111122223333.dkr.ecr.us-east-1.amazonaws.com
          
        
        Create a repository in Amazon ECR using the create-repository command.
        aws ecr create-repository --repository-name hello-world --region us-east-1 --image-scanning-configuration scanOnPush=true --image-tag-mutability MUTABLE
        
        NoteThe Amazon ECR repository must be in the same AWS Region as the Lambda function.
        If successful, you see a response like this:
        {
    "repository": {
        "repositoryArn": "arn:aws:ecr:us-east-1:111122223333:repository/hello-world",
        "registryId": "111122223333",
        "repositoryName": "hello-world",
        "repositoryUri": "111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world",
        "createdAt": "2023-03-09T10:39:01+00:00",
        "imageTagMutability": "MUTABLE",
        "imageScanningConfiguration": {
            "scanOnPush": true
        },
        "encryptionConfiguration": {
            "encryptionType": "AES256"
        }
    }
}
        
      
        Copy the repositoryUri from the output in the previous step.
      
        Run the docker tag command to tag your local image into your Amazon ECR repository as the latest version. In this command: 
        
         
         
        
          docker-image:test is the name and tag of your Docker image. This is the image name and tag that you specified in the docker build command.
        
          Replace <ECRrepositoryUri> with the repositoryUri that you copied. Make sure to include :latest at the end of the URI.
        
        docker tag docker-image:test <ECRrepositoryUri>:latest
      Example:
      docker tag docker-image:test 111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest
      
      
      Run the docker push command to deploy your local image to the Amazon ECR repository. Make sure to include :latest at the end of the repository URI.
docker push 111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest

      
      Create an execution role for the function, if you don't already have one. You need the Amazon Resource Name (ARN) of the role in the next step.
      
        Create the Lambda function. For ImageUri, specify the repository URI from earlier. Make sure to include :latest at the end of the URI.
		aws lambda create-function \
  --function-name hello-world \
  --package-type Image \
  --code ImageUri=111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest \
  --role arn:aws:iam::111122223333:role/lambda-ex
  		
      NoteYou can create a function using an image in a different AWS account, as long as the image is in the same Region as the Lambda function. For more information, see  Amazon ECR cross-account permissions.  
      
      Invoke the function.
      aws lambda invoke --function-name hello-world response.json
      You should see a response like this:
{
  "ExecutedVersion": "$LATEST", 
  "StatusCode": 200
}
    
    To see the output of the function, check the response.json file.
    To update the function code, you must build the image again, upload the new image to the Amazon ECR repository, and then use the update-function-code command to deploy the image to the Lambda function.Lambda resolves the image tag to a specific image digest. This means that if you point the image tag that was used to deploy the function to a new image in Amazon ECR, Lambda doesn't automatically update the function to use the new image.To deploy the new image to the same Lambda function, you must use the update-function-code command, even if the image tag in Amazon ECR remains the same. In the following example, the --publish option creates a new version of the function using the updated container image.aws lambda update-function-code \
  --function-name hello-world \
  --image-uri 111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest \
  --publish
 
    Using an alternative base image with the runtime interface client
    If you use an OS-only base image or an alternative base image, you must include the runtime interface client in your image. The runtime interface client extends the Runtime API, which manages the interaction between Lambda and your function code.
    Install the Lambda runtime interface client for Ruby using the RubyGems.org package manager:
    gem install aws_lambda_ric
    You can also download the Ruby runtime interface client from GitHub.
    The following example demonstrates how to build a container image for Ruby using a non-AWS base image. The example Dockerfile uses an official Ruby base image. The Dockerfile includes the runtime interface client.
    To complete the steps in this section, you must have the following:
           
           
           
           
        
            AWS CLI version 2
          
            Docker (minimum version 25.0.0)
          
            The Docker buildx plugin.
          
            Ruby
          To create a container image for Ruby using an alternative base image
        Create a directory for the project, and then switch to that directory.
        mkdir example
cd example
      
        Create a new file called Gemfile. This is where you list your application's required RubyGems packages. The AWS SDK for Ruby is available from RubyGems. You should choose specific AWS service gems to install. For example, to use the Ruby gem for Lambda, your Gemfile should look like this:
        source 'https://rubygems.org'

gem 'aws-sdk-lambda'
Alternatively, the aws-sdk gem contains every available AWS service gem. This gem is very large. We recommend that you use it only if you depend on many AWS services.
      
        Install the dependencies specified in the Gemfile using bundle install.
        bundle install
      
        Create a new file called lambda_function.rb. You can add the following sample function code to the file for testing, or use your own.
        Example  Ruby functionmodule LambdaFunction
  class Handler
    def self.process(event:,context:)
      "Hello from Lambda!"
    end
  end
end
      
      Create a new Dockerfile. The following Dockerfile uses a Ruby base image instead of an AWS base image. The Dockerfile includes the runtime interface client for Ruby, which makes the image  compatible with Lambda. Alternatively, you can add the runtime interface client to your application's Gemfile.
        
           
           
		   
           
        
            Set the FROM property to the Ruby base image.
          
            Create a directory for the function code and an environment variable that points
                  to that directory. In this example, the directory is /var/task, which
                  mirrors the Lambda execution environment. However, you can choose any directory for
                  the function code because the Dockerfile doesn't use an AWS base image.
          
            Set the ENTRYPOINT to the module that you want the Docker container to run when it starts. In this case, the module is the runtime interface client.
          
            Set the CMD argument to the Lambda function handler.
          
        Note that the example Dockerfile does not include a USER instruction. When you deploy a container image to Lambda, Lambda automatically defines a default Linux user with least-privileged permissions. This is different from standard Docker behavior which defaults to the root user when no USER instruction is provided.
        Example  DockerfileFROM ruby:2.7

# Install the runtime interface client for Ruby
RUN gem install aws_lambda_ric

# Add the runtime interface client to the PATH
ENV PATH="/usr/local/bundle/bin:${PATH}"

# Create a directory for the Lambda function
ENV LAMBDA_TASK_ROOT=/var/task
RUN mkdir -p ${LAMBDA_TASK_ROOT}
WORKDIR ${LAMBDA_TASK_ROOT}

# Copy Gemfile and Gemfile.lock
COPY Gemfile Gemfile.lock ${LAMBDA_TASK_ROOT}/

# Install Bundler and the specified gems
RUN gem install bundler:2.4.20 && \
    bundle config set --local path 'vendor/bundle' && \
    bundle install

# Copy function code
COPY lambda_function.rb ${LAMBDA_TASK_ROOT}/    

# Set runtime interface client as default command for the container runtime
ENTRYPOINT [ "aws_lambda_ric" ]

# Set the CMD to your handler (could also be done as a parameter override outside of the Dockerfile)
CMD [ "lambda_function.LambdaFunction::Handler.process" ]
      
        Build the Docker image with the docker build command. The
          following example names the image docker-image and gives it the test tag. To make your 
          image compatible with Lambda, you must use the --provenance=false option.
        docker buildx build --platform linux/amd64 --provenance=false -t docker-image:test .
        NoteThe command specifies the --platform linux/amd64 option to ensure that your container is compatible with the Lambda execution environment regardless of the  
       architecture of your build machine. If you intend to create a Lambda function using the ARM64 instruction set architecture, be sure to change the command to use the --platform linux/arm64 
       option instead.
      Use the runtime interface emulator to locally test the image. You can build the emulator into your image or use the following procedure to install it on your local machine.To install and run the runtime interface emulator on your local machine
          From your project directory, run the following command to download the runtime interface emulator (x86-64 architecture) from GitHub and install it on your local machine.
          
            Linux/macOS
          mkdir -p ~/.aws-lambda-rie && \
    curl -Lo ~/.aws-lambda-rie/aws-lambda-rie https://github.com/aws/aws-lambda-runtime-interface-emulator/releases/latest/download/aws-lambda-rie && \
    chmod +x ~/.aws-lambda-rie/aws-lambda-rie
      			  To install the arm64 emulator, replace the GitHub repository URL in the previous command with the following:
      			https://github.com/aws/aws-lambda-runtime-interface-emulator/releases/latest/download/aws-lambda-rie-arm64
      		
            PowerShell
      				  $dirPath = "$HOME\.aws-lambda-rie"
if (-not (Test-Path $dirPath)) {
    New-Item -Path $dirPath -ItemType Directory
}
      
$downloadLink = "https://github.com/aws/aws-lambda-runtime-interface-emulator/releases/latest/download/aws-lambda-rie"
$destinationPath = "$HOME\.aws-lambda-rie\aws-lambda-rie"
Invoke-WebRequest -Uri $downloadLink -OutFile $destinationPath
      				  To install the arm64 emulator, replace the $downloadLink with the following:
      				https://github.com/aws/aws-lambda-runtime-interface-emulator/releases/latest/download/aws-lambda-rie-arm64
              
          
        
          Start the Docker image with the docker run command. Note the following:
          
             
             
          
            docker-image is the image name and test is the tag.
            
            aws_lambda_ric lambda_function.LambdaFunction::Handler.process is the ENTRYPOINT followed by the CMD from your Dockerfile.
            
          
            Linux/macOS
				    docker run --platform linux/amd64 -d -v ~/.aws-lambda-rie:/aws-lambda -p 9000:8080 \
    --entrypoint /aws-lambda/aws-lambda-rie \
    docker-image:test \
        aws_lambda_ric lambda_function.LambdaFunction::Handler.process
      		
            PowerShell
				        docker run --platform linux/amd64 -d -v "$HOME\.aws-lambda-rie:/aws-lambda" -p 9000:8080 `
--entrypoint /aws-lambda/aws-lambda-rie `
docker-image:test `
    aws_lambda_ric lambda_function.LambdaFunction::Handler.process
				    
          
          This command runs the image as a container and creates a local endpoint at
            localhost:9000/2015-03-31/functions/function/invocations.
         NoteIf you built the Docker image for the ARM64 instruction set architecture, be sure to use the --platform linux/arm64 option instead of --platform linux/amd64.   
        
          Post an event to the local endpoint.
          
            Linux/macOS
      		      In Linux and macOS, run the following curl command:
                curl "http://localhost:9000/2015-03-31/functions/function/invocations" -d '{}'
                This command invokes the function with an empty event and returns a response. If you're using your own function code rather than the sample function code, you might want to invoke the function with a JSON payload. Example:
                curl "http://localhost:9000/2015-03-31/functions/function/invocations" -d '{"payload":"hello world!"}'
      		
            PowerShell
                In PowerShell, run the following Invoke-WebRequest command:
                Invoke-WebRequest -Uri "http://localhost:9000/2015-03-31/functions/function/invocations" -Method Post -Body '{}' -ContentType "application/json"
                This command invokes the function with an empty event and returns a response. If you're using your own function code rather than the sample function code, you might want to invoke the function with a JSON payload. Example:
                Invoke-WebRequest -Uri "http://localhost:9000/2015-03-31/functions/function/invocations" -Method Post -Body '{"payload":"hello world!"}' -ContentType "application/json"
              
          
        
          Get the container ID.
          docker ps
        
          Use the docker kill command to stop the container. In this command, replace 3766c4ab331c with the container ID from the previous step.
          docker kill 3766c4ab331c
        To upload the image to Amazon ECR and create the Lambda function
          Run the get-login-password command to authenticate the Docker CLI to your Amazon ECR registry.
        
         
         
        
          Set the --region value to the AWS Region where you want to create the Amazon ECR repository.
        
          Replace 111122223333 with your AWS account ID.
        
          aws ecr get-login-password --region us-east-1 | docker login --username AWS --password-stdin 111122223333.dkr.ecr.us-east-1.amazonaws.com
          
        
        Create a repository in Amazon ECR using the create-repository command.
        aws ecr create-repository --repository-name hello-world --region us-east-1 --image-scanning-configuration scanOnPush=true --image-tag-mutability MUTABLE
        
        NoteThe Amazon ECR repository must be in the same AWS Region as the Lambda function.
        If successful, you see a response like this:
        {
    "repository": {
        "repositoryArn": "arn:aws:ecr:us-east-1:111122223333:repository/hello-world",
        "registryId": "111122223333",
        "repositoryName": "hello-world",
        "repositoryUri": "111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world",
        "createdAt": "2023-03-09T10:39:01+00:00",
        "imageTagMutability": "MUTABLE",
        "imageScanningConfiguration": {
            "scanOnPush": true
        },
        "encryptionConfiguration": {
            "encryptionType": "AES256"
        }
    }
}
        
      
        Copy the repositoryUri from the output in the previous step.
      
        Run the docker tag command to tag your local image into your Amazon ECR repository as the latest version. In this command: 
        
         
         
        
          docker-image:test is the name and tag of your Docker image. This is the image name and tag that you specified in the docker build command.
        
          Replace <ECRrepositoryUri> with the repositoryUri that you copied. Make sure to include :latest at the end of the URI.
        
        docker tag docker-image:test <ECRrepositoryUri>:latest
      Example:
      docker tag docker-image:test 111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest
      
      
      Run the docker push command to deploy your local image to the Amazon ECR repository. Make sure to include :latest at the end of the repository URI.
docker push 111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest

      
      Create an execution role for the function, if you don't already have one. You need the Amazon Resource Name (ARN) of the role in the next step.
      
        Create the Lambda function. For ImageUri, specify the repository URI from earlier. Make sure to include :latest at the end of the URI.
		aws lambda create-function \
  --function-name hello-world \
  --package-type Image \
  --code ImageUri=111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest \
  --role arn:aws:iam::111122223333:role/lambda-ex
  		
      NoteYou can create a function using an image in a different AWS account, as long as the image is in the same Region as the Lambda function. For more information, see  Amazon ECR cross-account permissions.  
      
      Invoke the function.
      aws lambda invoke --function-name hello-world response.json
      You should see a response like this:
{
  "ExecutedVersion": "$LATEST", 
  "StatusCode": 200
}
    
    To see the output of the function, check the response.json file.
    To update the function code, you must build the image again, upload the new image to the Amazon ECR repository, and then use the update-function-code command to deploy the image to the Lambda function.Lambda resolves the image tag to a specific image digest. This means that if you point the image tag that was used to deploy the function to a new image in Amazon ECR, Lambda doesn't automatically update the function to use the new image.To deploy the new image to the same Lambda function, you must use the update-function-code command, even if the image tag in Amazon ECR remains the same. In the following example, the --publish option creates a new version of the function using the updated container image.aws lambda update-function-code \
  --function-name hello-world \
  --image-uri 111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest \
  --publish
  Document ConventionsDeploy .zip file archivesLayersDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAmazon ECRUser GuideRepository policies vs IAM
                policiesPrivate repository policies in Amazon ECRAmazon ECR uses resource-based permissions to control access to repositories. Resource-based
        permissions let you specify which users or roles have access to a repository and what
        actions they can perform on the repository. By default, only the AWS account that created the
        repository has access to the repository. You can apply a repository policy that allows additional
        access to your repository.TopicsRepository policies vs IAM
                policiesPrivate repository policy examples in Amazon ECRSetting a private repository policy
                statement in Amazon ECR
        Repository policies vs IAM
                policies
        Amazon ECR repository policies are a subset of IAM policies that are scoped for, and
            specifically used for, controlling access to individual Amazon ECR repositories. IAM
            policies are generally used to apply permissions for the entire Amazon ECR service but can
            also be used to control access to specific resources as well.
        Both Amazon ECR repository policies and IAM policies are used when determining which
            actions a specific user or role may perform on a repository. If a user or role is
            allowed to perform an action through a repository policy but is denied permission
            through an IAM policy (or vice versa) then the action will be denied. A user or role
            only needs to be allowed permission for an action through either a repository policy or
            an IAM policy but not both for the action to be allowed.
        ImportantAmazon ECR requires that users have permission to make calls to the
                    ecr:GetAuthorizationToken API through an IAM policy before they
                can authenticate to a registry and push or pull any images from any Amazon ECR
                repository. Amazon ECR provides several managed IAM policies to control user access at
                varying levels; for more information, see Amazon Elastic Container Registry Identity-based policy
                examples.
        You can use either of these policy types to control access to your repositories, as
            shown in the following examples.
        This example shows an Amazon ECR repository policy, which allows for a specific user to
            describe the repository and the images within the repository.
        {
    "Version": "2012-10-17",
    "Statement": [
        {
            "Sid": "ECRRepositoryPolicy",
            "Effect": "Allow",
            "Principal": {"AWS": "arn:aws:iam::account-id:user/username"},
            "Action": [
                "ecr:DescribeImages",
                "ecr:DescribeRepositories"
            ]
        }
    ]
}
        This example shows an IAM policy that achieves the same goal as above, by scoping
            the policy to a repository (specified by the full ARN of the repository) using the
            resource parameter. For more information about Amazon Resource Name (ARN) format, see
                Resources.
        {
    "Version": "2012-10-17",
    "Statement": [
        {
            "Sid": "AllowDescribeRepoImage",
            "Effect": "Allow",
            "Action": [
                "ecr:DescribeImages",
                "ecr:DescribeRepositories"
            ],
            "Resource": ["arn:aws:ecr:region:account-id:repository/repository-name"]
        }
    ]
}
    Document ConventionsDeleting a repositoryRepository policy examplesDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAmazon ECRUser GuideSetting a private repository policy
                statement in Amazon ECRYou can add an access policy statement to a repository in the AWS Management Console by following
            the steps below. You can add multiple policy statements per repository. For example
            policies, see Private repository policy examples in Amazon ECR.ImportantAmazon ECR requires that users have permission to make calls to the
                    ecr:GetAuthorizationToken API through an IAM policy before they
                can authenticate to a registry and push or pull any images from any Amazon ECR
                repository. Amazon ECR provides several managed IAM policies to control user access at
                varying levels; for more information, see Amazon Elastic Container Registry Identity-based policy
                examples.To set a repository policy statementOpen the Amazon ECR console at
         https://console.aws.amazon.com/ecr/repositories.
                From the navigation bar, choose the Region that contains the repository to set
                    a policy statement on.
            
                In the navigation pane, choose Repositories.
            
                On the Repositories page, choose the repository to set a
                    policy statement on to view the contents of the repository.
            
                From the repository image list view, in the navigation pane, choose
                        Permissions, Edit.
                NoteIf you don't see the Permissions option in the
                        navigation pane, ensure that you are in the repository image list
                        view.
            
                On the Edit permissions page, choose Add
                        statement.
            
                For Statement name, enter a name for the
                    statement.
            
                For Effect, choose whether the policy statement will
                    result in an allow or an explicit deny.
            
                For Principal, choose the scope to apply the policy
                    statement to. For more information, see AWS JSON
                        Policy Elements: Principal in the
                        IAM User Guide.
                
                     
                     
                     
                     
                
                        You can apply the statement to all authenticated AWS users by
                            selecting the Everyone (*) check box.
                    
                        For Service principal, specify the service
                            principal name (for example, ecs.amazonaws.com) to apply
                            the statement to a specific service.
                    
                        For AWS Account IDs, specify an AWS account
                            number (for example, 111122223333) to apply the
                            statement to all users under a specific AWS account. Multiple accounts
                            can be specified by using a comma delimited list.
                        ImportantThe account you are granting permissions to must have the Region
                                you are creating the repository policy in enabled, otherwise an
                                error will occur.
                    
                        For IAM Entities, select the roles or users
                            under your AWS account to apply the statement to.
                        NoteFor more complicated repository policies that are not
                                    currently supported in the AWS Management Console, you can apply the policy with the set-repository-policy AWS CLI command.
                    
            
                For Actions, choose the scope of the Amazon ECR API operations
                    that the policy statement should apply to from the list of individual API
                    operations.
            
                When you are finished, choose Save to set the
                    policy.
            
                Repeat the previous step for each repository policy to add.
            Document ConventionsRepository policy examplesTagging a repositoryDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideFunction states during updatesLambda function statesLambda includes a State field in the function configuration for all functions to indicate when your function is ready to invoke. State provides information about the current status of the function, including whether you can successfully invoke the function. Function states do not change the behavior of function invocations or how your function runs the code.NoteFunction state definitions differ slightly for SnapStart functions. For more information, see Lambda SnapStart and function states.Function states include:
     
     
     
     
  
      Pending – After Lambda creates the function, it sets the state to pending. While in pending state, Lambda attempts to create or configure resources for the function, such as VPC or EFS resources. 
        Lambda does not invoke a function during pending state. Any invocations or other API actions that operate on the function will fail.
    
      Active – Your function transitions to active state after Lambda completes resource configuration and provisioning. 
        Functions can only be successfully invoked while active.
    
      Failed – Indicates that resource configuration or provisioning encountered an error.
    
      Inactive – A function becomes inactive when it has been idle
        long enough for Lambda to reclaim the external resources that were configured for it.
        When you try to invoke a function that is inactive, the invocation fails and Lambda
        sets the function to pending state until the function resources are recreated.
        If Lambda fails to recreate the resources, the function returns to the inactive state.
        You might need to resolve any errors and redeploy your function to
        restore it to the active state.
    If you are using SDK-based automation workflows or calling Lambda’s service APIs directly, ensure that you check a function's state before invocation to verify that it is active. 
    You can do this with the Lambda API action GetFunction, or by configuring a waiter using the 
    AWS SDK for Java 2.0.aws lambda get-function --function-name my-function --query 'Configuration.[State, LastUpdateStatus]'You should see the following output:[
 "Active",
 "Successful" 
]The following operations fail while function creation is pending:
     
     
     
     
  
      Invoke
    
      UpdateFunctionCode
    
      UpdateFunctionConfiguration
    
      PublishVersion
    
    Function states during updates  
    Lambda has two operations for updating functions:
    
       
       
    
        UpdateFunctionCode: Updates the function's deployment package
      
        UpdateFunctionConfiguration: Updates the function's configuration
      
    Lambda uses the LastUpdateStatus attribute to track the progress of these update operations. While an update is in progress (when "LastUpdateStatus": "InProgress"):
    
       
       
       
    
        The function's State remains Active.
      
        Invocations continue to use the function's previous code and configuration until the update completes.
      
        The following operations fail:
        
           
           
           
           
        
            UpdateFunctionCode
          
            UpdateFunctionConfiguration
          
            PublishVersion
          
            TagResource
          
      
    Example GetFunctionConfiguration responseThe following example is the result of GetFunctionConfiguration request on a function undergoing an update.{
    "FunctionName": "my-function",
    "FunctionArn": "arn:aws:lambda:us-east-1:123456789012:function:my-function",
    "Runtime": "nodejs22.x",
    "VpcConfig": {
        "SubnetIds": [
            "subnet-071f712345678e7c8",
            "subnet-07fd123456788a036",
            "subnet-0804f77612345cacf"
        ],
        "SecurityGroupIds": [
            "sg-085912345678492fb"
        ],
        "VpcId": "vpc-08e1234569e011e83"
    },
    "State": "Active",
    "LastUpdateStatus": "InProgress",
    ...
}
  Document ConventionsTesting in consoleRetriesDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideHow to use layersLayers and layer versionsManaging Lambda dependencies with layersA Lambda layer is a .zip file archive that contains supplementary code or data.
  Layers usually contain library dependencies, a custom runtime,
  or configuration files. There are multiple reasons why you might consider using layers:
     
     
     
     
  
      To reduce the size of your deployment packages.
        Instead of including all of your function dependencies along with your function code
        in your deployment package, put them in a layer. This keeps deployment packages small
        and organized.
    
      To separate core function logic from dependencies.
        With layers, you can update your function dependencies independent of your function code,
        and vice versa. This promotes separation of concerns and helps you focus on your function
        logic.
    
      To share dependencies across multiple functions.
        After you create a layer, you can apply it to any number of functions in your account.
        Without layers, you need to include the same dependencies in each individual deployment
        package.
    
      To use the Lambda console code editor. The code
        editor is a useful tool for testing minor function code updates quickly. However, you
        can’t use the editor if your deployment package size is too large. Using layers reduces
        your package size and can unlock usage of the code editor.
    If you're working with Lambda functions in Go or Rust, we recommend against using layers.
    For Go and Rust functions, you provide your function code as an executable, which includes your
    compiled function code along with all of its dependencies. Putting your dependencies in a
    layer forces your function to manually load additional assemblies during the initialization
    phase, which can increase cold start times. For optimal performance for Go and Rust functions,
    include your dependencies along with your deployment package.The following diagram illustrates the high-level architectural differences between two
    functions that share dependencies. One uses Lambda layers, and the other does not.
     
      
     
     
  When you add a layer to a function, Lambda extracts the layer contents into the /opt
    directory in your function’s execution environment.
    All natively supported Lambda runtimes include paths to specific directories within the
    /opt directory. This gives your function access to your layer content. For more
    information about these specific paths and how to properly package your layers, see
    Packaging your layer content.You can include up to five layers per function. Also, you can use layers only with Lambda functions
    deployed as a .zip file archive. For functions
    defined as a container image, package your preferred runtime
    and all code dependencies when you create the container image. For more information, see
    
    Working with Lambda layers and extensions in container images on the AWS Compute Blog.TopicsHow to use layersLayers and layer versionsPackaging your layer contentCreating and deleting layers in LambdaAdding layers to functionsUsing AWS CloudFormation with layersUsing AWS SAM with layers
    How to use layers
    To create a layer, package your dependencies into a .zip file, similar to how you
      create a normal deployment package. More
      specifically, the general process of creating and using layers involves these three steps:
    
       
       
       
    
        First, package your layer content. This means creating a
          .zip file archive. For more information, see Packaging your layer content.
      
        Next, create the layer in Lambda. For more information,
          see Creating and deleting layers in Lambda.
      
        Add the layer to your function(s). For more information,
          see Adding layers to functions.
      
   
    Layers and layer versions
    A layer version is an immutable snapshot of a specific version of a layer. When you create
      a new layer, Lambda creates a new layer version with a version number of 1. Each time you publish
      an update to the layer, Lambda increments the version number and creates a new layer version.
    Every layer version is identified by a unique Amazon Resource Name (ARN). When adding a layer
      to the function, you must specify the exact layer version you want to use.
  Document ConventionsApplication SignalsPackaging layersDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideHow to use layersLayers and layer versionsManaging Lambda dependencies with layersA Lambda layer is a .zip file archive that contains supplementary code or data.
  Layers usually contain library dependencies, a custom runtime,
  or configuration files. There are multiple reasons why you might consider using layers:
     
     
     
     
  
      To reduce the size of your deployment packages.
        Instead of including all of your function dependencies along with your function code
        in your deployment package, put them in a layer. This keeps deployment packages small
        and organized.
    
      To separate core function logic from dependencies.
        With layers, you can update your function dependencies independent of your function code,
        and vice versa. This promotes separation of concerns and helps you focus on your function
        logic.
    
      To share dependencies across multiple functions.
        After you create a layer, you can apply it to any number of functions in your account.
        Without layers, you need to include the same dependencies in each individual deployment
        package.
    
      To use the Lambda console code editor. The code
        editor is a useful tool for testing minor function code updates quickly. However, you
        can’t use the editor if your deployment package size is too large. Using layers reduces
        your package size and can unlock usage of the code editor.
    If you're working with Lambda functions in Go or Rust, we recommend against using layers.
    For Go and Rust functions, you provide your function code as an executable, which includes your
    compiled function code along with all of its dependencies. Putting your dependencies in a
    layer forces your function to manually load additional assemblies during the initialization
    phase, which can increase cold start times. For optimal performance for Go and Rust functions,
    include your dependencies along with your deployment package.The following diagram illustrates the high-level architectural differences between two
    functions that share dependencies. One uses Lambda layers, and the other does not.
     
      
     
     
  When you add a layer to a function, Lambda extracts the layer contents into the /opt
    directory in your function’s execution environment.
    All natively supported Lambda runtimes include paths to specific directories within the
    /opt directory. This gives your function access to your layer content. For more
    information about these specific paths and how to properly package your layers, see
    Packaging your layer content.You can include up to five layers per function. Also, you can use layers only with Lambda functions
    deployed as a .zip file archive. For functions
    defined as a container image, package your preferred runtime
    and all code dependencies when you create the container image. For more information, see
    
    Working with Lambda layers and extensions in container images on the AWS Compute Blog.TopicsHow to use layersLayers and layer versionsPackaging your layer contentCreating and deleting layers in LambdaAdding layers to functionsUsing AWS CloudFormation with layersUsing AWS SAM with layers
    How to use layers
    To create a layer, package your dependencies into a .zip file, similar to how you
      create a normal deployment package. More
      specifically, the general process of creating and using layers involves these three steps:
    
       
       
       
    
        First, package your layer content. This means creating a
          .zip file archive. For more information, see Packaging your layer content.
      
        Next, create the layer in Lambda. For more information,
          see Creating and deleting layers in Lambda.
      
        Add the layer to your function(s). For more information,
          see Adding layers to functions.
      
   
    Layers and layer versions
    A layer version is an immutable snapshot of a specific version of a layer. When you create
      a new layer, Lambda creates a new layer version with a version number of 1. Each time you publish
      an update to the layer, Lambda increments the version number and creates a new layer version.
    Every layer version is identified by a unique Amazon Resource Name (ARN). When adding a layer
      to the function, you must specify the exact layer version you want to use.
  Document ConventionsApplication SignalsPackaging layersDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideRuntime environment lifecycleCold starts and latencyReducing cold starts with Provisioned ConcurrencyOptimizing static initializationUnderstanding the Lambda execution environment lifecycle
      Lambda invokes your function in an execution environment, which provides a secure and isolated runtime
      environment. The execution environment manages the resources required to run your function. The execution
      environment also provides lifecycle support for the function's runtime and any external extensions associated with your function.
    The function's runtime communicates with Lambda using the Runtime API.
    Extensions communicate with Lambda using the Extensions API.
    Extensions can also receive log messages and other telemetry from the function by using the Telemetry API.
    
         
          
         
         
    When you create your Lambda function, you specify configuration information, such as the amount of memory
    available and the maximum execution time allowed for your function. Lambda uses this information to set up the
    execution environment.The function's runtime and each external extension are processes that run within the execution environment.
    Permissions, resources, credentials, and environment variables are shared between the function and the
    extensions.TopicsLambda execution environment lifecycleCold starts and latencyReducing cold starts with Provisioned ConcurrencyOptimizing static initialization
      Lambda execution environment lifecycle    
        
           
            
           
           
        
        Each phase starts with an event that Lambda sends to the runtime and to all registered extensions. The
        runtime and each extension indicate completion by sending a Next API request. Lambda freezes the
        execution environment when the runtime and each extension have completed and there are no pending events.
        TopicsInit phaseFailures during the Init phaseRestore phase (Lambda SnapStart only)Invoke phaseFailures during the invoke phaseShutdown phase
       
        Init phase
        In the Init phase, Lambda performs three tasks:
        
           
           
           
           
        
            Start all extensions (Extension init)
          
            Bootstrap the runtime (Runtime init)
          
            Run the function's static code (Function init)
          
            Run any before-checkpoint runtime hooks (Lambda SnapStart only)
          
        The Init phase ends when the runtime and all extensions signal that they are ready by sending a
            Next API request. The Init phase is limited to 10 seconds. If all three tasks do not
          complete within 10 seconds, Lambda retries the Init phase at the time of the first function
          invocation with the configured function timeout.
          When Lambda SnapStart is activated, the Init phase happens when you publish a function version. Lambda saves a snapshot of the memory and disk state of the initialized execution environment, persists the encrypted snapshot, and caches it for low-latency access. If you have a before-checkpoint runtime hook, then the code runs at the end of Init phase.
          NoteThe 10-second timeout doesn't apply to functions that are using provisioned concurrency
              or SnapStart. For provisioned concurrency and SnapStart functions, your initialization code
              can run for up to 15 minutes. The time limit is 130 seconds or the configured function
              timeout (maximum 900 seconds), whichever is higher.
        When you use provisioned concurrency,
          Lambda initializes the execution environment when you configure the PC settings for a function. Lambda also ensures that
          initialized execution environments are always available in advance of invocations. You may see gaps between your function's
          invocation and initialization phases. Depending on your function's runtime and memory configuration, you may also see variable
          latency on the first invocation on an initialized execution environment.
        For functions using on-demand concurrency, Lambda may occasionally initialize execution environments ahead of
          invocation requests. When this happens, you may also observe a time gap between your function's initialization and
          invocation phases. We recommend you to not take a dependency on this behavior.
       
       
        Failures during the Init phase
        If a function crashes or times out during the Init phase, Lambda emits error information in the INIT_REPORT log.
    Example  — INIT_REPORT log for timeoutINIT_REPORT Init Duration: 1236.04 ms Phase: init Status: timeout       
    Example  — INIT_REPORT log for extension failureINIT_REPORT Init Duration: 1236.04 ms Phase: init Status: error Error Type: Extension.Crash		
        If the Init phase is successful, Lambda doesn't emit the INIT_REPORT log unless SnapStart or 
          provisioned concurrency is enabled. SnapStart and provisioned concurrency functions always emit INIT_REPORT. 
          For more information, see Monitoring for Lambda SnapStart.
        
       
        Restore phase (Lambda SnapStart only)
        When you first invoke a SnapStart function and as the function scales up, Lambda resumes new execution environments from the persisted snapshot instead of initializing the function from scratch. If you have an after-restore runtime hook, the code runs at the end of the Restore phase. You are charged for the duration of after-restore runtime hooks. The runtime must load and after-restore runtime hooks must complete within the timeout limit (10 seconds). Otherwise, you'll get a SnapStartTimeoutException. When the Restore phase completes, Lambda invokes the function handler (the Invoke phase).
         
          Failures during the Restore phase
          If the Restore phase fails, Lambda emits error information in the RESTORE_REPORT log.
      Example  — RESTORE_REPORT log for timeoutRESTORE_REPORT Restore Duration: 1236.04 ms Status: timeout
      Example  — RESTORE_REPORT log for runtime hook failureRESTORE_REPORT Restore Duration: 1236.04 ms Status: error Error Type: Runtime.ExitError		
        For more information about the RESTORE_REPORT log, see Monitoring for Lambda SnapStart.
         
       
       
        Invoke phase
        When a Lambda function is invoked in response to a Next API request, Lambda sends an
            Invoke event to the runtime and to each extension.
        The function's timeout setting limits the duration of the entire Invoke phase. For example, if
          you set the function timeout as 360 seconds, the function and all extensions need to complete within 360
          seconds. Note that there is no independent post-invoke phase. The duration is the sum of all invocation time
          (runtime + extensions) and is not calculated until the function and all extensions have finished
          executing.
        The invoke phase ends after the runtime and all extensions signal that they are done by sending a
            Next API request.
       
       
        Failures during the invoke phase
        If the Lambda function crashes or times out during the Invoke phase, Lambda resets the
          execution environment. The following diagram illustrates Lambda execution environment behavior when
          there's an invoke failure:
        
           
            
           
           
        
        In the previous diagram:
        
           
           
           
           
           
        
            The first phase is the INIT phase, which runs
              without errors.
          
            The second phase is the INVOKE phase, which runs
              without errors.
          
            At some point, suppose your function runs into an invoke failure (such as a function
              timeout or runtime error). The third phase, labeled INVOKE WITH ERROR
              , illustrates this scenario. When this happens, the Lambda service performs a
              reset. The reset behaves like a Shutdown event. First, Lambda shuts down the
              runtime, then sends a Shutdown event to each registered external extension.
              The event includes the reason for the shutdown. If this environment is used for a new
              invocation, Lambda re-initializes the extension and runtime together with the next
              invocation.
            
            Note that the Lambda reset does not clear the /tmp directory content prior to the next init phase.
              This behavior is consistent with the regular shutdown phase.
            NoteAWS is currently implementing changes to the Lambda service. Due to these changes, you may see minor differences between the structure and content 
of system log messages and trace segments emitted by different Lambda functions in your AWS account.If your function's system log configuration is set to plain text, this change affects the log messages captured in CloudWatch Logs when your 
                function experiences an invoke failure. The following examples show log outputs in both old and new formats.These changes will be implemented during the coming weeks, and all functions in all 
AWS Regions except the China and GovCloud regions will transition to use the new-format log messages and trace segments.
            
            Example CloudWatch Logs log output (runtime or extension crash) - old styleSTART RequestId: c3252230-c73d-49f6-8844-968c01d1e2e1 Version: $LATEST
RequestId: c3252230-c73d-49f6-8844-968c01d1e2e1 Error: Runtime exited without providing a reason
Runtime.ExitError
END RequestId: c3252230-c73d-49f6-8844-968c01d1e2e1
REPORT RequestId: c3252230-c73d-49f6-8844-968c01d1e2e1 Duration: 933.59 ms Billed Duration: 934 ms Memory Size: 128 MB Max Memory Used: 9 MB
            Example CloudWatch Logs log output (function timeout) - old styleSTART RequestId: b70435cc-261c-4438-b9b6-efe4c8f04b21 Version: $LATEST
2024-03-04T17:22:38.033Z b70435cc-261c-4438-b9b6-efe4c8f04b21 Task timed out after 3.00 seconds
END RequestId: b70435cc-261c-4438-b9b6-efe4c8f04b21
REPORT RequestId: b70435cc-261c-4438-b9b6-efe4c8f04b21 Duration: 3004.92 ms Billed Duration: 3000 ms Memory Size: 128 MB Max Memory Used: 33 MB Init Duration: 111.23 ms
            The new format for CloudWatch logs includes an additional statusfield in the REPORT line. In the case of a runtime or 
              extension crash, the REPORT line also includes a field ErrorType.
            
            Example CloudWatch Logs log output (runtime or extension crash) - new styleSTART RequestId: 5b866fb1-7154-4af6-8078-6ef6ca4c2ddd Version: $LATEST
END RequestId: 5b866fb1-7154-4af6-8078-6ef6ca4c2ddd
REPORT RequestId: 5b866fb1-7154-4af6-8078-6ef6ca4c2ddd Duration: 133.61 ms Billed Duration: 133 ms Memory Size: 128 MB Max Memory Used: 31 MB Init Duration: 80.00 ms Status: error Error Type: Runtime.ExitError
            Example CloudWatch Logs log output (function timeout) - new styleSTART RequestId: 527cb862-4f5e-49a9-9ae4-a7edc90f0fda Version: $LATEST
END RequestId: 527cb862-4f5e-49a9-9ae4-a7edc90f0fda
REPORT RequestId: 527cb862-4f5e-49a9-9ae4-a7edc90f0fda Duration: 3016.78 ms Billed Duration: 3016 ms Memory Size: 128 MB Max Memory Used: 31 MB Init Duration: 84.00 ms Status: timeout
          
            The fourth phase represents the INVOKE phase
              immediately following an invoke failure. Here, Lambda initializes the environment again
              by re-running the INIT phase. This is called a
              suppressed init. When suppressed inits occur, Lambda doesn't
              explicitly report an additional INIT phase in CloudWatch Logs.
              Instead, you may notice that the duration in the REPORT line includes an additional
              INIT duration + the
              INVOKE duration. For example, suppose you see the
              following logs in CloudWatch:
            2022-12-20T01:00:00.000-08:00 START RequestId: XXX Version: $LATEST 
2022-12-20T01:00:02.500-08:00 END RequestId: XXX 
2022-12-20T01:00:02.500-08:00 REPORT RequestId: XXX Duration: 3022.91 ms 
Billed Duration: 3000 ms Memory Size: 512 MB Max Memory Used: 157 MB
            In this example, the difference between the REPORT and START timestamps is 2.5 seconds.
              This doesn't match the reported duration of 3022.91 millseconds, because it doesn't take
              into account the extra INIT (suppressed init) that Lambda
              performed. In this example, you can infer that the actual
              INVOKE phase took 2.5 seconds.
            For more insight into this behavior, you can use the
              Accessing real-time telemetry data for extensions using the Telemetry API. The Telemetry API emits
              INIT_START, INIT_RUNTIME_DONE, and INIT_REPORT
              events with phase=invoke whenever suppressed inits occur in between
              invoke phases.
          
            The fifth phase represents the SHUTDOWN phase, which runs
              without errors.
          
       
       
        Shutdown phase
        When Lambda is about to shut down the runtime, it sends a Shutdown event to
          each registered external extension. Extensions can use this time for final cleanup tasks. The Shutdown event
          is a response to a Next API request.
        Duration limit: The maximum duration of the
          Shutdown phase depends on the configuration of registered extensions:
      
         
         
         
      
          0 ms – A function with no registered extensions
        
          500 ms – A function with a registered internal extension
        
          2,000 ms – A function with one or more registered external extensions
        
      If the runtime or an extension does not respond to the Shutdown event within the limit, Lambda
        ends the process using a SIGKILL signal.
        After the function and all extensions have completed, Lambda maintains the execution
          environment for some time in anticipation of another function invocation. However, Lambda terminates execution environments every few hours to allow for runtime updates and maintenance—even for functions that are invoked continuously. You should
          not assume that the execution environment will persist indefinitely. For more information, see
          Implement statelessness in functions.
        When the function is invoked again, Lambda thaws the environment for reuse. Reusing the
        execution environment has the following implications: 
        
           
           
           
        
            Objects declared outside of the function's handler method remain initialized, providing additional
              optimization when the function is invoked again. For example, if your Lambda function establishes a database
              connection, instead of reestablishing the connection, the original connection is used in subsequent
              invocations. We recommend adding logic in your code to check if a connection exists before creating a new
              one.
          
            Each execution environment provides between 512 MB and 10,240 MB, in 1-MB increments, of disk space in the /tmp
              directory. The directory content remains when the execution environment is frozen, providing a transient
              cache that can be used for multiple invocations. You can add extra code to check if the cache has the data
              that you stored. For more information on deployment size limits, see Lambda quotas.
          
            Background processes or callbacks that were initiated by your Lambda function and did not complete when
              the function ended resume if Lambda reuses the execution environment. Make sure that any background processes
              or callbacks in your code are complete before the code exits.
          
         
     
    Cold starts and latency
    When Lambda receives a request to run a function via the Lambda API, the service first prepares an execution
      environment. During this initialization phase, the service downloads your code, starts the environment, and
      runs any initialization code outside of the main handler. Finally, Lambda runs the handler code.
    
       
        
       
       
    
    In this diagram, the first two steps of downloading the code and setting up the environment are frequently referred
      to as a “cold start”. You are not charged for this time, but it does add latency to your overall invocation duration.
    After the invocation completes, the execution environment is frozen. To improve resource management and performance,
      Lambda retains the execution environment for a period of time. During this time, if another request arrives for the same
      function, Lambda can reuse the environment. This second request typically finishes more quickly, since the execution
      environment is already fully set up. This is called a “warm start”.
    Cold starts typically occur in under 1% of invocations. The duration of a cold start varies from under 100 ms to over
      1 second. In general, cold starts are typically more common in development and test functions than production workloads.
      This is because development and test functions are usually invoked less frequently.
   
    Reducing cold starts with Provisioned Concurrency
    If you need predictable function start times for your workload, provisioned
      concurrency is the recommended solution to ensure the lowest possible latency. This feature pre-initializes
      execution environments, reducing cold starts.
    For example, a function with a provisioned concurrency of 6 has 6 execution environments pre-warmed.
    
       
        
       
       
    
   
    Optimizing static initialization
    Static initialization happens before the handler code starts running in a function. This is the initialization code
      that you provide, that is outside of the main handler. This code is often used to import libraries and dependencies,
      set up configurations, and initialize connections to other services.
    The following Python example shows importing, and configuring modules, and creating the Amazon S3 client during the
      initialization phase, before the lambda_handler function runs during invoke.
    import os
import json
import cv2
import logging
import boto3

s3 = boto3.client('s3')
logger = logging.getLogger()
logger.setLevel(logging.INFO)

def lambda_handler(event, context):

  # Handler logic...

    The largest contributor of latency before function execution comes from initialization code. This code runs when
      a new execution environment is created for the first time. The initialization code is not run again if an invocation
      uses a warm execution environment. Factors that affect initialization code latency include:
    
       
       
       
    
        The size of the function package, in terms of imported libraries and dependencies, and Lambda layers.
      
        The amount of code and initialization work.
      
        The performance of libraries and other services in setting up connections and other resources.
      
    There are a number of steps that developers can take to optimize static initialization latency. If a function has
      many objects and connections, you may be able to rearchitect a single function into multiple, specialized functions.
      These are individually smaller and each have less initialization code.
    It’s important that functions only import the libraries and dependencies that they need. For example, if you only
      use Amazon DynamoDB in the AWS SDK, you can require an individual service instead of the entire SDK. Compare the following
      three examples:
    // Instead of const AWS = require('aws-sdk'), use:
const DynamoDB = require('aws-sdk/clients/dynamodb')

// Instead of const AWSXRay = require('aws-xray-sdk'), use:
const AWSXRay = require('aws-xray-sdk-core')

// Instead of const AWS = AWSXRay.captureAWS(require('aws-sdk')), use:
const dynamodb = new DynamoDB.DocumentClient()
AWSXRay.captureAWSClient(dynamodb.service)
    Static initialization is also often the best place to open database connections to allow a function to reuse
      connections over multiple invocations to the same execution environment. However, you may have large numbers of
      objects that are only used in certain execution paths in your function. In this case, you can lazily load variables
      in the global scope to reduce the static initialization duration.
    Avoid global variables for context-specific information. If your function has a global variable that is used
      only for the lifetime of a single invocation and is reset for the next invocation, use a variable scope that is
      local to the handler. Not only does this prevent global variable leaks across invocations, it also improves the
      static initialization performance.
  Document ConventionsProgramming modelEvent-driven architecturesDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideLayer paths for each Lambda runtimePackaging your layer contentA Lambda layer is a .zip file archive that contains supplementary code or data.
  Layers usually contain library dependencies, a custom runtime,
  or configuration files. This section explains how to properly package your layer content. For more
    conceptual information about layers and why you might consider using them, see
    Managing Lambda dependencies with layers.The first step to creating a layer is to bundle all of your layer content
    into a .zip file archive. Because Lambda functions run on
    Amazon Linux,
    your layer content must be able to compile and build in a Linux environment.To ensure that your layer content works properly in a Linux environment,
    we recommend creating your layer content using a tool like
    Docker or
    AWS Cloud9. AWS Cloud9 is a cloud-based
    integrated development environment (IDE) that provides built-in access to a
    Linux server for running and testing code. For more information, see
    
    Using Lambda layers to simplify your development process on the AWS
    Compute Blog.TopicsLayer paths for each Lambda runtime
    Layer paths for each Lambda runtime
    When you add a layer to a function, Lambda loads the layer content into the
      /opt directory of that execution environment. For each Lambda runtime,
      the PATH variable already includes specific folder paths within the
      /opt directory. To ensure that Lambda picks up your layer content, 
      your layer .zip file should have its dependencies
      in the following folder paths:
    
          
            Runtime
            Path
          
        
          
            
              Node.js
            
            
              nodejs/node_modules
            
          
          
            
              nodejs/node16/node_modules (NODE_PATH)
            
          
          
            
              nodejs/node18/node_modules (NODE_PATH)
            
          
          
            
              nodejs/node20/node_modules (NODE_PATH)
            
          
          
            
              Python
            
            
              python
            
          
          
            
              python/lib/python3.x/site-packages (site directories)
            
          
          
            
              Java
            
            
              java/lib (CLASSPATH)
            
          
          
            
              Ruby
            
            
              ruby/gems/3.3.0 (GEM_PATH)
            
          
          
            
              ruby/lib (RUBYLIB)
            
          
          
            
              All runtimes
            
            
              bin (PATH)  
            
          
          
            
              lib (LD_LIBRARY_PATH)
            
          
        
    The following examples show how you can structure the folders in your layer .zip archive.
    
      Node.js
          Example file structure for the AWS X-Ray SDK for Node.jsxray-sdk.zip
└ nodejs/node_modules/aws-xray-sdk
        
      Python
          Example file structure for the Requests librarylayer_content.zip
└ python
    └ lib
        └ python3.13
            └ site-packages
                └ requests
                └ <other_dependencies> (i.e. dependencies of the requests package)
                └ ...
        
      Ruby
          Example file structure for the JSON gemjson.zip
└ ruby/gems/3.3.0/
               | build_info
               | cache
               | doc
               | extensions
               | gems
               | └ json-2.1.0
               └ specifications
                 └ json-2.1.0.gemspec
        
      Java
          Example file structure for the Jackson JAR filelayer_content.zip
└ java
    └ lib
        └ jackson-core-2.17.0.jar
        └ <other potential dependencies>
        └ ...
        
      All
          Example file structure for the jq libraryjq.zip
└ bin/jq
        
    
    For language-specific instructions on packaging, creating, and adding
      a layer, refer to the following pages:
    
       
       
       
       
       
    
        Node.js – Working with layers for Node.js Lambda functions
      
        Python – Working with layers for Python Lambda functions
      
        Ruby – Working with layers for Ruby Lambda functions
      
        Java – Working with layers for Java Lambda functions
      
        TypeScript – Working with layers for TypeScript Lambda functions
      
    We recommend against using layers to manage dependencies for Lambda functions written in Go and Rust. This is 
    because Lambda functions written in these languages compile into a single executable, which you provide to Lambda when you deploy your function. This 
    executable contains your compiled function code, along with all of its dependencies. Using layers not only complicates this process, but also leads to 
    increased cold start times because your functions need to manually load extra assemblies into memory during the init phase.
    To use external dependencies with Go and Rust Lambda functions, include them directly in your deployment package.
      
  Document ConventionsLambda layersCreating and deleting layersDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideCreating the functionUsing the console code editorUpdating function codeChanging the runtimeChanging the architectureUsing the Lambda APIDownloading your function codeAWS CloudFormationDeploying Lambda functions as .zip file archivesWhen you create a Lambda function, you package your function code into a deployment package. Lambda supports two
    types of deployment packages: container images and .zip file archives. The workflow 
    to create a function depends on the
    deployment package type. To configure a function defined as a container image, see Create a Lambda function using a container image.You can use the Lambda console and the Lambda API to create a function defined with a .zip file archive. You can
    also upload an updated .zip file to change the function code.
  NoteYou cannot change the deployment package type (.zip or container image) for an existing function. For example, you cannot convert a container image function to use a .zip file archive. You must create a new function.TopicsCreating the functionUsing the console code editorUpdating function codeChanging the runtimeChanging the architectureUsing the Lambda APIDownloading your function codeAWS CloudFormationEncrypting Lambda .zip deployment packages
    Creating the function
    When you create a function defined with a .zip file archive, you choose a code template, the language version,
      and the execution role for the function. You add your function code after Lambda creates the function.
    To create the functionOpen the Functions page of the Lambda console.
        Choose Create function.
      
        Choose Author from scratch or Use a blueprint to create your
          function.  
      
        Under Basic information, do the following:
        
            For Function name, enter the function name. Function names are limited to 64 characters in length.
          
            For Runtime, choose the language version to use for your function.
          
            (Optional) For Architecture, choose the instruction set architecture to use for
              your function. The default architecture is x86_64. When you build the deployment package for your
              function, make sure that it is compatible with this instruction set
                architecture.
          
      
        (Optional) Under Permissions, expand Change default execution
            role. You can create a new Execution role or use an existing role.
      
        (Optional) Expand Advanced settings. You can choose a Code signing
            configuration for the function. You can also configure an (Amazon VPC) for the function to
          access.
      
        Choose Create function.
      
    Lambda creates the new function. You can now use the console to add the function code and configure other function parameters and features. 
      For code deployment instructions, see the handler page for the runtime your function uses.
    
    
  Node.js
      Deploy Node.js Lambda functions with .zip file archives 
    
  
  Python
    
      Working with .zip file archives for Python Lambda functions
    
  
  Ruby
    
      Deploy Ruby Lambda functions with .zip file archives
    
    
  
  Java
    
      Deploy Java Lambda functions with .zip or JAR file archives
    
    
  
  Go
    
      Deploy Go Lambda functions with .zip file archives
    
    
  
  C#
    
      Build and deploy C# Lambda functions with .zip file archives
    
    
  
  PowerShell
    
      Deploy PowerShell Lambda functions with .zip file archives
    
    

   
    Using the console code editor
    The console creates a Lambda function with a single source file. For scripting languages, you can edit
      this file and add more files using the built-in code editor.
      To save your changes, choose Save.
      Then, to run your code, choose Test.
    
     When you save your function code, the Lambda console creates a .zip file archive deployment package. 
   When you develop your function code outside of the console (using an IDE) you need to create a
      deployment package to upload your code to the Lambda function.
   
    Updating function code
    For scripting languages (Node.js, Python, and Ruby), you can edit your function code in the embedded code
        editor. If the code is larger than 3MB, or if you need to add libraries, or
      for languages that the editor doesn't support (Java, Go, C#), you must upload your function code as a .zip
      archive. If the .zip file archive is smaller than 50 MB, you can upload the .zip file archive from your local
      machine. If the file is larger than 50 MB, upload the file to the function from an Amazon S3 bucket.
    To upload function code as a .zip archive Open the Functions page of the Lambda console.
        Choose the function to update and choose the  Code tab.
      
        Under Code source, choose Upload from.
      
        Choose .zip file, and then choose Upload. 
        In the file chooser, select the new image version, choose Open, and then choose
                Save.
      
        (Alternative to step 4) Choose Amazon S3 location.
        
            In the text box, enter the S3 link URL of the .zip file archive, then choose Save.
          
      
   
    Changing the runtime
    If you update the function configuration to use a new runtime, you may need to update the function
      code to be compatible with the new runtime. If you update the function configuration to use a different runtime,
      you must provide new function code that is compatible with the runtime and
      architecture. For instructions on how to create a deployment package for the function code, see the handler page
      for the runtime that the function uses.
    The Node.js 20, Python 3.12, Java 21, .NET 8, Ruby 3.3, and later base images are based on the Amazon Linux 2023 minimal container image. Earlier base images use Amazon Linux 2. AL2023 provides several advantages over Amazon Linux 2, including a smaller deployment footprint and updated versions of libraries such as glibc. For more information, see Introducing the Amazon Linux 2023 runtime for AWS Lambda on the AWS
      Compute Blog.
    To change the runtimeOpen the Functions page of the Lambda console.
        Choose the function to update and choose the Code tab.
      
        Scroll down to the Runtime settings section, which is under the code editor.
      
        Choose Edit.
        
            For Runtime, select the runtime identifier.
          
            For Handler, specify file name and handler for your function.
          
            For Architecture, choose the instruction set architecture to use for your
              function.
          
      
        Choose Save.
      
   
    Changing the architecture
    Before you can change the instruction set architecture, you need to ensure that your function's code is
      compatible with the target architecture. 
    If you use Node.js, Python, or Ruby and you edit your function code in the embedded editor, the existing code may run without modification.
    However, if you provide your function code using a .zip file archive deployment package, you must prepare a
      new .zip file archive that is compiled and built correctly for the target runtime and instruction-set
      architecture. For instructions, see the handler page for your function runtime.
    To change the instruction set architectureOpen the Functions page of the Lambda console.
        Choose the function to update and choose the Code tab.
      
        Under Runtime settings, choose Edit.
      
        For Architecture, choose the instruction set architecture to use for your
          function.
      
        Choose Save.
      
   
    Using the Lambda API
    To create and configure a function that uses a .zip file archive, use the following API operations: 
    
       
       
       
    
        CreateFunction
      
        UpdateFunctionCode
      
        UpdateFunctionConfiguration
      
   
    Downloading your function code
    You can download the current unpublished ($LATEST) version of your function code .zip
      via the Lambda console. To do this, first ensure that you have the following IAM permissions:
    
       
       
       
       
       
       
       
    
        iam:GetPolicy
      
        iam:GetPolicyVersion
      
        iam:GetRole
      
        iam:GetRolePolicy
      
        iam:ListAttachedRolePolicies
      
        iam:ListRolePolicies
      
        iam:ListRoles
      
    To download the function code .zip
        Open the Functions page of the Lambda console.
      
        Choose the function you want to download the function code .zip for.
      
        In the Function overview, choose the Download
          button, then choose Download function code .zip.
        
            Alternatively, choose Download AWS SAM file to generate and
              download a SAM template based on your function's configuration. You can also choose
              Download both to download both the .zip and the SAM template.
          
      
   
    AWS CloudFormation
    
    You can use AWS CloudFormation to create a Lambda function that uses a .zip file archive. In your AWS CloudFormation template, the
      AWS::Lambda::Function resource specifies the Lambda function. For descriptions of the properties in
      the AWS::Lambda::Function resource, see AWS::Lambda::Function in the
      AWS CloudFormation User Guide.
    In the AWS::Lambda::Function resource, set the following properties to create a function defined
      as a .zip file archive:
    
       
    
        AWS::Lambda::Function
        
           
           
           
           
        PackageType – Set to Zip.Code – Enter the Amazon S3 bucket name and .zip file name in the S3Bucket and
              S3Keyfields. For Node.js or Python, you can provide inline source code of your Lambda
              function. 
            Runtime – Set the runtime value.
          
            Architecture – Set the architecture value to arm64 to use the AWS Graviton2
              processor. By default, the architecture value is x86_64.
          
      
  Document ConventionsConfiguring functionsEncryptionDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideCreating a layerDeleting a layer versionCreating and deleting layers in LambdaA Lambda layer is a .zip file archive that contains supplementary code or data.
  Layers usually contain library dependencies, a custom runtime,
  or configuration files. This section explains how to create and delete layers in Lambda. For more conceptual
    information about layers and why you might consider using them, see
    Managing Lambda dependencies with layers.After you’ve packaged your layer content, the
    next step is to create the layer in Lambda. This section demonstrates how to create and
    delete layers using the Lambda console or the Lambda API only. To create a layer using
    AWS CloudFormation, see Using AWS CloudFormation with layers. To create a layer using the
    AWS Serverless Application Model (AWS SAM), see Using AWS SAM with layers.TopicsCreating a layerDeleting a layer version
    Creating a layer
    To create a layer, you can either upload the .zip file archive from your local
      machine or from Amazon Simple Storage Service (Amazon S3). Lambda extracts the layer contents into the
      /opt directory when setting up the execution environment for the function.
    Layers can have one or more layer versions.
      When you create a layer, Lambda sets the layer version to version 1. You can change the
      permissions on an existing layer version at any time. However, to update the code or make
      other configuration changes, you must create a new version of the layer.
    To create a layer (console)
        Open the Layers page
          of the Lambda console.
      
        Choose Create layer.
      
        Under Layer configuration, for Name,
          enter a name for your layer.
      
        (Optional) For Description, enter a description for
          your layer.
      
        To upload your layer code, do one of the following:
        
          
            To upload a .zip file from your computer, choose Upload a
              .zip file. Then, choose Upload to select
              your local .zip file.
          
          
            To upload a file from Amazon S3, choose Upload a file from
              Amazon S3. Then, for Amazon S3 link URL,
              enter a link to the file.
          
        
      
        (Optional) For Compatible architectures, choose one
          value or both values. For more information, see Selecting and configuring an instruction set architecture for your Lambda function.
      
        (Optional) For Compatible runtimes, choose the
          runtimes that your layer is compatible with.
      
        (Optional) For License, enter any necessary
          license information.
      
        Choose Create.
      
    Alternatively, you can also use the PublishLayerVersion API to create a layer.
      For example, you can use the publish-layer-version AWS Command Line Interface (CLI) command
      with a name, description, and .zip file archive specified. The license info, compatible
      runtimes, and compatible architecture parameters are optional.
    aws lambda publish-layer-version --layer-name my-layer \
    --description "My layer" \
    --license-info "MIT" \
    --zip-file fileb://layer.zip \
    --compatible-runtimes python3.10 python3.11 \
    --compatible-architectures "arm64" "x86_64"
    You should see output similar to the following:
    {
    "Content": {
        "Location": "https://awslambda-us-east-2-layers.s3.us-east-2.amazonaws.com/snapshots/123456789012/my-layer-4aaa2fbb-ff77-4b0a-ad92-5b78a716a96a?versionId=27iWyA73cCAYqyH...",
        "CodeSha256": "tv9jJO+rPbXUUXuRKi7CwHzKtLDkDRJLB3cC3Z/ouXo=",
        "CodeSize": 169
    },
    "LayerArn": "arn:aws:lambda:us-east-2:123456789012:layer:my-layer",
    "LayerVersionArn": "arn:aws:lambda:us-east-2:123456789012:layer:my-layer:1",
    "Description": "My layer",
    "CreatedDate": "2023-11-14T23:03:52.894+0000",
    "Version": 1,
    "CompatibleArchitectures": [
        "arm64",
        "x86_64"
     ],
    "LicenseInfo": "MIT",
    "CompatibleRuntimes": [
        "python3.10",
        "python3.11"
    ]
}
    Each time you call publish-layer-version, you create a new version
      of the layer.
   
    Deleting a layer version
    To delete a layer version, use the DeleteLayerVersion API. For example,
      you can use the delete-layer-version CLI command with the layer name
      and layer version specified.
    aws lambda delete-layer-version --layer-name my-layer --version-number 1
    When you delete a layer version, you can no longer configure a Lambda function
      to use it. However, any function that already uses the version continues to have
      access to it. Also, Lambda never reuses version numbers for a layer name.
    When calculating quotas, deleting
      a layer version means it's no longer counted as part of the default 75 GB quota for
      storage of functions and layers. However, for functions that consume a deleted layer
      version, the layer content still counts towards the function's deployment package size
      quota (i.e. 250MB for .zip file archives).
  Document ConventionsPackaging layersAdding layersDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideAccessing layer content from your functionFinding layer informationAdding layers to functionsA Lambda layer is a .zip file archive that contains supplementary code or data.
  Layers usually contain library dependencies, a custom runtime,
  or configuration files. This section explains how to add a layer to a Lambda function. For more conceptual
    information about layers and why you might consider using them, see
    Managing Lambda dependencies with layers.Before you can configure a Lambda function to use a layer, you must:
     
     
     
  
      Package your layer content
    
      Create a layer in Lambda
    
      Make sure that you have permission to call the GetLayerVersion API on the
        layer version. For functions in your AWS account, you must have this permission in
        your user policy. To use a layer
        in another account, the owner of that account must grant your account permission in a
        resource-based policy. For
        examples, see Granting Lambda layer access to other accounts.
    You can add up to five layers to a Lambda function. The total unzipped size of the
    function and all layers cannot exceed the unzipped deployment package size quota of 250 MB.
    For more information, see Lambda quotas.Your functions can continue to use any layer version that you’ve already added, even
    after that layer version has been deleted, or after your permission to access the layer
    is revoked. However, you cannot create a new function that uses a deleted layer version.NoteMake sure that the layers you add to a function are compatible with the runtime
    and instruction set architecture of the function.To add a layer to a function (console)Open the Functions page of the Lambda console.
      Choose the function to configure.
    
      Under Layers, choose Add a layer
    
      Under Choose a layer, choose a layer source:
      
          For the AWS layers or Custom layers
          layer sources, choose a layer from the pull-down menu. Under Version,
          choose a layer version from the pull-down menu.
        
          For the Specify an ARN layer source, enter an ARN in the
            text box and choose Verify. Then, choose Add.
        
    The order in which you add the layers is the order in which Lambda merges the layer content
    into the execution environment. You can change the layer merge order using the console.To update layer merge order for your function (console)Open the Functions page of the Lambda console.
      Choose the function to configure.
    
      Under Layers, choose Edit
    
      Choose one of the layers.
    
      Choose Merge earlier or Merge later to adjust the order of the layers.
    
      Choose Save.
    Layers are versioned. The content of each layer version is immutable. The owner of a
    layer can release new layer versions to provide updated content. You can use the console
    to update the layer version attached to your functions.To update layer versions for your function (console)
      Open the Layers page
        of the Lambda console.
    
      Choose the layer you want to update the version for.
    
      Choose the Functions using this version tab.
    
      Choose the functions you want to modify, then choose Edit.
    
      For Layer version, choose the layer version to change to.
    
      Choose Update functions.
    You cannot update function layer versions across AWS accounts.TopicsAccessing layer content from your functionFinding layer information
    Accessing layer content from your function
    If your Lambda function includes layers, Lambda extracts the layer contents into the
      /opt directory in the function execution environment. Lambda extracts the layers
      in the order (low to high) listed by the function. Lambda merges folders with the same name.
      If the same file appears in multiple layers, the function uses the version in the last
      extracted layer.
    Each Lambda runtime adds specific /opt directory folders to the
      PATH variable. Your function code can access the layer content without having
      to specify the path. For more information about path settings in the Lambda execution
      environment, see Defined runtime environment variables.
    Refer to Layer paths for each Lambda runtime to learn where to include your
      libraries when creating a layer.
    If you’re using a Node.js or Python runtime, you can use the built-in code editor
      in the Lambda console. You should be able to import any library that you’ve added as
      a layer to the current function.
   
    Finding layer information
    To find layers in your account that are compatible with your function’s runtime,
      use the ListLayers API. For example, you can use the following list-layers
      AWS Command Line Interface (CLI) command:
    aws lambda list-layers --compatible-runtime python3.9
    You should see output similar to the following:
    {
    "Layers": [
        {
            "LayerName": "my-layer",
            "LayerArn": "arn:aws:lambda:us-east-2:123456789012:layer:my-layer",
            "LatestMatchingVersion": {
                "LayerVersionArn": "arn:aws:lambda:us-east-2:123456789012:layer:my-layer:2",
                "Version": 2,
                "Description": "My layer",
                "CreatedDate": "2023-11-15T00:37:46.592+0000",
                "CompatibleRuntimes": [
                    "python3.9",
                    "python3.10",
                    "python3.11",
                ]
            }
        }
    ]
}
    To list all layers in your account, omit the --compatible-runtime option.
      The response details show the latest version of each layer.
    You can also get the latest version of a layer using the ListLayerVersions API.
      For example, you can use the following list-layer-versions CLI command:
    aws lambda list-layer-versions --layer-name my-layer
    You should see output similar to the following:
    {
    "LayerVersions": [
        {
            "LayerVersionArn": "arn:aws:lambda:us-east-2:123456789012:layer:my-layer:2",
            "Version": 2,
            "Description": "My layer",
            "CreatedDate": "2023-11-15T00:37:46.592+0000",
            "CompatibleRuntimes": [
                "java11"
            ]
        },
        {
            "LayerVersionArn": "arn:aws:lambda:us-east-2:123456789012:layer:my-layer:1",
            "Version": 1,
            "Description": "My layer",
            "CreatedDate": "2023-11-15T00:27:46.592+0000",
            "CompatibleRuntimes": [
                "java11"
            ]
        }
    ]
}
  Document ConventionsCreating and deleting layersLayers with AWS CloudFormationDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideUsing AWS CloudFormation with layersYou can use AWS CloudFormation to create a layer and associate the layer with your Lambda function.
    The following example template creates a layer named my-lambda-layer and
    attaches the layer to the Lambda function using the Layers
    property.In this example, the template specifies the Amazon Resource Name (ARN) of an existing IAM execution role.
    You can also create a new execution role in the template using the AWS CloudFormation AWS::IAM::Role resource.Your function doesn't need any special permissions to use layers.---
Description: CloudFormation Template for Lambda Function with Lambda Layer
Resources:
  MyLambdaLayer:
    Type: AWS::Lambda::LayerVersion
    Properties:
      LayerName: my-lambda-layer
      Description: My Lambda Layer
      Content:
        S3Bucket: amzn-s3-demo-bucket
        S3Key: my-layer.zip
      CompatibleRuntimes:
        - python3.9
        - python3.10
        - python3.11

  MyLambdaFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: my-lambda-function
      Runtime: python3.9
      Handler: index.handler
      Timeout: 10
      Role: arn:aws:iam::111122223333:role/my_lambda_role
      Layers:
        - !Ref MyLambdaLayerDocument ConventionsAdding layersLayers with AWS SAMDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideUsing AWS SAM with layersYou can use the AWS Serverless Application Model (AWS SAM) to automate the creation of layers in your
    application. The AWS::Serverless::LayerVersion resource type creates
    a layer version that you can reference from your Lambda function configuration.AWSTemplateFormatVersion: '2010-09-09'
Transform: 'AWS::Serverless-2016-10-31'
Description: AWS SAM Template for Lambda Function with Lambda Layer

Resources:
  MyLambdaLayer:
    Type: AWS::Serverless::LayerVersion
    Properties:
      LayerName: my-lambda-layer
      Description: My Lambda Layer
      ContentUri: s3://amzn-s3-demo-bucket/my-layer.zip
      CompatibleRuntimes:
        - python3.9
        - python3.10
        - python3.11

  MyLambdaFunction:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName: MyLambdaFunction
      Runtime: python3.9
      Handler: app.handler
      CodeUri: s3://amzn-s3-demo-bucket/my-function
      Layers:
        - !Ref MyLambdaLayerDocument ConventionsLayers with AWS CloudFormationLambda extensionsDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideExecution environmentImpact on performance and resources PermissionsAugment Lambda functions using Lambda extensionsYou can use Lambda extensions to augment your Lambda functions. For example, use Lambda extensions to integrate
    functions with your preferred monitoring, observability, security, and governance tools. You can choose from a broad
    set of tools that AWS Lambda Partners provides, or you can
    create your own Lambda extensions.Lambda supports external and internal extensions. An external extension runs as an independent process in the
    execution environment and continues to run after the function invocation is fully processed. Because extensions run
    as separate processes, you can write them in a different language than the function. All Lambda runtimes support extensions.An internal extension runs as part of the runtime process. Your function accesses internal extensions by using
    wrapper scripts or in-process mechanisms such as JAVA_TOOL_OPTIONS. For more information, see Modifying the runtime environment.You can add extensions to a function using the Lambda console, the AWS Command Line Interface (AWS CLI), or infrastructure as code
    (IaC) services and tools such as AWS CloudFormation, AWS Serverless Application Model (AWS SAM), and Terraform.You are charged for the execution time that the extension consumes (in 1 ms increments). There is no cost to
    install your own extensions. For more pricing information for extensions, see
    AWS Lambda Pricing. For pricing
    information for partner extensions, see those partners' websites. See AWS Lambda extensions partners
    for a list of official partner extensions.For a tutorial on extensions and how to use them with your Lambda functions, see the
    AWS Lambda Extensions Workshop.TopicsExecution environmentImpact on performance and resources PermissionsConfiguring Lambda extensionsAWS Lambda extensions partnersUsing the Lambda Extensions API to create extensionsAccessing real-time telemetry data for extensions using the Telemetry API
    Execution environment
    Lambda invokes your function in an execution environment, which
      provides a secure and isolated runtime environment. The execution environment manages the resources required to
      run your function and provides lifecycle support for the function's runtime and extensions.
    
The lifecycle of the execution environment includes the following phases:
      
         
         
         
         
      
          Init: In this phase, Lambda creates or
            unfreezes an execution environment with the configured resources, downloads the code for the function and
            all layers, initializes any extensions, initializes the runtime, and then runs the function’s initialization
            code (the code outside the main handler). The Init phase happens either during the first
            invocation, or in advance of function invocations if you have enabled provisioned concurrency.
          The Init phase is split into three sub-phases: Extension init, 
          Runtime init, and Function init. These sub-phases ensure that all extensions and the runtime complete their setup tasks before the function code runs.
          When Lambda SnapStart is activated, the Init phase happens when you publish a function version. Lambda saves a snapshot of the memory and disk state of the initialized execution environment, persists the encrypted snapshot, and caches it for low-latency access. If you have a before-checkpoint runtime hook, then the code runs at the end of Init phase.
        
        Restore (SnapStart only): When you first invoke a SnapStart function and as the function scales up, Lambda resumes new execution environments from the persisted snapshot instead of initializing the function from scratch. If you have an after-restore runtime hook, the code runs at the end of the Restore phase. You are charged for the duration of after-restore runtime hooks. The runtime must load and after-restore runtime hooks must complete within the timeout limit (10 seconds). Otherwise, you'll get a SnapStartTimeoutException. When the Restore phase completes, Lambda invokes the function handler (the Invoke phase).
        
          Invoke: In this phase, Lambda invokes the function handler.
            After the function runs to completion, Lambda prepares to handle another function
            invocation.
        
          Shutdown: This phase is triggered if the Lambda function does not
            receive any invocations for a period of time. In the Shutdown phase, Lambda shuts down
            the runtime, alerts the extensions to let them stop cleanly, and then removes the environment. Lambda
            sends a Shutdown event to each extension, which tells the extension that the environment is about
            to be shut down.
        

    During the Init phase, Lambda extracts layers containing extensions into the /opt
      directory in the execution environment. Lambda looks for extensions in the /opt/extensions/ directory,
      interprets each file as an executable bootstrap for launching the extension, and starts all extensions in
      parallel.
   
    Impact on performance and resources 
    The size of your function's extensions counts towards the deployment package size limit. For a .zip file
      archive, the total unzipped size of the function and all extensions cannot exceed the unzipped deployment package
      size limit of 250 MB.
    Extensions can impact the performance of your function because they share function resources such as CPU,
      memory, and storage. For example, if an extension performs compute-intensive operations, you may see your
      function's execution duration increase.
    Each extension must complete its initialization before Lambda invokes the function. Therefore, an extension
      that consumes significant initialization time can increase the latency of the function invocation.
    To measure the extra time that the extension takes after the function execution, you can use the
      PostRuntimeExtensionsDuration
      function metric. To measure the increase in memory used, you can use the
      MaxMemoryUsed metric. To understand the impact of a specific extension, you can run different
      versions of your functions side by side.
    NoteMaxMemoryUsed metric is one of the Metrics collected by Lambda Insights and not a Lambda native metric.
   
    Permissions
    Extensions have access to the same resources as functions. Because extensions are executed within the same
      environment as the function, permissions are shared between the function and the extension.
    For a .zip file archive, you can create an AWS CloudFormation template to simplify the task of attaching the same extension
      configuration—including AWS Identity and Access Management (IAM) permissions—to multiple functions.
  Document ConventionsLayers with AWS SAMConfiguring extensionsDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideExecution environmentImpact on performance and resources PermissionsAugment Lambda functions using Lambda extensionsYou can use Lambda extensions to augment your Lambda functions. For example, use Lambda extensions to integrate
    functions with your preferred monitoring, observability, security, and governance tools. You can choose from a broad
    set of tools that AWS Lambda Partners provides, or you can
    create your own Lambda extensions.Lambda supports external and internal extensions. An external extension runs as an independent process in the
    execution environment and continues to run after the function invocation is fully processed. Because extensions run
    as separate processes, you can write them in a different language than the function. All Lambda runtimes support extensions.An internal extension runs as part of the runtime process. Your function accesses internal extensions by using
    wrapper scripts or in-process mechanisms such as JAVA_TOOL_OPTIONS. For more information, see Modifying the runtime environment.You can add extensions to a function using the Lambda console, the AWS Command Line Interface (AWS CLI), or infrastructure as code
    (IaC) services and tools such as AWS CloudFormation, AWS Serverless Application Model (AWS SAM), and Terraform.You are charged for the execution time that the extension consumes (in 1 ms increments). There is no cost to
    install your own extensions. For more pricing information for extensions, see
    AWS Lambda Pricing. For pricing
    information for partner extensions, see those partners' websites. See AWS Lambda extensions partners
    for a list of official partner extensions.For a tutorial on extensions and how to use them with your Lambda functions, see the
    AWS Lambda Extensions Workshop.TopicsExecution environmentImpact on performance and resources PermissionsConfiguring Lambda extensionsAWS Lambda extensions partnersUsing the Lambda Extensions API to create extensionsAccessing real-time telemetry data for extensions using the Telemetry API
    Execution environment
    Lambda invokes your function in an execution environment, which
      provides a secure and isolated runtime environment. The execution environment manages the resources required to
      run your function and provides lifecycle support for the function's runtime and extensions.
    
The lifecycle of the execution environment includes the following phases:
      
         
         
         
         
      
          Init: In this phase, Lambda creates or
            unfreezes an execution environment with the configured resources, downloads the code for the function and
            all layers, initializes any extensions, initializes the runtime, and then runs the function’s initialization
            code (the code outside the main handler). The Init phase happens either during the first
            invocation, or in advance of function invocations if you have enabled provisioned concurrency.
          The Init phase is split into three sub-phases: Extension init, 
          Runtime init, and Function init. These sub-phases ensure that all extensions and the runtime complete their setup tasks before the function code runs.
          When Lambda SnapStart is activated, the Init phase happens when you publish a function version. Lambda saves a snapshot of the memory and disk state of the initialized execution environment, persists the encrypted snapshot, and caches it for low-latency access. If you have a before-checkpoint runtime hook, then the code runs at the end of Init phase.
        
        Restore (SnapStart only): When you first invoke a SnapStart function and as the function scales up, Lambda resumes new execution environments from the persisted snapshot instead of initializing the function from scratch. If you have an after-restore runtime hook, the code runs at the end of the Restore phase. You are charged for the duration of after-restore runtime hooks. The runtime must load and after-restore runtime hooks must complete within the timeout limit (10 seconds). Otherwise, you'll get a SnapStartTimeoutException. When the Restore phase completes, Lambda invokes the function handler (the Invoke phase).
        
          Invoke: In this phase, Lambda invokes the function handler.
            After the function runs to completion, Lambda prepares to handle another function
            invocation.
        
          Shutdown: This phase is triggered if the Lambda function does not
            receive any invocations for a period of time. In the Shutdown phase, Lambda shuts down
            the runtime, alerts the extensions to let them stop cleanly, and then removes the environment. Lambda
            sends a Shutdown event to each extension, which tells the extension that the environment is about
            to be shut down.
        

    During the Init phase, Lambda extracts layers containing extensions into the /opt
      directory in the execution environment. Lambda looks for extensions in the /opt/extensions/ directory,
      interprets each file as an executable bootstrap for launching the extension, and starts all extensions in
      parallel.
   
    Impact on performance and resources 
    The size of your function's extensions counts towards the deployment package size limit. For a .zip file
      archive, the total unzipped size of the function and all extensions cannot exceed the unzipped deployment package
      size limit of 250 MB.
    Extensions can impact the performance of your function because they share function resources such as CPU,
      memory, and storage. For example, if an extension performs compute-intensive operations, you may see your
      function's execution duration increase.
    Each extension must complete its initialization before Lambda invokes the function. Therefore, an extension
      that consumes significant initialization time can increase the latency of the function invocation.
    To measure the extra time that the extension takes after the function execution, you can use the
      PostRuntimeExtensionsDuration
      function metric. To measure the increase in memory used, you can use the
      MaxMemoryUsed metric. To understand the impact of a specific extension, you can run different
      versions of your functions side by side.
    NoteMaxMemoryUsed metric is one of the Metrics collected by Lambda Insights and not a Lambda native metric.
   
    Permissions
    Extensions have access to the same resources as functions. Because extensions are executed within the same
      environment as the function, permissions are shared between the function and the extension.
    For a .zip file archive, you can create an AWS CloudFormation template to simplify the task of attaching the same extension
      configuration—including AWS Identity and Access Management (IAM) permissions—to multiple functions.
  Document ConventionsLayers with AWS SAMConfiguring extensionsDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideExecution environmentImpact on performance and resources PermissionsAugment Lambda functions using Lambda extensionsYou can use Lambda extensions to augment your Lambda functions. For example, use Lambda extensions to integrate
    functions with your preferred monitoring, observability, security, and governance tools. You can choose from a broad
    set of tools that AWS Lambda Partners provides, or you can
    create your own Lambda extensions.Lambda supports external and internal extensions. An external extension runs as an independent process in the
    execution environment and continues to run after the function invocation is fully processed. Because extensions run
    as separate processes, you can write them in a different language than the function. All Lambda runtimes support extensions.An internal extension runs as part of the runtime process. Your function accesses internal extensions by using
    wrapper scripts or in-process mechanisms such as JAVA_TOOL_OPTIONS. For more information, see Modifying the runtime environment.You can add extensions to a function using the Lambda console, the AWS Command Line Interface (AWS CLI), or infrastructure as code
    (IaC) services and tools such as AWS CloudFormation, AWS Serverless Application Model (AWS SAM), and Terraform.You are charged for the execution time that the extension consumes (in 1 ms increments). There is no cost to
    install your own extensions. For more pricing information for extensions, see
    AWS Lambda Pricing. For pricing
    information for partner extensions, see those partners' websites. See AWS Lambda extensions partners
    for a list of official partner extensions.For a tutorial on extensions and how to use them with your Lambda functions, see the
    AWS Lambda Extensions Workshop.TopicsExecution environmentImpact on performance and resources PermissionsConfiguring Lambda extensionsAWS Lambda extensions partnersUsing the Lambda Extensions API to create extensionsAccessing real-time telemetry data for extensions using the Telemetry API
    Execution environment
    Lambda invokes your function in an execution environment, which
      provides a secure and isolated runtime environment. The execution environment manages the resources required to
      run your function and provides lifecycle support for the function's runtime and extensions.
    
The lifecycle of the execution environment includes the following phases:
      
         
         
         
         
      
          Init: In this phase, Lambda creates or
            unfreezes an execution environment with the configured resources, downloads the code for the function and
            all layers, initializes any extensions, initializes the runtime, and then runs the function’s initialization
            code (the code outside the main handler). The Init phase happens either during the first
            invocation, or in advance of function invocations if you have enabled provisioned concurrency.
          The Init phase is split into three sub-phases: Extension init, 
          Runtime init, and Function init. These sub-phases ensure that all extensions and the runtime complete their setup tasks before the function code runs.
          When Lambda SnapStart is activated, the Init phase happens when you publish a function version. Lambda saves a snapshot of the memory and disk state of the initialized execution environment, persists the encrypted snapshot, and caches it for low-latency access. If you have a before-checkpoint runtime hook, then the code runs at the end of Init phase.
        
        Restore (SnapStart only): When you first invoke a SnapStart function and as the function scales up, Lambda resumes new execution environments from the persisted snapshot instead of initializing the function from scratch. If you have an after-restore runtime hook, the code runs at the end of the Restore phase. You are charged for the duration of after-restore runtime hooks. The runtime must load and after-restore runtime hooks must complete within the timeout limit (10 seconds). Otherwise, you'll get a SnapStartTimeoutException. When the Restore phase completes, Lambda invokes the function handler (the Invoke phase).
        
          Invoke: In this phase, Lambda invokes the function handler.
            After the function runs to completion, Lambda prepares to handle another function
            invocation.
        
          Shutdown: This phase is triggered if the Lambda function does not
            receive any invocations for a period of time. In the Shutdown phase, Lambda shuts down
            the runtime, alerts the extensions to let them stop cleanly, and then removes the environment. Lambda
            sends a Shutdown event to each extension, which tells the extension that the environment is about
            to be shut down.
        

    During the Init phase, Lambda extracts layers containing extensions into the /opt
      directory in the execution environment. Lambda looks for extensions in the /opt/extensions/ directory,
      interprets each file as an executable bootstrap for launching the extension, and starts all extensions in
      parallel.
   
    Impact on performance and resources 
    The size of your function's extensions counts towards the deployment package size limit. For a .zip file
      archive, the total unzipped size of the function and all extensions cannot exceed the unzipped deployment package
      size limit of 250 MB.
    Extensions can impact the performance of your function because they share function resources such as CPU,
      memory, and storage. For example, if an extension performs compute-intensive operations, you may see your
      function's execution duration increase.
    Each extension must complete its initialization before Lambda invokes the function. Therefore, an extension
      that consumes significant initialization time can increase the latency of the function invocation.
    To measure the extra time that the extension takes after the function execution, you can use the
      PostRuntimeExtensionsDuration
      function metric. To measure the increase in memory used, you can use the
      MaxMemoryUsed metric. To understand the impact of a specific extension, you can run different
      versions of your functions side by side.
    NoteMaxMemoryUsed metric is one of the Metrics collected by Lambda Insights and not a Lambda native metric.
   
    Permissions
    Extensions have access to the same resources as functions. Because extensions are executed within the same
      environment as the function, permissions are shared between the function and the extension.
    For a .zip file archive, you can create an AWS CloudFormation template to simplify the task of attaching the same extension
      configuration—including AWS Identity and Access Management (IAM) permissions—to multiple functions.
  Document ConventionsLayers with AWS SAMConfiguring extensionsDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideLambda execution environment
        lifecycleExtensions API referenceUsing the Lambda Extensions API to create extensionsLambda function authors use extensions to integrate Lambda with their preferred tools for monitoring,
    observability, security, and governance. Function authors can use extensions from AWS, AWS Partners, and
    open-source projects. For more information on using extensions, see Introducing AWS Lambda Extensions on the AWS
    Compute Blog. This section describes how to use the Lambda Extensions API, the Lambda execution environment lifecycle, and the Lambda Extensions API reference. 
     
      
     
     
  As an extension author, you can use the Lambda Extensions API to integrate deeply into the Lambda execution environment. Your extension can register for function and execution
    environment lifecycle events. In response to these events, you can start new processes, run logic, and control and
    participate in all phases of the Lambda lifecycle: initialization, invocation, and shutdown. In addition, you can use
    the Runtime Logs API to receive a stream of logs.An extension runs as an independent process in the execution environment and can continue to run after the
    function invocation is fully processed. Because extensions run as processes, you can write them in a different
    language than the function. We recommend that you implement extensions using a compiled language. In this case, the
    extension is a self-contained binary that is compatible with supported runtimes. All Lambda runtimes support extensions. If you use a non-compiled language, ensure that you include
    a compatible runtime in the extension. Lambda also supports internal extensions. An internal extension runs as a separate thread in
    the runtime process. The runtime starts and stops the internal extension. An alternative way to integrate with the Lambda environment is to
    use language-specific environment variables and wrapper scripts. You can use
    these to configure the runtime environment and modify the startup behavior of the runtime process.You can add extensions to a function in two ways. For a function deployed as a .zip file archive, you deploy your extension as a layer. For a function defined as a container image, you add the extensions to your container image.NoteFor example extensions and wrapper scripts, see AWS Lambda Extensions on
      the AWS Samples GitHub repository.TopicsLambda execution environment
        lifecycleExtensions API reference
    Lambda execution environment
        lifecycle
    
    The lifecycle of the execution environment includes the following phases:
      
         
         
         
      
          Init: In this phase, Lambda creates or
            unfreezes an execution environment with the configured resources, downloads the code for the function and
            all layers, initializes any extensions, initializes the runtime, and then runs the function’s initialization
            code (the code outside the main handler). The Init phase happens either during the first
            invocation, or in advance of function invocations if you have enabled provisioned concurrency.
          The Init phase is split into three sub-phases: Extension init, 
          Runtime init, and Function init. These sub-phases ensure that all extensions and the runtime complete their setup tasks before the function code runs.
        
          Invoke: In this phase, Lambda invokes the function handler.
            After the function runs to completion, Lambda prepares to handle another function
            invocation.
        
          Shutdown: This phase is triggered if the Lambda function does not
            receive any invocations for a period of time. In the Shutdown phase, Lambda shuts down
            the runtime, alerts the extensions to let them stop cleanly, and then removes the environment. Lambda
            sends a Shutdown event to each extension, which tells the extension that the environment is about
            to be shut down.
        
    Each phase starts with an event from Lambda to the runtime and to all registered extensions. The runtime and
      each extension signal completion by sending a Next API request. Lambda freezes the execution
      environment when each process has completed and there are no pending events.
    
       
        
       
       
    
     
    TopicsInit phaseInvoke phaseShutdown phasePermissions and
          configurationFailure handlingTroubleshooting extensions
     
      Init phase
      During the Extension init phase, each extension needs to register with
        Lambda to receive events. Lambda uses the full file name of the extension to validate that the
        extension has completed the bootstrap sequence. Therefore, each Register API
        call must include the Lambda-Extension-Name header with the full file name of
        the extension.
      You can register up to 10 extensions for a function. This limit is enforced through the
          Register API call.
      After each extension registers, Lambda starts the Runtime init phase. The
        runtime process calls functionInit to start the Function init
        phase.
      The Init phase completes after the runtime and each registered extension
        indicate completion by sending a Next API request.
      NoteExtensions can complete their initialization at any point in the Init
          phase.
      
         
          
         
         
      
     
     
      Invoke phase
      When a Lambda function is invoked in response to a Next API request, Lambda
        sends an Invoke event to the runtime and to each extension that is registered
        for the Invoke event.
      During the invocation, external extensions run in parallel with the function. They also continue running
        after the function has completed. This enables you to capture diagnostic information or to send logs, metrics,
        and traces to a location of your choice.
      After receiving the function response from the runtime, Lambda returns the response to the client, even if
        extensions are still running.
      The Invoke phase ends after the runtime and all extensions signal that they
        are done by sending a Next API request. 
      
         
          
         
         
      
      Event payload: The event sent to the runtime (and the
        Lambda function) carries the entire request, headers (such as RequestId), and
        payload. The event sent to each extension contains metadata that describes the event
        content. This lifecycle event includes the type of the event, the time that the function
        times out (deadlineMs), the requestId, the invoked function's
        Amazon Resource Name (ARN), and tracing headers.
      Extensions that want to access the function event body can use an in-runtime SDK that
        communicates with the extension. Function developers use the in-runtime SDK to send the
        payload to the extension when the function is invoked.
      Here is an example payload:
      {
    "eventType": "INVOKE",
    "deadlineMs": 676051,
    "requestId": "3da1f2dc-3222-475e-9205-e2e6c6318895",
    "invokedFunctionArn": "arn:aws:lambda:us-east-1:123456789012:function:ExtensionTest",
    "tracing": {
        "type": "X-Amzn-Trace-Id",
        "value": "Root=1-5f35ae12-0c0fec141ab77a00bc047aa2;Parent=2be948a625588e32;Sampled=1"
    }
 }          
      Duration limit: The function's timeout setting limits the duration of the entire Invoke phase. For example, if you set
        the function timeout as 360 seconds, the function and all extensions need to complete within 360 seconds. Note
        that there is no independent post-invoke phase. The duration is the total time it takes for your runtime and 
        all your extensions' invocations to complete and is not calculated until the function and all extensions have finished running.
      Performance impact and extension overhead: Extensions
        can impact function performance. As an extension author, you have control over the
        performance impact of your extension. For example, if your extension performs
        compute-intensive operations, the function's duration increases because the extension and
        the function code share the same CPU resources. In addition, if your extension performs
        extensive operations after the function invocation completes, the function duration
        increases because the Invoke phase continues until all extensions signal that
        they are completed.
      NoteLambda allocates CPU power in proportion to the function's memory setting. You might see increased
          execution and initialization duration at lower memory settings because the function and extension processes
          are competing for the same CPU resources. To reduce the execution and initialization duration, try increasing
          the memory setting.
      To help identify the performance impact introduced by extensions on the Invoke phase, Lambda
        outputs the PostRuntimeExtensionsDuration metric. This metric measures the cumulative time spent
        between the runtime Next API request and the last extension Next API request. To
        measure the increase in memory used, use the MaxMemoryUsed metric. For more information about
        function metrics, see Using CloudWatch metrics with Lambda.
      Function developers can run different versions of their functions side by side to
        understand the impact of a specific extension. We recommend that extension authors publish
        expected resource consumption to make it easier for function developers to choose a suitable
        extension.
     
     
      Shutdown phase
      When Lambda is about to shut down the runtime, it sends a Shutdown to each registered external extension. 
        Extensions can use this time for final cleanup tasks. The
          Shutdown event is sent in response to a Next API request.
      Duration limit: The maximum duration of the
          Shutdown phase depends on the configuration of registered extensions:
      
         
         
         
      
          0 ms – A function with no registered extensions
        
          500 ms – A function with a registered internal extension
        
          2,000 ms – A function with one or more registered external extensions
        
      If the runtime or an extension does not respond to the Shutdown event within the limit, Lambda
        ends the process using a SIGKILL signal.
      
         
          
         
         
      
      Event payload: The Shutdown event contains
        the reason for the shutdown and the time remaining in milliseconds.
       The shutdownReason includes the following values:
      
         
         
         
      
          SPINDOWN – Normal shutdown
        
          TIMEOUT – Duration limit timed out
        
          FAILURE – Error condition, such as an out-of-memory event
        
      
{ 
  "eventType": "SHUTDOWN", 
  "shutdownReason": "reason for shutdown", 
  "deadlineMs": "the time and date that the function times out in Unix time milliseconds" 
}        
      
     
     
      Permissions and
          configuration
      Extensions run in the same execution environment as the Lambda function. Extensions also
        share resources with the function, such as CPU, memory, and /tmp disk storage.
        In addition, extensions use the same AWS Identity and Access Management (IAM) role and security context as the
        function.
      File system and network access permissions: Extensions run in the same file
        system and network name namespace as the function runtime. This means that extensions need to be compatible with
        the associated operating system. If an extension requires any additional
        outbound
        network traffic rules, you must apply these rules to the function configuration.
      NoteBecause the function code directory is read-only, extensions cannot modify the
          function code.
      Environment variables: Extensions can access the
        function's environment variables, except for
        the following variables that are specific to the runtime process:
      
         
         
         
         
         
         
         
         
         
         
      
          AWS_EXECUTION_ENV
        
          AWS_LAMBDA_LOG_GROUP_NAME
        
          AWS_LAMBDA_LOG_STREAM_NAME
        
          AWS_XRAY_CONTEXT_MISSING
        
          AWS_XRAY_DAEMON_ADDRESS
        
          LAMBDA_RUNTIME_DIR
        
          LAMBDA_TASK_ROOT
        
          _AWS_XRAY_DAEMON_ADDRESS
        
          _AWS_XRAY_DAEMON_PORT
        
          _HANDLER
        
     
     
      Failure handling
      Initialization failures: If an extension fails, Lambda
        restarts the execution environment to enforce consistent behavior and to encourage fail fast
        for extensions. Also, for some customers, the extensions must meet mission-critical needs
        such as logging, security, governance, and telemetry collection.
      Invoke failures (such as out of memory, function
        timeout): Because extensions share resources with the runtime, memory exhaustion affects
        them. When the runtime fails, all extensions and the runtime itself participate in the
          Shutdown phase. In addition, the runtime is restarted—either
        automatically as part of the current invocation, or via a deferred re-initialization
        mechanism.
      If there is a failure (such as a function timeout or runtime error) during
        Invoke, the Lambda service performs a reset. The reset behaves like a
        Shutdown event. First, Lambda shuts down the runtime, then it sends a
        Shutdown event to each registered external extension. The event includes the
        reason for the shutdown. If this environment is used for a new invocation, the extension and
        runtime are re-initialized as part of the next invocation.
      
         
          
         
         
      
      For a more detailed explanation of the previous diagram, see
        Failures during the invoke phase.
      Extension logs: Lambda sends the log output of
        extensions to CloudWatch Logs. Lambda also generates an additional log event for each extension during
          Init. The log event records the name and registration preference (event,
        config) on success, or the failure reason on failure.
     
     
      Troubleshooting extensions
      
         
         
      
          If a Register request fails, make sure that the
              Lambda-Extension-Name header in the Register API call
            contains the full file name of the extension.
        
          If the Register request fails for an internal extension, make sure that
            the request does not register for the Shutdown event.
        
     
   
    Extensions API reference
    The OpenAPI specification for the extensions API version 2020-01-01 is available here: extensions-api.zip
    You can retrieve the value of the API endpoint from the
        AWS_LAMBDA_RUNTIME_API environment variable. To send a Register
      request, use the prefix 2020-01-01/ before each API path. For example:
    http://${AWS_LAMBDA_RUNTIME_API}/2020-01-01/extension/register 
    API methodsRegisterNextInit errorExit error
     
      Register
      During Extension init, all extensions need to register with Lambda to
        receive events. Lambda uses the full file name of the extension to validate that the
        extension has completed the bootstrap sequence. Therefore, each Register API
        call must include the Lambda-Extension-Name header with the full file name of
        the extension.
      Internal extensions are started and stopped by the runtime process, so they are not
        permitted to register for the Shutdown event.
      Path – /extension/register
      Method – POST
      Request headers
      
         
         
      
          Lambda-Extension-Name – The full file name of the extension.
            Required: yes. Type: string.
        
          Lambda-Extension-Accept-Feature – Use this to specify optional
            Extensions features during registration. Required: no. Type: comma separated string.
            Features available to specify using this setting:
          
             
          
              accountId – If specified, the Extension registration
                response will contain the account ID associated with the Lambda function that
                you're registering the Extension for.
            
        
      
        Request body parameters
         
      
          events – Array of the events to register for. Required: no. Type:
            array of strings. Valid strings: INVOKE, SHUTDOWN.
        
      
        Response headers
         
      
          Lambda-Extension-Identifier – Generated unique agent identifier
            (UUID string) that is required for all subsequent requests.
        
      
        Response codes
         
         
         
         
      
          200 – Response body contains the function name, function version, and handler
            name.
        
          400 – Bad Request
        
          403 – Forbidden
        
          500 – Container error. Non-recoverable state. Extension should exit
            promptly.
        
      Example request body{
    'events': [ 'INVOKE', 'SHUTDOWN']
}             
      Example response body{
    "functionName": "helloWorld",
    "functionVersion": "$LATEST",
    "handler": "lambda_function.lambda_handler"
}               
      Example response body with optional accountId feature{
    "functionName": "helloWorld",
    "functionVersion": "$LATEST",
    "handler": "lambda_function.lambda_handler",
    "accountId": "123456789012"
}
     
     
      Next
      Extensions send a Next API request to receive the next event, which can be
        an Invoke event or a Shutdown event. The response body contains
        the payload, which is a JSON document that contains event data.
      The extension sends a Next API request to signal that it is ready to
        receive new events. This is a blocking call.
      Do not set a timeout on the GET call, as the extension can be suspended for a period of
        time until there is an event to return.
      Path – /extension/event/next
      Method – GET
      
        Request headers
         
      
          Lambda-Extension-Identifier – Unique identifier for extension (UUID
            string). Required: yes. Type: UUID string.
        
      
        Response headers
         
      
          Lambda-Extension-Event-Identifier – Unique identifier for the event (UUID
            string).
        
      
        Response codes
         
         
         
      
          200 – Response contains information about the next event
              (EventInvoke or EventShutdown).
        
          403 – Forbidden
        
          500 – Container error. Non-recoverable state. Extension should exit
            promptly.
        
     
     
      Init error
      The extension uses this method to report an initialization error to Lambda. Call it when
        the extension fails to initialize after it has registered. After Lambda receives the error,
        no further API calls succeed. The extension should exit after it receives the response from
        Lambda.
      Path – /extension/init/error
      Method – POST
      
        Request headers
           
           
      
            Lambda-Extension-Identifier – Unique identifier for extension.
              Required: yes. Type: UUID string.
          
            Lambda-Extension-Function-Error-Type – Error type that the extension encountered.
              Required: yes. This header consists of a string value. Lambda accepts any string, but we recommend a format of
                <category.reason>. For example:
                
                   
                   
                   
                   
                Extension.NoSuchHandlerExtension.APIKeyNotFoundExtension.ConfigInvalidExtension.UnknownReason
          
      
        Request body parameters
         
      
          ErrorRequest – Information about the error. Required: no. 
        
      
    This field is a JSON object with the following structure:
    {
      errorMessage: string (text description of the error),
      errorType: string,
      stackTrace: array of strings
}    
Note that Lambda accepts any value for errorType.  
 The following example shows a Lambda function error message in which the function could not parse the event data
    provided in the invocation.
    Example Function error{
      "errorMessage" : "Error parsing event data.",
      "errorType" : "InvalidEventDataException",
      "stackTrace": [ ]
}      

      
        Response codes
         
         
         
         
      
          202 – Accepted
        
          400 – Bad Request
        
          403 – Forbidden
        
          500 – Container error. Non-recoverable state. Extension should exit
            promptly.
        
     
     
      Exit error
      The extension uses this method to report an error to Lambda before exiting. Call it when
        you encounter an unexpected failure. After Lambda receives the error, no further API calls
        succeed. The extension should exit after it receives the response from Lambda.
      Path – /extension/exit/error
      Method – POST
      
        Request headers
           
           
      
            Lambda-Extension-Identifier – Unique identifier for extension.
              Required: yes. Type: UUID string.
          
            Lambda-Extension-Function-Error-Type – Error type that the extension encountered.
              Required: yes. This header consists of a string value. Lambda accepts any string, but we recommend a format of
                <category.reason>. For example:
                
                   
                   
                   
                   
                Extension.NoSuchHandlerExtension.APIKeyNotFoundExtension.ConfigInvalidExtension.UnknownReason
          
      
        Request body parameters
         
      
          ErrorRequest – Information about the error. Required: no.
        
      
    This field is a JSON object with the following structure:
    {
      errorMessage: string (text description of the error),
      errorType: string,
      stackTrace: array of strings
}    
Note that Lambda accepts any value for errorType.  
 The following example shows a Lambda function error message in which the function could not parse the event data
    provided in the invocation.
    Example Function error{
      "errorMessage" : "Error parsing event data.",
      "errorType" : "InvalidEventDataException",
      "stackTrace": [ ]
}      

      
        Response codes
         
         
         
         
      
          202 – Accepted
        
          400 – Bad Request
        
          403 – Forbidden
        
          500 – Container error. Non-recoverable state. Extension should exit
            promptly.
        
       
     
  Document ConventionsExtensions partnersTelemetry APIDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideLanguage-specific environment variablesWrapper scriptsModifying the runtime environmentYou can use internal extensions to modify the runtime process. Internal
    extensions are not separate processes—they run as part of the runtime process.Lambda provides language-specific environment variables that you can
    set to add options and tools to the runtime. Lambda also provides wrapper
      scripts, which allow Lambda to delegate the runtime startup to your script. You can create a wrapper script
    to customize the runtime startup behavior.
    Language-specific environment variables
    Lambda supports configuration-only ways to enable code to be pre-loaded during function initialization through
      the following language-specific environment variables:
    
       
       
       
    
        JAVA_TOOL_OPTIONS – On Java, Lambda supports this
          environment variable to set additional command-line variables in Lambda. This environment variable allows you
          to specify the initialization of tools, specifically the launching of native or Java programming language
          agents using the agentlib or javaagent options. For more information, see
          JAVA_TOOL_OPTIONS environment variable.
      
        NODE_OPTIONS – Available in Node.js runtimes.
      
        DOTNET_STARTUP_HOOKS – On .NET Core 3.1 and above, this environment variable specifies
          a path to an assembly (dll) that Lambda can use.
      
    Using language-specific environment variables is the preferred way to set startup properties.
   
    Wrapper scripts
    You can create a wrapper script to customize the runtime startup behavior of your Lambda
      function. A wrapper script enables you to set configuration parameters that cannot be set through
      language-specific environment variables.
    NoteInvocations may fail if the wrapper script does not successfully start the runtime process.
    Wrapper scripts are supported on all native Lambda runtimes. Wrapper scripts are not supported on OS-only runtimes (the provided runtime family).
    When you use a wrapper script for your function, Lambda starts the runtime using your script. Lambda sends to
      your script the path to the interpreter and all of the original arguments for the standard runtime startup. Your
      script can extend or transform the startup behavior of the program. For example, the script can inject and alter
      arguments, set environment variables, or capture metrics, errors, and other diagnostic information.
    You specify the script by setting the value of the AWS_LAMBDA_EXEC_WRAPPER environment variable
      as the file system path of an executable binary or script.
     
      Example: Create and use a wrapper script as a Lambda layer
      In the following example, you create a wrapper script to start the Python interpreter with the -X
          importtime option. When you run the function, Lambda generates a log entry to show the duration of the
        import time for each import.
      To create and use a wrapper script as a layer
          Create a directory for the layer:
          mkdir -p python-wrapper-layer/bin
cd python-wrapper-layer/bin
        
          In the bin directory, paste the following code into a new file named
            importtime_wrapper. This is the wrapper script.
          #!/bin/bash

# the path to the interpreter and all of the originally intended arguments
args=("$@")

# the extra options to pass to the interpreter
extra_args=("-X" "importtime")

# insert the extra options
args=("${args[@]:0:$#-1}" "${extra_args[@]}" "${args[@]: -1}")

# start the runtime with the extra options
exec "${args[@]}"
        
          Give the script executable permissions:
          chmod +x importtime_wrapper
        
          Create a .zip file for the layer:
          cd ..
zip -r ../python-wrapper-layer.zip .
        
          Confirm that your .zip file has the following directory structure:
          python-wrapper-layer.zip
└ bin
    └ importtime_wrapper
        
          Create a layer using the .zip package.
        
          Create a function using the Lambda console.
          
              Open the Lambda console.
            
              Choose Create function.
            
              Enter a Function name.
            
              For Runtime, choose the Latest supported Python runtime.
            
              Choose Create function.
            
        
          Add the layer to your function.
          
              Choose your function, and then choose the Code tab if it's not already selected.
            
              Scroll down to the Layers section, and then choose Add a layer.
            
              For Layer source, select Custom layers, and then choose your layer from the Custom layers dropdown list.
            
               For Version, choose 1.
            
              Choose Add.
            
        
          Add the wrapper environment variable.
          
           Choose the Configuration tab, then choose Environment variables.
         
           Under Environment variables, choose Edit.
         
           Choose Add environment variable.
         
              For Key, enter AWS_LAMBDA_EXEC_WRAPPER.
            
              For Value, enter /opt/bin/importtime_wrapper (/opt/ + your .zip layer's folder structure).
            
              Choose Save.
            
        
          Test the wrapper script.
          
              Choose the Test tab.
            
              Under Test event, choose Test. You don't need to create a test event—the default event will work.
            
              Scroll down to Log output. Because your wrapper script started the Python interpreter with the -X importtime option,
                the logs show the time required for each import. For example:
              532 |           collections
import time:        63 |         63 |           _functools
import time:      1053 |       3646 |         functools
import time:      2163 |       7499 |       enum
import time:       100 |        100 |         _sre
import time:       446 |        446 |           re._constants
import time:       691 |       1136 |         re._parser
import time:       378 |        378 |         re._casefix
import time:       670 |       2283 |       re._compiler
import time:       416 |        416 |       copyreg
            
        
     
  Document ConventionsGet data about functions by runtimeRuntime APIDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideAWS managed extensionsAWS Lambda extensions partnersAWS Lambda has partnered with several third party entities to provide extensions to integrate with your Lambda functions. 
      The following list details third party extensions that are ready for you to use at any time.
       
       
       
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
  
          AppDynamics – Provides automatic instrumentation of Node.js or Python Lambda functions, providing visibility and alerting on function performance.
      
          Axiom – Provides dashboards for monitoring Lambda function performance and aggregate system-level metrics.
      
        Check Point CloudGuard – An extension-based runtime solution that offers full lifecycle security for serverless applications.
    
        Datadog – Provides comprehensive, real-time visibility to your serverless applications through the use of metrics, traces, and logs.
    
        Dynatrace – Provides visibility into traces and metrics, and leverages AI for automated error detection and root cause analysis across the entire application stack.
    
          Elastic – Provides Application Performance Monitoring (APM) to identify and resolve root cause issues using correlated traces, metrics, and logs.
      
      Epsagon – Listens to invocation events, stores traces, and sends them in parallel to Lambda function executions.
    
        Fastly– Protects your Lambda functions from suspicious activity, such as injection-style attacks, account takeover via credential stuffing, malicious bots, and API abuse.
    
        HashiCorp Vault – Manages secrets and makes them available for developers to use within function code, without making functions Vault aware.
    
        Honeycomb – Observability tool for debugging your app stack.
    
        Lumigo – Profiles Lambda function invocations and collects metrics for troubleshooting issues in serverless and microservice environments.
    
        New Relic – Runs alongside Lambda functions, automatically collecting, enhancing, and transporting telemetry to New Relic's unified observability platform.
    
      Sedai – An autonomous cloud management platform, powered by AI/ML, that delivers continuous optimization for cloud operations teams to maximize cloud cost savings, performance, and availability at scale.
    
        Sentry – Diagnose, fix, and optimize performance of Lambda functions.
    
        Site24x7 – Achieve real-time observability into your Lambda environments
    
        Splunk –  Collects high-resolution, low-latency metrics for efficient and effective monitoring of Lambda functions.
    
        Sumo Logic – Provides visibility into the health and performance of serverless applications.
    
        Salt Security – Simplifies API posture governance and API security for Lambda functions through automated setup and support for diverse runtimes.
    
      AWS managed extensions
      AWS provides its own managed extensions, including:
      
         
         
         
         
         
      
            AWS AppConfig – Use feature flags and dynamic data to update your Lambda functions. You can also use this extension to update other dynamic configuration, such as ops throttling and tuning. 
        
            Amazon CodeGuru Profiler – Improves application performance and reduces cost by pinpointing an application's most expensive line of code and providing recommendations for improving code.
        
            CloudWatch Lambda Insights – Monitor, troubleshoot, and optimize the performance of your Lambda functions through automated dashboards.
        
            AWS Distro for OpenTelemetry (ADOT) – 
                Enables functions to send trace data to AWS monitoring services such as AWS X-Ray, and to destinations that support OpenTelemetry such as Honeycomb and Lightstep.
        
            AWS Parameters and Secrets – Securely retrieve parameters from AWS Systems Manager Parameter Store and secrets from AWS Secrets Manager in Lambda functions.
        
  For additional extensions samples and demo projects, see AWS Lambda Extensions.Document ConventionsConfiguring extensionsExtensions APIDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideConfiguring extensions (.zip file archive)Using extensions in container imagesNext stepsConfiguring Lambda extensions
    Configuring extensions (.zip file archive)
    You can add an extension to your function as a Lambda layer. Using
      layers enables you to share extensions across your organization or to the entire community of Lambda developers.
      You can add one or more extensions to a layer. You can register up to 10 extensions for a function.
    You add the extension to your function using the same method as you would for any layer. For more information,
      see Managing Lambda dependencies with layers.
    Add an extension to your function (console)Open the Functions page of the Lambda console.
        Choose a function.
      
        Choose the Code tab if it is not already selected.
      
        Under Layers, choose Edit.
      
        For Choose a layer, choose Specify an ARN.
      
        For Specify an ARN, enter the Amazon Resource Name (ARN) of an extension
          layer.
      
        Choose Add.
      
   
    Using extensions in container images
    You can add extensions to your container image. The ENTRYPOINT container
      image setting specifies the main process for the function. Configure the ENTRYPOINT setting in the Dockerfile, or
      as an override in the function configuration.  
    You can run multiple processes within a container. Lambda manages the lifecycle of the main process and any
      additional processes. Lambda uses the Extensions API to manage the
      extension lifecycle.  
    
     
      Example: Adding an external extension
      An external extension runs in a separate process from the Lambda function. Lambda starts a process for each
        extension in the /opt/extensions/ directory. Lambda uses the Extensions API to manage the extension
        lifecycle. After the function has run to completion, Lambda sends a Shutdown event to each external
        extension.
      Example of adding an external extension to a Python base imageFROM public.ecr.aws/lambda/python:3.11

# Copy and install the app
COPY /app /app
WORKDIR /app
RUN pip install -r requirements.txt

# Add an extension from the local directory into /opt/extensions
ADD my-extension.zip /opt/extensions
CMD python ./my-function.py
     
   
    Next steps
    To learn more about extensions, we recommend the following resources:
    
       
       
       
    
        For a basic working example, see Building
          Extensions for AWS Lambda on the AWS Compute Blog.
      
        For information about extensions that AWS Lambda Partners provides, see Introducing
          AWS Lambda Extensions on the AWS Compute Blog.
      
        To view available example extensions and wrapper scripts, see AWS Lambda Extensions on the AWS Samples
          GitHub repository.
      
  Document ConventionsLambda extensionsExtensions partnersDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideCreating extensions using the Telemetry APIRegistering your extensionCreating a telemetry listenerSpecifying a destination protocolConfiguring memory usage and bufferingSending a subscription request to the Telemetry APIInbound Telemetry API messagesAccessing real-time telemetry data for extensions using the Telemetry APIThe Telemetry API enables your extensions to receive telemetry data directly from Lambda. During
    function initialization and invocation, Lambda automatically captures telemetry, including logs,
    platform metrics, and platform traces. The Telemetry API enables extensions to access this telemetry
    data directly from Lambda in near real time.Within the Lambda execution environment, you can subscribe your Lambda extensions to telemetry
    streams. After subscribing, Lambda automatically sends all telemetry data to your extensions. You then
    have the flexibility to process, filter, and dispatch the data to your preferred destination, such as
    an Amazon Simple Storage Service (Amazon S3) bucket or a third-party observability tools provider.The following diagram shows how the Extensions API and Telemetry API link extensions to Lambda
    from within the execution environment. Additionally, the Runtime API connects your runtime and
    function to Lambda.
     
      
     
     
  ImportantThe Lambda Telemetry API supersedes the Lambda Logs API. While the Logs API
    remains fully functional, we recommend using only the Telemetry API going forward. You can subscribe
    your extension to a telemetry stream using either the Telemetry API or the Logs API. After subscribing using one
    of these APIs, any attempt to subscribe using the other API returns an error.Extensions can use the Telemetry API to subscribe to three different telemetry streams:
     
     
     
  
      Platform telemetry – Logs, metrics, and traces, which describe
        events and errors related to the execution environment runtime lifecycle, extension lifecycle, and function
        invocations.
    
      Function logs – Custom logs that the Lambda function code
        generates.
    
      Extension logs – Custom logs that the Lambda extension code
        generates.
    NoteLambda sends logs and metrics to CloudWatch, and traces to X-Ray (if you've activated tracing), even if an extension
      subscribes to telemetry streams.SectionsCreating extensions using the Telemetry APIRegistering your extensionCreating a telemetry listenerSpecifying a destination protocolConfiguring memory usage and bufferingSending a subscription request to the Telemetry APIInbound Telemetry API messagesLambda Telemetry API referenceLambda Telemetry API Event schema referenceConverting Lambda Telemetry API Event objects to OpenTelemetry
      SpansUsing the Lambda Logs API
    Creating extensions using the Telemetry API
    Lambda extensions run as independent processes in the execution environment. Extensions can continue to run after
      function invocation completes. Because extensions are separate processes, you can write them in a language
      different from the function code. We recommend writing extensions using a compiled language such as Golang or
      Rust. This way, the extension is a self-contained binary that can be compatible with any supported runtime.
    The following diagram illustrates a four-step process to create an extension that receives and processes
      telemetry data using the Telemetry API.
    
       
        
       
       
    
    Here is each step in more detail:
    
       
       
       
       
    
        Register your extension using the Using the Lambda Extensions API to create extensions. This provides you with a
            Lambda-Extension-Identifier, which you'll need in the following steps. For more information
          about how to register your extension, see Registering your extension.
      
        Create a telemetry listener. This can be a basic HTTP or TCP server. Lambda uses the URI of the telemetry
          listener to send telemetry data to your extension. For more information, see Creating a telemetry listener.
      
        Using the Subscribe API in the Telemetry API, subscribe your extension to the desired telemetry streams.
          You'll need the URI of your telemetry listener for this step. For more information, see Sending a subscription request to the Telemetry API.
      
        Get telemetry data from Lambda via the telemetry listener. You can do any custom processing of this data,
          such as dispatching the data to Amazon S3 or to an external observability service.
      
    NoteA Lambda function's execution environment can start and stop multiple times as part of its lifecycle. In general, your extension code runs during
        function invocations, and also up to 2 seconds during the shutdown phase. We recommend batching the telemetry as
        it arrives to your listener. Then, use the Invoke and Shutdown lifecycle events to
        send each batch to their desired destinations.
   
    Registering your extension
    Before you can subscribe to telemetry data, you must register your Lambda extension. Registration
      occurs during the extension initialization phase. The following
      example shows an HTTP request to register an extension.
    POST http://${AWS_LAMBDA_RUNTIME_API}/2020-01-01/extension/register
 Lambda-Extension-Name: lambda_extension_name
{
    'events': [ 'INVOKE', 'SHUTDOWN']
}
    If the request succeeds, the subscriber receives an HTTP 200 success response. The response header contains
      the Lambda-Extension-Identifier. The response body contains other properties of the function.
    HTTP/1.1 200 OK
Lambda-Extension-Identifier: a1b2c3d4-5678-90ab-cdef-EXAMPLE11111
{
    "functionName": "lambda_function",
    "functionVersion": "$LATEST",
    "handler": "lambda_handler",
    "accountId": "123456789012"
}
    For more information, see the Extensions API reference.
   
    Creating a telemetry listener
    Your Lambda extension must have a listener that handles incoming requests from the Telemetry API. The following
      code shows an example telemetry listener implementation in Golang:
    // Starts the server in a goroutine where the log events will be sent
func (s *TelemetryApiListener) Start() (string, error) {
	address := listenOnAddress()
	l.Info("[listener:Start] Starting on address", address)
	s.httpServer = &http.Server{Addr: address}
	http.HandleFunc("/", s.http_handler)
	go func() {
		err := s.httpServer.ListenAndServe()
		if err != http.ErrServerClosed {
			l.Error("[listener:goroutine] Unexpected stop on Http Server:", err)
			s.Shutdown()
		} else {
			l.Info("[listener:goroutine] Http Server closed:", err)
		}
	}()
	return fmt.Sprintf("http://%s/", address), nil
}

// http_handler handles the requests coming from the Telemetry API.
// Everytime Telemetry API sends log events, this function will read them from the response body
// and put into a synchronous queue to be dispatched later.
// Logging or printing besides the error cases below is not recommended if you have subscribed to
// receive extension logs. Otherwise, logging here will cause Telemetry API to send new logs for
// the printed lines which may create an infinite loop.
func (s *TelemetryApiListener) http_handler(w http.ResponseWriter, r *http.Request) {
	body, err := ioutil.ReadAll(r.Body)
	if err != nil {
		l.Error("[listener:http_handler] Error reading body:", err)
		return
	}

	// Parse and put the log messages into the queue
	var slice []interface{}
	_ = json.Unmarshal(body, &slice)

	for _, el := range slice {
		s.LogEventsQueue.Put(el)
	}

	l.Info("[listener:http_handler] logEvents received:", len(slice), " LogEventsQueue length:", s.LogEventsQueue.Len())
	slice = nil
}
   
    Specifying a destination protocol
    When you subscribe to receive telemetry using the Telemetry API, you can specify a destination protocol in
      addition to the destination URI:
    {
    "destination": {
        "protocol": "HTTP",
        "URI": "http://sandbox.localdomain:8080"
    }
}
    Lambda accepts two protocols for receiving telemetry:
    
       
       
    
        HTTP (recommended) – Lambda delivers telemetry to a local HTTP
          endpoint (http://sandbox.localdomain:${PORT}/${PATH}) as an array of records in JSON format. The
            $PATH parameter is optional. Lambda supports only HTTP, not HTTPS. Lambda delivers telemetry
          through POST requests.
      
        TCP – Lambda delivers telemetry to a TCP port in Newline delimited JSON (NDJSON) format.
      
    NoteWe strongly recommend using HTTP rather than TCP. With TCP, the Lambda platform cannot acknowledge when it
        delivers telemetry to the application layer. Therefore, if your extension crashes, you might lose telemetry.
        HTTP does not have this limitation.
    Before subscribing to receive telemetry, establish the local HTTP listener or TCP port. During setup, note the
      following:
    
       
       
       
    
        Lambda sends telemetry only to destinations that are inside the execution environment.
      
        Lambda retries to send telemetry (with backoff) in the absence of a listener, or if the POST request
          encounters an error. If the telemetry listener crashes, it resumes receiving telemetry after Lambda
          restarts the execution environment.
      
        Lambda reserves port 9001. There are no other port number restrictions or recommendations.
      
   
    Configuring memory usage and buffering
    Memory usage in an execution environment grows linearly with the number of subscribers.
      Subscriptions consume memory resources because each one opens a new memory buffer to store
      telemetry data. Buffer memory usage contributes to the overall memory consumption in the
      execution environment.
    When subscribing to receive telemetry through the Telemetry API, you have the option to
      buffer telemetry data and deliver it to subscribers in batches. To optimize memory usage,
      you can specify a buffering configuration:
    {
    "buffering": {
        "maxBytes": 256*1024,
        "maxItems": 1000,
        "timeoutMs": 100
    }
}
    
          
            Parameter
            Description
            Defaults and limits
          
        
          
            
              maxBytes
            
            
              The maximum volume of telemetry (in bytes) to buffer in memory.
            
            
              Default: 262,144
              Minimum: 262,144
              Maximum: 1,048,576
            
          
          
            
              maxItems
            
            
              The maximum number of events to buffer in memory.
            
            
              Default: 10,000
              Minimum: 1,000
              Maximum: 10,000
            
          
          
            
              timeoutMs
            
            
              The maximum time (in milliseconds) to buffer a batch.
            
            
              Default: 1,000
              Minimum: 25
              Maximum: 30,000
            
          
        
    When setting up buffering, keep these points in mind:
    
       
       
       
       
    
        If any of the input streams are closed, Lambda flushes the logs. For example,
          this can occur if the runtime crashes.
      
        Each subscriber can customize their buffering configuration in their subscription request.
      
        When determining the buffer size for reading the data, anticipate receiving
          payloads as large as 2 * maxBytes + metadataBytes, where maxBytes
          is a component of your buffering setup. To gauge the amount of metadataBytes to
          consider, review the following metadata. Lambda appends metadata similar to this to each record:
        {
   "time": "2022-08-20T12:31:32.123Z",
   "type": "function",
   "record": "Hello World"
}
      
        If the subscriber cannot process incoming telemetry fast enough, or if your function code generates
          very high log volume, Lambda might drop records to keep memory utilization bounded. When this occurs,
          Lambda sends a platform.logsDropped event.
      
   
    Sending a subscription request to the Telemetry API
    Lambda extensions can subscribe to receive telemetry data by sending a subscription request to the Telemetry
      API. The subscription request should contain information about the types of events that you want the extension to
      subscribe to. In addition, the request can contain delivery destination
        information and a buffering configuration.
    Before sending a subscription request, you must have an extension ID
      (Lambda-Extension-Identifier). When you register your
        extension with the Extensions API, you obtain an extension ID from the API response.
    Subscription occurs during the extension initialization
        phase. The following example shows an HTTP request to subscribe to all three telemetry streams: platform
      telemetry, function logs, and extension logs.
    PUT http://${AWS_LAMBDA_RUNTIME_API}/2022-07-01/telemetry HTTP/1.1
{
   "schemaVersion": "2022-12-13",
   "types": [
        "platform",
        "function",
        "extension"
   ],
   "buffering": {
        "maxItems": 1000,
        "maxBytes": 256*1024,
        "timeoutMs": 100
   },
   "destination": {
        "protocol": "HTTP",
        "URI": "http://sandbox.localdomain:8080"
   }
}
    If the request succeeds, then the subscriber receives an HTTP 200 success response.
    HTTP/1.1 200 OK
"OK"
   
    Inbound Telemetry API messages
    After subscribing using the Telemetry API, an extension automatically starts to receive telemetry from Lambda
      via POST requests. Each POST request body contains an array of Event objects. Each Event
      has the following schema:
    {
   time: String,
   type: String,
   record: Object
}
    
       
       
       
    
        The time property defines when the Lambda platform generated the event. This is different from
          when the event actually occurred. The string value of time is a timestamp in ISO 8601
          format.
      
        The type property defines the event type. The following table describes all possible
          values.
      
        The record property defines a JSON object that contains the telemetry data. The schema of
          this JSON object depends on the type.
      
    The following table summarizes all types of Event objects, and links to the Telemetry API Event schema reference for each event
      type.
    
          
            Category
            Event type
            Description
            Event record schema
          
        
          
            
              Platform event
            
            
              platform.initStart
            
            
              Function initialization started.
            
            
              platform.initStart schema
            
          
          
            
              Platform event
            
            
              platform.initRuntimeDone
            
            
              Function initialization completed.
            
            
              platform.initRuntimeDone schema
            
          
          
            
              Platform event
            
            
              platform.initReport
            
            
              A report of function initialization.
            
            
              platform.initReport schema
            
          
          
            
              Platform event
            
            
              platform.start
            
            
              Function invocation started.
            
            
              platform.start schema
            
          
          
            
              Platform event
            
            
              platform.runtimeDone
            
            
              The runtime finished processing an event with either success or failure.
            
            
              platform.runtimeDone schema
            
          
          
            
              Platform event
            
            
              platform.report
            
            
              A report of function invocation.
            
            
              platform.report schema
            
          
          
            
              Platform event
            
            
              platform.restoreStart
            
            
              Runtime restore started.
            
            
              platform.restoreStart schema
            
          
          
            
              Platform event
            
            
              platform.restoreRuntimeDone
            
            
              Runtime restore completed.
            
            
              platform.restoreRuntimeDone schema
            
          
          
            
              Platform event
            
            
              platform.restoreReport
            
            
              Report of runtime restore.
            
            
              platform.restoreReport schema
            
          
          
            
              Platform event
            
            
              platform.telemetrySubscription
            
            
              The extension subscribed to the Telemetry API.
            
            
              platform.telemetrySubscription schema
            
          
          
            
              Platform event
            
            
              platform.logsDropped
            
            
              Lambda dropped log entries.
            
            
              platform.logsDropped schema
            
          
          
            
              Function logs
            
            
              function
            
            
              A log line from function code.
            
            
              function schema
            
          
          
            
              Extension logs
            
            
              extension
            
            
              A log line from extension code.
            
            
              extension schema
            
          
        
  Document ConventionsExtensions APIAPI referenceDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideImplement code before or after Lambda function snapshotsYou can use runtime hooks to implement code before Lambda creates a snapshot or after Lambda resumes a function
    from a snapshot. Runtime hooks are useful for a variety of purposes, such as:
     
     
     
     
  
      Cleanup and initialization: Before a snapshot is created, you can use a runtime hook to perform cleanup or resource release operations. After a snapshot is restored, you can use a runtime hook to re-initialize any resources or state that were not captured in the snapshot.
    
      Dynamic configuration: You can use runtime hooks to dynamically update configuration or other metadata before a snapshot is created or after it is restored. This can be useful if your function needs to adapt to changes in the runtime environment.
    
      External integrations: You can use runtime hooks to integrate with external services or systems, such as sending notifications or updating external state, as part of the checkpointing and restoration process.
    
      Performance tuning: You can use runtime hooks to fine-tune your function's startup sequence, such as by preloading dependencies. For more information, see Performance tuning.
    The following pages explain how to implement runtime hooks for your preferred runtime.TopicsJavaPython.NETDocument ConventionsHandling uniquenessJavaDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideRuntime environment lifecycleCold starts and latencyReducing cold starts with Provisioned ConcurrencyOptimizing static initializationUnderstanding the Lambda execution environment lifecycle
      Lambda invokes your function in an execution environment, which provides a secure and isolated runtime
      environment. The execution environment manages the resources required to run your function. The execution
      environment also provides lifecycle support for the function's runtime and any external extensions associated with your function.
    The function's runtime communicates with Lambda using the Runtime API.
    Extensions communicate with Lambda using the Extensions API.
    Extensions can also receive log messages and other telemetry from the function by using the Telemetry API.
    
         
          
         
         
    When you create your Lambda function, you specify configuration information, such as the amount of memory
    available and the maximum execution time allowed for your function. Lambda uses this information to set up the
    execution environment.The function's runtime and each external extension are processes that run within the execution environment.
    Permissions, resources, credentials, and environment variables are shared between the function and the
    extensions.TopicsLambda execution environment lifecycleCold starts and latencyReducing cold starts with Provisioned ConcurrencyOptimizing static initialization
      Lambda execution environment lifecycle    
        
           
            
           
           
        
        Each phase starts with an event that Lambda sends to the runtime and to all registered extensions. The
        runtime and each extension indicate completion by sending a Next API request. Lambda freezes the
        execution environment when the runtime and each extension have completed and there are no pending events.
        TopicsInit phaseFailures during the Init phaseRestore phase (Lambda SnapStart only)Invoke phaseFailures during the invoke phaseShutdown phase
       
        Init phase
        In the Init phase, Lambda performs three tasks:
        
           
           
           
           
        
            Start all extensions (Extension init)
          
            Bootstrap the runtime (Runtime init)
          
            Run the function's static code (Function init)
          
            Run any before-checkpoint runtime hooks (Lambda SnapStart only)
          
        The Init phase ends when the runtime and all extensions signal that they are ready by sending a
            Next API request. The Init phase is limited to 10 seconds. If all three tasks do not
          complete within 10 seconds, Lambda retries the Init phase at the time of the first function
          invocation with the configured function timeout.
          When Lambda SnapStart is activated, the Init phase happens when you publish a function version. Lambda saves a snapshot of the memory and disk state of the initialized execution environment, persists the encrypted snapshot, and caches it for low-latency access. If you have a before-checkpoint runtime hook, then the code runs at the end of Init phase.
          NoteThe 10-second timeout doesn't apply to functions that are using provisioned concurrency
              or SnapStart. For provisioned concurrency and SnapStart functions, your initialization code
              can run for up to 15 minutes. The time limit is 130 seconds or the configured function
              timeout (maximum 900 seconds), whichever is higher.
        When you use provisioned concurrency,
          Lambda initializes the execution environment when you configure the PC settings for a function. Lambda also ensures that
          initialized execution environments are always available in advance of invocations. You may see gaps between your function's
          invocation and initialization phases. Depending on your function's runtime and memory configuration, you may also see variable
          latency on the first invocation on an initialized execution environment.
        For functions using on-demand concurrency, Lambda may occasionally initialize execution environments ahead of
          invocation requests. When this happens, you may also observe a time gap between your function's initialization and
          invocation phases. We recommend you to not take a dependency on this behavior.
       
       
        Failures during the Init phase
        If a function crashes or times out during the Init phase, Lambda emits error information in the INIT_REPORT log.
    Example  — INIT_REPORT log for timeoutINIT_REPORT Init Duration: 1236.04 ms Phase: init Status: timeout       
    Example  — INIT_REPORT log for extension failureINIT_REPORT Init Duration: 1236.04 ms Phase: init Status: error Error Type: Extension.Crash		
        If the Init phase is successful, Lambda doesn't emit the INIT_REPORT log unless SnapStart or 
          provisioned concurrency is enabled. SnapStart and provisioned concurrency functions always emit INIT_REPORT. 
          For more information, see Monitoring for Lambda SnapStart.
        
       
        Restore phase (Lambda SnapStart only)
        When you first invoke a SnapStart function and as the function scales up, Lambda resumes new execution environments from the persisted snapshot instead of initializing the function from scratch. If you have an after-restore runtime hook, the code runs at the end of the Restore phase. You are charged for the duration of after-restore runtime hooks. The runtime must load and after-restore runtime hooks must complete within the timeout limit (10 seconds). Otherwise, you'll get a SnapStartTimeoutException. When the Restore phase completes, Lambda invokes the function handler (the Invoke phase).
         
          Failures during the Restore phase
          If the Restore phase fails, Lambda emits error information in the RESTORE_REPORT log.
      Example  — RESTORE_REPORT log for timeoutRESTORE_REPORT Restore Duration: 1236.04 ms Status: timeout
      Example  — RESTORE_REPORT log for runtime hook failureRESTORE_REPORT Restore Duration: 1236.04 ms Status: error Error Type: Runtime.ExitError		
        For more information about the RESTORE_REPORT log, see Monitoring for Lambda SnapStart.
         
       
       
        Invoke phase
        When a Lambda function is invoked in response to a Next API request, Lambda sends an
            Invoke event to the runtime and to each extension.
        The function's timeout setting limits the duration of the entire Invoke phase. For example, if
          you set the function timeout as 360 seconds, the function and all extensions need to complete within 360
          seconds. Note that there is no independent post-invoke phase. The duration is the sum of all invocation time
          (runtime + extensions) and is not calculated until the function and all extensions have finished
          executing.
        The invoke phase ends after the runtime and all extensions signal that they are done by sending a
            Next API request.
       
       
        Failures during the invoke phase
        If the Lambda function crashes or times out during the Invoke phase, Lambda resets the
          execution environment. The following diagram illustrates Lambda execution environment behavior when
          there's an invoke failure:
        
           
            
           
           
        
        In the previous diagram:
        
           
           
           
           
           
        
            The first phase is the INIT phase, which runs
              without errors.
          
            The second phase is the INVOKE phase, which runs
              without errors.
          
            At some point, suppose your function runs into an invoke failure (such as a function
              timeout or runtime error). The third phase, labeled INVOKE WITH ERROR
              , illustrates this scenario. When this happens, the Lambda service performs a
              reset. The reset behaves like a Shutdown event. First, Lambda shuts down the
              runtime, then sends a Shutdown event to each registered external extension.
              The event includes the reason for the shutdown. If this environment is used for a new
              invocation, Lambda re-initializes the extension and runtime together with the next
              invocation.
            
            Note that the Lambda reset does not clear the /tmp directory content prior to the next init phase.
              This behavior is consistent with the regular shutdown phase.
            NoteAWS is currently implementing changes to the Lambda service. Due to these changes, you may see minor differences between the structure and content 
of system log messages and trace segments emitted by different Lambda functions in your AWS account.If your function's system log configuration is set to plain text, this change affects the log messages captured in CloudWatch Logs when your 
                function experiences an invoke failure. The following examples show log outputs in both old and new formats.These changes will be implemented during the coming weeks, and all functions in all 
AWS Regions except the China and GovCloud regions will transition to use the new-format log messages and trace segments.
            
            Example CloudWatch Logs log output (runtime or extension crash) - old styleSTART RequestId: c3252230-c73d-49f6-8844-968c01d1e2e1 Version: $LATEST
RequestId: c3252230-c73d-49f6-8844-968c01d1e2e1 Error: Runtime exited without providing a reason
Runtime.ExitError
END RequestId: c3252230-c73d-49f6-8844-968c01d1e2e1
REPORT RequestId: c3252230-c73d-49f6-8844-968c01d1e2e1 Duration: 933.59 ms Billed Duration: 934 ms Memory Size: 128 MB Max Memory Used: 9 MB
            Example CloudWatch Logs log output (function timeout) - old styleSTART RequestId: b70435cc-261c-4438-b9b6-efe4c8f04b21 Version: $LATEST
2024-03-04T17:22:38.033Z b70435cc-261c-4438-b9b6-efe4c8f04b21 Task timed out after 3.00 seconds
END RequestId: b70435cc-261c-4438-b9b6-efe4c8f04b21
REPORT RequestId: b70435cc-261c-4438-b9b6-efe4c8f04b21 Duration: 3004.92 ms Billed Duration: 3000 ms Memory Size: 128 MB Max Memory Used: 33 MB Init Duration: 111.23 ms
            The new format for CloudWatch logs includes an additional statusfield in the REPORT line. In the case of a runtime or 
              extension crash, the REPORT line also includes a field ErrorType.
            
            Example CloudWatch Logs log output (runtime or extension crash) - new styleSTART RequestId: 5b866fb1-7154-4af6-8078-6ef6ca4c2ddd Version: $LATEST
END RequestId: 5b866fb1-7154-4af6-8078-6ef6ca4c2ddd
REPORT RequestId: 5b866fb1-7154-4af6-8078-6ef6ca4c2ddd Duration: 133.61 ms Billed Duration: 133 ms Memory Size: 128 MB Max Memory Used: 31 MB Init Duration: 80.00 ms Status: error Error Type: Runtime.ExitError
            Example CloudWatch Logs log output (function timeout) - new styleSTART RequestId: 527cb862-4f5e-49a9-9ae4-a7edc90f0fda Version: $LATEST
END RequestId: 527cb862-4f5e-49a9-9ae4-a7edc90f0fda
REPORT RequestId: 527cb862-4f5e-49a9-9ae4-a7edc90f0fda Duration: 3016.78 ms Billed Duration: 3016 ms Memory Size: 128 MB Max Memory Used: 31 MB Init Duration: 84.00 ms Status: timeout
          
            The fourth phase represents the INVOKE phase
              immediately following an invoke failure. Here, Lambda initializes the environment again
              by re-running the INIT phase. This is called a
              suppressed init. When suppressed inits occur, Lambda doesn't
              explicitly report an additional INIT phase in CloudWatch Logs.
              Instead, you may notice that the duration in the REPORT line includes an additional
              INIT duration + the
              INVOKE duration. For example, suppose you see the
              following logs in CloudWatch:
            2022-12-20T01:00:00.000-08:00 START RequestId: XXX Version: $LATEST 
2022-12-20T01:00:02.500-08:00 END RequestId: XXX 
2022-12-20T01:00:02.500-08:00 REPORT RequestId: XXX Duration: 3022.91 ms 
Billed Duration: 3000 ms Memory Size: 512 MB Max Memory Used: 157 MB
            In this example, the difference between the REPORT and START timestamps is 2.5 seconds.
              This doesn't match the reported duration of 3022.91 millseconds, because it doesn't take
              into account the extra INIT (suppressed init) that Lambda
              performed. In this example, you can infer that the actual
              INVOKE phase took 2.5 seconds.
            For more insight into this behavior, you can use the
              Accessing real-time telemetry data for extensions using the Telemetry API. The Telemetry API emits
              INIT_START, INIT_RUNTIME_DONE, and INIT_REPORT
              events with phase=invoke whenever suppressed inits occur in between
              invoke phases.
          
            The fifth phase represents the SHUTDOWN phase, which runs
              without errors.
          
       
       
        Shutdown phase
        When Lambda is about to shut down the runtime, it sends a Shutdown event to
          each registered external extension. Extensions can use this time for final cleanup tasks. The Shutdown event
          is a response to a Next API request.
        Duration limit: The maximum duration of the
          Shutdown phase depends on the configuration of registered extensions:
      
         
         
         
      
          0 ms – A function with no registered extensions
        
          500 ms – A function with a registered internal extension
        
          2,000 ms – A function with one or more registered external extensions
        
      If the runtime or an extension does not respond to the Shutdown event within the limit, Lambda
        ends the process using a SIGKILL signal.
        After the function and all extensions have completed, Lambda maintains the execution
          environment for some time in anticipation of another function invocation. However, Lambda terminates execution environments every few hours to allow for runtime updates and maintenance—even for functions that are invoked continuously. You should
          not assume that the execution environment will persist indefinitely. For more information, see
          Implement statelessness in functions.
        When the function is invoked again, Lambda thaws the environment for reuse. Reusing the
        execution environment has the following implications: 
        
           
           
           
        
            Objects declared outside of the function's handler method remain initialized, providing additional
              optimization when the function is invoked again. For example, if your Lambda function establishes a database
              connection, instead of reestablishing the connection, the original connection is used in subsequent
              invocations. We recommend adding logic in your code to check if a connection exists before creating a new
              one.
          
            Each execution environment provides between 512 MB and 10,240 MB, in 1-MB increments, of disk space in the /tmp
              directory. The directory content remains when the execution environment is frozen, providing a transient
              cache that can be used for multiple invocations. You can add extra code to check if the cache has the data
              that you stored. For more information on deployment size limits, see Lambda quotas.
          
            Background processes or callbacks that were initiated by your Lambda function and did not complete when
              the function ended resume if Lambda reuses the execution environment. Make sure that any background processes
              or callbacks in your code are complete before the code exits.
          
         
     
    Cold starts and latency
    When Lambda receives a request to run a function via the Lambda API, the service first prepares an execution
      environment. During this initialization phase, the service downloads your code, starts the environment, and
      runs any initialization code outside of the main handler. Finally, Lambda runs the handler code.
    
       
        
       
       
    
    In this diagram, the first two steps of downloading the code and setting up the environment are frequently referred
      to as a “cold start”. You are not charged for this time, but it does add latency to your overall invocation duration.
    After the invocation completes, the execution environment is frozen. To improve resource management and performance,
      Lambda retains the execution environment for a period of time. During this time, if another request arrives for the same
      function, Lambda can reuse the environment. This second request typically finishes more quickly, since the execution
      environment is already fully set up. This is called a “warm start”.
    Cold starts typically occur in under 1% of invocations. The duration of a cold start varies from under 100 ms to over
      1 second. In general, cold starts are typically more common in development and test functions than production workloads.
      This is because development and test functions are usually invoked less frequently.
   
    Reducing cold starts with Provisioned Concurrency
    If you need predictable function start times for your workload, provisioned
      concurrency is the recommended solution to ensure the lowest possible latency. This feature pre-initializes
      execution environments, reducing cold starts.
    For example, a function with a provisioned concurrency of 6 has 6 execution environments pre-warmed.
    
       
        
       
       
    
   
    Optimizing static initialization
    Static initialization happens before the handler code starts running in a function. This is the initialization code
      that you provide, that is outside of the main handler. This code is often used to import libraries and dependencies,
      set up configurations, and initialize connections to other services.
    The following Python example shows importing, and configuring modules, and creating the Amazon S3 client during the
      initialization phase, before the lambda_handler function runs during invoke.
    import os
import json
import cv2
import logging
import boto3

s3 = boto3.client('s3')
logger = logging.getLogger()
logger.setLevel(logging.INFO)

def lambda_handler(event, context):

  # Handler logic...

    The largest contributor of latency before function execution comes from initialization code. This code runs when
      a new execution environment is created for the first time. The initialization code is not run again if an invocation
      uses a warm execution environment. Factors that affect initialization code latency include:
    
       
       
       
    
        The size of the function package, in terms of imported libraries and dependencies, and Lambda layers.
      
        The amount of code and initialization work.
      
        The performance of libraries and other services in setting up connections and other resources.
      
    There are a number of steps that developers can take to optimize static initialization latency. If a function has
      many objects and connections, you may be able to rearchitect a single function into multiple, specialized functions.
      These are individually smaller and each have less initialization code.
    It’s important that functions only import the libraries and dependencies that they need. For example, if you only
      use Amazon DynamoDB in the AWS SDK, you can require an individual service instead of the entire SDK. Compare the following
      three examples:
    // Instead of const AWS = require('aws-sdk'), use:
const DynamoDB = require('aws-sdk/clients/dynamodb')

// Instead of const AWSXRay = require('aws-xray-sdk'), use:
const AWSXRay = require('aws-xray-sdk-core')

// Instead of const AWS = AWSXRay.captureAWS(require('aws-sdk')), use:
const dynamodb = new DynamoDB.DocumentClient()
AWSXRay.captureAWSClient(dynamodb.service)
    Static initialization is also often the best place to open database connections to allow a function to reuse
      connections over multiple invocations to the same execution environment. However, you may have large numbers of
      objects that are only used in certain execution paths in your function. In this case, you can lazily load variables
      in the global scope to reduce the static initialization duration.
    Avoid global variables for context-specific information. If your function has a global variable that is used
      only for the lifetime of a single invocation and is reset for the next invocation, use a variable scope that is
      local to the handler. Not only does this prevent global variable leaks across invocations, it also improves the
      static initialization performance.
  Document ConventionsProgramming modelEvent-driven architecturesDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideUsing CloudWatch metrics with LambdaWhen your AWS Lambda function finishes processing an event, Lambda automatically sends metrics
    about the invocation to Amazon CloudWatch. You don't need to grant any additional permissions to your
    execution role to receive function metrics, and there's no additional charge for these metrics.There are many types of metrics associated with Lambda functions. These include invocation
    metrics, performance metrics, concurrency metrics, asynchronous invocation metrics, and event
    source mapping metrics. For more information, see Types of metrics for Lambda functions.In the CloudWatch console, you can view these metrics
    and build graphs and dashboards with them. You can also set alarms to respond to changes in
    utilization, performance, or error rates. Lambda sends metric data to CloudWatch in 1-minute intervals.
    For more immediate insight into your Lambda function, you can create high-resolution custom metrics.
    Charges apply for custom metrics and CloudWatch alarms. For more information, see
    Amazon CloudWatch Pricing.Document ConventionsMonitoring functionsView function metricsDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAmazon CloudWatchUser GuideMetrics collected by Lambda InsightsLambda Insights collects several metrics from the Lambda functions where it is installed. 
      Some of these metrics are available as time series aggregated data in CloudWatch Metrics. 
      Other metrics are not aggregated into time series data but can be found in the 
      embedded metric format log entries by using CloudWatch Logs Insights.The following metrics are available as time series aggregated data in CloudWatch Metrics
    in the LambdaInsights namespace.
          
            Metric name
            Dimensions
            Description
          
        
                  
            
              cpu_total_time
            
              function_name
              function_name, version
            
            
              Sum of cpu_system_time and cpu_user_time.
              Unit: Milliseconds
              
            
          
          
            
              init_duration
            
              function_name
              function_name, version
            
            
              The amount of time spent in the init phase of the Lambda 
                execution environment lifecycle.
              Unit: Milliseconds
              
            
          
           
            
              memory_utilization
            
              function_name
              function_name, version
            
            
              The maximum memory measured as a percentage of the memory allocated 
              to the function.
              Unit: Percent
              
            
          
          
            
              rx_bytes
            
              function_name
              function_name, version
            
            
              The number of bytes received by the function.
              Unit: Bytes
              
            
          
          
          
            
              tmp_used
            
            
              The amount of space used in the /tmp directory.
              Unit: Bytes
              
            
          
          
          
            
              tx_bytes
            
              function_name
              function_name, version
            
            
              The number of bytes sent by the function.
              Unit: Bytes
              
            
          
          
            
              total_memory
            
              function_name
              function_name, version
            
            
              The amount of memory allocated to your Lambda function. This is the same as your
                function’s memory size.
              Unit: Megabytes
              
            
          
          
          
          
            
              total_network
            
              function_name
              function_name, version
            
            
              Sum of rx_bytes and tx_bytes. Even for functions that
                don't perform I/O tasks, this value is usually greater than zero because of network
                calls made by the Lambda runtime.
              Unit: Bytes
              
            
          
          
            
              used_memory_max
            
              function_name
              function_name, version
            
            
              The measured memory of the function sandbox.
              
              Unit: Megabytes
              
            
          
        
        The following metrics can be found in the 
      embedded metric format log entries by using CloudWatch Logs Insights. For more information 
      about CloudWatch Logs Insights, see  Analyzing Log Data with CloudWatch Logs
      Insights.For more information about embedded metric format, 
      see Embedding metrics within logs.
          
            Metric name
            Description
          
        
          
            
              cpu_system_time
            
              The amount of time the CPU spent executing kernel code.
              Unit: Milliseconds
              
            
          
          
            
              cpu_total_time
            
              Sum of cpu_system_time and cpu_user_time.
              Unit: Milliseconds
              
            
          
          
            
              cpu_user_time
            
              The amount of time the CPU spent executing user code.
              Unit: Milliseconds
              
            
          
          
            
              fd_max
            
              The maximum number of file descriptors available.
              Unit: Count
              
            
          
          
            
              fd_use
            
              The maximum number of file descriptors in use.
              Unit: Count
              
            
          
          
            
              memory_utilization

            
              The maximum memory measured as a percentage of the memory allocated 
                to the function.
              Unit: Percent
              
            
          
          
            
              rx_bytes

            
              The number of bytes received by the function.
              Unit: Bytes
              
            
          
          
          
            
              tx_bytes

            
              The number of bytes sent by the function.
              Unit: Bytes
              
            
          
          
            
              threads_max

            
              The number of threads in use by the function process. As a function author, you
                don't control the initial number of threads created by the runtime.
              Unit: Count
              
            
          
          
            
              tmp_max
            
              The amount of space available in the /tmp directory.
              Unit: Bytes
              
            
          
          
          
            
              total_memory

            
              The amount of memory allocated to your Lambda function. This is the same as your
                function’s memory size.
              Unit: Megabytes
              
            
          
          
            
              total_network

            
              Sum of rx_bytes and tx_bytes. Even for functions that
                don't perform I/O tasks, this value is usually greater than zero because of network
                calls made by the Lambda runtime.
              Unit: Bytes
              
            
          
          
            
              used_memory_max

            
              The measured memory of the function sandbox.
              
              Unit: Bytes
              
            
          
          
        Document ConventionsIntegration with Application InsightsTroubleshooting and known issuesDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\n