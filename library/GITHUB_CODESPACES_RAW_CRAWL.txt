Codespaces documentation Create a codespace to start developing in a secure, configurable, and dedicated development environment that works how and where you want it to.Overview Quickstart View video transcript Start hereView all Enabling or disabling GitHub Codespaces for your organizationYou can control which users can use GitHub Codespaces in your organization's private repositories.Understanding the codespace lifecycleLearn how to develop in a GitHub Codespaces environment, and maintain your data throughout the entire codespace lifecycle.Introduction to dev containersWhen you work in a codespace, the environment you are working in is created using a development container, or dev container, hosted on a virtual machine.Managing access to other repositories within your codespaceYou can manage the repositories that GitHub Codespaces can access.Set up your projectSetting up a Node.js project for GitHub CodespacesGet started with a Node.js, JavaScript, or TypeScript project in GitHub Codespaces by creating a custom dev container configuration.Setting up a Python project for GitHub CodespacesGet started with a Python project in GitHub Codespaces by creating a custom dev container configuration.Setting up a Java project for GitHub CodespacesGet started with a Java project in GitHub Codespaces by creating a custom dev container configuration.Setting up a C# (.NET) project for GitHub CodespacesGet started with a C# (.NET) project in GitHub Codespaces by creating a custom dev container configuration.What's newView all VSCode Copilot agent mode in CodespacesApril 11Scheduled Codespaces maintenance – AprilApril 02Scheduled Codespaces maintenanceFebruary 27GuidesDeep dive into GitHub CodespacesExplore more detail about how GitHub Codespaces work.@GitHubCreating a codespace for a repositoryYou can create a codespace for a branch in a repository to develop online.@GitHubCreating a codespace from a templateIf you're starting a new project, you can create a codespace from a blank template or choose a template specially designed for the type of work you want to do.@GitHubOpening an existing codespaceYou can reopen a codespace that you have closed or stopped and return to your work.@GitHubExplore guides All Codespaces docsGetting started with GitHub CodespacesWhat are GitHub Codespaces?GitHub Codespaces featuresUnderstanding the codespace lifecycleDeep dive into GitHub CodespacesDeveloping in a codespaceDeveloping in a codespaceCreating a codespace for a repositoryCreating a codespace from a templateDeleting a codespaceOpening an existing codespaceWorking collaboratively in a codespaceUsing source control in your codespaceUsing GitHub Codespaces for pull requestsStopping and starting a codespaceForwarding ports in your codespaceRebuilding the container in a codespaceDefault environment variables for your codespacePersisting environment variables and temporary filesConnecting to a private networkGetting started with GitHub Codespaces for machine learningUsing GitHub Codespaces in Visual Studio CodeUsing GitHub Codespaces with GitHub CLICustomizing your codespaceRenaming a codespaceChanging the shell in a codespaceChanging the machine type for your codespaceSetting your user preferencesPersonalizing GitHub Codespaces for your accountSetting your default editor for GitHub CodespacesSetting your default region for GitHub CodespacesSetting your timeout period for GitHub CodespacesConfiguring automatic deletion of your codespacesChoosing the stable or beta host imageSetting up your project for GitHub CodespacesAdding a dev container configuration to your repository • 6 articlesConfiguring dev containers • 4 articlesSetting up your repository for GitHub Codespaces • 2 articlesPrebuilding your codespacesAbout GitHub Codespaces prebuildsConfiguring prebuildsAllowing a prebuild to access other repositoriesManaging prebuildsTesting dev container configuration changes on a prebuild-enabled branchManaging your codespacesManaging your account-specific secrets for GitHub CodespacesManaging access to other repositories within your codespaceReviewing your security logs for GitHub CodespacesManaging GPG verification for GitHub CodespacesManaging GitHub Codespaces for your organizationEnabling or disabling GitHub Codespaces for your organizationChoosing who owns and pays for codespaces in your organizationListing the codespaces in your organizationManaging the cost of GitHub Codespaces in your organizationManaging development environment secrets for your repository or organizationReviewing your organization's audit logs for GitHub CodespacesRestricting access to machine typesRestricting the number of organization-billed codespaces a user can createRestricting the base image for codespacesRestricting the visibility of forwarded portsRestricting the idle timeout periodRestricting the retention period for codespacesReferenceAllowing your codespace to access a private registryUsing GitHub Copilot in GitHub CodespacesUsing the Visual Studio Code Command Palette in GitHub CodespacesSecurity in GitHub CodespacesDisaster recovery for GitHub CodespacesTroubleshooting GitHub CodespacesGitHub Codespaces logsTroubleshooting GitHub Codespaces clientsGetting the most out of your included usageExporting changes to a branchTroubleshooting creation and deletion of codespacesTroubleshooting authentication to a repositoryTroubleshooting your connection to GitHub CodespacesTroubleshooting prebuildsTroubleshooting personalization options for GitHub CodespacesTroubleshooting port forwarding for GitHub CodespacesTroubleshooting GPG verification for GitHub CodespacesWorking with support for GitHub Codespaces\n\n\n\nCodespaces documentation Create a codespace to start developing in a secure, configurable, and dedicated development environment that works how and where you want it to.Overview Quickstart View video transcript Start hereView all Enabling or disabling GitHub Codespaces for your organizationYou can control which users can use GitHub Codespaces in your organization's private repositories.Understanding the codespace lifecycleLearn how to develop in a GitHub Codespaces environment, and maintain your data throughout the entire codespace lifecycle.Introduction to dev containersWhen you work in a codespace, the environment you are working in is created using a development container, or dev container, hosted on a virtual machine.Managing access to other repositories within your codespaceYou can manage the repositories that GitHub Codespaces can access.Set up your projectSetting up a Node.js project for GitHub CodespacesGet started with a Node.js, JavaScript, or TypeScript project in GitHub Codespaces by creating a custom dev container configuration.Setting up a Python project for GitHub CodespacesGet started with a Python project in GitHub Codespaces by creating a custom dev container configuration.Setting up a Java project for GitHub CodespacesGet started with a Java project in GitHub Codespaces by creating a custom dev container configuration.Setting up a C# (.NET) project for GitHub CodespacesGet started with a C# (.NET) project in GitHub Codespaces by creating a custom dev container configuration.What's newView all VSCode Copilot agent mode in CodespacesApril 11Scheduled Codespaces maintenance – AprilApril 02Scheduled Codespaces maintenanceFebruary 27GuidesDeep dive into GitHub CodespacesExplore more detail about how GitHub Codespaces work.@GitHubCreating a codespace for a repositoryYou can create a codespace for a branch in a repository to develop online.@GitHubCreating a codespace from a templateIf you're starting a new project, you can create a codespace from a blank template or choose a template specially designed for the type of work you want to do.@GitHubOpening an existing codespaceYou can reopen a codespace that you have closed or stopped and return to your work.@GitHubExplore guides All Codespaces docsGetting started with GitHub CodespacesWhat are GitHub Codespaces?GitHub Codespaces featuresUnderstanding the codespace lifecycleDeep dive into GitHub CodespacesDeveloping in a codespaceDeveloping in a codespaceCreating a codespace for a repositoryCreating a codespace from a templateDeleting a codespaceOpening an existing codespaceWorking collaboratively in a codespaceUsing source control in your codespaceUsing GitHub Codespaces for pull requestsStopping and starting a codespaceForwarding ports in your codespaceRebuilding the container in a codespaceDefault environment variables for your codespacePersisting environment variables and temporary filesConnecting to a private networkGetting started with GitHub Codespaces for machine learningUsing GitHub Codespaces in Visual Studio CodeUsing GitHub Codespaces with GitHub CLICustomizing your codespaceRenaming a codespaceChanging the shell in a codespaceChanging the machine type for your codespaceSetting your user preferencesPersonalizing GitHub Codespaces for your accountSetting your default editor for GitHub CodespacesSetting your default region for GitHub CodespacesSetting your timeout period for GitHub CodespacesConfiguring automatic deletion of your codespacesChoosing the stable or beta host imageSetting up your project for GitHub CodespacesAdding a dev container configuration to your repository • 6 articlesConfiguring dev containers • 4 articlesSetting up your repository for GitHub Codespaces • 2 articlesPrebuilding your codespacesAbout GitHub Codespaces prebuildsConfiguring prebuildsAllowing a prebuild to access other repositoriesManaging prebuildsTesting dev container configuration changes on a prebuild-enabled branchManaging your codespacesManaging your account-specific secrets for GitHub CodespacesManaging access to other repositories within your codespaceReviewing your security logs for GitHub CodespacesManaging GPG verification for GitHub CodespacesManaging GitHub Codespaces for your organizationEnabling or disabling GitHub Codespaces for your organizationChoosing who owns and pays for codespaces in your organizationListing the codespaces in your organizationManaging the cost of GitHub Codespaces in your organizationManaging development environment secrets for your repository or organizationReviewing your organization's audit logs for GitHub CodespacesRestricting access to machine typesRestricting the number of organization-billed codespaces a user can createRestricting the base image for codespacesRestricting the visibility of forwarded portsRestricting the idle timeout periodRestricting the retention period for codespacesReferenceAllowing your codespace to access a private registryUsing GitHub Copilot in GitHub CodespacesUsing the Visual Studio Code Command Palette in GitHub CodespacesSecurity in GitHub CodespacesDisaster recovery for GitHub CodespacesTroubleshooting GitHub CodespacesGitHub Codespaces logsTroubleshooting GitHub Codespaces clientsGetting the most out of your included usageExporting changes to a branchTroubleshooting creation and deletion of codespacesTroubleshooting authentication to a repositoryTroubleshooting your connection to GitHub CodespacesTroubleshooting prebuildsTroubleshooting personalization options for GitHub CodespacesTroubleshooting port forwarding for GitHub CodespacesTroubleshooting GPG verification for GitHub CodespacesWorking with support for GitHub Codespaces\n\n\n\nGitHub DocsHelp for wherever you are on your GitHub journey.Get startedGet startedMigrationsAccount and profileAuthenticationBilling and paymentsSite policyCollaborative codingCodespacesRepositoriesPull requestsGitHub DiscussionsGitHub CopilotGitHub CopilotGet code suggestionsPrompt engineeringChat in GitHubCopilot Chat CookbookExtensions quickstartCI/CD and DevOpsGitHub ActionsGitHub PackagesGitHub PagesSecuritySecure codingSecret scanningSupply chain securityDependabotCode scanningSecurity advisoriesClient appsGitHub CLIGitHub MobileGitHub DesktopProject managementGitHub IssuesProjectsSearch on GitHubEnterprise and TeamsOrganizationsSecure your organizationEnterprise onboardingEnterprise administratorsGitHub Well-ArchitectedDevelopersAppsREST APIGraphQL APIWebhooksBuild Copilot ExtensionsGitHub ModelsCommunityBuilding communitiesGitHub SponsorsGitHub EducationGitHub for NonprofitsGitHub SupportContribute to GitHub DocsMore docsCodeQL query writingElectronnpmGetting startedSet up GitAt the heart of GitHub is an open-source version control system (VCS) called Git. Git is responsible for everything GitHub-related that happens locally on your computer.Connecting to GitHub with SSHYou can connect to GitHub using the Secure Shell Protocol (SSH), which provides a secure channel over an unsecured network.Creating and managing repositoriesYou can create a repository on GitHub to store and collaborate on your project's files, then manage the repository's name and location.Basic writing and formatting syntaxCreate sophisticated formatting for your prose and code on GitHub with simple syntax.PopularAbout pull requestsLearn about pull requests and draft pull requests on GitHub. Pull requests communicate changes to a branch in a repository. Once a pull request is opened, you can review changes with collaborators and add follow-up commits.Authentication documentationKeep your account and data secure with features like two-factor authentication, SSH, and commit signature verification.Getting code suggestions in your IDE with GitHub CopilotUse GitHub Copilot to get code suggestions in your editor.Managing remote repositoriesLearn to work with your local repositories on your computer and remote repositories hosted on GitHub.\n\n\n\nCodespaces/QuickstartQuickstart for GitHub CodespacesGet started with GitHub Codespaces quickly.In this articleIntroductionCreating your codespaceRunning the applicationEdit the application and view changesCommitting and pushing your changesPersonalizing with an extensionNext stepsFurther readingIntroduction
In this guide, you'll create a codespace from a template repository and explore some of the essential features available to you within the codespace. You'll work in the browser version of Visual Studio Code, which is initially the default editor for GitHub Codespaces. After trying out this quickstart you can use Codespaces in other editors, and you can change the default editor. Links are provided at the end of this guide.
From this quickstart, you'll learn how to create a codespace, connect to a forwarded port to view your running application, publish your codespace to a new repository, and personalize your setup with extensions.
For more information on exactly how GitHub Codespaces works, see the companion guide Deep dive into GitHub Codespaces.
Creating your codespace


Navigate to the github/haikus-for-codespaces template repository.


Click Use this template, then click Open in a codespace.



Running the application
Once your codespace is created, the template repository will be automatically cloned into it. Now you can run the application and launch it in a browser.


When the terminal becomes available, enter the command npm run dev. This example uses a Node.js project, and this command runs the script labeled "dev" in the package.json file, which starts up the web application defined in the sample repository.

If you're following along with a different application type, enter the corresponding start command for that project.


When your application starts, the codespace recognizes the port the application is running on and displays a pop-up message to let you know that the port has been forwarded.



Click Open in Browser to view your running application in a new tab.


Edit the application and view changes


Switch back to your codespace and open the haikus.json file by clicking it in the Explorer.


Edit the text field of the first haiku to personalize the application with your own haiku.


Go back to the running application tab in your browser and refresh to see your changes.
 If you've closed the browser tab, click the Ports tab in VS Code, hover over the Local Address value for the running port, and click the Open in Browser icon.



Committing and pushing your changes
Now that you've made a few changes, you can use the integrated terminal or the source view to publish your work to a new repository.


In the Activity Bar, click the Source Control view.



To stage your changes, click  next to the haikus.json file, or next to Changes if you've changed multiple files and you want to stage them all.



To commit your staged changes, type a commit message describing the change you've made, then click Commit.



Click Publish Branch.



In the "Repository Name" dropdown, type a name for your new repository, then select Publish to GitHub private repository or Publish to GitHub public repository.

The owner of the new repository will be the GitHub account with which you created the codespace.


In the pop-up that appears in the lower right corner of the editor, click Open on GitHub to view the new repository on GitHub. In the new repository, view the haikus.json file and check that the change you made in your codespace has been successfully pushed to the repository.



Personalizing with an extension
When you connect to a codespace using the browser, or the Visual Studio Code desktop application, you can access the Visual Studio Code Marketplace directly from the editor. For this example, you'll install a VS Code extension that alters the theme, but you can install any extension that's useful for your workflow.


In the Activity Bar, click the Extensions icon.



In the search bar, type fairyfloss and click Install.



Select the fairyfloss theme by selecting it from the list.



About Settings Sync
You can enable Settings Sync to sync extensions and other settings across devices and instances of VS Code. Your synced settings are cached in the cloud. If Settings Sync is turned on in a codespace, any updates you make to your settings in the codespace are pushed to the cloud, and any updates you push to the cloud from elsewhere are pulled into your codespace. For more information, see Personalizing GitHub Codespaces for your account.
Next steps
You've successfully created, personalized, and run your first application within a codespace but there's so much more to explore! Here are some helpful resources for taking your next steps with GitHub Codespaces.

Deep dive into GitHub Codespaces: This quickstart presented some of the features of GitHub Codespaces. The deep dive looks at these areas from a technical standpoint.
Adding a dev container configuration to your repository: These guides provide information on setting up your repository to use GitHub Codespaces with specific languages.
Introduction to dev containers: This guide provides details on creating a custom configuration for Codespaces for your project.

Further reading

Enabling or disabling GitHub Codespaces for your organization
Using GitHub Codespaces in Visual Studio Code
Using GitHub Codespaces with GitHub CLI
Setting your default editor for GitHub Codespaces.
Managing the cost of GitHub Codespaces in your organization\n\n\n\nCodespaces/Getting started/What are Codespaces?What are GitHub Codespaces?Learn about what GitHub Codespaces are.In this articleIntroductionUsing GitHub CodespacesBilling for CodespacesIntroduction
A codespace is a development environment that's hosted in the cloud. You can customize your project for GitHub Codespaces by committing configuration files to your repository (often known as Configuration-as-Code), which creates a repeatable codespace configuration for all users of your project. See Introduction to dev containers.
Each codespace you create is hosted by GitHub in a Docker container, running on a virtual machine. You can choose from a selection of virtual machine types, from 2 cores, 8 GB RAM, and 32 GB storage, up to 32 cores, 64 GB RAM, and 128 GB storage.
By default, the codespace development environment is created from an Ubuntu Linux image that includes a selection of popular languages and tools, but you can use an image based on a Linux distribution of your choice and configure it for your particular requirements. Regardless of your local operating system, your codespace will run in a Linux environment. Windows and macOS are not supported operating systems for the remote development container.
You can connect to your codespaces from your browser, from Visual Studio Code, or by using GitHub CLI. When you connect, you are placed within the Docker container. You have limited access to the outer Linux virtual machine host.

Using GitHub Codespaces
To begin developing using cloud-based compute resources, you can create a codespace from a template or from any branch or commit in a repository. When you create a codespace from a template, you can start from a blank template or choose a template suitable for the work you're doing.
To get started with GitHub Codespaces, see Quickstart for GitHub Codespaces. For more information on creating a codespace, see Creating a codespace for a repository or Creating a codespace from a template. If you want to return to a codespace you've already created, see Opening an existing codespace. To learn more about how GitHub Codespaces works, see Deep dive into GitHub Codespaces.
Using codespaces owned by your personal account
All personal GitHub accounts have a monthly quota of free use of GitHub Codespaces included in the Free or Pro plan. You can get started using GitHub Codespaces on your personal account without changing any settings or providing payment details.
If you create a codespace from an organization-owned repository, use of the codespace will either be charged to the organization (if the organization is configured for this), or to your personal account.
You can continue using GitHub Codespaces beyond your monthly included storage and compute usage by providing payment details and setting a spending limit. See About billing for GitHub Codespaces.
Using organization-owned codespaces
Owners of organizations on GitHub Team and GitHub Enterprise plans can pay for their members' and collaborators' use of GitHub Codespaces. This applies to codespaces created from repositories owned by the organization. See Choosing who owns and pays for codespaces in your organization. You can set a spending limit for use of GitHub Codespaces on your organization or enterprise account. See Managing the spending limit for GitHub Codespaces.
If use of a codespace will be billed to an organization or enterprise, this is shown when the codespace is created. See Creating a codespace for a repository. Codespaces that are billed to an organization, or its parent enterprise, are owned by the organization and can be deleted by an organization owner. See Deleting a codespace.
Your ability to create codespaces from organization-owned repositories depends on several factors, including the repository's visibility and the settings of the organization or its parent enterprise. For more information, see Troubleshooting creation and deletion of codespaces.
Customizing GitHub Codespaces
To customize the runtimes and tools in your codespace, you can create one or more dev container configurations for your repository. Adding dev container configurations to your repository allows you to define a choice of different development environments that are appropriate for the work people will do in your repository.
If you create a codespace from a repository without any dev container configurations, GitHub Codespaces will clone your repository into an environment with the default dev container image that includes many tools, languages, and runtime environments. If you create a codespace from a template, you might start with some initial configuration on top of the default image. See Introduction to dev containers.
You can personalize aspects of your codespace environment by using a public dotfiles repository. You can use dotfiles to set shell aliases and preferences, or to install your personal preference of the tools you like to use. If you use GitHub Codespaces in the browser, or in Visual Studio Code, you can use Settings Sync to give your codespace editor the same settings, keyboard shortcuts, snippets, and extensions that you have set up in your local installation of Visual Studio Code.
See Customizing your codespace.
Billing for Codespaces
For information on pricing, storage, and usage for GitHub Codespaces, see About billing for GitHub Codespaces.
Note
 You must set a non-zero spending limit on your personal, organization, or enterprise account before the account can be billed for use of GitHub Codespaces.

By default, all accounts have a GitHub Codespaces spending limit of $0 USD. This prevents new codespaces being created, or existing codespaces being opened, if doing so would incur a billable cost to your personal, organization, or enterprise account. For personal accounts, if you have access to create a codespace, you can do so as long as the account has not reached the limit of its monthly included usage. For organizations and enterprises, the default spending limit means that, to allow people to create codespaces that are billed to the organization, or its parent enterprise, the limit must be changed to a value above $0 USD.
Costs for GitHub Codespaces are always billed monthly, even if your account is otherwise billed annually. For information on how organizations owners and billing managers can manage the spending limit for GitHub Codespaces for an organization, see Managing the spending limit for GitHub Codespaces.\n\n\n\nCodespaces/Getting started/Codespaces featuresGitHub Codespaces featuresLearn about what GitHub Codespaces offer.GitHub Codespaces features
Preconfigured development environments
You can work in a development environment that has been specifically configured for the repository. It will have all of the tools, languages, and configurations you need to work on that project. Everyone who works on that repository in a codespace will have the same environment. This reduces the likelihood of environment-related problems occurring and being difficult to debug. Each repository can have settings that will give contributors a ready-to-use, fit-for-purpose environment, and the environment on your local machine will be unchanged.
Access the resources you need
Your local computer may not have the processing power, or storage space, you need to work on a project. GitHub Codespaces allows you to work remotely on a machine with adequate resources.
Work anywhere
All you need is a web browser. You can work in a codespace on your own computer, on a friend's laptop, or on a tablet. Open your codespace and pick up from where you left off on a different device.
Choose your editor
Work in the browser, using the VS Code web client or JupyterLab, or in the desktop-based VS Code application.
Work on multiple projects
You can use multiple codespaces to work on separate projects, or on different branches of the same repository, compartmentalizing your work to avoid changes made for one piece of work accidentally affecting something else you're working on.
Pair program with a teammate
If you work on a codespace in VS Code, you can use Live Share to work collaboratively with other people on your team. See Working collaboratively in a codespace.
Publish your web app from a codespace
Forward a port from your codespace and then share the URL, to allow teammates to try out the changes you've made to the application before you submit those changes in a pull request.
Try out a framework
GitHub Codespaces reduces the setup time when you want to learn a new framework. Just create a codespace from one of the quickstart templates.\n\n\n\nCodespaces/Getting started/The codespace lifecycleUnderstanding the codespace lifecycleLearn how to develop in a GitHub Codespaces environment, and maintain your data throughout the entire codespace lifecycle.In this articleAbout the lifecycle of a codespaceCreating a codespaceSaving changes in a codespaceTimeouts for GitHub CodespacesRebuilding a codespaceStopping a codespaceDeleting a codespaceLosing the connection while using GitHub CodespacesNote

This article explains the stages in the life of a codespace, from creation to deletion. If you have read the Quickstart for GitHub Codespaces article and you now want to start using GitHub Codespaces for your own work, see the articles under Developing in a codespace.

About the lifecycle of a codespace
The lifecycle of a codespace begins when you create a codespace and ends when you delete it. You can disconnect and reconnect to an active codespace without affecting its running processes. You may stop and restart a codespace without losing changes that you have made to your project.
Creating a codespace
When you want to work on a project, you can choose to create a new codespace or open an existing codespace. You might want to create a new codespace from a branch of your repository each time you develop in GitHub Codespaces or keep a long-running codespace for a feature. If you're starting a new project, you might want to create a codespace from a template and publish to a repository on GitHub later. For more information, see Creating a codespace for a repository and Creating a codespace from a template.
There are limits to the number of codespaces you can create, and the number of codespaces you can run at the same time. These limits vary based on a number of factors. If you reach the maximum number of codespaces and try to create another, a message is displayed telling you that you must remove an existing codespace before you can create a new one. Similarly, if you reach the maximum number of active codespaces and you try to start another, you are prompted to stop one of your active codespaces.
If you choose to create a new codespace each time you work on a project, you should regularly push your changes so that any new commits are on GitHub. If you choose to use a long-running codespace for your project, you should pull from your repository's default branch each time you start working in your codespace so that your environment has the latest commits. This workflow is very similar to if you were working with a project on your local machine.
To speed up codespace creation, repository administrators can enable GitHub Codespaces prebuilds for a repository. For more information, see About GitHub Codespaces prebuilds.
Saving changes in a codespace
When you connect to a codespace through the web, auto-save is enabled automatically for the web editor and configured to save changes after a delay. When you connect to a codespace through Visual Studio Code running on your desktop, you must enable auto-save. For more information, see Save/Auto Save in the Visual Studio Code documentation.
Your work will be saved on a virtual machine in the cloud. You can close and stop a codespace and return to the saved work later. If you have unsaved changes, your editor will prompt you to save them before exiting. However, if your codespace is deleted, then your work will be deleted too. To persist your work, you will need to commit your changes and push them to your remote repository, or publish your work to a new remote repository if you created your codespace from a template. For more information, see Using source control in your codespace.
Timeouts for GitHub Codespaces
If you leave your codespace running without interaction, or if you exit your codespace without explicitly stopping it, the codespace will timeout after a period of inactivity and stop running. By default, a codespace will timeout after 30 minutes of inactivity, but you can customize the duration of the timeout period for new codespaces that you create. For more information about setting the default timeout period for your codespaces, see Setting your timeout period for GitHub Codespaces. For more information about stopping a codespace, see Stopping a codespace.
When a codespace times out, your data is preserved from the last time your changes were saved. For more information, see Saving changes in a codespace.
Rebuilding a codespace
You can rebuild your codespace to implement changes you've made to your dev container configuration. For most uses, you can create a new codespace as an alternative to rebuilding a codespace. By default, when you rebuild your codespace, GitHub Codespaces will reuse images from your cache to speed up the rebuild process. Alternatively, you can perform a full rebuild, which clears your cache and rebuilds the container with fresh images.
Note

When you rebuild the container in a codespace, changes you have made outside the /workspaces directory are cleared. Changes you have made inside the /workspaces directory, which includes the clone of the repository or template from which you created the codespace, are preserved over a rebuild. For more information, see Deep dive into GitHub Codespaces.

For more information, see Introduction to dev containers and Rebuilding the container in a codespace.
Stopping a codespace
You can stop a codespace at any time. When you stop a codespace, any running processes are stopped. Any saved changes in your codespace will still be available when you next start it. The terminal history is preserved, but the visible contents of the terminal window are not preserved between codespace sessions.
If you do not explicitly stop a codespace, it will continue to run until it times out from inactivity. Closing a codespace does not stop the codespace. For example, if you're using a codespace in the VS Code web client and you close the browser tab, the codespace remains running on the remote machine. For information about timeouts, see Understanding the codespace lifecycle.
Only running codespaces incur CPU charges. A stopped codespace incurs only storage costs.
You may want to stop and restart a codespace to apply changes to it. For example, if you change the machine type used for your codespace, you will need to stop and restart it for the change to take effect. You can also stop your codespace and choose to restart or delete it if you encounter an error or something unexpected. For more information, see Stopping and starting a codespace.
Deleting a codespace
You can create a codespace for a particular task and then safely delete the codespace after you push your changes to a remote branch.
If you try to delete a codespace with unpushed git commits, your editor will notify you that you have changes that have not been pushed to a remote branch. You can push any desired changes and then delete your codespace, or continue to delete your codespace and any uncommitted changes. You can also export your code to a new branch without creating a new codespace. For more information, see Exporting changes to a branch.
Codespaces that have been stopped and remain inactive for a specified period of time will be deleted automatically. By default, inactive codespaces are deleted after 30 days, but you can customize your codespace retention period. For more information, see Configuring automatic deletion of your codespaces.
If you create a codespace, it will continue to accrue storage charges until it is deleted, irrespective of whether it is active or stopped. For more information, see About billing for GitHub Codespaces. Deleting a codespace does not reduce the current billable amount for GitHub Codespaces, which accumulates during each monthly billing cycle. For more information, see Viewing your GitHub Codespaces usage.
For more information on deleting a codespace, see Deleting a codespace.
Losing the connection while using GitHub Codespaces
GitHub Codespaces is a cloud-based development environment and requires an internet connection. If you lose connection to the internet while working in a codespace, you will not be able to access your codespace. However, any uncommitted changes will be saved. When you have access to an internet connection again, you can connect to your codespace in the exact same state that it was left in. If you have an unstable internet connection, you should commit and push your changes often.
If you know that you will often be working offline, you can use your devcontainer.json file with the "Dev Containers" extension for VS Code to build and attach to a local development container for your repository. For more information, see Developing inside a container in the Visual Studio Code documentation.\n\n\n\nCodespaces/Getting started/Deep dive into CodespacesDeep dive into GitHub CodespacesExplore more detail about how GitHub Codespaces work.In this articleCreating your codespaceCodespaces lifecycleRunning your applicationCommitting and pushing your changesPersonalizing your codespace with extensionsAbout the directory structure of a codespaceFurther readingGitHub Codespaces is an instant, cloud-based development environment that uses a container to provide you with common languages, tools, and utilities for development. GitHub Codespaces is also configurable, allowing you to create a customized development environment for your project. By configuring a custom development environment for your project, you can have a repeatable codespace configuration for all users of your project.
Creating your codespace
There are a number of entry points to create a codespace.

From a GitHub template or any template repository on GitHub to start a new project
From a branch in your repository for new feature work
From an open pull request to explore work-in-progress
From a commit in a repository's history to investigate a bug at a specific point in time

You can create a codespace on GitHub, in Visual Studio Code, or by using GitHub CLI.
Your codespace can be ephemeral if you need to test something or you can return to the same codespace to work on long-running feature work.
For more information, see Creating a codespace for a repository, Creating a codespace from a template, and Opening an existing codespace.
Note

You can create more than one codespace per repository or even per branch. However, there are limits to the number of codespaces you can create, and the number of codespaces you can run at the same time. If you reach the maximum number of codespaces and try to create another, a message is displayed telling you that you must remove an existing codespace before you can create a new one.

The codespace creation process
When you create a codespace, various steps happen in the background before the codespace is available to you.
Step 1: VM and storage are assigned to your codespace
When you create a codespace, a virtual machine (VM) is created using either the stable or public preview release of the VM host image. For more information, see Choosing the stable or beta host image. The host image defines the version of Linux that is used for the VM. The VM is both dedicated and private to you. Having a dedicated VM ensures that you have the entire set of compute resources from that machine available to you. If necessary, this also allows you to have full root access to your container.
A shallow clone is then made of your repository, or of the template repository if you're creating a codespace from a template. This is cloned into the /workspaces directory of the VM and subsequently mounted into the dev container. For more information, see About the directory structure of a codespace below.
Step 2: Dev container is created
GitHub Codespaces uses a Docker container as the development environment. This container is created based on configurations that you can define in a devcontainer.json file and, optionally, a Dockerfile. If you create a codespace from GitHub's blank template, or from a repository with no devcontainer.json file, GitHub Codespaces uses a default image, which has many languages and runtimes available. For more information, see Introduction to dev containers. For details of what the default image for dev containers includes, see the devcontainers/images repository.
Note

If you want to use Git hooks in your codespace and apply anything in the git template directory to your codespace, then you must set up hooks during step 4 after the container is created.
Since your repository is cloned onto the host VM before the container is created, anything in the git template directory will not apply in your codespace unless you set up hooks in your devcontainer.json configuration file using the postCreateCommand in step 4. For more information, see Step 4: Post-creation setup.

Step 3: Connecting to the codespace
When your container has been created and any other initialization has run, you'll be connected to your codespace. You can connect to it by using:

Your web browser
Visual Studio Code
GitHub CLI

Step 4: Post-creation setup
Once you are connected to your codespace, your automated setup may continue to build based on the configuration specified in your devcontainer.json file. You may see postCreateCommand and postAttachCommand run.
If you want to use Git hooks in your codespace, set up hooks using the devcontainer.json lifecycle scripts, such as postCreateCommand. For information about the lifecycle scripts, see the dev containers specification on the Development Containers website.
If you have a public dotfiles repository for GitHub Codespaces, you can enable it for use with new codespaces. When enabled, your dotfiles will be cloned to the container and the install script will be invoked. For more information, see Personalizing GitHub Codespaces for your account.
Finally, if you created the codespace from a repository, the entire history of the repository is copied down with a full clone. If you created the codespace from a template, the full history of the template repository is not preserved; instead, unless you are using the blank template, you will start with an initial commit for the contents of the template repository.
During post-creation setup you'll still be able to use the integrated terminal and make edits to your files, but take care to avoid any race conditions between your work and the commands that are running.
Codespaces lifecycle
Saving files in your codespace
Save changes to files in the normal way, depending on the editor you are using.
If you work on codespaces in Visual Studio Code, you can enable Auto Save to ensure that your changes are always saved.
Closing or stopping your codespace
Your codespace will keep running while you are using it, but will time out after a period of inactivity. File changes from the editor and terminal output are counted as activity, so your codespace will not time out if terminal output is continuing. The default inactivity timeout period is 30 minutes. You can define your personal timeout setting for codespaces you create, but this may be overruled by an organization timeout policy. For more information, see Setting your timeout period for GitHub Codespaces.
If a codespace times out it will stop running, but you can restart it from the browser tab (if you were using the codespace in the browser), from within VS Code, or from your list of codespaces at https://github.com/codespaces.
To stop your codespace you can

In the browser: on your list of codespaces at https://github.com/codespaces, click the ellipsis (...) to the right of the codespace you want to stop and click Stop codespace.
In VS Code: open the Visual Studio Code Command Palette - for example, by pressing Ctrl+Shift+P (Windows/Linux) or Shift+Command+P (Mac) - type Codespaces: stop then press Enter. For more information, see Using the Visual Studio Code Command Palette in GitHub Codespaces.
In a terminal window: use the GitHub CLI command gh codespace stop. For more information, see Using GitHub Codespaces with GitHub CLI.

If you exit your codespace without running the stop command (for example, by closing the browser tab), or if you leave the codespace running without interaction, the codespace and its running processes will continue for the duration of the inactivity timeout period.
When you close or stop your codespace, all uncommitted changes are preserved until you connect to the codespace again.
Running your application
Port forwarding gives you access to TCP ports running within your codespace. For example, if you're running a web application on port 4000 within your codespace, you can automatically forward that port to make the application accessible from your browser.
Port forwarding determines which ports are made accessible to you from the remote machine. Even if you do not forward a port, that port is still accessible to other processes running inside the codespace itself.

When an application running inside GitHub Codespaces outputs a port to the console, GitHub Codespaces detects the localhost URL pattern and automatically forwards the port. You can click on the URL in the terminal, or the link in the "toast" notification message that pops up at the bottom right corner of VS Code, to open the port in a browser. By default, GitHub Codespaces forwards the port using HTTP. For more information on port forwarding, see Forwarding ports in your codespace.
While ports can be forwarded automatically, they are not publicly accessible to the internet. By default, all ports are private, but you can manually make a port available to your organization or public, and then share access through a URL. For more information, see Forwarding ports in your codespace.
Running your application when you first land in your codespace can make for a fast inner dev loop. As you edit, your changes are automatically saved and available on your forwarded port. To view changes, go back to the running application tab in your browser and refresh it.
Committing and pushing your changes
Git is installed by default in your codespace and so you can rely on your existing Git workflow. You can work with Git in your codespace either via the Terminal or by using the source control features of VS Code.
If you're working with an existing repository, you can create a codespace from any branch, commit, or pull request in the repository, or you can switch to a new or existing branch from within your active codespace. Because GitHub Codespaces is designed to be ephemeral, you can use it as an isolated environment to experiment, check a teammate's pull request, or fix merge conflicts.
If you only have read access to a repository, then you can create a codespace for the repository as long as you can fork it. When you make a commit from the codespace, or push a new branch, GitHub Codespaces either automatically creates a fork of the repository for you, or links the codespace to an existing fork if you already have one for the upstream repository.
If you're working in a codespace created from a template, Git is installed by default, but you will need to publish your codespace to a remote repository to persist your work and to share it with others. If you start from GitHub's blank template, you first need to initialize your workspace as a Git repository (for example by entering git init) to start using source control within the codespace.
For more information, see Using source control in your codespace.
Note

Commits from your codespace will be attributed to the name and public email configured at https://github.com/settings/profile. A token scoped to the repository, included in the environment as GITHUB_TOKEN, and your GitHub credentials will be used to authenticate.

Personalizing your codespace with extensions
You can add extensions within a codespace to personalize your experience in VS Code.
VS Code extensions
If you work on your codespaces in the VS Code desktop application, or the web client, you can add any extensions you need from the Visual Studio Code Marketplace. For information on how extensions run in GitHub Codespaces, see Supporting Remote Development and GitHub Codespaces in the VS Code documentation.
If you already use VS Code, you can use Settings Sync to automatically sync extensions, settings, themes, and keyboard shortcuts between your local instance and any codespaces you create.
About the directory structure of a codespace
When you create a codespace, your repository is cloned into the /workspaces directory in your codespace. This is a persistent directory that is mounted into the container. Any changes you make inside this directory, including editing, adding, or deleting files, are preserved when you stop and start the codespace, and when you rebuild the container in the codespace.
Outside the /workspaces directory, your codespace contains a Linux directory structure that varies depending on the dev container image used to build your codespace. You can add files or make changes to files outside the /workspaces directory. For example, you can install new programs, or you can set up your shell configuration in a file such as ~/.bashrc. As a non-root user, you may not automatically have write access to certain directories, but most images allow root access to these directories with the sudo command.
Outside /workspaces, with the exception of the /tmp directory, the directories in a codespace are tied to the lifecycle of the container. This means any changes you make are preserved when you stop and start your codespace, but are not preserved when you rebuild the container. For more information on the /tmp directory, see Persisting environment variables and temporary files.
Clearing the directories outside /workspaces helps to ensure the rebuilt container is in the same state as it would be in a newly created codespace. If you're rebuilding a container to apply configuration changes to the codespace you're working in, you can be confident that any configuration changes you have made will work the same for users creating new codespaces with the same configuration. For more information, see Introduction to dev containers.
If you want to make changes to your codespace that will be more robust over rebuilds and across different codespaces, you have several options.

To install programs and tools in all codespaces created from a repository, in your dev container configuration, you can use lifecycle command properties such as postCreateCommand to run custom installation commands, or you can choose from pre-written installation commands called "features." For more information, see the dev containers specification on the Development Containers website and Adding features to a devcontainer.json file.
To install tools or customize your setup in every codespace you create, such as configuring your bash profile, you can link GitHub Codespaces with a dotfiles repository. The dotfiles repository is also cloned into the persistent /workspaces directory. For more information, see Personalizing GitHub Codespaces for your account.
If you want to preserve specific files over a rebuild, you can use a devcontainer.json file to create a symlink between the files and a persistent directory within /workspaces. For more information, see Rebuilding the container in a codespace.

Further reading

Enabling or disabling GitHub Codespaces for your organization
Managing the cost of GitHub Codespaces in your organization
Adding a dev container configuration to your repository
Understanding the codespace lifecycle\n\n\n\nCodespaces/Developing in a codespace/Develop in a codespaceDeveloping in a codespaceYou can work in a codespace using your browser, Visual Studio Code, or in a command shell.Tool navigationGitHub CLIVisual Studio CodeWeb browserIn this articleAbout development with GitHub CodespacesWorking in a codespace in the browserNavigating to an existing codespaceWorking in a codespace in VS CodeNavigating to an existing codespaceWorking in a codespace in a command shellAbout development with GitHub Codespaces
You can develop code in a codespace using your choice of tool:

A command shell, via an SSH connection initiated using GitHub CLI
The Visual Studio Code desktop application
A browser-based version of Visual Studio Code


The tabs in this article allow you to switch between information for each of these ways of working. You're currently on the tab for the web browser version of Visual Studio Code.
Working in a codespace in the browser
Using Codespaces in the browser provides you with a fully featured development experience. You can edit code, debug, use Git commands, and run your application.

The main components of the user interface are:

Side bar - By default, this area shows your project files in the Explorer.
Activity bar - This displays the Views and provides you with a way to switch between them. You can reorder the Views by dragging and dropping them.
Editor - This is where you edit your files. You can right-click the tab for a file to access options such as locating the file in the Explorer.
Panels - This is where you can see output and debug information, as well as the default place for the integrated Terminal.
Status bar - This area provides you with useful information about your codespace and project. For example, the branch name, configured ports, and more.
For the best experience with GitHub Codespaces, we recommend using a Chromium-based browser, like Google Chrome or Microsoft Edge. For more information, see Troubleshooting GitHub Codespaces clients.

Customizing the codespaces for a repository
You can customize the codespaces that are created for a repository by creating or updating the dev container configuration for the repository. You can do this from within a codespace. After you change a dev container configuration, you can apply the changes to the current codespace by rebuilding the Docker container for the codespace. For more information, see Introduction to dev containers.
Personalizing your codespace
You can use a dotfiles repository and Settings Sync to personalize aspects of the codespace environment for any codespace that you create. Personalization can include shell preferences and additional tools. For more information, see Personalizing GitHub Codespaces for your account.
Running your app from a codespace
You can forward ports in your codespace to test and debug your application. You can also manage the port protocol and share the port within your organization or publicly. For more information, see Forwarding ports in your codespace.
Committing your changes
When you've made changes to your codespace, either new code or configuration changes, you'll want to commit your changes. Committing configuration changes to your repository ensures that anyone else who creates a codespace from this repository has the same configuration. Any customization you do, such as adding VS Code extensions, will be available to all users.
For this tutorial, you created a codespace from a template repository, so the code in your codespace is not yet stored in a repository. You can create a repository by publishing the current branch to GitHub.
For information, see Using source control in your codespace.
Using the Visual Studio Code Command Palette
The Visual Studio Code Command Palette allows you to access and manage many features for Codespaces and Visual Studio Code. For more information, see Using the Visual Studio Code Command Palette in GitHub Codespaces.
Navigating to an existing codespace


You can see every available codespace that you have created on the "Your codespaces" page. To display this page, in the top-left corner of GitHub, select , then click  Codespaces. This takes you to github.com/codespaces.


Click the name of the codespace you want to develop in.



Alternatively, you can see any of your codespaces for a specific repository by navigating to that repository, clicking the  Code button and selecting the Codespaces tab. The dropdown menu will display all active codespaces for the repository.


The tabs in this article allow you to switch between information for each of these ways of working. You're currently on the tab for Visual Studio Code.
Working in a codespace in VS Code
GitHub Codespaces provides you with the full development experience of Visual Studio Code. You can edit code, debug, and use Git commands while developing in a codespace with VS Code. For more information, see the VS Code documentation.

The main components of the user interface are:

Side bar - By default, this area shows your project files in the Explorer.
Activity bar - This displays the Views and provides you with a way to switch between them. You can reorder the Views by dragging and dropping them.
Editor - This is where you edit your files. You can right-click the tab for a file to access options such as locating the file in the Explorer.
Panels - This is where you can see output and debug information, as well as the default place for the integrated Terminal.
Status bar - This area provides you with useful information about your codespace and project. For example, the branch name, configured ports, and more.

For more information on using VS Code, see the User Interface guide in the VS Code documentation.
You can connect to your codespace directly from VS Code. For more information, see Using GitHub Codespaces in Visual Studio Code.
For troubleshooting information, see Troubleshooting GitHub Codespaces clients.
Customizing the codespaces for a repository
You can customize the codespaces that are created for a repository by creating or updating the dev container configuration for the repository. You can do this from within a codespace. After you change a dev container configuration, you can apply the changes to the current codespace by rebuilding the Docker container for the codespace. For more information, see Introduction to dev containers.
Personalizing your codespace
You can use a dotfiles repository and Settings Sync to personalize aspects of the codespace environment for any codespace that you create. Personalization can include shell preferences and additional tools. For more information, see Personalizing GitHub Codespaces for your account.
Running your app from a codespace
You can forward ports in your codespace to test and debug your application. You can also manage the port protocol and share the port within your organization or publicly. For more information, see Forwarding ports in your codespace.
Committing your changes
When you've made changes to your codespace, either new code or configuration changes, you'll want to commit your changes. Committing configuration changes to your repository ensures that anyone else who creates a codespace from this repository has the same configuration. Any customization you do, such as adding VS Code extensions, will be available to all users.
For this tutorial, you created a codespace from a template repository, so the code in your codespace is not yet stored in a repository. You can create a repository by publishing the current branch to GitHub.
For information, see Using source control in your codespace.
Using the Visual Studio Code Command Palette
The Visual Studio Code Command Palette allows you to access and manage many features for Codespaces and Visual Studio Code. For more information, see Using the Visual Studio Code Command Palette in GitHub Codespaces.
Navigating to an existing codespace


You can see every available codespace that you have created on the "Your codespaces" page. To display this page, in the top-left corner of GitHub, select , then click  Codespaces. This takes you to github.com/codespaces.


Click the name of the codespace you want to develop in.



Alternatively, you can see any of your codespaces for a specific repository by navigating to that repository, clicking the  Code button and selecting the Codespaces tab. The dropdown menu will display all active codespaces for the repository.


The tabs in this article allow you to switch between information for each of these ways of working. You're currently on the tab for GitHub CLI.
Working in a codespace in a command shell
Note

To learn more about GitHub CLI, see About GitHub CLI.

You can use GitHub CLI to create a new codespace, or start an existing codespace, and then SSH to it. Once connected, you can work on the command line using your preferred command-line tools.
After installing GitHub CLI and authenticating with your GitHub account you can use the command gh codespace [<SUBCOMMAND>...] --help to browse the help information. Alternatively, you can view the same reference information at https://cli.github.com/manual/gh_codespace.
For more information, see Using GitHub Codespaces with GitHub CLI.\n\n\n\nCodespaces/Developing in a codespace/Create a codespace for a repoCreating a codespace for a repositoryYou can create a codespace for a branch in a repository to develop online.Tool navigationGitHub CLIVisual Studio CodeWeb browserIn this articleAbout creating a codespace for a repositoryCreating a codespace for a repositoryRecommended secretsFurther readingAbout creating a codespace for a repository
You can create a codespace on GitHub, in Visual Studio Code, or by using GitHub CLI. Use the tabs in this article to display instructions for each of these ways of creating a codespace.
You can use GitHub Codespaces on your personal GitHub account, with the quota of free use included each month for accounts on the Free and Pro plans. You can continue using GitHub Codespaces beyond your monthly included storage and compute usage by providing payment details and setting a spending limit. See About billing for GitHub Codespaces.
Organizations can enable members and outside collaborators to create and use codespaces at the organization's expense. For more information, see Choosing who owns and pays for codespaces in your organization.
Your ability to create codespaces from organization-owned repositories depends on several factors, including the repository's visibility and the settings of the organization or its parent enterprise. For more information, see Troubleshooting creation and deletion of codespaces.
If you're starting a new project, you might want to create a codespace from a template and publish to a repository on GitHub later. For more information, see Creating a codespace from a template.
If you create a codespace from a repository, the codespace will be associated with a specific branch, which cannot be empty. You can create more than one codespace per repository or even per branch.
You can see every available codespace that you have created on the "Your codespaces" page. To display this page, in the top-left corner of GitHub, select , then click  Codespaces. This takes you to github.com/codespaces.
The codespace creation process
When you create a codespace, a number of steps happen to create and connect you to your development environment:

Step 1: VM and storage are assigned to your codespace.
Step 2: Container is created and your repository is cloned.
Step 3: You can connect to the codespace.
Step 4: Codespace continues with post-creation setup.

For more information on what happens when you create a codespace, see Deep dive into GitHub Codespaces.
For more information on the lifecycle of a codespace, see Understanding the codespace lifecycle.
If you want to use Git hooks for your codespace, then you should set up hooks using the devcontainer.json lifecycle scripts, such as postCreateCommand. These get executed during step 4, above. For information about the lifecycle scripts, see the dev containers specification on the Development Containers website. Since the dev container for your codespace is created after the repository is cloned, any git template directory configured in the dev container image will not apply to your codespace. Hooks must instead be installed after the codespace is created.
You can edit code, debug, and use Git commands while developing in a codespace with VS Code. For more information, see the VS Code documentation.
To speed up codespace creation, repository administrators can enable GitHub Codespaces prebuilds for a repository. For more information, see About GitHub Codespaces prebuilds.
Creating a codespace for a repository



On GitHub, navigate to the main page of the repository.


Under the repository name, select the branch dropdown menu, which is labeled with the name of the current branch, then click the branch you want to create a codespace for.



Click the  Code button, then click the Codespaces tab.
A message is displayed at the bottom of the dialog telling you who will pay for the codespace.



Create your codespace, either using the default options, or after configuring advanced options:


Use the default options
To create a codespace using the default options, click . 


Configure advanced options
To configure advanced options for your codespace, such as a different machine type or a particular devcontainer.json file:


At the top right of the Codespaces tab, select  and click New with options.



On the options page for your codespace, choose your preferred options from the dropdown menus.

The options page may also display the names of one or more secrets that it's recommended you create in your Codespaces settings. For more information, see Recommended secrets.
Note


You can bookmark the options page to give you a quick way to create a codespace for this repository and branch.
The https://github.com/codespaces/new page provides a quick way to create a codespace for any repository and branch. You can get to this page quickly by typing codespace.new into your browser's address bar.
For more information about dev container configuration files, see Introduction to dev containers.
For more information about machine types, see Changing the machine type for your codespace.
Your choice of available machine types may be limited by a number of factors. These can include a policy configured for your organization, or a minimum machine type specification for your repository. For more information, see Restricting access to machine types and Setting a minimum specification for codespace machines.




Click Create codespace.






Recommended secrets
The names of user-defined secrets may be displayed on the advanced options page when you create a codespace. This will happen if recommended secrets have been specified in the dev container configuration you have selected. For more information, see Specifying recommended secrets for a repository.

Entering values for these development environment secrets, when you're prompted to do so, is recommended because it's likely your project will need values for these secrets. However, supplying values is not required for you to create a codespace. You can set these secrets within the codespace if you prefer.
If you enter a value for a recommended secret, the secret will be available in the new codespace. When you click Create codespace, the secret is also added to your personal settings for Codespaces, so you will not need to enter a value for the secret in future when you create a codespace for this repository.
If the name of a secret is shown with a checkbox that is unavailable for selection, and no input box, this is because you already have a secret of this name configured in your personal settings for Codespaces, and you have associated it with this repository. If you've created a secret of this name but have not associated it with this repository, the checkbox will be available to select and by doing so you can update your settings to add the association.
If you want to change the value of a preselected secret you can do so from your personal settings for Codespaces at github.com/settings/codespaces. For more information, see Managing your account-specific secrets for GitHub Codespaces.


After you connect your account on GitHub to the GitHub Codespaces extension, you can create a new codespace. For more information about the GitHub Codespaces extension, see the VS Code Marketplace.


In VS Code, in the Activity Bar, click the Remote Explorer icon.

Note

If the Remote Explorer is not displayed in the Activity Bar:

Access the Command Palette. For example, by pressing Shift+Command+P (Mac) / Ctrl+Shift+P (Windows/Linux).
Type: details.
Click Codespaces: Details.




Hover over the "Remote Explorer" side bar and click .



In the text box, type the name of the repository you want to develop in, then select it.

A message is displayed at the right side of subsequent prompts telling you who will pay for the codespace.



Click the branch you want to develop on.


If prompted to choose a dev container configuration file, choose a file from the list.


Click the machine type you want to use.
Note

Your choice of available machine types may be limited by a number of factors. These can include a policy configured for your organization, or a minimum machine type specification for your repository. For more information, see Restricting access to machine types and Setting a minimum specification for codespace machines.





Note

To learn more about GitHub CLI, see About GitHub CLI.

To create a new codespace, use the gh codespace create subcommand.
gh codespace create

You are prompted to choose a repository. A message is displayed telling you who will pay for the codespace. You are then prompted to choose a branch, a dev container configuration file (if more than one is available), and a machine type (if more than one is available).
Alternatively, you can use flags to specify some or all of the options:
gh codespace create -r OWNER/REPO -b BRANCH --devcontainer-path PATH -m MACHINE-TYPE

In this example, replace owner/repo with the repository identifier. Replace branch with the name of the branch, or the full SHA hash of the commit, that you want to be initially checked out in the codespace. If you use the -r flag without the b flag, the codespace is created from the default branch.
Replace path with the path to the dev container configuration file you want to use for the new codespace. If you omit this flag and more than one dev container file is available you will be prompted to choose one from a list. For more information about the dev container configuration file, see Introduction to dev containers.
Replace machine-type with a valid identifier for an available machine type. Identifiers are strings such as: basicLinux32gb and standardLinux32gb. The type of machines that are available depends on the repository, your personal account, and your location. If you enter an invalid or unavailable machine type, the available types are shown in the error message. If you omit this flag and more than one machine type is available you will be prompted to choose one from a list.
For full details of the options for this command, see the GitHub CLI manual.

Further reading

Opening an existing codespace
Facilitating quick creation and resumption of codespaces
REST API endpoints for Codespaces organizations\n\n\n\nCodespaces/Developing in a codespace/Create a codespace from a templateCreating a codespace from a templateIf you're starting a new project, you can create a codespace from a blank template or choose a template specially designed for the type of work you want to do.In this articleAbout templates for GitHub CodespacesCreating a codespace from a GitHub templateCreating a codespace from a template repositoryPublishing to a repository on GitHubFurther readingAbout templates for GitHub Codespaces
If you're starting a new project, you can get started with development work quickly by creating a codespace from a template. You'll be able to work on your project in a cloud-based development environment, save your files in the cloud, and publish your work to a new remote repository that you can share with others or clone to your local machine.
You can start from a blank template, choose from templates maintained by GitHub for popular technologies such as React or Jupyter Notebook, or launch a codespace from any template repository on GitHub.
With a blank template, you'll start with an empty directory, with access to cloud-based compute resources and the tools, languages, and runtime environments that come preinstalled with the default dev container image. With other templates, you'll get starter files for the technology you're working with, plus typically some extra files such as a README file, a .gitignore file, and dev container configuration files containing some custom environment configuration. For more information on dev containers and the default image, see Introduction to dev containers.
As an example, if you create a codespace from GitHub's React template, you'll arrive in a workspace containing template files for a simple application, such as index.js, app.js, and package.json. Shortly after the codespace opens, a development server will start up automatically, and you will be able to view the running application in a simple browser tab within the VS Code web client.

The files and configuration included in templates are defined in template repositories. The template repository is cloned into your codespace when you create the codespace. After that, the link is severed, and your codespace won't be linked to a remote repository until you publish to one.
Tip

To help people get started with your framework, library, or other project, you can set up a template repository for use with GitHub Codespaces. For more information, see Setting up a template repository for GitHub Codespaces.

Creating a codespace from a GitHub template
Templates maintained by GitHub, including the blank template, are available from the "Your codespaces" page.


In the top-left corner of GitHub, select , then click  Codespaces to take you to the "Your codespaces" page at github.com/codespaces.


To view the full list of templates, in the "Explore quick start templates" section, click See all.



Optionally, to view the template repository containing the files for a template, click the name of the template.



Under the name of the template you want to launch, click Use this template.


When you create a new codespace from a template, it is always opened in the Visual Studio Code web client. You can reopen an existing codespace in any supported editor. For more information, see Opening an existing codespace.
Creating a codespace from a template repository
You can create a codespace from any template repository, then publish your work to a new repository when you are ready. For more information on template repositories, see Creating a repository from a template.


On GitHub, navigate to the main page of the repository.


Click Use this template, then click Open in a codespace.

Note

If you're a maintainer of the template repository, and want to commit changes to the template repository itself, you should create a codespace from the  Code dropdown. For more information, see Creating a codespace for a repository.



When you create a new codespace from a template, it is always opened in the Visual Studio Code web client. You can reopen an existing codespace in any supported editor. For more information, see Opening an existing codespace.
Publishing to a repository on GitHub
When you work in a codespace created from a template, your work is saved on a virtual machine in the cloud, but it is not stored in a repository on GitHub.
You can save your files, close and stop your codespace, and come back to your work later. Typically, Git will come preinstalled, and the working directory will be automatically initialized as a Git repository unless you started from GitHub's blank template. This means you can immediately use Git for local source control, such as adding and committing files.
However, if you delete an unpublished codespace, or if it's automatically deleted by being left unused for the duration of the retention period, then your work will be deleted too. To persist your work, and to allow others to work on your project, you will need to publish your codespace to a repository on GitHub.
Note

If an unpublished codespace is currently billed to an organization, publishing the codespace transfers ownership and billing of the codespace to your personal account. See About billing for GitHub Codespaces.

Publishing from VS Code
If you're working in a codespace, you can publish it from the VS Code web client or desktop application.


In the Activity Bar, click the Source Control view.



To stage your changes, click + next to the file you've added or changed, or next to Changes if you've changed multiple files and you want to stage them all.

Note

If you start from GitHub's blank template, you will not see a list of changes unless you have already initialized your directory as a Git repository. To publish codespaces created from the blank template, click Publish to GitHub in the "Source Control" view, then skip to step 5.



To commit your staged changes, type a commit message describing the change you've made, then click Commit.



Click Publish Branch.



In the "Repository Name" dropdown, type a name for your new repository, then select Publish to GitHub private repository or Publish to GitHub public repository.

The owner of the new repository will be the GitHub account with which you created the codespace.


Optionally, in the pop-up that appears in the lower right corner of the editor, click Open on GitHub to view the new repository on GitHub.



When a codespace is published, you have access to a greater range of options to customize your GitHub Codespaces experience. For example, you can:

Change the machine type of your codespace to make sure you're using resources appropriate for the work you're doing (see Changing the machine type for your codespace).
Allow GitHub to automatically use GPG to sign commits you make in your codespace (see Managing GPG verification for GitHub Codespaces).
Share secrets with your codespace (see Managing your account-specific secrets for GitHub Codespaces).

Publishing from GitHub
You can publish an unpublished codespace from the "Your codespaces" page on GitHub. This is useful if you want to publish a codespace that you don't currently have open in your browser. If you do this, your work will be preserved in a repository, but there won't be a link between your existing codespace and the new repository. However, you can navigate to the new repository and create a codespace from there, and this codespace will be connected to the repository.


In the top-left corner of GitHub, select , then click  Codespaces to take you to the "Your codespaces" page at github.com/codespaces.


Next to the unpublished codespace, click the ellipsis (...), then select Publish to a new repository.



Choose a name for your new repository, set it as Public or Private, and click Create repository.



Optionally, to view the new repository, click See repository.


Further reading

Creating a codespace for a repository
Understanding the codespace lifecycle
Using source control in your codespace\n\n\n\nCodespaces/Developing in a codespace/Delete a codespaceDeleting a codespaceYou can delete a codespace you no longer need.Tool navigationGitHub CLIVisual Studio CodeWeb browserIn this articleOverviewWhy you should delete unused codespacesDeleting a codespaceBulk deleting codespacesDeleting codespaces in your organizationFurther readingOverview
GitHub Codespaces are automatically deleted after they have been stopped and have remained inactive for a defined number of days. The retention period for each codespace is set when the codespace is created and does not change. The default retention period is 30 days. See Configuring automatic deletion of your codespaces.
You can manually delete a codespace in a variety of ways:

In the terminal by using GitHub CLI
In Visual Studio Code
In your web browser

Use the tabs at the top of this article to display instructions for each of these ways of deleting a codespace.
Note

You can't delete a codespace from within JupyterLab.

Why you should delete unused codespaces
There are costs associated with storing codespaces. You should therefore delete any codespaces you no longer need. See About billing for GitHub Codespaces.
There are limits to the number of codespaces you can create, and the number of codespaces you can run at the same time. These limits vary based on a number of factors. If you reach the maximum number of codespaces and try to create another, a message is displayed telling you that you must remove an existing codespace before you can create a new one.
Deleting a codespace



In the top-left corner of GitHub, select , then click  Codespaces to take you to the "Your codespaces" page at github.com/codespaces.


To the right of the codespace you want to delete, click , then click  Delete.




Note

You may have prebuild codespaces that are consuming additional storage which are not displayed on this dashboard. To delete them, follow the steps for “Deleting a prebuild configuration.”


You can delete codespaces from within VS Code when you are not currently working in a codespace.


In VS Code, in the Activity Bar, click the Remote Explorer icon.

Note

If the Remote Explorer is not displayed in the Activity Bar:

Access the Command Palette. For example, by pressing Shift+Command+P (Mac) / Ctrl+Shift+P (Windows/Linux).
Type: details.
Click Codespaces: Details.




Under "GitHub Codespaces," right-click the codespace you want to delete.


Click Delete Codespace.




Note

To learn more about GitHub CLI, see About GitHub CLI.

To delete a codespace use the gh codespace delete subcommand and then choose a codespace from the list that's displayed.
gh codespace delete

If you have unsaved changes, you'll be prompted to confirm deletion. You can use the --force flag to force deletion, avoiding this prompt.
For more information about this command, see the GitHub CLI manual.

Bulk deleting codespaces

You can use GitHub CLI to delete several or all of your codespaces with a single command. For more information, click the "GitHub CLI" tab near the top of this page.


You can use GitHub CLI to delete several or all of your codespaces with a single command. For more information, click the "GitHub CLI" tab near the top of this page.


You can delete several or all of your codespaces with a single command, using gh codespace delete followed by one of these flags:
--all - Delete all of your codespaces.
--repo REPOSITORY - Delete all of your codespaces for this repository. Or use together with the --days flag to filter by age of the codespace.
--days NUMBER - Delete all of your codespaces that are older than the specified number of days. Can be used together with the --repo flag.
By default you are prompted to confirm deletion of any codespaces that contain unsaved changes. You can use the --force flag to skip this confirmation.
Example
Delete all of the codespaces for the octo-org/octo-repo repository that you created more than 7 days ago.
gh codespace delete --repo octo-org/octo-repo --days 7


Deleting codespaces in your organization
As an organization owner, you can use GitHub CLI to delete any codespace in your organization.

For more information, click the "GitHub CLI" tab near the top of this page.


For more information, click the "GitHub CLI" tab near the top of this page.




Enter one of these commands to display a list of codespaces.

gh codespace delete --org ORGANIZATION - Lists the current codespaces in the specified organization.
gh codespace delete --org ORGANIZATION --user USER - Lists only those codespaces created by the specified user.
You must be an owner of the specified organization.



In the list of codespaces, navigate to the codespace you want to delete.


To delete the selected codespace press Enter.
If the codespace contains unsaved changes you will be prompted to confirm deletion.



You can also use the REST API to delete codespaces for your organization. See REST API endpoints for Codespaces organizations.
Further reading

Understanding the codespace lifecycle
Configuring automatic deletion of your codespaces
Restricting the retention period for codespaces\n\n\n\nCodespaces/Developing in a codespace/Open an existing codespaceOpening an existing codespaceYou can reopen a codespace that you have closed or stopped and return to your work.Tool navigationGitHub CLIVisual Studio CodeWeb browserIn this articleResuming a codespace from a repository pageOpening an existing codespace from the "Your codespaces" pageLinking to an existing codespaceReopening an existing codespaceLinking to an existing codespaceReopening an existing codespaceFurther readingYou can reopen any of your active or stopped codespaces on GitHub, in Visual Studio Code, or by using GitHub CLI. You can't reopen a codespace that has been deleted. See Understanding the codespace lifecycle.
You can view all your codespaces on the "Your codespaces" page at github.com/codespaces. From this page, you can:

Open, stop, or delete your codespaces.
See who owns (and may be billed for) your codespaces: your personal account, or organizations you belong to. See About billing for GitHub Codespaces.
See the machine type, size, and status of your codespaces.
Create a new codespace, either by choosing one of GitHub's templates or by clicking New codespace. See Creating a codespace from a template and Creating a codespace for a repository.
Prevent automatic deletion of a codespace. See Configuring automatic deletion of your codespaces.


Resuming a codespace from a repository page
You can quickly resume a codespace when you're viewing a repository on GitHub.


With the  Code tab of your repository displayed on GitHub, press , (the comma key).
The "Resume codespace" page is displayed. This allows you to resume your most recently used codespace for the currently selected branch of the repository or, if you were viewing a pull request, for the topic branch of the pull request.



Click Resume this codespace.
Alternatively, if you want to create a new codespace for this branch of the repository, click Create a new one.
Note

If you don't have an existing codespace for this branch, the page is titled "Create codespace" and a button labeled Create a new codespace is displayed.



You can bookmark the address of this page if you want to get back to it quickly to resume your codespace. Alternatively you can use the address in a link to provide other people with a quick way of creating and resuming their own codespaces for this repository.
Opening an existing codespace from the "Your codespaces" page


In the top-left corner of GitHub, select , then click  Codespaces to take you to the "Your codespaces" page at github.com/codespaces.


To open a codespace in your default editor, click the name of the codespace. You can set your default editor for Codespaces in your personal settings page. See Setting your default editor for GitHub Codespaces.
To open the codespace in an editor other than your default:

Click the ellipsis (...) to the right of the codespace you want to open.
Click Open in.
Click Open in APPLICATION.

You can open the codespace in:

Your browser
Visual Studio Code
JupyterLab

If you choose Visual Studio Code, you must make sure you have VS Code installed on your local machine.
If you choose JupyterLab, the JupyterLab application must be installed in the codespace. The default dev container image includes JupyterLab, so codespaces created from the default image will always have JupyterLab installed. For more information about the default image, see Introduction to dev containers and the devcontainers/images repository. If you're not using the default image in your dev container configuration, you can install JupyterLab by adding the ghcr.io/devcontainers/features/python feature to your devcontainer.json file. You should include the option "installJupyterlab": true. For more information, see the README for the python feature, in the devcontainers/features repository.


Linking to an existing codespace
You can create links to your existing codespaces. This is useful if you have a long-lived codespace that you return to frequently. You can save the link in a location of your choice, as an alternative to using the link on https://github.com/codespaces.
Note

You can only open your own codespaces. If someone clicks a link to one of your codespaces they will see a 404 error message.

Create a link using one of the following URL patterns. In these URLs CODESPACE-NAME represents the unique, permanent name of the codespace, such as literate-space-parakeet-w5vg5ww5p793g7g9, not the codespace's display name. You can find the name of a codespace by copying the link to the codespace on your https://github.com/codespaces page and extracting the codespace name from the URL.

























Link opens inLink syntaxVS Code web clienthttps://CODESPACE-NAME.github.devVS Code web client with a specified workspacehttps://CODESPACE-NAME.github.dev?folder=/workspaces/PATH/TO/WORKSPACE/DIRECTORYVS Code desktop applicationhttps://github.com/codespaces/CODESPACE-NAME?editor=vscodeJupyterLabhttps://github.com/codespaces/CODESPACE-NAME?editor=jupyter


Reopening an existing codespace
Note

To use GitHub Codespaces in VS Code, you need to install the Codespaces extension. See Using GitHub Codespaces in Visual Studio Code.



In the VS Code desktop application, open the Command Palette with Command+Shift+P (Mac) or Ctrl+Shift+P (Windows/Linux).


Type "Codespaces" and select one of the following commands.

To open a codespace in a new window of VS Code, select Codespaces: Open Codespace in New Window
To open a codespace in the web editor, select Codespaces: Open in Browser



Click the codespace that you want to open.



You can also access the commands listed above by navigating to the Remote Explorer view in VS Code and right-clicking the codespace that you want to open.

Note

If the Remote Explorer is not displayed in the Activity Bar:

Access the Command Palette. For example, by pressing Shift+Command+P (Mac) / Ctrl+Shift+P (Windows/Linux).
Type: details.
Click Codespaces: Details.


Linking to an existing codespace
You can create links to your existing codespaces. This is useful if you have a long-lived codespace that you return to frequently. You can save the link in a location of your choice, as an alternative to using the link on https://github.com/codespaces.
Note

You can only open your own codespaces. If someone clicks a link to one of your codespaces they will see a 404 error message.

Create a link using one of the following URL patterns. In these URLs CODESPACE-NAME represents the unique, permanent name of the codespace, such as literate-space-parakeet-w5vg5ww5p793g7g9, not the codespace's display name. You can find the name of a codespace by copying the link to the codespace on your https://github.com/codespaces page and extracting the codespace name from the URL.

























Link opens inLink syntaxVS Code web clienthttps://CODESPACE-NAME.github.devVS Code web client with a specified workspacehttps://CODESPACE-NAME.github.dev?folder=/workspaces/PATH/TO/WORKSPACE/DIRECTORYVS Code desktop applicationhttps://github.com/codespaces/CODESPACE-NAME?editor=vscodeJupyterLabhttps://github.com/codespaces/CODESPACE-NAME?editor=jupyter


Reopening an existing codespace
If you have installed GitHub CLI, you can use it to work with GitHub Codespaces. For installation instructions for GitHub CLI, see the GitHub CLI repository.


In a terminal, enter one of the following GitHub CLI commands.


To open a codespace in VS Code, enter:
Shellgh codespace code
gh codespace code

Note

You must have VS Code installed on your local machine. See Setting up Visual Studio Code in the VS Code documentation.



To open a codespace in the browser, enter:
Shellgh codespace code --web
gh codespace code --web



To open a codespace in JupyterLab, enter:
Shellgh codespace jupyter
gh codespace jupyter

Note

The JupyterLab application must be installed in the codespace you are opening. The default dev container image includes JupyterLab, so codespaces created from the default image will always have JupyterLab installed. For more information about the default image, see Introduction to dev containers and the devcontainers/images repository. If you're not using the default image in your dev container configuration, you can install JupyterLab by adding the ghcr.io/devcontainers/features/python feature to your devcontainer.json file. You should include the option "installJupyterlab": true. For more information, see the README for the python feature, in the devcontainers/features repository.



To access a codespace from the command line, over SSH, enter:
Shellgh codespace ssh
gh codespace ssh





Using the arrow keys, navigate to the codespace that you want to open.


To open the codespace, press Enter.


See gh codespace code in the GitHub CLI manual.

Further reading

REST API endpoints for Codespaces organizations\n\n\n\nCodespaces/Developing in a codespace/Work collaborativelyWorking collaboratively in a codespaceYou can work collaboratively with other people in a codespace by using Visual Studio Live Share.In this articleSharing your codespace with someone elseStopping a Live Share sessionWorking collaboratively in someone else's codespaceVisual Studio Live Share lets you collaboratively edit and debug with others in real time, within a codespace. You can securely share your current codespace, or access a codespace created by someone else.
You can start a Live Share session either within the VS Code web client in your browser, or within the VS Code desktop application.
For more information about Live Share, see What is Visual Studio Live Share? in the Visual Studio documentation.
Sharing your codespace with someone else


In the Activity Bar, click the Extensions icon.


In the search box, type Live Share.



If the Install button is displayed beside the extension, click it to install the extension in the codespace.


If the extension is shown grayed out in the list, right-click it and click Enable.



In the Activity Bar, click the Live Share icon.



Click Share.
A "toast" notification message is displayed at the bottom right corner of VS Code, telling you that a link to your codespace has been copied to the clipboard. You can click Make read-only if you want to prevent guests from making changes to the files you share with them.



Send the link in your clipboard to anyone you want to join you in your Live Share session.
Important

Given the level of access Live Share sessions can provide to guests, you should only share with people you trust, and you should think through the implications of what you are sharing. For more information, see Security features of Live Share in the Visual Studio documentation.



Stopping a Live Share session
To stop sharing your codespace, click the stop icon in the Live Share panel.

If you, as the person who started the Live Share session, close the codespace the sharing session ends, even if the codespace remains active on the remote host.
The idle timeout, which automatically stops a codespace after a period of inactivity, only applies to the person who started the codespace. It does not apply to people who are working on the codespace via Live Share. The codespace may therefore time out while collaborators are using the codespace if the person who started the codespace remains inactive for the configured period of time. For more information, see Setting your timeout period for GitHub Codespaces.
Working collaboratively in someone else's codespace
If you want to work with someone within a codespace they've created, ask them to set up a Live Share session and send you a link, as described above.\n\n\n\nCodespaces/Developing in a codespace/Source controlUsing source control in your codespaceAfter making changes to a file in your codespace you can quickly commit the changes and push your update to the remote repository.Tool navigationVisual Studio CodeWeb browserIn this articleAbout source control in GitHub CodespacesAbout automatic forkingPublishing a codespace created from a templateCreating or switching branchesCommitting your changesPulling changes from the remote repositorySetting your codespace to automatically fetch new changesRaising a pull requestPushing changes to your remote repositoryPublishing a codespace created from a templateCreating or switching branchesCommitting your changesPulling changes from the remote repositorySetting your codespace to automatically fetch new changesRaising a pull requestPushing changes to your remote repositoryAbout source control in GitHub Codespaces
You can perform all the Git actions you need directly within your codespace. For example, you can fetch changes from a remote repository, switch branches, create a new branch, commit and push changes, and create a pull request. You can use the integrated terminal within your codespace to enter Git commands, or you can click icons and menu options to complete all the most common Git tasks. This guide explains how to use the graphical user interface for source control.

For more information about Git support in Visual Studio Code, see Using Version Control in VS Code in the Visual Studio Code documentation.


Source control in the Visual Studio Code web client uses the same workflow as the Visual Studio Code desktop application. For more information, see Using Version Control in VS Code in the Visual Studio Code documentation.

A typical workflow for updating a file using GitHub Codespaces would be:

From the default branch of your repository on GitHub, create a codespace. See Creating a codespace for a repository.
In your codespace, create a new branch to work on.
Make your changes and save them.
Commit the change.
Raise a pull request.

Note

By default, GitHub Codespaces uses the HTTPS protocol to transfer data to and from a remote repository, and authenticates with a GITHUB_TOKEN configured with read and write access to the repository from which you create the codespace. If you're having issues with authentication, see Troubleshooting authentication to a repository.

About automatic forking
To create a codespace for a repository for which you only have read access, you must have permission to fork the repository.
You do not need to fork the repository before you create the codespace. For example, you can create a codespace from the repository to look at the project and make experimental changes, then delete the codespace if you no longer need it.
If you make a commit from the codespace, or push a new branch, GitHub Codespaces either creates a fork of the repository under your account and links it to your codespace, or it links your codespace to an existing fork if you already have one for the repository. You can then push your changes to the fork and create a pull request to propose the changes to the upstream repository.
If you make a commit from the command line, you will see a prompt asking if you would like to proceed with linking your codespace to a new or existing fork. Enter y to proceed. If you commit changes from the Source Control view in VS Code, your codespace is automatically linked to a fork without you being prompted.
Note


If you delete your fork repository, then any codespaces linked to the fork are deleted, even if you originally created them from the upstream repository.
If you make a commit from the command line and refuse the new fork by entering n, you should push your changes from the command line rather than from VS Code's Source Control view. If you use the Source Control view, VS Code will still try to create a fork for you on push.


When GitHub Codespaces creates a fork, or links your codespace to an existing fork, the following things happen.

The access token associated with your codespace is updated to include read and write permission to your fork, in addition to read permission to the upstream repository.
In your Git settings, the upstream repository is reassigned to the name upstream, and the fork is added as a new remote repository under the name origin.

By default, source control commands that you access from your editor's user interface, such as the Sync Changes button in VS Code, target your fork. If you're working from the command line, you can use origin to refer to your fork and upstream to refer to the upstream repository. For example, you can fetch changes from the upstream repository to ensure your codespace is up to date with the latest changes to the project.
git fetch upstream

When you have made some changes, you can push them to a feature branch of your fork.
git push origin my-feature-branch

For more information, see About forks.

Publishing a codespace created from a template
When you create a codespace from a template repository or a template on the "Your codespaces" page, the work you do won't be stored in a repository on GitHub until you publish your codespace. For more information, see Creating a codespace from a template.
If you're working in a codespace, you can publish it from the VS Code web client or desktop application.


In the Activity Bar, click the Source Control view.



To stage your changes, click + next to the file you've added or changed, or next to Changes if you've changed multiple files and you want to stage them all.

Note

If you start from GitHub's blank template, you will not see a list of changes unless you have already initialized your directory as a Git repository. To publish codespaces created from the blank template, click Publish to GitHub in the "Source Control" view, then skip to step 5.



To commit your staged changes, type a commit message describing the change you've made, then click Commit.



Click Publish Branch.



In the "Repository Name" dropdown, type a name for your new repository, then select Publish to GitHub private repository or Publish to GitHub public repository.

The owner of the new repository will be the GitHub account with which you created the codespace.


Optionally, in the pop-up that appears in the lower right corner of the editor, click Open on GitHub to view the new repository on GitHub.



Creating or switching branches


If the current branch is not shown in the status bar, at the bottom of your codespace, right-click the status bar and select Source control.


Click the branch name in the status bar.



In the dropdown, either click the branch you want to switch to, or enter the name for a new branch and click Create new branch.



Tip

If someone has recently changed a file on the remote repository, in the branch you switched to, you may not see those changes until you pull the changes into your codespace.

Committing your changes


In the Activity Bar, click the Source Control view.



To stage your changes, click  next to the file you've changed, or next to Changes if you've changed multiple files and you want to stage them all.



In the text box, type a commit message describing the change you've made.



Click the down arrow at the right side of the Commit button, and select Commit & Push from the dropdown menu.



Pulling changes from the remote repository
You can pull changes from the remote repository into your codespace at any time.


In the Activity Bar, click the Source Control view.



At the top of the side bar, click .



In the dropdown menu, click Pull.


If the dev container configuration has been changed since you created the codespace, you can apply the changes by rebuilding the container for the codespace. For more information, see Introduction to dev containers.
Setting your codespace to automatically fetch new changes
You can set your codespace to automatically fetch details of any new commits that have been made to the remote repository. This allows you to see whether your local copy of the repository is out of date, in which case you may choose to pull in the new changes.
If the fetch operation detects new changes on the remote repository, you'll see the number of new commits in the status bar. You can then pull the changes into your local copy.


Click the Manage button at the bottom of the Activity Bar.



In the menu, click Settings.


On the Settings page, search for: autofetch.



To fetch details of updates for all remotes registered for the current repository, set Git: Autofetch to all.



If you want to change the number of seconds between each automatic fetch, edit the value of Git: Autofetch Period.


Raising a pull request


After you've committed changes to your local copy of the repository, click the pull request icon at the top of the "Source Control" side bar.



Check that the local branch and repository you're merging from, and the remote branch and repository you're merging into, are correct. Then give the pull request a title and a description.



Click Create.


Pushing changes to your remote repository
You can push changes you've saved and committed. This applies those changes to the upstream branch on the remote repository. You might want to do this if you're not yet ready to create a pull request, or if you prefer to create a pull request on GitHub.


At the top of the side bar, click .



In the dropdown menu, click Push.




Publishing a codespace created from a template
When you create a codespace from a template repository or a template on the "Your codespaces" page, the work you do won't be stored in a repository on GitHub until you publish your codespace. For more information, see Creating a codespace from a template.
If you're working in a codespace, you can publish it from the VS Code web client or desktop application.


In the Activity Bar, click the Source Control view.



To stage your changes, click + next to the file you've added or changed, or next to Changes if you've changed multiple files and you want to stage them all.

Note

If you start from GitHub's blank template, you will not see a list of changes unless you have already initialized your directory as a Git repository. To publish codespaces created from the blank template, click Publish to GitHub in the "Source Control" view, then skip to step 5.



To commit your staged changes, type a commit message describing the change you've made, then click Commit.



Click Publish Branch.



In the "Repository Name" dropdown, type a name for your new repository, then select Publish to GitHub private repository or Publish to GitHub public repository.

The owner of the new repository will be the GitHub account with which you created the codespace.


Optionally, in the pop-up that appears in the lower right corner of the editor, click Open on GitHub to view the new repository on GitHub.



Creating or switching branches


If the current branch is not shown in the status bar, at the bottom of your codespace, right-click the status bar and select Source control.


Click the branch name in the status bar.



In the dropdown, either click the branch you want to switch to, or enter the name for a new branch and click Create new branch.



Tip

If someone has recently changed a file on the remote repository, in the branch you switched to, you may not see those changes until you pull the changes into your codespace.

Committing your changes


In the Activity Bar, click the Source Control view.



To stage your changes, click  next to the file you've changed, or next to Changes if you've changed multiple files and you want to stage them all.



In the text box, type a commit message describing the change you've made.



Click the down arrow at the right side of the Commit button, and select Commit & Push from the dropdown menu.



Pulling changes from the remote repository
You can pull changes from the remote repository into your codespace at any time.


In the Activity Bar, click the Source Control view.



At the top of the side bar, click .



In the dropdown menu, click Pull.


If the dev container configuration has been changed since you created the codespace, you can apply the changes by rebuilding the container for the codespace. For more information, see Introduction to dev containers.
Setting your codespace to automatically fetch new changes
You can set your codespace to automatically fetch details of any new commits that have been made to the remote repository. This allows you to see whether your local copy of the repository is out of date, in which case you may choose to pull in the new changes.
If the fetch operation detects new changes on the remote repository, you'll see the number of new commits in the status bar. You can then pull the changes into your local copy.


Click the Manage button at the bottom of the Activity Bar.



In the menu, click Settings.


On the Settings page, search for: autofetch.



To fetch details of updates for all remotes registered for the current repository, set Git: Autofetch to all.



If you want to change the number of seconds between each automatic fetch, edit the value of Git: Autofetch Period.


Raising a pull request


After you've committed changes to your local copy of the repository, click the pull request icon at the top of the "Source Control" side bar.



Check that the local branch and repository you're merging from, and the remote branch and repository you're merging into, are correct. Then give the pull request a title and a description.



Click Create.


Pushing changes to your remote repository
You can push changes you've saved and committed. This applies those changes to the upstream branch on the remote repository. You might want to do this if you're not yet ready to create a pull request, or if you prefer to create a pull request on GitHub.


At the top of the side bar, click .



In the dropdown menu, click Push.\n\n\n\nCodespaces/Developing in a codespace/Pull requestsUsing GitHub Codespaces for pull requestsYou can use GitHub Codespaces in your web browser, or in Visual Studio Code to create pull requests, review pull requests, and address review comments.In this articleAbout pull requests in GitHub CodespacesOpening a pull request in CodespacesReviewing a pull request in CodespacesView comments from a review in CodespacesUsing a codespace to work on a pull request gives you all the benefits of GitHub Codespaces. For more information, see GitHub Codespaces features.
About pull requests in GitHub Codespaces
GitHub Codespaces provides you with many of the capabilities you might need to work with pull requests:

Create a pull request - Using either the Terminal and Git commands or the "Source Control" view, you can create pull requests just as you would on GitHub. If the repository uses a pull request template, you'll be able to use this within the "Source Control" view.
Open a pull request – You can open an existing pull request in a codespace, provided you have codespace access to the branch that is being merged in.
Review a pull request - Once you have opened a pull request in a codespace, you can use the "GitHub Pull Request" view to add review comments and approve pull requests. You can also use GitHub Codespaces to view review comments.

Opening a pull request in Codespaces


Under your repository name, click  Pull requests.



In the list of pull requests, click the pull request you'd like to open in Codespaces.


On the right-hand side of your screen, click  Code.


In the Codespaces tab, click .

A codespace is created for the pull request branch and is opened in your default editor for GitHub Codespaces.


Reviewing a pull request in Codespaces


With your default editor set to either Visual Studio Code or Visual Studio Code for Web, open the pull request in a codespace, as described in Opening a pull request in Codespaces previously in this article.


In the Activity Bar, click the Git pull request icon to display the "GitHub Pull Request" side bar. This icon is only displayed in the Activity Bar when you open a pull request in a codespace.

If you opened a pull request in a codespace and the pull request icon is not displayed in the Activity Bar, make sure you are signed in to GitHub. Click the GitHub icon in the Activity Bar then click Sign in.



To review the changes that have been made to a specific file, click the file's name in the "GitHub Pull Request" side bar.

This displays a diff view in the editor, with the version of the file from the base branch on the left, and the new version of the file, from the head branch of the pull request, on the right.


To add a review comment, click the + sign next to the line number in the file displayed on the right side of the editor.



Type your review comment and then click Start Review.



Optionally, you can suggest a change that the author of the pull request can click to commit if they agree with your suggestion. To do this, click and hold the + sign next to the first line you want to suggest changing, then drag the + sign to the last line you want to suggest changing. Then click Make a Suggestion in the comment box that's displayed.
The lines you selected are copied into the comment box, where you can edit them to suggest a change. You can add a comment above the line containing ```suggestion to explain your suggested change.
Click Add Comment to add your suggestion to the pull request.



When you are finished adding review comments, you can add a summary comment for your pull request review in the "GitHub Pull Request" side bar. You can then click Comment and Submit, or click the dropdown arrow and select Approve and Submit or Request Changes and Submit.



For more information on reviewing a pull request, see Reviewing proposed changes in a pull request.
View comments from a review in Codespaces
Once you have received feedback on a pull request, you can open it in a codespace in your web browser, or in VS Code, to see the review comments. From there you can respond to comments, add reactions, or dismiss the review.\n\n\n\nCodespaces/Developing in a codespace/Stop a codespaceStopping and starting a codespaceYou can stop and start your codespace to save resources and to pause work.Tool navigationGitHub CLIVisual Studio CodeWeb browserIn this articleAbout stopping and starting a codespaceStopping a codespaceRestarting a codespaceFurther readingAbout stopping and starting a codespace
You can stop a codespace at any time. When you stop a codespace, any running processes are stopped. Any saved changes in your codespace will still be available when you next start it. The terminal history is preserved, but the visible contents of the terminal window are not preserved between codespace sessions.
If you do not explicitly stop a codespace, it will continue to run until it times out from inactivity. Closing a codespace does not stop the codespace. For example, if you're using a codespace in the VS Code web client and you close the browser tab, the codespace remains running on the remote machine. For information about timeouts, see Understanding the codespace lifecycle.
Only running codespaces incur CPU charges. A stopped codespace incurs only storage costs.
You may want to stop and restart a codespace to apply changes to it. For example, if you change the machine type used for your codespace, you will need to stop and restart it for the change to take effect. You can also stop your codespace and choose to restart or delete it if you encounter an error or something unexpected.
Regardless of where you created or access your codespaces, you can view and manage them in your browser at https://github.com/codespaces.
Stopping a codespace


Navigate to the "Your Codespaces" page at https://github.com/codespaces.
To the right of the codespace you want to stop, click the ellipsis (...).
Click Stop codespace.




Note

To learn more about GitHub CLI, see About GitHub CLI.

To stop a codespace use the gh codespace stop subcommand and then choose the codespace you want to stop from the list that's displayed.
Shellgh codespace stop
gh codespace stop




Open the VS Code Command Palette (Shift+Command+P (Mac) / Ctrl+Shift+P (Windows/Linux)).
Type stop and select Codespaces: Stop Codespace from the list of options.
In the list of codespaces, select the codespace you want to stop.


Restarting a codespace



Navigate to the "Your Codespaces" page at https://github.com/codespaces.


Click the name of the codespace you want to restart.





When you restart a codespace you can choose to open it in Visual Studio Code or in your browser.


To restart a codespace and open it in Visual Studio Code, use the gh codespace code subcommand and then choose the codespace you want to restart from the list that's displayed.
Shellgh codespace code
gh codespace code



To restart a codespace and open it in your browser, use the gh codespace open --web subcommand and then choose the codespace you want to restart from the list that's displayed.
Shellgh codespace open --web
gh codespace open --web






Open the VS Code Command Palette (Shift+Command+P (Mac) / Ctrl+Shift+P (Windows/Linux)).
Type connect and select Codespaces: Connect to Codespace from the list of options.
In the list of codespaces, select the codespace you want to restart.


Further reading

Understanding the codespace lifecycle\n\n\n\nCodespaces/Developing in a codespace/Forward portsForwarding ports in your codespaceYou can forward ports in your codespace to test and debug your application. You can also manage the port protocol and share the port within your organization or publicly.Tool navigationGitHub CLIVisual Studio CodeWeb browserIn this articleAbout forwarded portsForwarding a portUsing HTTPS forwardingSharing a portUsing command-line tools and REST clients to access portsAutomatically forwarding a portLabeling a portForwarding a portSharing a portUsing command-line tools and REST clients to access portsAutomatically forwarding a portLabeling a portSharing a portUsing command-line tools and REST clients to access portsAutomatically forwarding a portLabeling a portAbout forwarded ports
Port forwarding gives you access to TCP ports running within your codespace. For example, if you're running a web application on a particular port in your codespace, you can forward that port. This allows you to access the application from the browser on your local machine for testing and debugging.

When an application running inside a codespace prints output to the terminal that contains a localhost URL, such as http://localhost:PORT or http://127.0.0.1:PORT, the port is automatically forwarded. If you're using GitHub Codespaces in the browser or in Visual Studio Code, the URL string in the terminal is converted into a link that you can click to view the web page on your local machine. By default, GitHub Codespaces forwards ports using HTTP.
You can edit the dev container configuration for the repository to automatically forward one or more ports. You can also forward a port manually, label forwarded ports, share forwarded ports with members of your organization, share forwarded ports publicly, and add forwarded ports to the codespace configuration.
Note

Organization owners can restrict the ability to make forward ports available publicly or within the organization. For more information, see Restricting the visibility of forwarded ports.

Forwarding a port
You can manually forward a port that wasn't forwarded automatically.


Open the terminal in your codespace.


Click the PORTS tab.


Under the list of ports, click Add port.



Type the port number or address, then press Enter.



Using HTTPS forwarding
By default, GitHub Codespaces forwards ports using HTTP but you can update any port to use HTTPS, as needed. If you update a port with public visibility to use HTTPS, the port's visibility will automatically change to private.


Open the terminal in your codespace.


Click the PORTS tab.


Right-click the port you want to update, then hover over Change Port Protocol.



Select the protocol needed for this port. The protocol that you select will be remembered for this port for the lifetime of the codespace.


Sharing a port
Note

You can only make a port private to an organization if your organization uses GitHub Team or GitHub Enterprise Cloud.

If you want to share a forwarded port with others, you can either make the port private to your organization or make the port public. After you make a port private to your organization, anyone in the organization with the port's URL can view the running application. After you make a port public, anyone who knows the URL and port number can view the running application without needing to authenticate.
Note

Your choice of port visibility options may be limited by a policy configured for your organization. For more information, see Restricting the visibility of forwarded ports.



Open the terminal in your codespace.


Click the PORTS tab.


Right-click the port that you want to share, click the Port Visibility, then click Private to Organization or Public.



To the right of the local address for the port, click the copy icon.



Send the copied URL to the person you want to share the port with.


Using command-line tools and REST clients to access ports
When you forward a port, your application becomes available at the URL https://CODESPACENAME-PORT.app.github.dev. For example, https://monalisa-hot-potato-vrpqrxxrx7x2rxx-4000.app.github.dev. If you forward a private port from the VS Code desktop application, your application will also be available at a localhost port such as 127.0.0.1:4000.
To access your application using a REST client, such as Postman, or a command-line tool like curl, you don't need to authenticate if you're using a localhost port, or if you're accessing a public port at the remote domain. However, to connect to a private port at the remote domain, you must authenticate by using the GITHUB_TOKEN access token in your request.
Note

The GITHUB_TOKEN is automatically created when you start a codespace and remains the same for the duration of the codespace session. If you stop and then restart a codespace a new GITHUB_TOKEN is generated.

Finding the address to connect to


Open the terminal in your codespace.


Click the PORTS tab. This lists all of the ports you have forwarded.


Right-click the port you want to connect to and click Copy Local Address.



Paste the copied address somewhere for later use.


Finding the GITHUB_TOKEN


In the terminal in your codespace, enter echo $GITHUB_TOKEN.
The token is a string beginning ghu_.


Copy the token.
Important

Don't share this access token with anyone.



Using curl to access a forwarded port
In a terminal on your local computer, enter:
curl ADDRESS -H "X-Github-Token: TOKEN"

Replace ADDRESS and TOKEN with the values you copied previously.
Using Postman to access a forwarded port


Open Postman.


Create a new GET request.


Paste the address you copied previously as the request URL.



In the Headers tab, create a new entry where the key is "X-Github-Token" and the value is the GITHUB_TOKEN you copied previously.



Click Send.


Automatically forwarding a port
You can add a forwarded port to the GitHub Codespaces configuration for the repository, so that the port will be automatically forwarded for all codespaces created from the repository. After you update the configuration, any previously created codespaces must be rebuilt for the change to apply. For more information about the dev container configuration file, see Introduction to dev containers.


In your codespace, open the dev container configuration file you want to update. Typically this file is .devcontainer/devcontainer.json.


Add the forwardPorts property.
"forwardPorts": [NUMBER],

Replace NUMBER with the port number you want to forward. This can be a comma-separated list of port numbers.


Save the file.


Labeling a port
When you open a codespace in the browser, or in the VS Code desktop application, you can label a forwarded port to make it easier to identify in a list.


Open the terminal in your codespace.


Click the PORTS tab.


Right-click the port you want to label, then click Set Port Label.



Type a label for your port, then press Enter.



Automatically labeling a forwarded port
You can label a port and write the change to a dev container configuration file for the repository. If you do this for a port that is automatically forwarded, using the forwardPorts property, then the label will be automatically applied to that forwarded port for all future codespaces created from the repository using that configuration file.


Open the terminal in your codespace.


Click the PORTS tab.


Right-click the port whose label attribute you want to add to the codespace configuration, then click Set Label and Update devcontainer.json.



Type a label for your port, then press Enter.



If your repository has more than one dev container configuration file, you will be prompted to choose which file you want to update.
The dev container configuration file is updated to include the new label in the portsAttributes property. For example:
// Use 'forwardPorts' to make a list of ports inside the container available locally.
"forwardPorts": [3333, 4444],

"portsAttributes": {
  "3333": {
    "label": "app-standard-preview"
  },
  "4444": {
    "label": "app-pro-preview"
  }
}





When an application running inside a codespace prints output to the terminal that contains a localhost URL, such as http://localhost:PORT or http://127.0.0.1:PORT, the port is automatically forwarded. If you're using GitHub Codespaces in the browser or in Visual Studio Code, the URL string in the terminal is converted into a link that you can click to view the web page on your local machine. By default, GitHub Codespaces forwards ports using HTTP.
You can edit the dev container configuration for the repository to automatically forward one or more ports. You can also forward a port manually, label forwarded ports, share forwarded ports with members of your organization, share forwarded ports publicly, and add forwarded ports to the codespace configuration.
Note

Organization owners can restrict the ability to make forward ports available publicly or within the organization. For more information, see Restricting the visibility of forwarded ports.

Forwarding a port
You can manually forward a port that wasn't forwarded automatically.


Open the terminal in your codespace.


Click the PORTS tab.


Under the list of ports, click Add port.



Type the port number or address, then press Enter.



Sharing a port
Note

You can only make a port private to an organization if your organization uses GitHub Team or GitHub Enterprise Cloud.

If you want to share a forwarded port with others, you can either make the port private to your organization or make the port public. After you make a port private to your organization, anyone in the organization with the port's URL can view the running application. After you make a port public, anyone who knows the URL and port number can view the running application without needing to authenticate.
Note

Your choice of port visibility options may be limited by a policy configured for your organization. For more information, see Restricting the visibility of forwarded ports.



Open the terminal in your codespace.


Click the PORTS tab.


Right-click the port that you want to share, click Port Visibility, then click Private to Organization or Public.



To the right of the local address for the port, click the copy icon.



Send the copied URL to the person you want to share the port with.


Using command-line tools and REST clients to access ports
When you forward a port, your application becomes available at the URL https://CODESPACENAME-PORT.app.github.dev. For example, https://monalisa-hot-potato-vrpqrxxrx7x2rxx-4000.app.github.dev. If you forward a private port from the VS Code desktop application, your application will also be available at a localhost port such as 127.0.0.1:4000.
To access your application using a REST client, such as Postman, or a command-line tool like curl, you don't need to authenticate if you're using a localhost port, or if you're accessing a public port at the remote domain. However, to connect to a private port at the remote domain, you must authenticate by using the GITHUB_TOKEN access token in your request.
Note

The GITHUB_TOKEN is automatically created when you start a codespace and remains the same for the duration of the codespace session. If you stop and then restart a codespace a new GITHUB_TOKEN is generated.

Finding the address to connect to


Open the terminal in your codespace.


Click the PORTS tab. This lists all of the ports you have forwarded.


Right-click the port you want to connect to and click Copy Local Address.



Paste the copied address somewhere for later use.


Finding the GITHUB_TOKEN


In the terminal in your codespace, enter echo $GITHUB_TOKEN.
The token is a string beginning ghu_.


Copy the token.
Important

Don't share this access token with anyone.



Using curl to access a forwarded port
In a terminal on your local computer, enter:
curl ADDRESS -H "X-Github-Token: TOKEN"

Replace ADDRESS and TOKEN with the values you copied previously.
Using Postman to access a forwarded port


Open Postman.


Create a new GET request.


Paste the address you copied previously as the request URL.



In the Headers tab, create a new entry where the key is "X-Github-Token" and the value is the GITHUB_TOKEN you copied previously.



Click Send.


Automatically forwarding a port
You can add a forwarded port to the GitHub Codespaces configuration for the repository, so that the port will be automatically forwarded for all codespaces created from the repository. After you update the configuration, any previously created codespaces must be rebuilt for the change to apply. For more information about the dev container configuration file, see Introduction to dev containers.


In your codespace, open the dev container configuration file you want to update. Typically this file is .devcontainer/devcontainer.json.


Add the forwardPorts property.
"forwardPorts": [NUMBER],

Replace NUMBER with the port number you want to forward. This can be a comma-separated list of port numbers.


Save the file.


Labeling a port
When you open a codespace in the browser, or in the VS Code desktop application, you can label a forwarded port to make it easier to identify in a list.


Open the terminal in your codespace.


Click the PORTS tab.


Right-click the port you want to label, then click Set Port Label.



Type a label for your port, then press Enter.



Automatically labeling a forwarded port
You can label a port and write the change to a dev container configuration file for the repository. If you do this for a port that is automatically forwarded, using the forwardPorts property, then the label will be automatically applied to that forwarded port for all future codespaces created from the repository using that configuration file.


Open the terminal in your codespace.


Click the PORTS tab.


Right-click the port whose label attribute you want to add to the codespace configuration, then click Set Label and Update devcontainer.json.



Type a label for your port, then press Enter.



If your repository has more than one dev container configuration file, you will be prompted to choose which file you want to update.
The dev container configuration file is updated to include the new label in the portsAttributes property. For example:
// Use 'forwardPorts' to make a list of ports inside the container available locally.
"forwardPorts": [3333, 4444],

"portsAttributes": {
  "3333": {
    "label": "app-standard-preview"
  },
  "4444": {
    "label": "app-pro-preview"
  }
}





Note

To learn more about GitHub CLI, see About GitHub CLI.

To forward a port use the gh codespace ports forward subcommand. Replace codespace-port:local-port with the remote and local ports that you want to connect. After entering the command choose from the list of codespaces that's displayed.
gh codespace ports forward CODESPACE-PORT:LOCAL-PORT

For more information about this command, see the GitHub CLI manual.
To see details of forwarded ports enter gh codespace ports and then choose a codespace.
Sharing a port
Note

You can only make a port private to an organization if your organization uses GitHub Team or GitHub Enterprise Cloud.

If you want to share a forwarded port with others, you can either make the port private to your organization or make the port public. After you make a port private to your organization, anyone in the organization with the port's URL can view the running application. After you make a port public, anyone who knows the URL and port number can view the running application without needing to authenticate.
Note

Your choice of port visibility options may be limited by a policy configured for your organization. For more information, see Restricting the visibility of forwarded ports.

To change the visibility of a forwarded port, use the gh codespace ports visibility subcommand. There are three visibility settings:

private - Visible only to you. This is the default setting when you forward a port.
org - Visible to members of the organization that owns the repository.
public - Visible to anyone who knows the URL and port number.

Replace codespace-port with the forwarded port number. Replace setting with private, org, or public. After entering the command choose from the list of codespaces that's displayed.
gh codespace ports visibility CODESPACE-PORT:SETTINGS

You can set the visibility for multiple ports with one command. For example:
gh codespace ports visibility 80:private 3000:public 3306:org

For more information about this command, see the GitHub CLI manual.
Using command-line tools and REST clients to access ports
When you forward a port, your application becomes available at the URL https://CODESPACENAME-PORT.app.github.dev. For example, https://monalisa-hot-potato-vrpqrxxrx7x2rxx-4000.app.github.dev. If you forward a private port from the VS Code desktop application, your application will also be available at a localhost port such as 127.0.0.1:4000.
To access your application using a REST client, such as Postman, or a command-line tool like curl, you don't need to authenticate if you're using a localhost port, or if you're accessing a public port at the remote domain. However, to connect to a private port at the remote domain, you must authenticate by using the GITHUB_TOKEN access token in your request.
Note

The GITHUB_TOKEN is automatically created when you start a codespace and remains the same for the duration of the codespace session. If you stop and then restart a codespace a new GITHUB_TOKEN is generated.

Finding the address to connect to
To find the address for a forwarded port, enter gh codespace ports. If you have more than one codespace, select the appropriate codespace from the list that's displayed.
Copy the address and paste it somewhere for later use.
Finding the GITHUB_TOKEN


Start an SSH session for your codespace.
gh codespace ssh



If you have more than one codespace, select the appropriate codespace from the list that's displayed.


Display the GITHUB_TOKEN.
echo $GITHUB_TOKEN

The token is a string beginning ghu_.


Copy the token.
Important

Don't share this access token with anyone.



Exit the SSH session.
exit



Using curl to access a forwarded port
In a terminal on your local computer, enter:
curl ADDRESS -H "X-Github-Token: TOKEN"

Replace ADDRESS and TOKEN with the values you copied previously.
Using Postman to access a forwarded port


Open Postman.


Create a new GET request.


Paste the address you copied previously as the request URL.



In the Headers tab, create a new entry where the key is "X-Github-Token" and the value is the GITHUB_TOKEN you copied previously.



Click Send.


Automatically forwarding a port
You can add a forwarded port to the GitHub Codespaces configuration for the repository, so that the port will be automatically forwarded for all codespaces created from the repository. After you update the configuration, any previously created codespaces must be rebuilt for the change to apply. For more information about the dev container configuration file, see Introduction to dev containers.


In your codespace, open the dev container configuration file you want to update. Typically this file is .devcontainer/devcontainer.json.


Add the forwardPorts property.
"forwardPorts": [NUMBER],

Replace NUMBER with the port number you want to forward. This can be a comma-separated list of port numbers.


Save the file.


Labeling a port
When you open a codespace in the browser, or in the VS Code desktop application, you can label a forwarded port to make it easier to identify in a list.


Open the terminal in your codespace.


Click the PORTS tab.


Right-click the port you want to label, then click Set Port Label.



Type a label for your port, then press Enter.



Automatically labeling a forwarded port
You can label a port and write the change to a dev container configuration file for the repository. If you do this for a port that is automatically forwarded, using the forwardPorts property, then the label will be automatically applied to that forwarded port for all future codespaces created from the repository using that configuration file.


Open the terminal in your codespace.


Click the PORTS tab.


Right-click the port whose label attribute you want to add to the codespace configuration, then click Set Label and Update devcontainer.json.



Type a label for your port, then press Enter.



If your repository has more than one dev container configuration file, you will be prompted to choose which file you want to update.
The dev container configuration file is updated to include the new label in the portsAttributes property. For example:
// Use 'forwardPorts' to make a list of ports inside the container available locally.
"forwardPorts": [3333, 4444],

"portsAttributes": {
  "3333": {
    "label": "app-standard-preview"
  },
  "4444": {
    "label": "app-pro-preview"
  }
}



Seeing port labels on the command line
You can see the port labels when you list the forwarded ports for a codespace. To do this, use the gh codespace ports command and then select a codespace.\n\n\n\nCodespaces/Developing in a codespace/Rebuilding a containerRebuilding the container in a codespaceYou can rebuild the dev container of a codespace you are working in to apply configuration changes. From time to time, you may want to perform a full rebuild.In this articleAbout rebuilding the dev containerRebuilding a containerPersisting data over a rebuildFurther readingAbout rebuilding the dev container
When you work in a codespace, your development environment is a Docker container that runs on a virtual machine. If you make changes to your dev container configuration from within a codespace, and you want to apply those changes to the current codespace, you need to rebuild the container.
By default, when you rebuild the dev container, GitHub Codespaces will speed up the build process by reusing cached images from previous builds of the container. This is usually the quickest way to implement changes to your dev container configuration, for the following reasons.

GitHub Codespaces can reuse images in your cache rather than repulling them from container registries.
The parts of your dev container configuration that define how the container is built, such as dev container features and Dockerfile instructions, may have already been implemented in image layers in your cache, so you won't need to wait for these processes to run again. (However, commands in your configuration that run after the container is built, such as onCreateCommand, will run again.)

Occasionally, you may want to perform a full rebuild of your container. With a full rebuild, GitHub Codespaces cleans all Docker containers, images, and volumes from the cache, then rebuilds your container with newly pulled images. All the setup defined in your configuration will run again, generating new image layers. You may want to perform a full rebuild after many iterations of rebuilding your container with cached images, in situations such as the following.

You want to ensure that the setup defined in your configuration is not dependent on cached images, and will run as required when someone creates a new codespace based on the configuration. For example, a dependency may have been removed from the base image since it was last pulled into your codespace.
You want to free up the disk space used by your cache, for example if you are low on disk space or want to minimize storage charges. Your image cache might be using a significant amount of disk space if you've changed your base image multiple times, if you've made a large number of iterative changes to your configuration, or if you're running multiple containers with Docker Compose.

Rebuilding a container
You can rebuild a container within a codespace in the VS Code web client or desktop application, or you can use GitHub CLI.
Rebuilding the dev container in the VS Code web client or desktop application


Access the VS Code Command Palette with Shift+Command+P (Mac) or Ctrl+Shift+P (Windows/Linux).


Start typing "Rebuild" and select Codespaces: Rebuild Container.



Select Rebuild or Full Rebuild in the confirmation dialog which opens.


If changes to your dev container configuration cause a container error, your codespace will run in recovery mode, and you will see an error message.


To diagnose the error by reviewing the creation logs, click View creation log.
To fix the errors identified in the logs, update your devcontainer.json file.
To apply the changes, rebuild your container.



Using GitHub CLI to rebuild a dev container
If you've changed a dev container configuration outside of VS Code (for example, on GitHub), you can use GitHub CLI to rebuild the dev container for an existing codespace.


In a terminal, enter the following command.
gh codespace rebuild

Your codespaces are listed.


Use the arrow keys on your keyboard to highlight the required codespace, then press Enter.


To perform a full rebuild with GitHub CLI, you can use the gh codespace rebuild --full command.
Persisting data over a rebuild
When you create a codespace, your repository is cloned into the /workspaces directory in your codespace. This is a persistent directory that is mounted into the container. Any changes you make inside this directory, including editing, adding, or deleting files, are preserved when you stop and start the codespace, and when you rebuild the container in the codespace.
Outside the /workspaces directory, your codespace contains a Linux directory structure that varies depending on the dev container image used to build your codespace. You can add files or make changes to files outside the /workspaces directory. For example, you can install new programs, or you can set up your shell configuration in a file such as ~/.bashrc. As a non-root user, you may not automatically have write access to certain directories, but most images allow root access to these directories with the sudo command.
Outside /workspaces, with the exception of the /tmp directory, the directories in a codespace are tied to the lifecycle of the container. This means any changes you make are preserved when you stop and start your codespace, but are not preserved when you rebuild the container.
If you want to preserve files outside the /workspaces directory over a rebuild, you can create, at the desired location in the container, a symbolic link (symlink) to the persistent directory. For example, in your /workspaces/.devcontainer directory, you can create a config directory that will be preserved across a rebuild. You can then symlink the config directory and its contents as a postCreateCommand in your devcontainer.json file.
{
    "image": "mcr.microsoft.com/devcontainers/base:alpine",
    "postCreateCommand": "chmod +x .devcontainer/postCreate.sh && .devcontainer/postCreate.sh"
}

In the example postCreate.sh file below, the contents of the config directory are symbolically linked to the home directory.
#!/bin/bash
ln -sf $PWD/.devcontainer/config $HOME/config && set +x

Further reading

Introduction to dev containers\n\n\n\nCodespaces/Developing in a codespace/Default environment variablesDefault environment variables for your codespaceGitHub sets default environment variables for each codespace.In this articleAbout default environment variablesList of default environment variablesAbout default environment variables
GitHub sets default environment variables for every codespace. Commands run in codespaces can create, read, and modify environment variables.
Note

Environment variables are case-sensitive.

List of default environment variables





















































Environment variableDescriptionCODESPACE_NAMEThe name of the codespace For example, octocat-literate-space-parakeet-mld5CODESPACESAlways true while in a codespaceGIT_COMMITTER_EMAILThe email for the "author" field of future git commits.GIT_COMMITTER_NAMEThe name for the "committer" field of future git commits.GITHUB_CODESPACES_PORT_FORWARDING_DOMAINReturns the domain of the GitHub Codespaces forwarded port. For example, app.github.dev.GITHUB_API_URLReturns the API URL. For example, https://api.github.com.GITHUB_GRAPHQL_URLReturns the GraphQL API URL. For example, https://api.github.com/graphql.GITHUB_REPOSITORYThe owner and repository name. For example, octocat/Hello-World.GITHUB_SERVER_URLReturns the URL of the GitHub server. For example, https://github.com.GITHUB_TOKENA signed auth token representing the user in the codespace. You can use this to make authenticated calls to the GitHub API. For more information, see Security in GitHub Codespaces.GITHUB_USERThe name of the user that initiated the codespace. For example, octocat.\n\n\n\nCodespaces/Developing in a codespace/Persist variables and filesPersisting environment variables and temporary filesYou can configure custom environment variables so that they are set to the same value every time you open a codespace. You can also ensure that temporary files are not deleted when a codespace stops.In this articleSetting persistent environment variablesPreventing temporary files from being automatically deletedFurther readingSetting persistent environment variables
You can set persistent custom environment variables in multiple ways, depending on which codespaces, repositories, or users you want the variables to be available to.
For all the methods of setting custom variables listed below, you can access the custom variable in your codespace by using syntax like echo $VARNAME.
For a single codespace
You can set the value of the environment variable in the ~/.bashrc file, or in an equivalent configuration file if you are not using the Bash shell. For example, add the statement VARNAME=value.
After you save the change to this file, the value will be set the next time you open the codespace, or you can set it immediately by using a command such as source ~/.bashrc. The variable will remain set if you stop and start the codespace. However, changes to files in the home directory will be reset if you rebuild the container, so variables set in the ~/.bashrc file will not persist over a rebuild. For more information, see Preventing temporary files from being automatically deleted.
For all codespaces for a repository
There are three ways that you can set persistent custom environment variables for all codespaces that you create for a repository:

You can edit the devcontainer.json configuration file for the repository.
You can use a custom Dockerfile.
You can use development environment secrets.

Edit the devcontainer.json configuration file for the repository
Edit the devcontainer.json configuration file for the repository, and use the remoteEnv property to set the environment variable value:
{
  "remoteEnv": {
    "VARNAME": "value"
  }
}

Only use this method for values that you are happy to commit to your repository as plaintext. For sensitive values such as access tokens, use development environment secrets.
The environment variable will be set within your editor's remote server process, and will be available for sub-processes of that remote server process, such as terminals and debugging sessions. However, the variable will not be available more broadly inside the container. This method is useful if you don't need the environment variable to be set for other background processes that run at startup, and if you are using a premade image and don't have or want a custom Dockerfile.
This setting will take effect when you rebuild your container or create a new codespace after pushing this change to the repository. For more information about applying configuration changes to a codespace, see Introduction to dev containers.
Use a custom Dockerfile
If you are using a custom Dockerfile you can set the environment variable there by adding ENV VARNAME=value.
This method is useful if you already have a Dockerfile and want to set a variable on a container-wide level.
This setting will take effect when you rebuild your container or create a new codespace after pushing this change to the repository. For more information about applying configuration changes to a codespace, see Introduction to dev containers.
Use development environment secrets
You can use development environment secrets for GitHub Codespaces to set custom variables for codespaces created for the repository. For more information, see Managing your account-specific secrets for GitHub Codespaces.
You should use this method for environment variable values that you do not want to commit to the repository as plaintext.
This setting will take effect the next time you create a codespace for this repository, or when you restart an existing codespace.
For all codespaces that you create
If you want to set a personalized environment variable for all codespaces that you create you can set this using a file in your dotfiles repository. For example, add VARNAME=value in the .bash_profile file. Environment variables you set in a dotfile are personal to you and are not set for anyone else. For more information about Dotfiles, see Personalizing GitHub Codespaces for your account.
Preventing temporary files from being automatically deleted
When you create a codespace, your repository is cloned into the /workspaces directory in your codespace. This is a persistent directory that is mounted into the container. Any changes you make inside this directory, including editing, adding, or deleting files, are preserved when you stop and start the codespace, and when you rebuild the container in the codespace.
Outside the /workspaces directory, your codespace contains a Linux directory structure that varies depending on the dev container image used to build your codespace. You can add files or make changes to files outside the /workspaces directory. For example, you can install new programs, or you can set up your shell configuration in a file such as ~/.bashrc. As a non-root user, you may not automatically have write access to certain directories, but most images allow root access to these directories with the sudo command.
Outside /workspaces, with the exception of the /tmp directory, the directories in a codespace are tied to the lifecycle of the container. This means any changes you make are preserved when you stop and start your codespace, but are not preserved when you rebuild the container. For information about creating symlinks to preserve data outside the /workspaces directory, see Rebuilding the container in a codespace.
The /tmp directory is an exception because it is mounted into the container, but it is not persistent. Therefore, the contents of the /tmp directory are persisted over a rebuild, but are cleared each time the codespace stops. For example, the /tmp directory is cleared when a codespace session times out after a period of inactivity. For more information, see Setting your timeout period for GitHub Codespaces.
If you have temporary files that you want to be available the next time you start the codespace, do not save them in the /tmp directory.
Further reading

Changing the shell in a codespace\n\n\n\nCodespaces/Developing in a codespace/Connecting to a private networkConnecting to a private networkYou can connect GitHub Codespaces to resources on a private network, including package registries, license servers, and on-premises databases.In this articleAbout codespace networkingConnecting to resources on a private networkRestricting access to the public internetAbout codespace networking
By default, your codespaces have access to all resources on the public internet, including package managers, license servers, databases, and cloud platform APIs, but they have no access to resources on private networks.
Connecting to resources on a private network
There are currently two methods of accessing resources on a private network within GitHub Codespaces.

Using a GitHub CLI extension to configure your local machine as a gateway to remote resources
Using a VPN

Using the GitHub CLI extension to access remote resources
Warning

The GitHub CLI extension is closing down and is no longer supported.

The GitHub CLI extension allows you to create a bridge between a codespace and your local machine, so that the codespace can access any remote resource that is accessible from your machine. The codespace uses your local machine as a network gateway to reach those resources. For more information, see Using GitHub CLI to access remote resources.
Using a VPN to access resources behind a private network
As an alternative to the GitHub CLI extension, you can use a VPN to access resources behind a private network from within your codespace.
We recommend VPN tools like OpenVPN to access resources on a private network. For more information, see Using the OpenVPN client from GitHub Codespaces.
There are also a number of third party solutions that, while not explicitly endorsed by GitHub, have provided examples of how to integrate with GitHub Codespaces.
These third party solutions include:

Tailscale

Allowlisting private resources for codespaces
While GitHub publishes IP ranges for several products on its Meta API, IP addresses for codespaces are dynamically assigned, meaning your codespace is not guaranteed to have the same IP address day to day. For more information, see REST API endpoints for meta data.
Allowlisting an entire IP range would give overly broad access to all codespaces (including users not affiliated with your codespaces), so for this reason codespace creation is disabled if you enable IP allow lists. For more information, see Managing allowed IP addresses for your organization.
Restricting access to the public internet
At present, there is no way to restrict codespaces from accessing the public internet, or to restrict appropriately authenticated users from accessing a forwarded port.
For more information on how to secure your codespaces, see Security in GitHub Codespaces.\n\n\n\nCodespaces/Developing in a codespace/Machine learningGetting started with GitHub Codespaces for machine learningLearn about working on machine learning projects with GitHub Codespaces and its out-of-the-box tools.In this articleIntroductionBuilding a simple image classifierOpening your codespace in JupyterLabConfiguring NVIDIA CUDA for your codespaceIntroduction
This guide introduces you to machine learning with GitHub Codespaces. You’ll build a simple image classifier, learn about some of the tools that come preinstalled in GitHub Codespaces, and find out how to open your codespace in JupyterLab.
Building a simple image classifier
We'll use a Jupyter notebook to build a simple image classifier.
Jupyter notebooks are sets of cells that you can execute one after another. The notebook we'll use includes a number of cells that build an image classifier using PyTorch. Each cell is a different phase of that process: download a dataset, set up a neural network, train a model, and then test that model.
We'll run all of the cells, in sequence, to perform all phases of building the image classifier. When we do this Jupyter saves the output back into the notebook so that you can examine the results.
Creating a codespace


Go to the github/codespaces-jupyter template repository.


Click Use this template, then click Open in a codespace.



A codespace for this template will open in a web-based version of Visual Studio Code.
Opening the image classifier notebook
The default container image that's used by GitHub Codespaces includes a set of machine learning libraries that are preinstalled in your codespace. For example, Numpy, pandas, SciPy, Matplotlib, seaborn, scikit-learn, Keras, PyTorch, Requests, and Plotly. For more information about the default image, see Introduction to dev containers and the devcontainers/images repository.

In the VS Code editor, close any "Get Started" tabs that are displayed.
Open the notebooks/image-classifier.ipynb notebook file.

Building the image classifier
The image classifier notebook contains all the code you need to download a dataset, train a neural network, and evaluate its performance.


Click Run All to execute all of the notebook’s cells.



If you are prompted to choose a kernel source, select Python Environments, then select the version of Python at the recommended location.



Scroll down to view the output of each cell.



Opening your codespace in JupyterLab
You can open your codespace in JupyterLab from the "Your codespaces" page at github.com/codespaces, or by using GitHub CLI. For more information, see Opening an existing codespace.
The JupyterLab application must be installed in the codespace you are opening. The default dev container image includes JupyterLab, so codespaces created from the default image will always have JupyterLab installed. For more information about the default image, see Introduction to dev containers and the devcontainers/images repository. If you're not using the default image in your dev container configuration, you can install JupyterLab by adding the ghcr.io/devcontainers/features/python feature to your devcontainer.json file. You should include the option "installJupyterlab": true. For more information, see the README for the python feature, in the devcontainers/features repository.
Configuring NVIDIA CUDA for your codespace
Note

This section only applies to customers who can create codespaces on machines that use a GPU. The ability to choose a machine type that uses a GPU was offered to selected customers during a trial period. This option is not generally available.

Some software requires you to install NVIDIA CUDA to use your codespace’s GPU. Where this is the case, you can create your own custom configuration, by using a devcontainer.json file, and specify that CUDA should be installed. For more information on creating a custom configuration, see Introduction to dev containers.
For full details of the script that's run when you add the nvidia-cuda feature, see the devcontainers/features repository.


Within the codespace, open the .devcontainer/devcontainer.json file in the editor.


Add a top-level features object with the following contents:
JSON  "features": {
    "ghcr.io/devcontainers/features/nvidia-cuda:1": {
      "installCudnn": true
    }
  }
  "features": {
    "ghcr.io/devcontainers/features/nvidia-cuda:1": {
      "installCudnn": true
    }
  }

For more information about the features object, see the development containers specification.
If you are using the devcontainer.json file from the image classifier repository you created for this tutorial, your devcontainer.json file will now look like this:
{
  "customizations": {
    "vscode": {
      "extensions": [
        "ms-python.python",
        "ms-toolsai.jupyter"
      ]
    }
  },
  "features": {
    "ghcr.io/devcontainers/features/nvidia-cuda:1": {
      "installCudnn": true
    }
  }
}



Save the change.


Access the VS Code Command Palette (Shift+Command+P / Ctrl+Shift+P), then start typing "rebuild". Click Codespaces: Rebuild Container.

Tip

You may occasionally want to perform a full rebuild to clear your cache and rebuild your container with fresh images. For more information, see Rebuilding the container in a codespace.
The codespace container will be rebuilt. This will take several minutes. When the rebuild is complete the codespace is automatically reopened.



Publish your change to a repository so that CUDA will be installed in any new codespaces you create from this repository in future. For more information, see Creating a codespace from a template.\n\n\n\nCodespaces/Developing in a codespace/Visual Studio CodeUsing GitHub Codespaces in Visual Studio CodeYou can develop in your codespace directly in Visual Studio Code by connecting the GitHub Codespaces extension with your GitHub account.In this articleAbout GitHub Codespaces in Visual Studio CodePrerequisitesCreating a codespace in VS CodeOpening a codespace in VS CodeChanging the machine type in VS CodeDeleting a codespace in VS CodeSwitching to VS Code Insiders in the web clientUsing the Insiders desktop application for CodespacesFurther readingAbout GitHub Codespaces in Visual Studio Code
You can use your local install of Visual Studio Code to create, manage, work in, and delete codespaces. To use GitHub Codespaces in VS Code, you need to install the Codespaces extension. For more information on setting up GitHub Codespaces in VS Code, see Prerequisites.
By default, if you create a new codespace on GitHub, it will open in the browser. If you would prefer to open any new codespaces in VS Code automatically, you can set your default editor to be VS Code. For more information, see Setting your default editor for GitHub Codespaces.
If you prefer to work in the browser, but want to continue using your existing VS Code extensions, themes, and shortcuts, you can turn on Settings Sync. For more information, see Personalizing GitHub Codespaces for your account.
Prerequisites
To develop in a codespace directly in VS Code, you must install and sign into the GitHub Codespaces extension with your GitHub credentials. The GitHub Codespaces extension requires VS Code October 2020 Release 1.51 or later.
Use the Visual Studio Code Marketplace to install the GitHub Codespaces extension. For more information, see Extension Marketplace in the VS Code documentation.


In VS Code, in the Activity Bar, click the Remote Explorer icon.

Note

If the Remote Explorer is not displayed in the Activity Bar:

Access the Command Palette. For example, by pressing Shift+Command+P (Mac) / Ctrl+Shift+P (Windows/Linux).
Type: details.
Click Codespaces: Details.




Select "GitHub Codespaces" from the dropdown at the top of the "Remote Explorer" side bar, if it is not already selected.


Click Sign in to GitHub.



If you are not currently signed in to GitHub you'll be prompted to do so. Go ahead and sign in.


When you're prompted to specify what you want to authorize, click the Authorize button for "GitHub."


If the authorization page is displayed, click Authorize Visual-Studio-Code.


Creating a codespace in VS Code
After you connect your account on GitHub to the GitHub Codespaces extension, you can create a new codespace. For more information about the GitHub Codespaces extension, see the VS Code Marketplace.


In VS Code, in the Activity Bar, click the Remote Explorer icon.

Note

If the Remote Explorer is not displayed in the Activity Bar:

Access the Command Palette. For example, by pressing Shift+Command+P (Mac) / Ctrl+Shift+P (Windows/Linux).
Type: details.
Click Codespaces: Details.




Hover over the "Remote Explorer" side bar and click .



In the text box, type the name of the repository you want to develop in, then select it.

A message is displayed at the right side of subsequent prompts telling you who will pay for the codespace.



Click the branch you want to develop on.


If prompted to choose a dev container configuration file, choose a file from the list.


Click the machine type you want to use.
Note

Your choice of available machine types may be limited by a number of factors. These can include a policy configured for your organization, or a minimum machine type specification for your repository. For more information, see Restricting access to machine types and Setting a minimum specification for codespace machines.



Opening a codespace in VS Code


In VS Code, in the Activity Bar, click the Remote Explorer icon.

Note

If the Remote Explorer is not displayed in the Activity Bar:

Access the Command Palette. For example, by pressing Shift+Command+P (Mac) / Ctrl+Shift+P (Windows/Linux).
Type: details.
Click Codespaces: Details.




Under "GitHub Codespaces", hover over the codespace you want to develop in.


Click the connection icon (a plug symbol).



Changing the machine type in VS Code
Typically, you can run your codespace on a choice of remote machine types. These machine types offer a choice of hardware specifications ranging from 2 cores to 32 cores, although the full range of machine types may not always be available. Each machine type has a different level of resources and a different billing tier. For information, see About billing for GitHub Codespaces.
By default the machine type with the lowest valid resources is used when you create a codespace. You can change the machine type of your codespace at any time.
Note

Your choice of available machine types may be limited by a number of factors. These can include a policy configured for your organization, or a minimum machine type specification for your repository. For more information, see Restricting access to machine types and Setting a minimum specification for codespace machines.



In VS Code, open the Command Palette with Command+Shift+P (Mac) or Ctrl+Shift+P (Windows/Linux).


Search for and select "Codespaces: Change Machine Type."



If you're not following these instructions within a codespace, click the codespace that you want to change.

If you are following these instructions in a codespace, the change will apply to the codespace you're working in.


Select the machine type you want to use.


If you're changing to a machine type with a different storage capacity, a prompt will appear asking if you would like to continue. Read the prompt and click Yes to accept.


If you changed to a virtual machine with a different storage capacity (for example, from 32 GB to 64 GB), your codespace will be unavailable for a short time while the machine type is changed. If the codespace is currently active, it will automatically be stopped. When the change is complete, you'll be able to restart the codespace running on the new machine type.
If you changed to a virtual machine with the same storage capacity, the change will be applied the next time you restart the codespace. An active codespace will not be stopped automatically. For more information on restarting a codespace, see Stopping and starting a codespace.
Deleting a codespace in VS Code
You can delete codespaces from within VS Code when you are not currently working in a codespace.


In VS Code, in the Activity Bar, click the Remote Explorer icon.

Note

If the Remote Explorer is not displayed in the Activity Bar:

Access the Command Palette. For example, by pressing Shift+Command+P (Mac) / Ctrl+Shift+P (Windows/Linux).
Type: details.
Click Codespaces: Details.




Under "GitHub Codespaces," right-click the codespace you want to delete.


Click Delete Codespace.


Switching to VS Code Insiders in the web client
If you are using the VS Code web client, you can switch to the Insiders version of the application. For more information about this version of VS Code, see Introducing the Insiders Build in the VS Code blog.
After you switch versions in a codespace, the web client will continue to use the Insiders version if you stop and restart the codespace. New codespaces that you create and open in the VS Code web client will also use the Insiders version.


In bottom left of the browser window that's displaying a codespace, click .


In the menu, select "Switch to Insiders Version."



Click Reload.


To switch back to the Stable version of VS Code, repeat the process but choose Switch to Stable Version. After you switch back, the codespace will continue to use the Stable version if you stop and restart the codespace. New codespaces that you create and open in the VS Code web client will also use the Stable version.
Using the Insiders desktop application for Codespaces
To use GitHub Codespaces in the Insiders version of the VS Code desktop application, start or create your codespaces from within the VS Code Insiders application. For more information see Creating a codespace in VS Code and Opening a codespace in VS Code earlier in this article.
Further reading

Using the Visual Studio Code Command Palette in GitHub Codespaces
Using GitHub Copilot in GitHub Codespaces\n\n\n\nCodespaces/Developing in a codespace/GitHub CLIUsing GitHub Codespaces with GitHub CLIYou can work with GitHub Codespaces directly from your command line by using gh, the GitHub command line interface.In this articleAbout GitHub CLIInstalling GitHub CLIUsing GitHub CLIgh commands for GitHub CodespacesAbout GitHub CLI
GitHub CLI is an open source tool for using GitHub from your computer's command line. When you're working from the command line, you can use the GitHub CLI to save time and avoid switching context. For more information, see About GitHub CLI.
You can work with GitHub Codespaces in the GitHub CLI to:

List all of your codespaces
Create a new codespace
View details of a codespace
Stop a codespace
Delete a codespace
Rename a codespace
Rebuild a codespace
SSH into a codespace
Open a codespace in Visual Studio Code
Open a codespace in JupyterLab
Copy a file to/from a codespace
Modify ports in a codespace
Access codespace logs
Access remote resources
Change the machine type of a codespace

Installing GitHub CLI
For installation instructions for GitHub CLI, see the GitHub CLI repository.
Using GitHub CLI
If you have not already done so, run gh auth login to authenticate with your GitHub account.
To use gh to work with GitHub Codespaces, type gh codespace SUBCOMMAND or its alias gh cs SUBCOMMAND.
As an example of a series of commands you might use to work with GitHub Codespaces, you could:

List your current codespaces, to check whether you have a codespace for a particular repository:
gh codespace list
Create a new codespace for the required repository branch:
gh codespace create -r github/docs -b main
SSH into the new codespace:
gh codespace ssh -c octocat-literate-space-parakeet-7gwrqp9q9jcx4vq
Forward a port to your local machine:
gh codespace ports forward 8000:8000 -c octocat-literate-space-parakeet-7gwrqp9q9jcx4vq

gh commands for GitHub Codespaces
The sections below give example commands for each of the available operations.
For a complete reference of gh commands for GitHub Codespaces, including details of all available options for each command, see the GitHub CLI online help for gh codespace. Alternatively, on the command line, use gh codespace --help for general help or gh codespace SUBCOMMAND --help for help with a specific subcommand.
Note

The -c CODESPACE_NAME flag, used with many commands, is optional. If you omit it a list of codespaces is displayed for you to choose from.

List all of your codespaces
gh codespace list

The list includes the unique name of each codespace, which you can use in other gh codespace commands.
An asterisk at the end of the branch name for a codespace indicates that there are uncommitted or unpushed changes in that codespace.
Create a new codespace
gh codespace create -r OWNER/REPO_NAME [-b BRANCH]

For more information, see Creating a codespace for a repository.
View details of a codespace
gh codespace view

After running this command you are prompted to choose one of your existing codespaces. The following information is then displayed:

Name of the codespace
State (for example, "Available" or "Shutdown")
Repository
Git status
Path to the dev container configuration file used to create the codespace
Machine type
Idle timeout
Date and time the codespace was created
Retention period

For more information, see the GitHub CLI reference.
Stop a codespace
gh codespace stop -c CODESPACE-NAME

For more information, see Deep dive into GitHub Codespaces.
Delete a codespace
gh codespace delete -c CODESPACE-NAME

For more information, see Deleting a codespace.
Rename a codespace
gh codespace edit -c CODESPACE-NAME -d 'DISPLAY-NAME'

For more information, see Renaming a codespace.
Rebuild a codespace
gh codespace rebuild

To perform a full rebuild, add --full at the end of this command. For more information, see Rebuilding the container in a codespace.
When you use this command to rebuild a codespace, it uses the devcontainer.json file that is currently saved in the codespace's system. This happens regardless of whether or not the current state of the file has been saved in source control. For more information, see Introduction to dev containers.
SSH into a codespace
To run commands on the remote codespace machine, from your terminal, you can SSH into the codespace.
gh codespace ssh -c CODESPACE-NAME

Note

The codespace you connect to must be running an SSH server. The default dev container image includes an SSH server, which is started automatically. If your codespaces are not created from the default image, you can install and start an SSH server by adding the following to the features object in your devcontainer.json file.
"features": {
// ...
"ghcr.io/devcontainers/features/sshd:1": {
"version": "latest"
},
// ...
}

For more information about the devcontainer.json file and the default container image, see Introduction to dev containers.

GitHub Codespaces creates a local SSH key automatically to provide a seamless authentication experience. For more information on connecting with SSH, see gh codespace ssh.
Open a codespace in Visual Studio Code
gh codespace code -c CODESPACE-NAME

You must have VS Code installed on your local machine. For more information, see Using GitHub Codespaces in Visual Studio Code.
Open a codespace in JupyterLab
gh codespace jupyter -c CODESPACE-NAME

The JupyterLab application must be installed in the codespace you are opening. The default dev container image includes JupyterLab, so codespaces created from the default image will always have JupyterLab installed. For more information about the default image, see Introduction to dev containers and the devcontainers/images repository. If you're not using the default image in your dev container configuration, you can install JupyterLab by adding the ghcr.io/devcontainers/features/python feature to your devcontainer.json file. You should include the option "installJupyterlab": true. For more information, see the README for the python feature, in the devcontainers/features repository.
Copy a file to/from a codespace
gh codespace cp [-r] SOURCE(S) DESTINATION

Use the prefix remote: on a file or directory name to indicate that it's on the codespace. As with the UNIX cp command, the first argument specifies the source and the last specifies the destination. If the destination is a directory, you can specify multiple sources. Use the -r (recursive) flag if any of the sources is a directory.
The location of files and directories on the codespace is relative to the home directory of the remote user.
Examples


Copy a file from the local machine to the $HOME directory of a codespace:
gh codespace cp myfile.txt remote:


Copy a file to the directory in which a repository is checked out in a codespace:
gh codespace cp myfile.txt remote:/workspaces/REPOSITORY-NAME


Copy a file from a codespace to the current directory on the local machine:
gh codespace cp remote:myfile.txt .


Copy three local files to the $HOME/temp directory of a codespace:
gh codespace cp a1.txt a2.txt a3.txt remote:temp


Copy three files from a codespace to the current working directory on the local machine:
gh codespace cp remote:a1.txt remote:a2.txt remote:a3.txt .


Copy a local directory into the $HOME directory of a codespace:
gh codespace cp -r mydir remote:


Copy a directory from a codespace to the local machine, changing the directory name:
gh codespace cp -r remote:mydir mydir-localcopy


For more information about the gh codespace cp command, including additional flags you can use, see the GitHub CLI manual.
Modify ports in a codespace
You can forward a port on a codespace to a local port. The port remains forwarded as long as the process is running. To stop forwarding the port, press Control+C.
gh codespace ports forward CODESPACE-PORT_NAME:LOCAL-PORT-NAME -c CODESPACE-NAME

To see details of forwarded ports enter gh codespace ports and then choose a codespace.
You can set the visibility of a forwarded port. There are three visibility settings:

private - Visible only to you. This is the default setting when you forward a port.
org - Visible to members of the organization that owns the repository.
public - Visible to anyone who knows the URL and port number.

gh codespace ports visibility CODESPACE-PORT:private|org|public -c CODESPACE-NAME

You can set the visibility for multiple ports with one command. For example:
gh codespace ports visibility 80:private 3000:public 3306:org -c CODESPACE-NAME

For more information, see Forwarding ports in your codespace.
Access codespace logs
You can see the creation log for a codespace. After entering this command you will be asked to enter the passphrase for your SSH key.
gh codespace logs -c CODESPACE-NAME

For more information about the creation log, see GitHub Codespaces logs.
Access remote resources
You can use the GitHub CLI extension to create a bridge between a codespace and your local machine, so that the codespace can access any remote resource that is accessible from your machine. For more information on using the extension, see Using GitHub CLI to access remote resources.
Note

The GitHub CLI extension is currently in public preview and subject to change.

Change the machine type of a codespace
gh codespace edit -m MACHINE-TYPE-NAME

For more information, see the "GitHub CLI" tab of Changing the machine type for your codespace.\n\n\n\nCodespaces/Customizing your codespace/Rename a codespaceRenaming a codespaceYou can change the codespace display name to one of your choice on GitHub or using the GitHub CLI.Tool navigationGitHub CLIWeb browserIn this articleAbout renaming a codespaceRenaming a codespaceFurther readingAbout renaming a codespace
When you create a codespace it's assigned an auto-generated display name. If you have multiple codespaces, the display name helps you to differentiate between codespaces. For example: literate space parakeet. You can change the display name for your codespace.
To find the display name of a codespace:


On GitHub, view your list of codespaces at https://github.com/codespaces.



In the Visual Studio Code desktop application, or the VS Code web client, click the Remote Explorer. The display name is the second item in the list. For example: psychic chainsaw in the screenshot below.

Note

If the Remote Explorer is not displayed in the Activity Bar:

Access the Command Palette. For example, by pressing Shift+Command+P (Mac) / Ctrl+Shift+P (Windows/Linux).
Type: details.
Click Codespaces: Details.




In a terminal window on your local machine, use this GitHub CLI command: gh codespace list.


Permanent codespace names
In addition to a display name, every codespace also has a unique, permanent name. The permanent name is a combination of the initial display name, followed by some random characters - for example, literate-space-parakeet-w5vg5ww5p793g7g9. You can't change the permanent name.
You will occasionally need to know the permanent name of a codespace. For example, when you use some GitHub CLI commands, or when you discuss a particular codespace with GitHub support.
To find the permanent name of a codespace, do one of the following:

Open the codespace in the browser. The subdomain of the URL is the name of the codespace. For example: https://obscure-space-engine-grx7rgg6qp43v9j5.github.dev is the URL for the obscure-space-engine-grx7rgg6qp43v9j5 codespace.
If you cannot open a codespace, you can access the name from your list of codespaces at https://github.com/codespaces. Right-click the display name of the codespace and select your browser's option for copying the link address. The final part of the URL you copy is the permanent name of the codespace.
In a codespace, use this command in the terminal: echo $CODESPACE_NAME.
If GitHub CLI is installed, either locally or in a codespace, use this command in the terminal to list all of your codespaces: gh codespace list.

The permanent name the codespace is also included in many of the log files. For example, in the GitHub Codespaces extension log, after fetching codespace or Connecting to codespace, and in the browser console log after clientUrl. For more information, see GitHub Codespaces logs.
Renaming a codespace
Changing the display name of a codespace can be useful if you have multiple codespaces that you will be using for an extended period. An appropriate name helps you identify a codespace that you use for a particular purpose.

If you have installed GitHub CLI, you can use it to work with GitHub Codespaces. For installation instructions for GitHub CLI, see the GitHub CLI repository.
To change the display name of a codespace, use the gh codespace edit subcommand:
gh codespace edit -c PERMANENT-CODESPACE-NAME -d 'NEW-DISPLAY-NAME'

In this example, replace PERMANENT-CODESPACE-NAME with the permanent name of the codespace whose display name you want to change. Replace NEW-DISPLAY-NAME with the display name you want to use for this codespace.
Display names can be up to 48 characters in length. The display name can contain any combination of characters, including spaces, provided you enclose it in single quotes.
For more information, see Using GitHub Codespaces with GitHub CLI.


You can change the display name for your codespace on GitHub.


In the top-left corner of GitHub, select , then click  Codespaces to take you to the "Your codespaces" page at github.com/codespaces.
The current display name for each of your codespaces is displayed.


Click the ellipsis (...) to the right of the codespace you want to modify.


Click Rename.


In the prompt, under "Change display name to..." type your desired display name and click OK.



Further reading

Setting your user preferences
Managing your codespaces\n\n\n\nCodespaces/Customizing your codespace/Change your shellChanging the shell in a codespaceYou can change your shell in a codespace to keep the setup you're used to.In this articleChanging from the default shell in VS CodeInstalling a new shellSetting the default shell in VS CodeSetting the default shell over SSHConfiguring your shellFurther readingWhen you're working in a codespace, you can open a new terminal window with a shell of your choice, change your default shell for new terminal windows, or install a new shell. You can also use dotfiles to configure your shell.
Codespaces that use the default dev container image come with the bash, zsh, and fish shells installed. If you open a new codespace in the VS Code web client, or connect to a codespace over SSH, the terminal opens with a bash session running by default. In the VS Code desktop application, the default shell depends on your local settings and operating system. For more information, see Terminal Profiles in the VS Code documentation.
Changing from the default shell in VS Code
If you don't want to use the default shell, you can open a new terminal session with a different shell.


If you cannot see the integrated terminal in VS Code, press Ctrl+`.


To the right of the  icon for opening a new terminal window, select the dropdown icon.



In the dropdown menu, click the name of the shell you want to use.


Installing a new shell
If you want to use a shell that isn't already installed in the base image or dev container configuration for a codespace, you can install a new shell.
If you're using the default dev container image, look for installation instructions for Ubuntu Linux. If you just want to use a different shell for one session, you can use the command line to install the shell in the codespace you're working in. However, you may lose programs you have installed if you rebuild the container in the codespace. For more information, see Deep dive into GitHub Codespaces.
A more robust option for installing new shells is to include the installation commands either in a dotfiles repository, or as a lifecycle command such as postCreateCommand in a devcontainer.json file. You should use a dotfiles repository to install a shell you want to use in all your own codespaces, and a devcontainer.json file for a shell that contributors to a specific repository should have installed. For more information, see Personalizing GitHub Codespaces for your account and Introduction to dev containers.
Adding a VS Code terminal profile for a new shell
VS Code automatically detects most standard shells and adds them as a terminal profile, so you can easily open new terminal windows using the shell you have installed.
If the shell you install isn't detected automatically, you can add a new terminal profile to your user settings. This setting is dependent on your operating system, so you should use linux for the VS Code web client and your local operating system for the desktop application.


To open the Visual Studio Code Command Palette, press Command+Shift+P (Mac) or Ctrl+Shift+P (Windows).


Start typing "user settings," then click Preferences: Open User Settings (JSON).


In the settings.json file, inside the JSON object, add a new property like the following. Replace OPERATING-SYSTEM with the relevant operating system (such as linux, windows, or osx) and SHELL with the shell you have installed.
JSON"terminal.integrated.profiles.OPERATING-SYSTEM": {
  "SHELL": {
    "path": "SHELL"
  }
}
"terminal.integrated.profiles.OPERATING-SYSTEM": {
  "SHELL": {
    "path": "SHELL"
  }
}

For example:
"terminal.integrated.profiles.linux": {
 "csh": {
   "path": "csh"
 }
}



Save the file.


You can use Settings Sync to share these settings across all codespaces you open in the VS Code web client and desktop application. If you're working in the web client, Settings Sync is disabled by default, and you must enable Settings Sync to push changes to your settings or pull in new changes you have made elsewhere. For more information, see Personalizing GitHub Codespaces for your account.
Setting the default shell in VS Code
You can set a default terminal profile to choose the default shell used for all new terminal windows you open in VS Code. The default terminal profile is dependent on your operating system, so you can set a default profile for Linux, if you're using the VS Code web client, or for your local operating system, if you're using the desktop application.
Note

Regardless of your default profile, codespaces opened in the web client always open with a bash session running initially.



To open the Visual Studio Code Command Palette, press Command+Shift+P (Mac) or Ctrl+Shift+P (Windows).


Start typing "user settings," then click Preferences: Open User Settings (JSON).


Inside the JSON object, to set the default shell for the relevant operating system, add lines or edit existing lines like the following.
"terminal.integrated.defaultProfile.OPERATING-SYSTEM": "SHELL"

For example:
JSON{
   "terminal.integrated.defaultProfile.osx": "zsh",
   "terminal.integrated.defaultProfile.linux": "bash",
   "terminal.integrated.defaultProfile.windows": "PowerShell"
}
{
   "terminal.integrated.defaultProfile.osx": "zsh",
   "terminal.integrated.defaultProfile.linux": "bash",
   "terminal.integrated.defaultProfile.windows": "PowerShell"
}



Save the settings.json file.


You can use Settings Sync to share these settings across all codespaces you open in the VS Code web client and desktop application. If you're working in the web client, Settings Sync is disabled by default, and you must enable Settings Sync to push changes to your settings or pull in new changes you have made elsewhere. For more information, see Personalizing GitHub Codespaces for your account.
Setting the default shell over SSH
When you connect to a codespace from the command line over SSH, you connect to a bash session in the codespace by default.
If you have enabled a dotfiles repository for GitHub Codespaces, you can change the default shell you connect to by adding a command to an installation script such as install.sh in your dotfiles. For more information, see Using GitHub Codespaces with GitHub CLI and Personalizing GitHub Codespaces for your account. For example, the following command changes the default shell to zsh.
Shellsudo chsh "$(id -un)" --shell "/usr/bin/zsh"
sudo chsh "$(id -un)" --shell "/usr/bin/zsh"

If you want to use a default shell that isn't installed in your codespace by default, or ensure you have the latest version of the shell, you can install the shell first.
Shellsudo apt-get update -y
sudo apt-get install -y csh
sudo chsh "$(id -un)" --shell "/usr/bin/csh"
sudo apt-get update -y
sudo apt-get install -y csh
sudo chsh "$(id -un)" --shell "/usr/bin/csh"

Note

If you create a new codespace (for example by using gh codespace create), you must wait sufficient time to ensure the script has finished running before you connect to the codespace over SSH. If the script hasn't finished running, you will connect to a default bash session.

When you have connected to the codespace, for most shells, you can use the command readlink /proc/$$/exe to check the correct shell is running.
Configuring your shell
With most shells, you have the option of using a configuration file, such as .bashrc, to configure the shell with your preferred settings. These settings can include things like aliases and environment variables.
By default, codespaces contain predefined configuration for the shells that come preinstalled. For example, the home directory in a codespace contains .bashrc and .zshrc files. You can change the contents of these files then use a command like source ~/.bashrc to update your shell configuration. However, you will lose any changes to these files if you rebuild the container in a codespace. For more information, see Deep dive into GitHub Codespaces.
Generally, you should use a dotfiles repository to configure shells with your preferred settings. The setup in your dotfiles applies to all codespaces you create, and persists over rebuilds of the container. For more information, see Personalizing GitHub Codespaces for your account.
Troubleshooting the fish shell
The fish shell includes a web-based configuration interface. You can use the fish_config command to start a local web server and launch this interface, then do things like change the terminal prompt or view your environment variables.
You can use the web-based interface for fish in a codespace. However,
the color settings in VS Code's integrated terminal depend on your chosen VS Code theme, and you cannot override these settings by setting a new theme in the fish_config interface.
When fish starts the local server, the default link that GitHub Codespaces provides to the forwarded port does not work. For example, if you click Open in Browser on the popup message, you will be taken to an error page.
To access the web-based interface for fish_config:


In a terminal running a fish session, enter fish_config.


In the terminal output, use Command+click or Ctrl+click to open the link to the web_config HTML file.
$ fish_config
Web config started at file:///tmp/web_config60rc9tr3.html
Hit ENTER to stop.



In the web_config file, use Command+click or Ctrl+click to open the link to the forwarded port.
<body>
  <p><a href="http://localhost:8000/1b9411c2469e392b96df5e5b28da485b/">Start the Fish Web config</a></p>
</body>



Further reading

Setting your user preferences
Managing your codespaces\n\n\n\nCodespaces/Customizing your codespace/Change the machine typeChanging the machine type for your codespaceYou can change the type of machine that's running your codespace, so that you're using resources appropriate for the work you're doing.Tool navigationGitHub CLIVisual Studio CodeWeb browserIn this articleAbout machine typesChanging the machine typeFurther readingAbout machine types
Typically, you can run your codespace on a choice of remote machine types. These machine types offer a choice of hardware specifications ranging from 2 cores to 32 cores, although the full range of machine types may not always be available. Each machine type has a different level of resources and a different billing tier. For information, see About billing for GitHub Codespaces.
By default the machine type with the lowest valid resources is used when you create a codespace. You can choose an alternative machine type either when you create a codespace or at any time after you've created a codespace.
For information on choosing a machine type when you create a codespace, see Creating a codespace for a repository.
Unpublished codespaces (codespaces created from a template that are not linked to a repository on GitHub) always run on a virtual machine with the same specifications. You can't change the machine type of an unpublished codespace. For more information, see Creating a codespace from a template.
Changing the machine type
Note

Your choice of available machine types may be limited by a number of factors. These can include a policy configured for your organization, or a minimum machine type specification for your repository. For more information, see Restricting access to machine types and Setting a minimum specification for codespace machines.




In the top-left corner of GitHub, select , then click  Codespaces to take you to the "Your codespaces" page at github.com/codespaces.
The number of cores, memory, storage capacity, and currently used storage are displayed for each codespace. Some details are omitted if you are using a narrow browser window.



Click the ellipsis (...) to the right of the codespace you want to modify.


Click Change machine type.



If multiple machine types are available for your codespace, choose the type of machine you want to use.



Click Update codespace.






In VS Code, open the Command Palette with Command+Shift+P (Mac) or Ctrl+Shift+P (Windows/Linux).


Search for and select "Codespaces: Change Machine Type."



If you're not following these instructions within a codespace, click the codespace that you want to change.

If you are following these instructions in a codespace, the change will apply to the codespace you're working in.


Select the machine type you want to use.


If you're changing to a machine type with a different storage capacity, a prompt will appear asking if you would like to continue. Read the prompt and click Yes to accept.




If you have installed GitHub CLI, you can use it to work with GitHub Codespaces. For installation instructions for GitHub CLI, see the GitHub CLI repository.
You can use the gh codespace edit --machine MACHINE-TYPE-NAME GitHub CLI command to change the machine type of a codespace. To use this command, you'll first need to find out the available machine types for your codespace.


To view your list of codespaces, in a terminal, enter the following command.
gh codespace list



Optionally, to find the current machine type for a codespace, enter the following command.
gh api /user/codespaces/CODESPACE-NAME

Replace CODESPACE-NAME with the permanent name of the codespace, for example literate-space-parakeet-w5vg5ww5p793g7g9. The permanent names are listed under the NAME column in the list returned by gh codespace list.
If you're prompted to request the codespace scope, follow the instructions in the terminal.
Details for the current machine are listed under the machine field.


To find the available machine types for a codespace, enter the following command.
gh api /user/codespaces/CODESPACE-NAME/machines

Replace CODESPACE-NAME with the permanent name of the codespace, for example literate-space-parakeet-w5vg5ww5p793g7g9.


To change the machine type for a codespace, enter the following command.
gh codespace edit --machine MACHINE-TYPE-NAME

Replace MACHINE-TYPE-NAME with the name of an available machine type for your codespace, for example standardLinux32gb.


Using the arrow keys, navigate to the codespace you want to change, then press Enter.



If you changed to a virtual machine with a different storage capacity (for example, from 32 GB to 64 GB), your codespace will be unavailable for a short time while the machine type is changed. If the codespace is currently active, it will automatically be stopped. When the change is complete, you'll be able to restart the codespace running on the new machine type.
If you changed to a virtual machine with the same storage capacity, the change will be applied the next time you restart the codespace. An active codespace will not be stopped automatically. For more information on restarting a codespace, see Stopping and starting a codespace.

Further reading

REST API endpoints for Codespaces machines
gh codespace edit in the GitHub CLI manual
Setting your user preferences
Managing your codespaces\n\n\n\nCodespaces/Setting your user preferences/Personalize your codespacesPersonalizing GitHub Codespaces for your accountYou can personalize GitHub Codespaces by using a dotfiles repository on GitHub or by using Settings Sync.In this articleAbout personalizing CodespacesSettings SyncDotfilesOther available settingsFurther readingAbout personalizing Codespaces
When using any development environment, customizing the settings and tools to your preferences and workflows is an important step. GitHub Codespaces allows for two main ways of personalizing your codespaces.

Settings Sync - You can synchronize your Visual Studio Code settings between the desktop application and the VS Code web client.
Dotfiles – You can use a dotfiles repository to specify scripts, shell preferences, and other configurations.

GitHub Codespaces personalization applies to any codespace you create.
Project maintainers can also define a default configuration that applies to every codespace for a repository, created by anyone. For more information, see Introduction to dev containers.
Settings Sync
Settings Sync allows you to synchronize configurations such as settings, keyboard shortcuts, snippets, extensions, and UI state across machines and instances of VS Code. For more information, see Settings Sync in the VS Code documentation.
Your synced settings are cached in the cloud. If Settings Sync is turned on in a codespace, any updates you make to your settings in the codespace are pushed to the cloud, and any updates you push to the cloud from elsewhere are pulled into your codespace.
For example, a common use of Settings Sync would be to sync your settings from your VS Code desktop application, which you use for local work, to codespaces you open in the browser. To do this, you would need to do the following things.

Turn on Settings Sync in the desktop application. For more information, see Settings Sync in the VS Code documentation.
Enable Settings Sync in your user preferences for GitHub Codespaces. For more information, see Managing your preferences for Settings Sync.
Optionally, if you want to sync settings changes back to your desktop application from a codespace, turn on Settings Sync in the codespace and add the repository from which you created the codespace to your list of trusted repositories. For more information, see Turning on Settings Sync in a codespace.

Alternatively, you may want to use the same settings across all codespaces you open in the web client, while leaving your local VS Code application unaffected. To do this, you would need to do the following things.

In a codespace, configure your settings as you want them, then turn on Settings Sync in the codespace to push the settings to the cloud. When you do this, Settings Sync is enabled automatically in your user preferences for GitHub Codespaces, so your settings will be pulled into all new codespaces. For more information, see Turning on Settings Sync in a codespace.
In the desktop application, leave Settings Sync turned off, or sync your settings to a different account.

About Settings Sync in codespaces
Whether Settings Sync is turned on by default in a codespace, and the relationship between your cached settings and the settings in a codespace, depend on several factors. These factors include the editor in which you open the codespace, your user preferences on GitHub, and your list of trusted repositories.
For codespaces opened in the VS Code desktop application, Settings Sync remains on if you have previously turned on Settings Sync in the application. If Settings Sync is on, your settings are synced both to and from the cloud.
For codespaces opened in the VS Code web client, Settings Sync is disabled by default. This means the VS Code instance in the codespace uses the default theme and settings.
If you use the web client and want your codespaces to use your cached synced settings, you can enable Settings Sync in your user preferences on GitHub. For more information, see Managing your preferences for Settings Sync. Settings Sync is enabled in your user preferences automatically if you open a codespace in the web client and turn on Settings Sync in the codespace.
When Settings Sync is enabled in your user preferences, for codespaces opened in the web client, the behavior of Settings Sync depends on your list of trusted repositories.


If you create a codespace from a repository you trust, Settings Sync is turned on in the codespace by default, so your settings are synced both to and from the cloud.


If you create a codespace from a repository you haven't added to your list of trusted repositories, the sync takes place in one direction and at one time only. When you create the codespace, your settings are pulled into the codespace from your cached settings in the cloud, but from then on, Settings Sync is turned off in the codespace. This means updates you make to your settings in the codespace are not pushed back to the cloud, and any updates you make to your cached settings from elsewhere are not reflected in the codespace after you have created it.
If you turn on Settings Sync in a codespace, you will be prompted to add the repository to your list of trusted repositories. For more information, see Turning on Settings Sync in a codespace.


Your list of trusted repositories for GitHub Codespaces is shared between the GPG verification and Settings Sync features. Assuming you have both features enabled, if you have added a selected list of trusted repositories for GPG verification, Settings Sync is turned on in codespaces created from these repositories. If you trust a new repository for Settings Sync, GPG verification is enabled for the same repository. Although the features share the same list of trusted repositories, you can enable or disable GPG verification and Settings Sync independently.
Note

If you have previously enabled GPG verification for all repositories, we recommend changing your preferences to use a selected list of trusted repositories. For more information, see Security in GitHub Codespaces.

For more information on managing your preferences for GPG verification, see Managing GPG verification for GitHub Codespaces.
Managing your preferences for Settings Sync
If you enable Settings Sync in your user preferences, codespaces opened in the VS Code web client will pull in your cached settings from the cloud, and codespaces created from trusted repositories will sync with your cached settings in both directions.


In the upper-right corner of any page on GitHub, click your profile photo, then click  Settings.


In the "Code, planning, and automation" section of the sidebar, click  Codespaces.


To enable or disable Settings Sync, under "Settings Sync," select or deselect Enable.


To change your trusted repositories for GPG verification and Settings Sync, under "Trusted repositories," either select All repositories, or select Selected repositories and use the "Select repositories" dropdown to add repositories you trust.
Note

We recommend using a selected list of trusted repositories. For more information, see Security in GitHub Codespaces.



Your updates will take effect in new codespaces. However, you can turn on Settings Sync in an existing codespace. For more information, see Turning on Settings Sync in a codespace.
Turning on Settings Sync in a codespace
Note

You should only turn on Settings Sync in codespaces created from repositories you trust. For more information, see Security in GitHub Codespaces.

The following procedure describes how to turn on Settings Sync in a codespace opened in the web client. For information about turning on Settings Sync in the VS Code desktop application, see Settings Sync in the VS Code documentation.


In VS Code, at the bottom of the Activity Bar, select , then click Sign in to Sync Settings.


If the repository from which you created the codespace is not in your list of trusted repositories, a browser window will open asking you to authorize additional permissions for Settings Sync. If you trust the repository, click Authorize, then close the browser window. The codespace will reload and display your latest synced settings.
Note

If you have Settings Sync disabled in your user preferences, and have set your trusted repositories to all repositories, you will see a warning about enabling Settings Sync for all repositories. Review the warning and choose whether to enable Settings Sync for all repositories or revise your list of trusted repositories.



To configure which settings you want to sync, open the Command Palette with Shift+Command+P (Mac) / Ctrl+Shift+P (Windows/Linux), then start typing "Settings Sync". Click Settings Sync: Configure....


Select the settings you want to sync, then click OK.



Turning off Settings Sync in a codespace
You can turn off Settings Sync to stop syncing settings to and from an instance of VS Code.
When you turn off Settings Sync in a codespace, new codespaces continue to use the settings cached from the last time your settings were pushed to the cloud. If you use the VS Code web client for codespaces, and want codespaces to use the default settings instead of your cached settings, you can disable Settings Sync. For more information, see Managing your preferences for Settings Sync.
If you want to return to using the default VS Code settings in all instances of VS Code, including the desktop application, you can clear the cache in the cloud when you turn off Settings Sync.


If Settings Sync is currently turned off in your instance of VS Code, and you want to clear your cached settings, you must first turn it on. For instructions, see Personalizing GitHub Codespaces for your account.


At the bottom of the Activity Bar, select  and click Settings Sync is On.


In the dropdown, click Settings Sync: Turn Off.



To clear your cached settings, in the dialog, select Turn off sync on all your devices and clear the data from the cloud.



Click Turn off.


Dotfiles
Dotfiles are files and folders on Unix-like systems starting with . that control the configuration of applications and shells on your system. You can store and manage your dotfiles in a repository on GitHub. For advice and tutorials about what to include in your dotfiles repository, see GitHub does dotfiles.
Your dotfiles repository might include your shell aliases and preferences, any tools you want to install, or any other codespace personalization you want to make.
You can configure GitHub Codespaces to use dotfiles from any repository you own by selecting that repository in your personal GitHub Codespaces settings.
When you create a new codespace, GitHub clones your selected dotfiles repository to the codespace environment, and looks for one of the following files to set up the environment.

install.sh
install
bootstrap.sh
bootstrap
script/bootstrap
setup.sh
setup
script/setup

If none of these files are found, then any files or folders in your selected dotfiles repository starting with . are symlinked to the codespace's ~ or $HOME directory.
Any changes to your selected dotfiles repository will apply only to each new codespace, and do not affect any existing codespace.
Note

Currently, Codespaces does not support personalizing the User-scoped settings for VS Code with your dotfiles repository. You can set default Workspace and Remote [Codespaces] settings for a specific project in the project's repository. For more information, see Introduction to dev containers.

Enabling your dotfiles repository for Codespaces
You can use your selected dotfiles repository to personalize your GitHub Codespaces environment. Once you choose your dotfiles repository, you can add your scripts, preferences, and configurations to it. You then need to enable your dotfiles from your personal GitHub Codespaces settings page.
Warning

Dotfiles have the ability to run arbitrary scripts, which may contain unexpected or malicious code. Before installing a dotfiles repo, we recommend checking scripts to ensure they don't perform any unexpected actions.



In the upper-right corner of any page on GitHub, click your profile photo, then click  Settings.


In the "Code, planning, and automation" section of the sidebar, click  Codespaces.


Under "Dotfiles", select Automatically install dotfiles so that GitHub Codespaces automatically installs your dotfiles into every new codespace you create.



Use the dropdown to choose the repository you want to install dotfiles from.



You can add further script, preferences, configuration files to your dotfiles repository or edit existing files whenever you want. Changes to settings will only be picked up by new codespaces.
If your codespace fails to pick up configuration settings from dotfiles, see Troubleshooting personalization options for GitHub Codespaces.
Other available settings
You can also personalize GitHub Codespaces using additional options in your personal settings:

To enable GPG verification, see Managing GPG verification for GitHub Codespaces.
To set your editor, see Setting your default editor for GitHub Codespaces.
To set how long a codespace can remain unused before it is automatically stopped, see Setting your timeout period for GitHub Codespaces.
To set the period for which your unused codespaces are retained, see Configuring automatic deletion of your codespaces.
To set your default region, see Setting your default region for GitHub Codespaces.

Further reading

Creating a new repository
Deep dive into GitHub Codespaces
Customizing your codespace
Managing your codespaces\n\n\n\nCodespaces/Setting your user preferences/Set the default editorSetting your default editor for GitHub CodespacesYou can set your default editor for Codespaces in your personal settings page.In this articleSetting your default editorFurther readingOn the settings page, you can set your editor preference so that when you create a codespace, or open an existing codespace, it is opened in your choice of:

Visual Studio Code (desktop application)
Visual Studio Code (web client application)
JupyterLab - the web interface for Project Jupyter

When you create a new codespace from a template, it is always opened in the Visual Studio Code web client. You can reopen an existing codespace in any supported editor. For more information, see Opening an existing codespace.
If you want to use Visual Studio Code as your default editor for GitHub Codespaces, you need to install Visual Studio Code and the GitHub Codespaces extension for Visual Studio Code. For more information, see the download page for Visual Studio Code and the GitHub Codespaces extension on the Visual Studio Code marketplace.
Setting your default editor


In the upper-right corner of any page on GitHub, click your profile photo, then click  Settings.


In the "Code, planning, and automation" section of the sidebar, click  Codespaces.


Under "Editor preference", select the option you want.


If you choose Visual Studio Code, you must make sure you have VS Code installed on your local machine.


If you choose Visual Studio Code, GitHub Codespaces will automatically open in the desktop application when you next create or open a codespace.
You may need to allow access to both your browser and Visual Studio Code for it to open successfully.


If you choose JupyterLab, the JupyterLab application must be installed in the codespaces you open. The default dev container image includes JupyterLab, so codespaces created from the default image will always have JupyterLab installed. For more information about the default image, see Introduction to dev containers and the devcontainers/images repository. If you're not using the default image in your dev container configuration, you can install JupyterLab by adding the ghcr.io/devcontainers/features/python feature to your devcontainer.json file. You should include the option "installJupyterlab": true. For more information, see the README for the python feature, in the devcontainers/features repository.




Further reading

Customizing your codespace
Managing your codespaces\n\n\n\nCodespaces/Setting your user preferences/Set the default regionSetting your default region for GitHub CodespacesYou can set your default region in the GitHub Codespaces profile settings page to personalize where your data is held.In this articleSetting your default regionFurther readingYou can manually select the region that your codespaces will be created in, allowing you to meet stringent security and compliance requirements. By default, your region is set automatically, based on your location.
Setting your default region


In the upper-right corner of any page on GitHub, click your profile photo, then click  Settings.


In the "Code, planning, and automation" section of the sidebar, click  Codespaces.


Under "Region", select the setting you want: Set automatically or Set manually.


If you chose Set manually, select the dropdown menu and click your region.


Further reading

Customizing your codespace
Managing your codespaces\n\n\n\nCodespaces/Setting your user preferences/Set the timeoutSetting your timeout period for GitHub CodespacesYou can set your default timeout for GitHub Codespaces in your personal settings page.Tool navigationGitHub CLIVisual Studio CodeWeb browserIn this articleAbout the idle timeoutSetting your default timeout periodSetting the timeout period for a codespaceSetting a timeout periodFurther readingAbout the idle timeout
A codespace will stop running after a period of inactivity. By default this period is 30 minutes, but you can specify a longer or shorter default timeout period in your personal settings on GitHub. The updated setting will apply to any new codespaces you create, or to existing codespaces the next time you start them. You can also specify a timeout when you use GitHub CLI to create a codespace.
Warning

Codespaces compute usage is billed for the duration for which a codespace is active. If you're not using a codespace but it remains running, and hasn't yet timed out, you are billed for the total time that the codespace was active, irrespective of whether you were using it. For more information, see About billing for GitHub Codespaces.

Inactivity defined
In the context of the Codespaces idle timeout, inactivity is defined as the absence of activity indicative of a user's presence. Personal interaction with a codespace, such as typing or using the mouse, resets the idle timeout period. Terminal activity, either input or output, also resets the idle timeout period. For example, if you publish a web app on a port from a codespace and page requests generate output in a terminal on the codespace, then each time terminal output occurs the timeout will be reset. However, if you share a port, and then don't interact with the codespace, and no terminal output is generated, the codespace will time out after the configured period.
Timeout periods for organization-owned repositories
Organizations can set a maximum idle timeout policy for codespaces created from some or all of their repositories. If an organization policy sets a maximum timeout which is less than the default timeout you have set, the organization's timeout will be used instead of your setting. You will be notified of this after the codespace is created. For more information, see Restricting the idle timeout period.

Setting your default timeout period


In the upper-right corner of any page on GitHub, click your profile photo, then click  Settings.


In the "Code, planning, and automation" section of the sidebar, click  Codespaces.


Under "Default idle timeout", enter the time that you want, then click Save. The time must be between 5 minutes and 240 minutes (4 hours).





Setting the timeout period for a codespace
Note

To learn more about GitHub CLI, see About GitHub CLI.

To set the timeout period when you create a codespace, use the idle-timeout argument with the codespace create subcommand. Specify the time in minutes, followed by m. The time must be between 5 minutes and 240 minutes (4 hours).
gh codespace create --idle-timeout 90m

If you don't specify a timeout period when you create a codespace, then the default timeout period will be used. For information about setting a default timeout period, click the "Web browser" tab on this page. You can't currently specify a default timeout period through GitHub CLI.


Setting a timeout period
You can set your default timeout period in your web browser, on GitHub. Alternatively, if you use GitHub CLI to create a codespace you can set a timeout period for that particular codespace. For more information, click the appropriate tab above.

Further reading

Customizing your codespace
Managing your codespaces\n\n\n\nCodespaces/Setting your user preferences/Configure automatic deletionConfiguring automatic deletion of your codespacesInactive codespaces are automatically deleted. You can choose how long your stopped codespaces are retained, up to a maximum of 30 days.Tool navigationGitHub CLIVisual Studio CodeWeb browserIn this articleSetting a default retention period for your codespacesChecking the remaining time until autodeletionAvoiding automatic deletion of codespacesSetting a retention period for a codespaceSetting the retention periodChecking whether codespaces will be autodeleted soonFurther readingBy default, GitHub Codespaces are automatically deleted after they have been stopped and have remained inactive for 30 days.
However, because GitHub Codespaces incurs storage charges, you may prefer to reduce the retention period by changing your default period in your personal settings for GitHub Codespaces. For more information about storage charges, see About billing for GitHub Codespaces.
Note

Whether or not you have set a personal codespace retention period, it's a good idea to get into the habit of deleting codespaces that you no longer need. See Deleting a codespace.

Automatic deletion happens irrespective of whether a codespace contains unpushed changes. To prevent automatic deletion of a codespace, just open the codespace again. The retention period is reset every time you connect to a codespace, and the retention countdown restarts when the codespace is stopped.
If a repository belongs to an organization, the organization owner may have set a retention period for the whole organization. If this period is less than the default retention period in your personal settings then the organization retention period will apply to codespaces you create for this repository. See Restricting the retention period for codespaces.
Each codespace has its own retention period. You may, therefore, have codespaces with different retention periods. For example, if:

You created a codespace, changed your default retention period, then created another codespace.
You created a codespace using GitHub CLI and specified a different retention period.
You created a codespace for an organization-owned repository that has a retention period configured in the organization settings. The ownership of the codespaces you create is shown on the Your codespaces page.

Note

The retention period is specified in days. A day represents a 24-hour period, beginning at the time of day when you stop a codespace.


Setting a default retention period for your codespaces


In the upper-right corner of any page on GitHub, click your profile photo, then click  Settings.


In the "Code, planning, and automation" section of the sidebar, click  Codespaces.


Under "Default retention period", enter the number of days for which you want your codespaces to be retained, by default, after they have been stopped.

You can set your default retention period between 0 and 30 days.
Warning

Setting the period to 0 will result in your codespaces being immediately deleted when you stop them, or when they timeout due to inactivity. See Setting your timeout period for GitHub Codespaces.



Click Save.


When you create a codespace using GitHub CLI you can override this default. If you create a codespace in an organization that specifies a shorter retention period, the organization-level value overrides your personal setting.
If you set a retention period of more than a day, you'll be sent an email notification one day prior to its deletion.
Checking the remaining time until autodeletion
You can check whether a codespace is due to be automatically deleted soon.
When an inactive codespace is approaching the end of its retention period, this is indicated in your list of codespaces on GitHub at https://github.com/codespaces.

Avoiding automatic deletion of codespaces
You may have a codespace that you want to keep for longer than the retention period defined in your personal settings. You can do this by using the "Keep codespace" option. When you select this option, your codespace will be retained indefinitely, until you delete it manually.
Note

The "Keep codespace" option is not available for organization-owned codespaces affected by an organization retention policy.

Codespaces incur storage costs, or consume your included storage allowance if the codespace is owned by your personal GitHub account. You should therefore be aware of the cost implications of storing codespaces indefinitely. See About billing for GitHub Codespaces.


In the top-left corner of GitHub, select , then click  Codespaces to take you to the "Your codespaces" page at github.com/codespaces.


To the right of the codespace you want to exempt from automatic deletion, click , then click  Keep codespace.



Codespaces that you have exempted from automatic deletion are indicated in your list of codespaces with the bookmark icon ().



Setting a retention period for a codespace
If you have installed GitHub CLI, you can use it to work with GitHub Codespaces. For installation instructions for GitHub CLI, see the GitHub CLI repository.
To set the codespace retention period when you create a codespace, use the --retention-period flag with the codespace create subcommand. Specify the period in days. The period must be between 0 and 30 days.
gh codespace create --retention-period DAYS

If you don't specify a retention period when you create a codespace, then either your default retention period, or an organization retention period, will be used, depending on which is lower. For information about setting your default retention period, click the "Web browser" tab on this page.
Note

To learn more about GitHub CLI, see About GitHub CLI.



Setting the retention period
You can set your default retention period in your web browser, on GitHub. Alternatively, if you use GitHub CLI to create a codespace you can set a retention period for that particular codespace. For more information, click the appropriate tab above.
Checking whether codespaces will be autodeleted soon
You can check, in the Visual Studio Code desktop application, whether a codespace is due to be automatically deleted soon.


In VS Code, in the Activity Bar, click the Remote Explorer icon.

Note

If the Remote Explorer is not displayed in the Activity Bar:

Access the Command Palette. For example, by pressing Shift+Command+P (Mac) / Ctrl+Shift+P (Windows/Linux).
Type: details.
Click Codespaces: Details.




Choose GitHub Codespaces from the dropdown menu at the top right of the Remote Explorer, if it is not already selected.


Under "GITHUB CODESPACES," position the mouse pointer over the codespace that you're interested in. A pop-up box is displayed showing you information about the codespace.
If the codespace is nearing the end of its retention period, a line is included telling when this period is due to expire.




Further reading

Customizing your codespace
Managing your codespaces\n\n\n\nCodespaces/Setting your user preferences/Choose the host imageChoosing the stable or beta host imageYou can choose to build codespaces using either the stable or beta version of the host image for the underlying virtual machine.In this articleAbout the virtual machine host imageChoosing the host imageFurther readingAbout the virtual machine host image
A GitHub codespace is a development environment provided by a Docker container that runs on a virtual machine (VM). For more information about the relationship of the development container and the VM, see Quickstart for GitHub Codespaces.
The VM for a codespace is built using a host image that defines the operating system of the VM. The image is periodically upgraded to improve security, functionality, and performance. The upgraded host image is initially made available as a beta release and subsequently becomes the stable release after a period of testing. You can choose, in your personal settings, to use either the stable or beta version of the host image. Any codespace you create or resume after changing this setting will run on a VM built from the specified host image.
The stable image is the default selected setting. Changing the setting to the beta host image gives you early access to improvements and new features on the host VM, but may also introduce incompatibilities with your current dev container configuration. This gives you the opportunity to alter your dev container configuration to avoid problems before the beta image is promoted to the stable image. If you do encounter problems with the beta host image, you can switch back to the stable host image at any time.
Note


It's unlikely you will encounter problems using the beta host image unless your dev container configuration has dependencies on components of the VM host kernel.
The virtual machine host image should not be confused with the dev container image, which provides the environment of your codespace. For more information, see Restricting the base image for codespaces.


If you choose to use the beta host image but no beta image is currently available, your codespaces will be built using the stable host image.
For information about the current host image versions, including the date on which the current stable image will be replaced by the current beta image, see the github/codespaces-host-images repository.
Choosing the host image


In the upper-right corner of any page on GitHub, click your profile photo, then click  Settings.


In the "Code, planning, and automation" section of the sidebar, click  Codespaces.


Under "Host image version preference", select either Stable or Beta.



Further reading

Customizing your codespace
Managing your codespaces\n\n\n\nCodespaces/Setting up your project/Adding a dev container configuration/Introduction to dev containersIntroduction to dev containersWhen you work in a codespace, the environment you are working in is created using a development container, or dev container, hosted on a virtual machine.Who can use this feature?People with write permissions to a repository can create or edit the codespace configuration.In this articleAbout dev containersUsing the default dev container configurationUsing a predefined dev container configurationCreating a custom dev container configurationApplying configuration changes to a codespaceFurther readingAbout dev containers
Development containers, or dev containers, are Docker containers that are specifically configured to provide a fully featured development environment. Whenever you work in a codespace, you are using a dev container on a virtual machine.
You can configure the dev container for a repository so that codespaces created for that repository give you a tailored development environment, complete with all the tools and runtimes you need to work on a specific project. If you don't define a configuration in the repository then GitHub Codespaces uses a default configuration, which contains many of the common tools that your team might need for development with your project. See Using the default dev container configuration.
The configuration files for a dev container are contained in a .devcontainer directory in your repository. You can use Visual Studio Code to add configuration files for you. You can choose from a selection of predefined configurations for various project types. You can use these without further configuration, or you can edit the configurations to refine the development environment they produce. See Using a predefined dev container configuration.
Alternatively, you can add your own custom configuration files. See Creating a custom dev container configuration.
You can define a single dev container configuration for a repository, different configurations for different branches, or multiple configurations. When multiple configurations are available, users can choose their preferred configuration when they create a codespace. This is particularly useful for large repositories that contain source code in different programming languages or for different projects. You can create a choice of configurations that allow different teams to work in a codespace that's set up appropriately for the work they are doing.
When you create a codespace from a template, you might start with one or more dev container configuration files in your workspace. To configure your environment further, you can add or remove settings from these files and rebuild the container to apply the changes to the codespace you're working in. If you publish your codespace to a repository on GitHub, then any codespaces created from that repository will share the configuration you've defined. See Applying configuration changes to a codespace and Creating a codespace from a template.
devcontainer.json
The primary file in a dev container configuration is the devcontainer.json file. You can use this file to determine the environment of codespaces created for your repository. The contents of this file define a dev container that can include frameworks, tools, extensions, and port forwarding. The devcontainer.json file usually contains a reference to a Dockerfile, which is typically located alongside the devcontainer.json file.
If you create a codespace from a repository without a devcontainer.json file, or if you start from GitHub's blank template, the default dev container configuration is used. See Using the default dev container configuration.
The devcontainer.json file is usually located in the .devcontainer directory of your repository. Alternatively, you can locate it directly in the root of the repository, in which case the file name must begin with a period: .devcontainer.json.
If you want to have a choice of dev container configurations in your repository, any alternatives to the .devcontainer/devcontainer.json (or .devcontainer.json) file must be located in their own subdirectory at the path .devcontainer/SUBDIRECTORY/devcontainer.json. For example, you could have a choice of two configurations:

.devcontainer/database-dev/devcontainer.json
.devcontainer/gui-dev/devcontainer.json

When you have multiple devcontainer.json files in your repository, each codespace is created from only one of the configurations. Settings cannot be imported or inherited between devcontainer.json files. If a devcontainer.json file in a custom subdirectory has dependent files, such as the Dockerfile or scripts that are run by commands in the devcontainer.json file, it's recommended that you co-locate these files in the same subdirectory.
For information about how to choose your preferred dev container configuration when you create a codespace, see Creating a codespace for a repository.
For information about the settings and properties that you can set in a devcontainer.json file, see the Specification on the Development Containers website.
How to use the devcontainer.json
It's useful to think of the devcontainer.json file as providing "customization" rather than "personalization." You should only include things that everyone working on your codebase needs as standard elements of the development environment, not things that are personal preferences. Things like linters are good to standardize on, and to require everyone to have installed, so they're good to include in your devcontainer.json file. Things like user interface decorators or themes are personal choices that should not be put in the devcontainer.json file.
You can personalize your codespaces by using dotfiles and Settings Sync. See Personalizing GitHub Codespaces for your account.
Dockerfile
You can add a Dockerfile as part of your dev container configuration.
The Dockerfile is a text file that contains the instructions needed to create a Docker container image. This image is used to generate a development container each time someone creates a codespace using the devcontainer.json file that references this Dockerfile. The instructions in the Dockerfile typically begin by referencing a parent image on which the new image that will be created is based. This is followed by commands that are run during the image creation process, for example to install software packages.
The Dockerfile for a dev container is typically located in the .devcontainer folder, alongside the devcontainer.json in which it is referenced.
Note

As an alternative to using a Dockerfile you can use the image property in the devcontainer.json file to refer directly to an existing image you want to use. The image you specify here must be allowed by any organization image policy that has been set. See Restricting the base image for codespaces. If neither a Dockerfile nor an image is found then the default container image is used. See Using the default dev container configuration.

Simple Dockerfile example
The following example uses four instructions:
ARG defines a build-time variable.
FROM specifies the parent image on which the generated Docker image will be based. If a base image policy has been configured, allowing only certain images to be used, the specified image must match one of the image references in the policy. If it does not, codespaces for this repository will be created in recovery mode. See Restricting the base image for codespaces.
COPY copies a file from the repository and adds it to the filesystem of the codespace.
RUN updates package lists and runs a script. You can also use a RUN instruction to install software, as shown by the commented out instructions. To run multiple commands, use && to combine the commands into a single RUN statement.
DockerfileARG VARIANT="16"
FROM mcr.microsoft.com/devcontainers/javascript-node:1-${VARIANT}

RUN apt-get update && export DEBIAN_FRONTEND=noninteractive \
    && apt-get -y install --no-install-recommends bundler

# [Optional] Uncomment if you want to install an additional version
#  of node using nvm
# ARG EXTRA_NODE_VERSION=18
# RUN su node -c "source /usr/local/share/nvm/nvm.sh \
#    && nvm install ${EXTRA_NODE_VERSION}"

COPY ./script-in-your-repo.sh /tmp/scripts/script-in-codespace.sh
RUN apt-get update && bash /tmp/scripts/script-in-codespace.sh
ARG VARIANT="16"
FROM mcr.microsoft.com/devcontainers/javascript-node:1-${VARIANT}

RUN apt-get update && export DEBIAN_FRONTEND=noninteractive \
    && apt-get -y install --no-install-recommends bundler

# [Optional] Uncomment if you want to install an additional version
#  of node using nvm
# ARG EXTRA_NODE_VERSION=18
# RUN su node -c "source /usr/local/share/nvm/nvm.sh \
#    && nvm install ${EXTRA_NODE_VERSION}"

COPY ./script-in-your-repo.sh /tmp/scripts/script-in-codespace.sh
RUN apt-get update && bash /tmp/scripts/script-in-codespace.sh

Note

In the above example, the script that's copied to the codespace (script-in-your-repo.sh) must exist in your repository.

For more information about Dockerfile instructions, see Dockerfile reference in the Docker documentation.
Using a Dockerfile
To use a Dockerfile as part of a dev container configuration, reference it in your devcontainer.json file by using the dockerfile property.
JSONC{
  // ...
  "build": { "dockerfile": "Dockerfile" },
  // ...
}
{
  // ...
  "build": { "dockerfile": "Dockerfile" },
  // ...
}

Various options are available to you if you want to use existing container orchestration in your dev container. See the "Orchestration options" section of the Specification on the Development Containers website.
Using the default dev container configuration
If you don't add a dev container configuration to your repository, or if your configuration does not specify a base image to use, then GitHub creates a container from a default Linux image. This Linux image includes a number of runtime versions for popular languages like Python, Node, PHP, Java, Go, C++, Ruby, and .NET Core/C#. The latest or LTS releases of these languages are used. There are also tools to support data science and machine learning, such as JupyterLab and Conda. The default dev container image also includes other developer tools and utilities like Git, GitHub CLI, yarn, openssh, and vim. To see all the languages, runtimes, and tools that are included use the devcontainer-info content-url command inside your codespace terminal and follow the URL that the command outputs.
For information about what's included in the default Linux image, see the devcontainers/images repository.
The default configuration is a good option if you're working on a small project that uses the languages and tools that GitHub Codespaces provides.
Note

GitHub does not charge for storage of containers built from the default dev container image. For more information about billing for codespace storage, see About billing for GitHub Codespaces. For information on how to check whether a codespace was built from the default dev container image, see Getting the most out of your included usage.

Using a predefined dev container configuration
If you use Codespaces in Visual Studio Code, or in a web browser, you can create a dev container configuration for your repository by choosing from a list of predefined configurations. These configurations provide common setups for particular project types, and can help you quickly get started with a configuration that already has the appropriate container options, Visual Studio Code settings, and Visual Studio Code extensions that should be installed.
Using a predefined configuration is a great idea if you need some additional extensibility. You can also start with a predefined configuration and amend it as needed for your project. For more information about the definitions of predefined dev containers, see the devcontainers/images repository.
You can add a predefined dev container configuration either while working in a codespace, or while working on a repository locally. To do this in VS Code while you are working locally, and not connected to a codespace, you must have the "Dev Containers" extension installed and enabled. For more information about this extension, see the VS Code Marketplace. The following procedure describes the process when you are using a codespace. The steps in VS Code when you are not connected to a codespace are very similar.


Access the Visual Studio Code Command Palette (Shift+Command+P / Ctrl+Shift+P), then start typing "add dev". Click Codespaces: Add Dev Container Configuration Files.



Click Create a new configuration.


Click Show All Definitions.



Click the definition you want to use.



Follow the prompts to customize your definition.


Click OK.


If you are working in a codespace, apply your changes by clicking Rebuild now in the pop-up at the bottom right of the window. For more information about rebuilding your container, see Applying configuration changes to a codespace.



Adding additional features to your devcontainer.json file
Features are self-contained units of installation code and dev container configuration, designed to work across a wide range of base container images. You can use features to quickly add tools, runtimes, or libraries to your codespace image. For more information, see the available features and features specification on the Development Containers website.
You can add features to a devcontainer.json file from VS Code or from your repository on GitHub. See Adding features to a devcontainer.json file.
Creating a custom dev container configuration
If none of the predefined configurations meets your needs, you can create a custom configuration by writing your own devcontainer.json file.


If you're adding a single devcontainer.json file that will be used by everyone who creates a codespace from your repository, create the file within a .devcontainer directory at the root of the repository.


If you want to offer users a choice of configuration, you can create multiple custom devcontainer.json files, each located within a separate subdirectory of the .devcontainer directory.
Note


You can't locate your devcontainer.json files in directories more than one level below .devcontainer. For example, a file at .devcontainer/teamA/devcontainer.json will work, but .devcontainer/teamA/testing/devcontainer.json will not.
When users create codespaces from the Use this template button in a template repository, they will not be given a choice between configurations. The codespace will be built based on the default configuration defined in .devcontainer/devcontainer.json, or in .devcontainer.json at the root of your repository. See Setting up a template repository for GitHub Codespaces.


If multiple devcontainer.json files are found in the repository, they are listed in the Dev container configuration dropdown on the codespace creation options page. See Creating a codespace for a repository.



Adding a devcontainer.json file
If you don't already have a devcontainer.json file in your repository, you can quickly add one from GitHub.


Navigate to your repository and click the  Code dropdown.


In the Codespaces tab, click the ellipsis (...), then select Configure dev container.



A new .devcontainer/devcontainer.json file will open in the editor. The file will contain some initial properties, including a features object to which you can add new tools, libraries, or runtimes. See Adding features to a devcontainer.json file.
If your repository already contains one or more devcontainer.json files, then clicking Configure dev container will open the existing devcontainer.json file with the highest precedence according to the specification on the Development Containers website.
Default configuration selection during codespace creation
If .devcontainer/devcontainer.json or .devcontainer.json exists, it will be the default selection in the list of available configuration files when you create a codespace. If neither file exists, the default dev container configuration will be selected by default.
In the following screenshot, the repository does not contain .devcontainer/devcontainer.json or .devcontainer.json files, so the default dev container configuration is selected. However, two alternative configuration files have been defined in subdirectories of the .devcontainer directory, so these are listed as options.

Editing the devcontainer.json file
You can add and edit the supported configuration keys in the devcontainer.json file to specify aspects of the codespace's environment, like which VS Code extensions will be installed. For information about the settings and properties that you can set in a devcontainer.json file, see the Specification on the Development Containers website.
The devcontainer.json file is written using the JSONC (JSON with comments) format. This allows you to include comments within the configuration file. See Editing JSON with VS Code in the VS Code documentation.
Note

If you use a linter to validate the devcontainer.json file, make sure it is set to JSONC and not JSON or comments will be reported as errors.

Interface settings for VS Code
You can configure the interface settings for VS Code, with three scopes: User, Remote [Codespaces], and Workspace. You can view these scopes in the VS Code Settings editor.
To display the Setting editor, use the keyboard shortcut Command+, (Mac) / Ctrl+, (Linux/Windows).

If a setting is defined in multiple scopes, Workspace settings take priority, then Remote [Codespaces], then User.
You can define default interface settings for VS Code in two places.

Interface settings defined in the .vscode/settings.json file in your repository are applied as Workspace-scoped settings in the codespace.
Interface settings defined in the settings key in the devcontainer.json file are applied as Remote [Codespaces]-scoped settings in the codespace.

Applying configuration changes to a codespace
Changes to a configuration will be applied the next time you create a codespace. However, you can apply your changes to an existing codespace by rebuilding the container. You can do this within a codespace in the VS Code web client or desktop application, or you can use GitHub CLI.
Note

When you rebuild the container in a codespace, changes you have made outside the /workspaces directory are cleared. Changes you have made inside the /workspaces directory, which includes the clone of the repository or template from which you created the codespace, are preserved over a rebuild. For more information, see Deep dive into GitHub Codespaces.

Rebuilding the dev container in the VS Code web client or desktop application


Access the VS Code Command Palette (Shift+Command+P / Ctrl+Shift+P), then start typing "rebuild". Click Codespaces: Rebuild Container.

Tip

You may occasionally want to perform a full rebuild to clear your cache and rebuild your container with fresh images. For more information, see Rebuilding the container in a codespace.



If changes to your dev container configuration cause a container error, your codespace will run in recovery mode, and you will see an error message.


To diagnose the error by reviewing the creation logs, click View creation log.
To fix the errors identified in the logs, update your devcontainer.json file.
To apply the changes, rebuild your container.



Using GitHub CLI to rebuild a dev container
If you've changed a dev container configuration outside of VS Code (for example, on GitHub), you can use GitHub CLI to rebuild the dev container for an existing codespace.


In a terminal, enter the following command.
gh codespace rebuild

Your codespaces are listed.


Use the arrow keys on your keyboard to highlight the required codespace, then press Enter.


Further reading

Prebuilding your codespaces\n\n\n\nCodespaces/Setting up your project/Adding a dev container configuration/Setting up a Node.js projectSetting up a Node.js project for GitHub CodespacesGet started with a Node.js, JavaScript, or TypeScript project in GitHub Codespaces by creating a custom dev container configuration.In this articleIntroductionStep 1: Open the project in a codespaceStep 2: Add a dev container configurationStep 3: Modify your devcontainer.json fileStep 4: Run your applicationStep 5: Commit your changesNext stepsIntroduction
This guide shows you how to set up an example Node.js project in GitHub Codespaces using the Visual Studio Code web client. It will step you through the process of opening the project in a codespace, and adding and modifying a predefined dev container configuration.
After you complete this tutorial, you'll be able to add a dev container configuration to your own repository, using either the VS Code web client or the VS Code desktop application.
For more information about dev containers, see Introduction to dev containers.
Step 1: Open the project in a codespace


Sign in to GitHub.com, if you haven't already done so.


Go to https://github.com/microsoft/vscode-remote-try-node.


Click Use this template, then click Open in a codespace.



When you create a codespace, your project is created on a remote virtual machine that is dedicated to you. By default, the container for your codespace has many languages and runtimes including Node.js, JavaScript, and TypeScript. It also includes a common set of tools, such as nvm, npm, yarn, git, wget, rsync, openssh, and nano.
You can customize your codespace by adjusting the amount of vCPUs and RAM, adding dotfiles to personalize your environment, or by modifying the tools and scripts installed. For more information, see Customizing your codespace.
GitHub Codespaces uses a file called devcontainer.json to configure the development container that you use when you work in a codespace. Each repository can contain one or more devcontainer.json files, to give you exactly the development environment you need to work on your code in a codespace.
On launch, GitHub Codespaces uses a devcontainer.json file, and any dependent files that make up the dev container configuration, to install tools and runtimes, and perform other setup tasks that the project requires. For more information, see Introduction to dev containers.
Step 2: Add a dev container configuration
The default development container, or "dev container," for GitHub Codespaces will allow you to work successfully on a Node.js project like vscode-remote-try-node. However, we recommend that you configure your own dev container to include all of the tools and scripts your project needs. This will ensure a fully reproducible environment for all GitHub Codespaces users in your repository.
To set up your repository to use a custom dev container, you will need to create one or more devcontainer.json files. You can either add these from a predefined configuration template, in Visual Studio Code, or you can write your own. For more information on dev container configurations, see Introduction to dev containers.


Access the Visual Studio Code Command Palette (Shift+Command+P / Ctrl+Shift+P), then start typing "add dev". Click Codespaces: Add Dev Container Configuration Files.



Click Create a new configuration.


In this example, the template repository from which you created the codespace already contains a dev container configuration, so a message is displayed telling you that the configuration file already exists. We're going to overwrite the existing configuration file, so click Continue.


Click Show All Definitions.



Type node and click Node.js & JavaScript. Other options are available if your project uses particular tools. For example, Node and MongoDB.



Choose the version of Node.js you want to use for your project. In this case, select the version marked "(default)."



A list of additional features is displayed. We'll install JSHint, a code quality tool for detecting errors in JavaScript code. To install this tool, type js, select JSHint (via npm), then click OK.



A message is displayed telling you that the dev container configuration file already exists. Click Overwrite.
A devcontainer.json file is created and is opened in the editor.


Details of your custom dev container configuration
If you look in the Visual Studio Code Explorer you'll see that a .devcontainer directory has been added to the root of your project's repository containing the devcontainer.json file. This is the main configuration file for codespaces created from this repository.
devcontainer.json
The devcontainer.json file that you have added will contain values for the name, image, and features properties. Some additional properties that you may find useful are included but are commented out.
The file will look similar to this, depending on which image you chose:
// For format details, see https://aka.ms/devcontainer.json. For config options, see the
// README at: https://github.com/devcontainers/templates/tree/main/src/javascript-node
{
  "name": "Node.js",
  // Or use a Dockerfile or Docker Compose file. More info: https://containers.dev/guide/dockerfile
  "image": "mcr.microsoft.com/devcontainers/javascript-node:0-18-bullseye",
  "features": {
    "ghcr.io/devcontainers-contrib/features/jshint:2": {}
  }

  // Features to add to the dev container. More info: https://containers.dev/features.
  // "features": {},

  // Use 'forwardPorts' to make a list of ports inside the container available locally.
  // "forwardPorts": [],

  // Use 'postCreateCommand' to run commands after the container is created.
  // "postCreateCommand": "yarn install",

  // Configure tool-specific properties.
  // "customizations": {},

  // Uncomment to connect as root instead. More info: https://aka.ms/dev-containers-non-root.
  // "remoteUser": "root"
}


name: You can name your dev container anything you want. A default value is supplied.
image: The name of an image in a container registry (DockerHub, GitHub Container registry, or Azure Container Registry) that will be used to create the dev container for the codespace.
features: A list of one or more objects, each of which references one of the available dev container features. Features are self-contained, shareable units of installation code and development container configuration. They provide an easy way to add more tooling, runtime, or library features to your development container. You can add features either within VS Code or in the devcontainer.json editor on GitHub. For more information, click either the Visual Studio Code or Web browser tab in Adding features to a devcontainer.json file.
forwardPorts: Any ports listed here will be forwarded automatically. For more information, see Forwarding ports in your codespace.
postCreateCommand: Use this property to run commands after your codespace is created. This can be formatted as a string (as above), an array, or an object. For more information, see the dev containers specification on the Development Containers website.
customizations: This property allows you to customize a specific tool or service when it is used for working in a codespace. For example, you can configure specific settings and extensions for VS Code. For more information, see Supporting tools and services on the Development Containers website.
remoteUser: By default, you’re running as the vscode user, but you can optionally set this to root.
For a complete list of available properties, see the dev containers specification on the Development Containers website.

Additional dev container configuration files
If you are familiar with Docker, you may want to use a Dockerfile, or Docker Compose, to configure your codespace environment, in addition to the devcontainer.json file. You can do this by adding your Dockerfile or docker-compose.yml files alongside the devcontainer.json file. For more information, see Using Images, Dockerfiles, and Docker Compose on the Development Containers website.
Step 3: Modify your devcontainer.json file
With your dev container configuration added and a basic understanding of what everything does, you can now make changes to customize your environment further. In this example, you'll add properties that will:

Run npm install, after the dev container is created, to install the dependencies listed in the package.json file.
Automatically install a VS Code extension in this codespace.



In the devcontainer.json file, add a comma after the features property, and delete the two commented out lines about features.
JSON  "features": {
    "ghcr.io/devcontainers-contrib/features/jshint:2": {}
  },

  // Features to add to the dev container. More info: https://containers.dev/features.
  // "features": {},
  "features": {
    "ghcr.io/devcontainers-contrib/features/jshint:2": {}
  },

  // Features to add to the dev container. More info: https://containers.dev/features.
  // "features": {},



Uncomment the postCreateCommand property and assign it the command npm install.
JSONC // Use 'postCreateCommand' to run commands after the container is created.
 "postCreateCommand": "npm install",
 // Use 'postCreateCommand' to run commands after the container is created.
 "postCreateCommand": "npm install",



Uncomment the customizations property and edit it as follows to install the "Code Spell Checker" VS Code extension.
JSONC// Configure tool-specific properties.
"customizations": {
  // Configure properties specific to VS Code.
  "vscode": {
    // Add the IDs of extensions you want installed when the container is created.
    "extensions": [
      "streetsidesoftware.code-spell-checker"
    ]
  }
}
// Configure tool-specific properties.
"customizations": {
  // Configure properties specific to VS Code.
  "vscode": {
    // Add the IDs of extensions you want installed when the container is created.
    "extensions": [
      "streetsidesoftware.code-spell-checker"
    ]
  }
}

The devcontainer.json file should now look similar to this, depending on which image you chose:
// README at: https://github.com/devcontainers/templates/tree/main/src/javascript-node
{
  "name": "Node.js",
  // Or use a Dockerfile or Docker Compose file. More info: https://containers.dev/guide/dockerfile
  "image": "mcr.microsoft.com/devcontainers/javascript-node:0-18-bullseye",
  "features": {
    "ghcr.io/devcontainers-contrib/features/jshint:2": {}
  },

  // Use 'forwardPorts' to make a list of ports inside the container available locally.
  // "forwardPorts": [],

  // Use 'postCreateCommand' to run commands after the container is created.
  "postCreateCommand": "npm install",

  // Configure tool-specific properties.
  "customizations": {
    // Configure properties specific to VS Code.
    "vscode": {
      // Add the IDs of extensions you want installed when the container is created.
      "extensions": [
        "streetsidesoftware.code-spell-checker"
      ]
    }
  }

  // Uncomment to connect as root instead. More info: https://aka.ms/dev-containers-non-root.
  // "remoteUser": "root"
}



Save your changes.


Access the VS Code Command Palette (Shift+Command+P / Ctrl+Shift+P), then start typing "rebuild". Click Codespaces: Rebuild Container.

Tip

You may occasionally want to perform a full rebuild to clear your cache and rebuild your container with fresh images. For more information, see Rebuilding the container in a codespace.
Rebuilding inside your codespace ensures your changes work as expected before you commit the changes to the repository. If something does result in a failure, you’ll be placed in a codespace with a recovery container that you can rebuild from to keep adjusting your container.

After the dev container is rebuilt, and your codespace becomes available again, the postCreateCommand will have been run, installing npm, and the "Code Spell Checker" extension will be available for use.


Step 4: Run your application
In the previous section, you used the postCreateCommand to install a set of packages via the npm install command. With the dependencies now installed, you can run the application.


In the Terminal of your codespace, enter npm start.



When your project starts, you should see a "toast" notification message at the bottom right corner of VS Code, telling you that your application is available on a forwarded port. To view the running application, click Open in Browser.



Step 5: Commit your changes
When you've made changes to your codespace, either new code or configuration changes, you'll want to commit your changes. Committing configuration changes to your repository ensures that anyone else who creates a codespace from this repository has the same configuration. Any customization you do, such as adding VS Code extensions, will be available to all users.
For this tutorial, you created a codespace from a template repository, so the code in your codespace is not yet stored in a repository. You can create a repository by publishing the current branch to GitHub.
For information, see Using source control in your codespace.
Next steps
You should now be able to add a custom dev container configuration to your own Node.js, JavaScript, or TypeScript project.
Here are some additional resources for more advanced scenarios.

Adding features to a devcontainer.json file
Managing your account-specific secrets for GitHub Codespaces
Managing GPG verification for GitHub Codespaces
Forwarding ports in your codespace\n\n\n\nCodespaces/Setting up your project/Adding a dev container configuration/Setting up a C# (.NET) projectSetting up a C# (.NET) project for GitHub CodespacesGet started with a C# (.NET) project in GitHub Codespaces by creating a custom dev container configuration.In this articleIntroductionStep 1: Open the project in a codespaceStep 2: Add a dev container configurationStep 3: Modify your devcontainer.json fileStep 4: Run your applicationStep 5: Commit your changesNext stepsIntroduction
This tutorial guide shows you how to set up an example C# (.NET) project in GitHub Codespaces using the Visual Studio Code web client. It will step you through the process of opening the project in a codespace, and adding and modifying a predefined dev container configuration.
After you complete this tutorial, you'll be able to add a dev container configuration to your own repository, using either the VS Code web client or the VS Code desktop application.
For more information about dev containers, see Introduction to dev containers.
Step 1: Open the project in a codespace


Sign in to GitHub.com, if you haven't already done so.


Go to https://github.com/microsoft/vscode-remote-try-dotnet.


Click Use this template, then click Open in a codespace.



When you create a codespace, your project is created on a remote virtual machine that is dedicated to you. By default, the container for your codespace has many languages and runtimes, including .NET. It also includes a common set of tools like git, wget, rsync, openssh, and nano.
You can customize your codespace by adjusting the amount of vCPUs and RAM, adding dotfiles to personalize your environment, or by modifying the tools and scripts installed. For more information, see Customizing your codespace.
GitHub Codespaces uses a file called devcontainer.json to configure the development container that you use when you work in a codespace. Each repository can contain one or more devcontainer.json files, to give you exactly the development environment you need to work on your code in a codespace.
On launch, GitHub Codespaces uses a devcontainer.json file, and any dependent files that make up the dev container configuration, to install tools and runtimes, and perform other setup tasks that the project requires. For more information, see Introduction to dev containers.
Step 2: Add a dev container configuration
The default development container, or "dev container," for GitHub Codespaces comes with the latest .NET version and common tools preinstalled. However, we recommend that you configure your own dev container to include all of the tools and scripts your project needs. This will ensure a fully reproducible environment for all GitHub Codespaces users in your repository.
To set up your repository to use a custom dev container, you will need to create one or more devcontainer.json files. You can either add these from a predefined configuration template, in Visual Studio Code, or you can write your own. For more information on dev container configurations, see Introduction to dev containers.


Access the Visual Studio Code Command Palette (Shift+Command+P / Ctrl+Shift+P), then start typing "add dev". Click Codespaces: Add Dev Container Configuration Files.



Click Create a new configuration.


In this example, the template repository from which you created the codespace already contains a dev container configuration, so a message is displayed telling you that the configuration file already exists. We're going to overwrite the existing configuration file, so click Continue.


Click Show All Definitions.



Type c# and click C# (.NET). Other options are available if your project uses particular tools. For example, C# and MS SQL.



Choose the version of .NET you want to use for your project. In this case, select the version marked "(default)."



A list of additional features is displayed. We'll install the .NET CLI, a command-line interface for developing, building, running, and publishing .NET applications. To install this tool, type dotnet, select Dotnet CLI, then click OK.



A message is displayed telling you that the dev container configuration file already exists. Click Overwrite.
A devcontainer.json file is created and is opened in the editor.


Details of your custom dev container configuration
If you look in the Visual Studio Code Explorer you'll see that a .devcontainer directory has been added to the root of your project's repository containing the devcontainer.json file. This is the main configuration file for codespaces created from this repository.
devcontainer.json
The devcontainer.json file that you have added will contain values for the name, image, and features properties. Some additional properties that you may find useful are included but are commented out.
The file will look similar to this, depending on which image you chose:
// For format details, see https://aka.ms/devcontainer.json. For config options, see the
// README at: https://github.com/devcontainers/templates/tree/main/src/dotnet
{
  "name": "C# (.NET)",
  // Or use a Dockerfile or Docker Compose file. More info: https://containers.dev/guide/dockerfile
  "image": "mcr.microsoft.com/devcontainers/dotnet:0-7.0",
  "features": {
    "ghcr.io/devcontainers/features/dotnet:1": {}
  }

  // Features to add to the dev container. More info: https://containers.dev/features.
  // "features": {},

  // Use 'forwardPorts' to make a list of ports inside the container available locally.
  // "forwardPorts": [5000, 5001],
  // "portsAttributes": {
  //   "5001": {
  //     "protocol": "https"
  //   }
  // }

  // Use 'postCreateCommand' to run commands after the container is created.
  // "postCreateCommand": "dotnet restore",

  // Configure tool-specific properties.
  // "customizations": {},

  // Uncomment to connect as root instead. More info: https://aka.ms/dev-containers-non-root.
  // "remoteUser": "root"
}


name: You can name your dev container anything you want. A default value is supplied.
image: The name of an image in a container registry (DockerHub, GitHub Container registry, or Azure Container Registry) that will be used to create the dev container for the codespace.
features: A list of one or more objects, each of which references one of the available dev container features. Features are self-contained, shareable units of installation code and development container configuration. They provide an easy way to add more tooling, runtime, or library features to your development container. You can add features either within VS Code or in the devcontainer.json editor on GitHub. For more information, click either the Visual Studio Code or Web browser tab in Adding features to a devcontainer.json file.
forwardPorts: Any ports listed here will be forwarded automatically. For more information, see Forwarding ports in your codespace.
portsAttributes - This property maps a specified port to one or more default options. For more information, see the dev containers specification on the Development Containers website.
postCreateCommand: Use this property to run commands after your codespace is created. This can be formatted as a string (as above), an array, or an object. For more information, see the dev containers specification on the Development Containers website.
customizations: This property allows you to customize a specific tool or service when it is used for working in a codespace. For example, you can configure specific settings and extensions for VS Code. For more information, see Supporting tools and services on the Development Containers website.
remoteUser: By default, you’re running as the vscode user, but you can optionally set this to root.

For a complete list of available properties, see the dev containers specification on the Development Containers website.
Additional dev container configuration files
If you are familiar with Docker, you may want to use a Dockerfile, or Docker Compose, to configure your codespace environment, in addition to the devcontainer.json file. You can do this by adding your Dockerfile or docker-compose.yml files alongside the devcontainer.json file. For more information, see Using Images, Dockerfiles, and Docker Compose on the Development Containers website.
Step 3: Modify your devcontainer.json file
With your dev container configuration added and a basic understanding of what everything does, you can now make changes to customize your environment further. In this example, you'll add properties that will:

Forward the port on which the application runs on the remote machine to your local machine.
Run dotnet restore, after the dev container is created, to restore the dependencies required by the application.
Automatically install a VS Code extension in this codespace.



In the devcontainer.json file, add a comma after the features property, and delete the two commented out lines about features.
JSONC  "features": {
    "ghcr.io/devcontainers/features/dotnet:1": {}
  },

  // Features to add to the dev container. More info: https://containers.dev/features.
  // "features": {},
  "features": {
    "ghcr.io/devcontainers/features/dotnet:1": {}
  },

  // Features to add to the dev container. More info: https://containers.dev/features.
  // "features": {},



Uncomment the forwardPorts property and change its value to port 5000 only.
JSONC// Use 'forwardPorts' to make a list of ports inside the container available locally.
"forwardPorts": [5000],
// Use 'forwardPorts' to make a list of ports inside the container available locally.
"forwardPorts": [5000],



Uncomment the postCreateCommand property.
JSONC// Use 'postCreateCommand' to run commands after the container is created.
"postCreateCommand": "dotnet restore",
// Use 'postCreateCommand' to run commands after the container is created.
"postCreateCommand": "dotnet restore",



Uncomment the customizations property and edit it as follows to install the "Code Spell Checker" VS Code extension.
JSONC// Configure tool-specific properties.
"customizations": {
  // Configure properties specific to VS Code.
  "vscode": {
    // Add the IDs of extensions you want installed when the container is created.
    "extensions": [
      "streetsidesoftware.code-spell-checker"
    ]
  }
}
// Configure tool-specific properties.
"customizations": {
  // Configure properties specific to VS Code.
  "vscode": {
    // Add the IDs of extensions you want installed when the container is created.
    "extensions": [
      "streetsidesoftware.code-spell-checker"
    ]
  }
}

The devcontainer.json file should now look similar to this, depending on which image you chose:
// For format details, see https://aka.ms/devcontainer.json. For config options, see the
// README at: https://github.com/devcontainers/templates/tree/main/src/dotnet
{
  "name": "C# (.NET)",
  // Or use a Dockerfile or Docker Compose file. More info: https://containers.dev/guide/dockerfile
  "image": "mcr.microsoft.com/devcontainers/dotnet:0-7.0",
  "features": {
    "ghcr.io/devcontainers/features/dotnet:1": {}
  },

  // Use 'forwardPorts' to make a list of ports inside the container available locally.
  "forwardPorts": [5000],
  // "portsAttributes": {
  //   "5001": {
  //     "protocol": "https"
  //   }
  // }

  // Use 'postCreateCommand' to run commands after the container is created.
  "postCreateCommand": "dotnet restore",

  // Configure tool-specific properties.
  "customizations": {
    // Configure properties specific to VS Code.
    "vscode": {
      // Add the IDs of extensions you want installed when the container is created.
      "extensions": [
        "streetsidesoftware.code-spell-checker"
      ]
    }
  }

  // Uncomment to connect as root instead. More info: https://aka.ms/dev-containers-non-root.
  // "remoteUser": "root"
}



Save your changes.


Access the VS Code Command Palette (Shift+Command+P / Ctrl+Shift+P), then start typing "rebuild". Click Codespaces: Rebuild Container.

Tip

You may occasionally want to perform a full rebuild to clear your cache and rebuild your container with fresh images. For more information, see Rebuilding the container in a codespace.
Rebuilding inside your codespace ensures your changes work as expected before you commit the changes to the repository. If something does result in a failure, you’ll be placed in a codespace with a recovery container that you can rebuild from to keep adjusting your container.

After the dev container is rebuilt, and your codespace becomes available again, the postCreateCommand will have been run, restoring the required dependencies, and the "Code Spell Checker" extension will be available for use.


Step 4: Run your application
In the previous section, you used the postCreateCommand to install a set of packages via the dotnet restore command. With the dependencies now installed, you can run the application.


Run the application by pressing F5 or entering dotnet watch run in the Terminal.


When the application starts, click the Ports tab, right-click port 5000 and click Open in Browser.



Step 5: Commit your changes
When you've made changes to your codespace, either new code or configuration changes, you'll want to commit your changes. Committing configuration changes to your repository ensures that anyone else who creates a codespace from this repository has the same configuration. Any customization you do, such as adding VS Code extensions, will be available to all users.
For this tutorial, you created a codespace from a template repository, so the code in your codespace is not yet stored in a repository. You can create a repository by publishing the current branch to GitHub.
For information, see Using source control in your codespace.
Next steps
You should now be able to add a custom dev container configuration to your own C# (.NET) project.
Here are some additional resources for more advanced scenarios.

Adding features to a devcontainer.json file
Managing your account-specific secrets for GitHub Codespaces
Managing GPG verification for GitHub Codespaces
Forwarding ports in your codespace\n\n\n\nCodespaces/Setting up your project/Adding a dev container configuration/Setting up a Java projectSetting up a Java project for GitHub CodespacesGet started with a Java project in GitHub Codespaces by creating a custom dev container configuration.In this articleIntroductionStep 1: Open the project in a codespaceStep 2: Add a dev container configurationStep 3: Modify your devcontainer.json fileStep 4: Run your applicationStep 5: Commit your changesNext stepsIntroduction
This guide shows you how to set up an example Java project in GitHub Codespaces using the Visual Studio Code web client. It will step you through the process of opening the project in a codespace, and adding and modifying a predefined dev container configuration.
After you complete this tutorial, you'll be able to add a dev container configuration to your own repository, using either the VS Code web client or the VS Code desktop application.
For more information about dev containers, see Introduction to dev containers.
Step 1: Open the project in a codespace


Sign in to GitHub.com, if you haven't already done so.


Go to https://github.com/microsoft/vscode-remote-try-java.


Click Use this template, then click Open in a codespace.



When you create a codespace, your project is created on a remote virtual machine that is dedicated to you. By default, the container for your codespace has many languages and runtimes, including Java. It also includes a set of commonly used tools such as Gradle, Maven, git, wget, rsync, openssh, and nano.
You can customize your codespace by adjusting the amount of vCPUs and RAM, adding dotfiles to personalize your environment, or by modifying the tools and scripts installed. For more information, see Customizing your codespace.
GitHub Codespaces uses a file called devcontainer.json to configure the development container that you use when you work in a codespace. Each repository can contain one or more devcontainer.json files, to give you exactly the development environment you need to work on your code in a codespace.
On launch, GitHub Codespaces uses a devcontainer.json file, and any dependent files that make up the dev container configuration, to install tools and runtimes, and perform other setup tasks that the project requires. For more information, see Introduction to dev containers.
Step 2: Add a dev container configuration
The default development container, or "dev container," for GitHub Codespaces will allow you to work successfully on a Java project like vscode-remote-try-java. However, we recommend that you configure your own dev container to include all of the tools and scripts your project needs. This will ensure a fully reproducible environment for all GitHub Codespaces users in your repository.
To set up your repository to use a custom dev container, you will need to create one or more devcontainer.json files. You can either add these from a predefined configuration template, in Visual Studio Code, or you can write your own. For more information on dev container configurations, see Introduction to dev containers.


Access the Visual Studio Code Command Palette (Shift+Command+P / Ctrl+Shift+P), then start typing "add dev". Click Codespaces: Add Dev Container Configuration Files.



Click Create a new configuration.


In this example, the template repository from which you created the codespace already contains a dev container configuration, so a message is displayed telling you that the configuration file already exists. We're going to overwrite the existing configuration file, so click Continue.


Click Show All Definitions.



Type java and click the Java option. Other options are available if your project uses particular tools. For example, Java & PostgreSQL.



Choose the version of Java you want to use for your project. In this case, select the version marked "(default)."



Select the option to Install Maven and click OK.



A list of additional features you can install is displayed. We'll install Ant, the Java library and command-line tool for building applications. To install this feature, type ant, select Ant (via SDKMAN), then click OK.



A message is displayed telling you that the dev container configuration file already exists. Click Overwrite.
A devcontainer.json file is created and is opened in the editor.


Details of your custom dev container configuration
If you look in the Visual Studio Code Explorer you'll see that a .devcontainer directory has been added to the root of your project's repository containing the devcontainer.json file. This is the main configuration file for codespaces created from this repository.
devcontainer.json
The devcontainer.json file that you have added will contain values for the name, image, and features properties. Some additional properties that you may find useful are included but are commented out.
The file will look similar to this, depending on which image you chose:
// For format details, see https://aka.ms/devcontainer.json. For config options, see the
// README at: https://github.com/devcontainers/templates/tree/main/src/java
{
  "name": "Java",
  // Or use a Dockerfile or Docker Compose file. More info: https://containers.dev/guide/dockerfile
  "image": "mcr.microsoft.com/devcontainers/java:0-17",

  "features": {
    "ghcr.io/devcontainers/features/java:1": {
      "version": "none",
      "installMaven": "true",
      "installGradle": "false"
    },
    "ghcr.io/devcontainers-contrib/features/ant-sdkman:2": {}
  }

  // Use 'forwardPorts' to make a list of ports inside the container available locally.
  // "forwardPorts": [],

  // Use 'postCreateCommand' to run commands after the container is created.
  // "postCreateCommand": "java -version",

  // Configure tool-specific properties.
  // "customizations": {},

  // Uncomment to connect as root instead. More info: https://aka.ms/dev-containers-non-root.
  // "remoteUser": "root"
}


name: You can name your dev container anything you want. A default value is supplied.
image: The name of an image in a container registry (DockerHub, GitHub Container registry, or Azure Container Registry) that will be used to create the dev container for the codespace.
features: A list of one or more objects, each of which references one of the available dev container features. Features are self-contained, shareable units of installation code and development container configuration. They provide an easy way to add more tooling, runtime, or library features to your development container. You can add features either within VS Code or in the devcontainer.json editor on GitHub. For more information, click either the Visual Studio Code or Web browser tab in Adding features to a devcontainer.json file.
forwardPorts: Any ports listed here will be forwarded automatically. For more information, see Forwarding ports in your codespace.
postCreateCommand: Use this property to run commands after your codespace is created. This can be formatted as a string (as above), an array, or an object. For more information, see the dev containers specification on the Development Containers website.
customizations: This property allows you to customize a specific tool or service when it is used for working in a codespace. For example, you can configure specific settings and extensions for VS Code. For more information, see Supporting tools and services on the Development Containers website.
remoteUser: By default, you’re running as the vscode user, but you can optionally set this to root.

For a complete list of available properties, see the dev containers specification on the Development Containers website.
Additional dev container configuration files
If you are familiar with Docker, you may want to use a Dockerfile, or Docker Compose, to configure your codespace environment, in addition to the devcontainer.json file. You can do this by adding your Dockerfile or docker-compose.yml files alongside the devcontainer.json file. For more information, see Using Images, Dockerfiles, and Docker Compose on the Development Containers website.
Step 3: Modify your devcontainer.json file
With your dev container configuration added and a basic understanding of what everything does, you can now make changes to customize your environment further. In this example, you'll add properties that will:

Run a command, after the dev container is created, to create a new file.
Automatically install two VS Code extensions in this codespace.



In the devcontainer.json file, add a comma after the features property.
JSON"features": {
  "ghcr.io/devcontainers/features/java:1": {
    "version": "none",
    "installMaven": "true",
    "installGradle": "false"
  },
  "ghcr.io/devcontainers-contrib/features/ant-sdkman:2": {}
},
"features": {
  "ghcr.io/devcontainers/features/java:1": {
    "version": "none",
    "installMaven": "true",
    "installGradle": "false"
  },
  "ghcr.io/devcontainers-contrib/features/ant-sdkman:2": {}
},



Uncomment the postCreateCommand property and change its value to echo \"This file was added by the postCreateCommand.\" > TEMP.md.
JSONC// Use 'postCreateCommand' to run commands after the container is created.
"postCreateCommand": "echo \"This file was added by the postCreateCommand.\" > TEMP.md",
// Use 'postCreateCommand' to run commands after the container is created.
"postCreateCommand": "echo \"This file was added by the postCreateCommand.\" > TEMP.md",



Uncomment the customizations property and edit it as follows to install the "Code Spell Checker" extension and the "Extension Pack for Java."
JSONC// Configure tool-specific properties.
"customizations": {
  // Configure properties specific to VS Code.
  "vscode": {
    // Add the IDs of extensions you want installed when the container is created.
    "extensions": [
      "streetsidesoftware.code-spell-checker",
      "vscjava.vscode-java-pack"
    ]
  }
}
// Configure tool-specific properties.
"customizations": {
  // Configure properties specific to VS Code.
  "vscode": {
    // Add the IDs of extensions you want installed when the container is created.
    "extensions": [
      "streetsidesoftware.code-spell-checker",
      "vscjava.vscode-java-pack"
    ]
  }
}



The devcontainer.json file should now look similar to this, depending on which image you chose:
// For format details, see https://aka.ms/devcontainer.json. For config options, see the
// README at: https://github.com/devcontainers/templates/tree/main/src/java
{
  "name": "Java",
  // Or use a Dockerfile or Docker Compose file. More info: https://containers.dev/guide/dockerfile
  "image": "mcr.microsoft.com/devcontainers/java:0-17",

  "features": {
    "ghcr.io/devcontainers/features/java:1": {
      "version": "none",
      "installMaven": "true",
      "installGradle": "false"
    },
    "ghcr.io/devcontainers-contrib/features/ant-sdkman:2": {}
  },

  // Use 'forwardPorts' to make a list of ports inside the container available locally.
  // "forwardPorts": [],

  // Use 'postCreateCommand' to run commands after the container is created.
  "postCreateCommand": "echo \"This file was added by the postCreateCommand.\" > TEMP.md",

  // Configure tool-specific properties.
  "customizations": {
    // Configure properties specific to VS Code.
    "vscode": {
      // Add the IDs of extensions you want installed when the container is created.
      "extensions": [
        "streetsidesoftware.code-spell-checker",
        "vscjava.vscode-java-pack"
      ]
    }
  }

  // Uncomment to connect as root instead. More info: https://aka.ms/dev-containers-non-root.
  // "remoteUser": "root"
}



Save your changes.


Access the VS Code Command Palette (Shift+Command+P / Ctrl+Shift+P), then start typing "rebuild". Click Codespaces: Rebuild Container.

Tip

You may occasionally want to perform a full rebuild to clear your cache and rebuild your container with fresh images. For more information, see Rebuilding the container in a codespace.
Rebuilding inside your codespace ensures your changes work as expected before you commit the changes to the repository. If something does result in a failure, you’ll be placed in a codespace with a recovery container that you can rebuild from to keep adjusting your container.

After the dev container is rebuilt, and your codespace becomes available again, the postCreateCommand will have been run, creating a TEMP.md file, and the two extensions will be available for use.


Step 4: Run your application


Run the application by pressing F5.


If a "toast" notification message is displayed at the bottom right corner of VS Code, asking whether you want to switch to standard mode, click Yes.



When the project files have been imported, click the Debug Console tab to see the program output.



Step 5: Commit your changes
When you've made changes to your codespace, either new code or configuration changes, you'll want to commit your changes. Committing configuration changes to your repository ensures that anyone else who creates a codespace from this repository has the same configuration. Any customization you do, such as adding VS Code extensions, will be available to all users.
For this tutorial, you created a codespace from a template repository, so the code in your codespace is not yet stored in a repository. You can create a repository by publishing the current branch to GitHub.
For information, see Using source control in your codespace.
Next steps
You should now be able to add a custom dev container configuration to your own Java project.
Here are some additional resources for more advanced scenarios.

Adding features to a devcontainer.json file
Managing your account-specific secrets for GitHub Codespaces
Managing GPG verification for GitHub Codespaces
Forwarding ports in your codespace\n\n\n\nCodespaces/Setting up your project/Adding a dev container configuration/Setting up a PHP projectSetting up a PHP project for GitHub CodespacesGet started with a PHP project in GitHub Codespaces by creating a custom dev container configuration.In this articleIntroductionStep 1: Open the project in a codespaceStep 2: Add a dev container configurationStep 3: Modify your devcontainer.json fileStep 4: Run your applicationStep 5: Commit your changesNext stepsIntroduction
This guide shows you how to set up an example PHP project in GitHub Codespaces using the Visual Studio Code web client. It will step you through the process of opening the project in a codespace, and adding and modifying a predefined dev container configuration.
After you complete this tutorial, you'll be able to add a dev container configuration to your own repository, using either the VS Code web client or the VS Code desktop application.
For more information about dev containers, see Introduction to dev containers.
Step 1: Open the project in a codespace


Sign in to GitHub.com, if you haven't already done so.


Go to https://github.com/microsoft/vscode-remote-try-php.


Click Use this template, then click Open in a codespace.



When you create a codespace, your project is created on a remote virtual machine that is dedicated to you. By default, the container for your codespace has many languages and runtimes including PHP. It also includes a common set of tools, such as Composer, XDebug, Apache, pecl, nvm, git, lynx, and curl.
You can customize your codespace by adjusting the amount of vCPUs and RAM, adding dotfiles to personalize your environment, or by modifying the tools and scripts installed. For more information, see Customizing your codespace.
GitHub Codespaces uses a file called devcontainer.json to configure the development container that you use when you work in a codespace. Each repository can contain one or more devcontainer.json files, to give you exactly the development environment you need to work on your code in a codespace.
On launch, GitHub Codespaces uses a devcontainer.json file, and any dependent files that make up the dev container configuration, to install tools and runtimes, and perform other setup tasks that the project requires. For more information, see Introduction to dev containers.
Step 2: Add a dev container configuration
The default development container, or "dev container," for GitHub Codespaces will allow you to work successfully on a PHP project like vscode-remote-try-php. However, we recommend that you configure your own dev container to include all of the tools and scripts your project needs. This will ensure a fully reproducible environment for all GitHub Codespaces users in your repository.
To set up your repository to use a custom dev container, you will need to create one or more devcontainer.json files. You can either add these from a predefined configuration template, in Visual Studio Code, or you can write your own. For more information on dev container configurations, see Introduction to dev containers.


Access the Visual Studio Code Command Palette (Shift+Command+P / Ctrl+Shift+P), then start typing "add dev". Click Codespaces: Add Dev Container Configuration Files.



Click Create a new configuration.


In this example, the template repository from which you created the codespace already contains a dev container configuration, so a message is displayed telling you that the configuration file already exists. We're going to overwrite the existing configuration file, so click Continue.


Click Show All Definitions.



Type php and click PHP. Other options are available if your project uses particular tools. For example, PHP & MariaDB.


Choose the version of PHP you want to use for your project. In this case, select the version marked "(default)."


A list of additional features you can install is displayed. We'll install GitHub CLI, a tool for interacting with GitHub from the command line. To install this tool, type github, select GitHub CLI, then click OK, then select Keep defaults.


A message is displayed telling you that the dev container configuration file already exists. Click Overwrite.
A devcontainer.json file is created and is opened in the editor.


Details of your custom dev container configuration
If you look in the Visual Studio Code Explorer you'll see that a .devcontainer directory has been added to the root of your project's repository containing the devcontainer.json file. This is the main configuration file for codespaces created from this repository.
devcontainer.json
The devcontainer.json file that you have added will contain values for the name, image, and features properties. Some additional properties that you may find useful are included but are commented out.
The file will look similar to this, depending on which image you chose:
// For format details, see https://aka.ms/devcontainer.json. For config options, see the
// README at: https://github.com/devcontainers/templates/tree/main/src/php
{
  "name": "PHP",
  // Or use a Dockerfile or Docker Compose file. More info: https://containers.dev/guide/dockerfile
  "image": "mcr.microsoft.com/devcontainers/php:1-8.2-bullseye",

  // Features to add to the dev container. More info: https://containers.dev/features.
  // "features": {},

  // Configure tool-specific properties.
  // "customizations": {},

  // Use 'forwardPorts' to make a list of ports inside the container available locally.
  "forwardPorts": [
    8080
  ],
  "features": {
    "ghcr.io/devcontainers/features/github-cli:1": {}
  }

  // Use 'postCreateCommand' to run commands after the container is created.
  // "postCreateCommand": "sudo chmod a+x \"$(pwd)\" && sudo rm -rf /var/www/html && sudo ln -s \"$(pwd)\" /var/www/html"

  // Uncomment to connect as root instead. More info: https://aka.ms/dev-containers-non-root.
  // "remoteUser": "root"
}


name: You can name your dev container anything you want. A default value is supplied.
image: The name of an image in a container registry (DockerHub, GitHub Container registry, or Azure Container Registry) that will be used to create the dev container for the codespace.
features: A list of one or more objects, each of which references one of the available dev container features. Features are self-contained, shareable units of installation code and development container configuration. They provide an easy way to add more tooling, runtime, or library features to your development container. You can add features either within VS Code or in the devcontainer.json editor on GitHub. For more information, click either the Visual Studio Code or Web browser tab in Adding features to a devcontainer.json file.
forwardPorts: Any ports listed here will be forwarded automatically. For more information, see Forwarding ports in your codespace.
postCreateCommand: Use this property to run commands after your codespace is created. This can be formatted as a string (as above), an array, or an object. For more information, see the dev containers specification on the Development Containers website.
customizations: This property allows you to customize a specific tool or service when it is used for working in a codespace. For example, you can configure specific settings and extensions for VS Code. For more information, see Supporting tools and services on the Development Containers website.
remoteUser: By default, you’re running as the vscode user, but you can optionally set this to root.
For a complete list of available properties, see the dev containers specification on the Development Containers website.

Additional dev container configuration files
If you are familiar with Docker, you may want to use a Dockerfile, or Docker Compose, to configure your codespace environment, in addition to the devcontainer.json file. You can do this by adding your Dockerfile or docker-compose.yml files alongside the devcontainer.json file. For more information, see Using Images, Dockerfiles, and Docker Compose on the Development Containers website.
Step 3: Modify your devcontainer.json file
With your dev container configuration added and a basic understanding of what everything does, you can now make changes to customize your environment further. In this example, you'll add properties that will:

Run composer install, after the dev container is created, to install the dependencies listed in a composer.json file.
Automatically install a VS Code extension in this codespace.



In the devcontainer.json file, delete the two commented-out lines about features:
// Features to add to the dev container. More info: https://containers.dev/features.
// "features": {},



Edit the customizations property as follows to install the "Composer" extension.
JSONC// Configure tool-specific properties.
"customizations": {
  // Configure properties specific to VS Code.
  "vscode": {
    "extensions": [
      "ikappas.composer"
    ]
  }
},
// Configure tool-specific properties.
"customizations": {
  // Configure properties specific to VS Code.
  "vscode": {
    "extensions": [
      "ikappas.composer"
    ]
  }
},



Add a comma after the features property.
"features": {
  "ghcr.io/devcontainers/features/github-cli:1": {}
},



Uncomment the postCreateCommand property and add some text to the end to run the command composer install if a composer.json file exists. (The existing commands are just some setup procedures that allow Apache to access the files in the workspace.)
JSONC// Use 'postCreateCommand' to run commands after the container is created.
"postCreateCommand": "sudo chmod a+x \"$(pwd)\" && sudo rm -rf /var/www/html && sudo ln -s \"$(pwd)\" /var/www/html; if [ -f composer.json ];then composer install;fi"
// Use 'postCreateCommand' to run commands after the container is created.
"postCreateCommand": "sudo chmod a+x \"$(pwd)\" && sudo rm -rf /var/www/html && sudo ln -s \"$(pwd)\" /var/www/html; if [ -f composer.json ];then composer install;fi"



The devcontainer.json file should now look similar to this, depending on which image you chose:
// For format details, see https://aka.ms/devcontainer.json. For config options, see the
// README at: https://github.com/devcontainers/templates/tree/main/src/php
{
  "name": "PHP",
  // Or use a Dockerfile or Docker Compose file. More info: https://containers.dev/guide/dockerfile
  "image": "mcr.microsoft.com/devcontainers/php:1-8.2-bullseye",

  // Configure tool-specific properties.
  "customizations": {
    // Configure properties specific to VS Code.
    "vscode": {
      "extensions": [
        "ikappas.composer"
      ]
    }
  },

  // Use 'forwardPorts' to make a list of ports inside the container available locally.
  "forwardPorts": [
    8080
  ],
  "features": {
    "ghcr.io/devcontainers/features/github-cli:1": {}
  },

  // Use 'postCreateCommand' to run commands after the container is created.
  "postCreateCommand": "sudo chmod a+x \"$(pwd)\" && sudo rm -rf /var/www/html && sudo ln -s \"$(pwd)\" /var/www/html; if [ -f composer.json ];then composer install;fi"

  // Uncomment to connect as root instead. More info: https://aka.ms/dev-containers-non-root.
  // "remoteUser": "root"
}



Save your changes.


Access the VS Code Command Palette (Shift+Command+P / Ctrl+Shift+P), then start typing "rebuild". Click Codespaces: Rebuild Container.

Tip

You may occasionally want to perform a full rebuild to clear your cache and rebuild your container with fresh images. For more information, see Rebuilding the container in a codespace.
Rebuilding inside your codespace ensures your changes work as expected before you commit the changes to the repository. If something does result in a failure, you’ll be placed in a codespace with a recovery container that you can rebuild from to keep adjusting your container.

After the dev container is rebuilt, and your codespace becomes available again, the postCreateCommand will have been run, installing any Composer dependencies, and the "Composer" extension will be available for use.


Step 4: Run your application
In the previous section, you modified the postCreateCommand to install a set of packages via the composer install command. With the dependencies now installed, you can run the application. However, in this scenario we first need to change the ports that Apache will listen on. We're forwarding port 8080, so we'll instruct Apache to use this port rather than the default port 80.


In the Terminal of your codespace, enter:
Shellsudo sed -i 's/Listen 80$//' /etc/apache2/ports.conf
sudo sed -i 's/Listen 80$//' /etc/apache2/ports.conf



Then, enter:
Shellsudo sed -i 's/<VirtualHost \*:80>/ServerName 127.0.0.1\n<VirtualHost \*:8080>/' /etc/apache2/sites-enabled/000-default.conf
sudo sed -i 's/<VirtualHost \*:80>/ServerName 127.0.0.1\n<VirtualHost \*:8080>/' /etc/apache2/sites-enabled/000-default.conf



Then start Apache using its control tool:
Shellapache2ctl start
apache2ctl start



When your project starts, you should see a "toast" notification message at the bottom right corner of VS Code, telling you that your application is available on a forwarded port. To view the running application, click Open in Browser.


Step 5: Commit your changes
When you've made changes to your codespace, either new code or configuration changes, you'll want to commit your changes. Committing configuration changes to your repository ensures that anyone else who creates a codespace from this repository has the same configuration. Any customization you do, such as adding VS Code extensions, will be available to all users.
For this tutorial, you created a codespace from a template repository, so the code in your codespace is not yet stored in a repository. You can create a repository by publishing the current branch to GitHub.
For information, see Using source control in your codespace.
Next steps
You should now be able to add a custom dev container configuration to your own PHP project.
Here are some additional resources for more advanced scenarios.

Adding features to a devcontainer.json file
Managing your account-specific secrets for GitHub Codespaces
Managing GPG verification for GitHub Codespaces
Forwarding ports in your codespace\n\n\n\nCodespaces/Setting up your project/Adding a dev container configuration/Setting up a Python projectSetting up a Python project for GitHub CodespacesGet started with a Python project in GitHub Codespaces by creating a custom dev container configuration.In this articleIntroductionStep 1: Open the project in a codespaceStep 2: Add a dev container configurationStep 3: Modify your devcontainer.json fileStep 4: Run your applicationStep 5: Commit your changesNext stepsIntroduction
This guide shows you how to set up an example Python project in GitHub Codespaces using the Visual Studio Code web client. It will step you through the process of opening the project in a codespace, and adding and modifying a predefined dev container configuration.
After you complete this tutorial, you'll be able to add a dev container configuration to your own repository, using either the VS Code web client or the VS Code desktop application.
For more information about dev containers, see Introduction to dev containers.
Step 1: Open the project in a codespace


Sign in to GitHub.com, if you haven't already done so.


Go to https://github.com/microsoft/vscode-remote-try-python.


Click Use this template, then click Open in a codespace.



When you create a codespace, your project is created on a remote virtual machine that is dedicated to you. By default, the container for your codespace has many languages and runtimes, including Python. It also includes a common set of tools like git, wget, rsync, openssh, and nano.
You can customize your codespace by adjusting the amount of vCPUs and RAM, adding dotfiles to personalize your environment, or by modifying the tools and scripts installed. For more information, see Customizing your codespace.
GitHub Codespaces uses a file called devcontainer.json to configure the development container that you use when you work in a codespace. Each repository can contain one or more devcontainer.json files, to give you exactly the development environment you need to work on your code in a codespace.
On launch, GitHub Codespaces uses a devcontainer.json file, and any dependent files that make up the dev container configuration, to install tools and runtimes, and perform other setup tasks that the project requires. For more information, see Introduction to dev containers.
Step 2: Add a dev container configuration
The default development container, or "dev container," for GitHub Codespaces comes with the latest Python version, package managers (pip, Miniconda), and other common tools preinstalled. However, we recommend that you configure your own dev container to include all of the tools and scripts your project needs. This will ensure a fully reproducible environment for all GitHub Codespaces users in your repository.
To set up your repository to use a custom dev container, you will need to create one or more devcontainer.json files. You can either add these from a predefined configuration template, in Visual Studio Code, or you can write your own. For more information on dev container configurations, see Introduction to dev containers.


Access the Visual Studio Code Command Palette (Shift+Command+P / Ctrl+Shift+P), then start typing "add dev". Click Codespaces: Add Dev Container Configuration Files.



Click Create a new configuration.


In this example, the template repository from which you created the codespace already contains a dev container configuration, so a message is displayed telling you that the configuration file already exists. We're going to overwrite the existing configuration file, so click Continue.


Click Show All Definitions.



Start typing python and click Python 3 in the list. Other options are available if your project uses particular tools. For example, Python 3 & PostgreSQL.



Choose the version of Python you want to use for your project. In this case, select the version marked "(default)."



A list of additional features is displayed. We'll install Coverage.py, a code coverage tool for Python. To install this tool, type py, select Coverage.py (via pipx), then click OK.



A message is displayed telling you that the dev container configuration file already exists. Click Overwrite.
A devcontainer.json file is created and is opened in the editor.


Details of your custom dev container configuration
If you look in the Visual Studio Code Explorer you'll see that a .devcontainer directory has been added to the root of your project's repository containing the devcontainer.json file. This is the main configuration file for codespaces created from this repository.
devcontainer.json
The devcontainer.json file that you have added will contain values for the name, image, and features properties. Some additional properties that you may find useful are included but are commented out.
The file will look similar to this, depending on which image you chose:
// For format details, see https://aka.ms/devcontainer.json. For config options, see the
// README at: https://github.com/devcontainers/templates/tree/main/src/python
{
  "name": "Python 3",
  // Or use a Dockerfile or Docker Compose file. More info: https://containers.dev/guide/dockerfile
  "image": "mcr.microsoft.com/devcontainers/python:0-3.11-bullseye",
  "features": {
    "ghcr.io/devcontainers-contrib/features/coverage-py:2": {}
  }

  // Features to add to the dev container. More info: https://containers.dev/features.
  // "features": {},

  // Use 'forwardPorts' to make a list of ports inside the container available locally.
  // "forwardPorts": [],

  // Use 'postCreateCommand' to run commands after the container is created.
  // "postCreateCommand": "pip3 install --user -r requirements.txt",

  // Configure tool-specific properties.
  // "customizations": {},

  // Uncomment to connect as root instead. More info: https://aka.ms/dev-containers-non-root.
  // "remoteUser": "root"
}


name: You can name your dev container anything you want. A default value is supplied.
image: The name of an image in a container registry (DockerHub, GitHub Container registry, or Azure Container Registry) that will be used to create the dev container for the codespace.
features: A list of one or more objects, each of which references one of the available dev container features. Features are self-contained, shareable units of installation code and development container configuration. They provide an easy way to add more tooling, runtime, or library features to your development container. You can add features either within VS Code or in the devcontainer.json editor on GitHub. For more information, click either the Visual Studio Code or Web browser tab in Adding features to a devcontainer.json file.
forwardPorts: Any ports listed here will be forwarded automatically. For more information, see Forwarding ports in your codespace.
postCreateCommand: Use this property to run commands after your codespace is created. This can be formatted as a string (as above), an array, or an object. For more information, see the dev containers specification on the Development Containers website.
customizations: This property allows you to customize a specific tool or service when it is used for working in a codespace. For example, you can configure specific settings and extensions for VS Code. For more information, see Supporting tools and services on the Development Containers website.
remoteUser: By default, you’re running as the vscode user, but you can optionally set this to root.

For a complete list of available properties, see the dev containers specification on the Development Containers website.
Additional dev container configuration files
If you are familiar with Docker, you may want to use a Dockerfile, or Docker Compose, to configure your codespace environment, in addition to the devcontainer.json file. You can do this by adding your Dockerfile or docker-compose.yml files alongside the devcontainer.json file. For more information, see Using Images, Dockerfiles, and Docker Compose on the Development Containers website.
Step 3: Modify your devcontainer.json file
With your dev container configuration added and a basic understanding of what everything does, you can now make changes to customize your environment further. In this example, you'll add properties that will:

Install a package required by the application.
Install a VS Code extension in this codespace.



In the devcontainer.json file, add a comma after the features property, and delete the two commented out lines about features.
JSON"features": {
  "ghcr.io/devcontainers-contrib/features/coverage-py:2": {}
},

// Features to add to the dev container. More info: https://containers.dev/features.
// "features": {},
"features": {
  "ghcr.io/devcontainers-contrib/features/coverage-py:2": {}
},

// Features to add to the dev container. More info: https://containers.dev/features.
// "features": {},



Uncomment the postCreateCommand property.
JSONC// Use 'postCreateCommand' to run commands after the container is created.
"postCreateCommand": "pip3 install --user -r requirements.txt",
// Use 'postCreateCommand' to run commands after the container is created.
"postCreateCommand": "pip3 install --user -r requirements.txt",



Uncomment the customizations property and edit it as follows to install the "Code Spell Checker" VS Code extension.
JSONC// Configure tool-specific properties.
"customizations": {
  // Configure properties specific to VS Code.
  "vscode": {
    // Add the IDs of extensions you want installed when the container is created.
    "extensions": [
      "streetsidesoftware.code-spell-checker"
    ]
  }
}
// Configure tool-specific properties.
"customizations": {
  // Configure properties specific to VS Code.
  "vscode": {
    // Add the IDs of extensions you want installed when the container is created.
    "extensions": [
      "streetsidesoftware.code-spell-checker"
    ]
  }
}

The devcontainer.json file should now look similar to this, depending on which image you chose:
// For format details, see https://aka.ms/devcontainer.json. For config options, see the
// README at: https://github.com/devcontainers/templates/tree/main/src/python
{
  "name": "Python 3",
  // Or use a Dockerfile or Docker Compose file. More info: https://containers.dev/guide/dockerfile
  "image": "mcr.microsoft.com/devcontainers/python:0-3.11-bullseye",
  "features": {
    "ghcr.io/devcontainers-contrib/features/coverage-py:2": {}
  },

  // Use 'forwardPorts' to make a list of ports inside the container available locally.
  // "forwardPorts": [],

  // Use 'postCreateCommand' to run commands after the container is created.
  "postCreateCommand": "pip3 install --user -r requirements.txt",

  // Configure tool-specific properties.
  "customizations": {
    // Configure properties specific to VS Code.
    "vscode": {
      // Add the IDs of extensions you want installed when the container is created.
      "extensions": [
        "streetsidesoftware.code-spell-checker"
      ]
    }
  }

  // Uncomment to connect as root instead. More info: https://aka.ms/dev-containers-non-root.
  // "remoteUser": "root"
}



Save your changes.


Access the VS Code Command Palette (Shift+Command+P / Ctrl+Shift+P), then start typing "rebuild". Click Codespaces: Rebuild Container.

Tip

You may occasionally want to perform a full rebuild to clear your cache and rebuild your container with fresh images. For more information, see Rebuilding the container in a codespace.
Rebuilding inside your codespace ensures your changes work as expected before you commit the changes to the repository. If something does result in a failure, you’ll be placed in a codespace with a recovery container that you can rebuild from to keep adjusting your container.

After the dev container is rebuilt, and your codespace becomes available again, the postCreateCommand will have been run, installing the package listed in the requirements.txt file, and the "Code Spell Checker" extension will be available for use.


Step 4: Run your application
In the previous section, you used the postCreateCommand to install a package for the Flask web framework. You can now use this to run the web application.


In the Terminal of your codespace, enter python -m flask run.



When your project starts, you should see a "toast" notification message at the bottom right corner of VS Code, telling you that your application is available on a forwarded port. To view the running application, click Open in Browser.



Step 5: Commit your changes
When you've made changes to your codespace, either new code or configuration changes, you'll want to commit your changes. Committing configuration changes to your repository ensures that anyone else who creates a codespace from this repository has the same configuration. Any customization you do, such as adding VS Code extensions, will be available to all users.
For this tutorial, you created a codespace from a template repository, so the code in your codespace is not yet stored in a repository. You can create a repository by publishing the current branch to GitHub.
For information, see Using source control in your codespace.
Next steps
You should now be able to add a custom dev container configuration to your own Python project.
Here are some additional resources for more advanced scenarios.

Adding features to a devcontainer.json file
Managing your account-specific secrets for GitHub Codespaces
Managing GPG verification for GitHub Codespaces
Forwarding ports in your codespace\n\n\n\nCodespaces/Setting up your project/Configuring dev containers/Set a minimum machine specSetting a minimum specification for codespace machinesYou can avoid under-resourced machine types being used for GitHub Codespaces for your repository.Who can use this feature?People with write permissions to a repository can create or edit the codespace configuration.In this articleOverviewSetting a minimum machine specificationFurther readingOverview
Each codespace that you create is hosted on a separate virtual machine. When you create a codespace from a repository, you can usually choose from different types of virtual machines. Each machine type has different resources (processor cores, memory, storage) and, by default, the machine type with the least resources is used. For more information, see Changing the machine type for your codespace.
If your project needs a certain level of compute power, you can configure GitHub Codespaces so that only machine types that meet these requirements can be used by default, or selected by users. You configure this in a devcontainer.json file.
Unpublished codespaces (codespaces created from a template that are not linked to a repository on GitHub) always run on a virtual machine with the same specifications. You can't change the machine type of an unpublished codespace.
Important

Access to some machine types may be restricted at the organization level. Typically this is done to prevent people choosing higher resourced machines that are billed at a higher rate. If your repository is affected by an organization-level policy for machine types you should make sure you don't set a minimum specification that would leave no available machine types for people to choose. For more information, see Restricting access to machine types.

Setting a minimum machine specification


You can configure the codespaces that are created for your repository by adding settings to a devcontainer.json file. If your repository doesn't already contain a devcontainer.json file, you can add one now. See Adding a dev container configuration to your repository.


Edit the devcontainer.json file, adding the hostRequirements property at the top level of the file, within the enclosing JSON object. For example:
JSON"hostRequirements": {
   "cpus": 8,
   "memory": "8gb",
   "storage": "32gb"
}
"hostRequirements": {
   "cpus": 8,
   "memory": "8gb",
   "storage": "32gb"
}

You can specify any or all of the options: cpus, memory, and storage.
To check the specifications of the GitHub Codespaces machine types that are currently available for your repository, step through the process of creating a codespace until you see the choice of machine types. For more information, see Creating a codespace for a repository.


Save the file and commit your changes to the required branch of the repository.
Now when you create a codespace for that branch of the repository, and you go to the creation configuration options, you will only be able to select machine types that match or exceed the resources you've specified.



Further reading

Introduction to dev containers\n\n\n\nCodespaces/Setting up your project/Configuring dev containers/Adding featuresAdding features to a devcontainer.json fileWith features, you can quickly add tools, runtimes, or libraries to your dev container configuration.Tool navigationVisual Studio CodeWeb browserFeatures are self-contained units of installation code and dev container configuration, designed to work across a wide range of base container images. You can use features to quickly add tools, runtimes, or libraries to your codespace image. For more information, see the available features and features specification on the Development Containers website.
You can add features to a devcontainer.json file from VS Code or from your repository on GitHub. Use the tabs in this article to display instructions for each of these ways of adding features.
Adding features to a devcontainer.json file



Navigate to your repository on GitHub, find your devcontainer.json file, and click  to edit the file.
If you don't already have a devcontainer.json file, you can create one now. For more information, see Introduction to dev containers.


To the right of the file editor, in the Marketplace tab, browse or search for the feature you want to add, then click the name of the feature.



Under "Installation," click the code snippet to copy it to your clipboard, then paste the snippet into the features object in your devcontainer.json file.

"features": {
     // ...
     "ghcr.io/devcontainers/features/terraform:1": {},
     // ...
 }



By default, the latest version of the feature will be used. To choose a different version, or configure other options for the feature, expand the properties listed under "Options" to view the available values, then add the options by manually editing the object in your devcontainer.json file.

"features": {
     // ...
     "ghcr.io/devcontainers/features/terraform:1": {
         "version": "1.1",
         "tflint": "latest"
     },
     // ...
 }



Commit the changes to your devcontainer.json file.


The configuration changes will take effect in new codespaces created from the repository. To make the changes take effect in existing codespaces, you will need to pull the updates to the devcontainer.json file into your codespace, then rebuild the container for the codespace. For more information, see Introduction to dev containers.


Note

To add features in VS Code while you are working locally, and not connected to a codespace, you must have the "Dev Containers" extension installed and enabled. For more information about this extension, see the VS Code Marketplace.



Access the VS Code Command Palette with Shift+Command+P (Mac) or Ctrl+Shift+P (Windows/Linux).


Start typing "add dev" then click Codespaces: Add Dev Container Configuration Files.



Click Modify your active configuration.


Update your feature selections, then click OK.


If you're working in a codespace, a prompt will appear in the lower-right corner. To rebuild the container and apply the changes to the codespace you're working in, click Rebuild Now.\n\n\n\nCodespaces/Setting up your project/Configuring dev containers/Automatically opening filesAutomatically opening files in the codespaces for a repositoryYou can set particular files to be opened automatically whenever someone creates a codespace for your repository and opens the codespace in the Visual Studio Code web client.Who can use this feature?People with write permissions to a repository can create or edit the codespace configuration.In this articleOverviewSetting files to be opened automaticallyFurther readingOverview
If there's a particular file that's useful for people to see when they create a codespace for your repository, you can set this file to be opened automatically in the VS Code web client. You set this up in the dev container configuration file for your repository.
The file, or files, you specify are only opened the first time a codespace is opened in the web client. If the person closes the specified files, those files are not automatically reopened the next time that person opens or restarts the codespace.
Note

This automation only applies to the VS Code web client, not to the VS Code desktop application, or other supported editors.

Setting files to be opened automatically


You can configure the codespaces that are created for your repository by adding settings to a devcontainer.json file. If your repository doesn't already contain a devcontainer.json file, you can add one now. See Adding a dev container configuration to your repository.


Edit the devcontainer.json file, adding a customizations.codespaces.openFiles property. The customizations property resides at the top level of the file, within the enclosing JSON object. For example:
JSON"customizations": {
  "codespaces": {
    "openFiles": [
      "README.md",
      "scripts/tsconfig.json",
      "docs/main/CODING_STANDARDS.md"
    ]
  }
}
"customizations": {
  "codespaces": {
    "openFiles": [
      "README.md",
      "scripts/tsconfig.json",
      "docs/main/CODING_STANDARDS.md"
    ]
  }
}

The value of the openFiles property is an array of one or more files in your repository. The paths are relative to the root of the repository (absolute paths are not supported). The files are opened in the web client in the order specified, with the first file in the array displayed in the editor.


Save the file and commit your changes to the required branch of the repository.


Further reading

Introduction to dev containers\n\n\n\nCodespaces/Setting up your project/Configuring dev containers/Specifying recommended secretsSpecifying recommended secrets for a repositoryYou can add a setting to your dev container configuration that will prompt people to set specific development environment secrets when they create a codespace.Who can use this feature?People with write permissions to a repository can create or edit the codespace configuration.In this articleAbout recommended secretsSpecifying recommended secrets in the dev container configurationFurther readingAbout recommended secrets
If a project needs user-specific secrets to be set up, you can prompt people to do this when they create a codespace. You do this by adding a setting to a dev container configuration file for the repository.
After you specify recommended secrets, if people have not already created those secrets in their personal settings for Codespaces, they will be prompted to do so when they use the advanced options method of creating a codespace. This is done on GitHub by clicking the  Code button, then clicking the Codespaces tab, then selecting  and clicking New with options.

Recommended secrets are listed at the bottom of the page.

Note

The names of the recommended secrets are only listed on this page when the container configuration on the selected branch specifies these secrets.

Each recommended secret is displayed in one of three ways:

If the person has not set the recommended secret in their Codespaces settings, an input box is displayed, allowing them to create the secret now. A description and link to more information are displayed if you have configured them. Entering a value is optional.
If the person has already created the recommended secret but has not associated it with this repository, they can select a checkbox to add this association. Doing so is optional.
If the person has already created the recommended secret and associated it with this repository, a preselected checkbox is displayed.

When to specify recommended secrets for a project
You should use recommended secrets for development environment secrets that the user who creates the codespace, rather than the owner of the repository or organization, must provide. For example, if you have a public project, and users must provide a personal API key to run the application in your project, you can specify a recommended secret so that users will be prompted to provide the key as the value of the secret when they use the advanced options page to create a codespace.
Alternatively, for development environment secrets that the owner of the repository or organization can provide, such as API keys shared across a team, you can set secrets at the level of the repository or organization. For more information, see Managing development environment secrets for your repository or organization.
Specifying recommended secrets in the dev container configuration


You can configure the codespaces that are created for your repository by adding settings to a devcontainer.json file. If your repository doesn't already contain a devcontainer.json file, you can add one now. See Adding a dev container configuration to your repository.


Edit the devcontainer.json file, adding the secrets property at the top level of the file, within the enclosing JSON object. For example:
JSON"secrets": {
  "NAME_OF_SECRET_1": {
    "description": "This is the description of the secret.",
    "documentationUrl": "https://example.com/link/to/info"
  },
  "NAME_OF_SECRET_2": { }
}
"secrets": {
  "NAME_OF_SECRET_1": {
    "description": "This is the description of the secret.",
    "documentationUrl": "https://example.com/link/to/info"
  },
  "NAME_OF_SECRET_2": { }
}



Add a property within secrets for each secret you want to recommend. For example, change NAME_OF_SECRET_1 and NAME_OF_SECRET_2, in the previous code example, to the names of the secrets that people should create in their personal settings for Codespaces.


Optionally, supply a description for each secret and a URL for more information about this secret.
You can omit description and documentationUrl, as shown by NAME_OF_SECRET_2 in the previous code example.


Specify additional secrets, as required.


Save the file and commit your changes to the required branch of the repository.


Further reading

Creating a codespace for a repository\n\n\n\nCodespaces/Setting up your project/Setting up your repository/Facilitating codespace creationFacilitating quick creation and resumption of codespacesYou can add a link to take people straight to a page for creating a codespace, with your choice of options preconfigured. Alternatively you can link to the "Resume codespace" page.In this articleOverviewCreating a link to the codespace creation page for your repositoryCreating a link to resume a codespaceCreating an "Open in GitHub Codespaces" badgeOverview
You can make it easy for people to work on your repository in a codespace by providing a link to the codespace creation page. One place you might want to do this is in the README file for your repository. For example, you can add the link to an "Open in GitHub Codespaces" badge.

The link to the codespace creation page can include specific configuration options to help people create an appropriate codespace. People who use the link will be able to choose different options, if they want, before creating the codespace. For information about the available options, see Creating a codespace for a repository.
Alternatively, you can link to the "Resume codespace" page, which provides a quick way for people to open a codespace they were working on recently.
Creating a link to the codespace creation page for your repository
You can use these URLs to link to the codespace creation page for your repository. Replace the text in uppercase letters.

Create a codespace for the default branch of the repository:
https://codespaces.new/OWNER/REPO-NAME
Create a codespace for a specific branch of the repository:
https://codespaces.new/OWNER/REPO-NAME/tree/BRANCH-NAME
Create a codespace for the topic branch of a pull request:
https://codespaces.new/OWNER/REPO-NAME/pull/PR-SHA

Configuring more options
You can use the "Share a deep link" option to configure more options for the codespace and build a custom URL, then copy a Markdown or HTML snippet for an "Open in GitHub Codespaces" badge.


On GitHub, navigate to the main page of the repository.


If you want to create a link for a branch other than the repository's default branch, under the repository name, click the button labeled with the name of the current branch. In the dropdown menu, select the branch for which you want to create a link.



Click the  Code button, then click the Codespaces tab.


To open the "Share codespace configuration" window, at the top right of the Codespaces tab, select , then click Share a deep link.



Optionally, to take users to a page where they can quickly resume a recent codespace or create a new one, select Quick start. For more information, see Creating a link to resume a codespace.


Optionally, to specify a dev container configuration, select Configuration file, then use the dropdown menu to choose a configuration. If you don't specify a configuration, the default configuration for your repository is used. For more information, see Introduction to dev containers.


Under "Snippets," you can copy the URL you have built, or copy a Markdown or HTML snippet including an "Open in GitHub Codespaces" badge. To copy the URL or snippet, select between the URL, HTML, and Markdown tabs, then click .



Creating a link to resume a codespace
You can create a link to a page for resuming your most recent codespace that matches the repository, branch, and other options specified in the URL.
Add ?quickstart=1 to a codespaces.new URL, such as the URLs listed in the previous section of this article. This produces a URL that displays a "Resume codespace" page.
For example, the URL https://codespaces.new/octo-org/octo-repo?quickstart=1 opens a page to allow you to resume your most recent codespace for the default branch of the octo-org/octo-repo repository.

Note


If the codespaces.new URL already contains a query string, add &quickstart=1 at the end of the query string.
This type of URL will always open a codespace in the VS Code web client, even if this is not set as your default editor for GitHub Codespaces.


If no matching codespaces are found, the page is titled "Create codespace" and a button is displayed for creating a new codespace with matching parameters.
This type of URL is useful, for instance, in a README for your repository as it gives people a way of either creating a codespace, or resuming their codespace, in just a couple of clicks.
Creating an "Open in GitHub Codespaces" badge
Tip

You can use the "Share a deep link" option to create a Markdown or HTML snippet that includes an "Open in GitHub Codespaces" badge with a custom URL. For more information, see Configuring more options.



Get the URL to the codespace creation page, or the "Resume codespace" page, as described in the previous sections.


Add the following Markdown to, for example, the README.md file of your repository:
Markdown[![Open in GitHub Codespaces](https://github.com/codespaces/badge.svg)](URL)
[![Open in GitHub Codespaces](https://github.com/codespaces/badge.svg)](URL)

For example:
[![Open in GitHub Codespaces](https://github.com/codespaces/badge.svg)](https://codespaces.new/github/docs)

The example Markdown is rendered like this:\n\n\n\nCodespaces/Setting up your project/Setting up your repository/Set up a template repoSetting up a template repository for GitHub CodespacesYou can help people get started with a project by setting up a template repository for use with GitHub Codespaces.In this articleIntroductionDescribe your templateAdd starter filesConfigure the dev containerIntroduction
By setting up a template repository, you can help people get started with your framework, library, or other project in GitHub Codespaces. Users will be able to start working with your template files immediately in a cloud-based development environment, without having to worry about cloning your repository or installing tools or other dependencies. With some configuration, you will be able to set users up in a codespace with important files already open for editing, and with an application already running in a preview browser tab within the VS Code web editor.
Anyone with read access to your template repository can create a codespace from the repository's page on GitHub. You can turn any existing repository into a template, and you do not have to change any settings to allow users to create a codespace from your template repository. For more information on turning a repository into a template, see Creating a template repository.
To help users find your template and get started quickly, you can share a link to the codespace creation page for the template. For example, you could provide this link in a tutorial for getting started with your framework. You can use the "share a deep link" option and select Quick start to build a link that takes users to a page where they can quickly create a new codespace or resume a recent one. For more information, see Facilitating quick creation and resumption of codespaces.
When someone creates a codespace from your template, the contents of your template repository will be cloned into their codespace. When the user is ready, they will be able to publish their work to a new repository on GitHub belonging to their personal account. For more information, see Creating a codespace from a template.
Organizations can pay for members of the organization and outside collaborators to use GitHub Codespaces at the organization's expense. This includes codespaces created from template repositories owned by the organization. However, if a user publishes a codespace created from a template to their personal account, ownership and billing of the codespace transfers to the user who created the codespace. For more information, see About billing for GitHub Codespaces.
Describe your template
If you don't have one, create a README for your template repository to describe the purpose of your template and how to get started with it. For more information, see About READMEs.
You can also provide a short description of your project by navigating to the repository's page and clicking  next to the About section on the right of the page.

Add starter files
Template repositories typically contain starter files with boilerplate code so users can quickly get started with a library, framework, or other technology.
For guidance on the kinds of files to include, you can look at the starter files included in the official GitHub templates for GitHub Codespaces, as follows.


In the top-left corner of GitHub, select , then click  Codespaces to take you to the "Your codespaces" page at github.com/codespaces.


To view the full list of templates, in the "Explore quick start templates" section, click See all.



To view the template repository that contains the files for the template, click the name of the template.



Configure the dev container
You can add dev container configuration files to your template repository to customize the development environment for people using your template with GitHub Codespaces. You can choose from a list of predefined configuration settings in Visual Studio Code, or you can create a custom configuration by writing your own devcontainer.json file. If you don't add configuration files, the default container image will be used. For more information, see Introduction to dev containers and Adding a dev container configuration to your repository.
Note

When users create codespaces from the Use this template button in a template repository, they will not be given a choice between configurations. The codespace will be built based on the default configuration defined in .devcontainer/devcontainer.json, or in .devcontainer.json at the root of your repository.

You should configure your dev container with the tools and customization to give users the best experience with your template. For example, in your devcontainer.json file:

You can use the openFiles property to define a list of files to be opened automatically in the VS Code web client when a codespace is created from your template.
If users need to provide personal secrets such as API keys to run the application in your template, you can prompt them to provide these secrets. For more information, see Specifying recommended secrets for a repository.
If your template contains files for a web application, you can make the application run automatically in the user's codespace. You can do this by using the postAttachCommand property to run a script that starts the application on a local server as soon as the VS Code web client connects to the codespace, and by setting the onAutoForward property of a port to openPreview to display the application running on that port in a simple browser embedded in the VS Code web client.

The following configuration settings for a React template will open the app.js file in the user's editor, run npm start (defined in a package.json file) to start a local server, and forward port 3000 to a preview browser tab in the codespace.
{
    "postAttachCommand": {
      "server": "npm start"
    },

    "portsAttributes": {
      "3000": {
        "label": "Application",
        "onAutoForward": "openPreview"
      }
    },

    "customizations": {
      "codespaces": {
        "openFiles": ["src/App.js"]
      }
    }
}

For more information, see Automatically opening files in the codespaces for a repository and the dev containers specification on the Development Containers website.\n\n\n\nCodespaces/Prebuilding your codespaces/About prebuildsAbout GitHub Codespaces prebuildsGitHub Codespaces prebuilds help to speed up the creation of new codespaces for large or complex repositories.Who can use this feature?You create and configure prebuilds in your repository's settings. Repository-level settings for GitHub Codespaces are available for all repositories owned by personal accounts. 
For repositories owned by organizations, repository-level settings for GitHub Codespaces are available for organizations on GitHub Team and GitHub Enterprise plans. To access the settings, the organization or its parent enterprise must have added a payment method and set a spending limit for GitHub Codespaces. For more information, see Choosing who owns and pays for codespaces in your organization and GitHub’s plans.In this articleOverviewThe prebuild processAbout pushing changes to prebuild-enabled branchesOverview
A prebuild assembles the main components of a codespace for a particular combination of repository, branch, and devcontainer.json configuration file. It provides a quick way to create a new codespace. For complex and/or large repositories in particular, you can create a new codespace more quickly by using a prebuild.
If it currently takes more than 2 minutes to create a codespace for a repository, you are likely to benefit from using prebuilds. This is because, with a prebuild, any source code, editor extensions, project dependencies, commands, and configurations have already been downloaded, installed, and applied before you create a codespace.
By default, whenever you push changes to your repository, GitHub Codespaces uses GitHub Actions to automatically update your prebuilds.
When prebuilds are available for a particular branch of a repository, a particular dev container configuration file, and for your region, you'll see the " Prebuild ready" label in the list of machine type options when you create a codespace. If a prebuild is still being created, you will see the " Prebuild in progress" label. For more information, see Creating a codespace for a repository.

When you create a codespace from a template on the "Your codespaces" page, GitHub may automatically use a prebuild to speed up creation time. For more information on templates, see Creating a codespace from a template.
Note

Each prebuild that's created consumes storage space that will either incur a billable charge or, for repositories owned by your personal GitHub account, will use some of your monthly included storage. For more information, see About billing for GitHub Codespaces.

The prebuild process
To create a prebuild, you set up a prebuild configuration. When you save the configuration, a GitHub Actions workflow runs to create each of the required prebuilds; one workflow per prebuild. Workflows also run whenever the prebuilds for your configuration need to be updated. This can happen at scheduled intervals, on pushes to a prebuild-enabled repository, or when you change the dev container configuration. For more information, see Configuring prebuilds.
When a prebuild configuration workflow runs, GitHub creates a temporary codespace, performing setup operations up to and including any onCreateCommand and updateContentCommand commands in the devcontainer.json file. No postCreateCommand commands are run during the creation of a prebuild. For more information about these commands, see the devcontainer.json reference in the VS Code documentation. A snapshot of the generated container is then taken and stored.
As with other GitHub Actions workflows, running a prebuild configuration workflow will either consume some of the GitHub Actions minutes included with your account, if you have any, or it will incur charges for GitHub Actions minutes. Storage of codespace prebuilds is billed in the same way as storage of active or stopped codespaces. For more information, see About billing for GitHub Codespaces.
When you create a codespace from a prebuild, GitHub downloads the existing container snapshot from storage and deploys it on a fresh virtual machine, completing the remaining commands specified in the dev container configuration. Since many operations have already been performed, such as cloning the repository, creating a codespace from a prebuild can be substantially quicker than creating one without a prebuild. This is true where the repository is large and/or onCreateCommand commands take a long time to run.
About pushing changes to prebuild-enabled branches
By default, each push to a branch that has a prebuild configuration results in a GitHub-managed GitHub Actions workflow run to update the prebuild. The prebuild workflow has a concurrency limit of one workflow run at a time for a given prebuild configuration, unless changes were made that affect the dev container configuration for the associated repository. For more information, see Introduction to dev containers. If a run is already in progress, the workflow run that was queued most recently will run next, after the current run completes.
With the prebuild set to be updated on each push, it means that if there are very frequent pushes to your repository, prebuild updates will occur at least as often as it takes to run the prebuild workflow. That is, if your workflow run typically takes one hour to complete, prebuilds will be created for your repository roughly hourly, if the run succeeds, or more often if there were pushes that change the dev container configuration on the branch.
For example, let's imagine 5 pushes are made, in quick succession, against a branch that has a prebuild configuration. In this situation:


A workflow run is started for the first push, to update the prebuild.


If the 4 remaining pushes do not affect the dev container configuration, the workflow runs for these are queued in a "pending" state.
If any of the remaining 4 pushes change the dev container configuration, then the service will not skip that one and will immediately run the prebuild creation workflow, updating the prebuild accordingly if it succeeds.


Once the first run completes, workflow runs for pushes 2, 3, and 4 will be canceled, and the last queued workflow (for push 5) will run and update the prebuild.\n\n\n\nCodespaces/Prebuilding your codespaces/Configure prebuildsConfiguring prebuildsYou can configure your project to prebuild a codespace automatically each time you push a change to your repository.Who can use this feature?People with admin access to a repository can configure prebuilds for the repository.Repository-level settings for GitHub Codespaces are available for all repositories owned by personal accounts. 
For repositories owned by organizations, repository-level settings for GitHub Codespaces are available for organizations on GitHub Team and GitHub Enterprise plans. To access the settings, the organization or its parent enterprise must have added a payment method and set a spending limit for GitHub Codespaces. For more information, see Choosing who owns and pays for codespaces in your organization and GitHub’s plans.In this articlePrerequisitesConfiguring prebuildsConfiguring environment variablesConfiguring time-consuming tasks to be included in the prebuildFurther readingYou can set up a prebuild configuration for the combination of a specific branch of your repository with a specific dev container configuration file.
Any branches created from a prebuild-enabled parent branch will typically also get prebuilds for the same dev container configuration. This is because prebuilds for child branches that use the same dev container configuration as the parent branch are, for the most part, identical, so developers can benefit from faster codespace creation times on those branches also. See Introduction to dev containers.
Typically, when you configure prebuilds for a branch, prebuilds will be available for multiple machine types. However, if your repository is greater than 32 GB, prebuilds won't be available for 2-core and 4-core machine types, since the storage these provide is limited to 32 GB.
Prerequisites
Prebuilds are created using GitHub Actions. As a result, GitHub Actions must be enabled for the repository for which you are configuring prebuilds. See Managing GitHub Actions settings for a repository.
You can set up prebuilds in any repository owned by a personal account. The prebuild will consume storage space that will either incur a billable charge or, for repositories owned by your personal account, will use some of your monthly included storage.
Note

If you create prebuilds for a forked repository, the storage cost of those prebuilds is subtracted from your monthly included storage, while available. If you have used all of your included storage, and you have set up billing, your personal account will be billed. This is true even when the codespaces you create for a fork are paid for by the organization that owns the parent repository. See About billing for GitHub Codespaces.

For repositories owned by an organization, you can set up prebuilds if the organization is on a GitHub Team or GitHub Enterprise plan. Additionally, you must have added a payment method and set a spending limit for GitHub Codespaces on the organization account or its parent enterprise. See Managing the spending limit for GitHub Codespaces and GitHub’s plans.
Configuring prebuilds


On GitHub, navigate to the main page of the repository.


Under your repository name, click  Settings. If you cannot see the "Settings" tab, select the  dropdown menu, then click Settings.



In the "Code & automation" section of the side bar, click  Codespaces.


In the "Prebuild configuration" section of the page, click Set up prebuild.



Choose the branch for which you want to set up prebuilds.

Note

Any branches created from a prebuild-enabled base branch will typically also get prebuilds for the same dev container configuration. For example, if you enable prebuilds for a dev container configuration file on the default branch of the repository, branches based on the default branch will, in most cases, also get prebuilds for the same dev container configuration.



Optionally, in the Configuration file dropdown menu that's displayed, choose the devcontainer.json configuration file that you want to use for your prebuilds. See Introduction to dev containers.



Choose how you want to automatically trigger prebuild updates.


Every push (the default setting) - With this setting, prebuilds will be updated on every push made to the given branch. This will ensure that codespaces generated from a prebuild always contain the latest codespace configuration, including any recently added or updated dependencies.


On configuration change - With this setting, prebuilds will be updated every time any of the following files is changed:


.devcontainer/devcontainer.json
Note

Prebuild updates are not triggered by changes to devcontainer.json files within subdirectories of .devcontainer.



The Dockerfile referenced in the build.dockerfile property of the .devcontainer/devcontainer.json file.


This setting ensures that changes to the dev container configuration files for the repository are used when a codespace is generated from a prebuild. The GitHub Actions workflow that updates the prebuilds will run less often, so this option will use fewer GitHub Actions minutes. However, this option will not guarantee that codespaces always include recently added or updated dependencies, so these may have to be added or updated manually after a codespace has been created.


Scheduled - With this setting, you can have your prebuilds updated on a custom schedule that's defined by you. This can reduce consumption of GitHub Actions minutes, however, with this option, codespaces may be created that do not use the latest dev container configuration changes.





Optionally, select Reduce prebuild available to only specific regions to create prebuilds only in specified regions. Select the regions in which you want prebuilds to be available.
By default, prebuilds are created in all of the available regions, incurring storage charges per prebuild.

Note


The prebuild in each region incurs individual storage charges. You should, therefore, only enable prebuilds for regions in which you know they'll be used. See About billing for GitHub Codespaces.
Developers can set their default region for GitHub Codespaces, which can allow you to enable prebuilds for fewer regions. See Setting your default region for GitHub Codespaces.




Optionally, under Template history, set the number of prebuild versions to be retained. You can input any number between 1 and 5. The default number of saved versions is 2, which means that only the latest prebuild and the previous version are saved.

Depending on your prebuild trigger settings, your prebuild could change with each push or on each dev container configuration change. Retaining older versions of prebuilds enables you to create a prebuild from an older commit with a different dev container configuration than the current prebuild. This setting allows you to set the number of retained versions to a level that is appropriate for your needs.
If you set the number of prebuild versions to save to 1, GitHub Codespaces will only save the latest version of the prebuild and will delete the older version each time the template is updated. This means you will not get a prebuilt codespace if you go back to an older dev container configuration.
There is a storage cost associated with each prebuild version that's retained. For example, if you are generating prebuilds in 4 regions and retaining 2 versions, you will be charged for storage of up to 8 prebuilds. See About billing for GitHub Codespaces.


Optionally, add users or teams to notify when the prebuild workflow run fails for this configuration. You can begin typing a username, team name, or full name, then click the name once it appears to add them to the list. The users or teams you add will receive an email when prebuild failures occur, containing a link to the workflow run logs to help with further investigation.

Note

People will only receive notifications of failed prebuilds if they have enabled notifications for failed Actions workflows in their personal settings. See Configuring notifications.



Optionally, at the bottom of the page, click Show advanced options.

In the "Advanced options" section, if you select Disable prebuild optimization, codespaces will be created without a prebuild if the latest prebuild workflow has failed or is currently running. See Troubleshooting prebuilds.


Click Create.
If the dev container configuration for the repository specifies permissions for accessing other repositories, you will be shown an authorization page. For more information on how this is specified in the devcontainer.json file, see Managing access to other repositories within your codespace.
Click  to view the details of the requested permissions.

Click Authorize and continue to grant these permissions for creation of prebuilds. Alternatively, you can click Continue without authorizing but, if you do so, codespaces created from the resulting prebuilds may not work properly.
Note

Users who create codespaces using this prebuild will also be asked to grant these permissions.



After you create a prebuild configuration it is listed on the GitHub Codespaces page of your repository settings. A GitHub Actions workflow is queued and then run to create prebuilds in the regions you specified, based on the branch and dev container configuration file you selected.

For information about editing and deleting prebuild configurations, see Managing prebuilds.
Configuring environment variables
To allow the prebuild process to access environment variables required to create your development environment, you can set these either as Codespaces repository secrets or as Codespaces organization secrets. Secrets that you create in this way will be accessible by anyone who creates a codespace from this repository. See Managing development environment secrets for your repository or organization.
Prebuilds cannot use any user-level secrets while building your environment, because these are not available until after the codespace has been created.
Configuring time-consuming tasks to be included in the prebuild
You can use the onCreateCommand and updateContentCommand commands in your devcontainer.json to include time-consuming processes as part of the prebuild creation. See the Visual Studio Code documentation, devcontainer.json reference.
onCreateCommand is run only once, when the prebuild is created, whereas updateContentCommand is run at creation of the prebuild and at subsequent updates to it. Incremental builds should be included in updateContentCommand since they represent the source of your project and need to be included for every prebuild update.
Further reading

Allowing a prebuild to access other repositories
Troubleshooting prebuilds\n\n\n\nCodespaces/Prebuilding your codespaces/Allow external repo accessAllowing a prebuild to access other repositoriesYou can permit your prebuild to access other GitHub repositories so that it can be built successfully.Who can use this feature?People with admin access to a repository can configure prebuilds for the repository.Repository-level settings for GitHub Codespaces are available for all repositories owned by personal accounts. 
For repositories owned by organizations, repository-level settings for GitHub Codespaces are available for organizations on GitHub Team and GitHub Enterprise plans. To access the settings, the organization or its parent enterprise must have added a payment method and set a spending limit for GitHub Codespaces. For more information, see Choosing who owns and pays for codespaces in your organization and GitHub’s plans.In this articleAllowing a prebuild read access to external resourcesAllowing a prebuild write access to external resourcesFurther readingBy default, the GitHub Actions workflow for a prebuild configuration can only access its own repository contents. Your project may use additional resources, located elsewhere, to build the development environment.
Allowing a prebuild read access to external resources
You can configure read access to other GitHub repositories, with the same repository owner, by specifying permissions in the devcontainer.json file used by your prebuild configuration. For more information, see Managing access to other repositories within your codespace.
Note


You can only authorize read permissions in this way, and the owner of the target repository must be the same as the owner of the repository for which you're creating a prebuild. For example, if you're creating a prebuild configuration for the octo-org/octocatrepository, then you'll be able to grant read permissions for other repositories, such as octo-org/octodemo, if this is specified in the devcontainer.json file, and provided you have the permissions yourself.
You can't use wildcards to specify repositories. You must define permissions for each repository for which you want to grant access.


When you create or edit a prebuild configuration for a devcontainer.json file that sets up read access to other repositories with the same repository owner, you'll be prompted to grant these permissions when you click Create or Update. For more information, see Configuring prebuilds.
Allowing a prebuild write access to external resources
If your project requires write access to resources, or if the external resources reside in a repository with a different owner than the repository for which you are creating a prebuild configuration, you can use a personal access token to grant this access.
You will need to create a new personal account and then use this account to create a personal access token (classic) with the appropriate scopes.


Create a new personal account on GitHub.
Warning

Although you can generate the personal access token (classic) using your existing personal account, we strongly recommend creating a new account with access only to the target repositories required for your scenario. This is because the access token's repository permission grants access to all of the repositories that the account has access to. For more information, see Creating an account on GitHub and Security hardening for GitHub Actions.



Give the new account read access to the required repositories. For more information, see Managing an individual's access to an organization repository.


While signed into the new account, create a personal access token (classic) with the repo scope. Optionally, if the prebuild will need to download packages from the GitHub Container registry, also select the read:packages scope. For more information, see Managing your personal access tokens.

If the prebuild will use a package from the GitHub Container registry, you will need to either grant the new account access to the package or configure the package to inherit the access permissions of the repository you are prebuilding. For more information, see Configuring a package's access control and visibility.


Copy the token string. You will assign this to a Codespaces repository secret.


Sign back into the account that has admin access to the repository.


In the repository for which you want to create GitHub Codespaces prebuilds, create a new Codespaces repository secret called CODESPACES_PREBUILD_TOKEN, giving it the value of the token you created and copied. For more information, see Managing development environment secrets for your repository or organization.


The personal access token will be used for all subsequent prebuilds created for your repository. Unlike other Codespaces repository secrets, the CODESPACES_PREBUILD_TOKEN secret is only used for prebuilding and will not be available for use in codespaces created from your repository.
Further reading

Configuring prebuilds
Troubleshooting prebuilds\n\n\n\nCodespaces/Prebuilding your codespaces/Manage prebuildsManaging prebuildsYou can review, modify, and delete the prebuild configurations for your repository.Who can use this feature?Repository-level settings for GitHub Codespaces are available for all repositories owned by personal accounts. 
For repositories owned by organizations, repository-level settings for GitHub Codespaces are available for organizations on GitHub Team and GitHub Enterprise plans. To access the settings, the organization or its parent enterprise must have added a payment method and set a spending limit for GitHub Codespaces. For more information, see Choosing who owns and pays for codespaces in your organization and GitHub’s plans.In this articleAbout managing prebuildsViewing the progress of prebuildsEditing a prebuild configurationDisabling a prebuild configurationDeleting a prebuild configurationManually trigger prebuildsFurther readingAbout managing prebuilds
The prebuilds that you configure for a repository are created and updated using a GitHub Actions workflow, managed by the GitHub Codespaces service.
Depending on the settings in a prebuild configuration, the workflow to update the prebuild may be triggered by these events:

Creating or updating the prebuild configuration
Pushing a commit or a pull request to a branch that's configured to have prebuilds
Changing any of the dev container configuration files
A schedule that you've defined in the prebuild configuration
Manually triggering the workflow

The settings in the prebuild configuration determine which events automatically trigger an update of the prebuild. See Configuring prebuilds.
People with admin access to a repository can check the progress of prebuilds, edit, and delete prebuild configurations.
To locate all repositories that are hosting a prebuild configuration, you must obtain a copy of your usage report by following the steps for Viewing your GitHub Codespaces usage.
Viewing the progress of prebuilds
You can view the current status of the latest workflow run for each prebuild configuration you've set up on the GitHub Codespaces page of your repository settings. For example, "Currently running" or "Last run 1 hour ago."
To see the log output for the latest prebuild workflow run, click See output.

This displays the output of the most recent run of the workflow in the Actions tab.

Alternatively, to view all prebuild workflow runs associated with the specified branch, select the  dropdown menu and click View runs.

This displays the workflow run history for prebuilds for the associated branch.

Editing a prebuild configuration


On the Codespaces page of your repository settings, click the ellipsis to the right of the prebuild configuration you want to edit.


In the dropdown menu, click Edit.



Make the required changes to the prebuild configuration, then click Update.
If the dev container configuration for the repository specifies permissions for accessing other repositories, you will be shown an authorization page. For more information on how this is specified in the devcontainer.json file, see Managing access to other repositories within your codespace.
Click  to view the details of the requested permissions.

Click Authorize and continue to grant these permissions for creation of prebuilds. Alternatively, you can click Continue without authorizing but, if you do so, codespaces created from the resulting prebuilds may not work properly.
Note

Users who create codespaces using this prebuild will also be asked to grant these permissions.



Disabling a prebuild configuration
To pause the update of prebuilds for a configuration, you can disable workflow runs for the configuration. Disabling the workflow runs for a prebuild configuration does not delete any previously created prebuilds for that configuration and, as a result, codespaces will continue to be generated from an existing prebuild.
Disabling the workflow runs for a prebuild configuration is useful if you need to investigate prebuild creation failures.


On the Codespaces page of your repository settings, click the ellipsis to the right of the prebuild configuration you want to disable.


In the dropdown menu, click Disable runs.



To confirm that you want to disable this configuration, click OK.


Deleting a prebuild configuration
Note

You can find a list of the repositories that contain a prebuild by obtaining a copy of your “usage report.”

Deleting a prebuild configuration also deletes all previously created prebuilds for that configuration. As a result, shortly after you delete a configuration, prebuilds generated by that configuration will no longer be available when you create a new codespace.
After you delete a prebuild configuration, workflow runs for that configuration that have been queued or started will still run. They will be listed in the workflow run history, along with previously completed workflow runs.


On the Codespaces page of your repository settings, click the ellipsis to the right of the prebuild configuration you want to delete.


In the dropdown menu, click Delete.



Click OK to confirm the deletion.


Manually trigger prebuilds
It may be useful to manually trigger a workflow run for a prebuild configuration. Generally, this is only necessary if you are debugging a problem with the workflow for a prebuild configuration.


On the Codespaces page of your repository settings, click the ellipsis to the right of the prebuild configuration whose workflow you want to trigger.


In the dropdown menu, click Manually trigger.



Further reading

Troubleshooting prebuilds\n\n\n\nCodespaces/Prebuilding your codespaces/Test dev container changesTesting dev container configuration changes on a prebuild-enabled branchWhen you change the dev container configuration for a branch that's enabled for prebuilds, you should test your changes in a codespace.Who can use this feature?People with write permissions to a repository can create or edit the dev container configuration for a branch.Any changes you make to the dev container configuration for a prebuild-enabled branch will result in an update to the codespace configuration and the associated prebuild. It’s therefore important to test such changes in a codespace from a test branch before committing your changes to a branch of your repository that's actively used. This will ensure you’re not introducing breaking changes for your team.
For more information, see Introduction to dev containers.
Testing changes to the dev container configuration


Create a codespace from the prebuild-enabled branch whose dev container you want to change. For more information, see Creating a codespace for a repository.


In the codespace, check out a test branch. For more information, see Using source control in your codespace.


Make the required changes to the dev container configuration.


Apply the changes by rebuilding the container. For more information, see Introduction to dev containers.


After everything looks good, we also recommend creating a new codespace from your test branch to ensure everything is working. You can then commit your changes to your repository's default branch or an active feature branch, triggering an update of the prebuild for that branch.
Note

Creating this codespace will take longer than usual because it will not be created from a prebuild.\n\n\n\nCodespaces/Managing your codespaces/Codespaces secretsManaging your account-specific secrets for GitHub CodespacesYou can store sensitive information, like tokens, that you want to access in your codespaces via environment variables.In this articleAbout secrets for GitHub CodespacesAdding a secretEditing a secretDeleting a secretUsing secretsFurther readingAbout secrets for GitHub Codespaces
You can add development environment secrets to your personal account that you want to use in your codespaces. For example, you may want to store and access the following sensitive information as secrets:

Access tokens to cloud services
Service principals
Subscription identifiers
Credentials for a private image registry (for more information, see Allowing your codespace to access a private registry)

You can choose which repositories should have access to each secret. Then, you can use the secret in any codespace you create for a repository that has access to the secret. To share a secret with a codespace created from a template, you will need to publish the codespace to a repository on GitHub, then give that repository access to the secret.
Once you have created a secret, it will be available when you create a new codespace or restart the codespace. If you've created a secret on GitHub and you want to use it in a currently running codespace, stop the codespace and then restart it. For information about stopping the codespace, see Using the Visual Studio Code Command Palette in GitHub Codespaces.
Naming secrets
The following rules apply to secret names:

Secret names can only contain alphanumeric characters ([a-z], [A-Z], [0-9]) or underscores (_). Spaces are not allowed.
Secret names must not start with the GITHUB_ prefix.
Secret names must not start with a number.
Secret names are not case-sensitive.
Secret names must be unique at the level they are created at. For example, a secret created at the repository level must have a unique name in that repository.

If a secret with the same name exists at multiple levels, the secret at the lowest level takes precedence. For example, if an organization-level secret has the same name as a repository-level secret, then the repository-level secret takes precedence.
Limits for secrets
You can store up to 100 secrets for GitHub Codespaces.
Secrets are limited to 48 KB in size.
Adding a secret


In the upper-right corner of any page on GitHub, click your profile photo, then click  Settings.


In the "Code, planning, and automation" section of the sidebar, click  Codespaces.


To the right of "Codespaces secrets", click New secret.


Under "Name," type a name for your secret.


Under "Value", type the value of your secret.


Select the "Repository access" drop-down menu, then click a repository you want to have access to the secret. Repeat for every repository you want to have access to the secret.



Click Add secret.


Editing a secret
You can update the value of an existing secret, and you can change which repositories can access a secret.


In the upper-right corner of any page on GitHub, click your profile photo, then click  Settings.


In the "Code, planning, and automation" section of the sidebar, click  Codespaces.


Under "Codespaces secrets," to the right of the secret you want to edit, click Update.


Under "Value," click the link "enter a new value."



Under "Value", type the value of your secret.


Select the "Repository access" drop-down menu, then click a repository you want to have access to the secret. Repeat for every repository you want to have access to the secret.



Optionally, to remove the secret's access to a repository, deselect the repository.



Click Save changes.


Deleting a secret

In the upper-right corner of any page on GitHub, click your profile photo, then click  Settings.
In the "Code, planning, and automation" section of the sidebar, click  Codespaces.
Under "Codespaces secrets," to the right of the secret you want to delete, click Delete.
Read the warning, then click OK.

Using secrets
A development environment secret is exported as an environment variable into the user's terminal session.

You can use development environment secrets after the codespace is built and is running. For example, a secret can be used:

When launching an application from the integrated terminal or ssh session.
Within a dev container lifecycle script that is run after the codespace is running. For more information about dev container lifecycle scripts, see the documentation on the Development Containers website: Specification.

Development environment secrets cannot be used:

During codespace build time (that is, within a Dockerfile or custom entry point).
Within a dev container feature. For more information, see the features property in the dev containers specification on the Development Containers website.

Further reading

Managing development environment secrets for your repository or organization
Creating a codespace for a repository
Setting your user preferences
Customizing your codespace\n\n\n\nCodespaces/Managing your codespaces/Repository accessManaging access to other repositories within your codespaceYou can manage the repositories that GitHub Codespaces can access.In this articleOverviewCreating codespaces with custom permissionsSetting additional repository permissionsAuthorizing requested permissionsFurther readingOverview
By default, your codespace is assigned a token scoped with read permission or read and write permission to the repository from which it was created. The scope of this token changes automatically in the following circumstances.

If you create a codespace for a repository to which you only have read access, then make a commit in the codespace or push a new branch, GitHub Codespaces automatically links your codespace to a new or existing fork of the repository and updates the token to have read and write permission to the fork. For more information, see Using source control in your codespace.
If you create a codespace from a template, then publish the codespace to a new repository, GitHub Codespaces updates the token to have read and write permission to the new repository. For more information, see Creating a codespace from a template.

For more information, see Security in GitHub Codespaces.
If your project needs additional permissions for other repositories, you can configure this in the devcontainer.json file, as described in Setting additional repository permissions later in this article. When permissions are listed in the devcontainer.json file, you will be prompted to review and authorize the additional permissions as part of codespace creation for that repository. Once you've authorized the listed permissions, GitHub Codespaces will remember your choice and will not prompt you for authorization unless the permissions in the devcontainer.json file change.
Note

Updating the permissions in the devcontainer.json file does not change the permissions of existing codespaces. If you need additional permissions in an existing codespace, see Troubleshooting authentication to a repository.

Creating codespaces with custom permissions
To create a codespace with custom permissions, you must use one of the following:

The GitHub web UI
GitHub CLI 2.5.2 or later
GitHub Codespaces Visual Studio Code extension 1.5.3 or later

Setting additional repository permissions
You configure repository permissions for GitHub Codespaces in a devcontainer.json file. Any custom permissions you add or change will only apply to new codespaces created after your changes have been committed to the repository. If you add or change permissions from within a codespace those permissions will not apply to the current codespace, even if you rebuild the codespace.


If your repository does not already contain a devcontainer.json file, add one now. For more information, see Adding a dev container configuration to your repository.


Edit the devcontainer.json file, adding the repository name and permissions needed to the repositories object:
JSON{
  "customizations": {
    "codespaces": {
      "repositories": {
        "my_org/my_repo": {
          "permissions": {
            "issues": "write"
          }
        }
      }
    }
  }
}
{
  "customizations": {
    "codespaces": {
      "repositories": {
        "my_org/my_repo": {
          "permissions": {
            "issues": "write"
          }
        }
      }
    }
  }
}

Note


You can only reference repositories that belong to the same personal account or organization as the repository you are currently working in.
You can use the * wildcard to grant permissions to multiple repositories in an organization. For example, to grant permissions to all repositories in the my_org organization use my_org/*. This syntax is only valid for codespaces. In any devcontainer.json files that are used for prebuilds, you must define permissions for each repository separately. For more information, see Allowing a prebuild to access other repositories.


You can grant as many or as few of the following permissions for each repository listed:

actions - read / write
checks - read / write
contents - read / write
deployments - read / write
discussions - read / write
issues - read / write
packages - read
pages - read / write
pull_requests - read / write
repository_projects - read / write
statuses - read / write
workflows - write

To set a permission for a repository in an organization, you must explicitly add that repository name in the repositories object.
{
  "customizations": {
    "codespaces": {
      "repositories": {
        "my_org/my_repo": {
          "permissions": {
            "issues": "write"
          }
        }
      }
    }
  }
}

To set all permissions for a given repository, use "permissions": "read-all" or "permissions": "write-all" in the repository object.
{
  "customizations": {
    "codespaces": {
      "repositories": {
        "my_org/my_repo": {
          "permissions": "write-all"
        }
      }
    }
  }
}



Authorizing requested permissions
If additional repository permissions are defined in the devcontainer.json file, you will be prompted to review and optionally authorize the permissions when you create a codespace or a prebuild configuration for this repository. When you authorize permissions for a repository, GitHub Codespaces will not re-prompt you unless the set of requested permissions has changed for the repository.

You should only authorize permissions for repositories you know and trust. If you don't trust the set of requested permissions, click Continue without authorizing to create the codespace with the base set of permissions. Rejecting additional permissions may impact the functionality of your project within the codespace as the codespace will only have access to the repository from which it was created.
You can only authorize permissions that your personal account already possesses. If a codespace requests permissions for repositories that you don't currently have access to, contact an owner or admin of the repository to obtain sufficient access and then try to create a codespace again.
Further reading

Setting your user preferences
Customizing your codespace\n\n\n\nCodespaces/Managing your codespaces/Security logsReviewing your security logs for GitHub CodespacesYou can use the security log to review all actions related to GitHub Codespaces.In this articleAbout security logs for GitHub CodespacesFurther readingAbout security logs for GitHub Codespaces
When you perform an action related to GitHub Codespaces in repositories owned by your personal account, you can review the actions in the security log. For information about accessing the log, see Reviewing your security log.

The security log includes details on what action occurred and when you performed it. For information about GitHub Codespaces actions, see Reviewing your security log.
Further reading

Reviewing your organization's audit logs for GitHub Codespaces
GitHub Codespaces logs
Setting your user preferences
Customizing your codespace\n\n\n\nCodespaces/Managing your codespaces/GPG verificationManaging GPG verification for GitHub CodespacesYou can allow GitHub to automatically use GPG to sign commits you make in your codespaces, so other people can be confident that the changes come from a trusted source.In this articleAbout GPG verification in GitHub CodespacesEnabling or disabling GPG verificationFurther readingAbout GPG verification in GitHub Codespaces
After you enable GPG verification, GitHub will automatically sign commits you make in GitHub Codespaces, and the commits will have a verified status on GitHub. For more information about GitHub-signed commits, see About commit signature verification.
By default, GPG verification is disabled for codespaces you create. If you enable GPG verification, your commits are signed in repositories that you trust.
Your list of trusted repositories for GitHub Codespaces is shared between the GPG verification and Settings Sync features. Assuming you have both features enabled, if you have added a selected list of trusted repositories for GPG verification, Settings Sync is turned on in codespaces created from these repositories. If you trust a new repository for Settings Sync, GPG verification is enabled for the same repository. Although the features share the same list of trusted repositories, you can enable or disable GPG verification and Settings Sync independently.
Note

If you have previously enabled GPG verification for all repositories, we recommend changing your preferences to use a selected list of trusted repositories. For more information, see Security in GitHub Codespaces.

For more information about managing your preferences for Settings Sync, see Personalizing GitHub Codespaces for your account.
Note

If you have linked a dotfiles repository with GitHub Codespaces, the Git configuration in your dotfiles may conflict with the configuration that GitHub Codespaces requires to sign commits. For more information, see Troubleshooting GPG verification for GitHub Codespaces.

Enabling or disabling GPG verification


In the upper-right corner of any page on GitHub, click your profile photo, then click  Settings.


In the "Code, planning, and automation" section of the sidebar, click  Codespaces.


On the page that's displayed, under "GPG verification," enable or disable GPG verification by selecting or deselecting Enable.


To change your trusted repositories for GPG verification and Settings Sync, under "Trusted repositories," either select All repositories, or select Selected repositories and use the "Select repositories" dropdown to add repositories you trust.
Note

We recommend using a selected list of trusted repositories. For more information, see Security in GitHub Codespaces.



Once you enable GPG verification, it will automatically take effect in any new codespaces you create from the relevant repositories. To have GPG verification take effect in an existing active codespace, you will need to stop and restart the codespace. For more information, see Stopping and starting a codespace.
Further reading

Setting your user preferences
Customizing your codespace\n\n\n\nCodespaces/Managing your organization/Enable or disable CodespacesEnabling or disabling GitHub Codespaces for your organizationYou can control which users can use GitHub Codespaces in your organization's private repositories.Who can use this feature?Organization owners can control which users can use GitHub Codespaces.Organizations on GitHub Team and GitHub Enterprise plans can choose to disable GitHub Codespaces in private repositories. For more information, see GitHub’s plans.In this articleAbout enabling and disabling GitHub CodespacesPrerequisites for enabling GitHub CodespacesAbout changing your settingsEnabling or disabling GitHub CodespacesAbout enabling and disabling GitHub Codespaces
GitHub Codespaces is always available in an organization's public repositories, and any user can create a codespace from these repositories. If your organization is on a GitHub Free plan, GitHub Codespaces is always available in your organization's private repositories too, and any users with access to these repositories can create a codespace at their own expense.
If you're the owner of an organization on a GitHub Team or GitHub Enterprise Cloud plan, you can choose whether to enable or disable GitHub Codespaces in your organization's private repositories. If you enable GitHub Codespaces in these repositories, you can choose whether to enable for all users or for a selection of members and collaborators.
By enabling GitHub Codespaces, you can help your members and collaborators get started with projects quickly, without needing to install lots of tools and dependencies locally to start contributing. However, you might want to roll out GitHub Codespaces gradually across your organization by enabling it for groups of users at a time. Alternatively, if you need to comply with security regulations that require increased control over the private code in your organization, you might want to disable GitHub Codespaces for all your members.
If you have enabled GitHub Codespaces in private repositories for at least some users, you can choose to pay for these users' usage of GitHub Codespaces across all repositories in your organization. For more information, see Choosing who owns and pays for codespaces in your organization.
If you cannot access the settings to enable GitHub Codespaces in your organization, this may be because an enterprise owner has disabled GitHub Codespaces for your organization. For more information, see Enforcing policies for GitHub Codespaces in your enterprise in the GitHub Enterprise Cloud documentation.
Prerequisites for enabling GitHub Codespaces
Only people who can either push changes to a repository, or fork the repository, can create a codespace for that repository. To allow a user to create codespaces for a repository owned by your organization, you must do one of the following things.

Ensure that the user has read access to the repository, and the repository permits forking, so that the user can create a codespace from the repository, push their changes to a fork, and create a pull request for any changes they want to make. For more information, see Managing the forking policy for your organization.
Ensure that the user has write access to the repository, so that they can push changes directly to the repository without forking.

In addition, to allow users to create codespaces, you must ensure that your organization does not have an IP address allow list enabled. For more information, see Managing allowed IP addresses for your organization in the GitHub Enterprise Cloud documentation.
Note

If you are a verified educator or a teacher, you must enable GitHub Codespaces from a GitHub Classroom to use your Codespaces Education benefit. For more information, see Using GitHub Codespaces with GitHub Classroom.

About changing your settings
If you remove a user's access to GitHub Codespaces, the user will immediately be unable to open existing codespaces they have created from your organization's private repositories. If you were previously paying for codespaces the user had created from your organization's public repositories, ownership of these codespaces will transfer the user.
Before removing users' access, you should alert the affected users. If they have unpublished work in a codespace, they can make sure the work is pushed to a branch in the repository before they lose access.
Once a user loses access to a codespace, the codespace is retained for a period of 7 days, then it is permanently deleted. During this 7-day period, to recover unpublished work from the codespace, the user must contact us through the GitHub Support portal.
Enabling or disabling GitHub Codespaces
Note

If you remove a user's access to GitHub Codespaces, the user will immediately be unable to open existing codespaces they have created from your organization's private repositories. For more information, see About changing your settings.



In the upper-right corner of GitHub, select your profile photo, then click  Your organizations.


Next to the organization, click Settings.


In the left sidebar, click  Codespaces.


Under  Codespaces, in the left sidebar, click General.


On the Codespaces settings page, under "Codespaces access," select your preferred setting for GitHub Codespaces in your organization's private repositories.
You can disable Codespaces, enable for specific members or teams, enable for all members, or enable for all members and collaborators.\n\n\n\nCodespaces/Managing your organization/Billing and ownershipChoosing who owns and pays for codespaces in your organizationYou can choose whether codespaces are paid for and owned by your organization or by your members.Who can use this feature?Organization owners can change an organization's billing details and control who owns and pays for codespaces.Organizations on GitHub Team and GitHub Enterprise plans can pay for their members' use of GitHub Codespaces. These organizations can then access policies that apply to codespaces paid for by the organization. See GitHub’s plans.In this articleOverviewAbout choosing who pays for codespacesAbout ownership of codespacesAbout changing your settingsChoosing who owns and pays for codespacesSetting a spending limitOverview
If you're the owner of an organization on a GitHub Team or GitHub Enterprise Cloud plan, you can pay for your members' and collaborators' usage of GitHub Codespaces. Paying for usage will allow people to use GitHub Codespaces to work in your repositories without having to do so at their own expense and will give your organization more control over the codespaces created from your repositories.
To pay for usage, you must do all of the following things:

Allow at least some of your members and collaborators to use GitHub Codespaces in your organization's private repositories. See Enabling or disabling GitHub Codespaces for your organization.
Choose for codespaces created from your organization's repositories to be organization-owned. See Choosing who owns and pays for codespaces.
Set a non-zero spending limit for GitHub Codespaces. See Managing the spending limit for GitHub Codespaces.

About choosing who pays for codespaces
Paying for a codespace means paying for the storage and compute costs of the codespace over the codespace's lifetime. See About billing for GitHub Codespaces.
Organizations on a GitHub Free plan cannot pay for GitHub Codespaces, so the user who creates the codespace always pays.
For organizations on a GitHub Team or GitHub Enterprise Cloud plan, when a user creates a codespace from a repository in the organization, either the user or the organization can pay for the codespace. The user who creates a codespace can't choose who pays for it, but the organization can choose to pay for certain users. In an organization's settings, you can choose for codespaces to be user-owned or organization-owned.
If an organization chooses for codespaces to be user-owned, a user who creates a codespace from a repository in the organization always pays for the codespace. The user's access to create codespaces depends on the visibility of the repository and your organization's access settings.
If an organization chooses for codespaces to be organization-owned, the organization will pay for a codespace if all the following things are true:

The organization has set a non-zero spending limit for GitHub Codespaces.
The codespace is created from one of the organization's repositories, or from a fork of one of the organization's repositories. This includes both public and private repositories.
The user creating the codespace is a member or collaborator of the organization, and the organization has enabled GitHub Codespaces for this user. This can include all members and collaborators if the organization has chosen to enable Codespaces for all users. If Codespaces isn't enabled for a user, they can still create codespaces from public repositories in the organization, but the user will pay for these codespaces.

For more information about enabling GitHub Codespaces for members and collaborators, see Enabling or disabling GitHub Codespaces for your organization.
About ownership of codespaces
A codespace is paid for by the account that owns it. The codespace owner can be the user who created the codespace, or it can be an organization.
If your organization owns a codespace, your organization has control over that codespace. For example, for codespaces owned by your organization, you can:

Use the REST API to manage codespaces, such as stopping or deleting a codespace
Access audit logs to review actions related to GitHub Codespaces
Set policies to manage constraints, such as restricting the dev container image or machine type that can be used in codespaces, or setting a default timeout and retention period

If a user owns a codespace, your organization does not have any of these options for managing the codespace, even if the codespace was created from one of your organization's repositories.
When a user creates a codespace, they're told who will pay for it, and therefore who owns it. From a user's point of view, apart from the policies your organization can use to set constraints on codespaces, the experience with GitHub Codespaces will be similar regardless of who owns a codespace. For example, most of a user's personal settings for GitHub Codespaces, such as dotfiles, secrets, and GPG verification, apply regardless of who owns the codespace.
About changing your settings
When you change your ownership settings, existing codespaces can transfer to a new owner.
If you change from organization ownership to user ownership, codespaces that are currently owned by your organization will be transferred to the ownership of the user who created the codespace. Before you make this change, you should ask each user to review the codespaces that will be transferred to their ownership. These codespaces will now incur usage on the user's personal account.
If you change from user ownership to organization ownership, existing codespaces may be transferred to your organization's ownership. A codespace will be transferred if the user who currently owns the codespace is a member or collaborator, and you have enabled GitHub Codespaces for this user. Otherwise, a codespace will remain under the ownership of the user.
Choosing who owns and pays for codespaces
Note

If you cannot access the option to make codespaces organization-owned, this may be because you have disabled GitHub Codespaces for all users in your organization's private repositories. See About choosing who pays for codespaces.



In the upper-right corner of GitHub, select your profile photo, then click  Your organizations.


Next to the organization, click Settings.


In the left sidebar, click  Codespaces.


Under  Codespaces, in the left sidebar, click General.


On the Codespaces settings page, under "Codespace ownership," select the setting you want for your organization:

Organization ownership: Codespaces can be owned and paid for by your organization.
User ownership: Codespaces are always owned and paid for by the user who creates the codespace.



Optionally, under "Codespaces access," review the members and collaborators for whom you have enabled Codespaces. These are the only users who can create codespaces that your organization pays for. See Enabling or disabling GitHub Codespaces for your organization.


Setting a spending limit
Note
 You must set a non-zero spending limit on your personal, organization, or enterprise account before the account can be billed for use of GitHub Codespaces.

By default, all accounts have a GitHub Codespaces spending limit of $0 USD. This prevents new codespaces being created, or existing codespaces being opened, if doing so would incur a billable cost to your personal, organization, or enterprise account. For personal accounts, if you have access to create a codespace, you can do so as long as the account has not reached the limit of its monthly included usage. For organizations and enterprises, the default spending limit means that, to allow people to create codespaces that are billed to the organization, or its parent enterprise, the limit must be changed to a value above $0 USD.
For information on managing and changing your account's spending limit, see Managing the spending limit for GitHub Codespaces.\n\n\n\nCodespaces/Managing your organization/List organization codespacesListing the codespaces in your organizationYou can list all of the currently active or stopped codespaces for your organization.Who can use this feature?To list all of the current codespaces for your organization, you must be an organization owner.Organizations on GitHub Team and GitHub Enterprise plans can pay for members' and collaborators' use of GitHub Codespaces. These organizations can then access settings and policies to manage codespaces paid for by the organization. For more information, see Choosing who owns and pays for codespaces in your organization and GitHub’s plans.Overview
As an organization owner, you can list all of the currently active and stopped codespaces for your organization. You might want to do this to check how many codespaces users are creating, to make sure they aren't incurring unnecessary costs. For information about pricing, see About billing for GitHub Codespaces.
The easiest way to list the codespaces for an organization is by using GitHub CLI. You can also use the REST API, which provides more information about each codespace.
For information on how to see the current total Codespaces usage for your organization or enterprise, and generate a detailed report, see Viewing your GitHub Codespaces usage.
Using GitHub CLI to list codespaces
To list all of the current codespaces for a specified organization, use the following command.
Shellgh codespace list --org ORGANIZATION
gh codespace list --org ORGANIZATION

This command returns a list that includes the following information for each codespace:

The name and display name
The user who created the codespace
The repository and branch
The current state of the codespace

To list all of the current codespaces for an organization that were created by a specific user, use the following command.
Shellgh codespace list --org ORGANIZATION --user USER
gh codespace list --org ORGANIZATION --user USER

Note

In the above commands, replace ORGANIZATION with the name of the organization you are querying. You must be an owner of the organization.

Using the REST API to list codespaces
You can use the /orgs/{org}/codespaces API endpoint as an alternative method of listing the current codespaces for an organization. This returns more information than GitHub CLI; for example, the machine type details.
For more information about this endpoint, see REST API endpoints for Codespaces organizations.\n\n\n\nCodespaces/Managing your organization/Manage Codespaces costsManaging the cost of GitHub Codespaces in your organizationYou can check your GitHub Codespaces usage and set usage limits.Who can use this feature?To manage billing for GitHub Codespaces for an organization, you must be an organization owner or a billing manager.Organizations on GitHub Team and GitHub Enterprise plans can pay for members' and collaborators' use of GitHub Codespaces. These organizations can then access settings and policies to manage codespaces paid for by the organization. For more information, see Choosing who owns and pays for codespaces in your organization and GitHub’s plans.In this articleOverviewSpending limitsDisabling or limiting billing for CodespacesDeleting unused codespacesFurther readingOverview
Your organization is billed according to its compute and storage usage for GitHub Codespaces. This article explains the ways in which you, as an organization owner, can manage these costs.
To learn about pricing for GitHub Codespaces, see About billing for GitHub Codespaces.
Spending limits
You can set a spending limit for GitHub Codespaces for your organization. This limit is applied to the total compute and storage cost for GitHub Codespaces. For more information, see Managing the spending limit for GitHub Codespaces.


Compute usage: This is the total time during which all GitHub Codespaces instances ("codespaces") were active in a billing month.


Storage usage: For GitHub Codespaces billing purposes, this includes all files used by all codespaces and prebuilds in your account. This includes resources such as cloned repositories, configuration files, and extensions, among others.


You can check the compute and storage usage for GitHub Codespaces for the current billing month. For information, see Viewing your GitHub Codespaces usage.
Note

Prebuilds for GitHub Codespaces are created and updated using GitHub Actions. This may incur billable costs for GitHub Actions. You can set a spending limit for GitHub Actions. For more information, see About billing for GitHub Codespaces and Managing your spending limit for GitHub Actions. Storage of the generated prebuilds is charged at the same rate as your codespaces, and is included in your GitHub Codespaces spending limit.

Disabling or limiting billing for Codespaces
You can choose for all usage of Codespaces in your organization to be billed to the user who creates the codespace. Alternatively, you can specify which organization members or collaborators can use Codespaces at your organization's expense. For more information, see Choosing who owns and pays for codespaces in your organization.
You can limit the number of codespaces that people can create, where the organization will be billed for the codespace. This can help to reduce codespace storage charges for your organization. For more information, see Restricting the number of organization-billed codespaces a user can create.
You can configure which repositories can be accessed from codespaces created for a particular repository. For more information, see Managing access to other repositories within your codespace.
You can limit the choice of types of machine that are available for codespaces created from repositories owned by your organization. This allows you to prevent people using overly resourced machines for their codespaces, and incurring unnecessary charges. For more information, see Restricting access to machine types.
You can set a maximum idle timeout constraint to limit the maximum timeout that people can set for codespaces that are billable to your organization. This can reduce the compute usage charges generated by codespaces that are left running in an idle state, by stopping active codespace after a shorter timeout period. For more information, see Restricting the idle timeout period.
You can also restrict how long stopped codespaces can remain unused before they are automatically deleted. This can help to reduce storage costs for Codespaces. For more information, see Restricting the retention period for codespaces.
Repository owners who set up prebuilds for their repository can reduce the storage costs of prebuilds by configuring these to be created only in selected regions. For more information, see Configuring prebuilds.
Deleting unused codespaces
Your users can delete their own codespaces in https://github.com/codespaces and from within Visual Studio Code. To reduce the size of a codespace, users can manually delete files using the terminal or from within VS Code.
As an organization owner, you can delete any codespace in your organization. For more information, see Deleting a codespace.
Note

Codespaces are automatically deleted after they have been stopped and have remained inactive for a user-definable number of days. For more information, see Configuring automatic deletion of your codespaces. As an organization owner, you can set the maximum retention period for codespaces owned by your organization. This will override a user's personal retention setting. For more information, see Restricting the retention period for codespaces.

Further reading

Listing the codespaces in your organization\n\n\n\nCodespaces/Managing your organization/Manage secretsManaging development environment secrets for your repository or organizationDevelopment environment secrets allow you to store sensitive information in your organization or repository for use with GitHub Codespaces.Who can use this feature?To manage development environment secrets for GitHub Codespaces for an organization, you must be an organization owner.Development environment secrets are available in all public repositories, in private repositories owned by personal accounts, and in private repositories owned by organizations on GitHub Team or GitHub Enterprise plans. For more information, see GitHub’s plans.In this articleAbout secretsAdding secrets for a repositoryAdding secrets for an organizationReviewing access to organization-level secretsFurther readingAbout secrets
Development environment secrets are encrypted environment variables that you create in the GitHub Codespaces settings for an organization, a repository, or a personal account. This article explains how to manage organization secrets and repository secrets. For information on creating user-specific secrets, see Managing your account-specific secrets for GitHub Codespaces.
The development environment secrets that you create are available to use in GitHub Codespaces. GitHub uses a libsodium sealed box to encrypt secrets before they reach GitHub and only decrypts them when you use them in a codespace.
Organization secrets let you share secrets between multiple repositories, which reduces the need to create duplicate secrets. You can use access policies to control which repositories can use organization secrets.
Once you have created a secret, it will be available when you create a new codespace or restart the codespace. If you've created a secret on GitHub and you want to use it in a currently running codespace, stop the codespace and then restart it. For information about stopping the codespace, see Using the Visual Studio Code Command Palette in GitHub Codespaces.
Naming secrets
The following rules apply to secret names:


Secret names can only contain alphanumeric characters ([a-z], [A-Z], [0-9]) or underscores (_). Spaces are not allowed.


Secret names must not start with the GITHUB_ prefix.


Secret names must not start with a number.


Secret names are not case-sensitive.


Secret names must be unique at the level they are created at. For example, a secret created at the repository level must have a unique name in that repository, and a secret created at the organization level must have a unique name at that level.
If a secret with the same name exists at multiple levels, the secret at the lowest level takes precedence. For example, if an organization-level secret has the same name as a repository-level secret, then the repository-level secret takes precedence.


Limits for secrets
You can store up to 100 secrets per organization and 100 secrets per repository.
Secrets are limited to 48 KB in size.
Recommended secrets for a repository
Your project may require specific user secrets. For example, to run the application in a codespace, the user may need to supply a personal API key. If this is the case, you can specify recommended secrets in the dev container configuration. The user will then be prompted to supply values for these secrets, if they haven't already created these personal secrets, when they use the advanced options page to create a codespace. If the user supplies a secret value for use in the codespace, this secret is added to their personal settings for Codespaces. They will not have to enter a value for this secret when they create a codespace for this repository in future. For more information, see Specifying recommended secrets for a repository.
Adding secrets for a repository
To create development environment secrets for an organization repository, you must have administrator access.


On GitHub, navigate to the main page of the repository.


Under your repository name, click  Settings. If you cannot see the "Settings" tab, select the  dropdown menu, then click Settings.



In the "Security" section of the sidebar, select  Secrets and variables, then click Codespaces.


At the top of the page, click New repository secret.


Type a name for your secret in the Name input box.


Enter the value for your secret.


Click Add secret.


Adding secrets for an organization
When creating a development environment secret in an organization, you can use a policy to limit which repositories can access that secret. For example, you can grant access to all repositories, or limit access to only private repositories or a specified list of repositories.
To create secrets at the organization level, you must have admin access.


On GitHub, navigate to the main page of the organization.


Under your organization name, click  Settings. If you cannot see the "Settings" tab, select the  dropdown menu, then click Settings.



In the "Security" section of the sidebar, select  Secrets and variables, then click Codespaces.


At the top of the page, click New secret.


Type a name for your secret in the Name input box.


Enter the Value for your secret.


From the Repository access dropdown list, choose an access policy.


Click Add secret.


Reviewing access to organization-level secrets
You can check which access policies are applied to a development environment secret in your organization.


On GitHub, navigate to the main page of the organization.


Under your organization name, click  Settings. If you cannot see the "Settings" tab, select the  dropdown menu, then click Settings.



In the "Security" section of the sidebar, select  Secrets and variables, then click Codespaces.


Optionally, to view or edit the configured permissions for each secret, to the right of the secret, click .


Further reading

Managing your account-specific secrets for GitHub Codespaces\n\n\n\nCodespaces/Managing your organization/Audit logsReviewing your organization's audit logs for GitHub CodespacesYou can use the audit log to review all actions related to GitHub Codespaces.Who can use this feature?Organizations on GitHub Team and GitHub Enterprise plans can pay for members' and collaborators' use of GitHub Codespaces. These organizations can then access settings and policies to manage codespaces paid for by the organization. For more information, see Choosing who owns and pays for codespaces in your organization and GitHub’s plans.When any member of your organization performs an action related to GitHub Codespaces, you can review the actions in the audit log. For information about accessing the log, see Reviewing the audit log for your organization.

The audit log includes details such as who performed the action, what the action was, and when the action was performed. For information on GitHub Codespaces actions, see Audit log events for your organization.
Further reading

Reviewing your security logs for GitHub Codespaces
GitHub Codespaces logs\n\n\n\nCodespaces/Managing your organization/Restrict machine typesRestricting access to machine typesYou can set constraints on the types of machines users can choose when they create codespaces in your organization.Who can use this feature?To manage access to machine types for the repositories in an organization, you must be an owner of the organization.Organizations on GitHub Team and GitHub Enterprise plans can pay for members' and collaborators' use of GitHub Codespaces. These organizations can then access settings and policies to manage codespaces paid for by the organization. For more information, see Choosing who owns and pays for codespaces in your organization and GitHub’s plans.In this articleOverviewAdding a policy to limit the available machine typesEditing a policyDeleting a policyFurther readingOverview
Typically, when you create a codespace you are offered a choice of specifications for the machine that will run your codespace. You can choose the machine type that best suits your needs. For more information, see Creating a codespace for a repository.
If you pay for using GitHub Codespaces then your choice of machine type will affect how much you are billed. The compute cost for a codespace is proportional to the number of processor cores in the machine type you choose. For example, the compute cost of using a codespace for an hour on a 16-core machine is eight times greater than a 2-core machine. For more information about pricing, see About billing for GitHub Codespaces.
As an organization owner, you may want to configure constraints on the types of machine that are available. For example, if the work in your organization doesn't require significant compute power or storage space, you can remove the highly resourced machines from the list of options that people can choose from. You do this by defining one or more policies in the GitHub Codespaces settings for your organization.
Behavior when you set a machine type constraint
If there are existing codespaces that no longer conform to a policy you have defined, these codespaces will continue to operate until they are stopped or time out. When the user attempts to resume the codespace they are shown a message telling them that the currently selected machine type is no longer allowed for this organization and prompting them to choose an alternative machine type.
If you remove higher specification machine types that are required by the GitHub Codespaces configuration for an individual repository in your organization, then it won't be possible to create a codespace for that repository. When someone attempts to create a codespace they will see a message telling them that there are no valid machine types available that meet the requirements of the repository's GitHub Codespaces configuration.
Note

Anyone who can edit the devcontainer.json configuration file in a repository can set a minimum specification for machines that can be used for codespaces for that repository. For more information, see Setting a minimum specification for codespace machines.

If setting a policy for machine types prevents people from using GitHub Codespaces for a particular repository there are two options:

You can adjust your policies to specifically remove the restrictions from the affected repository.
Anyone who has a codespace that they can no longer access, because of the new policy, can export their codespace to a branch. This branch will contain all of their changes from the codespace. They can then open a new codespace on this branch with a compliant machine type or work on this branch locally. For more information, see Exporting changes to a branch.

Setting organization-wide and repository-specific policies
When you create a policy you choose whether it applies to all repositories in your organization, or only to specified repositories. If you set an organization-wide policy then any policies you set for individual repositories must fall within the restriction set at the organization level. Adding policies makes the choice of machine more, not less, restrictive.
For example, you could create an organization-wide policy that restricts the machine types to either 2 or 4 cores. You can then set a policy for Repository A that restricts it to just 2-core machines. Setting a policy for Repository A that restricted it to machines with 2, 4, or 8 cores would result in a choice of 2-core and 4-core machines only, because the organization-wide policy prevents access to 8-core machines.
If you add an organization-wide policy, you should set it to the largest choice of machine types that will be available for any repository in your organization. You can then add repository-specific policies to further restrict the choice.
Note

Codespaces policies only apply to codespaces that your organizations pays for. If someone creates a codespace for a repository in your organization at their own expense, then the codespace will not be bound by these policies. For more information, see Choosing who owns and pays for codespaces in your organization.

Adding a policy to limit the available machine types


In the upper-right corner of GitHub, select your profile photo, then click  Your organizations.


Next to the organization, click Settings.


In the "Code, planning, and automation" section of the sidebar, select  Codespaces then click Policies.


On the "Codespaces policies" page, click Create Policy.


Enter a name for your new policy.


Click Add constraint and choose Machine types.


Click  to edit the constraint, then clear the selection of any machine types that you don't want to be available.



Click outside of the dialog box to close it.


By default the policy is set to apply to all repositories, if you want it to apply only to some of the repositories in your organization, click All repositories and then click Selected repositories in the dropdown menu.

Note

If you're adding a constraint to an existing policy that already contains the "Maximum codespaces per user" constraint, you won't be able to apply the policy to selected repositories. This is because the "Maximum codespaces per user" constraint always applies to all repositories in the organization.

With Selected repositories selected:


Click .



Select the repositories you want this policy to apply to.


At the bottom of the repository list, click Select repositories.





If you want to add another constraint to the policy, click Add constraint and choose another constraint. For information about other constraints, see:

Restricting the number of organization-billed codespaces a user can create
Restricting the base image for codespaces
Restricting the visibility of forwarded ports
Restricting the idle timeout period
Restricting the retention period for codespaces



After you've finished adding constraints to your policy, click Save.


The policy will be applied to all new codespaces that are billable to your organization. The machine type constraint is also applied to existing codespaces when someone attempts to restart a stopped codespace or reconnect to an active codespace.
Editing a policy
You can edit an existing policy. For example, you may want to add or remove constraints to or from a policy.

Display the "Codespaces policies" page. For more information, see Adding a policy to limit the available machine types.
Click the name of the policy you want to edit.
Beside the "Machine types" constraint, click .
Make the required changes then click Save.

Deleting a policy


Display the "Codespaces policies" page. For more information, see Adding a policy to limit the available machine types.


Click  to the right of the policy you want to delete.



Further reading

Managing the spending limit for GitHub Codespaces\n\n\n\nCodespaces/Managing your organization/Restrict codespace creationRestricting the number of organization-billed codespaces a user can createYou can specify the maximum number of codespaces that any member of your organization, or collaborator, can create for the repositories in your organization.Who can use this feature?To manage this constraint for an organization, you must be an owner of the organization.Organizations on GitHub Team and GitHub Enterprise plans can pay for members' and collaborators' use of GitHub Codespaces. These organizations can then access settings and policies to manage codespaces paid for by the organization. For more information, see Choosing who owns and pays for codespaces in your organization and GitHub’s plans.In this articleOverviewAdding a policy to define the maximum codespaces per userEditing a policyDeleting a policyOverview
By default, if organization members, or collaborators, are permitted to create codespaces that are billable to your organization, they can create multiple such codespaces. The number of organization-billed codespaces someone can create is governed by a limit to the total number of codespaces that they can create across all repositories they can access. This limit is set by GitHub.
As an organization owner, you can restrict the number of codespaces that each user can create, where the costs of the codespace are billable to the organization. This can help to reduce the overall cost of GitHub Codespaces to the organization, as there is a charge for codespace storage. For more information, see About billing for GitHub Codespaces.
To restrict the maximum number of organization-billed codespaces that users can create, you create a policy in the Codespaces settings for your organization. For example, if you set the maximum to 2, users who already have 2 active or stopped codespaces that are billed to your organization will have to delete one of these before they can create a new codespace that's billed to the organization.
This setting does not restrict users from creating codespaces that are not billed to your organization. For example, they can create additional codespaces for public repositories, using their personal Codespaces usage allowance. However, users who are permitted to create organization-billed codespaces, but have reached the limit for such codespaces, cannot choose to create a codespace for an organization-owned repository using their personal included allowance.
For information about the free use of GitHub Codespaces for personal accounts, see About billing for GitHub Codespaces. For information on how to choose who can create codespaces that are billed to your organization, see Enabling or disabling GitHub Codespaces for your organization.
Policies with the "Maximum codespaces per user" constraint are applied to every repository in your organization. You can't, therefore, add this constraint to an existing policy that is configured to apply only to selected repositories.
Adding a policy to define the maximum codespaces per user


In the upper-right corner of GitHub, select your profile photo, then click  Your organizations.


Next to the organization, click Settings.


In the "Code, planning, and automation" section of the sidebar, select  Codespaces then click Policies.


On the "Codespaces policies" page, click Create Policy.


Enter a name for your new policy.


Click Add constraint and choose Maximum codespaces per user.


Click  to edit the constraint.


In the "Maximum value" field, enter the maximum number of organization-billed codespaces that each user can create.



Click Save.


If you want to add another constraint to the policy, click Add constraint and choose another constraint. For information about other constraints, see:


Restricting access to machine types


Restricting the base image for codespaces


Restricting the visibility of forwarded ports


Restricting the idle timeout period


Restricting the retention period for codespaces


Note

When you add a constraint to a policy that already contains the "Maximum codespaces per user" constraint, you won't be able to restrict the additional constraint to specific repositories, as the "Maximum codespaces per user" constraint applies to all repositories in the organization.



After you've finished adding constraints to your policy, click Save.


The policy is applied when anyone attempts to create a new codespace that is billable to your organization.
Editing a policy
You can edit an existing policy. For example, you may want to add or remove constraints to or from a policy.

Display the "Codespaces policies" page. For more information, see Adding a policy to define the maximum codespaces per user.
Click the name of the policy you want to edit.
Beside the "Maximum codespaces per user" constraint, click .
Edit the maximum number of codespaces.
Click Save.

Deleting a policy

Display the "Codespaces policies" page. For more information, see Adding a policy to define the maximum codespaces per user.
Click  to the right of the policy you want to delete.\n\n\n\nCodespaces/Managing your organization/Restrict base imageRestricting the base image for codespacesYou can specify which base images can be used to create the dev container for new codespaces created within your organization.Who can use this feature?To manage image constraints for an organization's codespaces, you must be an owner of the organization.Organizations on GitHub Team and GitHub Enterprise plans can pay for members' and collaborators' use of GitHub Codespaces. These organizations can then access settings and policies to manage codespaces paid for by the organization. For more information, see Choosing who owns and pays for codespaces in your organization and GitHub’s plans.In this articleOverviewAdding a policy to define the allowed imagesEditing a policyDeleting a policyOverview
When you create a codespace, a development container is automatically created on a remote virtual machine. This dev container is created from a Docker image. The image is effectively a template for Docker containers and it determines many aspects of the resulting environment provided by the codespace. For more information, see Quickstart for GitHub Codespaces.
You can choose which image you want to use for your codespaces by specifying it in the dev container configuration for a repository. You can do this, for example, by using the image property in the devcontainer.json file.
JSON"image": "mcr.microsoft.com/devcontainers/javascript-node:18",
"image": "mcr.microsoft.com/devcontainers/javascript-node:18",

For more information, see the dev containers specification on the Development Containers website.
Alternatively, you can specify the base image in a Dockerfile. For more information, see Introduction to dev containers.
If you don't specify an image in the dev container configuration for a repository, the default dev container image is used. The default image contains a number of runtime versions for popular languages and commonly used tools. For more information, see Introduction to dev containers.
As an organization owner, you can add a policy to restrict which dev container images can be used for codespaces created within your organization.
If you attempt to create a codespace using a devcontainer.json that specifies an image that is not allowed by the policy, the following message is displayed in GitHub:

The codespace cannot be created because the image specified in your dev container configuration is not allowed. You may need to select a different branch, modify your container configuration, or adjust your organization's policy setting.

Using the CLI, the error message is:

error creating codespace: HTTP 400: Base image 'IMAGE-REFERENCE' is not allowed based on an organization policy set by your organization administrator.

If the image for a codespace is specified in a Dockerfile, and does not match the policy, a codespace is created in recovery mode, using the default recovery container rather than the specified image. A message to this effect is included at the end of the creation log. For more information about the creation log, see GitHub Codespaces logs.
Note


The dev container base image should not be confused with the host image. The host image is the image used to build the virtual machine on which the dev container runs. For more information, see Choosing the stable or beta host image.
The base image policy is applied when a codespace is created, and when you perform a full container rebuild. For more information, see Understanding the codespace lifecycle.
The base image policy does not apply to the default image, or the image that's used to recover a codespace if an error is introduced into a dev container configuration which prevents the container from being rebuilt.


Setting organization-wide and repository-specific policies
When you create a policy you choose whether it applies to all repositories in your organization, or only to specified repositories. If you set an organization-wide policy then any policies you set for individual repositories must fall within the restriction set at the organization level. Adding policies makes the choice of image more, not less, restrictive.
For example, you could create an organization-wide policy that restricts the base image to any of ten specified images. You can then set a policy for Repository A that restricts the image to a subset of just two of the images specified at the organization level. Specifying additional images for Repository A will have no effect because these images are not specified in the organization-level policy. If you add an organization-wide policy, you should set it to the largest choice of images that will be available for any repository in your organization. You can then add repository-specific policies to further restrict the choice.
Note

Codespaces policies only apply to codespaces that your organizations pays for. If someone creates a codespace for a repository in your organization at their own expense, then the codespace will not be bound by these policies. For more information, see Choosing who owns and pays for codespaces in your organization.

Adding a policy to define the allowed images


In the upper-right corner of GitHub, select your profile photo, then click  Your organizations.


Next to the organization, click Settings.


In the "Code, planning, and automation" section of the sidebar, select  Codespaces then click Policies.


On the "Codespaces policies" page, click Create Policy.


Enter a name for your new policy.


Click Add constraint and choose Base images.


Click  to edit the constraint.


In the "Allowed values" field, enter the image reference of the Docker image you want to allow.

You can use the * wildcard as the last character of the image reference to match all images that start with the same reference to the left of the wildcard. For example, mcr.microsoft.com/devcontainers/*.


Click  to add the value.


If required, repeat the previous two steps to add more image references.
When you add multiple image references, if an image reference specified in the dev container configuration of a repository does not match any of the references in a policy that applies to the repository, you will not be able to create codespaces for that repository.


Click outside of the dialog box to close it.


By default the policy is set to apply to all repositories, if you want it to apply only to some of the repositories in your organization, click All repositories and then click Selected repositories in the dropdown menu.

Note

If you're adding a constraint to an existing policy that already contains the "Maximum codespaces per user" constraint, you won't be able to apply the policy to selected repositories. This is because the "Maximum codespaces per user" constraint always applies to all repositories in the organization.

With Selected repositories selected:


Click .



Select the repositories you want this policy to apply to.


At the bottom of the repository list, click Select repositories.





If you want to add another constraint to the policy, click Add constraint and choose another constraint. For information about other constraints, see:

Restricting access to machine types
Restricting the number of organization-billed codespaces a user can create
Restricting the visibility of forwarded ports
Restricting the idle timeout period
Restricting the retention period for codespaces



After you've finished adding constraints to your policy, click Save.


The policy is applied when anyone attempts to create a new codespace that is billable to your organization. The base image constraint does not affect existing codespaces, either active or stopped.
Editing a policy
You can edit an existing policy. For example, you may want to add or remove constraints to or from a policy.

Display the "Codespaces policies" page. For more information, see Adding a policy to define the allowed images.
Click the name of the policy you want to edit.
Beside the "Base images" constraint, click .
Add or remove image references.
Click Save.

Deleting a policy


Display the "Codespaces policies" page. For more information, see Adding a policy to define the allowed images.


Click  to the right of the policy you want to delete.\n\n\n\nCodespaces/Managing your organization/Restrict port visibilityRestricting the visibility of forwarded portsYou can set constraints on the visibility options users can choose when they forward ports from codespaces in your organization.Who can use this feature?To manage access to port visibility constraints for the repositories in an organization, you must be an owner of the organization.Organizations on GitHub Team and GitHub Enterprise plans can pay for members' and collaborators' use of GitHub Codespaces. These organizations can then access settings and policies to manage codespaces paid for by the organization. For more information, see Choosing who owns and pays for codespaces in your organization and GitHub’s plans.In this articleOverviewAdding a policy to limit the port visibility optionsEditing a policyDeleting a policyOverview
Typically, within a codespace you are able to forward ports privately (only to yourself), to members of your organization, or publicly (to anyone with the URL). For more information, see Forwarding ports in your codespace.
As an organization owner, you may want to configure constraints on the visibility options users can set when forwarding ports. For example, for security reasons, you may want to disallow public port forwarding. You do this by defining one or more policies in the GitHub Codespaces settings for your organization.
Behavior when you set a port visibility constraint
If there are existing codespaces that no longer conform to a policy you have defined, these codespaces will continue to operate until they are stopped or time out. When the user resumes the codespace, it will be subject to the policy constraints.
Note

You can't disable private port forwarding, as private port forwarding is required by GitHub Codespaces to continue working as designed, for example to forward SSH on port 22.

Setting organization-wide and repository-specific policies
When you create a policy you choose whether it applies to all repositories in your organization, or only to specified repositories. If you set an organization-wide policy then any policies you set for individual repositories must fall within the restriction set at the organization level. Adding policies makes the choice of visibility options more, not less, restrictive.
For example, you could create an organization-wide policy that restricts the visibility options to organization only. You can then set a policy for Repository A that disallows both public and organization visibility, which would result in only private port forwarding being available for this repository. Setting a policy for Repository A that allowed both public and organization would result in only organization visibility, because the organization-wide policy does not allow public visibility.
If you add an organization-wide policy, you should set it to the most lenient visibility option that will be available for any repository in your organization. You can then add repository-specific policies to further restrict the choice.
Note

Codespaces policies only apply to codespaces that your organizations pays for. If someone creates a codespace for a repository in your organization at their own expense, then the codespace will not be bound by these policies. For more information, see Choosing who owns and pays for codespaces in your organization.

Adding a policy to limit the port visibility options


In the upper-right corner of GitHub, select your profile photo, then click  Your organizations.


Next to the organization, click Settings.


In the "Code, planning, and automation" section of the sidebar, select  Codespaces then click Policies.


On the "Codespaces policies" page, click Create Policy.


Enter a name for your new policy.


Click Add constraint and choose Port visibility.


Click  to edit the constraint.


Clear the selection of the port visibility options (Org or Public) that you don't want to be available.



Click outside of the dialog box to close it.


By default the policy is set to apply to all repositories, if you want it to apply only to some of the repositories in your organization, click All repositories and then click Selected repositories in the dropdown menu.

Note

If you're adding a constraint to an existing policy that already contains the "Maximum codespaces per user" constraint, you won't be able to apply the policy to selected repositories. This is because the "Maximum codespaces per user" constraint always applies to all repositories in the organization.

With Selected repositories selected:


Click .



Select the repositories you want this policy to apply to.


At the bottom of the repository list, click Select repositories.





If you want to add another constraint to the policy, click Add constraint and choose another constraint. For information about other constraints, see:

Restricting access to machine types
Restricting the number of organization-billed codespaces a user can create
Restricting the base image for codespaces
Restricting the idle timeout period
Restricting the retention period for codespaces



After you've finished adding constraints to your policy, click Save.


The policy will be applied to all new codespaces that are billable to your organization. The port visibility constraint is also applied to existing codespaces the next time they are started.
Editing a policy
You can edit an existing policy. For example, you may want to add or remove constraints to or from a policy.

Display the "Codespaces policies" page. For more information, see Adding a policy to limit the port visibility options.
Click the name of the policy you want to edit.
Beside the "Port visibility" constraint, click .
Make the required changes then click Save.

Deleting a policy


Display the "Codespaces policies" page. For more information, see Adding a policy to limit the port visibility options.


Click  to the right of the policy you want to delete.\n\n\n\nCodespaces/Managing your organization/Restrict timeout periodsRestricting the idle timeout periodYou can set a maximum timeout period for any codespaces owned by your organization.Who can use this feature?To manage timeout constraints for an organization's codespaces, you must be an owner of the organization.Organizations on GitHub Team and GitHub Enterprise plans can pay for members' and collaborators' use of GitHub Codespaces. These organizations can then access settings and policies to manage codespaces paid for by the organization. For more information, see Choosing who owns and pays for codespaces in your organization and GitHub’s plans.In this articleOverviewAdding a policy to set a maximum idle timeout periodEditing a policyDeleting a policyOverview
By default, codespaces time out after 30 minutes of inactivity. When a codespace times out it is stopped and will no longer incur charges for compute usage.
The personal settings of a GitHub user allow them to define their own timeout period for codespaces they create. This may be longer than the default 30-minute period. For more information, see Setting your timeout period for GitHub Codespaces.
As an organization owner, you may want to configure constraints on the maximum idle timeout period for codespaces created for repositories owned by your organization. This can help you to limit costs associated with codespaces that are left to timeout after long periods of inactivity. You can set a maximum timeout for the codespaces for all repositories owned by your organization, or for the codespaces of specific repositories.
Note

Maximum idle timeout constraints only apply to codespaces that are owned by your organization.

For more information about pricing for GitHub Codespaces compute usage, see About billing for GitHub Codespaces.
Inactivity defined
In the context of the Codespaces idle timeout, inactivity is defined as the absence of activity indicative of a user's presence. Personal interaction with a codespace, such as typing or using the mouse, resets the idle timeout period. Terminal activity, either input or output, also resets the idle timeout period. For example, if you publish a web app on a port from a codespace and page requests generate output in a terminal on the codespace, then each time terminal output occurs the timeout will be reset. However, if you share a port, and then don't interact with the codespace, and no terminal output is generated, the codespace will time out after the configured period.
Behavior when you set a maximum idle timeout constraint
If someone sets the default idle timeout to 90 minutes in their personal settings and they then start a codespace for a repository that has a maximum idle timeout constraint of 60 minutes, the codespace will time out after 60 minutes of inactivity. When codespace creation completes, a message explaining this will be displayed:

Idle timeout for this codespace is set to 60 minutes in compliance with your organization’s policy.

Setting organization-wide and repository-specific policies
When you create a policy, you choose whether it applies to all repositories in your organization, or only to specified repositories. If you create an organization-wide policy with a timeout constraint, then the timeout constraints in any policies that are targeted at specific repositories must fall within the restriction configured for the entire organization. The shortest timeout period - in an organization-wide policy, a policy targeted at specified repositories, or in someone's personal settings - is applied.
If you add an organization-wide policy with a timeout constraint, you should set the timeout to the longest acceptable period. You can then add separate policies that set the maximum timeout to a shorter period for specific repositories in your organization.
Note

Codespaces policies only apply to codespaces that your organizations pays for. If someone creates a codespace for a repository in your organization at their own expense, then the codespace will not be bound by these policies. For more information, see Choosing who owns and pays for codespaces in your organization.

Adding a policy to set a maximum idle timeout period


In the upper-right corner of GitHub, select your profile photo, then click  Your organizations.


Next to the organization, click Settings.


In the "Code, planning, and automation" section of the sidebar, select  Codespaces then click Policies.


On the "Codespaces policies" page, click Create Policy.


Enter a name for your new policy.


Click Add constraint and choose Maximum idle timeout.


Click  to edit the constraint.


Enter the maximum number of minutes codespaces can remain inactive before they time out, then click Save.



By default the policy is set to apply to all repositories, if you want it to apply only to some of the repositories in your organization, click All repositories and then click Selected repositories in the dropdown menu.

Note

If you're adding a constraint to an existing policy that already contains the "Maximum codespaces per user" constraint, you won't be able to apply the policy to selected repositories. This is because the "Maximum codespaces per user" constraint always applies to all repositories in the organization.

With Selected repositories selected:


Click .



Select the repositories you want this policy to apply to.


At the bottom of the repository list, click Select repositories.





If you want to add another constraint to the policy, click Add constraint and choose another constraint. For information about other constraints, see:

Restricting access to machine types
Restricting the number of organization-billed codespaces a user can create
Restricting the base image for codespaces
Restricting the visibility of forwarded ports
Restricting the retention period for codespaces



After you've finished adding constraints to your policy, click Save.


The policy will be applied to all new codespaces that are billable to your organization. The timeout constraint is also applied to existing codespaces the next time they are started.
Editing a policy
You can edit an existing policy. For example, you may want to add or remove constraints to or from a policy.

Display the "Codespaces policies" page. For more information, see Adding a policy to set a maximum idle timeout period.
Click the name of the policy you want to edit.
Beside the "Maximum idle timeout" constraint, click .
Make the required changes then click Save.

Deleting a policy


Display the "Codespaces policies" page. For more information, see Adding a policy to set a maximum idle timeout period.


Click  to the right of the policy you want to delete.\n\n\n\nCodespaces/Managing your organization/Restrict the retention periodRestricting the retention period for codespacesYou can set a maximum retention period for any codespaces owned by your organization.Who can use this feature?To manage retention constraints for an organization's codespaces, you must be an owner of the organization.Organizations on GitHub Team and GitHub Enterprise plans can pay for members' and collaborators' use of GitHub Codespaces. These organizations can then access settings and policies to manage codespaces paid for by the organization. For more information, see Choosing who owns and pays for codespaces in your organization and GitHub’s plans.In this articleOverviewAdding a policy to set a maximum codespace retention periodEditing a policyDeleting a policyOverview
GitHub Codespaces are automatically deleted after they have been stopped and have remained inactive for a defined number of days. The retention period for each codespace is set when the codespace is created and does not change. The default retention period is 30 days.
GitHub users can set a personal retention period of less than 30 days for codespaces they create. For more information, see Configuring automatic deletion of your codespaces.
As an organization owner, you may want to configure constraints on the maximum retention period for codespaces created for the repositories owned by your organization. This can help you to limit the storage costs associated with codespaces that are stopped and then left unused until they are automatically deleted. For more information about storage charges, see About billing for GitHub Codespaces. You can set a maximum retention period for all, or for specific, repositories owned by your organization.
Note

Setting a maximum retention policy for a repository prevents people from exempting a codespace from automatic deletion. The "Keep codespace" option will be unavailable for codespaces created for that repository. For more information, see Configuring automatic deletion of your codespaces.

Setting organization-wide and repository-specific policies
When you create a policy, you choose whether it applies to all repositories in your organization, or only to specified repositories. If you create an organization-wide policy with a codespace retention constraint, then the retention constraints in any policies that are targeted at specific repositories should be shorter than the restriction configured for the entire organization, or they will have no effect. The shortest retention period - in an organization-wide policy, a policy targeted at specified repositories, or the default retention period in someone's personal settings - is applied.
If you add an organization-wide policy with a retention constraint, you should set the retention period to the longest acceptable period. You can then add separate policies that set the maximum retention to a shorter period for specific repositories in your organization.
Note

Codespaces policies only apply to codespaces that your organizations pays for. If someone creates a codespace for a repository in your organization at their own expense, then the codespace will not be bound by these policies. For more information, see Choosing who owns and pays for codespaces in your organization.

Adding a policy to set a maximum codespace retention period


In the upper-right corner of GitHub, select your profile photo, then click  Your organizations.


Next to the organization, click Settings.


In the "Code, planning, and automation" section of the sidebar, select  Codespaces then click Policies.


On the "Codespaces policies" page, click Create Policy.


Enter a name for your new policy.


Click Add constraint and choose Retention period.


Click  to edit the constraint.


Enter the maximum number of days codespaces can remain stopped before they are automatically deleted, then click Save.

Note


A day, in this context, is a 24-hour period, beginning at the time of day when the codespace was stopped.
The valid range is 0-30 days.
Setting the period to 0 will result in codespaces being immediately deleted when they are stopped, or when they timeout due to inactivity.




By default the policy is set to apply to all repositories, if you want it to apply only to some of the repositories in your organization, click All repositories and then click Selected repositories in the dropdown menu.

Note

If you're adding a constraint to an existing policy that already contains the "Maximum codespaces per user" constraint, you won't be able to apply the policy to selected repositories. This is because the "Maximum codespaces per user" constraint always applies to all repositories in the organization.

With Selected repositories selected:


Click .



Select the repositories you want this policy to apply to.


At the bottom of the repository list, click Select repositories.





If you want to add another constraint to the policy, click Add constraint and choose another constraint. For information about other constraints, see:

Restricting access to machine types
Restricting the number of organization-billed codespaces a user can create
Restricting the base image for codespaces
Restricting the visibility of forwarded ports
Restricting the idle timeout period



After you've finished adding constraints to your policy, click Save.


The policy will be applied to all new codespaces that are billable to your organization. The retention period constraint is only applied on codespace creation.
Editing a policy
You can edit an existing policy. For example, you may want to add or remove constraints to or from a policy.
The retention period constraint is only applied to codespaces when they are created. Editing a policy has no effect on existing codespaces.

Display the "Codespaces policies" page. For more information, see Adding a policy to set a maximum codespace retention period.
Click the name of the policy you want to edit.
Beside the "Retention period" constraint, click .
Make the required changes then click Save.

Deleting a policy
You can delete a policy at any time. Deleting a policy has no effect on existing codespaces.


Display the "Codespaces policies" page. For more information, see Adding a policy to set a maximum codespace retention period.


Click the delete button to the right of the policy you want to delete.


Click  to the right of the policy you want to delete.\n\n\n\nCodespaces/Reference/Access a private registryAllowing your codespace to access a private registryYou can allow GitHub Codespaces to access container images or other packages in a private registry.In this articleAbout private registries and GitHub CodespacesAccessing packages stored in registries with granular permissionsAccessing images stored in other registriesDebugging private image registry accessAbout private registries and GitHub Codespaces
A registry is a secure space for storing, managing, and fetching container images or other packages. There are many examples of registries, such as:

GitHub's Container registry, the Azure Container Registry, and DockerHub for container images
The npm registry for Node.js packages.

Certain GitHub Packages registries, including the Container registry, can be configured to allow packages to be pulled seamlessly into GitHub Codespaces during codespace creation, without having to provide any authentication credentials.
To access other container image registries, you can create secrets in GitHub to store the access details, which will allow GitHub Codespaces to access images stored in that registry.
Accessing packages stored in registries with granular permissions
GitHub Packages registries that support granular permissions, including the Container registry, provide the easiest way for GitHub Codespaces to consume packages. For the list of GitHub Packages registries that support granular permissions and seamless GitHub Codespaces access, see About permissions for GitHub Packages.
Accessing a package published to the same repository as the codespace
If you publish a package in the same repository that the codespace is being launched in, you will automatically be able to fetch that package on codespace creation. You won't have to provide any additional credentials, unless the Inherit access from repo option was unselected when the package was published.
Inheriting access from the repository from which a package was published
By default, the package inherits the access setting of the repository from which it was published. For example, if the repository is public, the package is also public. If the repository is private, the package is also private, but is accessible from the repository.
This behavior is controlled by the Inherit access from repo option. Inherit access from repo is selected by default when publishing via GitHub Actions, but not when publishing directly to a registry using a personal access token.
If the Inherit access from repo option was not selected when the package was published, you can manually add the repository to the published package's access controls. For more information, see Configuring a package's access control and visibility.
Accessing a package published to the organization a codespace will be launched in
If you want a package to be accessible to all codespaces in an organization, we recommend that you publish the package with internal visibility. This will automatically make the package visible to all codespaces within the organization, unless the repository the codespace is launched from is public.
If the codespace is being launched from a public repository referencing an internal or private package, you must manually allow the public repository access to the internal package. This prevents the internal package from being accidentally leaked publicly. For more information, see Configuring a package's access control and visibility.
Accessing a private package from a subset of repositories in an organization
If you want to allow a subset of an organization's repositories to access a package, or allow an internal or private package to be accessed from a codespace launched in a public repository, you can manually add repositories to a package's access settings. For more information, see Configuring a package's access control and visibility.
Publishing a package from a codespace
Seamless access from a codespace to a registry is limited to pulling packages. If you want to publish a package from inside a codespace, you must use a personal access token (classic) with the write:packages scope.
We recommend publishing packages via GitHub Actions. For more information, see Publishing Docker images and Publishing Node.js packages.
Accessing images stored in other registries
You can define secrets to allow GitHub Codespaces to access container image registries other than GitHub's Container registry. If you are accessing a container image from a registry that doesn't support seamless access, GitHub Codespaces checks for the presence of three secrets, which define the server name, username, and personal access token for a registry. If these secrets are found, GitHub Codespaces will make the registry available inside your codespace.

<*>_CONTAINER_REGISTRY_SERVER
<*>_CONTAINER_REGISTRY_USER
<*>_CONTAINER_REGISTRY_PASSWORD

You can store secrets at the user, repository, or organization-level, allowing you to share them securely between different codespaces. When you create a set of secrets for a private image registry, you need to replace the "<*>" in the name with a consistent identifier. For more information, see Managing your account-specific secrets for GitHub Codespaces and Managing development environment secrets for your repository or organization.
If you are setting the secrets at the user or organization level, make sure to assign those secrets to the repository you'll be creating the codespace in by choosing an access policy from the dropdown list.

Pulling a Docker image into your codespace
GitHub Codespaces uses Docker, so to pull a private Docker image inside your codespace at runtime, you need to be able to use Docker-in-Docker. To make this possible, the secrets required for login to Docker are automatically added to the ~/.docker/config.json file within your codespace. This happens after the onCreateCommand lifecycle hook but before postCreateCommand, postStartCommand, and postAttachCommand. As a result, postCreateCommand will be able to use Docker-in-Docker to pull a Docker image into the codespace, but onCreateCommand will not. For this reason, Docker-in-Docker is not available during prebuild creation.
After the codespace is running you will be able to open a terminal in the codespace and run the command docker pull PRIVATE-IMAGE-URL.
Example secrets
For a private image registry in Azure, you could create the following secrets:
ACR_CONTAINER_REGISTRY_SERVER = mycompany.azurecr.io
ACR_CONTAINER_REGISTRY_USER = acr-user-here
ACR_CONTAINER_REGISTRY_PASSWORD = <PERSONAL_ACCESS_TOKEN>

For information on common image registries, see Common image registry servers. Note that accessing AWS Elastic Container Registry (ECR) is different.

Once you've added the secrets, you may need to stop and then start the codespace you are in for the new environment variables to be passed into the container. For more information, see Using the Visual Studio Code Command Palette in GitHub Codespaces.
Accessing AWS Elastic Container Registry
To access AWS Elastic Container Registry (ECR), you can provide an AWS access key ID and secret key, and GitHub can retrieve an access token for you and log in on your behalf.
*_CONTAINER_REGISTRY_SERVER = <ECR_URL>
*_CONTAINER_REGISTRY_USER = <AWS_ACCESS_KEY_ID>
*_CONTAINER_REGISTRY_PASSWORD = <AWS_SECRET_KEY>

You must also ensure you have the appropriate AWS IAM permissions to perform the credential swap (e.g. sts:GetServiceBearerToken) as well as the ECR read operation (either AmazonEC2ContainerRegistryFullAccess or ReadOnlyAccess).
Alternatively, if you don't want GitHub to perform the credential swap on your behalf, you can provide an authorization token fetched via AWS's APIs or CLI.
*_CONTAINER_REGISTRY_SERVER = <ECR_URL>
*_CONTAINER_REGISTRY_USER = AWS
*_CONTAINER_REGISTRY_PASSWORD = <TOKEN>

Since these tokens are short lived and need to be refreshed periodically, we recommend providing an access key ID and secret.
While these secrets can have any name, so long as the *_CONTAINER_REGISTRY_SERVER is an ECR URL, we recommend using ECR_CONTAINER_REGISTRY_* unless you are dealing with multiple ECR registries.
For more information, see AWS ECR's Private registry authentication documentation.
Common image registry servers
Some of the common image registry servers are listed below:

DockerHub - https://index.docker.io/v1/
GitHub Container Registry - ghcr.io
Azure Container Registry - <registry name>.azurecr.io
AWS Elastic Container Registry - <aws_account_id>.dkr.ecr.<region>.amazonaws.com
Google Cloud Container Registry - gcr.io (US), eu.gcr.io (EU), asia.gcr.io (Asia)

Debugging private image registry access
If you are having trouble pulling an image from a private image registry, make sure you are able to run docker login -u <user> -p <password> <server>, using the values of the secrets defined above. If login fails, ensure that the login credentials are valid and that you have the appropriate permissions on the server to fetch a container image. If login succeeds, make sure that these values are copied appropriately into the right GitHub Codespaces secrets, either at the user, repository, or organization level and try again.\n\n\n\nCodespaces/Reference/Copilot in CodespacesUsing GitHub Copilot in GitHub CodespacesYou can use GitHub Copilot in GitHub Codespaces by adding a VS Code extension.GitHub Copilot is an AI pair programmer that you can use in any codespace that you open in the VS Code web client or desktop application. For more information about GitHub Copilot, see What is GitHub Copilot?.
To start using GitHub Copilot in GitHub Codespaces, install the GitHub Copilot extension from the Visual Studio Code Marketplace.
To include GitHub Copilot, or other extensions, in all of your codespaces, enable Settings Sync. For more information, see Personalizing GitHub Codespaces for your account. Additionally, to include GitHub Copilot in a given project for all users, you can specify GitHub.copilot as an extension in your devcontainer.json file. For information about configuring a devcontainer.json file, see Introduction to dev containers.
Further reading

Quickstart for GitHub Copilot\n\n\n\nCodespaces/Reference/VS Code Command PaletteUsing the Visual Studio Code Command Palette in GitHub CodespacesYou can use the Command Palette feature of Visual Studio Code to access many commands in GitHub Codespaces.In this articleAbout the Visual Studio Code Command PaletteAccessing the VS Code Command PaletteCommands for CodespacesFurther readingAbout the Visual Studio Code Command Palette
The VS Code Command Palette is one of the focal features of Visual Studio Code and is available for you to use in GitHub Codespaces. The Command Palette allows you to access many commands for GitHub Codespaces and VS Code. For more information on using the VS Code Command Palette, see User Interface in the VS Code documentation.
Accessing the VS Code Command Palette
You can access the VS Code Command Palette in a number of ways.


Shift+Command+P (Mac) / Ctrl+Shift+P (Windows/Linux).
Note that this command is a reserved keyboard shortcut in Firefox.


F1


From the Application Menu, click View > Command Palette.


Commands for Codespaces
To see all commands related to GitHub Codespaces, access the VS Code Command Palette, then start typing "Codespaces".

Suspending or stopping a codespace
If you add a new secret or change the machine type, you'll have to stop and restart the codespace for it to apply your changes.
To suspend or stop your codespace's container, access the VS Code Command Palette, then start typing "stop". Select Codespaces: Stop Current Codespace.

Adding a predefined dev container configuration
To add a predefined dev container configuration, access the VS Code Command Palette, then start typing "add dev". Click Codespaces: Add Dev Container Configuration Files.

Rebuilding a codespace
If you add a dev container or edit any of the configuration files (devcontainer.json and Dockerfile), you'll have to rebuild your codespace for it to apply your changes.
To rebuild your container, access the VS Code Command Palette, then start typing "rebuild". Select Codespaces: Rebuild Container.

Tip

You may occasionally want to perform a full rebuild to clear your cache and rebuild your container with fresh images. For more information, see Rebuilding the container in a codespace.

Codespaces logs
You can use the VS Code Command Palette to access the codespace creation logs, or you can use it export all logs.
To retrieve the logs for GitHub Codespaces, access the VS Code Command Palette, then start typing "export". Select Codespaces: Export Logs to export all logs related to GitHub Codespaces or select Codespaces: View Creation Logs to view logs related to the setup.

Further reading

Using GitHub Codespaces in Visual Studio Code\n\n\n\nCodespaces/Reference/Security in CodespacesSecurity in GitHub CodespacesOverview of the GitHub Codespaces security architecture, with guidelines to help you maintain security and minimize the risk of attack.In this articleOverview of codespace securityGood security practices for your codespacesOverview of codespace security
GitHub Codespaces is designed to be security hardened by default. Consequently, you will need to ensure that your software development practices do not risk reducing the security posture of your codespace.
This guide describes the way GitHub Codespaces keeps your development environment secure and provides some of the good practices that will help maintain your security as you work. As with any development tool, remember that you should only open and work within repositories you know and trust.
Environment isolation
GitHub Codespaces is designed to keep your codespaces separate from each other, with each using its own virtual machine and network.
Isolated virtual machines
Each codespace is hosted on its own newly-built virtual machine (VM). Two codespaces are never co-located on the same VM.
Every time you restart a codespace, it's deployed to a new VM with the latest available security updates.
Isolated networking
Each codespace has its own isolated virtual network. We use firewalls to block incoming connections from the internet and to prevent codespaces from communicating with each other on internal networks. Codespaces are allowed to make outbound connections to the internet.
Authentication
You can connect to a codespace using a web browser or from Visual Studio Code. If you connect from VS Code, you are prompted to authenticate with GitHub.
Every time a codespace is created or restarted, it's assigned a new GitHub token with an automatic expiry period. This period allows you to work in the codespace without needing to reauthenticate during a typical working day, but reduces the chance that you will leave a connection open when you stop using the codespace.
The token's scope will vary depending on the access you have to the repository where the codespace was created:

If you have write access to the repository: The token will be scoped for read/write access to the repository.
If you only have read access to the repository: The token will only allow the code to be cloned from the source repository. If you make a commit in the codespace, or push a new branch, GitHub Codespaces automatically creates a fork of the repository, or links the codespace to an existing fork if you already have one for the upstream repository. The token is updated to have read and write access to the fork. For more information, see Using source control in your codespace.
If you've authorized your codespace to access other repositories: The token will be scoped for read or read/write access to the source repository and to any other repositories to which you've authorized access. For more information, see Managing access to other repositories within your codespace.

Codespace connections
You can connect to your codespace using the TLS encrypted tunnel provided by the GitHub Codespaces service. Only the creator of a codespace can connect to a codespace. Connections are authenticated with GitHub.
If you need to allow external access to services running on a codespace, you can enable port forwarding for private or public access.
Port forwarding
If you need to connect to a service (such as a development web server) running within your codespace, you can configure port forwarding to make the service available on the internet.
Organization owners can restrict the ability to make forward ports available publicly or within the organization. For more information, see Restricting the visibility of forwarded ports.
Privately forwarded ports: Are accessible on the internet, but only the codespace creator can access them, after authenticating to GitHub.
Publicly forwarded ports within your organization: Are accessible on the internet, but only to members of the same organization as the codespace, after authenticating to GitHub.
Publicly forwarded ports: Are accessible on the internet, and anyone on the internet can access them. No authentication is needed to access public forwarded ports.
All forwarded ports are private by default, which means that you will need to authenticate before you can access the port. Access to a codespace's private forwarded ports is controlled by authentication cookies with a 3-hour expiry period. When the cookie expires, you will need to reauthenticate.
A public forwarded port will automatically revert back to private when you remove and re-add the port, or if you restart the codespace.
You can use the "Ports" panel to configure a port for public or private access, and can stop port forwarding when it's no longer required. For more information, see Forwarding ports in your codespace.
Good security practices for your codespaces
Codespaces are designed to be security hardened by default. To help maintain this posture, we recommend that you follow good security practices during your development procedures:

As with any development tool, remember that you should only open and work within repositories you know and trust.
Before you add new dependencies to the codespace, check whether they are well-maintained, and if they release updates to fix any security vulnerabilities found in their code.

Using development environment secrets to access sensitive information
Always use development environment secrets when you want to use sensitive information (such as access tokens) in a codespace. You can access your secrets as environment variables in the codespace, including from the terminal. For example, you can launch a terminal within your codespace and use echo $SECRET_NAME to see the value of a development environment secret.
The secret values are copied to environment variables whenever the codespace is resumed or created and are also synced when they are changed.
Development environment secrets are not copied into the environment if you don't have write access to the codespace's repository.
For more information on secrets, see:

Managing your account-specific secrets for GitHub Codespaces
Managing development environment secrets for your repository or organization

Working with other people's contributions and repositories
When you create a codespace from a PR branch from a fork, the token in the codespace will vary depending on whether the repository is public or private:

For a private repository, the codespace is granted access to both the fork and parent.
For a public repository, the codespace will only have access to the fork and opening PRs on the parent.

We also further protect you in these scenarios by not injecting any of your codespace secrets into the environment. For more information, see Managing your account-specific secrets for GitHub Codespaces.
Note

The scope of the token in the codespace can change if you create a codespace from a fork to which you only have read access, then make a commit or push a new branch in the codespace. In this situation, as with any other repository, GitHub Codespaces automatically creates a new fork, or links your codespace to an existing fork owned by your account, and updates the token to have read and write access to the newly linked fork. For more information, see Using source control in your codespace.
When GitHub Codespaces links your codespace to an existing fork, this existing fork can be either a fork of the fork from which you created a codespace, or your own fork of the shared upstream repository.

Additional good practices
There are some additional good practices and risks that you should be aware of when using GitHub Codespaces.
Understanding a repository's devcontainer.json file
When you create a codespace, if a devcontainer.json file is found for your repository, it is parsed and used to configure your codespace. The devcontainer.json file can contain powerful features, such as installing third-party extensions and running arbitrary code supplied in a postCreateCommand.
For more information, see Introduction to dev containers.
Granting access through features
Certain development features can potentially add risk to your environment. For example, commit signing, secrets injected into environment variables, authenticated registry access, and packages access can all present potential security issues. We recommend that you only grant access to those who need it and adopt a policy of being as restrictive as possible.
Using extensions
Any additional VS Code extensions that you've installed can potentially introduce more risk. To help mitigate this risk, ensure that the you only install trusted extensions, and that they are always kept up to date.
Using Settings Sync
VS Code's Settings Sync can allow potentially malicious content to transfer across devices. By default, Settings Sync is disabled for codespaces opened in the browser. If you're creating a codespace for a repository whose contents you do not trust, you should open the codespace in the browser and leave Settings Sync turned off.
If you have enabled Settings Sync in your user preferences, and want to allow changes to your settings to sync from your codespaces to other instances of VS Code, we recommend you add a selected list of trusted repositories, rather than trusting all repositories. When you create codespaces from trusted repositories, changes you make to your settings in the codespaces are synced to your cached settings in the cloud, from which they can transfer to your devices. For more information about managing Settings Sync, see Personalizing GitHub Codespaces for your account.\n\n\n\nCodespaces/Reference/Disaster recoveryDisaster recovery for GitHub CodespacesThis article describes guidance for a disaster recovery scenario, when a whole region experiences an outage due to major natural disaster or widespread service interruption.In this articleOption 1: Create a new codespace in another regionOption 2: Wait for recoveryOption 3: Clone the repository locally or edit in the browserOption 4: Use the Dev Containers extension and Docker for a local containerized environmentWe work hard to make sure that GitHub Codespaces is always available to you. However, forces beyond our control sometimes impact the service in ways that can cause unplanned service disruptions.
Although disaster recovery scenarios are rare occurrences, we recommend that you prepare for the possibility that there is an outage of an entire region. If an entire region experiences a service disruption, the locally redundant copies of your data would be temporarily unavailable.
The following guidance provides options on how to handle service disruption to the entire region where your codespace is deployed.
Note

You can reduce the potential impact of service-wide outages by pushing to remote repositories frequently.

Option 1: Create a new codespace in another region
In the case of a regional outage, we suggest you recreate your codespace in an unaffected region to continue working. This new codespace will have all of the changes as of your last push to GitHub. For information on manually setting another region, see Setting your default region for GitHub Codespaces.
You can optimize recovery time by configuring a devcontainer.json in the project's repository, which allows you to define the tools, runtimes, frameworks, editor settings, extensions, and other configuration necessary to restore the development environment automatically. For more information, see Introduction to dev containers.
Option 2: Wait for recovery
In this case, no action on your part is required. Know that we are working diligently to restore service availability.
You can check the current service status on the Status Dashboard.
Option 3: Clone the repository locally or edit in the browser
While GitHub Codespaces provides the benefit of a pre-configured developer environment, your source code should always be accessible through the repository hosted on GitHub. In the event of a GitHub Codespaces outage, you can still clone the repository locally or edit files in the GitHub browser editor. For more information, see Editing files.
While this option does not configure a development environment for you, it will allow you to make changes to your source code as needed while you wait for the service disruption to resolve.
Option 4: Use the Dev Containers extension and Docker for a local containerized environment
If your repository has a devcontainer.json, consider using the Dev Containers extension in Visual Studio Code to build and attach to a local development container for your repository. The setup time for this option will vary depending on your local specifications and the complexity of your dev container setup. For more information, see Developing inside a container in the VS Code documentation.
Note

Be sure your local setup meets the minimum requirements before attempting this option.\n\n\n\nCodespaces/Troubleshooting/Codespaces logsGitHub Codespaces logsOverview of the logs used by GitHub Codespaces.Tool navigationGitHub CLIVisual Studio CodeWeb browserIn this articleCodespace logsCodespace logsCodespace logsCreation logsExtension logsBrowser console logsFurther readingInformation on GitHub Codespaces is output to various logs:


Codespace logs
Creation logs
Browser console logs (for the VS Code web client)

Extension logs are available if you are using GitHub Codespaces in VS Code. Click the "Visual Studio Code" tab above for details.



Codespace logs
Creation logs
Extension logs (for the VS Code desktop application)

Browser logs are available if you are using GitHub Codespaces in your browser. Click the "Web browser" tab above for details.



Codespace logs
Creation logs

Other logs are available if you are using GitHub Codespaces in VS Code or in your web browser. Click the tabs above for details.


Codespace logs
These logs contain detailed information about the codespace, the container, the session, and the VS Code environment. They are useful for diagnosing connection issues and other unexpected behavior. For example, the codespace freezes but the "Reload Windows" option unfreezes it for a few minutes, or you are randomly disconnected from the codespace but able to reconnect immediately.

If you are using GitHub Codespaces in the browser, ensure that you are connected to the codespace you want to debug.
Open the VS Code Command Palette (Shift+Command+P (Mac) / Ctrl+Shift+P (Windows/Linux)) and type export logs. Select Codespaces: Export Logs from the list to download the logs.
Define where to save the zip archive of logs then click Save (desktop) or click OK (web).
If you are using GitHub Codespaces in the browser, right-click on the zip archive of logs from the Explorer view and select Download… to download them to your local machine.



Codespace logs
These logs contain detailed information about the codespace, the container, the session, and the VS Code environment. They are useful for diagnosing connection issues and other unexpected behavior. For example, the codespace freezes but the "Reload Windows" option unfreezes it for a few minutes, or you are randomly disconnected from the codespace but able to reconnect immediately.

Open the VS Code Command Palette (Shift+Command+P (Mac) / Ctrl+Shift+P (Windows/Linux)) and type export log. Select Codespaces: Export Logs from the list to download the logs.
Define where to save the zip archive of logs then click Save (desktop) or click OK (web).



Codespace logs
These logs contain detailed information about the codespace, the container, the session, and the VS Code environment. They are useful for diagnosing connection issues and other unexpected behavior. For example, the codespace freezes but the "Reload Windows" option unfreezes it for a few minutes, or you are randomly disconnected from the codespace but able to reconnect immediately.
Currently you can't use GitHub CLI to access these logs. To access them, open your codespace in VS Code or in a browser.

Creation logs
These logs contain information about the container, dev container, and their configuration. They are useful for debugging configuration and setup problems.


Connect to the codespace you want to debug.
Open the VS Code Command Palette (Shift+Command+P (Mac) / Ctrl+Shift+P (Windows/Linux)) and type creation log. Select Codespaces: View Creation Log from the list to open the creation.log file.

If you want to share the log with support, you can copy the text from the creation log into a text editor and save the file locally.


Open the VS Code Command Palette (Shift+Command+P (Mac) / Ctrl+Shift+P (Windows/Linux)) and type creation log. Select Codespaces: View Creation Log from the list to open the creation.log file.
If you want to share the log with support, you can copy the text from the creation log into a text editor and save the file locally.


Note

To learn more about GitHub CLI, see About GitHub CLI.

To see the creation log use the gh codespace logs subcommand. After entering the command choose from the list of codespaces that's displayed.
gh codespace logs

For more information about this command, see the GitHub CLI manual.
If you want to share the log with support, you can save the output to a file:
gh codespace logs -c <CODESPACE-NAME> > /path/to/logs.txt



Extension logs
These logs are available for VS Code desktop users only. They are useful if it seems like the GitHub Codespaces extension or VS Code editor are having issues that prevent creation or connection.

In VS Code, open the Command Palette.
Type logs and select Developer: Open Extension Logs Folder.
Your system's file explorer is displayed showing various log files and folders. Open the folder output_logging_DATETIME.

From this view, you can access logs generated by extensions you use in VS Code, including GitHub Codespaces.


Browser console logs
These logs are useful only if you want to debug problems with using GitHub Codespaces in the browser. They are useful for debugging problems creating and connecting to GitHub Codespaces.
The following instructions are for Chrome. The steps for other browsers are similar.


In the browser window for the codespace you want to debug, open the developer tools window.


Click the Console tab.


Show the console sidebar, if it is not already displayed. For more information, see Console features reference in the Chrome for Developers documentation.


In the sidebar, click NUMBER errors to show only the errors.


In the log area on the right, right-click and select Save as to save a copy of the errors to your local machine.




Further reading

Reviewing your organization's audit logs for GitHub Codespaces
Reviewing your security logs for GitHub Codespaces\n\n\n\nCodespaces/Troubleshooting/Codespaces clientsTroubleshooting GitHub Codespaces clientsThis article provides troubleshooting information for issues you may encounter with the client you use for GitHub Codespaces.Tool navigationVisual Studio CodeWeb browserIn this articleTroubleshooting the Visual Studio Code web clientVS Code troubleshooting
Troubleshooting the Visual Studio Code web client
If you encounter issues using GitHub Codespaces in a browser that is not Chromium-based, try switching to a Chromium-based browser, such as Google Chrome or Microsoft Edge. Alternatively, check for known issues with your browser in the microsoft/vscode repository by searching for issues labeled with the name of your browser, such as firefox or safari.
If you encounter issues using GitHub Codespaces in a Chromium-based browser, you can check if you're experiencing another known issue with VS Code in the microsoft/vscode repository.
Differences from working in VS Code locally
When you open a codespace in your browser, using the VS Code web client, you will notice some differences from working in a local workspace in the VS Code desktop application. For example, some key bindings will be different or missing, and some extensions may behave differently. For a summary, see: Known limitations and adaptions in the VS Code docs.
You can check for known issues and log new issues with the VS Code experience in the microsoft/vscode repository.
Visual Studio Code Insiders
Visual Studio Code Insiders is the most frequent release of VS Code. It has all the latest features and bug fixes, but may also occasionally contain new issues that result in a broken build.
If you are using an Insiders build and notice broken behavior, we recommend switching to Visual Studio Code Stable and trying again.
Click  in the bottom left of the editor and select Switch to Stable Version.... If the VS Code web client doesn't load, or  isn't available, you can force switching to Visual Studio Code Stable by appending ?vscodeChannel=stable to your codespace URL and loading the codespace at that URL.
If the problem isn't fixed in Visual Studio Code Stable, check for known issues and, if required, log a new issue with the VS Code experience, in the microsoft/vscode repository.
Troubleshooting the Simple Browser
When you have started a web application in a codespace, you can preview the running application in the Simple Browser embedded in VS Code. In some projects, the application automatically opens in a Simple Browser tab in the editor when the application starts. This happens if, in the devcontainer.json configuration file for the codespace, the onAutoForward property of the port the application runs on is set to openPreview.
"portsAttributes": {
  "3000": {
    "label": "Application",
    "onAutoForward": "openPreview"
  }
}

If the Simple Browser tab does not open automatically, you can open the Simple Browser manually to view the application.


In VS Code, click the Ports tab.


Right-click the port, then click Preview in Editor.



The simple browser tab does not open automatically
If the devcontainer.json configuration file specifies "onAutoForward": "openPreview" for a port, but the Simple Browser does not open automatically when an application starts, check that the application has started on the port specified in the configuration. The application might start on a different port if the intended port is busy.
To implement the port configuration specified in devcontainer.json, GitHub Codespaces writes the configuration to VS Code's settings.json file when a codespace is created. You can check that the configuration has been correctly written to settings.json in your codespace.


In the terminal in your codespace, enter the following command.
Bashcat ~/.vscode-remote/data/Machine/settings.json
cat ~/.vscode-remote/data/Machine/settings.json



Verify that the settings.json file contains lines like the following.
 "remote.portsAttributes": {
     "3000": {
         "label": "Application",
         "onAutoForward": "openPreview"
     }
 }



If the settings.json file doesn't contain these settings, check whether you have dotfiles enabled, and whether any configuration in your dotfiles is overwriting the settings.json file. For more information, see Personalizing GitHub Codespaces for your account.
The application does not load
Occasionally, you may find that the Simple Browser tab opens, but displays an error page icon or a blank page instead of your running application. This can happen if the web application you are loading includes a content security policy (CSP) that restricts the domains in which the site's pages may be embedded. For more information, see CSP: frame-ancestors on the mdn website.
You may be able to change your application's frame-ancestors security policy locally to make the application display in the Simple Browser. Alternatively, if a frame-ancestors policy is causing the problem, you should be able to view the application by opening it in a regular browser tab rather than the simple browser. To do this, click the Ports tab in VS Code, right-click the port, and click Open in Browser.


VS Code troubleshooting
When you open a codespace in the VS Code desktop application, you may notice a few differences compared with working in a local workspace, but the experience should be similar.
If you encounter problems, you can check for known issues and log new issues with the VS Code experience in the microsoft/vscode repository.
Visual Studio Code Insiders
Visual Studio Code Insiders is the most frequent release of VS Code. It has all the latest features and bug fixes, but may also occasionally contain new issues that result in a broken build.
If you are using an Insiders build and notice broken behavior, we recommend switching to Visual Studio Code Stable and trying again.
To switch to Visual Studio Code Stable, close the Visual Studio Code Insiders application, open the Visual Studio Code Stable application, and re-open your codespace.
If the problem isn't fixed in Visual Studio Code Stable, check for known issues and, if required, log a new issue with the VS Code experience, in the microsoft/vscode repository.
Troubleshooting the Simple Browser
When you have started a web application in a codespace, you can preview the running application in the Simple Browser embedded in VS Code. In some projects, the application automatically opens in a Simple Browser tab in the editor when the application starts. This happens if, in the devcontainer.json configuration file for the codespace, the onAutoForward property of the port the application runs on is set to openPreview.
"portsAttributes": {
  "3000": {
    "label": "Application",
    "onAutoForward": "openPreview"
  }
}

If the Simple Browser tab does not open automatically, you can open the Simple Browser manually to view the application.


In VS Code, click the Ports tab.


Right-click the port, then click Preview in Editor.



The simple browser tab does not open automatically
If the devcontainer.json configuration file specifies "onAutoForward": "openPreview" for a port, but the Simple Browser does not open automatically when an application starts, check that the application has started on the port specified in the configuration. The application might start on a different port if the intended port is busy.
To implement the port configuration specified in devcontainer.json, GitHub Codespaces writes the configuration to VS Code's settings.json file when a codespace is created. You can check that the configuration has been correctly written to settings.json in your codespace.


In the terminal in your codespace, enter the following command.
Bashcat ~/.vscode-remote/data/Machine/settings.json
cat ~/.vscode-remote/data/Machine/settings.json



Verify that the settings.json file contains lines like the following.
 "remote.portsAttributes": {
     "3000": {
         "label": "Application",
         "onAutoForward": "openPreview"
     }
 }



If the settings.json file doesn't contain these settings, check whether you have dotfiles enabled, and whether any configuration in your dotfiles is overwriting the settings.json file. For more information, see Personalizing GitHub Codespaces for your account.
The application does not load
Occasionally, you may find that the Simple Browser tab opens, but displays an error page icon or a blank page instead of your running application. This can happen if the web application you are loading includes a content security policy (CSP) that restricts the domains in which the site's pages may be embedded. For more information, see CSP: frame-ancestors on the mdn website.
You may be able to change your application's frame-ancestors security policy locally to make the application display in the Simple Browser. Alternatively, if a frame-ancestors policy is causing the problem, you should be able to view the application by opening it in a regular browser tab rather than the simple browser. To do this, click the Ports tab in VS Code, right-click the port, and click Open in Browser.\n\n\n\nCodespaces/Troubleshooting/Included usageGetting the most out of your included usageFind out about the free use of GitHub Codespaces that's included with personal accounts.In this articleAbout Codespaces computeAbout Codespaces storageUnderstanding your Codespaces usageTips for making your allowed usage go furtherPersonal GitHub accounts include a quota of free use of GitHub Codespaces every month.
Note

Free use of GitHub Codespaces is included in personal accounts only. It is not included in organization or enterprise accounts.

There are two types of Codespaces usage: compute and storage. During your monthly billing period, as you use Codespaces, your compute and storage usage is deducted from the quota of free usage that's included in your personal GitHub account, until either compute or storage is consumed. Once one of those limits is reached, your use of GitHub Codespaces will be restricted, unless you've set up a spending limit and a payment method. You will not be able to create new codespaces or open existing codespaces, that you would be billed for, until your quota renews. If you have access to repositories owned by an organization that pays for use of GitHub Codespaces, you may still be able to create codespaces for those repositories.
The amount of free usage provided on your personal account every month is designed to allow you to make open source contributions, or to work on side projects, free of charge. It is not intended to be enough for you to do everyday work free of charge.
About Codespaces compute
Codespaces compute is counted in core hours, which is the sum of the time a codespace is active, multiplied by the multiplier for the codespace's machine type: for example, a multiplier of 2 for a 2-core machine, or a multiplier of 8 for an 8-core machine. A codespace becomes active when you create it or start it. A codespace stops being active when you stop it or delete it, or when it is stopped or deleted automatically.
The default idle timeout, which stops a codespace after a period of inactivity, is 30 minutes. You can reduce this if required. See the "About billing for compute usage" section of About billing for GitHub Codespaces.
About Codespaces storage
You can see the storage usage for each of your codespaces on the "Your codespaces" page at github.com/codespaces.

Note

If the dev container for a codespace was built from the default image, the size of the codespace shown on this page does not include the size of the base dev container. Storage for the base dev container is provided free of charge. See Storage usage for your base dev container.

For billing purposes, Codespaces storage is counted in GB-months. This is a cumulative measure of the total storage each codespace consumes from creation to deletion, plus the storage for prebuilds. See the "Billing for storage usage" section of About billing for GitHub Codespaces.
Where did my monthly storage go?
Deleting codespaces you're not using will avoid using up the free storage included in your personal account unnecessarily. However, if you have set up prebuild configurations, your included storage may continue to diminish during your monthly billing cycle.
Although prebuilds are not listed on the "Your codespaces" page, prebuilds created for a repository consume storage even if you do not currently have any codespaces for that repository. To avoid this, you can delete the prebuilds configurations you set up. See About GitHub Codespaces prebuilds and Managing prebuilds.
Understanding your Codespaces usage
You can check the cumulative GitHub Codespaces usage for your current monthly billing cycle in your GitHub settings. See Viewing your GitHub Codespaces usage.

You can expand the "Usage hours" and "Storage" section for more information - for example, to see how much of the consumed storage was used by prebuilds.
For more specific information - for example, if you want to know which repositories have prebuilds that are consuming storage - you can generate a usage report. The usage report is a CSV file that's emailed to you. For more information on how to generate a usage report, see Viewing your GitHub Codespaces usage.
To see your Codespaces usage, filter the report to show only rows that mention "Codespaces" in the Product column.

Storage usage for your base dev container
If you don't add a dev container configuration to your repository, or if your configuration does not specify a dev container image to use, then GitHub creates a container from a default Linux image. Storage of base dev containers built from the default dev container image is free of charge and does not consume your included storage. Your storage usage will be based only on the files in your repository, and any files you subsequently add to the codespace, including VS Code extensions. If you use an alternative base image, then the resulting container and all of the files in the codespace will be counted as used storage. For information about what's included in the default Linux image, see the devcontainers/images repository.
You can check which image was used to create a codespace's dev container. In the Terminal of your codespace, run this command.
Shelldevcontainer-info
devcontainer-info

If the dev container for the current codespace was built from the default image, the output of this command will contain the following information.
- Definition ID: universal
- Source code repository: https://github.com/devcontainers/images

Tips for making your allowed usage go further


Your codespaces consume compute usage while they are running. If you're not using a codespace, stopping the codespace prevents unnecessary compute usage. See Stopping and starting a codespace.


You can reduce the idle timeout for Codespaces in your personal settings to less than the default 30 minutes. This will shorten the period of inactivity before your codespaces are automatically stopped. This can save on compute usage. See Setting your timeout period for GitHub Codespaces.


Your codespaces consume storage while they exist. You should delete a codespace you have finished using and know that you will not use again. See Deleting a codespace.
Note

Deleting a codespace will not reduce your used storage amount for the billing current month as this is a cumulative figure.



Configure your retention period to ensure codespaces you forget to delete are deleted automatically. The default retention period is 30 days. See Configuring automatic deletion of your codespaces.


Visual Studio Code extensions consume storage. Make sure you are only installing extensions that you need. You can find out how much space is being used by extensions by running this command in your codespace.
Shelldu -h -s ~/.vscode-remote/extensions
du -h -s ~/.vscode-remote/extensions



Monitor your compute and storage usage by going to your billing page on GitHub, https://github.com/settings/billing, and reviewing the figures in the "Codespaces" section.
Note

Storage is calculated hourly and added to your existing storage usage. Consumed storage is therefore cumulative for the duration of your month-long billing cycle. This means that, during the billing period, the value you see on your billing page will only increase or remain the same. Usage will be reset to zero when a new billing cycle starts. Deleting a codespace, or a prebuild, will not reduce the usage figure for the current month, but it will reduce the rate at which storage usage accumulates.



Ensure that you are using prebuilds for only as many versions and as many regions as you need. See About GitHub Codespaces prebuilds and About billing for GitHub Codespaces.
Note

If your included storage usage is exhausted, new prebuilds are disabled until you set up a spending limit or your included usage quota renews.



If you have configured prebuilds in a repository's settings, but you're not using GitHub Codespaces for that repository, consider deleting the prebuild configuration to avoid prebuilds for that repository consuming your included storage allowance unnecessarily. When you delete a prebuild configuration all the associated prebuilds are deleted, reducing your storage consumption from that point onward. See Managing prebuilds.
You can check for prebuild configurations in the "Codespaces" page of a repository's settings. See Configuring prebuilds.
Alternatively, you can check which repositories have prebuilds by reviewing a usage report. See Understanding your Codespaces usage above.


Storage of containers built from the default dev container image for codespaces is free of charge and does not reduce your included storage. You can therefore avoid your storage allowance being consumed by your dev container by using the default image in your dev container configuration, rather than specifying a more specialized image. See Introduction to dev containers and Storage usage for your base dev container above.\n\n\n\nCodespaces/Troubleshooting/Exporting changesExporting changes to a branchThis article provides steps for exporting your codespace changes to a branch.In this articleAbout exporting changesExporting changes to a branchAbout exporting changes
While using GitHub Codespaces, you may want to export your changes to a branch without launching your codespace. This can be useful when you have hit a spending limit or have a general issue accessing your codespace.
You can export your changes in one of several ways, depending on how you created the codespace. In every case, only the Git branch that is currently checked out in the codespace is exported. Work contained in other branches is not exported.

If you created the codespace from a repository to which you have write access, you can export your changes to a new branch of the repository.
If you created the codespace from a repository to which you only have read access, you can export your changes to a fork of the repository. GitHub Codespaces will create a new fork for you, or link your codespace to an existing fork if you already have one for the repository, and export your changes to a new branch of the fork. For more information, see Using source control in your codespace.
If you created the codespace from a template, and have not yet published it, you can publish the codespace to a new repository.

Note

GitHub blocks pushes containing files larger than 100 MiB. If your codespace contains large files you will not be able to export your changes to a branch or fork. For more information, see About large files on GitHub.

Exporting changes to a branch
The following steps describe how to export your changes to a branch or fork. For information on exporting an unpublished codespace to a new repository, see Creating a codespace from a template.


In the top-left corner of GitHub, select , then click  Codespaces to take you to the "Your codespaces" page at github.com/codespaces. Or, for an individual repository, click the  Code menu.


Click the ellipsis (...) to the right of the codespace you want to export from.


Select  Export changes to a branch or  Export changes to a fork.



In the dialog box, click Create branch or Create fork.


The name of the new branch will be the permanent name of your codespace prefixed by the string codespace-, for example codespace-ideal-space-engine-w5vg5ww5p793g7g9.\n\n\n\nCodespaces/Troubleshooting/Creation and deletionTroubleshooting creation and deletion of codespacesThis article provides troubleshooting steps for common issues you may experience when creating or deleting a codespace, including storage and configuration issues.In this articleCreating codespacesDeleting codespacesContainer storageConfigurationCreating codespaces
No access to create a codespace
GitHub Codespaces is not available for all repositories. If the options for creating a codespace are not displayed, GitHub Codespaces may not be available for that repository.
If you have remaining monthly included usage of GitHub Codespaces on your personal account, or you have set up a payment method and a spending limit, you can create a codespace for any public repository.
You can also create a codespace for any private repository to which you have at least read access, provided this private repository is owned by a personal account. If a repository is private and is owned by an organization, you may or may not be able to create a codespace for that repository, depending on the settings of the organization or its parent enterprise.
If you can't create a codespace for a repository, this may be due to one of the following organization or enterprise settings.

Organization and enterprise owners can choose which users can access GitHub Codespaces in an organization's private  repositories. For more information, see Enabling or disabling GitHub Codespaces for your organization.
Organization and enterprise owners can disable forking for some or all of an organization's private repositories. If you only have read access to a repository, and you cannot fork it, then you cannot create a codespace for that repository. For more information, see Managing the forking policy for your organization.

For information about other organization and enterprise settings that can affect whether you can create a codespace, see Enabling or disabling GitHub Codespaces for your organization.
For more information about included usage for personal accounts, and setting a spending limit, see About billing for GitHub Codespaces and Managing the spending limit for GitHub Codespaces.
Codespace does not open when created
If you create a codespace and it does not open:

Try reloading the page in case there was a caching or reporting problem.
Go to your GitHub Codespaces page: https://github.com/codespaces and check whether the new codespace is listed there. The process may have successfully created the codespace but failed to report back to your browser. If the new codespace is listed, you can open it directly from that page.
Retry creating the codespace for the repository to rule out a transient communication failure.

If you still cannot create a codespace for a repository where GitHub Codespaces is available, you may need to contact support. For more information, see Working with support for GitHub Codespaces.
Codespace creation fails
If the creation of a codespace fails, it's likely to be due to a temporary infrastructure issue in the cloud - for example, a problem provisioning a virtual machine for the codespace. A less common reason for failure is if it takes longer than an hour to build the container. In this case, the build is canceled and codespace creation will fail.
Note

A codespace that was not successfully created is never going to be usable and should be deleted. For more information, see Deleting a codespace.

If you create a codespace and the creation fails:


Check GitHub's Status page for any active incidents.


Go to your GitHub Codespaces page, delete the codespace, and create a new codespace.


If the container is building, look at the logs that are streaming and make sure the build is not stuck. A container build that takes longer than one hour will be canceled, resulting in a failed creation.
One common scenario where this could happen is if you have a script running that is prompting for user input and waiting for an answer. If this is the case, remove the interactive prompt so that the build can complete non-interactively.


Note

To view the logs during a build:


In the browser, if the initial steps of the build process take more than a few seconds, the "Setting up your codespace" page is displayed. Click View logs.



In the VS Code desktop application, click Building codespace in the "Setting up remote connection" popup message that's displayed.

Log messages are printed to the Terminal in VS Code




If you have a container that takes a long time to build, consider using prebuilds to speed up codespace creations. For more information, see Configuring prebuilds.

Deleting codespaces
A codespace can only be deleted by:

The person who created the codespace
An organization owner for an organization-owned codespace
Automatic deletion at the end of a retention period

For more information, see Deleting a codespace and Configuring automatic deletion of your codespaces.
Container storage
When you create a codespace, it has a finite amount of storage and over time it may be necessary for you to free up space. Try running any of the following commands in the GitHub Codespaces terminal to free up storage space.

Remove packages that are no longer used by using sudo apt autoremove.
Clean the apt cache by using sudo apt clean.
See the top 10 largest files in the codespace withsudo find / -printf '%s %p\n'| sort -nr | head -10.
Delete unneeded files, such as build artifacts and logs.

Some more destructive options:

Remove unused Docker images, networks, and containers by using docker system prune (append -a if you want to remove all images, and --volumes if you want to remove all volumes).
Remove untracked files from working tree: git clean -i.

Configuration
If changes to your dev container configuration cause a container error, your codespace will run in recovery mode, and you will see an error message.
This codespace is currently running in recovery mode due to a container error.

Review the creation logs and update the dev container configuration as needed. For more information, see GitHub Codespaces logs.
You can then try restarting the codespace, or rebuilding the container. For more information on rebuilding the container, see Introduction to dev containers.\n\n\n\nCodespaces/Troubleshooting/Authenticating to repositoriesTroubleshooting authentication to a repositoryLearn how to troubleshoot common authentication issues when you clone, push to, or pull from a repository in a codespace.In this articleAuthenticating to the repository you created the codespace fromAuthenticating to repositories that you didn't create the codespace fromWhen you create a codespace for a repository, you can generally use git pull and git push to pull and push changes to that repository without any additional authentication. However, occasionally you may see authentication errors when trying to run these operations.
You may also get errors if you are trying to interact with a repository other than the one from which you created the codespace.
Authenticating to the repository you created the codespace from
If you're trying to push to or pull from the repository from which you created the codespace, but authentication is failing, you may see an error like git@github.com: Permission denied (publickey) or Host key verification failed.
You may see these errors if you use a dotfiles repository with GitHub Codespaces, and you have configured Git to use a protocol other than HTTPS for transferring data to the remote repository. For example, you may have configured Git to use SSH by including lines like the following in a config file in your dotfiles.
[url "git@github.com:"]
  insteadOf = https://github.com/

GitHub Codespaces uses the HTTPS protocol by default, and authenticates with a GITHUB_TOKEN configured with read and write access to the repository from which you created the codespace. We recommend you use the default HTTPS and GITHUB_TOKEN in your codespace. The permissions of the GITHUB_TOKEN are usually limited to just one repository, following the security principle of least privilege. SSH authentication does not have fine-grained repository permissions, so an accidental exposure of your SSH key could give someone access to all your repositories.
To use the default HTTPS, remove the conflicting configuration from your dotfiles. If your dotfiles repository contains an installation script in a recognized file such as install.sh, you can use logic like the following to exclude the configuration in codespaces.
if [ -z "$CODESPACES" ]; then
  git config --global url."git@github.com".insteadOf "https://github.com"
fi

If you're working in a codespace created from a repository you trust, and you need to use SSH, ensure that your codespace is set up to authenticate with an SSH key that is linked to your GitHub account. For more information, see Generating a new SSH key and adding it to the ssh-agent.
Authenticating to repositories that you didn't create the codespace from
The GITHUB_TOKEN in a codespace is configured with read and write access to the repository from which you created the codespace. By default, the token does not have access to other repositories. You may find you cannot clone a repository, or you cannot push to a repository you have cloned.
We do not recommend manually updating the value of the GITHUB_TOKEN in a codespace. If your project requires access to other repositories, you can give codespaces access to these repositories by listing additional permissions in your dev container configuration. This will allow users to authorize the additional permissions when they create a codespace. However, it will not change the permissions of an existing codespace. For more information, see Managing access to other repositories within your codespace.
If you need access to another repository in an existing codespace, or if the permissions you need are specific to you and don't apply to other contributors, you can create a personal access token with access to the repository and add the token to your codespace. We recommend you limit the token's access by using a fine-grained personal access token, selecting only the repositories to which you need access, and giving the required access to the Contents permission only. For more information, see Managing your personal access tokens.
You can then add the token as an environment variable in a codespace, or as a secret for GitHub Codespaces. If you create a secret, you should only allow certain trusted repositories to access the secret. When you add a new secret, you will be prompted to reload your existing codespace to pull in the new secret. For more information, see Managing your account-specific secrets for GitHub Codespaces.
To use the token to authenticate in your codespace, you have the following options.


When you create the environment variable or secret, you can use the name GH_TOKEN. The GH_TOKEN variable is used by default in GitHub CLI operations, so you can clone the repository using the command gh repo clone OWNER/REPO.
However, if you then try to push to the repository using git push, Git's credential helper will try to use the existing GITHUB_TOKEN to authenticate, and authentication will fail. You can override the helper, but this may introduce friction when you try to interact with the original repository from which you created the codespace.


You can clone the repository with a URL that includes the access token. Replace YOUR-VARIABLE with the name of the environment variable or secret you created.
git clone https://USERNAME:$YOUR-VARIABLE@github.com/OWNER/REPO`

This will store the access token for the specific repository, so you will be able to push to and pull from the repository without overriding the existing credential helper.
Note

If you clone in this way, the token will be visible in your Git configuration. You should only use this method when working in a codespace created from a repository you trust, and you should limit the scope of the access token as much as possible.\n\n\n\nCodespaces/Troubleshooting/ConnectionTroubleshooting your connection to GitHub CodespacesTroubleshooting help for connecting to GitHub Codespaces.In this article503 codespace service unavailableBrowser cannot connectUnable to connect to your codespace in JupyterLabGitHub Codespaces extension for Visual Studio Code cannot connect503 codespace service unavailable
Codespaces are set to stop after 30 minutes without any activity. If you try to interact with a codespace after it has stopped, you may see a 503 service unavailable error.

If a Start button is shown in Visual Studio Code or in your browser window, click Start to reconnect to the codespace.
Reset your codespace by reloading the window. From the Command Palette in Visual Studio Code, click Developer: Reload Window.

Browser cannot connect
Sometimes you may not be able to access a codespace from your browser. If this happens, go to https://github.com/codespaces and try connecting to the codespace from that page.

If the codespace is not listed on that page, check that you are the owner of the codespace you are trying to connect to. You can only open a codespace that you created.
If the codespace is listed but you cannot connect from that page, check whether you can connect using a different browser.

Diagnose by error message
"Oh no, it looks like you are offline"
Check that you have a stable internet connection and that your company network is not blocking the connection. If possible, check logging for rejected connections on your device.
If you see rejected connections, make sure the domains documented by the /meta REST API endpoint are not blocked by your firewall. For more information, see REST API endpoints for meta data.
To get the list of domains required by GitHub Codespaces, execute the following command using GitHub CLI:
gh api meta --jq .domains.codespaces
"We are having trouble fetching your codespace information"
This is a transitional error. Wait for a few minutes and try again.
"We were unable to authenticate your connection"
This indicates that something went wrong with authentication. Try clearing up your local storage and cookies and try again.
If you still can't connect and the message you're seeing isn't in this list, check the service availability of Codespaces at githubstatus.com. If the Codespaces service is available, you may need to contact support. For more information, see Working with support for GitHub Codespaces.
Unable to connect to your codespace in JupyterLab
To be able to use a codespace in JupyterLab, you must ensure that your codespace has it installed. The default dev container image that's used by GitHub Codespaces includes JupyterLab, but if you have customized your dev container configuration you will have to manually install JupyterLab.
If your codespace uses a Debian-based image, you can install JupyterLab in the dev container by adding the python feature to your devcontainer.json file, with the installJupyterlab option set to true. Otherwise, install it directly in your Dockerfile. For installation instructions, see Installation in the JupyterLab documentation.
For more information about the python feature, see the README page in the devcontainers/features repository. For more information about the devcontainer.json file and the Dockerfile, see Introduction to dev containers.
If you still cannot connect, you may need to contact support. For more information, see Working with support for GitHub Codespaces.
GitHub Codespaces extension for Visual Studio Code cannot connect
If you cannot connect to a codespace from Visual Studio Code desktop, use the following troubleshooting steps.

Check that you have the latest version of the GitHub Codespaces extension installed. The extension is a preview release and frequent updates are released.

In Visual Studio Code, display the "Extensions" tab.
Select the GitHub Codespaces extension to display the extension's overview page.
If an update is available, a button is shown, click Update to X.X.X to upgrade to the latest version.


Check whether you are using the stable build of Visual Studio Code or the Visual Studio Code Insiders release (nightly updates). If you are using the insiders release, try installing the stable build.
Make sure your company network is not blocking the connection.

If you receive errors like connect EACCES, connect ECONNREFUSED, getaddrinfo ENOTFOUND, or other similar errors, your firewall is likely blocking connections to our connection service. To verify this, please visit this URL. If the request fails or you see no data, you likely need to work with your system administrator add *.visualstudio.com to your firewall's IP allow list.
If you see the error Tunnel service HTTPS certificate is invalid. This may be caused by the use of a self-signed certificate or a firewall intercepting the connection it's likely that your firewall is doing TLS inspection and injecting a self-signed certificate which GitHub is not able to verify. To resolve this, your system administrator will either need to allow *.visualstudio.com to bypass the inspection or install the root CA that the firewall is injecting on your local machine.



If you still cannot connect, you may need to contact support. For more information, see Working with support for GitHub Codespaces.
The codespace has latency issues
If the codespace seems particularly slow or has latency issues, it is possible that it has been created in a region that is far from you. To resolve this, you can manually set your GitHub Codespaces region.\n\n\n\nCodespaces/Troubleshooting/Codespaces prebuildsTroubleshooting prebuildsYou can use prebuilds to speed up the creation of codespaces. This article provides troubleshooting steps for common issues with prebuilds.In this articleChecking whether a codespace was created from a prebuild?Checking prebuild usageThe "Prebuild Ready" label is sometimes missingSome resources cannot be accessed in codespaces created using a prebuildTroubleshooting failed workflow runs for prebuildsFurther readingFor more information about GitHub Codespaces prebuilds, see Prebuilding your codespaces.
Checking whether a codespace was created from a prebuild?
When you create a codespace, you can choose the type of the virtual machine you want to use. If a prebuild is available for the type of virtual machine, " Prebuild ready" is shown next to it.

If you have your GitHub Codespaces editor preference set to "Visual Studio Code for Web" then the "Setting up your codespace" page will show the message "Prebuilt codespace found" if a prebuild is being used.

Similarly, if your editor preference is "VS Code" then the integrated terminal will contain the message "You are on a prebuilt codespace defined by the prebuild configuration for your repository" when you create a new codespace. For more information, see Setting your default editor for GitHub Codespaces.
After you have created a codespace you can check whether it was created from a prebuild by running the following GitHub CLI command in the terminal:
Shellgh api /user/codespaces/$CODESPACE_NAME --jq .prebuild
gh api /user/codespaces/$CODESPACE_NAME --jq .prebuild

This returns true if the codespace was created using a prebuild.
Alternatively, if GitHub CLI (gh) is not installed, you can use the following command, which returns createFromPrebuild if the codespace was created from a prebuild:
Shellcat /workspaces/.codespaces/shared/environment-variables.json | jq '.ACTION_NAME'
cat /workspaces/.codespaces/shared/environment-variables.json | jq '.ACTION_NAME'

Checking prebuild usage
You can check whether a repository is using prebuilds in the "Codespaces" page of the repository's settings.
You can check how much storage space has been consumed by prebuilds in your current billing cycle by reviewing the billing data for your personal or organization account. You can also generate a usage report to see which repositories have been using prebuilds. For more information, see Viewing your GitHub Codespaces usage.
The "Prebuild Ready" label is sometimes missing
You may notice that sometimes, when you create a new codespace from a prebuild-enabled branch, the " Prebuild Ready" label is not displayed in the dialog box for choosing a machine type. This means that prebuilds are not currently available.
By default, each time you push to a prebuild-enabled branch, the prebuild is updated. If the push involves a change to the dev container configuration then, while the update is in progress, the " Prebuild Ready" label is removed from the list of machine types. During this time you can still create codespaces without a prebuild. If required, you can reduce the occasions on which prebuilds are unavailable for a repository by setting the prebuild to be updated only when you make a change to your dev container configuration files, or only on a custom schedule. For more information, see Configuring prebuilds.
If your branch is not specifically enabled for prebuilds it may still benefit from prebuilds if it was branched from a prebuild-enabled branch. However, if the dev container configuration is changed on your branch, so that it's not the same as the configuration on the base branch, prebuilds will no longer be available on your branch.
Here are things to check if the " Prebuild Ready" label is not displayed for a particular branch:

Confirm that a prebuild configuration exists for this branch. If you’re not a repository administrator, you'll need to reach out to one to confirm this.
Confirm that the prebuild configuration includes your region.
Check whether a change to the dev container configuration was pushed to the prebuild-enabled branch recently. If so, you will typically have to wait until the prebuild workflow run for this push completes before prebuilds are available again.
If no configuration changes were recently made, go to the Actions tab of your repository, click  Codespaces Prebuilds in the workflows list, and check that prebuild workflow runs for the branch are succeeding. If latest runs of a workflow failed, and one or more of these failed runs contained changes to the dev container configuration, then there will be no available prebuilds for the associated branch.

Some resources cannot be accessed in codespaces created using a prebuild
If the devcontainer.json configuration file for a prebuild configuration specifies that permissions for access to other repositories are required, then the repository administrator is prompted to authorize these permissions when they create or update the prebuild configuration. If the administrator does not grant all of the requested permissions there's a chance that problems may occur in the prebuild, and in codespaces created from this prebuild. This is true even if the user who creates a codespace based on this prebuild does grant all of the permissions when they are prompted to do so.
Troubleshooting failed workflow runs for prebuilds
Increasing the GitHub Actions spending limit
Prebuilds are created and updated using GitHub Actions. Your prebuild workflows will fail if you have used all of your GitHub Actions minutes and have reached your spending limit. If this occurs you can increase your GitHub Actions spending limit to allow the workflows to run. For more information, see Managing your spending limit for GitHub Actions.
Authorizing access permissions
If the devcontainer.json configuration file for a prebuild configuration is updated to specify that permissions for access to other repositories are required, and a repository administrator has not been prompted to authorize these permissions for the prebuild configuration, then the prebuild workflow may fail. Try updating the prebuild configuration, without making any changes. If, when you click Update, the authorization page is displayed, check that the requested permissions are appropriate and, if so, authorize the request. For more information, see Managing prebuilds and Managing access to other repositories within your codespace.
If the workflow runs for a prebuild configuration are failing, you can temporarily disable the prebuild configuration while you investigate. For more information, see Managing prebuilds.
Preventing out-of-date prebuilds being used
By default, if the latest prebuild workflow has failed, then a previous prebuild for the same combination of repository, branch, and devcontainer.json configuration file will be used to create new codespaces. This behavior is called prebuild optimization.
We recommend keeping prebuild optimization enabled, because it helps ensure that codespaces can still be created quickly if an up-to-date prebuild is not available. However, as a repository administrator, you can disable prebuild optimization if you run into problems with prebuilt codespaces being behind the current state of the branch. If you disable prebuild optimization, codespaces for the relevant combination of repository, branch, and devcontainer.json file will be created without a prebuild if the latest prebuild workflow has failed or is currently running.


On GitHub, navigate to the main page of the repository.


Under your repository name, click  Settings. If you cannot see the "Settings" tab, select the  dropdown menu, then click Settings.



In the "Code & automation" section of the side bar, click  Codespaces.


To the right of the affected prebuild configuration, select the ellipsis (...), then click Edit.



Scroll to the bottom of the "Edit configuration" page and click Show advanced options.



If you're sure you want to disable the default setting, select Disable prebuild optimization.



To save your change, click Update.


Further reading

Configuring prebuilds
Managing prebuilds\n\n\n\nCodespaces/Troubleshooting/PersonalizationTroubleshooting personalization options for GitHub CodespacesTroubleshooting steps for common issues with dotfiles and Settings Sync.In this articleTroubleshooting dotfilesTroubleshooting Settings SyncYou can personalize GitHub Codespaces by using a dotfiles repository on GitHub or by using Settings Sync. For more information, see Personalizing GitHub Codespaces for your account.
Troubleshooting dotfiles
If your codespace fails to pick up configuration settings from dotfiles, you should work through the following debugging steps.


Enable dotfiles by selecting Automatically install dotfiles in your personal GitHub Codespaces settings.



Check /workspaces/.codespaces/.persistedshare/dotfiles to see if your dotfiles were cloned.

If your dotfiles were cloned, try manually re-running your install script to verify that it is executable.
If your dotfiles were not cloned, check /workspaces/.codespaces/.persistedshare/EnvironmentLog.txt to see if there was a problem cloning them.



Check /workspaces/.codespaces/.persistedshare/creation.log for possible issues. For more information, see Creation logs.


If the configuration from your dotfiles is correctly picked up, but part of the configuration is incompatible with codespaces, use the $CODESPACES environment variable to add conditional logic for codespace-specific configuration settings. For more information about configuration that may be incompatible with codespaces, see:

Troubleshooting authentication to a repository
Troubleshooting GPG verification for GitHub Codespaces

Troubleshooting Settings Sync
You can turn off Settings Sync to stop syncing settings to and from an instance of VS Code.
When you turn off Settings Sync in a codespace, new codespaces continue to use the settings cached from the last time your settings were pushed to the cloud. If you use the VS Code web client for codespaces, and want codespaces to use the default settings instead of your cached settings, you can disable Settings Sync. For more information, see Managing your preferences for Settings Sync.
If you want to return to using the default VS Code settings in all instances of VS Code, including the desktop application, you can clear the cache in the cloud when you turn off Settings Sync.


If Settings Sync is currently turned off in your instance of VS Code, and you want to clear your cached settings, you must first turn it on. For instructions, see Personalizing GitHub Codespaces for your account.


At the bottom of the Activity Bar, select  and click Settings Sync is On.


In the dropdown, click Settings Sync: Turn Off.



To clear your cached settings, in the dialog, select Turn off sync on all your devices and clear the data from the cloud.



Click Turn off.\n\n\n\nCodespaces/Troubleshooting/Port forwardingTroubleshooting port forwarding for GitHub CodespacesTroubleshooting steps for common port forwarding issues.When an application running inside a codespace outputs a port to the console, GitHub Codespaces detects the localhost URL pattern and automatically forwards the port. For more information, see Forwarding ports in your codespace.
If a port is not automatically forwarded, you can forward it manually. For more information, see Forwarding ports in your codespace.
If port forwarding is set up, check the following:

Use the link in the notification "toast" message, that pops up in the bottom right corner of VS Code, or click the URL in Terminal, to open the forwarded port. Typing in localhost:8000 (as an example) to your local machine will not work if you're connected to the codespace via the browser.
Make sure to check that your application is still running from within your codespace. If your codespace has stopped after a period of inactivity, you'll need to ensure to restart your application once the codespace has restarted.

Typically, you can make a forwarded port accessible publicly, or within the organization that owns a repository. For more information, see Forwarding ports in your codespace. If either, or both, of the options for public or organization visibility are not available, this indicates that an organization-level policy has been configured. For more information, see Restricting the visibility of forwarded ports.
The domain GitHub uses for port forwarding may change from time to time. If you reference a forwarded port in your code, for example in a test, we recommend that you use an environment variable instead of hardcoding the URL. For more information, see Default environment variables for your codespace.\n\n\n\nCodespaces/Troubleshooting/GPG verificationTroubleshooting GPG verification for GitHub CodespacesThis article provides troubleshooting advice for errors related to signing your commits in codespaces.In this articleErrors after disabling GPG verificationErrors caused by conflicting Git configurationErrors in the VS Code "Source Control" viewFurther readingIf you enable GPG verification, GitHub Codespaces automatically signs your commits in codespaces that you create from selected repositories. For more information, see Managing GPG verification for GitHub Codespaces.
Once you enable GPG verification, it will automatically take effect in any new codespaces you create from the relevant repositories. To have GPG verification take effect in an existing active codespace, you will need to stop and restart the codespace. For more information, see Stopping and starting a codespace.
If GitHub Codespaces fails to sign a commit, you may see the error message gpg failed to sign the data in the command line or in a Visual Studio Code pop-up window.
The following sections of this article provide troubleshooting advice for common causes of this error.

If GPG verification has previously been enabled in your settings for GitHub Codespaces, and you have recently disabled GPG verification or removed a repository from your list of trusted repositories, Git may still be trying to sign your commits. For more information, see Errors after disabling GPG verification.
If GPG verification is enabled for the codespace, you may have overridden the Git configuration required to sign your commits. For more information, see Errors caused by conflicting Git configuration.
If GPG verification is disabled for the codespace, and you're encountering the error when trying to commit from the "Source Control" view in VS Code, this may be because of your VS Code settings. For more information, see Errors in the VS Code "Source Control" view.

Errors after disabling GPG verification
When you enable GPG verification, GitHub Codespaces signs all the commits you make in codespaces by default. It does this by setting the commit.gpgsign Git configuration value to true.
If you have disabled GPG verification, and are working in an existing codespace, then this value will still be set to true. This means that GitHub Codespaces will try to sign your commits, but will be unable to do so, because you have disabled the GPG verification setting.
To keep making regular, unsigned commits in your codespace, reset commit.gpgsign to the default value of false by entering the following command in the terminal.
Shellgit config --unset commit.gpgsign
git config --unset commit.gpgsign

To check that the value has been correctly removed from your configuration, you can enter git config --list. You should not see a value for commit.gpgsign in the list.
Errors caused by conflicting Git configuration
To automatically sign your commits, GitHub Codespaces sets certain Git configuration values in your codespace. If you override the values set by GitHub Codespaces, you may be unable to sign your commits.
You may be inadvertently overriding these values if you have linked GitHub Codespaces with a dotfiles repository that contains Git configuration files. For more information about using dotfiles with GitHub Codespaces, see Personalizing GitHub Codespaces for your account.
Checking for conflicting configuration
To sign your commits with GPG, GitHub Codespaces automatically sets the following Git configuration values at the system level.





















Configuration settingRequired valueuser.nameMust match the full name set on your GitHub profilecredential.helperMust be set to /.codespaces/bin/gitcredential_github.shgpg.programMust be set to /.codespaces/bin/gh-gpgsign
To check that these values are set correctly in a codespace, you can use the git config --list --show-origin command. Because GitHub Codespaces sets this configuration at the system level, the required configuration settings should come from /usr/local/etc/gitconfig.
$ git config --list --show-origin
file:/usr/local/etc/gitconfig   credential.helper=/.codespaces/bin/gitcredential_github.sh
file:/usr/local/etc/gitconfig   user.name=Mona Lisa
file:/usr/local/etc/gitconfig   gpg.program=/.codespaces/bin/gh-gpgsign

In addition to the values listed above, you may run into errors if the dotfiles used in your codespaces contain any of the following values.

The user.signingkey Git config value
The commit.gpgsign Git config value
A manually set GITHUB_TOKEN

Removing conflicting configuration
If you want to keep automatic GPG verification for GitHub Codespaces enabled, you will need to remove any conflicting configuration from the dotfiles used in your codespaces.
For example, if the global .gitconfig file on your local machine contains a gpg.program value, and you have pushed this file to a dotfiles repository that is linked with GitHub Codespaces, then you may want to remove gpg.program from this file and set it at the system level on your local machine instead.
Note

Any changes to your dotfiles repository will apply to new codespaces you create, but not to your existing codespaces.



On your local machine, open a terminal.


To remove the conflicting value from ~/.gitconfig (Mac/Linux) or C:\Users\YOUR-USER\.gitconfig (Windows), use the git config --global --unset command.
git config --global --unset gpg.program



Push the change to your dotfiles repository on GitHub.


Optionally, to keep your local configuration, set the value again in a Git configuration file that you do not push to your dotfiles repository.
For example, you can use the --system flag to set the configuration in the system-level file at PATH/etc/gitconfig, where PATH is the directory in which Git is installed on your system.
git config --system gpg.program gpg2



Alternatively, if your dotfiles repository contains an installation script in a recognized file such as install.sh, you can use the $CODESPACES environment variable to add conditional logic, such as only setting gpg.program when you are not in a codespace. In the following example, -z "$CODESPACES" returns true if you are not in a codespace.
Shellif [ -z "$CODESPACES" ]; then
  git config --global gpg.program gpg2
fi
if [ -z "$CODESPACES" ]; then
  git config --global gpg.program gpg2
fi

Errors in the VS Code "Source Control" view
If GPG verification is disabled in your settings for GitHub Codespaces, or the repository you created the codespace from isn't in your list of trusted repositories, then Git should not attempt to sign your commits. If you encounter a signing error when trying to commit from the "Source Control" view in VS Code, you should check the VS Code settings in your codespace.


In the lower-left corner of the window, select , then click Settings.



On the "User" tab, in the search bar, search for "gpg".


Verify that the "Enables commit signing with GPG or X.509" setting is deselected.



If you find this setting is enabled, you should either deselect the checkbox to stop VS Code trying to sign your commits, or you should enable GPG verification for the repository you're working in so your commits can be signed successfully.
If you change your VS Code settings, you must ensure Settings Sync is enabled if you want to share your changes with other codespaces you create. You should only turn on Settings Sync in a codespace created from a repository you trust. For more information, see Personalizing GitHub Codespaces for your account.
Further reading

About commit signature verification
git config in the official Git documentation\n\n\n\nCodespaces/Troubleshooting/Working with supportWorking with support for GitHub CodespacesTips on getting the best help from support for GitHub Codespaces.In this articleCodespace namesCodespaces IDsBefore support can help you with problems with codespaces, you need to know the permanent name of the codespace and its codespaces ID (identifier). In addition, support may ask you to share some logs with them. For more information, see GitHub Codespaces logs and About GitHub Support.
Codespace names
Each codespace has two names: a display name, that you can change, and a unique, permanent name, that you cannot change. Unless you create a codespace with the GitHub CLI and specify a display name of your choice, the display name is automatically generated when you create a codespace, consisting of two or three random words - for example, literate space parakeet. The permanent name is a combination of the initial display name, followed by some random characters - for example, literate-space-parakeet-w5vg5ww5p793g7g9. If you change the display name the permanent name remains unaffected. For more information, see Renaming a codespace.
You will occasionally need to know the permanent name of a codespace. For example, when you use some GitHub CLI commands, or when you discuss a particular codespace with GitHub support.
To find the permanent name of a codespace, do one of the following:

Open the codespace in the browser. The subdomain of the URL is the name of the codespace. For example: https://obscure-space-engine-grx7rgg6qp43v9j5.github.dev is the URL for the obscure-space-engine-grx7rgg6qp43v9j5 codespace.
If you cannot open a codespace, you can access the name from your list of codespaces at https://github.com/codespaces. Right-click the display name of the codespace and select your browser's option for copying the link address. The final part of the URL you copy is the permanent name of the codespace.
In a codespace, use this command in the terminal: echo $CODESPACE_NAME.
If GitHub CLI is installed, either locally or in a codespace, use this command in the terminal to list all of your codespaces: gh codespace list.

The permanent name the codespace is also included in many of the log files. For example, in the GitHub Codespaces extension log, after fetching codespace or Connecting to codespace, and in the browser console log after clientUrl. For more information, see GitHub Codespaces logs.
Codespaces IDs
Every codespace also has an ID (identifier). This is not shown by default in Visual Studio Code so you may need to update the settings for the GitHub Codespaces extension before you can access the ID.


In Visual Studio Code, browser or desktop, in the Activity Bar on the left, click Remote Explorer to show details for the codespace.
Note

If the Remote Explorer is not displayed in the Activity Bar:

Access the Command Palette. For example, by pressing Shift+Command+P (Mac) / Ctrl+Shift+P (Windows/Linux).
Type: details.
Click Codespaces: Details.




If the side bar includes a "Codespace Performance" section, hover over the Codespace ID and click the clipboard icon to copy the ID.


If the information is not shown, click , in the bottom-left corner of the Activity Bar, and click Settings.


In the Settings tab, search for "performance" then, under "GitHub > Codespaces: Show Performance Explorer", select the checkbox labeled "Display the Codespace Performance window in the Remote Explorer."\n\n\n\nCodespaces/github.dev editorThe github.dev web-based editorYou can use the github.dev web-based editor to edit files and commit your changes.In this articleAbout the github.dev editorOpening the github.dev editorCodespaces and github.devUsing source controlUsing extensionsUsing github.dev behind a firewallTroubleshootingNote
 The github.dev editor is currently in public preview. You can provide feedback in our Discussions.

About the github.dev editor
The github.dev editor introduces a lightweight editing experience that runs entirely in your browser. With the github.dev editor, you can navigate files and source code repositories from GitHub, and make and commit code changes. You can open any repository, fork, or pull request in the editor.
The github.dev editor is available to everyone for free on GitHub.com.
The github.dev editor provides many of the benefits of Visual Studio Code, such as search, syntax highlighting, and a source control view. You can also use Settings Sync to share your own VS Code settings with the editor. See Settings Sync in the VS Code documentation.
The github.dev editor runs entirely in your browser’s sandbox. The editor doesn’t clone the repository, but instead uses the GitHub Repositories extension to carry out most of the functionality that you will use. Your work is saved in the browser’s local storage until you commit it. You should commit your changes regularly to ensure that they're always accessible.
You must be signed in to GitHub to use the github.dev editor.
Opening the github.dev editor
You can open any GitHub repository in github.dev in either of the following ways:


To open the repository in the same browser tab, press . while browsing any repository or pull request on GitHub.
To open the repository in a new browser tab, press >.


Change the URL from "github.com" to "github.dev".


When viewing a file, select the  dropdown menu and click github.dev.



Codespaces and github.dev
Both github.dev and GitHub Codespaces allow you to edit your code straight from your repository. However, both have slightly different benefits, depending on your use case.









































github.devGitHub CodespacesCostFree.Free monthly quota of usage for personal accounts. For information on pricing, see About billing for GitHub Codespaces.AvailabilityAvailable to everyone on GitHub.com.Available to everyone on GitHub.com.Start upgithub.dev opens instantly with a key-press and you can start using it right away, without having to wait for additional configuration or installation.When you create or resume a codespace, the codespace is assigned a VM and the container is configured based on the contents of a devcontainer.json file. This set up may take a few minutes to create the environment. See Creating a codespace for a repository.ComputeThere is no associated compute, so you won’t be able to build and run your code or use the integrated terminal.With GitHub Codespaces, you get the power of a dedicated VM on which you can run and debug your application.Terminal accessNone.GitHub Codespaces provides a common set of tools by default, meaning that you can use the Terminal exactly as you would in your local environment.ExtensionsOnly a subset of extensions that can run in the web will appear in the Extensions View and can be installed. See Using extensions.With GitHub Codespaces, you can use most extensions from the Visual Studio Code Marketplace.

Continue working on Codespaces
You can start your workflow in github.dev and continue working on a codespace. If you try to access the Run and Debug View or the Terminal, you'll be notified that they are not available in github.dev.
To continue your work in a codespace, click Continue Working on… and select Create New Codespace to create a codespace on your current branch. Before you choose this option, you must commit any changes.

Using source control
When you use github.dev, all actions are managed through the "Source Control" view, which is located in the Activity Bar on the left hand side. For more information on the "Source Control" view, see Version Control in the VS Code documentation.
Because github.dev uses the GitHub Repositories extension to power its functionality, you can switch branches without needing to stash changes. See GitHub Repositories in the VS Code documentation.
Create a new branch


If the current branch is not shown in the status bar, at the bottom of your codespace, right-click the status bar and select Source control.


Click the branch name in the status bar.



In the dropdown, either click the branch you want to switch to, or enter the name for a new branch and click Create new branch.

Any uncommitted changes you have made in your old branch will be available on your new branch.


Commit your changes


In the Activity Bar, click the Source Control view.



To stage your changes, click  next to the file you've changed, or next to Changes if you've changed multiple files and you want to stage them all.



In the text box, type a commit message describing the change you've made.



Click Commit & Push.
Your changes are automatically be pushed to your branch on GitHub.


Create a pull request


After you've committed changes to your local copy of the repository, click the pull request icon at the top of the "Source Control" side bar.



Check that the local branch and repository you're merging from, and the remote branch and repository you're merging into, are correct. Then give the pull request a title and a description.



Click Create.


Working with an existing pull request
You can use github.dev to work with an existing pull request.

Browse to the pull request you'd like to open in github.dev.
Press . to open the pull request in github.dev.
Once you have made any changes, commit them using the steps in Commit your changes. Your changes will be committed directly to the branch, it's not necessary to push the changes.

Using extensions
The github.dev editor supports VS Code extensions that have been specifically created or updated to run in the web. These extensions are known as "web extensions". To learn how you can create a web extension or update your existing extension to work for the web, see Web extensions in the VS Code documentation.
Extensions that can run in github.dev will appear in the Extensions View and can be installed. If you use Settings Sync, any compatible extensions are also installed automatically. For information, see Settings Sync in the VS Code documentation.
Using github.dev behind a firewall
If you are working behind a firewall you will need to add the following URLs to your firewall's allow list.

























URLUsehttps://*.vscode-cdn.netgithub.dev runs entirely in the browser. To do so it needs to download VS Code assets from endpoints at this URL.https://update.code.visualstudio.comgithub.dev runs entirely in the browser. To do so it needs to download VS Code assets from endpoints at this URL.https://api.github.comUsed to retrieve source files from GitHubhttps://vscode-sync-insiders.trafficmanager.netOptional. To allow settings to be synchronized via Settings Sync.
Every extension installed in github.dev is run under an independent web worker. This adds a layer of security between multiple extensions running in the same browser. As a result, request URLs coming from extensions are similar to this: https://v--151hfiju3s93ktt2rqh65902gukb27osot905m4g52k40kaea3h6.vscode-cdn.net.
Data is retrieved from the repository at runtime using the GitHub Repositories extension. This data is not stored on the local computer between github.dev sessions, with the exception of the browser storage of unsaved files and currently displayed files (to allow for page reloads). The only non-repository data that's stored locally between sessions are some user settings and the credentials sent by GitHub's authentication flow.
Troubleshooting
If you have issues opening github.dev, try the following:

Make sure you are signed in to GitHub.
Disable any ad blockers.
Use a non-incognito window in your browser to open github.dev.

Known limitations

The github.dev editor is currently supported in Chrome (and various other Chromium-based browsers), Edge, Firefox, and Safari. We recommend that you use the latest versions of these browsers.
Some keybindings may not work, depending on the browser you are using. These keybinding limitations are documented in the Known limitations and adaptations section of the VS Code documentation.
. may not work to open github.dev according to your local keyboard layout. In that case, you can open any GitHub repository in github.dev by changing the URL from github.com to github.dev.
When intensively writing documentation or code in the web editor, you might encounter issues with pushing some commits. To resolve this, wait a few minutes for the API rate limit to reset.\n\n\n\nGuides for CodespacesLearn how to make the most of GitHubAll Codespaces guides48 guides foundQuickstart for GitHub CodespacesGet started with GitHub Codespaces quickly.CodespacesDeep dive into GitHub CodespacesQuickstartExplore more detail about how GitHub Codespaces work.CodespacesIntroduction to dev containersHow-to guideWhen you work in a codespace, the environment you are working in is created using a development container, or dev container, hosted on a virtual machine.CodespacesSet upFundamentalsSetting up a Node.js project for GitHub CodespacesTutorialGet started with a Node.js, JavaScript, or TypeScript project in GitHub Codespaces by creating a custom dev container configuration.CodespacesDeveloperSet upSetting up a Python project for GitHub CodespacesTutorialGet started with a Python project in GitHub Codespaces by creating a custom dev container configuration.CodespacesDeveloperSet upSetting up a C# (.NET) project for GitHub CodespacesTutorialGet started with a C# (.NET) project in GitHub Codespaces by creating a custom dev container configuration.CodespacesDeveloperSet upSetting up a Java project for GitHub CodespacesTutorialGet started with a Java project in GitHub Codespaces by creating a custom dev container configuration.CodespacesDeveloperSet upSetting up a PHP project for GitHub CodespacesTutorialGet started with a PHP project in GitHub Codespaces by creating a custom dev container configuration.CodespacesDeveloperSet upSetting a minimum specification for codespace machinesHow-to guideYou can avoid under-resourced machine types being used for GitHub Codespaces for your repository.CodespacesSet upAdding features to a devcontainer.json fileHow-to guideWith features, you can quickly add tools, runtimes, or libraries to your dev container configuration.CodespacesSet upAutomatically opening files in the codespaces for a repositoryHow-to guideYou can set particular files to be opened automatically whenever someone creates a codespace for your repository and opens the codespace in the Visual Studio Code web client.CodespacesSet upSpecifying recommended secrets for a repositoryHow-to guideYou can add a setting to your dev container configuration that will prompt people to set specific development environment secrets when they create a codespace.CodespacesSet upFacilitating quick creation and resumption of codespacesHow-to guideYou can add a link to take people straight to a page for creating a codespace, with your choice of options preconfigured. Alternatively you can link to the "Resume codespace" page.CodespacesSet upSetting up a template repository for GitHub CodespacesHow-to guideYou can help people get started with a project by setting up a template repository for use with GitHub Codespaces.CodespacesSet upPersonalizing GitHub Codespaces for your accountHow-to guideYou can personalize GitHub Codespaces by using a dotfiles repository on GitHub or by using Settings Sync.CodespacesSet upFundamentalsCreating a codespace for a repositoryHow-to guideYou can create a codespace for a branch in a repository to develop online.CodespacesFundamentalsDeveloperCreating a codespace from a templateHow-to guideIf you're starting a new project, you can create a codespace from a blank template or choose a template specially designed for the type of work you want to do.CodespacesFundamentalsDeveloperDeveloping in a codespaceHow-to guideYou can work in a codespace using your browser, Visual Studio Code, or in a command shell.CodespacesFundamentalsDeveloperDeleting a codespaceHow-to guideYou can delete a codespace you no longer need.CodespacesFundamentalsDeveloperForwarding ports in your codespaceHow-to guideYou can forward ports in your codespace to test and debug your application. You can also manage the port protocol and share the port within your organization or publicly.CodespacesFundamentalsDeveloperOpening an existing codespaceHow-to guideYou can reopen a codespace that you have closed or stopped and return to your work.CodespacesFundamentalsDeveloperStopping and starting a codespaceHow-to guideYou can stop and start your codespace to save resources and to pause work.CodespacesFundamentalsDeveloperWorking collaboratively in a codespaceHow-to guideYou can work collaboratively with other people in a codespace by using Visual Studio Live Share.CodespacesDeveloperUsing GitHub Codespaces in Visual Studio CodeHow-to guideYou can develop in your codespace directly in Visual Studio Code by connecting the GitHub Codespaces extension with your GitHub account.CodespacesVisual Studio CodeDeveloperUsing GitHub Codespaces with GitHub CLIHow-to guideYou can work with GitHub Codespaces directly from your command line by using gh, the GitHub command line interface.CodespacesCLIDeveloperUsing source control in your codespaceHow-to guideAfter making changes to a file in your codespace you can quickly commit the changes and push your update to the remote repository.CodespacesFundamentalsDeveloperUsing GitHub Codespaces for pull requestsHow-to guideYou can use GitHub Codespaces in your web browser, or in Visual Studio Code to create pull requests, review pull requests, and address review comments.CodespacesVisual Studio CodeDeveloperChanging the machine type for your codespaceHow-to guideYou can change the type of machine that's running your codespace, so that you're using resources appropriate for the work you're doing.CodespacesConfiguring automatic deletion of your codespacesHow-to guideInactive codespaces are automatically deleted. You can choose how long your stopped codespaces are retained, up to a maximum of 30 days.CodespacesSetting your default editor for GitHub CodespacesHow-to guideYou can set your default editor for Codespaces in your personal settings page.CodespacesSetting your default region for GitHub CodespacesHow-to guideYou can set your default region in the GitHub Codespaces profile settings page to personalize where your data is held.CodespacesSetting your timeout period for GitHub CodespacesHow-to guideYou can set your default timeout for GitHub Codespaces in your personal settings page.CodespacesManaging your account-specific secrets for GitHub CodespacesHow-to guideYou can store sensitive information, like tokens, that you want to access in your codespaces via environment variables.CodespacesDeveloperSecuritySecret storeManaging access to other repositories within your codespaceYou can manage the repositories that GitHub Codespaces can access.CodespacesSecurityManaging GPG verification for GitHub CodespacesHow-to guideYou can allow GitHub to automatically use GPG to sign commits you make in your codespaces, so other people can be confident that the changes come from a trusted source.CodespacesDeveloperSecurityEnabling or disabling GitHub Codespaces for your organizationHow-to guideYou can control which users can use GitHub Codespaces in your organization's private repositories.CodespacesBillingAdministratorManaging the cost of GitHub Codespaces in your organizationReferenceYou can check your GitHub Codespaces usage and set usage limits.CodespacesBillingManaging development environment secrets for your repository or organizationDevelopment environment secrets allow you to store sensitive information in your organization or repository for use with GitHub Codespaces.CodespacesSecret storeSecurityRestricting access to machine typesHow-to guideYou can set constraints on the types of machines users can choose when they create codespaces in your organization.CodespacesRestricting the base image for codespacesHow-to guideYou can specify which base images can be used to create the dev container for new codespaces created within your organization.CodespacesRestricting the idle timeout periodHow-to guideYou can set a maximum timeout period for any codespaces owned by your organization.CodespacesRestricting the retention period for codespacesHow-to guideYou can set a maximum retention period for any codespaces owned by your organization.CodespacesRestricting the visibility of forwarded portsHow-to guideYou can set constraints on the visibility options users can choose when they forward ports from codespaces in your organization.CodespacesReviewing your organization's audit logs for GitHub CodespacesHow-to guideYou can use the audit log to review all actions related to GitHub Codespaces.CodespacesSecurityAdministratorAbout billing for GitHub CodespacesOverviewLearn about the costs for using GitHub Codespaces, and the monthly usage quotas included with GitHub personal accounts.CodespacesBillingUsing the Visual Studio Code Command Palette in GitHub CodespacesReferenceYou can use the Command Palette feature of Visual Studio Code to access many commands in GitHub Codespaces.CodespacesVisual Studio CodeDisaster recovery for GitHub CodespacesThis article describes guidance for a disaster recovery scenario, when a whole region experiences an outage due to major natural disaster or widespread service interruption.CodespacesSecurity in GitHub CodespacesReferenceOverview of the GitHub Codespaces security architecture, with guidelines to help you maintain security and minimize the risk of attack.CodespacesSecurity\n\n\n\nVideo transcripts/CodespacesTranscript - "Codespaces - Your instant dev box in the cloud"Audio and visual transcript.See video for this transcript[A developer wearing a blue t-shirt sits at home, behind a mic and a pop shield decorated with GitHub's Octocat logo. The developer shares their screen while still showing on webcam in the upper-right corner. On their screen, they are looking at a GitHub repository called "js-project".]
Developer: So, today we're gonna run my JavaScript project in GitHub Codespaces.
[On the repository page, above the list of files, the developer selects the "Code" button to open a dropdown menu. They click "Open with Codespaces", then click "New codespace".]
Developer: So while we're creating our codespace, you might have the question, "What even is a codespace?"
[In the browser, the codespace loads. On a white background, the text "Preparing your codespace" is displayed below GitHub's Octocat logo and a VS Code logo.]
Developer: A codespace is an instant cloud developer environment, where we can run, test, debug, push: everything that we're used to doing in a development environment, but without any of the machine setup we're used to doing locally.
[The codespace opens in the VS Code web editor in the browser, running with the dark theme. Directories and files from the repository are displayed in the left sidebar. In an integrated terminal, a message says, "Welcome to Codespaces," and lists included runtimes and tools.]
Developer: So when we create this codespace, you'll see we land in a machine that is already set up, and it has Python, Node, Docker, and even more, so it has tools like Java and Rust and Go and C++.
But you'll see we landed in the default image. The great thing about Codespaces is you can fully customize your setup, not only for you, but for everyone else who comes along in this repository. So you can have a "config-as-code" setup that allows you to use your own image, or Dockerfile, or Docker Compose.
So for our app, we're actually just gonna go ahead and start it up. So I'm gonna run npm start here, and you'll see that we're told our app is running on port 3000, and we can open it in the browser and connect securely to a forwarded port that has our app fully up and running.
[A popup is displayed for the forwarded port. On the popup, the developer clicks a button labeled "Open in browser". A new browser tab opens showing a web page titled "Haikus for Mona". On the web page, a cartoon image shows a grinning Mona the Octocat skipping over a puddle with a purple umbrella. Below the image, a haiku: "Rain in Seattle. Don't forget an umbrella, or it will be gloom."]
Developer: So you'll see here's my Node app, up and running, connected to in a codespace. And this took us about 60 seconds to get set up in Codespaces.
[The developer scrolls to an image of Mona poking a record player with her tentacle.]
Developer: So you can imagine this fully customized, to really bring down the setup time for really every repository you have.
And that's a quick look at GitHub Codespaces.
End of transcript. For more information about GitHub Codespaces, see the GitHub Codespaces documentation.\n\n\n\nCodespaces documentation Create a codespace to start developing in a secure, configurable, and dedicated development environment that works how and where you want it to.Overview Quickstart View video transcript Start hereView all Enabling or disabling GitHub Codespaces for your organizationYou can control which users can use GitHub Codespaces in your organization's private repositories.Understanding the codespace lifecycleLearn how to develop in a GitHub Codespaces environment, and maintain your data throughout the entire codespace lifecycle.Introduction to dev containersWhen you work in a codespace, the environment you are working in is created using a development container, or dev container, hosted on a virtual machine.Managing access to other repositories within your codespaceYou can manage the repositories that GitHub Codespaces can access.Set up your projectSetting up a Node.js project for GitHub CodespacesGet started with a Node.js, JavaScript, or TypeScript project in GitHub Codespaces by creating a custom dev container configuration.Setting up a Python project for GitHub CodespacesGet started with a Python project in GitHub Codespaces by creating a custom dev container configuration.Setting up a Java project for GitHub CodespacesGet started with a Java project in GitHub Codespaces by creating a custom dev container configuration.Setting up a C# (.NET) project for GitHub CodespacesGet started with a C# (.NET) project in GitHub Codespaces by creating a custom dev container configuration.What's newView all VSCode Copilot agent mode in CodespacesApril 11Scheduled Codespaces maintenance – AprilApril 02Scheduled Codespaces maintenanceFebruary 27GuidesDeep dive into GitHub CodespacesExplore more detail about how GitHub Codespaces work.@GitHubCreating a codespace for a repositoryYou can create a codespace for a branch in a repository to develop online.@GitHubCreating a codespace from a templateIf you're starting a new project, you can create a codespace from a blank template or choose a template specially designed for the type of work you want to do.@GitHubOpening an existing codespaceYou can reopen a codespace that you have closed or stopped and return to your work.@GitHubExplore guides All Codespaces docsGetting started with GitHub CodespacesWhat are GitHub Codespaces?GitHub Codespaces featuresUnderstanding the codespace lifecycleDeep dive into GitHub CodespacesDeveloping in a codespaceDeveloping in a codespaceCreating a codespace for a repositoryCreating a codespace from a templateDeleting a codespaceOpening an existing codespaceWorking collaboratively in a codespaceUsing source control in your codespaceUsing GitHub Codespaces for pull requestsStopping and starting a codespaceForwarding ports in your codespaceRebuilding the container in a codespaceDefault environment variables for your codespacePersisting environment variables and temporary filesConnecting to a private networkGetting started with GitHub Codespaces for machine learningUsing GitHub Codespaces in Visual Studio CodeUsing GitHub Codespaces with GitHub CLICustomizing your codespaceRenaming a codespaceChanging the shell in a codespaceChanging the machine type for your codespaceSetting your user preferencesPersonalizing GitHub Codespaces for your accountSetting your default editor for GitHub CodespacesSetting your default region for GitHub CodespacesSetting your timeout period for GitHub CodespacesConfiguring automatic deletion of your codespacesChoosing the stable or beta host imageSetting up your project for GitHub CodespacesAdding a dev container configuration to your repository • 6 articlesConfiguring dev containers • 4 articlesSetting up your repository for GitHub Codespaces • 2 articlesPrebuilding your codespacesAbout GitHub Codespaces prebuildsConfiguring prebuildsAllowing a prebuild to access other repositoriesManaging prebuildsTesting dev container configuration changes on a prebuild-enabled branchManaging your codespacesManaging your account-specific secrets for GitHub CodespacesManaging access to other repositories within your codespaceReviewing your security logs for GitHub CodespacesManaging GPG verification for GitHub CodespacesManaging GitHub Codespaces for your organizationEnabling or disabling GitHub Codespaces for your organizationChoosing who owns and pays for codespaces in your organizationListing the codespaces in your organizationManaging the cost of GitHub Codespaces in your organizationManaging development environment secrets for your repository or organizationReviewing your organization's audit logs for GitHub CodespacesRestricting access to machine typesRestricting the number of organization-billed codespaces a user can createRestricting the base image for codespacesRestricting the visibility of forwarded portsRestricting the idle timeout periodRestricting the retention period for codespacesReferenceAllowing your codespace to access a private registryUsing GitHub Copilot in GitHub CodespacesUsing the Visual Studio Code Command Palette in GitHub CodespacesSecurity in GitHub CodespacesDisaster recovery for GitHub CodespacesTroubleshooting GitHub CodespacesGitHub Codespaces logsTroubleshooting GitHub Codespaces clientsGetting the most out of your included usageExporting changes to a branchTroubleshooting creation and deletion of codespacesTroubleshooting authentication to a repositoryTroubleshooting your connection to GitHub CodespacesTroubleshooting prebuildsTroubleshooting personalization options for GitHub CodespacesTroubleshooting port forwarding for GitHub CodespacesTroubleshooting GPG verification for GitHub CodespacesWorking with support for GitHub Codespaces\n\n\n\nCodespaces documentation Create a codespace to start developing in a secure, configurable, and dedicated development environment that works how and where you want it to.Overview Quickstart View video transcript Start hereView all Enabling or disabling GitHub Codespaces for your organizationYou can control which users can use GitHub Codespaces in your organization's private repositories.Understanding the codespace lifecycleLearn how to develop in a GitHub Codespaces environment, and maintain your data throughout the entire codespace lifecycle.Introduction to dev containersWhen you work in a codespace, the environment you are working in is created using a development container, or dev container, hosted on a virtual machine.Managing access to other repositories within your codespaceYou can manage the repositories that GitHub Codespaces can access.Set up your projectSetting up a Node.js project for GitHub CodespacesGet started with a Node.js, JavaScript, or TypeScript project in GitHub Codespaces by creating a custom dev container configuration.Setting up a Python project for GitHub CodespacesGet started with a Python project in GitHub Codespaces by creating a custom dev container configuration.Setting up a Java project for GitHub CodespacesGet started with a Java project in GitHub Codespaces by creating a custom dev container configuration.Setting up a C# (.NET) project for GitHub CodespacesGet started with a C# (.NET) project in GitHub Codespaces by creating a custom dev container configuration.What's newView all VSCode Copilot agent mode in CodespacesApril 11Scheduled Codespaces maintenance – AprilApril 02Scheduled Codespaces maintenanceFebruary 27GuidesDeep dive into GitHub CodespacesExplore more detail about how GitHub Codespaces work.@GitHubCreating a codespace for a repositoryYou can create a codespace for a branch in a repository to develop online.@GitHubCreating a codespace from a templateIf you're starting a new project, you can create a codespace from a blank template or choose a template specially designed for the type of work you want to do.@GitHubOpening an existing codespaceYou can reopen a codespace that you have closed or stopped and return to your work.@GitHubExplore guides All Codespaces docsGetting started with GitHub CodespacesWhat are GitHub Codespaces?GitHub Codespaces featuresUnderstanding the codespace lifecycleDeep dive into GitHub CodespacesDeveloping in a codespaceDeveloping in a codespaceCreating a codespace for a repositoryCreating a codespace from a templateDeleting a codespaceOpening an existing codespaceWorking collaboratively in a codespaceUsing source control in your codespaceUsing GitHub Codespaces for pull requestsStopping and starting a codespaceForwarding ports in your codespaceRebuilding the container in a codespaceDefault environment variables for your codespacePersisting environment variables and temporary filesConnecting to a private networkGetting started with GitHub Codespaces for machine learningUsing GitHub Codespaces in Visual Studio CodeUsing GitHub Codespaces with GitHub CLICustomizing your codespaceRenaming a codespaceChanging the shell in a codespaceChanging the machine type for your codespaceSetting your user preferencesPersonalizing GitHub Codespaces for your accountSetting your default editor for GitHub CodespacesSetting your default region for GitHub CodespacesSetting your timeout period for GitHub CodespacesConfiguring automatic deletion of your codespacesChoosing the stable or beta host imageSetting up your project for GitHub CodespacesAdding a dev container configuration to your repository • 6 articlesConfiguring dev containers • 4 articlesSetting up your repository for GitHub Codespaces • 2 articlesPrebuilding your codespacesAbout GitHub Codespaces prebuildsConfiguring prebuildsAllowing a prebuild to access other repositoriesManaging prebuildsTesting dev container configuration changes on a prebuild-enabled branchManaging your codespacesManaging your account-specific secrets for GitHub CodespacesManaging access to other repositories within your codespaceReviewing your security logs for GitHub CodespacesManaging GPG verification for GitHub CodespacesManaging GitHub Codespaces for your organizationEnabling or disabling GitHub Codespaces for your organizationChoosing who owns and pays for codespaces in your organizationListing the codespaces in your organizationManaging the cost of GitHub Codespaces in your organizationManaging development environment secrets for your repository or organizationReviewing your organization's audit logs for GitHub CodespacesRestricting access to machine typesRestricting the number of organization-billed codespaces a user can createRestricting the base image for codespacesRestricting the visibility of forwarded portsRestricting the idle timeout periodRestricting the retention period for codespacesReferenceAllowing your codespace to access a private registryUsing GitHub Copilot in GitHub CodespacesUsing the Visual Studio Code Command Palette in GitHub CodespacesSecurity in GitHub CodespacesDisaster recovery for GitHub CodespacesTroubleshooting GitHub CodespacesGitHub Codespaces logsTroubleshooting GitHub Codespaces clientsGetting the most out of your included usageExporting changes to a branchTroubleshooting creation and deletion of codespacesTroubleshooting authentication to a repositoryTroubleshooting your connection to GitHub CodespacesTroubleshooting prebuildsTroubleshooting personalization options for GitHub CodespacesTroubleshooting port forwarding for GitHub CodespacesTroubleshooting GPG verification for GitHub CodespacesWorking with support for GitHub Codespaces\n\n\n\nCodespaces/Getting startedGetting started with GitHub CodespacesLearn how to get started with GitHub Codespaces, then find out more about how a codespace works.What are GitHub Codespaces?Learn about what GitHub Codespaces are.GitHub Codespaces featuresLearn about what GitHub Codespaces offer.Understanding the codespace lifecycleLearn how to develop in a GitHub Codespaces environment, and maintain your data throughout the entire codespace lifecycle.Deep dive into GitHub CodespacesExplore more detail about how GitHub Codespaces work.\n\n\n\nCodespaces/Developing in a codespaceDeveloping in a codespaceCreate a codespace to get started with developing your project inside a dedicated cloud environment. You can use your codespace in the browser or in a choice of code editors.Developing in a codespaceYou can work in a codespace using your browser, Visual Studio Code, or in a command shell.Creating a codespace for a repositoryYou can create a codespace for a branch in a repository to develop online.Creating a codespace from a templateIf you're starting a new project, you can create a codespace from a blank template or choose a template specially designed for the type of work you want to do.Deleting a codespaceYou can delete a codespace you no longer need.Opening an existing codespaceYou can reopen a codespace that you have closed or stopped and return to your work.Working collaboratively in a codespaceYou can work collaboratively with other people in a codespace by using Visual Studio Live Share.Using source control in your codespaceAfter making changes to a file in your codespace you can quickly commit the changes and push your update to the remote repository.Using GitHub Codespaces for pull requestsYou can use GitHub Codespaces in your web browser, or in Visual Studio Code to create pull requests, review pull requests, and address review comments.Stopping and starting a codespaceYou can stop and start your codespace to save resources and to pause work.Forwarding ports in your codespaceYou can forward ports in your codespace to test and debug your application. You can also manage the port protocol and share the port within your organization or publicly.Rebuilding the container in a codespaceYou can rebuild the dev container of a codespace you are working in to apply configuration changes. From time to time, you may want to perform a full rebuild.Default environment variables for your codespaceGitHub sets default environment variables for each codespace.Persisting environment variables and temporary filesYou can configure custom environment variables so that they are set to the same value every time you open a codespace. You can also ensure that temporary files are not deleted when a codespace stops.Connecting to a private networkYou can connect GitHub Codespaces to resources on a private network, including package registries, license servers, and on-premises databases.Getting started with GitHub Codespaces for machine learningLearn about working on machine learning projects with GitHub Codespaces and its out-of-the-box tools.Using GitHub Codespaces in Visual Studio CodeYou can develop in your codespace directly in Visual Studio Code by connecting the GitHub Codespaces extension with your GitHub account.Using GitHub Codespaces with GitHub CLIYou can work with GitHub Codespaces directly from your command line by using gh, the GitHub command line interface.\n\n\n\nCodespaces/Customizing your codespaceCustomizing your codespaceYou can customize a codespace you've created to suit your own preferences.Renaming a codespaceYou can change the codespace display name to one of your choice on GitHub or using the GitHub CLI.Changing the shell in a codespaceYou can change your shell in a codespace to keep the setup you're used to.Changing the machine type for your codespaceYou can change the type of machine that's running your codespace, so that you're using resources appropriate for the work you're doing.\n\n\n\nCodespaces/Setting your user preferencesSetting your user preferencesYou can adjust your personal settings for GitHub Codespaces so that the codespaces you create always give you the development experience that works best for you.Personalizing GitHub Codespaces for your accountYou can personalize GitHub Codespaces by using a dotfiles repository on GitHub or by using Settings Sync.Setting your default editor for GitHub CodespacesYou can set your default editor for Codespaces in your personal settings page.Setting your default region for GitHub CodespacesYou can set your default region in the GitHub Codespaces profile settings page to personalize where your data is held.Setting your timeout period for GitHub CodespacesYou can set your default timeout for GitHub Codespaces in your personal settings page.Configuring automatic deletion of your codespacesInactive codespaces are automatically deleted. You can choose how long your stopped codespaces are retained, up to a maximum of 30 days.Choosing the stable or beta host imageYou can choose to build codespaces using either the stable or beta version of the host image for the underlying virtual machine.\n\n\n\nCodespaces/Setting up your projectSetting up your project for GitHub CodespacesYou can configure GitHub Codespaces for the specific requirements of your project. Every time you create a codespace from your repository your working environment will have everything you need.Adding a dev container configuration to your repositoryIntroduction to dev containersSetting up a Node.js project for GitHub CodespacesSetting up a C# (.NET) project for GitHub CodespacesSetting up a Java project for GitHub CodespacesSetting up a PHP project for GitHub CodespacesSetting up a Python project for GitHub CodespacesConfiguring dev containersSetting a minimum specification for codespace machinesAdding features to a devcontainer.json fileAutomatically opening files in the codespaces for a repositorySpecifying recommended secrets for a repositorySetting up your repository for GitHub CodespacesFacilitating quick creation and resumption of codespacesSetting up a template repository for GitHub Codespaces\n\n\n\nCodespaces/Setting up your project/Adding a dev container configurationAdding a dev container configuration to your repositoryYou can add a custom dev container configuration to your repository to set up the GitHub Codespaces development environment for your codebase.Introduction to dev containersWhen you work in a codespace, the environment you are working in is created using a development container, or dev container, hosted on a virtual machine.Setting up a Node.js project for GitHub CodespacesGet started with a Node.js, JavaScript, or TypeScript project in GitHub Codespaces by creating a custom dev container configuration.Setting up a C# (.NET) project for GitHub CodespacesGet started with a C# (.NET) project in GitHub Codespaces by creating a custom dev container configuration.Setting up a Java project for GitHub CodespacesGet started with a Java project in GitHub Codespaces by creating a custom dev container configuration.Setting up a PHP project for GitHub CodespacesGet started with a PHP project in GitHub Codespaces by creating a custom dev container configuration.Setting up a Python project for GitHub CodespacesGet started with a Python project in GitHub Codespaces by creating a custom dev container configuration.\n\n\n\nCodespaces/Setting up your project/Configuring dev containersConfiguring dev containersYou can customize the dev container configuration for your repository.Setting a minimum specification for codespace machinesYou can avoid under-resourced machine types being used for GitHub Codespaces for your repository.Adding features to a devcontainer.json fileWith features, you can quickly add tools, runtimes, or libraries to your dev container configuration.Automatically opening files in the codespaces for a repositoryYou can set particular files to be opened automatically whenever someone creates a codespace for your repository and opens the codespace in the Visual Studio Code web client.Specifying recommended secrets for a repositoryYou can add a setting to your dev container configuration that will prompt people to set specific development environment secrets when they create a codespace.\n\n\n\nCodespaces/Setting up your project/Setting up your repositorySetting up your repository for GitHub CodespacesYou can set up your repository to make it easy for people to work on a project using GitHub Codespaces.Facilitating quick creation and resumption of codespacesYou can add a link to take people straight to a page for creating a codespace, with your choice of options preconfigured. Alternatively you can link to the "Resume codespace" page.Setting up a template repository for GitHub CodespacesYou can help people get started with a project by setting up a template repository for use with GitHub Codespaces.\n\n\n\nCodespaces/Prebuilding your codespacesPrebuilding your codespacesTo speed up codespace creation, you can configure your project to prebuild codespaces for specific branches in specific regions.Who can use this feature?You create and configure prebuilds in your repository's settings. Repository-level settings for GitHub Codespaces are available for all repositories owned by personal accounts. 
For repositories owned by organizations, repository-level settings for GitHub Codespaces are available for organizations on GitHub Team and GitHub Enterprise plans. To access the settings, the organization or its parent enterprise must have added a payment method and set a spending limit for GitHub Codespaces. For more information, see Choosing who owns and pays for codespaces in your organization and GitHub’s plans.About GitHub Codespaces prebuildsGitHub Codespaces prebuilds help to speed up the creation of new codespaces for large or complex repositories.Configuring prebuildsYou can configure your project to prebuild a codespace automatically each time you push a change to your repository.Allowing a prebuild to access other repositoriesYou can permit your prebuild to access other GitHub repositories so that it can be built successfully.Managing prebuildsYou can review, modify, and delete the prebuild configurations for your repository.Testing dev container configuration changes on a prebuild-enabled branchWhen you change the dev container configuration for a branch that's enabled for prebuilds, you should test your changes in a codespace.\n\n\n\nCodespaces/Managing your codespacesManaging your codespacesYou can use GitHub Codespaces settings to manage information that your codespace might need.Managing your account-specific secrets for GitHub CodespacesYou can store sensitive information, like tokens, that you want to access in your codespaces via environment variables.Managing access to other repositories within your codespaceYou can manage the repositories that GitHub Codespaces can access.Reviewing your security logs for GitHub CodespacesYou can use the security log to review all actions related to GitHub Codespaces.Managing GPG verification for GitHub CodespacesYou can allow GitHub to automatically use GPG to sign commits you make in your codespaces, so other people can be confident that the changes come from a trusted source.\n\n\n\nCodespaces/Managing your organizationManaging GitHub Codespaces for your organizationYou can manage and review how users in your organization can use GitHub Codespaces.Who can use this feature?Organizations on GitHub Team and GitHub Enterprise plans can pay for members' and collaborators' use of GitHub Codespaces. These organizations can then access settings and policies to manage codespaces paid for by the organization. For more information, see Choosing who owns and pays for codespaces in your organization and GitHub’s plans.Enabling or disabling GitHub Codespaces for your organizationYou can control which users can use GitHub Codespaces in your organization's private repositories.Choosing who owns and pays for codespaces in your organizationYou can choose whether codespaces are paid for and owned by your organization or by your members.Listing the codespaces in your organizationYou can list all of the currently active or stopped codespaces for your organization.Managing the cost of GitHub Codespaces in your organizationYou can check your GitHub Codespaces usage and set usage limits.Managing development environment secrets for your repository or organizationDevelopment environment secrets allow you to store sensitive information in your organization or repository for use with GitHub Codespaces.Reviewing your organization's audit logs for GitHub CodespacesYou can use the audit log to review all actions related to GitHub Codespaces.Restricting access to machine typesYou can set constraints on the types of machines users can choose when they create codespaces in your organization.Restricting the number of organization-billed codespaces a user can createYou can specify the maximum number of codespaces that any member of your organization, or collaborator, can create for the repositories in your organization.Restricting the base image for codespacesYou can specify which base images can be used to create the dev container for new codespaces created within your organization.Restricting the visibility of forwarded portsYou can set constraints on the visibility options users can choose when they forward ports from codespaces in your organization.Restricting the idle timeout periodYou can set a maximum timeout period for any codespaces owned by your organization.Restricting the retention period for codespacesYou can set a maximum retention period for any codespaces owned by your organization.\n\n\n\nCodespaces/ReferenceReferenceThis section contains references that will allow you to be successful with GitHub CodespacesAllowing your codespace to access a private registryYou can allow GitHub Codespaces to access container images or other packages in a private registry.Using GitHub Copilot in GitHub CodespacesYou can use GitHub Copilot in GitHub Codespaces by adding a VS Code extension.Using the Visual Studio Code Command Palette in GitHub CodespacesYou can use the Command Palette feature of Visual Studio Code to access many commands in GitHub Codespaces.Security in GitHub CodespacesOverview of the GitHub Codespaces security architecture, with guidelines to help you maintain security and minimize the risk of attack.Disaster recovery for GitHub CodespacesThis article describes guidance for a disaster recovery scenario, when a whole region experiences an outage due to major natural disaster or widespread service interruption.\n\n\n\nCodespaces/TroubleshootingTroubleshooting GitHub CodespacesThese guides provide information for troubleshooting GitHub CodespacesGitHub Codespaces logsOverview of the logs used by GitHub Codespaces.Troubleshooting GitHub Codespaces clientsThis article provides troubleshooting information for issues you may encounter with the client you use for GitHub Codespaces.Getting the most out of your included usageFind out about the free use of GitHub Codespaces that's included with personal accounts.Exporting changes to a branchThis article provides steps for exporting your codespace changes to a branch.Troubleshooting creation and deletion of codespacesThis article provides troubleshooting steps for common issues you may experience when creating or deleting a codespace, including storage and configuration issues.Troubleshooting authentication to a repositoryLearn how to troubleshoot common authentication issues when you clone, push to, or pull from a repository in a codespace.Troubleshooting your connection to GitHub CodespacesTroubleshooting help for connecting to GitHub Codespaces.Troubleshooting prebuildsYou can use prebuilds to speed up the creation of codespaces. This article provides troubleshooting steps for common issues with prebuilds.Troubleshooting personalization options for GitHub CodespacesTroubleshooting steps for common issues with dotfiles and Settings Sync.Troubleshooting port forwarding for GitHub CodespacesTroubleshooting steps for common port forwarding issues.Troubleshooting GPG verification for GitHub CodespacesThis article provides troubleshooting advice for errors related to signing your commits in codespaces.Working with support for GitHub CodespacesTips on getting the best help from support for GitHub Codespaces.\n\n\n\nSite policy/Privacy Policies/GitHub General Privacy StatementGitHub General Privacy StatementIn this articleGitHub Privacy StatementPersonal Data We CollectProcessing Purposes: How We Use Your Personal DataSharing of Personal DataPrivate repositories: GitHub AccessLawful Bases for Processing Personal Data (Applicable to EEA and UK End Users)Your Privacy RightsInternational data transfersData Privacy Framework (DPF)Security and RetentionSecurityContact UsInformation for MinorsChanges to Our Privacy StatementTranslationsOur use of cookies and tracking technologiesUS State Specific InformationGitHub Privacy Statement
Effective date: February 1, 2024
Welcome to the GitHub Privacy Statement. This is where we describe how we handle your “Personal Data”, which is information that is directly linked or can be linked to you. It applies to the Personal Data that GitHub, Inc. or GitHub B.V., processes as the “Data Controller” when you interact with websites, applications, and services that display this Statement (collectively, “Services”). This Statement does not apply to services or products that do not display this Statement, such as Previews, where relevant.
End User Notice: Organization-Provided GitHub Accounts
When a school or employer supplies your GitHub account, they assume the role of Data Controller for most Personal Data used in our Services. This enables them to:

Manage and administer your GitHub account, including adjusting privacy settings.
Access and utilize your Personal Data, which includes details on how you use the Services, as well as your content and files.

Should you access a GitHub Service through an account provided by an organization, such as your employer or school, the organization becomes the Data Controller, and this Privacy Statement's direct applicability to you changes. Even so, GitHub remains dedicated to preserving your privacy rights. In such circumstances, GitHub functions as a Data Processor, adhering to the Data Controller's instructions regarding your Personal Data's processing. A Data Protection Agreement governs the relationship between GitHub and the Data Controller. For further details regarding their privacy practices, please refer to the privacy statement of the organization providing your account.
In cases where your organization grants access to GitHub products, GitHub acts as the Data Controller solely for specific processing activities. These activities are clearly defined in a contractual agreement with your organization, known as a Data Protection Agreement. You can review our standard Data Protection Agreement at GitHub Data Protection Agreement. For those limited purposes, this Statement governs the handling of your Personal Data. For all other aspects of GitHub product usage, your organization's policies apply.
Third Party Access and Data Protection
When you use third-party extensions, integrations, or follow references and links within our Services, the privacy policies of these third parties apply to any Personal Data you provide or consent to share with them. Their privacy statements will govern how this data is processed.
Personal Data We Collect
Personal Data is collected from you directly, automatically from your device, and also from third parties. The Personal Data GitHub processes when you use the Services depends on variables like how you interact with our Services (such as through web interfaces, desktop or mobile applications), the features you use (such as pull requests, Codespaces, or GitHub Copilot) and your method of accessing the Services (your preferred IDE). Below, we detail the information we collect through each of these channels:
From You

Account Data: We collect certain information when you open an account such as your GitHub handle, name, email address, password, payment information and transaction information.
User Content and Files: When you use our Services, we collect Personal Data included as part of the information you provide such as code, inputs, text, documents, images, or feedback.
Demographic information: In some cases, you provide us with ethnicity, gender, or similar demographic details.
Feedback Data: This consists of information you submit through surveys, reviews, or interactive features.
Payment Information: For paid subscriptions, we collect details like name, billing address, and payment specifics.
Profile Information: We collect information to create a user profile, which may include a photo, additional email addresses, job title, or biography.
Sales and Marketing Data: This includes information provided for promotional communications, such as name, email address, and company name.
Support Data: When you seek customer support, we collect details like code, text, or multimedia files.

Automatically

Buttons, Tools, and Content from Other Companies: Our Services may contain links or buttons that lead to third-party services like Twitter or LinkedIn. Use of these features may result in data collection. Engaging with these buttons, tools, or content may automatically send certain browser information to these companies. Please review the privacy statements of these companies for more information.
Essential Cookies and Similar Tracking Technologies: We use cookies and similar technologies to provide essential functionality like storing settings and recognizing you while using our Services.
Non-essential Cookies: Depending on your jurisdiction, we may use online analytics products that use cookies to help us analyze how de-identified users use our Services and to enhance your experience when you use the Services. We may also employ third-party Cookies to gather data for interest-based advertising. In some jurisdictions, we only use non-essential cookies after obtaining your consent. See this section for more details and control options.
Email Marketing Interactions: Our emails may have web beacons that offer information on your device type, email client, email reception, opens, and link clicks.
Geolocation Information: Depending on the Service's functionality, we collect regional geolocation data.
Service Usage Information: We collect data about your interactions with the Services, such as IP address, device information, session details, date and time of requests, device type and ID, operating system and application version, information related to your contributions to repositories, and performance of specific features or Services.
Website Usage Data: We automatically log data about your Website interactions, including the referring site, date and time of visit, pages viewed, and links clicked.

From Third Parties

Information from Other Users of the Services: Other users may share information about you when they submit issues and comments. We may also receive information about you if you are identified as a representative or administrator on your company's account.
Publicly Available Sources: We may acquire information about you from publicly available sources like public GitHub repositories.
Services you linked to your GitHub account: When you or your administrator integrate third-party apps or services with our Services, we receive information based on your settings with those services. This can include details like your name and email from services like Google for authentication. The information we receive depends on the third-party's settings and privacy policies. Always review these to understand what data is shared with our Services.
Vendors, Partners, and Affiliates: We may receive information about you from third parties, like vendors, resellers, partners, or affiliates for the purposes outlined in this statement.

Processing Purposes: How We Use Your Personal Data
The Personal Data we process depends on your interaction and access methods with our Services, including the interfaces (web, desktop, mobile apps), features used (pull requests, Codespaces, GitHub Copilot), and your preferred access tools (like your IDE). This section details all the potential ways GitHub may process your Personal Data:

Business Operations: We use Personal Data for activities like billing, accounting, and compensation. This includes creating aggregated statistical data for internal reporting, financial reporting, revenue planning, capacity planning, and forecast modeling (including product strategy).
Communication: We use Personal Data to inform you about new Services, features, offers, promotions, and other pertinent information. This also includes sending confirmations, invoices, technical notices, updates, security alerts, and administrative messages.
Inference: We generate new information from other data we collect to derive likely preferences or other characteristics. For instance, we infer your general geographic location based on your IP address.
Personalization: We use Personal Data to customize the Service to your preferences, to evaluate the effectiveness of enterprise business ads and promotional communications, and to ensure a seamless and consistent user experience.
Safety and Security: To promote safety, integrity, and security across our Services, we process Personal Data, using both automated and, at times, manual techniques for abuse detection, prevention, and violations of terms of service.
Service Provision: We use Personal Data to deliver and update our Services as configured and used by You, and to make ongoing personalized experiences and recommendations.
Troubleshooting: We use Personal Data to identify and resolve technical issues.
Ongoing Service Performance: Personal Data helps us keep the Services up to date and performant, and meet user productivity, reliability, efficacy, quality, privacy, accessibility and security needs.
Complying with and resolving legal obligations: including responding to Data Subject Requests for Personal Data processed by GitHub as Controller (for example website data), tax requirements, agreements and disputes.
Delivering Professional Services: We use Personal Data to deliver training, consulting or implementation (“Professional Services”). This includes providing technical support, professional planning, advice, guidance, data migration, deployment, and solution/software development services.
Improving Professional Services: Enhancing delivery, efficacy, quality, and security of Professional Services and the underlying product(s) based on issues identified while providing Professional Services, including fixing software defects, and otherwise keeping the Professional Services up to date and performant.

When carrying out these activities, GitHub practices data minimization and uses the minimum amount of Personal Information required.
Sharing of Personal Data
We may share Personal Data with the following recipients:

Abuse and Fraud Prevention Entities: We may disclose Personal Data based on a good faith belief it is needed to prevent fraud, abuse, or attacks on our Services, or to protect the safety of GitHub and our users.
Affiliates: Personal Data may be shared with GitHub affiliates, including Microsoft, to facilitate customer service, marketing and advertising, order fulfillment, billing, technical support, and legal and compliance obligations. Our affiliates may only use the Personal Data in a manner consistent with this Privacy Statement.
GitHub Organization Accounts: If an organization adds you to their GitHub account, we might share Personal Data with that organization to fulfill the commercial relationship. In such a case, your use of the Services is protected by a data protection agreement and terms between your organization and GitHub
Competent Authorities: We may disclose Personal Data to authorized law enforcement, regulators, courts, or other public authorities in response to lawful requests or to protect our rights and safety. Please refer to our Guidelines for Legal Requests of User Data for more information.
Corporate Transaction Entities: we might disclose Personal Data within the limits of the law and in accordance with this Privacy Statement for strategic business transactions such as sales or a merger.
Partners and Resellers: We cooperate with third-parties that offer sales, consulting, support, and technical services for our Services. We may share your data with these partners and resellers where allowed, and with your consent when required.
Subprocessors and Service Providers: We may use vendors to provide services on our behalf, including hosting, marketing, advertising, social, analytics, support ticketing, credit card processing, or security services. They are bound by contractual obligations to ensure the security, privacy, and confidentiality of your information. Please visit https://docs.github.com/en/site-policy/privacy-policies/github-subprocessors to see our list of Subprocessors.
Visual Studio Code (GitHub Codespaces): GitHub Codespaces and github.dev offer Visual Studio Code in a web browser, where some telemetry is collected by default. Details on telemetry collection are on the VS Code website. To opt out, go to File > Preferences > Settings in the top left menu of VS Code. Opting out will sync this preference across all future web sessions in GitHub Codespaces and github.dev.
Other Third-party Applications: Upon your instruction, we may share Personal Data with third-party applications available on our Marketplace. You are responsible for the data you instruct us to share with these applications.
Other Users and the Public: Depending on your account settings, we may share Personal Data with other users of the Services and the public. You control what information is made public. To adjust your settings, visit User Settings in your profile. Please be aware that any information you share in a collaborative context may become publicly accessible.

Private repositories: GitHub Access
If your GitHub account has private repositories, you control the access to that information. GitHub personnel does not access private repository information without your consent except as provided in this Privacy Statement and for:

security purposes
automated scanning or manual review for known vulnerabilities, active malware, or other content known to violate our Terms of Service
to assist the repository owner with a support matter
to maintain the integrity of the Services, or
to comply with our legal obligations if we have reason to believe the contents are in violation of the law.

GitHub will provide you with notice regarding private repository access unless doing so is prohibited by law or if GitHub acted in response to a security threat or other risk to security.
Lawful Bases for Processing Personal Data (Applicable to EEA and UK End Users)
GitHub processes Personal Data in compliance with the GDPR, ensuring a lawful basis for each processing activity. The basis varies depending on the data type and the context, including how you access the services. Our processing activities typically fall under these lawful bases:

Contractual Necessity: Processing is required to fulfill our contractual duties to you, in accordance with the GitHub Terms of Service.
Legal Obligation: We process data when it's necessary to comply with applicable laws or to protect the rights, safety, and property of GitHub, our affiliates, users, or third parties.
Legitimate Interests: We process data for purposes that are in our legitimate interests, such as securing our Services, communicating with you, and improving our Services. This is done only when these interests are not overridden by your data protection rights or your fundamental rights and freedoms.
Consent: We process data when you have explicitly consented to such processing. When we rely on consent as the legal basis, you have the right to withdraw your consent for data processing at any time. The procedures for withdrawal are detailed in this Statement and available on our website.

Your Privacy Rights
Depending on your residence location, you may have specific legal rights regarding your Personal Data:

The right to access the data collected about you
The right to request detailed information about the specific types of Personal Data we've collected over the past 12 months, including data disclosed for business purposes
The right to rectify or update inaccurate or incomplete Personal Data under certain circumstances
The right to erase or limit the processing of your Personal Data under specific conditions
The right to object to the processing of your Personal Data, as allowed by applicable law
The right to withdraw consent, where processing is based on your consent
The right to receive your collected Personal Data in a structured, commonly used, and machine-readable format to facilitate its transfer to another company, where technically feasible

To exercise these rights, please send an email to privacy[at]github[dot]com and follow the instructions provided. To verify your identity for security, we may request extra information before addressing your data-related request. Please contact our Data Protection Officer at dpo[at]github[dot]com for any feedback or concerns. Depending on your region, you have the right to complain to your local Data Protection Authority. European users can find authority contacts on the European Data Protection Board website, and UK users on the Information Commissioner’s Office website.
We aim to promptly respond to requests in compliance with legal requirements. Please note that we may retain certain data as necessary for legal obligations or for establishing, exercising, or defending legal claims.
International data transfers
GitHub stores and processes Personal Data in a variety of locations, including your local region, the United States, and other countries where GitHub, its affiliates, subsidiaries, or subprocessors have operations. We transfer Personal Data from the European Union, the United Kingdom, and Switzerland to countries that the European Commission has not recognized as having an adequate level of data protection. When we engage in such transfers, we generally rely on the standard contractual clauses published by the European Commission under Commission Implementing Decision 2021/914, to help protect your rights and enable these protections to travel with your data. To learn more about the European Commission’s decisions on the adequacy of the protection of personal data in the countries where GitHub processes personal data, see this article on the European Commission website.
Data Privacy Framework (DPF)
GitHub also complies with the EU-U.S. Data Privacy Framework (EU-U.S. DPF), the UK Extension to the EU-U.S. DPF, and the Swiss-U.S. Data Privacy Framework (Swiss-U.S. DPF) as set forth by the U.S. Department of Commerce. GitHub has certified to the U.S. Department of Commerce that it adheres to the EU-U.S. Data Privacy Framework Principles (EU-U.S. DPF Principles) with regard to the processing of personal data received from the European Union in reliance on the EU-U.S. DPF and from the United Kingdom (and Gibraltar) in reliance on the UK Extension to the EU-U.S. DPF. GitHub has certified to the U.S. Department of Commerce that it adheres to the Swiss-U.S. Data Privacy Framework Principles (Swiss-U.S. DPF Principles) with regard to the processing of personal data received from Switzerland in reliance on the Swiss-U.S. DPF. If there is any conflict between the terms in this privacy statement and the EU-U.S. DPF Principles and/or the Swiss-U.S. DPF Principles, the Principles shall govern. To learn more about the Data Privacy Framework (DPF) program, and to view our certification, please visit https://www.dataprivacyframework.gov/.
GitHub has the responsibility for the processing of Personal Data it receives under the Data Privacy Framework (DPF) Principles and subsequently transfers to a third party acting as an agent on GitHub’s behalf. GitHub shall remain liable under the DPF Principles if its agent processes such Personal Data in a manner inconsistent with the DPF Principles, unless the organization proves that it is not responsible for the event giving rise to the damage.
Dispute resolution process
In compliance with the EU-U.S. DPF, the UK Extension to the EU-U.S. DPF, and the Swiss-U.S. DPF, GitHub commits to resolve DPF Principles-related complaints about our collection and use of your personal information. EU, UK, and Swiss individuals with inquiries or complaints regarding our handling of personal data received in reliance on the EU-U.S. DPF, the UK Extension, and the Swiss-U.S. DPF should first contact GitHub at: dpo[at]github[dot]com.
If you do not receive timely acknowledgment of your DPF Principles-related complaint from us, or if we have not addressed your DPF Principles-related complaint to your satisfaction, please visit https://go.adr.org/dpf_irm.html for more information or to file a complaint. The services of the International Centre for Dispute Resolution are provided at no cost to you.
An individual has the possibility, under certain conditions, to invoke binding arbitration for complaints regarding DPF compliance not resolved by any of the other DPF mechanisms. For additional information visit https://www.dataprivacyframework.gov/s/article/ANNEX-I-introduction-dpf?tabset-35584=2.
Government Enforcement
GitHub is subject to the investigatory and enforcement powers of the Federal Trade Commission (FTC). Under Section 5 of the Federal Trade Commission Act (15 U.S.C. § 45), an organization's failure to abide by commitments to implement the DPF Principles may be challenged as deceptive by the FTC. The FTC has the power to prohibit such misrepresentations through administrative orders or by seeking court orders.
Security and Retention
GitHub uses appropriate administrative, technical, and physical security controls to protect your Personal Data. We’ll retain your Personal Data as long as your account is active and as needed to fulfill contractual obligations, comply with legal requirements, resolve disputes, and enforce agreements. The retention duration depends on the purpose of data collection and any legal obligations.
Security
GitHub uses administrative, technical, and physical security controls where appropriate to protect your Personal Data.
Contact Us
Contact us via our contact form or by emailing our Data Protection Officer at dpo[at]github[dot]com.
Our addresses are:
GitHub B.V.
Prins Bernhardplein 200, Amsterdam
1097JB
The Netherlands
GitHub, Inc.
88 Colin P. Kelly Jr. St.
San Francisco, CA 94107
United States
Information for Minors
Our Services are not intended for individuals under the age of 13. We do not intentionally gather Personal Data from such individuals. If you become aware that a minor has provided us with Personal Data, please notify us.
Changes to Our Privacy Statement
GitHub may periodically revise this Privacy Statement. If there are material changes to the statement, we will provide at least 30 days prior notice by updating our website or sending an email to your primary email address associated with your GitHub account.
Translations
Below are translations of this document into other languages. In the event of any conflict, uncertainty, or apparent inconsistency between any of those versions and the English version, this English version is the controlling version.
French
Cliquez ici pour obtenir la version française: Déclaration de confidentialité de GitHub (PDF).
Other translations
For translations of this statement into other languages, please visit https://docs.github.com/ and select a language from the drop-down menu under “English.”
Our use of cookies and tracking technologies
Cookies and tracking technologies
GitHub uses cookies to provide, secure and improve our Service or to develop new features and functionality of our Service. For example, we use them to (i) keep you logged in, (ii) remember your preferences, (iii) identify your device for security and fraud purposes, including as needed to maintain the integrity of our Service, (iv) compile statistical reports, and (v) provide information and insight for future development of GitHub. We provide more information about cookies on GitHub that describes the cookies we set, the needs we have for those cookies, and the expiration of such cookies.
For Enterprise Marketing Pages, we may also use non-essential cookies to (i) gather information about enterprise users’ interests and online activities to personalize their experiences, including by making the ads, content, recommendations, and marketing seen or received more relevant and (ii) serve and measure the effectiveness of targeted advertising and other marketing efforts. If you disable the non-essential cookies on the Enterprise Marketing Pages, the ads, content, and marketing you see may be less relevant.
Our emails to users may contain a pixel tag, which is a small, clear image that can tell us whether or not you have opened an email and what your IP address is. We use this pixel tag to make our email communications more effective and to make sure we are not sending you unwanted email.
The length of time a cookie will stay on your browser or device depends on whether it is a “persistent” or “session” cookie. Session cookies will only stay on your device until you stop browsing. Persistent cookies stay until they expire or are deleted. The expiration time or retention period applicable to persistent cookies depends on the purpose of the cookie collection and tool used. You may be able to delete cookie data. For more information, see GitHub General Privacy Statement.
What are cookies and similar technologies?
We use cookies and similar technologies, such as web beacons, local storage, and mobile analytics, to operate and provide our Services. When visiting Enterprise Marketing Pages, like resources.github.com, these and additional cookies, like advertising IDs, may be used for sales and marketing purposes.
Cookies are small text files stored by your browser on your device. A cookie can later be read when your browser connects to a web server in the same domain that placed the cookie. The text in a cookie contains a string of numbers and letters that may uniquely identify your device and can contain other information as well. This allows the web server to recognize your browser over time, each time it connects to that web server.
Web beacons are electronic images (also called “single-pixel” or “clear GIFs”) that are contained within a website or email. When your browser opens a webpage or email that contains a web beacon, it automatically connects to the web server that hosts the image (typically operated by a third party). This allows that web server to log information about your device and to set and read its own cookies. In the same way, third-party content on our websites (such as embedded videos, plug-ins, or ads) results in your browser connecting to the third-party web server that hosts that content.
Mobile identifiers for analytics can be accessed and used by apps on mobile devices in much the same way that websites access and use cookies. When visiting Enterprise Marketing pages, like resources.github.com, on a mobile device these may allow us and our third-party analytics and advertising partners to collect data for sales and marketing purposes.
We may also use so-called “flash cookies” (also known as “Local Shared Objects” or “LSOs”) to collect and store information about your use of our Services. Flash cookies are commonly used for advertisements and videos.
How do we and our partners use cookies and similar technologies?
The GitHub Services use cookies and similar technologies for a variety of purposes, including to store your preferences and settings, enable you to sign-in, analyze how our Services perform, track your interaction with the Services, develop inferences, combat fraud, and fulfill other legitimate purposes. Some of these cookies and technologies may be provided by third parties, including service providers and advertising partners. For example, our analytics and advertising partners may use these technologies in our Services to collect personal information (such as the pages you visit, the links you click on, and similar usage information, identifiers, and device information) related to your online activities over time and across Services for various purposes, including targeted advertising. GitHub will place non-essential cookies on pages where we market products and services to enterprise customers, for example, on resources.github.com.
We and/or our partners also share the information we collect or infer with third parties for these purposes.
The table below provides additional information about how we use different types of cookies:

























PurposeDescriptionRequired CookiesGitHub uses required cookies to perform essential website functions and to provide the services. For example, cookies are used to log you in, save your language preferences, provide a shopping cart experience, improve performance, route traffic between web servers, detect the size of your screen, determine page load times, improve user experience, and for audience measurement. These cookies are necessary for our websites to work.AnalyticsWe allow third parties to use analytics cookies to understand how you use our websites so we can make them better. For example, cookies are used to gather information about the pages you visit and how many clicks you need to accomplish a task. We also use some analytics cookies to provide personalized advertising.Social MediaGitHub and third parties use social media cookies to show you ads and content based on your social media profiles and activity on GitHub’s websites. This ensures that the ads and content you see on our websites and on social media will better reflect your interests. This also enables third parties to develop and improve their products, which they may use on websites that are not owned or operated by GitHub.AdvertisingIn addition, GitHub and third parties use advertising cookies to show you new ads based on ads you've already seen. Cookies also track which ads you click or purchases you make after clicking an ad. This is done both for payment purposes and to show you ads that are more relevant to you. For example, cookies are used to detect when you click an ad and to show you ads based on your social media interests and website browsing history.
What are your cookie choices and controls?
You have several options to disable non-essential cookies:


Specifically on GitHub Enterprise Marketing Pages
Any GitHub page that serves non-essential cookies will have a link in the page’s footer to cookie settings. You can express your preferences at any time by clicking on that linking and updating your settings.
Some users will also be able to manage non-essential cookies via a cookie consent banner, including the options to accept, manage, and reject all non-essential cookies.


Generally for all websites
You can control the cookies you encounter on the web using a variety of widely-available tools. For example:



If your browser sends a Do Not Track (DNT) signal, GitHub will not set non-essential cookies and will not load third party resources which set non-essential cookies.
Many browsers provide cookie controls which may limit the types of cookies you encounter online. Check out the documentation for your browser to learn more.
If you enable a browser extension designed to block tracking, such as Privacy Badger, non-essential cookies set by a website or third parties may be disabled.
If you enable a browser extension designed to block unwanted content, such as uBlock Origin, non-essential cookies will be disabled to the extent that content that sets non-essential cookies will be blocked.
You may use the Global Privacy Control (GPC) to communicate your privacy preferences. If GitHub detects the GPC signal from your device, GitHub will not share your data (we do not sell your data). To learn more, visit Global Privacy Control — Take Control Of Your Privacy
Advertising controls. Our advertising partners may participate in associations that provide simple ways to opt out of ad targeting, which you can access at:
United States: NAI and DAA
Canada: Digital Advertising Alliance of Canada
Europe: European Digital Advertising Alliance

These choices are specific to the browser you are using. If you access our Services from other devices or browsers, take these actions from those systems to ensure your choices apply to the data collected when you use those systems.
US State Specific Information
This section provides extra information specifically for residents of certain US states that have distinct data privacy laws and regulations. These laws may grant specific rights to residents of these states when the laws come into effect. This section uses the term “personal information” as an equivalent to the term “Personal Data.”
Privacy Rights
These rights are common to the US State privacy laws:

Right to Knowledge and Correction: You have the right to request details on the specific personal information we’ve collected about you and the right to correct inaccurate information. You can exercise this right by contacting us. You can also access and edit basic account information in your settings.
Right to Know Data Recipients: We share your information with service providers for legitimate business operations, such as data storage and hosting. For more details, please see “Sharing Your Information” below.
Right to request Deletion: You reserve the right to request the deletion of your data, barring a few exceptions. Such exceptions include circumstances where we are required to retain data to comply with legal obligations, detect fraudulent activity, investigate reports of abuse or other violations of our Terms of Service, or rectify security issues. Upon receiving your verified request, we will promptly delete your personal information (unless an exception applies), and instruct our service providers to do the same. We employ brief retention terms by design.
Right to a Timely Response: You are allowed to make two free requests in any 12-month period. We commit to responding to your request within 45 days. In complex cases, we may extend our response time by an additional 45 days.
Non-Discrimination: We will not hold it against you when you exercise any of your rights. On the contrary, we encourage you to review your privacy settings closely and contact us with any questions.

Notice of Collection of Personal Information
We may collect various categories of personal information about our website visitors and users of "Services" which includes GitHub applications, software, products, or services. That information includes identifiers/contact information, demographic information, payment information, commercial information, internet or electronic network activity information, geolocation data, audio, electronic, visual, or similar information, and inferences drawn from such information.
We collect this information for various purposes. This includes identifying accessibility gaps and offering targeted support, fostering diversity and representation, providing services, troubleshooting, conducting business operations such as billing and security, improving products and supporting research, communicating important information, ensuring personalized experiences, and promoting safety and security.
Exercising your Privacy Rights
To make an access, deletion, correction, or opt-out request, please send an email to privacy[at]github[dot]com and follow the instructions provided. We may need to verify your identity before processing your request. If you choose to use an authorized agent to submit a request on your behalf, please ensure they have your signed permission or power of attorney as required.
To opt out of the sharing of your personal information, you can click on the "Do Not Share My Personal Information" link on the footer of our Websites or use the Global Privacy Control ("GPC") if available. Authorized agents can also submit opt-out requests on your behalf.
California
Mandatory Disclosures
We also make the following disclosures for purposes of compliance with California privacy law:

We collected the following categories of personal information in the last 12 months: identifiers/contact information, demographic information (such as gender), payment card information associated with you, commercial information, Internet or other electronic network activity information, geolocation data, audio, electronic, visual or similar information, and inferences drawn from the above.
The sources of personal information from whom we collected are: directly from you, automatically or from third parties.
The business or commercial purposes of collecting personal information are as summarized above and in our Privacy Statement under Processing Purposes.
We disclosed the following categories of personal information for a business purpose in the last 12 months: identifiers/contact information, demographic information (such as gender and rough geographic location), payment information, commercial information, Internet or other electronic network activity information, geolocation data, audio, electronic, visual or similar information, and inferences drawn from the above. We disclosed each category to third-party business partners and service providers, third-party sites or platforms such as social networking sites, and other third parties as described in the Sharing of Personal Data section of our Privacy Statement.
As defined by applicable law, we “shared” the following categories of personal information in the last 12 months: identifiers/contact information, Internet or other electronic network activity information, and inferences drawn from the above. We shared each category to or with advertising networks, data analytics providers, and social networks.
The business or commercial purpose of sharing personal information is to assist us with marketing, advertising, and audience measurement.
We do not “sell” or “share” the personal information of known minors under 16 years of age.

Shine the Light Act
Under California Civil Code section 1798.83, also known as the “Shine the Light” law, California residents who have provided personal information to a business with which the individual has established a business relationship for personal, family, or household purposes (“California Customers”) may request information about whether the business has disclosed personal information to any third parties for the third parties’ direct marketing purposes. Please be aware that we do not disclose personal information to any third parties for their direct marketing purposes as defined by this law. California Customers may request further information about our compliance with this law by emailing (privacy[at]github[dot]com). Please note that businesses are required to respond to one request per California Customer each year and may not be required to respond to requests made by means other than through the designated email address.
Removal of Content
California residents under the age of 18 who are registered users of online sites, services, or applications have a right under California Business and Professions Code Section 22581 to remove, or request and obtain removal of, content or information they have publicly posted. To remove content or information you have publicly posted, please submit a Private Information Removal request. Alternatively, to request that we remove such content or information, please send a detailed description of the specific content or information you wish to have removed to GitHub support. Please be aware that your request does not guarantee complete or comprehensive removal of content or information posted online and that the law may not permit or require removal in certain circumstances. If you have any questions about our privacy practices with respect to California residents, please send an email to privacy[at]github[dot]com.
We value the trust you place in us and are committed to handling your personal information with care and respect. If you have any questions or concerns about our privacy practices, please email our Data Protection Officer at dpo[at]github[dot]com.
Colorado/Connecticut/Virginia
If you live in Colorado, Connecticut, or Virginia you have some additional rights:

If we deny your rights request, you have the right to appeal that decision. We will provide you with the necessary information to submit an appeal at that time.
You have the right to opt out of profiling in furtherance of decisions that produce legal or similarly significant effects concerning the consumer. GitHub does not engage in such profiling as defined by Colorado law, so there’s no need to opt out.

Nevada
We do not sell your covered information, as defined under Chapter 603A of the Nevada Revised Statutes. If you still have questions about your covered information or anything else in our Privacy Statement, please send an email to privacy[at]github[dot]com.\n\n\n\nContributing to GitHub Docs documentation Learn about how the GitHub Docs team creates documentation and how you can contribute.Start hereBest practices for GitHub DocsFollow these best practices to create documentation that's user-friendly and easy to understand.Style guideFollow this guide to make sure GitHub's documentation stays consistent and follows clear patterns that our readers can understand.About the content modelThe content model describes the structure and types of content that we publish.About contributing to GitHub DocsYou can contribute to GitHub Docs content in several ways.What's newView all Contributing to GitHub DocsOctober 02Docs are being translated to French, German, Korean, and RussianDecember 05Webhook docs generated from the OpenAPI schemaNovember 16All Contribute to GitHub Docs docsWriting for GitHub DocsBest practices for GitHub DocsAbout GitHub's documentation philosophyAbout GitHub's documentation fundamentalsContent design principlesWriting content to be translatedMaking content findable in searchVersioning documentationUsing Markdown and Liquid in GitHub DocsUsing YAML frontmatterUsing videos in GitHub DocsCreating reusable contentCreating screenshotsCreating diagrams for GitHub DocsCreating tool switchers in articlesConfiguring redirectsChanging an article's titleAnnotating code examplesTemplatesStyle guide and content modelStyle guideAbout the content modelContents of a GitHub Docs articleAbout topicsConceptual content typeReferential content typeProcedural content typeTroubleshooting content typeRelease note content typeQuickstart content typeTutorial content typeAbout combining multiple content typesCollaborating on GitHub DocsAbout contributing to GitHub DocsUsing Git on GitHub DocsUsing the TODOCS placeholder to leave notesUsing the content linterLabel referenceSetting up your environment to work on GitHub DocsWorking on GitHub Docs in a codespaceCreating a local environmentTroubleshooting your environment\n\n\n\nSite policy/GitHub Terms/GitHub Terms of ServiceGitHub Terms of ServiceIn this articleSummaryThe GitHub Terms of ServiceA. DefinitionsB. Account TermsC. Acceptable UseD. User-Generated ContentE. Private RepositoriesF. Copyright Infringement and DMCA PolicyG. Intellectual Property NoticeH. API TermsI. GitHub Additional Product TermsJ. Beta PreviewsK. PaymentL. Cancellation and TerminationM. Communications with GitHubN. Disclaimer of WarrantiesO. Limitation of LiabilityP. Release and IndemnificationQ. Changes to These TermsR. MiscellaneousThank you for using GitHub! We're happy you're here. Please read this Terms of Service agreement carefully before accessing or using GitHub. Because it is such an important contract between us and our users, we have tried to make it as clear as possible. For your convenience, we have presented these terms in a short non-binding summary followed by the full legal terms.
Summary

















































































SectionWhat can you find there?A. DefinitionsSome basic terms, defined in a way that will help you understand this agreement. Refer back up to this section for clarification.B. Account TermsThese are the basic requirements of having an Account on GitHub.C. Acceptable UseThese are the basic rules you must follow when using your GitHub Account.D. User-Generated ContentYou own the content you post on GitHub. However, you have some responsibilities regarding it, and we ask you to grant us some rights so we can provide services to you.E. Private RepositoriesThis section talks about how GitHub will treat content you post in private repositories.F. Copyright & DMCA PolicyThis section talks about how GitHub will respond if you believe someone is infringing your copyrights on GitHub.G. Intellectual Property NoticeThis describes GitHub's rights in the website and service.H. API TermsThese are the rules for using GitHub's APIs, whether you are using the API for development or data collection.I. Additional Product TermsWe have a few specific rules for GitHub's features and products.J. Beta PreviewsThese are some of the additional terms that apply to GitHub's features that are still in development.K. PaymentYou are responsible for payment. We are responsible for billing you accurately.L. Cancellation and TerminationYou may cancel this agreement and close your Account at any time.M. Communications with GitHubWe only use email and other electronic means to stay in touch with our users. We do not provide phone support.N. Disclaimer of WarrantiesWe provide our service as is, and we make no promises or guarantees about this service. Please read this section carefully; you should understand what to expect.O. Limitation of LiabilityWe will not be liable for damages or losses arising from your use or inability to use the service or otherwise arising under this agreement. Please read this section carefully; it limits our obligations to you.P. Release and IndemnificationYou are fully responsible for your use of the service.Q. Changes to these Terms of ServiceWe may modify this agreement, but we will give you 30 days' notice of material changes.R. MiscellaneousPlease see this section for legal details including our choice of law.
The GitHub Terms of Service
Effective date: November 16, 2020
A. Definitions
Short version: We use these basic terms throughout the agreement, and they have specific meanings. You should know what we mean when we use each of the terms. There's not going to be a test on it, but it's still useful information.

An "Account" represents your legal relationship with GitHub. A “Personal Account” represents an individual User’s authorization to log in to and use the Service and serves as a User’s identity on GitHub. “Organizations” are shared workspaces that may be associated with a single entity or with one or more Users where multiple Users can collaborate across many projects at once. A Personal Account can be a member of any number of Organizations.
The “Agreement” refers, collectively, to all the terms, conditions, notices contained or referenced in this document (the “Terms of Service” or the "Terms") and all other operating rules, policies (including the GitHub Privacy Statement, available at github.com/site/privacy) and procedures that we may publish from time to time on the Website. Most of our site policies are available at docs.github.com/categories/site-policy.
"Beta Previews" mean software, services, or features identified as alpha, beta, preview, early access, or evaluation, or words or phrases with similar meanings.
“Content” refers to content featured or displayed through the Website, including without limitation code, text, data, articles, images, photographs, graphics, software, applications, packages, designs, features, and other materials that are available on the Website or otherwise available through the Service. "Content" also includes Services. “User-Generated Content” is Content, written or otherwise, created or uploaded by our Users. "Your Content" is Content that you create or own.
“GitHub,” “We,” and “Us” refer to GitHub, Inc., as well as our affiliates, directors, subsidiaries, contractors, licensors, officers, agents, and employees.
The “Service” refers to the applications, software, products, and services provided by GitHub, including any Beta Previews.
“The User,” “You,” and “Your” refer to the individual person, company, or organization that has visited or is using the Website or Service; that accesses or uses any part of the Account; or that directs the use of the Account in the performance of its functions. A User must be at least 13 years of age. Special terms may apply for business or government Accounts (See Section B(5): Additional Terms).
The “Website” refers to GitHub’s website located at github.com, and all content, services, and products provided by GitHub at or through the Website. It also refers to GitHub-owned subdomains of github.com, such as education.github.com and pages.github.com. These Terms also govern GitHub’s conference websites, such as githubuniverse.com, and product websites, such as electronjs.org. Occasionally, websites owned by GitHub may provide different or additional terms of service. If those additional terms conflict with this Agreement, the more specific terms apply to the relevant page or service.

B. Account Terms
Short version: Personal Accounts and Organizations have different administrative controls; a human must create your Account; you must be 13 or over; you must provide a valid email address; and you may not have more than one free Account. You alone are responsible for your Account and anything that happens while you are signed in to or using your Account. You are responsible for keeping your Account secure.
1. Account Controls


Users. Subject to these Terms, you retain ultimate administrative control over your Personal Account and the Content within it.


Organizations. The "owner" of an Organization that was created under these Terms has ultimate administrative control over that Organization and the Content within it. Within the Service, an owner can manage User access to the Organization’s data and projects. An Organization may have multiple owners, but there must be at least one Personal Account designated as an owner of an Organization. If you are the owner of an Organization under these Terms, we consider you responsible for the actions that are performed on or through that Organization.


2. Required Information
You must provide a valid email address in order to complete the signup process. Any other information requested, such as your real name, is optional, unless you are accepting these terms on behalf of a legal entity (in which case we need more information about the legal entity) or if you opt for a paid Account, in which case additional information will be necessary for billing purposes.
3. Account Requirements
We have a few simple rules for Personal Accounts on GitHub's Service.

You must be a human to create an Account. Accounts registered by "bots" or other automated methods are not permitted. We do permit machine accounts:
A machine account is an Account set up by an individual human who accepts the Terms on behalf of the Account, provides a valid email address, and is responsible for its actions. A machine account is used exclusively for performing automated tasks. Multiple users may direct the actions of a machine account, but the owner of the Account is ultimately responsible for the machine's actions. You may maintain no more than one free machine account in addition to your free Personal Account.
One person or legal entity may maintain no more than one free Account (if you choose to control a machine account as well, that's fine, but it can only be used for running a machine).
You must be age 13 or older. While we are thrilled to see brilliant young coders get excited by learning to program, we must comply with United States law. GitHub does not target our Service to children under 13, and we do not permit any Users under 13 on our Service. If we learn of any User under the age of 13, we will terminate that User’s Account immediately. If you are a resident of a country outside the United States, your country’s minimum age may be older; in such a case, you are responsible for complying with your country’s laws.
Your login may only be used by one person — i.e., a single login may not be shared by multiple people. A paid Organization may only provide access to as many Personal Accounts as your subscription allows.
You may not use GitHub in violation of export control or sanctions laws of the United States or any other applicable jurisdiction. You may not use GitHub if you are or are working on behalf of a Specially Designated National (SDN) or a person subject to similar blocking or denied party prohibitions administered by a U.S. government agency. GitHub may allow persons in certain sanctioned countries or territories to access certain GitHub services pursuant to U.S. government authorizations. For more information, please see our Export Controls policy.

4. Account Security
You are responsible for keeping your Account secure while you use our Service. We offer tools such as two-factor authentication to help you maintain your Account's security, but the content of your Account and its security are up to you.

You are responsible for all content posted and activity that occurs under your Account (even when content is posted by others who have Accounts under your Account).
You are responsible for maintaining the security of your Account and password. GitHub cannot and will not be liable for any loss or damage from your failure to comply with this security obligation.
You will promptly notify GitHub by contacting us through the GitHub Support portal if you become aware of any unauthorized use of, or access to, our Service through your Account, including any unauthorized use of your password or Account.

5. Additional Terms
In some situations, third parties' terms may apply to your use of GitHub. For example, you may be a member of an organization on GitHub with its own terms or license agreements; you may download an application that integrates with GitHub; or you may use GitHub to authenticate to another service. Please be aware that while these Terms are our full agreement with you, other parties' terms govern their relationships with you.
If you are a government User or otherwise accessing or using any GitHub Service in a government capacity, this Government Amendment to GitHub Terms of Service applies to you, and you agree to its provisions.
If you have signed up for GitHub Enterprise Cloud, the Enterprise Cloud Addendum applies to you, and you agree to its provisions.
C. Acceptable Use
Short version: GitHub hosts a wide variety of collaborative projects from all over the world, and that collaboration only works when our users are able to work together in good faith. While using the service, you must follow the terms of this section, which include some restrictions on content you can post, conduct on the service, and other limitations. In short, be excellent to each other.
Your use of the Website and Service must not violate any applicable laws, including copyright or trademark laws, export control or sanctions laws, or other laws in your jurisdiction. You are responsible for making sure that your use of the Service is in compliance with laws and any applicable regulations.
You agree that you will not under any circumstances violate our Acceptable Use Policies or Community Guidelines.
D. User-Generated Content
Short version: You own content you create, but you allow us certain rights to it, so that we can display and share the content you post. You still have control over your content, and responsibility for it, and the rights you grant us are limited to those we need to provide the service. We have the right to remove content or close Accounts if we need to.
1. Responsibility for User-Generated Content
You may create or upload User-Generated Content while using the Service. You are solely responsible for the content of, and for any harm resulting from, any User-Generated Content that you post, upload, link to or otherwise make available via the Service, regardless of the form of that Content. We are not responsible for any public display or misuse of your User-Generated Content.
2. GitHub May Remove Content
We have the right to refuse or remove any User-Generated Content that, in our sole discretion, violates any laws or GitHub terms or policies. User-Generated Content displayed on GitHub Mobile may be subject to mobile app stores' additional terms.
3. Ownership of Content, Right to Post, and License Grants
You retain ownership of and responsibility for Your Content. If you're posting anything you did not create yourself or do not own the rights to, you agree that you are responsible for any Content you post; that you will only submit Content that you have the right to post; and that you will fully comply with any third party licenses relating to Content you post.
Because you retain ownership of and responsibility for Your Content, we need you to grant us — and other GitHub Users — certain legal permissions, listed in Sections D.4 — D.7. These license grants apply to Your Content. If you upload Content that already comes with a license granting GitHub the permissions we need to run our Service, no additional license is required. You understand that you will not receive any payment for any of the rights granted in Sections D.4 — D.7. The licenses you grant to us will end when you remove Your Content from our servers, unless other Users have forked it.
4. License Grant to Us
We need the legal right to do things like host Your Content, publish it, and share it. You grant us and our legal successors the right to store, archive, parse, and display Your Content, and make incidental copies, as necessary to provide the Service, including improving the Service over time. This license includes the right to do things like copy it to our database and make backups; show it to you and other users; parse it into a search index or otherwise analyze it on our servers; share it with other users; and perform it, in case Your Content is something like music or video.
This license does not grant GitHub the right to sell Your Content. It also does not grant GitHub the right to otherwise distribute or use Your Content outside of our provision of the Service, except that as part of the right to archive Your Content, GitHub may permit our partners to store and archive Your Content in public repositories in connection with the GitHub Arctic Code Vault and GitHub Archive Program.
5. License Grant to Other Users
Any User-Generated Content you post publicly, including issues, comments, and contributions to other Users' repositories, may be viewed by others. By setting your repositories to be viewed publicly, you agree to allow others to view and "fork" your repositories (this means that others may make their own copies of Content from your repositories in repositories they control).
If you set your pages and repositories to be viewed publicly, you grant each User of GitHub a nonexclusive, worldwide license to use, display, and perform Your Content through the GitHub Service and to reproduce Your Content solely on GitHub as permitted through GitHub's functionality (for example, through forking). You may grant further rights if you adopt a license. If you are uploading Content you did not create or own, you are responsible for ensuring that the Content you upload is licensed under terms that grant these permissions to other GitHub Users.
6. Contributions Under Repository License
Whenever you add Content to a repository containing notice of a license, you license that Content under the same terms, and you agree that you have the right to license that Content under those terms. If you have a separate agreement to license that Content under different terms, such as a contributor license agreement, that agreement will supersede.
Isn't this just how it works already? Yep. This is widely accepted as the norm in the open-source community; it's commonly referred to by the shorthand "inbound=outbound". We're just making it explicit.
7. Moral Rights
You retain all moral rights to Your Content that you upload, publish, or submit to any part of the Service, including the rights of integrity and attribution. However, you waive these rights and agree not to assert them against us, to enable us to reasonably exercise the rights granted in Section D.4, but not otherwise.
To the extent this agreement is not enforceable by applicable law, you grant GitHub the rights we need to use Your Content without attribution and to make reasonable adaptations of Your Content as necessary to render the Website and provide the Service.
E. Private Repositories
Short version: We treat the content of private repositories as confidential, and we only access it as described in our Privacy Statement—for security purposes, to assist the repository owner with a support matter, to maintain the integrity of the Service, to comply with our legal obligations, if we have reason to believe the contents are in violation of the law, or with your consent.
1. Control of Private Repositories
Some Accounts may have private repositories, which allow the User to control access to Content.
2. Confidentiality of Private Repositories
GitHub considers the contents of private repositories to be confidential to you. GitHub will protect the contents of private repositories from unauthorized use, access, or disclosure in the same manner that we would use to protect our own confidential information of a similar nature and in no event with less than a reasonable degree of care.
3. Access
GitHub personnel may only access the content of your private repositories in the situations described in our Privacy Statement.
You may choose to enable additional access to your private repositories. For example:

You may enable various GitHub services or features that require additional rights to Your Content in private repositories. These rights may vary depending on the service or feature, but GitHub will continue to treat your private repository Content as confidential. If those services or features require rights in addition to those we need to provide the GitHub Service, we will provide an explanation of those rights.

Additionally, we may be compelled by law to disclose the contents of your private repositories.
GitHub will provide notice regarding our access to private repository content, unless for legal disclosure, to comply with our legal obligations, or where otherwise bound by requirements under law, for automated scanning, or if in response to a security threat or other risk to security.
F. Copyright Infringement and DMCA Policy
If you believe that content on our website violates your copyright, please contact us in accordance with our Digital Millennium Copyright Act Policy. If you are a copyright owner and you believe that content on GitHub violates your rights, please contact us via our convenient DMCA form or by emailing copyright@github.com. There may be legal consequences for sending a false or frivolous takedown notice. Before sending a takedown request, you must consider legal uses such as fair use and licensed uses.
We will terminate the Accounts of repeat infringers of this policy.
G. Intellectual Property Notice
Short version: We own the service and all of our content. In order for you to use our content, we give you certain rights to it, but you may only use our content in the way we have allowed.
1. GitHub's Rights to Content
GitHub and our licensors, vendors, agents, and/or our content providers retain ownership of all intellectual property rights of any kind related to the Website and Service. We reserve all rights that are not expressly granted to you under this Agreement or by law. The look and feel of the Website and Service is copyright © GitHub, Inc. All rights reserved. You may not duplicate, copy, or reuse any portion of the HTML/CSS, JavaScript, or visual design elements or concepts without express written permission from GitHub.
2. GitHub Trademarks and Logos
If you’d like to use GitHub’s trademarks, you must follow all of our trademark guidelines, including those on our logos page: https://github.com/logos.
3. License to GitHub Policies
This Agreement is licensed under this Creative Commons Zero license. For details, see our site-policy repository.
H. API Terms
Short version: You agree to these Terms of Service, plus this Section H, when using any of GitHub's APIs (Application Provider Interface), including use of the API through a third party product that accesses GitHub.
Abuse or excessively frequent requests to GitHub via the API may result in the temporary or permanent suspension of your Account's access to the API. GitHub, in our sole discretion, will determine abuse or excessive usage of the API. We will make a reasonable attempt to warn you via email prior to suspension.
You may not share API tokens to exceed GitHub's rate limitations.
You may not use the API to download data or Content from GitHub for spamming purposes, including for the purposes of selling GitHub users' personal information, such as to recruiters, headhunters, and job boards.
All use of the GitHub API is subject to these Terms of Service and the GitHub Privacy Statement.
GitHub may offer subscription-based access to our API for those Users who require high-throughput access or access that would result in resale of GitHub's Service.
I. GitHub Additional Product Terms
Short version: You need to follow certain specific terms and conditions for GitHub's various features and products, and you agree to the Supplemental Terms and Conditions when you agree to this Agreement.
Some Service features may be subject to additional terms specific to that feature or product as set forth in the GitHub Additional Product Terms. By accessing or using the Services, you also agree to the GitHub Additional Product Terms.
J. Beta Previews
Short version: Beta Previews may not be supported or may change at any time. You may receive confidential information through those programs that must remain confidential while the program is private. We'd love your feedback to make our Beta Previews better.
1. Subject to Change
Beta Previews may not be supported and may be changed at any time without notice. In addition, Beta Previews are not subject to the same security measures and auditing to which the Service has been and is subject. By using a Beta Preview, you use it at your own risk.
2. Confidentiality
As a user of Beta Previews, you may get access to special information that isn’t available to the rest of the world. Due to the sensitive nature of this information, it’s important for us to make sure that you keep that information secret.
Confidentiality Obligations. You agree that any non-public Beta Preview information we give you, such as information about a private Beta Preview, will be considered GitHub’s confidential information (collectively, “Confidential Information”), regardless of whether it is marked or identified as such. You agree to only use such Confidential Information for the express purpose of testing and evaluating the Beta Preview (the “Purpose”), and not for any other purpose. You should use the same degree of care as you would with your own confidential information, but no less than reasonable precautions to prevent any unauthorized use, disclosure, publication, or dissemination of our Confidential Information. You promise not to disclose, publish, or disseminate any Confidential Information to any third party, unless we don’t otherwise prohibit or restrict such disclosure (for example, you might be part of a GitHub-organized group discussion about a private Beta Preview feature).
Exceptions. Confidential Information will not include information that is: (a) or becomes publicly available without breach of this Agreement through no act or inaction on your part (such as when a private Beta Preview becomes a public Beta Preview); (b) known to you before we disclose it to you; (c) independently developed by you without breach of any confidentiality obligation to us or any third party; or (d) disclosed with permission from GitHub. You will not violate the terms of this Agreement if you are required to disclose Confidential Information pursuant to operation of law, provided GitHub has been given reasonable advance written notice to object, unless prohibited by law.
3. Feedback
We’re always trying to improve of products and services, and your feedback as a Beta Preview user will help us do that. If you choose to give us any ideas, know-how, algorithms, code contributions, suggestions, enhancement requests, recommendations or any other feedback for our products or services (collectively, “Feedback”), you acknowledge and agree that GitHub will have a royalty-free, fully paid-up, worldwide, transferable, sub-licensable, irrevocable and perpetual license to implement, use, modify, commercially exploit and/or incorporate the Feedback into our products, services, and documentation.
K. Payment
Short version: You are responsible for any fees associated with your use of GitHub. We are responsible for communicating those fees to you clearly and accurately, and letting you know well in advance if those prices change.
1. Pricing
Our pricing and payment terms are available at github.com/pricing. If you agree to a subscription price, that will remain your price for the duration of the payment term; however, prices are subject to change at the end of a payment term.
2. Upgrades, Downgrades, and Changes

We will immediately bill you when you upgrade from the free plan to any paying plan.
If you change from a monthly billing plan to a yearly billing plan, GitHub will bill you for a full year at the next monthly billing date.
If you upgrade to a higher level of service, we will bill you for the upgraded plan immediately.
You may change your level of service at any time by choosing a plan option or going into your Billing settings. If you choose to downgrade your Account, you may lose access to Content, features, or capacity of your Account. Please see our section on Cancellation for information on getting a copy of that Content.

3. Billing Schedule; No Refunds
Payment Based on Plan For monthly or yearly payment plans, the Service is billed in advance on a monthly or yearly basis respectively and is non-refundable. There will be no refunds or credits for partial months of service, downgrade refunds, or refunds for months unused with an open Account; however, the service will remain active for the length of the paid billing period. In order to treat everyone equally, no exceptions will be made.
Payment Based on Usage Some Service features are billed based on your usage. A limited quantity of these Service features may be included in your plan for a limited term without additional charge. If you choose to use paid Service features beyond the quantity included in your plan, you pay for those Service features based on your actual usage in the preceding month. Monthly payment for these purchases will be charged on a periodic basis in arrears. See GitHub Additional Product Terms for Details.
Invoicing For invoiced Users, User agrees to pay the fees in full, up front without deduction or setoff of any kind, in U.S. Dollars. User must pay the fees within thirty (30) days of the GitHub invoice date. Amounts payable under this Agreement are non-refundable, except as otherwise provided in this Agreement. If User fails to pay any fees on time, GitHub reserves the right, in addition to taking any other action at law or equity, to (i) charge interest on past due amounts at 1.0% per month or the highest interest rate allowed by law, whichever is less, and to charge all expenses of recovery, and (ii) terminate the applicable order form. User is solely responsible for all taxes, fees, duties and governmental assessments (except for taxes based on GitHub's net income) that are imposed or become due in connection with this Agreement.
4. Authorization
By agreeing to these Terms, you are giving us permission to charge your on-file credit card, PayPal account, or other approved methods of payment for fees that you authorize for GitHub.
5. Responsibility for Payment
You are responsible for all fees, including taxes, associated with your use of the Service. By using the Service, you agree to pay GitHub any charge incurred in connection with your use of the Service. If you dispute the matter, contact us through the GitHub Support portal. You are responsible for providing us with a valid means of payment for paid Accounts. Free Accounts are not required to provide payment information.
L. Cancellation and Termination
Short version: You may close your Account at any time. If you do, we'll treat your information responsibly.
1. Account Cancellation
It is your responsibility to properly cancel your Account with GitHub. You can cancel your Account at any time by going into your Settings in the global navigation bar at the top of the screen. The Account screen provides a simple, no questions asked cancellation link. We are not able to cancel Accounts in response to an email or phone request.
2. Upon Cancellation
We will retain and use your information as necessary to comply with our legal obligations, resolve disputes, and enforce our agreements, but barring legal requirements, we will delete your full profile and the Content of your repositories within 90 days of cancellation or termination (though some information may remain in encrypted backups). This information cannot be recovered once your Account is canceled.
We will not delete Content that you have contributed to other Users' repositories or that other Users have forked.
Upon request, we will make a reasonable effort to provide an Account owner with a copy of your lawful, non-infringing Account contents after Account cancellation, termination, or downgrade. You must make this request within 90 days of cancellation, termination, or downgrade.
3. GitHub May Terminate
GitHub has the right to suspend or terminate your access to all or any part of the Website at any time, with or without cause, with or without notice, effective immediately. GitHub reserves the right to refuse service to anyone for any reason at any time.
4. Survival
All provisions of this Agreement which, by their nature, should survive termination will survive termination — including, without limitation: ownership provisions, warranty disclaimers, indemnity, and limitations of liability.
M. Communications with GitHub
Short version: We use email and other electronic means to stay in touch with our users.
1. Electronic Communication Required
For contractual purposes, you (1) consent to receive communications from us in an electronic form via the email address you have submitted or via the Service; and (2) agree that all Terms of Service, agreements, notices, disclosures, and other communications that we provide to you electronically satisfy any legal requirement that those communications would satisfy if they were on paper. This section does not affect your non-waivable rights.
2. Legal Notice to GitHub Must Be in Writing
Communications made through email or GitHub Support's messaging system will not constitute legal notice to GitHub or any of its officers, employees, agents or representatives in any situation where notice to GitHub is required by contract or any law or regulation. Legal notice to GitHub must be in writing and served on GitHub's legal agent.
3. No Phone Support
GitHub only offers support via email, in-Service communications, and electronic messages. We do not offer telephone support.
N. Disclaimer of Warranties
Short version: We provide our service as is, and we make no promises or guarantees about this service. Please read this section carefully; you should understand what to expect.
GitHub provides the Website and the Service “as is” and “as available,” without warranty of any kind. Without limiting this, we expressly disclaim all warranties, whether express, implied or statutory, regarding the Website and the Service including without limitation any warranty of merchantability, fitness for a particular purpose, title, security, accuracy and non-infringement.
GitHub does not warrant that the Service will meet your requirements; that the Service will be uninterrupted, timely, secure, or error-free; that the information provided through the Service is accurate, reliable or correct; that any defects or errors will be corrected; that the Service will be available at any particular time or location; or that the Service is free of viruses or other harmful components. You assume full responsibility and risk of loss resulting from your downloading and/or use of files, information, content or other material obtained from the Service.
O. Limitation of Liability
Short version: We will not be liable for damages or losses arising from your use or inability to use the service or otherwise arising under this agreement. Please read this section carefully; it limits our obligations to you.
You understand and agree that we will not be liable to you or any third party for any loss of profits, use, goodwill, or data, or for any incidental, indirect, special, consequential or exemplary damages, however arising, that result from

the use, disclosure, or display of your User-Generated Content;
your use or inability to use the Service;
any modification, price change, suspension or discontinuance of the Service;
the Service generally or the software or systems that make the Service available;
unauthorized access to or alterations of your transmissions or data;
statements or conduct of any third party on the Service;
any other user interactions that you input or receive through your use of the Service; or
any other matter relating to the Service.

Our liability is limited whether or not we have been informed of the possibility of such damages, and even if a remedy set forth in this Agreement is found to have failed of its essential purpose. We will have no liability for any failure or delay due to matters beyond our reasonable control.
P. Release and Indemnification
Short version: You are responsible for your use of the service. If you harm someone else or get into a dispute with someone else, we will not be involved.
If you have a dispute with one or more Users, you agree to release GitHub from any and all claims, demands and damages (actual and consequential) of every kind and nature, known and unknown, arising out of or in any way connected with such disputes.
You agree to indemnify us, defend us, and hold us harmless from and against any and all claims, liabilities, and expenses, including attorneys’ fees, arising out of your use of the Website and the Service, including but not limited to your violation of this Agreement, provided that GitHub (1) promptly gives you written notice of the claim, demand, suit or proceeding; (2) gives you sole control of the defense and settlement of the claim, demand, suit or proceeding (provided that you may not settle any claim, demand, suit or proceeding unless the settlement unconditionally releases GitHub of all liability); and (3) provides to you all reasonable assistance, at your expense.
Q. Changes to These Terms
Short version: We want our users to be informed of important changes to our terms, but some changes aren't that important — we don't want to bother you every time we fix a typo. So while we may modify this agreement at any time, we will notify users of any material changes and give you time to adjust to them.
We reserve the right, at our sole discretion, to amend these Terms of Service at any time and will update these Terms of Service in the event of any such amendments. We will notify our Users of material changes to this Agreement, such as price increases, at least 30 days prior to the change taking effect by posting a notice on our Website or sending email to the primary email address specified in your GitHub account. Customer's continued use of the Service after those 30 days constitutes agreement to those revisions of this Agreement. For any other modifications, your continued use of the Website constitutes agreement to our revisions of these Terms of Service. You can view all changes to these Terms in our Site Policy repository.
We reserve the right at any time and from time to time to modify or discontinue, temporarily or permanently, the Website (or any part of it) with or without notice.
R. Miscellaneous
1. Governing Law
Except to the extent applicable law provides otherwise, this Agreement between you and GitHub and any access to or use of the Website or the Service are governed by the federal laws of the United States of America and the laws of the State of California, without regard to conflict of law provisions. You and GitHub agree to submit to the exclusive jurisdiction and venue of the courts located in the City and County of San Francisco, California.
2. Non-Assignability
GitHub may assign or delegate these Terms of Service and/or the GitHub Privacy Statement, in whole or in part, to any person or entity at any time with or without your consent, including the license grant in Section D.4. You may not assign or delegate any rights or obligations under the Terms of Service or Privacy Statement without our prior written consent, and any unauthorized assignment and delegation by you is void.
3. Section Headings and Summaries
Throughout this Agreement, each section includes titles and brief summaries of the following terms and conditions. These section titles and brief summaries are not legally binding.
4. Severability, No Waiver, and Survival
If any part of this Agreement is held invalid or unenforceable, that portion of the Agreement will be construed to reflect the parties’ original intent. The remaining portions will remain in full force and effect. Any failure on the part of GitHub to enforce any provision of this Agreement will not be considered a waiver of our right to enforce such provision. Our rights under this Agreement will survive any termination of this Agreement.
5. Amendments; Complete Agreement
This Agreement may only be modified by a written amendment signed by an authorized representative of GitHub, or by the posting by GitHub of a revised version in accordance with Section Q. Changes to These Terms. These Terms of Service, together with the GitHub Privacy Statement, represent the complete and exclusive statement of the agreement between you and us. This Agreement supersedes any proposal or prior agreement oral or written, and any other communications between you and GitHub relating to the subject matter of these terms including any confidentiality or nondisclosure agreements.
6. Questions
Questions about the Terms of Service? Contact us through the GitHub Support portal.\n\n\n\nGitHub DocsHelp for wherever you are on your GitHub journey.Get startedGet startedMigrationsAccount and profileAuthenticationBilling and paymentsSite policyCollaborative codingCodespacesRepositoriesPull requestsGitHub DiscussionsGitHub CopilotGitHub CopilotGet code suggestionsPrompt engineeringChat in GitHubCopilot Chat CookbookExtensions quickstartCI/CD and DevOpsGitHub ActionsGitHub PackagesGitHub PagesSecuritySecure codingSecret scanningSupply chain securityDependabotCode scanningSecurity advisoriesClient appsGitHub CLIGitHub MobileGitHub DesktopProject managementGitHub IssuesProjectsSearch on GitHubEnterprise and TeamsOrganizationsSecure your organizationEnterprise onboardingEnterprise administratorsGitHub Well-ArchitectedDevelopersAppsREST APIGraphQL APIWebhooksBuild Copilot ExtensionsGitHub ModelsCommunityBuilding communitiesGitHub SponsorsGitHub EducationGitHub for NonprofitsGitHub SupportContribute to GitHub DocsMore docsCodeQL query writingElectronnpmGetting startedSet up GitAt the heart of GitHub is an open-source version control system (VCS) called Git. Git is responsible for everything GitHub-related that happens locally on your computer.Connecting to GitHub with SSHYou can connect to GitHub using the Secure Shell Protocol (SSH), which provides a secure channel over an unsecured network.Creating and managing repositoriesYou can create a repository on GitHub to store and collaborate on your project's files, then manage the repository's name and location.Basic writing and formatting syntaxCreate sophisticated formatting for your prose and code on GitHub with simple syntax.PopularAbout pull requestsLearn about pull requests and draft pull requests on GitHub. Pull requests communicate changes to a branch in a repository. Once a pull request is opened, you can review changes with collaborators and add follow-up commits.Authentication documentationKeep your account and data secure with features like two-factor authentication, SSH, and commit signature verification.Getting code suggestions in your IDE with GitHub CopilotUse GitHub Copilot to get code suggestions in your editor.Managing remote repositoriesLearn to work with your local repositories on your computer and remote repositories hosted on GitHub.\n\n\n\nGet started with GitHub documentation Learn how to start building, shipping, and maintaining software with GitHub. Explore our products, sign up for an account, and connect with the world's largest development community.Quickstart Start hereAbout GitHub and GitYou can use GitHub and Git to collaborate on work.GitHub’s plansAn overview of GitHub's pricing plans.Getting started with your GitHub accountWith a personal account on GitHub, you can import or create repositories, collaborate with others, and connect with the GitHub community.Getting started with GitHub TeamWith GitHub Team groups of people can collaborate across many projects at the same time in an organization account.PopularCreating an account on GitHubCreate a personal account to get started with GitHub.Hello WorldFollow this Hello World exercise to learn GitHub's pull request workflow.Set up GitAt the heart of GitHub is an open-source version control system (VCS) called Git. Git is responsible for everything GitHub-related that happens locally on your computer.About versions of GitHub DocsYou can read documentation that reflects the GitHub product you're currently using.GuidesTypes of GitHub accountsAccounts on GitHub allow you to organize and control access to code.@GitHubFinding ways to contribute to open source on GitHubYou can find ways to contribute to open source projects on GitHub that are relevant to you.@GitHubTroubleshooting connectivity problemsIf you're having trouble connecting to GitHub, you can troubleshoot your connection, then use the GitHub Debug tool to diagnose problems.@GitHubAll Get started docsStart your journeyAbout GitHub and GitCreating an account on GitHubHello WorldSetting up your profileFinding inspiration on GitHubDownloading files from GitHubUploading a project to GitHubGit and GitHub learning resourcesOnboardingGetting started with your GitHub accountGetting started with GitHub TeamGetting started with the GitHub Enterprise Cloud trialGetting started with GitHub Enterprise CloudUsing GitHubGitHub flowConnecting to GitHubCommunicating on GitHubExploring early access releases with feature previewSupported browsersGitHub MobileAllowing access to GitHub's services from a restricted networkTroubleshooting connectivity problemsLearning about GitHubGitHub’s plansGitHub language supportTypes of GitHub accountsAccess permissions on GitHubAbout GitHub Advanced SecurityFAQ about changes to GitHub’s plansGitHub glossaryLearning to codeGetting started with GitFinding and understanding example codeReusing other people's code in your projectsLearning to debug with GitHub CopilotStoring your secrets safelyAccessibilityManaging your theme settingsKeyboard shortcutsGitHub Command PaletteWriting on GitHubGetting started with writing and formatting on GitHub • 3 articlesWorking with advanced formatting • 10 articlesWorking with saved replies • 5 articlesEditing and sharing content with gists • 4 articlesExploring projects on GitHubFinding ways to contribute to open source on GitHubUsing GitHub Copilot to explore projectsContributing to a projectSaving repositories with starsFollowing peopleFollowing organizationsGit basicsSet up GitSetting your username in GitCaching your GitHub credentials in GitWhy is Git always asking for my password?Updating credentials from the macOS KeychainGit workflowsAbout remote repositoriesManaging remote repositoriesAssociating text editors with GitConfiguring Git to handle line endingsIgnoring filesGit cheatsheetUsing GitAbout GitPushing commits to a remote repositoryGetting changes from a remote repositoryDealing with non-fast-forward errorsSplitting a subfolder out into a new repositoryAbout Git subtree mergesAbout Git rebaseUsing Git rebase on the command lineResolving merge conflicts after a Git rebaseDealing with special characters in branch and tag namesTroubleshooting the 2 GB push limitExploring integrationsAbout using integrationsAbout building integrationsFeatured GitHub integrationsGitHub Developer ProgramArchiving your GitHub personal account and public repositoriesRequesting an archive of your personal account’s dataOpting into or out of the GitHub Archive Program for your public repositoryUsing GitHub DocsAbout versions of GitHub DocsUsing hover cards on GitHub DocsShowcase your expertise with GitHub CertificationsAbout GitHub CertificationsRegistering for a GitHub Certifications exam\n\n\n\nMigrations documentation If you're moving to GitHub from another code hosting platform or moving between GitHub products, learn how to use our migration tooling to bring your work with you.Overview Plan your migration Start hereAbout GitHub ImporterIf your source code is stored on another Git-based hosting service, you can move the code to GitHub.com using GitHub Importer.About GitHub Enterprise ImporterWith GitHub Enterprise Importer, you can migrate your enterprise to GitHub Enterprise Cloud from various sources.Automating migration with GitHub Actions ImporterUse GitHub Actions Importer to plan and automate your migration to GitHub Actions.PopularImporting a repository with GitHub ImporterIf you have a project hosted on another Git-based hosting service, you can quickly import it to GitHub using the GitHub Importer tool.Adding locally hosted code to GitHubIf your code is stored locally on your computer and is tracked by Git or not tracked by any version control system (VCS), you can import the code to GitHub using GitHub CLI or Git commands.Migrating repositories from GitHub Enterprise Server to GitHub Enterprise CloudYou can migrate repositories from GitHub Enterprise Server to GitHub Enterprise Cloud, using the GitHub CLI or API.GuidesReclaiming mannequins for GitHub Enterprise ImporterAfter your migration, you can assign the history of a placeholder identity, or mannequin, to a member of your organization.@GitHubTroubleshooting your migration with GitHub Enterprise ImporterIf your migration fails or produces unexpected results, you can try common troubleshooting steps.@GitHubAll Migrations docsOverviewAbout GitHub's migration toolingPlanning your migration to GitHubMigration paths to GitHubAbout locked repositoriesProgrammatically importing repositoriesImporting source codeUsing GitHub Importer • 2 articlesUsing the command line to import source code • 6 articlesUsing GitHub Enterprise ImporterUnderstanding GitHub Enterprise Importer • 1 articlesMigrating from Azure DevOps to GitHub Enterprise Cloud • 4 articlesMigrating from Bitbucket Server to GitHub Enterprise Cloud • 4 articlesMigrating between GitHub products • 6 articlesCompleting your migration with GitHub Enterprise Importer • 3 articlesUsing ghe-migratorAbout ghe-migratorExporting migration data from GitHub Enterprise ServerExporting migration data from GitHub.comMigrating data to GitHub Enterprise Server\n\n\n\nAccount and profile documentation Make GitHub work best for you by adjusting the settings for your personal account, personalizing your profile page, and managing the notifications you receive.Quickstart Start hereChanging your GitHub usernameYou can change the username for your account on GitHub.Managing your profile READMEYou can add a README to your GitHub profile to tell other people about yourself.About notificationsNotifications provide updates about the activity on GitHub that you've subscribed to. You can use the notifications inbox to customize, triage, and manage your updates.PopularSetting your commit email addressYou can set the email address that is used to author commits on GitHub and on your computer.Inviting collaborators to a personal repositoryYou can invite users to become collaborators to your personal repository.Configuring notificationsChoose the type of activity on GitHub that you want to receive notifications for and how you want these updates delivered.What's newView all Sunset notice for automatic watching of repositories and teamsApril 15Deprecation of real-time GitHub Actions workflow job events in Slack and Microsoft Teams appsFebruary 03Notification emails for GitHub Issues now include more detailFebruary 03GuidesWhy are my contributions not showing up on my profile?Learn common reasons that contributions may be missing from your contributions graph.@GitHubManaging notifications from your inboxUse your inbox to quickly triage and sync your notifications across email and mobile.@GitHubBlocking command line pushes that expose your personal email addressIf you've chosen to keep your email address private when performing web-based operations, you can also choose to block command line pushes that may expose your personal email address.@GitHubAll Account and profile docsSetting up and managing your personal account on GitHubManaging user account settings • 9 articlesManaging your personal account • 6 articlesManaging email preferences • 9 articlesManaging access to your personal repositories • 4 articlesManaging your membership in organizations • 7 articlesSetting up and managing your GitHub profileCustomizing your profile • 7 articlesManaging contribution settings on your profile • 6 articlesManaging subscriptions and notifications on GitHubSetting up notifications • 2 articlesViewing and triaging notifications • 3 articlesManaging subscriptions for activity on GitHub • 2 articles\n\n\n\nAuthentication documentation Keep your account and data secure with features like two-factor authentication, SSH, and commit signature verification.Overview Start hereGenerating a new SSH key and adding it to the ssh-agentAfter you've checked for existing SSH keys, you can generate a new SSH key to use for authentication, then add it to the ssh-agent.Managing your personal access tokensYou can use a personal access token in place of a password when authenticating to GitHub in the command line or with the API.Configuring two-factor authenticationYou can choose among multiple options to add a second source of authentication to your account.PopularTroubleshooting SSHWhen using SSH to connect and authenticate to GitHub, you may need to troubleshoot unexpected issues that may arise.Checking for existing SSH keysBefore you generate an SSH key, you can check to see if you have any existing SSH keys.Adding a new SSH key to your GitHub accountTo configure your account on GitHub.com to use your new (or existing) SSH key, you'll also need to add the key to your account.Authenticating with SAML single sign-onYou can authenticate to GitHub with SAML single sign-on (SSO).What's newView all Copilot extension for GitHub Models now requires updated permissionsApril 14Multi-domain support and filterable changes are now in public preview on GitHub DesktopApril 01As of March 29, fine-grained PATs and GitHub Apps need updates to access GitHub Models playgroundMarch 18GuidesRecovering your account if you lose your 2FA credentialsIf you lose access to your two-factor authentication credentials, you can use your recovery codes, or another recovery option, to regain access to your account.@GitHubError: Permission denied (publickey)A "Permission denied" error means that the server rejected your connection. There could be several reasons why, and the most common examples are explained below.@GitHubCreating a strong passwordSecure your account on GitHub with a strong and unique password using a password manager.@GitHubAll Authentication docsKeeping your account and data secureAbout authentication to GitHubCreating a strong passwordSwitching between accountsVerifying new devices when signing inUpdating your GitHub access credentialsManaging your personal access tokensReviewing your SSH keysReviewing your deploy keysToken expiration and revocationReviewing your security logSecurity log eventsRemoving sensitive data from a repositoryAbout anonymized URLsAbout GitHub's IP addressesGitHub's SSH key fingerprintsSudo modePreventing unauthorized accessViewing and managing your sessionsSecuring your account with two-factor authentication (2FA)About two-factor authenticationConfiguring two-factor authenticationConfiguring two-factor authentication recovery methodsAccessing GitHub using two-factor authenticationRecovering your account if you lose your 2FA credentialsChanging your two-factor authentication methodAbout mandatory two-factor authenticationCountries where SMS authentication is supportedDisabling two-factor authentication for your personal accountAuthenticating with a passkeyAbout passkeysManaging your passkeysSigning in with a passkeyConnecting to GitHub with SSHAbout SSHUsing SSH agent forwardingManaging deploy keysChecking for existing SSH keysGenerating a new SSH key and adding it to the ssh-agentAdding a new SSH key to your GitHub accountTesting your SSH connectionWorking with SSH key passphrasesTroubleshooting SSHUsing SSH over the HTTPS portRecovering your SSH key passphraseDeleted or missing SSH keysError: Host key verification failedError: Permission denied (publickey)Error: Bad file numberError: Key already in useError: Permission to user/repo denied to other-userError: Permission to user/repo denied to user/other-repoError: Agent admitted failure to signError: ssh-add: illegal option -- apple-use-keychainError: SSL certificate problem, verify that the CA cert is OKError: Unknown key typeError: We're doing an SSH key auditManaging commit signature verificationAbout commit signature verificationDisplaying verification statuses for all of your commitsChecking for existing GPG keysGenerating a new GPG keyAdding a GPG key to your GitHub accountTelling Git about your signing keyAssociating an email with your GPG keySigning commitsSigning tagsTroubleshooting commit signature verificationChecking your commit and tag signature verification statusUsing a verified email address in your GPG key\n\n\n\nBilling and payments documentation Learn about the different components of your bill, and how you can view and manage those components.Overview Start hereAdding or editing a payment methodYou can add a payment method to your account or update your account's existing payment method at any time.Setting your billing emailYour account's billing email is where GitHub sends receipts and other billing-related communication.About per-user pricingLearn about per-user pricing for organizations.PopularDowngrading your account's planYou can downgrade the plan for any type of account on GitHub at any time.About billing for GitHub ActionsIf you want to use GitHub Actions beyond the storage or minutes included in your account, you will be billed for additional usage.About billing for GitHub CodespacesLearn about the costs for using GitHub Codespaces, and the monthly usage quotas included with GitHub personal accounts.GuidesHow does upgrading or downgrading affect the billing process?When you upgrade the subscription for your personal account or organization, changes are applied immediately. When you downgrade your subscription, changes are applied at the end of your current billing cycle.@GitHubUpgrading Git Large File StorageYou can purchase additional data packs to increase your monthly bandwidth quota and total storage capacity for Git LFS.@GitHubAll Billing and payments docsUsing the billing platformAbout billing on GitHubViewing your subscriptions and billing dateAdding or editing a payment methodViewing your payment history and receiptsAdding information to your receiptsAdding a sales tax certificateSetting your billing emailChanging the duration of your billing cycleRedeeming a couponTroubleshooting a declined credit card chargeUnlocking a locked accountUsing the new billing platformAbout the new billing platformGetting started with the new billing platformAbout the billing cycleManaging licenses and plans for your accountRoles for the new billing platformEstimating spendingGathering insights on your spendingPreventing overspendingManaging your payment and billing informationAbout billing for Git Large File StorageManaging the plan for your GitHub accountAbout billing for plansAbout per-user pricingUpgrading your account's planViewing and managing pending changes to your planDowngrading your account's planConnecting an Azure subscriptionHow does upgrading or downgrading affect the billing process?One-time payments for customers in IndiaDiscounted plans for GitHub accountsManaging billing for your productsManaging billing for GitHub Actions • 3 articlesManaging billing for GitHub Codespaces • 3 articlesManaging billing for GitHub Packages • 3 articlesManaging billing for GitHub Copilot • 1 articlesManaging billing for GitHub Advanced Security products • 4 articlesManaging billing for GitHub Sponsors • 4 articlesManaging billing for GitHub Marketplace apps • 4 articlesManaging billing for Git Large File Storage • 4 articlesSetting up paid accounts for procurement companiesSetting up paid organizations for procurement companies • 4 articlesSetting up enterprise accounts for procurement companies • 4 articles\n\n\n\nSite policySite policy documentationGitHub TermsAcceptable Use PoliciesPrivacy PoliciesOther Site PoliciesContent Removal PoliciesSecurity PoliciesGitHub Company Policies\n\n\n\nRepositories documentation Learn to use and manage the repositories that allow you to store and collaborate on your project's code.Quickstart Overview Start hereCloning a repositoryWhen you create a repository on GitHub, it exists as a remote repository. You can clone your repository to create a local copy on your computer and sync between the two locations.Restoring a deleted repositoryYou can restore some deleted repositories to recover their contents.Adding a file to a repositoryYou can upload and commit an existing file to a repository on GitHub or by using the command line.Licensing a repositoryPublic repositories on GitHub are often used to share open source software. For your repository to truly be open source, you'll need to license it so that others are free to use, change, and distribute the software.PopularAbout protected branchesYou can protect important branches by setting branch protection rules, which define whether collaborators can delete or force push to the branch and set requirements for any pushes to the branch, such as passing status checks or a linear commit history.About releasesYou can create a release to package software, along with release notes and links to binary files, for other people to use.About READMEsYou can add a README file to your repository to tell other people why your project is useful, what they can do with your project, and how they can use it.About code ownersYou can use a CODEOWNERS file to define individuals or teams that are responsible for code in a repository.What's newView all Repository updates July 31st 2024July 31Repository updates June 12th 2024June 12Repository Updates April 30th, 2024April 30GuidesDeleting a repositoryYou can delete any repository or fork if you're either an organization owner or have admin permissions for the repository or fork. Deleting a forked repository does not delete the upstream repository.@GitHubManaging a branch protection ruleYou can create a branch protection rule to enforce certain workflows for one or more branches, such as requiring an approving review or passing status checks for all pull requests merged into the protected branch.@GitHubSetting repository visibilityYou can choose who can view your repository.@GitHubAll Repositories docsCreating and managing repositoriesAbout repositoriesBest practices for repositoriesQuickstart for repositoriesRepository limitsCreating a new repositoryCreating a repository from a templateCreating a template repositoryCreating an issues-only repositoryDuplicating a repositoryCloning a repositoryTroubleshooting cloning errorsRenaming a repositoryTransferring a repositoryDeleting a repositoryRestoring a deleted repositoryManaging your repository’s settings and featuresCustomizing your repository • 8 articlesEnabling features for your repository • 5 articlesManaging repository settings • 9 articlesConfiguring branches and merges in your repositoryManaging branches in your repository • 4 articlesConfiguring pull request merges • 8 articlesManaging protected branches • 2 articlesManaging rulesets for a repository • 5 articlesWorking with filesManaging files • 7 articlesUsing files • 5 articlesManaging large files • 9 articlesReleasing projects on GitHubAbout releasesManaging releases in a repositoryViewing your repository's releases and tagsSearching a repository's releasesLinking to releasesComparing releasesAutomatically generated release notesAutomation for release forms with query parametersViewing activity and data for your repositoryViewing deployment activity for your repositoryAbout repository graphsUsing Pulse to view a summary of repository activityViewing traffic to a repositoryViewing a project's contributorsAnalyzing changes to a repository's contentUnderstanding connections between repositoriesUsing the activity view to see changes to a repositoryArchiving a GitHub repositoryArchiving repositoriesAbout archiving content and data on GitHubReferencing and citing contentBacking up a repository\n\n\n\nPull requests documentation Learn how to use pull requests to suggest changes to a project, receive suggested changes to your own projects, and address issues in pull requests, such as merge conflicts.Overview Start hereChanging a commit messageIf a commit message contains unclear, incorrect, or sensitive information, you can amend it locally and push a new commit with a new message to GitHub. You can also change a commit message to add missing information.Resolving a merge conflict using the command lineYou can resolve merge conflicts using the command line and a text editor.Creating and deleting branches within your repositoryYou can create or delete branches directly on GitHub.Creating a pull requestCreate a pull request to propose and collaborate on changes to a repository. These changes are proposed in a branch, which ensures that the default branch only contains finished and approved work.PopularAbout pull request reviewsReviews allow collaborators to comment on the changes proposed in pull requests, approve the changes, or request further changes before the pull request is merged. Repository administrators can require that all pull requests are approved before being merged.Resolving a merge conflict on GitHubYou can resolve simple merge conflicts that involve competing line changes on GitHub, using the conflict editor.Syncing a forkSync a fork of a repository to keep it up-to-date with the upstream repository.Merging a pull requestMerge a pull request into the upstream branch when work is completed. Anyone with push access to the repository can complete the merge.What's newView all Pull request merge experience – April 3 updateApril 03Improved pull request merge experience is now generally availableMarch 04Improved pull request merge experience enabled by default in public previewFebruary 12GuidesApproving a pull request with required reviewsIf your repository requires reviews, pull requests must have a specific number of approving reviews from people with write or admin permissions in the repository before they can be merged.@GitHubReverting a pull requestYou can revert a pull request after it's been merged to the upstream branch.@GitHubWhy are my commits linked to the wrong user?GitHub uses the email address in the commit header to link the commit to a GitHub user. If your commits are being linked to another user, or not linked to a user at all, you may need to change your local Git configuration settings, add an email address to your account email settings, or do both.@GitHubAll Pull requests docsCommitting changes to your projectCreating and editing commits • 4 articlesViewing and comparing commits • 2 articlesTroubleshooting commits • 3 articlesCollaborating with pull requestsGetting started • 3 articlesWorking with forks • 8 articlesCollaborating on repositories with code quality features • 2 articlesProposing changes to your work with pull requests • 12 articlesAddressing merge conflicts • 3 articlesReviewing changes in pull requests • 11 articlesIncorporating changes from a pull request • 6 articles\n\n\n\nGitHub Discussions documentation GitHub Discussions is a collaborative communication forum for the community around an open source or internal project. Community members can ask and answer questions, share updates, have open-ended conversations, and follow along on decisions affecting the community's way of working.Quickstart Start hereView all About discussionsUse discussions to ask and answer questions, share information, make announcements, and conduct or participate in a conversation about a project.Participating in a discussionYou can converse with the community and maintainers in a forum within the repository for a project on GitHub.Moderating discussionsYou can promote healthy collaboration by marking comments as answers, locking or unlocking discussions, converting issues to discussions, and editing or deleting comments, discussions, and categories that don't align with your community's code of conduct.PopularGranting higher permissions to top contributorsRepository administrators can promote any community member to a moderator and maintainer.Best practices for community conversations on GitHubYou can use discussions to brainstorm with your team, and eventually move the conversation to an issue when you are ready to scope out the work.Finding your discussionsYou can easily access every discussion you've created or participated in.Collaborating with maintainers using discussionsYou can contribute to the goals, plans, health, and community for a project on GitHub by communicating with the maintainers of the project in a discussion.What's newView all Incidents will now post in Community DiscussionsDecember 11Delete discussions when blocking their author from your organizationJuly 31The Comment Box Becomes More Consistent and AccessibleOctober 31Communities on GitHub.com using discussionsvercel/next.jsThe React Frameworkgatsbyjs/gatsbyBuild blazing fast, modern apps and websites with Reactnodejs/nodeNode.js JavaScript runtime ✨🐢🚀✨tailwindlabs/tailwindcssA utility-first CSS framework for rapid UI development.laravel/frameworkLaravel is a web application framework with expressive, elegant syntax.prisma/prismaModern database access (ORM alternative) for Node.js & TypeScript | PostgreSQL, MySQL, MariaDB & SQLitedotnet/csharplangThe official repo for the design of the C# programming languagehome-assistant/frontend🍭 Frontend for Home Assistantjspsych/jsPsychA JavaScript library for creating and running behavioral experiments in a web browseradonisjs/core🚀 The Node.js Framework highly focused on developer ergonomics, stability and confidenceImageMagick/ImageMagick🧙‍♂️ ImageMagick 7react-hook-form/react-hook-form📋 React Hooks for forms validation (Web + React Native)GuidesAbout discussionsUse discussions to ask and answer questions, share information, make announcements, and conduct or participate in a conversation about a project.@GitHubParticipating in a discussionYou can converse with the community and maintainers in a forum within the repository for a project on GitHub.@GitHubModerating discussionsYou can promote healthy collaboration by marking comments as answers, locking or unlocking discussions, converting issues to discussions, and editing or deleting comments, discussions, and categories that don't align with your community's code of conduct.@GitHubExplore guides All GitHub Discussions docsDiscussions guidesBest practices for community conversations on GitHubFinding your discussionsGranting higher permissions to top contributorsCollaborating with your community using discussionsAbout discussionsParticipating in a discussionCollaborating with maintainers using discussionsManaging discussions for your communityManaging discussionsManaging categories for discussionsModerating discussionsViewing insights for your discussionsCreating discussion category formsSyntax for discussion category forms\n\n\n\nGitHub Copilot documentation You can use GitHub Copilot to get autocomplete-style suggestions from an AI pair programmer as you code.Overview Quickstart Start hereWhat is GitHub Copilot?Learn what GitHub Copilot is and what you can do with it.Quickstart for GitHub CopilotQuickly learn how to use GitHub Copilot.Quickstart for GitHub Copilot Extensions using agentsBuild and try out GitHub's Blackbeard extension to learn about the development process for GitHub Copilot Extensions.PopularBest practices for using GitHub CopilotLearn how to get the most out of Copilot.Copilot Chat CookbookFind examples of prompts to use with GitHub Copilot Chat.Getting code suggestions in your IDE with GitHub CopilotUse GitHub Copilot to get code suggestions in your editor.Asking GitHub Copilot questions in your IDEUse Copilot Chat in your editor to give you code suggestions, explain code, generate unit tests, and suggest code fixes.What's newView all OpenAI o3 and o4-mini are now available in public preview for GitHub Copilot and GitHub ModelsApril 16Using vision input in Copilot Chat with Claude and Gemini is now in public previewApril 16GitHub Copilot Chat for Eclipse is now generally availableApril 16All GitHub Copilot docsAbout GitHub CopilotWhat is GitHub Copilot?GitHub Copilot featuresPlans for GitHub CopilotSetting up GitHub CopilotSetting up GitHub Copilot for your organizationSetting up GitHub Copilot for yourselfUsing GitHub CopilotBest practices for using GitHub CopilotGetting code suggestions in your IDE with GitHub CopilotCopilot Chat • 7 articlesAsking GitHub Copilot questions in Windows TerminalCode review • 3 articlesUsing GitHub Copilot in the command lineUsing extensions to integrate external tools with Copilot ChatAI models for Copilot • 9 articlesFinding public code that matches GitHub Copilot suggestionsUsing GitHub Copilot for pull requests • 2 articlesGuides on using GitHub Copilot • 4 articlesCopilot Chat CookbookDebugging errors • 2 articlesFunctionality analysis and feature suggestions • 2 articlesRefactoring code • 10 articlesDocumenting code • 5 articlesTesting code • 3 articlesSecurity analysis • 1 articlesManaging CopilotManaging Copilot as an individual subscriber • 3 articlesManaging GitHub Copilot in your organization • 5 articlesManaging GitHub Copilot in your enterprise • 1 articlesMonitoring usage and entitlements • 2 articlesConfiguring personal settings • 6 articlesConfiguring and auditing content exclusion • 2 articlesRolling out GitHub Copilot at scaleChoosing your enterprise's plan for GitHub CopilotDriving Copilot adoption in your companySetting up a self-serve process for GitHub Copilot licensesAnalyzing usage over time with the Copilot metrics APIReminding inactive users to use their GitHub Copilot licenseManaging your company's spending on GitHub CopilotCustomizing CopilotExtending the capabilities of GitHub Copilot in your organizationAbout customizing GitHub Copilot Chat responsesAdding personal custom instructions for GitHub CopilotAdding repository custom instructions for GitHub CopilotExtending Copilot Chat with the Model Context Protocol (MCP)Building Copilot ExtensionsAbout building Copilot ExtensionsQuickstart for GitHub Copilot Extensions using agentsSetting up Copilot ExtensionsCreating a Copilot Extension • 3 articlesBuilding a Copilot agent for your Copilot Extension • 5 articlesBuilding a Copilot skillset for your Copilot Extension • 2 articlesUsing OIDC with GitHub Copilot ExtensionsDebugging your GitHub Copilot ExtensionManaging the availability of your Copilot ExtensionCopilot Extensions FAQCopilot Extensions GlossaryTroubleshooting GitHub CopilotTroubleshooting common issues with GitHub CopilotViewing logs for GitHub Copilot in your environmentTroubleshooting firewall settings for GitHub CopilotTroubleshooting network errors for GitHub CopilotTroubleshooting issues with GitHub Copilot ChatResponsible use of GitHub Copilot featuresResponsible use of GitHub Copilot Chat in your IDEResponsible use of GitHub Copilot Chat in GitHubResponsible use of GitHub Copilot Chat in GitHub MobileResponsible use of GitHub Copilot in the CLIResponsible use of GitHub Copilot in Windows TerminalResponsible use of GitHub Copilot in GitHub DesktopResponsible use of GitHub Copilot pull request summariesResponsible use of GitHub Copilot text completionResponsible use of GitHub Copilot code review\n\n\n\nGitHub Copilot/Use GitHub Copilot/Get code suggestionsGetting code suggestions in your IDE with GitHub CopilotUse GitHub Copilot to get code suggestions in your editor.Tool navigationAzure Data StudioEclipseJetBrains IDEsVim/NeovimVisual StudioVisual Studio CodeXcodeIn this articleAbout GitHub Copilot and JetBrains IDEsPrerequisitesGetting code suggestionsShowing alternative suggestionsShowing multiple suggestions in a new tabAccepting partial suggestionsAbout GitHub Copilot and Visual StudioPrerequisitesGetting code suggestionsShowing alternative suggestionsGetting comment suggestionsAbout GitHub Copilot and Visual Studio CodePrerequisitesGetting code suggestionsShowing alternative suggestionsShowing multiple suggestions in a new tabAccepting partial suggestionsAbout next edit suggestionsChanging the AI modelAbout GitHub Copilot and Vim/NeovimPrerequisitesLearning to use GitHub Copilot in Vim/NeovimAbout GitHub Copilot and Azure Data StudioPrerequisitesGetting code suggestionsShowing alternative suggestionsAccepting partial suggestionsAbout GitHub Copilot in XcodePrerequisitesGetting code suggestionsAbout GitHub Copilot and EclipsePrerequisitesGetting code suggestionsManually triggering code completionAccepting partial suggestionsNext steps

    
        Get started for free 
    
    
    
        Open in Visual Studio Code 
    
    


About GitHub Copilot and JetBrains IDEs
This guide demonstrates how to get coding suggestions from GitHub Copilot in a JetBrains IDE. To see instructions for other popular coding environments, use the tool switcher at the top of the page.
The examples in this guide use Java, however other languages will work similarly. GitHub Copilot provides suggestions for numerous languages and a wide variety of frameworks, but works especially well for Python, JavaScript, TypeScript, Ruby, Go, C# and C++. GitHub Copilot can also assist in query generation for databases, generating suggestions for APIs and frameworks, and can help with infrastructure as code development.
Prerequisites


Access to Copilot. To use GitHub Copilot in JetBrains, you need either limited access through Copilot Free or a paid Copilot plan for full access. For information about how to get access to Copilot, see What is GitHub Copilot?.


Compatible JetBrains IDE. To use GitHub Copilot in JetBrains, you must have a compatible JetBrains IDE installed. GitHub Copilot is compatible with the following IDEs:

IntelliJ IDEA (Ultimate, Community, Educational)
Android Studio
AppCode
CLion
Code With Me Guest
DataGrip
DataSpell
GoLand
JetBrains Client
MPS
PhpStorm
PyCharm (Professional, Community, Educational)
Rider
RubyMine
RustRover
WebStorm
Writerside

See the JetBrains IDEs tool finder to download.


GitHub Copilot plugin. See the GitHub Copilot plugin in the JetBrains Marketplace. For installation instructions, see Installing the GitHub Copilot extension in your environment.


Log in to GitHub in your JetBrains IDE. For authentication instructions, see Installing the GitHub Copilot extension in your environment.


Getting code suggestions
GitHub Copilot offers coding suggestions as you type. For example, in a Java file, create a class by typing class Test.
GitHub Copilot will automatically suggest a class body in grayed text. To accept the suggestion, press Tab.
You can also describe something you want to do using natural language within a comment, and Copilot will suggest the code to accomplish your goal. For example, type this comment in a Java file:
Java// find all images without alternate text
// and give them a red border
void process () {
// find all images without alternate text
// and give them a red border
void process () {

GitHub Copilot will automatically suggest code. To accept the suggestion, press Tab.
GitHub Copilot will attempt to match the context and style of your code. You can always edit the suggested code.
Tip

If you receive limited or no suggestions from Copilot, you may have duplication detection enabled. For more information about duplication detection, see Managing Copilot policies as an individual subscriber.

Showing alternative suggestions
For any given input, GitHub Copilot may offer multiple suggestions. You can select which suggestion to use, or reject all suggestions.
For example, type the following line in a Java file, and press Enter:
Javaprivate int calculateDaysBetweenDates(Date date1,
private int calculateDaysBetweenDates(Date date1,

GitHub Copilot will show you a suggestion.
Now hover over the suggestion to show the GitHub Copilot control for choosing suggestions. To display next or previous suggestions, click the forward or back arrow button in the control.
You can also use keyboard shortcuts to show alternative suggestions:




















OSSee next suggestionSee previous suggestionmacOSOption+]Option+[Windows or LinuxAlt+]Alt+[
To accept a suggestion, click "Accept" in the Copilot command palette, or press Tab. To reject all suggestions, press Esc.
Showing multiple suggestions in a new tab
If you don't want to use any of the initial suggestions GitHub Copilot offers, you can show multiple suggestions in a new tab.
For example, type the following line in a Java file:
Javaprivate int calculateDaysBetweenDates(Date date1,
private int calculateDaysBetweenDates(Date date1,

GitHub Copilot will show you a suggestion.
To open a new tab with multiple additional suggestions, use the following keyboard shortcut, then click Open GitHub Copilot:

















OSOpen multiple suggestionsmacOSCommand+Shift+AWindows or LinuxCtrl+Enter
To accept a suggestion, below the suggestion, click Accept suggestion NUMBER. To reject all suggestions, close the tab.
Accepting partial suggestions
If you don't want to accept an entire suggestion from GitHub Copilot, you can accept the next word or the next line of a suggestion.
For example, type the following line in a Java file:
Javaprivate int calculateDaysBetweenDates(Date date1,
private int calculateDaysBetweenDates(Date date1,

GitHub Copilot will show a suggestion in grayed text. The exact suggestion may vary.
Now hover over the suggestion to show the GitHub Copilot control for choosing suggestions. To accept only the next word of the suggestion, click Accept Word in the control.
Alternatively, you can use a keyboard shortcut to accept the next word of a suggestion:




















OSAccept Next WordAccept Next LinemacOSCommand+→Command+Control+→Windows or LinuxControl+→Control+Alt+→
If you want to accept the next line of a suggestion, you will need to set a custom keyboard shortcut for the command editor.action.inlineSuggest.acceptNextLine. For more information on setting custom keyboard shortcuts, see Configuring GitHub Copilot in your environment.


About GitHub Copilot and Visual Studio
This guide demonstrates how to get coding suggestions from GitHub Copilot in Visual Studio for Windows. To see instructions for other popular coding environments, use the tool switcher at the top of the page.
The examples in this guide use C#, however other languages will work similarly. GitHub Copilot provides suggestions for numerous languages and a wide variety of frameworks, but works especially well for Python, JavaScript, TypeScript, Ruby, Go, C# and C++. GitHub Copilot can also assist in query generation for databases, generating suggestions for APIs and frameworks, and can help with infrastructure as code development.
Prerequisites


Access to Copilot. To use GitHub Copilot in GitHub Copilot in Visual Studio, you need either limited access through Copilot Free or a paid Copilot plan for full access. For information about how to get access to Copilot, see What is GitHub Copilot?.


Compatible version of Visual Studio. To use GitHub Copilot in Visual Studio, you must have version 2022 17.8 or later of Visual Studio for Windows installed. For more information, see Install Visual Studio in the Microsoft documentation.


GitHub Copilot extension for Visual Studio. For instructions on how to install the Copilot extension, see Install GitHub Copilot in Visual Studio in the Microsoft documentation.


Add your GitHub account to Visual Studio. See Add your GitHub accounts to your Visual Studio keychain in the Microsoft documentation.


Getting code suggestions
GitHub Copilot offers coding suggestions as you type. For example, type this function
signature in a C# file:
C#int CalculateDaysBetweenDates(
int CalculateDaysBetweenDates(

GitHub Copilot will automatically suggest an entire function body in grayed text. To accept the suggestion, press Tab.
You can also describe something you want to do using natural language within a comment, and Copilot will suggest the code to accomplish your goal. For example, type this comment in the C# file:
C#using System.Xml.Linq;

var doc = XDocument.Load("index.xhml");

// find all images
using System.Xml.Linq;

var doc = XDocument.Load("index.xhml");

// find all images

GitHub Copilot will suggest an implementation of the function. To accept the suggestion, press Tab.
Tip

If you receive limited or no suggestions from Copilot, you may have duplication detection enabled. For more information about duplication detection, see Managing Copilot policies as an individual subscriber.

Showing alternative suggestions
For any given input, GitHub Copilot may offer multiple suggestions. You can select which suggestion to use, or reject all suggestions.
For example, type this function signature in a C# file:
C#int CalculateDaysBetweenDates(
int CalculateDaysBetweenDates(

GitHub Copilot will show you a suggestion.
Now hover over the suggestion to show the GitHub Copilot control for choosing suggestions. To display next or previous suggestions, click the forward or back arrow button in the control.
Alternatively, you can show alternate suggestions by pressing Alt+. (or Alt+,) on your keyboard.
To accept a suggestion, click "Accept" in the Copilot command palette, or press Tab. To reject all suggestions, press Esc.
Getting comment suggestions
Note


Comment suggestions are currently in public preview and are subject to change.
Comment suggestions are available in Visual Studio 17.14 Preview 2 and later.


GitHub Copilot can suggest comments for your code, by analyzing the code you write and generating comments that describe what the code does. For Copilot Free users, comment suggestions count towards your monthly Copilot Chat usage, not your code suggestions usage.
Comment suggestions are available in the following languages:

C#
C++

Enabling comment suggestions
To enable comment suggestions, you need to configure the comment style in Visual Studio.
For C++

In Visual Studio, in the Tools menu, click Options.
In the left-side panel, click Text Editor.
Click C++, then Code Style, then General.
Under "Comments", select Xml Doc Comments from the dropdown.
Select Insert existing comment style at the start of new lines when writing comments and Continue single line comments.

For C#

In Visual Studio, in the Tools menu, click Options.
In the left-side panel, click Text Editor.
Click C#, then Advanced.
Under "Comments", select Generate XML documentation comments for ///, Insert // at the start of new lines when writing // comments, and Insert * at the start of new lines when writing /* */ comments.

Using comment suggestions
To initiate comment suggestions, type the standard comment initiator for the language you are writing in (for example, ///), before the code you want to comment, and wait for the suggestion to appear.
To accept the suggestion, press Tab. To modify the suggestion, press Alt+/. To reject the suggestion, press Esc.


About GitHub Copilot and Visual Studio Code
This guide demonstrates how to get coding suggestions from GitHub Copilot in Visual Studio Code. To see instructions for other popular coding environments, use the tool switcher at the top of the page.
Copilot in VS Code provides two kinds of suggestions:

Code completions. Copilot offers coding suggestions as you type. You can also describe something you want to do using natural language within a comment, and Copilot will suggest the code to accomplish your goal.
Next edit suggestions (public preview). Based on the edits you are making, Copilot will predict the location of the next edit you are likely to make and suggest a completion for it.

The examples in this guide use JavaScript, however other languages will work similarly. GitHub Copilot provides suggestions for numerous languages and a wide variety of frameworks, but works especially well for Python, JavaScript, TypeScript, Ruby, Go, C# and C++. GitHub Copilot can also assist in query generation for databases, generating suggestions for APIs and frameworks, and can help with infrastructure as code development.
Prerequisites


Access to Copilot. To use GitHub Copilot in Visual Studio Code, you need either limited access through Copilot Free or a paid Copilot plan for full access. For information about how to get access to Copilot, see What is GitHub Copilot?.


Sign in to GitHub in Visual Studio Code. See Set up GitHub Copilot in Visual Studio Code in the VS Code documentation..


Visual Studio Code. To use GitHub Copilot in Visual Studio Code, you must have Visual Studio Code installed. For more information, see the Visual Studio Code download page.


Copilot in Visual Studio Code. When you set up GitHub Copilot in Visual Studio Code for the first time, the required extensions are installed automatically. You don't need to download or install them manually. For detailed instructions, see Set up GitHub Copilot in Visual Studio Code in the Visual Studio Code documentation.


Getting code suggestions
GitHub Copilot offers coding suggestions as you type. For example, type this function header in a JavaScript file:
JavaScriptfunction calculateDaysBetweenDates(begin, end) {
function calculateDaysBetweenDates(begin, end) {

GitHub Copilot will automatically suggest the rest of the function. To accept the suggestion, press Tab.
You can also describe something you want to do using natural language within a comment, and Copilot will suggest the code to accomplish your goal. For example, type this comment in a JavaScript file:
JavaScript// write a function to
// find all images without alternate text
// and give them a red border
// write a function to
// find all images without alternate text
// and give them a red border

GitHub Copilot will automatically suggest code. To accept the suggestion, press Tab.
Tip

If you receive limited or no suggestions from Copilot, you may have duplication detection enabled. For more information about duplication detection, see Managing Copilot policies as an individual subscriber.

Showing alternative suggestions
For any given input, GitHub Copilot may offer multiple suggestions. You can select which suggestion to use, or reject all suggestions.
For example, type this function header in a JavaScript file, and press Enter:
JavaScriptfunction calculateDaysBetweenDates(begin, end) {
function calculateDaysBetweenDates(begin, end) {

GitHub Copilot will show you a suggestion.
Now hover over the suggestion to show the GitHub Copilot control for choosing suggestions. To display next or previous suggestions, click the forward or back arrow button in the control.
You can also use keyboard shortcuts to show alternative suggestions:




















OSSee next suggestionSee previous suggestionmacOSOption (⌥) or Alt+]Option (⌥) or Alt+[Windows or LinuxAlt+]Alt+[
To accept a suggestion, click "Accept" in the Copilot command palette, or press Tab. To reject all suggestions, press Esc.
Showing multiple suggestions in a new tab
If you don't want to use any of the initial suggestions GitHub Copilot offers, you can show multiple suggestions in a new tab.
For example, type this function header in a JavaScript file, and press Enter:
JavaScriptfunction calculateDaysBetweenDates(begin, end) {
function calculateDaysBetweenDates(begin, end) {

GitHub Copilot will show you a suggestion. Now press Ctrl+Enter to open a new tab with multiple additional options.
To accept a suggestion, below the suggestion, click Accept suggestion NUMBER. To reject all suggestions, close the tab.
Accepting partial suggestions
If you don't want to accept an entire suggestion from GitHub Copilot, you can accept the next word or the next line of a suggestion.
For example, type this function header in a JavaScript file, and press Enter:
JavaScriptfunction calculateDaysBetweenDates(begin, end) {
function calculateDaysBetweenDates(begin, end) {

GitHub Copilot will automatically suggest an entire function body in grayed text. The exact suggestion may vary.
Now hover over the suggestion to show the GitHub Copilot control for choosing suggestions. To accept only the next word of the suggestion, click Accept Word in the control.
Alternatively, you can use a keyboard shortcut to accept the next word of a suggestion:

















OSAccept Next WordmacOSCommand+→Windows or LinuxControl+→
If you want to accept the next line of a suggestion, you will need to set a custom keyboard shortcut for the command editor.action.inlineSuggest.acceptNextLine. For more information on setting custom keyboard shortcuts, see Configuring GitHub Copilot in your environment.
About next edit suggestions
Inline suggestions autocomplete code, but many development tasks involve editing existing code. Next edit suggestions assists with edits both at the cursor and in other relevant parts of the code, helping maintain consistency and streamline changes.
Next edit suggestions predicts where and what edits may be needed based on ongoing changes. Suggestions may span a single symbol, an entire line, or multiple lines, depending on the scope of the potential change.
To enable next edit suggestions, see Configuring GitHub Copilot in your environment.
Navigating and accepting suggestions
You can navigate suggested code changes using Tab, making it easier to find the next relevant edit without manually searching through files or references. Press Tab again to accept a suggestion.
An arrow in the gutter indicates an available edit suggestion. Hover over the arrow to access the edit suggestion menu, which provides keyboard shortcuts and settings options. If an edit suggestion is outside the current editor view, the arrow will point up or down to indicate where the next suggestion is.

For more details and examples, see Code completions with GitHub Copilot in VS Code in the Visual Studio Code documentation.
Changing the AI model
You can change the large language model that's used to generate code completion suggestions. For more information, see Changing the AI model for Copilot code completion.


About GitHub Copilot and Vim/Neovim
This guide demonstrates how to get coding suggestions from GitHub Copilot in Vim/Neovim. To see instructions for other popular coding environments, use the tool switcher at the top of the page.
Prerequisites


Access to Copilot. To use GitHub Copilot in Vim/Neovim, you need either limited access through Copilot Free or a paid Copilot plan for full access. For information about how to get access to Copilot, see What is GitHub Copilot?.


Compatible version of Vim/Neovim. To use GitHub Copilot in Vim/Neovim you must have Vim version 9.0.0185 / Neovim version 0.6 or above and Node.js version 18 or above installed. For more information, see the Vim / Neovim documentation and the Node.js website.


GitHub Copilot extension for Vim/Neovim. To use GitHub Copilot in Vim/Neovim, you must install the GitHub Copilot plugin. For more information, see Installing the GitHub Copilot extension in your environment.


Learning to use GitHub Copilot in Vim/Neovim
GitHub Copilot provides suggestions inline as you type in Vim/Neovim. To accept a suggestion, press the tab key.
For more information and guidance on using GitHub Copilot in Vim/Neovim run the following command to view the plugin documentation:
Shell:help copilot
:help copilot



About GitHub Copilot and Azure Data Studio
This guide demonstrates how to get coding suggestions from GitHub Copilot in Azure Data Studio. To see instructions for other popular coding environments, use the tool switcher at the top of the page.
Prerequisites


Access to Copilot. To use GitHub Copilot in Azure Data Studio, you need either limited access through Copilot Free or a paid Copilot plan for full access. For information about how to get access to Copilot, see What is GitHub Copilot?.


Compatible version of Azure Data Studio. To use GitHub Copilot in Azure Data Studio, you must have Azure Data Studio version 1.44.0 or later installed. For more information, see the Azure Data Studio download page in the Azure Data Studio documentation.


GitHub Copilot extension for Azure Data Studio. To use GitHub Copilot in Azure Data Studio, you must install the GitHub Copilot extension. For more information, see Installing the GitHub Copilot extension in your environment.


Getting code suggestions
GitHub Copilot can provide you with inline suggestions as you create SQL databases in Azure Data Studio. For example, if you're writing a query that joins two tables, Copilot may suggest the join condition from columns in the open editor, other files in the workspace, and common syntax patterns.
In a SQL file, type the following query:
SQLSELECT [UserId], [Red], [Orange], [Yellow], [Green], [Blue], [Purple], [Rainbow]
FROM [Tag].[Scoreboard]
INNER JOIN
SELECT [UserId], [Red], [Orange], [Yellow], [Green], [Blue], [Purple], [Rainbow]
FROM [Tag].[Scoreboard]
INNER JOIN

GitHub Copilot will automatically suggest a join condition in grayed text. The exact suggestion may vary. To accept the suggestion, press Tab.
You can also describe something you want to do using natural language within a comment, and Copilot will suggest the code to accomplish your goal. For example, type this comment in a SQL file:
SQLSELECT TokenColor, COUNT(UserID) AS UserCount
FROM Tag.Users
GROUP BY TokenColor
-- pivot that query on tokencolor for Purple, Blue, Green, Yellow, Orange, Red
-- and rename the columns to match the colors
SELECT [Purple], [Blue], [Green], [Yellow], [Orange], [Red]
SELECT TokenColor, COUNT(UserID) AS UserCount
FROM Tag.Users
GROUP BY TokenColor
-- pivot that query on tokencolor for Purple, Blue, Green, Yellow, Orange, Red
-- and rename the columns to match the colors
SELECT [Purple], [Blue], [Green], [Yellow], [Orange], [Red]

GitHub Copilot will automatically suggest code. To accept the suggestion, press Tab.
Tip

If you receive limited or no suggestions from Copilot, you may have duplication detection enabled. For more information on duplication detection, see Managing Copilot policies as an individual subscriber.

Showing alternative suggestions
For some suggestions, GitHub Copilot may provide multiple alternatives. You can select which suggestion you want to use, or reject all suggestions.
For example, type this query in a SQL file:
SQLSELECT [UserId], [Red], [Orange], [Yellow], [Green], [Blue], [Purple], [Rainbow]
FROM [Tag].[Scoreboard]
INNER JOIN
SELECT [UserId], [Red], [Orange], [Yellow], [Green], [Blue], [Purple], [Rainbow]
FROM [Tag].[Scoreboard]
INNER JOIN

GitHub Copilot will show you a suggestion.
Now hover over the suggestion to show the GitHub Copilot control for choosing suggestions. To display next or previous suggestions, click the forward or back arrow button in the control.
You can also use keyboard shortcuts to show alternative suggestions:




















OSSee next suggestionSee previous suggestionmacOSOption+[Option+]Windows or LinuxAlt+[Alt+]
To accept a suggestion, click "Accept" in the Copilot control, or press Tab. To reject all suggestions, press Esc.
Accepting partial suggestions
If you don't want to accept an entire suggestion from GitHub Copilot, you can accept the next word or the next line of a suggestion.
For example, type this query in a SQL file:
SQLSELECT [UserId], [Red], [Orange], [Yellow], [Green], [Blue], [Purple], [Rainbow]
FROM [Tag].[Scoreboard]
INNER JOIN
SELECT [UserId], [Red], [Orange], [Yellow], [Green], [Blue], [Purple], [Rainbow]
FROM [Tag].[Scoreboard]
INNER JOIN

GitHub Copilot will show you a suggestion in grayed text. The exact suggestion may vary.
Now hover over the suggestion to show the GitHub Copilot control for choosing suggestions. To accept only the next word of the suggestion, click Accept Word in the control.
Alternatively, you can use a keyboard shortcut to accept the next word of a suggestion:

















OSAccept Next WordmacOSCommand+→Windows or LinuxControl+→
If you want to accept the next line of the suggestion, you will need to set a custom keyboard shortcut for the command editor.action.inlineSuggest.acceptNextLine. For more information on setting custom keyboard shortcuts, see Keyboard shortcuts in Azure Data Studio in the Microsoft documentation.


About GitHub Copilot in Xcode
This guide demonstrates how to get coding suggestions from GitHub Copilot in Xcode. To see instructions for other popular coding environments, use the tool switcher at the top of the page.
Prerequisites


Access to Copilot. To use GitHub Copilot in Xcode, you need either limited access through Copilot Free or a paid Copilot plan for full access. For information about how to get access to Copilot, see What is GitHub Copilot?.


GitHub Copilot extension for Xcode. To use GitHub Copilot for Xcode, you must install the GitHub Copilot for Xcode extension. See Installing the GitHub Copilot extension in your environment.


Getting code suggestions
GitHub Copilot offers coding suggestions as you type. For example, type this function
signature in a Swift file:
Swiftfunc calculateDaysBetweenDates(
func calculateDaysBetweenDates(

GitHub Copilot will automatically suggest an entire function body in grayed text. To accept the first line of a suggestion, press Tab. To view the full suggestion, hold Option, and to accept the full suggestion, press Option+Tab.
Improving code suggestions
If you encounter issues with code suggestions, such as conflicting or missing suggestions, you can try the following:

Disable Xcode's native predictive text completion: To avoid receiving two sets of code suggestions, you can disable Xcode's native predictive text completion. You can find this setting in the Xcode settings in the "Editing" tab under "Text Editing".
Check for duplication detection in Copilot: If you receive limited or no suggestions from Copilot, you may have duplication detection enabled. For more information on duplication detection, see Managing Copilot policies as an individual subscriber.
Check for updates and restart Xcode: Ensure you have the latest version of Copilot for Xcode in the extension application and restart Xcode.

You can also open an issue in the Copilot for Xcode repository.


About GitHub Copilot and Eclipse
This guide demonstrates how to get coding suggestions from GitHub Copilot in Eclipse. To see instructions for other popular coding environments, use the tool switcher at the top of the page.
Prerequisites


Access to Copilot. To use GitHub Copilot in Eclipse, you need either limited access through Copilot Free or a paid Copilot plan for full access. For information about how to get access to Copilot, see What is GitHub Copilot?.


GitHub Copilot extension for Eclipse.To use GitHub Copilot in Eclipse, you must install the GitHub Copilot extension. See Installing the GitHub Copilot extension in your environment.


Getting code suggestions
GitHub Copilot offers coding suggestions as you type. For example, type this function header in a Java file:
Javapublic int getDiff(int a, int b)
public int getDiff(int a, int b)

GitHub Copilot will automatically suggest the rest of the function. To accept the suggestion, press Tab.
To discard the suggestion, press Esc.
You can also describe something you want to do using natural language within a comment, and Copilot will suggest the code to accomplish your goal. For example, type this comment in a Java file:
Java/*
 * Return the difference between two different integers.
 */
/*
 * Return the difference between two different integers.
 */

GitHub Copilot will automatically suggest code.
Tip

If you receive limited or no suggestions from Copilot, you may have duplication detection enabled. For more information about duplication detection, see Managing Copilot policies as an individual subscriber.

Manually triggering code completion
You can also use keyboard shortcuts to trigger code completion.

















OSTrigger code completionmacOSOption+Command+/Windows or LinuxCtrl+Alt+/
Accepting partial suggestions
If you don't want to accept an entire suggestion from Copilot, you can accept the next word of a suggestion.

















OSAccept next wordmacOSCommand+→Windows or LinuxCtrl+→

Next steps

Learn how to write effective prompts - See Prompt engineering for Copilot Chat.
Configure Copilot in your editor - You can enable or disable GitHub Copilot from within your editor, and create your own preferred keyboard shortcuts for Copilot. See Configuring GitHub Copilot in your environment.
Get started with GitHub Copilot Chat - Learn how to ask Copilot for information and assistance, using GitHub Copilot Chat. See Asking GitHub Copilot questions in your IDE.
Troubleshoot issues - Learn more about how to troubleshoot common issues with GitHub Copilot. See Troubleshooting GitHub Copilot.\n\n\n\nGitHub Copilot/Use GitHub Copilot/Copilot Chat/Prompt engineeringPrompt engineering for Copilot ChatFollow these strategies to improve your Copilot results.In this articleStart general, then get specificGive examplesBreak complex tasks into simpler tasksAvoid ambiguityIndicate relevant codeExperiment and iterateKeep history relevantFollow good coding practicesFurther readingA prompt is a request that you make to GitHub Copilot. For example, a question that you ask Copilot Chat, or a code snippet that you ask Copilot to complete. In addition to your prompt, Copilot uses additional context, like the code in your current file and the chat history, to generate a response.
Follow the tips in this article to write prompts that generate better responses from Copilot.
Start general, then get specific
When writing a prompt for Copilot, first give Copilot a broad description of the goal or scenario. Then list any specific requirements.
For example:

Write a function that tells me if a number is prime
The function should take an integer and return true if the integer is prime
The function should error if the input is not a positive integer

Give examples
Use examples to help Copilot understand what you want. You can provide example input data, example outputs, and example implementations.
For example:

Write a function that finds all dates in a string and returns them in an array. Dates can be formatted like:

05/02/24
05/02/2024
5/2/24
5/2/2024
05-02-24
05-02-2024
5-2-24
5-2-2024

Example:
findDates("I have a dentist appointment on 11/14/2023 and book club on 12-1-23")
Returns: ["11/14/2023", "12-1-23"]

Unit tests can also serve as examples. Before writing your function, you can use Copilot to write unit tests for the function. Then, you can ask Copilot to write a function described by those unit tests.
Break complex tasks into simpler tasks
If you want Copilot to complete a complex or large task, break the task into multiple simple, small tasks.
For example, instead of asking Copilot to generate a word search puzzle, break the process down into smaller tasks, and ask Copilot to accomplish them one by one:

Write a function to generate a 10 by 10 grid of letters.
Write a function to find all words in a grid of letters, given a list of valid words.
Write a function that uses the previous functions to generate a 10 by 10 grid of letters that contains at least 10 words.
Update the previous function to print the grid of letters and 10 random words from the grid.

Avoid ambiguity
Avoid ambiguous terms. For example, don’t ask "what does this do" if "this" could be the current file, the last Copilot response, or a specific code block. Instead, be specific:

What does the createUser function do?
What does the code in your last response do?

Ambiguity can also apply to libraries:

If you are using an uncommon library, describe what the library does.
If you want to use a specific library, set the import statements at the top of the file or specify what library you want to use.

Indicate relevant code
If you are using Copilot in your IDE to get suggestions as you code, open any relevant files and close irrelevant files. Copilot will use the open files to understand your request.
If you are using Copilot Chat in your IDE, open the file or highlight the code that you want Copilot to reference. You can also use keywords to manually supply context to Copilot Chat. For example, you can add the @workspace chat participant in VS Code, or @project in JetBrains IDEs. See GitHub Copilot Chat cheat sheet.
Experiment and iterate
If you don’t get the result that you want, iterate on your prompt and try again.
If you are using Copilot to get suggestions as you code, you can delete the suggestion entirely and start over. Or you can keep the suggestion and request modifications.
If you are using Copilot Chat, you can reference the previous response in your next request. Or, you can delete the previous response and start over.
Keep history relevant
Copilot Chat uses the chat history to get context about your request. To give Copilot only the relevant history:

Use threads to start a new conversation for a new task
Delete requests that are no longer relevant or that didn’t give you the desired result

Follow good coding practices
If you aren't getting the responses you want when you ask Copilot for suggestions or explanations in your codebase, make sure that your existing code follows best practices and is easy to read. For example:

Use a consistent code style and patterns
Use descriptive names for variables and functions
Comment your code
Structure your code into modular, scoped components
Include unit tests

Tip

Use Copilot to help your code follow best practices. For example, ask Copilot to add comments or to break a large function into smaller functions.

Further reading

How to use GitHub Copilot: Prompts, tips, and use cases in the GitHub blog
Using GitHub Copilot in your IDE: Tips, tricks, and best practices in the GitHub blog
A developer’s guide to prompt engineering and LLMs in the GitHub blog
Prompting GitHub Copilot Chat to become your personal AI assistant for accessibility in the GitHub blog\n\n\n\nGitHub Copilot/Use GitHub Copilot/Copilot Chat/Chat in GitHubAsking GitHub Copilot questions in GitHubYou can use GitHub Copilot Chat in GitHub to answer general questions about software development, or specific questions about the issues or code in a repository.In this articleOverviewPowered by skillsCustomizing Copilot Chat responsesAI models for Copilot ChatSubmitting a question to Copilot ChatAsking Copilot Chat questions in different contextsAsking Copilot Chat questions in a repositoryAsking Copilot Chat questions about a specific file or symbolAsking Copilot Chat questions about specific pieces of codeAsking questions about alerts from GitHub Advanced Security productsAsking questions about a specific pull requestAsking a question about a specific issue or discussionAsking a question about a specific commitUsing images in Copilot ChatAccessing Copilot Chat from the search barAccessing Copilot Chat from the dashboardExtending Copilot Chat in GitHubSharing Copilot Chat conversationsSharing feedback about GitHub Copilot Chat in GitHubFurther readingOverview
GitHub Copilot Chat in GitHub is a chat interface that lets you ask and receive answers to coding-related questions on the GitHub website.
Copilot Chat can help you with a variety of coding-related tasks, like offering you code suggestions, providing natural language descriptions of a piece of code's functionality and purpose, generating unit tests for your code, and proposing fixes for bugs in your code. For more information, see Asking GitHub Copilot questions in GitHub.
On GitHub, you can use Copilot Chat to ask different questions in different contexts. For example, you can ask about a specific repository, a specific issue, or a specific pull request. You can also ask general questions about software development, or about a specific programming language.
Limitations
The quality of the results from Copilot Chat may, in some situations, be degraded if very large files, or a large number of files, are used as a context for a question.
Viewing and editing generated files within Copilot Chat
Note

This feature is currently in public preview and subject to change.

When you ask a question, Copilot may generate one or more files as part of its response. In the Copilot Chat panel, the files are displayed inline, within the chat response. In immersive view (that is, at https://github.com/copilot), the generated files are displayed in a side panel. You can view and edit the files in the panel, or download them to your computer.
For example, asking Generate a simple calculator using HTML, CSS, and JavaScript may generate multiple files, such as index.html, styles.css, and script.js.
In immersive view, you can also preview how some file formats, such as Markdown, render by toggling to the "Preview" tab in the side panel.
Powered by skills
When using the GPT-4o and Claude Sonnet models, Copilot has access to a collection of skills to fetch data from GitHub, which are dynamically selected based on the question you ask. You can tell which skill Copilot used by clicking  to expand the status information in the chat window.

You can explicitly ask GitHub Copilot Chat in GitHub to use a particular skill - for example, Use the Bing skill to find the latest GPT4 model from OpenAI.
You can generate a list of currently available skills by asking Copilot: What skills are available?
Customizing Copilot Chat responses
GitHub Copilot can provide chat responses that are tailored to the way your team works, the tools you use, the specifics of your project, or your personal preferences, if you provide it with enough context to do so. Instead of repeating instructions in each prompt, you can create and save instructions for Copilot Chat to customize what responses you receive.
There are two types of custom instructions you can add for Copilot Chat:

Repository instructions: You can create a custom instructions file for a repository, so that all prompts asked in the context of the repository automatically include the instructions you've defined
Personal instructions: You can add personal instructions so that all the chat responses you, as a user, receive are tailored to your preferences

For more information, see Adding repository custom instructions for GitHub Copilot and Adding personal custom instructions for GitHub Copilot.
AI models for Copilot Chat
You can change the large language model that Copilot uses to generate responses to chat prompts, including premium models with advanced capabilities. You may find that different models perform better, or provide more useful responses, depending on the type of questions you ask. For more information see Changing the AI model for Copilot Chat.
Submitting a question to Copilot Chat
You can open Copilot Chat from any page on GitHub. Certain questions may require you to be in a specific context, such as a repository, issue, or pull request. The following procedure describes how to ask a general software related question, and demonstrates the core functionality of Copilot Chat on GitHub. For more information on other scenarios, see Asking Copilot Chat questions in different contexts.
Depending on the question you ask, and your enterprise and organization settings, Copilot may respond using information based on the results of a Bing search. By using Bing search, Copilot can answer a broad range of tech-related questions with up-to-date details based on information currently available on the internet. For information on how to enable or disable Bing search integration, see Managing Copilot policies as an individual subscriber and Managing policies and features for Copilot in your enterprise.


At the top right of any page on GitHub, click  beside the  icon and click Immersive in the dropdown menu.



At the bottom of the page, in the "Ask Copilot" box, type a question and press Enter.
Some examples of general questions you could ask are:

What are the advantages of the Go programming language?
What is Agile software development?
What is the most popular JavaScript framework?
Give me some examples of regular expressions.
Write a bash script to output today's date.



Optionally, after submitting a question, you can click  in the text box to stop the response.


If Copilot uses a Bing search to answer your question, "Using web search results for 'SEARCH QUERY'" is displayed above the response. Click this to see the search results that Copilot used to answer your question.


Within a conversation thread, you can ask follow-up questions. Copilot will answer within the context of the conversation. For example, you could type "tell me more" to get Copilot to expand on its last comment.
You can use your initial question as a foundation for follow-up questions. A detailed foundational prompt can help Copilot provide more relevant answers to your follow-up questions. For more information, see Prompting GitHub Copilot Chat to become your personal AI assistant for accessibility on the GitHub Blog.


To start a new conversation, click  at the top left of the page.


To see a list of your previous conversations, click  at the top left of the page.


Regenerating a response with a different model
Note

This feature is currently in public preview and is subject to change.

After Copilot responds to your question, you can regenerate the same prompt using a different model by clicking the retry icon () below the response. The new response will use your selected model and maintain the full context of the conversation.
You can switch between responses to compare the results from different models.
For help deciding which model to use, see Choosing the right AI model for your task.
Using subthreads in a conversation
Note

Subthreading in Copilot Chat is currently in public preview and is subject to change.

Subthreads are branches of a conversation that are created from a point in a conversation where you asked a question. Subthreads offer more control and flexibility for exploring aspects of a topic, or new topics, all within the same thread.
You can create and navigate through subthreads in Copilot Chat's immersive view. In the Copilot Chat panel, if you open a conversation that contains subthreads, only the most recently edited subthread is displayed.
You can create a subthread in immersive mode by either editing or retrying any of your questions in the conversation.
To edit a question:


Hover over the question you want to edit.


Click the  button that's displayed.



Edit the question, then click Send.


Note

You can only edit the text of a question. You can't edit any attachments.

To retry a question:


Hover over the response to a question you want to retry. Resubmitting a question to Copilot may generate a different response.


Click the  button.



The response to your edited or retried question is displayed in a new subthread.
To navigate between subthreads:


If you have retried a question, a retry counter is displayed under the response, alongside the retry button.

Click  or  to navigate to the previous or next subthread.


If you have edited a question, an edit counter is added below the question.

Hover over the counter to display the edit and navigation buttons, then click  or  to navigate to the previous or next subthread.


Asking Copilot Chat questions in different contexts
You can ask Copilot Chat different types of questions depending on where you are on GitHub. For example, to ask a question about a specific repository, you must be in the context of that repository. The following sections describe how to access the different contexts.
For examples of the types of questions you can ask in different contexts, see Getting started with prompts for Copilot Chat.
Asking Copilot Chat questions in a repository
To ask a question about a specific repository, you must be viewing the repository on GitHub.


Navigate to a repository on GitHub.


At the top right of the page, click the  GitHub Copilot icon next to the search bar.
Copilot Chat will open a new conversation, with the repository you are viewing selected as the context for your question.



At the bottom of the panel, in the "Ask Copilot" box, type a question and press Enter.
Note

Copilot's ability to answer natural language questions in a repository context is improved when the repository has been indexed for semantic code search. The indexing status of the repository is displayed when you start a conversation that has a repository context. For more information, see Indexing repositories for Copilot Chat.



Asking Copilot Chat questions about a specific file or symbol
You can ask Copilot about a specific file, folder, or symbol within a repository.
Note
 A "symbol" is a named entity in code. This could be a variable, function, class, module, or any other identifier that's part of a codebase.



At the top right of the page, click the  GitHub Copilot icon next to the search bar.


To select a repository for context, click  at the bottom of the chat panel, then select "Repositories".



Once the repository has been attached, click  again, then select "Files, folders, and symbols".


Search for and select one or more files, folders, or symbols.


In the "Ask Copilot" box, type a question and press Enter.
Copilot replies in the chat panel.
Tip

Copilot's ability to answer natural language questions like these in a repository context is optimized when the semantic code search index for the repository is up to date. For more information, see Indexing repositories for Copilot Chat.



Asking Copilot Chat questions about specific pieces of code
You can chat with Copilot about a file in your repository, or about specific lines of code within a file.


On GitHub, navigate to a repository and open a file.


Do one of the following:


To ask a question about the entire file, click the Copilot icon () at the top right of the file view.



To ask a question about specific lines within the file:

Select the lines by clicking the line number for the first line you want to select, holding down Shift and clicking the line number for the last line you want to select.
To ask your own question about the selected lines, click the Copilot icon () to the right of your selection.
This displays the GitHub Copilot Chat panel with the selected lines indicated as the context of your question.
To ask a predefined question, click the downward-pointing button beside the Copilot icon, then choose one of the options.






If you clicked the Copilot icon, type a question in the "Ask Copilot" box at the bottom of the chat panel and press Enter.
Copilot responds to your request in the panel.



Asking questions about alerts from GitHub Advanced Security products
Copilot allows you to use natural language questions to ask about security alerts in repositories in your organization when these alerts are generated by GitHub Advanced Security features (code scanning, secret scanning, and Dependabot alerts).


At the top right of any page on GitHub, click  beside the  icon and click Immersive in the dropdown menu.



To select a repository for context, click  at the bottom of the chat panel, then select "Repositories".



In the "Search repositories" box, type the name of the repository you want to ask about, then click the repository in the list of search results.


In the "Ask Copilot" box, type a question and press Enter.

Tip

Copilot's ability to answer natural language questions like these in a repository context is optimized when the semantic code search index for the repository is up to date. For more information, see Indexing repositories for Copilot Chat.



Asking questions about a specific pull request
You can ask Copilot different questions about a pull request, from different views within the pull request. For example, you can ask Copilot to summarize a pull request, or explain what has changed within specific files or lines of code in a pull request.
Get a summary of a pull request

On GitHub, navigate to a pull request in a repository.
At the top right of the page, click the  GitHub Copilot icon next to the search bar.
If the panel contains a previous conversation you had with Copilot, click the  plus sign icon at the top right of the Copilot panel to start a new conversation.
At the bottom of the Copilot Chat panel, in the "Ask Copilot" box, type a question and press Enter.

Ask about changes to a specific file in a pull request

On GitHub, navigate to a pull request in a repository.
Click the Files changed tab.
Click  at the top right of the file, then click Ask Copilot about this diff.
Type a question in the "Ask Copilot" box at the bottom of the chat panel and press Enter.

Ask about specific lines within a file in a pull request

On GitHub, navigate to a pull request in a repository.
Click the Files changed tab.
Click the line number for the first line you want to select, then hold down Shift and click the line number for the last line you want to select.
Ask Copilot a question, or choose from a list of predefined questions.

To ask your own question about the selected lines, to the right of your selection, click the  Copilot icon.
This displays the GitHub Copilot Chat panel with the selected lines indicated as the context of your question.



Ask why a workflow has failed

On GitHub, navigate to a pull request in a repository.
Scroll to the bottom of the page, then, next to one of the failing checks, click Details.
At the top right of the page, click the  GitHub Copilot icon next to the search bar.
If the panel contains a previous conversation you had with Copilot, click the  plus sign icon at the top right of the Copilot panel to start a new conversation.
At the bottom of the Copilot Chat panel, in the "Ask Copilot" box, ask Copilot why the pull request has failed and press Enter.

Copilot will respond with information about why the pull request failed. Copilot may also provide suggestions for how to fix the issue.

If Copilot has provided steps to fix the issue, you can follow the steps to resolve the problem.

Asking a question about a specific issue or discussion
You can ask Copilot to summarize or answer questions about a specific issue or discussion.
Note
 The quality of Copilot Chat's responses may be degraded when working with issues or discussions that have very long bodies or a large number of comments. For example, this may occur if you ask Copilot to summarize a long-running discussion. Where this happens, Copilot will warn you so you can double check its output.



Navigate to an issue or discussion on GitHub.


At the top right of the page, click the  GitHub Copilot icon next to the search bar.


If the panel contains a previous conversation you had with Copilot, click the  plus sign icon at the top right of the Copilot panel to start a new conversation.


At the bottom of the Copilot chat panel, in the "Ask Copilot" box, type a question and press Enter.
Copilot responds to your request in the panel.
Tip
 Instead of navigating to an issue or discussion in your browser to ask a question, you can include the relevant URL in your message. For example, Summarize https://github.com/monalisa/octokit/issues/1.



Asking a question about a specific commit
You can ask Copilot to explain the changes in a commit.


Navigate to a commit on GitHub.


At the top right of the page, click the  GitHub Copilot icon next to the search bar.


If the panel contains a previous conversation you had with Copilot, click the  plus sign icon at the top right of the Copilot panel to start a new conversation.


At the bottom of the Copilot chat panel, in the "Ask Copilot" box, type a question and press Enter.
Tip

If you know the SHA for a commit, instead of navigating to the commit, you can ask Copilot about the commit from any page in the repository on GitHub by including the SHA in your message. For example, What changed in commit a778e0eab?



Optionally, after submitting a question, you can click  in the text box to stop the response.


Using images in Copilot Chat
Note


Attaching images to chat prompts is currently in public preview and is subject to change.
You can only attach an image in the immersive view of Copilot Chat (https://github.com/copilot), not in the chat panel.


You can attach an image to Copilot and then ask about the image. For example, you can attach:

A screenshot of a code snippet and ask Copilot to explain the code.
A mockup of the user interface for an application and ask Copilot to generate the code.
A flowchart and ask Copilot to describe the processes shown in the image.
A screenshot of a web page and ask Copilot to generate HTML for a similar page.

Note

The following types of image file are supported: JPEG (.jpg, .jpeg), PNG (.png), GIF (.gif), or WEBP (.webp).

Attaching an image to your chat prompt


Go to the immersive view of Copilot Chat (https://github.com/copilot).


If you see the AI model picker at the top of the page, select one of the models that supports adding images to prompts:

GPT-4o (the default that's used if you don't see a model picker)
Claude 3.5 Sonnet
Claude 3.7 Sonnet
Gemini 2.0 Flash
Gemini 2.5 Pro




Do one of the following:

Copy an image and paste it into the prompt box at the bottom of the page.
Click  in the prompt box, then click Image. Browse to the image file you want to attach, select it and click Open.
Drag and drop an image file from your operating system's file explorer into the prompt box.



Type your prompt into the chat view to accompany the image. For example, explain this diagram, describe each of these images in detail, what does this error message mean.


Accessing Copilot Chat from the search bar
You can ask Copilot a question about an entire repository by typing your question in the main search box of the repository.


Navigate to a repository on GitHub.


Press /, or click in the main search box at the top of the page.


In the search box, after repo:OWNER/REPO, type the question you want to ask Copilot.
For example, you could enter:

What does this repo do?
Where is authentication implemented in this codebase?
How does license file detection work in this repo?



Click Ask Copilot.

The GitHub Copilot Chat panel is displayed and Copilot responds to your request.


Optionally, after submitting a question, you can click  in the text box to stop the response.


Accessing Copilot Chat from the dashboard
You can access Copilot's immersive view from the dashboard. The dashboard is your personalized overview of your activity on GitHub, seen when you visit https://github.com while logged in.


Go to the dashboard at https://github.com.


In the "Ask Copilot" box, type a question and press Enter.

You will be taken to the immersive view where Copilot will respond to your request.


Extending Copilot Chat in GitHub
GitHub Copilot Extensions integrate the power of external tools into Copilot Chat, helping you reduce context switching and receive responses with domain-specific context. You can install Copilot Extensions from the GitHub Marketplace or build private ones within your organization, then type @ in a chat window to see a list of your available extensions. To use an extension, select the extension from the list or type the full slug name, then type your prompt.
To learn more, see Using extensions to integrate external tools with Copilot Chat.
Sharing Copilot Chat conversations
Note
 This feature is currently in public preview and subject to change. During the public preview, this feature is only available to users without enterprise or team memberships.

You can share Copilot Chat conversations from the immersive view (https://github.com/copilot). Shared conversations are public or private (i.e. permission-based), for example, a conversation about a private repository. If you share a private conversation, the recipient must have the necessary permissions to view the content. Shared conversations are read-only—the recipient can view the conversation but cannot interact.


In the top right of any page on GitHub, click the  GitHub Copilot icon next to the search bar.


To view a conversation in immersive mode, click  Immersive.


Once you submit your first prompt, a share button will appear in the upper right corner. Click  to open the share dialog.



To copy the conversation link, click  Create link. The link is copied to your clipboard.


Sharing feedback about GitHub Copilot Chat in GitHub
Note
 The ability to provide feedback to GitHub about Copilot pull request summaries is dependent on enterprise settings. For more information, see Managing policies and features for Copilot in your enterprise.

To give feedback about a particular Copilot Chat response, click either the thumbs up or thumbs down icon at the bottom of each chat response.
To give feedback about Copilot Chat in general, click the ellipsis (...) at the top right of the chat panel, then click  Give feedback.
Further reading

Asking GitHub Copilot questions in your IDE.
Asking GitHub Copilot questions in GitHub Mobile.\n\n\n\nGitHub Copilot/Copilot Chat CookbookCopilot Chat CookbookFind examples of prompts to use with GitHub Copilot Chat.SpotlightGenerate unit testsCopilot Chat can help with generating unit tests for a function.Improving code readability and maintainabilityLearn how to improve your code readability and maintainability.Debugging invalid JSONCopilot can identify and resolve syntax errors or structural issues in JSON data.Explore 23 prompt articlesCategory: AllComplexity: AllReset filtersDebugging invalid JSONCopilot Chat can identify and resolve syntax errors or structural issues in JSON data.Debugging codeIntermediateHandling API rate limitsCopilot Chat can help handle API  rate limits by suggesting code that detects implements retry logic.Debugging codeIntermediateExploring potential feature implementationsCopilot Chat can help explore different approaches for implementing a single feature.Functionality analysisIntermediateAnalyzing and incorporating user feedbackCopilot Chat can enhance the process of incorporating user feedback into your project.Functionality analysisIntermediateImproving code readability and maintainabilityCopilot Chat can suggest ways to make your code easier to understand and maintain.Refactoring codeSimpleFixing lint errorsCopilot Chat can suggest ways to fix issues identified by a code linter.Refactoring codeIntermediateRefactoring for performance optimizationCopilot Chat can suggest ways to speed up slow-running code.Refactoring codeSimpleRefactoring to implement a design patternCopilot Chat can suggest design patterns that you can use to improve your code.Refactoring codeIntermediateRefactoring data access layersCopilot Chat can suggest ways to decouple your data access code from your business logic, making an application easier to maintain and scale.Refactoring codeAdvancedDecoupling business logic from UI componentsCopilot Chat can help you separate your business logic from your user interface code, making it easier to maintain and scale your application.Refactoring codeAdvancedHandling cross-cutting concernsCopilot Chat can help you avoid code that relates to a concern other than the core concern of the method or function in which the code is located.Refactoring codeIntermediateSimplifying complex inheritance hierarchiesCopilot Chat can help you to refactor code to avoid classes with multiple layers of inheritance.Refactoring codeIntermediateFixing database deadlocks or data integrity issuesCopilot Chat can help you avoid code that causes slow or blocked database operations, or tables with missing or incorrect data.Refactoring codeAdvancedTranslating code to a different programming languageCopilot Chat can help you rewrite code to perform the same operations but in a different programming language.Refactoring codeSimpleDocumenting legacy codeCopilot Chat can help with documenting legacy code.Documenting codeSimpleExplaining legacy codeCopilot Chat can help with explaining unfamiliar code.Documenting codeSimpleExplaining complex algorithms or logicCopilot Chat can help add clear and concise documentation on complex algorithms or logic.Documenting codeIntermediateSyncing documentation with code changesCopilot Chat can help with keeping code documentation up-to-date.Documenting codeIntermediateWriting discussions or blog postsCopilot Chat can help you generate ideas, outline, or draft discussions or blog posts.Documenting codeSimpleGenerate unit testsCopilot Chat can help with generating unit tests for a function.Testing codeIntermediateCreate mock objects to abstract layersCopilot Chat can help with creating mock objects that you can use for unit tests.Testing codeIntermediateCreate end-to-end tests for a webpageCopilot Chat can help with generating end-to-end tests.Testing codeAdvancedFinding existing vulnerabilities in codeCopilot Chat can help find common vulnerabilities in your code and suggest fixes.Security analysisIntermediate\n\n\n\n