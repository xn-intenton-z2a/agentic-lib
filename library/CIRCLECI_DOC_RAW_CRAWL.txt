Welcome to CircleCI DocumentationUse the tutorials, samples, how-to, and reference documentation to learn CircleCI.1Connect your code2Set up a project3Invite your team Examples and guidesGet started in minutes: follow step-by-step guides or explore a sample app.Quickstart guideNodePythonGoHello worldSet up Slack notificationsFeatured ResourcesExecution environmentsRun jobs in Linux, Windows, macOS, Arm, or GPU environments.PipelinesTrigger pipelines from your VCS, API, and the CircleCI app.Deployment ExamplesCreate and configure jobs to deploy to AWS, GCP, and more.Using DockerBuild Docker images and execute your jobs in Docker environments.Third Party IntegrationsEasily integrate third-party tools using certified and partner orbs.SecurityCreate and manage contexts in the CircleCI app.Test splittingUse test splitting to run tests simultaneously across multiple environments to reduce pipeline execution time.OIDCUse OpenID Connect tokens to access compatible cloud services without long-lived credentials being stored in CircleCI.Config policiesCreate organization-level policies to impose rules and scopes to govern the use of configuration elementsDeploysNewView and manage your deployments from a single dashboard. Gain immediate visibility into org wide deployments. No infra access required.Get started with deploysSamples and toolssamplesOpen Source ProjectsSample config.yml FilesDatabase Config ExamplesFull Config ExampleUsing Environment VariablestoolsConfiguration ReferenceCircleCI config SDKWebhooksAPI v2 ReferenceAPI v1 Reference\n\nWelcome to CircleCI DocumentationUse the tutorials, samples, how-to, and reference documentation to learn CircleCI.1Connect your code2Set up a project3Invite your team Examples and guidesGet started in minutes: follow step-by-step guides or explore a sample app.Quickstart guideNodePythonGoHello worldSet up Slack notificationsFeatured ResourcesExecution environmentsRun jobs in Linux, Windows, macOS, Arm, or GPU environments.PipelinesTrigger pipelines from your VCS, API, and the CircleCI app.Deployment ExamplesCreate and configure jobs to deploy to AWS, GCP, and more.Using DockerBuild Docker images and execute your jobs in Docker environments.Third Party IntegrationsEasily integrate third-party tools using certified and partner orbs.SecurityCreate and manage contexts in the CircleCI app.Test splittingUse test splitting to run tests simultaneously across multiple environments to reduce pipeline execution time.OIDCUse OpenID Connect tokens to access compatible cloud services without long-lived credentials being stored in CircleCI.Config policiesCreate organization-level policies to impose rules and scopes to govern the use of configuration elementsDeploysNewView and manage your deployments from a single dashboard. Gain immediate visibility into org wide deployments. No infra access required.Get started with deploysSamples and toolssamplesOpen Source ProjectsSample config.yml FilesDatabase Config ExamplesFull Config ExampleUsing Environment VariablestoolsConfiguration ReferenceCircleCI config SDKWebhooksAPI v2 ReferenceAPI v1 Reference DocsTerms of UsePrivacy PolicyCookie PolicySecurity© 2025 Circle Internet Services, Inc., All Rights Reserved.Welcome to CircleCI DocumentationUse the tutorials, samples, how-to, and reference documentation to learn CircleCI.1Connect your code2Set up a project3Invite your team Examples and guidesGet started in minutes: follow step-by-step guides or explore a sample app.Quickstart guideNodePythonGoHello worldSet up Slack notificationsFeatured ResourcesExecution environmentsRun jobs in Linux, Windows, macOS, Arm, or GPU environments.PipelinesTrigger pipelines from your VCS, API, and the CircleCI app.Deployment ExamplesCreate and configure jobs to deploy to AWS, GCP, and more.Using DockerBuild Docker images and execute your jobs in Docker environments.Third Party IntegrationsEasily integrate third-party tools using certified and partner orbs.SecurityCreate and manage contexts in the CircleCI app.Test splittingUse test splitting to run tests simultaneously across multiple environments to reduce pipeline execution time.OIDCUse OpenID Connect tokens to access compatible cloud services without long-lived credentials being stored in CircleCI.Config policiesCreate organization-level policies to impose rules and scopes to govern the use of configuration elementsDeploysNewView and manage your deployments from a single dashboard. Gain immediate visibility into org wide deployments. No infra access required.Get started with deploysSamples and toolssamplesOpen Source ProjectsSample config.yml FilesDatabase Config ExamplesFull Config ExampleUsing Environment VariablestoolsConfiguration ReferenceCircleCI config SDKWebhooksAPI v2 ReferenceAPI v1 Reference\n\nWelcome to CircleCI DocumentationUse the tutorials, samples, how-to, and reference documentation to learn CircleCI.1Connect your code2Set up a project3Invite your team Examples and guidesGet started in minutes: follow step-by-step guides or explore a sample app.Quickstart guideNodePythonGoHello worldSet up Slack notificationsFeatured ResourcesExecution environmentsRun jobs in Linux, Windows, macOS, Arm, or GPU environments.PipelinesTrigger pipelines from your VCS, API, and the CircleCI app.Deployment ExamplesCreate and configure jobs to deploy to AWS, GCP, and more.Using DockerBuild Docker images and execute your jobs in Docker environments.Third Party IntegrationsEasily integrate third-party tools using certified and partner orbs.SecurityCreate and manage contexts in the CircleCI app.Test splittingUse test splitting to run tests simultaneously across multiple environments to reduce pipeline execution time.OIDCUse OpenID Connect tokens to access compatible cloud services without long-lived credentials being stored in CircleCI.Config policiesCreate organization-level policies to impose rules and scopes to govern the use of configuration elementsDeploysNewView and manage your deployments from a single dashboard. Gain immediate visibility into org wide deployments. No infra access required.Get started with deploysSamples and toolssamplesOpen Source ProjectsSample config.yml FilesDatabase Config ExamplesFull Config ExampleUsing Environment VariablestoolsConfiguration ReferenceCircleCI config SDKWebhooksAPI v2 ReferenceAPI v1 Reference\n\n\n\n\n\nWelcome to CircleCICircleCI is the software delivery engine for teams who want to ship software faster, using code that’s reusable and easy to maintain. Get StartedSign Up for FreeLearn CircleCIGetting StartedConfigurationToolsWhat's NewAI projects5-minute quickstart guideA step-by-step guide to set up your first CircleCI project, in minutes.onboardingFree on-demand coursesWe recommend new users start with our General Developer Training course.learningLanguage guidesFind examples based on your favorite programming language.how toConfiguration introductionFollow this guide to learn about the core of the CircleCI experience - config.yml.onboardingSample configurationsDon’t start from scratch. Copy and paste a sample .circleci/config.yml file.samplesConfiguration referenceFind a full config.yml example and a list of all configuration keys.referenceOrbs introductionLearn how orbs can help your team automate code and integrate quickly.orbsCircleCI VS Code extensionManage your pipelines and get help writing config. in the IDE.toolsCircleCI Command Line InterfaceAccess advanced tools through the local terminal.toolsReleases UI in open previewView and manage your releases from a single dashboard.featureConfig policies soft failsImproved visibility of config policies with soft fail notifications now on the pipelines dashboard.featureInbound webhooksTrigger pipelines from anywhere that can emit a webhook or curl command.featureOrchestrate model deploymentThe new Amazon SageMaker orb ensures zero downtime releases across environments.How toIntegrate your AI pipelinesTrigger CI pipelines on model, dataset and prompt changes with inbound webhooks.How toTest non-deterministic featuresFind out how to automate evaluation of LLM-based applications in your CI pipeline.LearningOrbs: reusable configurationAutomate your manual tasksOrbs are CircleCI’s package manager. They’re shareable across teams, making it easy to keep your configuration up-to-date and in-sync.POPULAR ORBSInsights: performance metricsSave time and moneyUse the CircleCI Insights dashboard to evaluate the overall health of your pipelines and find ways to speed up builds.MONITOR SPEED AND SPENDHelpful Resources3 NewNew featuresTrack our platform changes. Stay up to date with the latest in CI.newIntegrationsIntegrate your DevOps processes using orbs and our API.integrationsLanguage guidesGet help building the language & framework your app is written in.guidesWebhooksCreate customizable integrations with workflow and job events.integrations\n\nWelcome to CircleCICircleCI is the software delivery engine for teams who want to ship software faster, using code that’s reusable and easy to maintain. Get StartedSign Up for FreeLearn CircleCIGetting StartedConfigurationToolsWhat's NewAI projects5-minute quickstart guideA step-by-step guide to set up your first CircleCI project, in minutes.onboardingFree on-demand coursesWe recommend new users start with our General Developer Training course.learningLanguage guidesFind examples based on your favorite programming language.how toConfiguration introductionFollow this guide to learn about the core of the CircleCI experience - config.yml.onboardingSample configurationsDon’t start from scratch. Copy and paste a sample .circleci/config.yml file.samplesConfiguration referenceFind a full config.yml example and a list of all configuration keys.referenceOrbs introductionLearn how orbs can help your team automate code and integrate quickly.orbsCircleCI VS Code extensionManage your pipelines and get help writing config. in the IDE.toolsCircleCI Command Line InterfaceAccess advanced tools through the local terminal.toolsReleases UI in open previewView and manage your releases from a single dashboard.featureConfig policies soft failsImproved visibility of config policies with soft fail notifications now on the pipelines dashboard.featureInbound webhooksTrigger pipelines from anywhere that can emit a webhook or curl command.featureOrchestrate model deploymentThe new Amazon SageMaker orb ensures zero downtime releases across environments.How toIntegrate your AI pipelinesTrigger CI pipelines on model, dataset and prompt changes with inbound webhooks.How toTest non-deterministic featuresFind out how to automate evaluation of LLM-based applications in your CI pipeline.LearningOrbs: reusable configurationAutomate your manual tasksOrbs are CircleCI’s package manager. They’re shareable across teams, making it easy to keep your configuration up-to-date and in-sync.POPULAR ORBSInsights: performance metricsSave time and moneyUse the CircleCI Insights dashboard to evaluate the overall health of your pipelines and find ways to speed up builds.MONITOR SPEED AND SPENDHelpful Resources3 NewNew featuresTrack our platform changes. Stay up to date with the latest in CI.newIntegrationsIntegrate your DevOps processes using orbs and our API.integrationsLanguage guidesGet help building the language & framework your app is written in.guidesWebhooksCreate customizable integrations with workflow and job events.integrations\n\n\n\nOrbsOrbs are shareable packages of CircleCI configuration you can use to simplify your builds. Choose from the many partner, community, or CircleCI authored orbs in our public registry below, or create a private orb that’s exclusive to your organization.Read documentationNewly published orbs may not appear on this page for up to 30 minutes.    Search OrbsFilter by Orb TypeAllSelect CategoriesSelect\n\n\n\nImagesCircleCI maintains a fleet of images for various programming languages, databases, and operating systems.Read documentationConvenience Images\n\n\n\nNEW
        
          Actionable insights from 15 million+ datapoints.

        
        
          Get the newsletter 
        
      
    
    
  


  
    
      
        
          
            Confidence in every
            
              
                rollback
              
              
                
                  
                  change
                
              
                
                  
                  release
                
              
                
                  
                  rollback
                
              
                
                  
                  prompt
                
              
                
                  
                  eval
                
              
                
                  
                  deploy
                
              
            
          
          Engineering teams of all sizes use CircleCI to easily build, test, and deploy production-ready code.
          

  
    
    
      
        
        Start building for free
      
    
  
    
    
      
        
        Watch a demo
      
    
  

        
        
          





          
            
          
        
      
    
  
  


  
    
    
      

Trusted by




  
  
  
    
    
    
      
      
      
      
        
          
          Meta
        
      
    
  
    
    
    
      
      
      
      
        
          

          Nextdoor
        
      
    
  
    
    
    
      
      
      
      
        
          
          Adobe
        
      
    
  
    
    
    
      
      
      
      
        
          

          Okta
        
      
    
  
    
    
    
      
      
      
      
        
          
          Hinge
        
      
    
  

    
  


  
    
      
        





      
      
        
        With CircleCI, you can capture every change.
        Focus on your code, and beyond. Trigger automatic tests whenever anything in your ecosystem changes: libraries, images, even LLMs.

        

  
    
    
      
        
        Explore the product
      
    
  

      
    
  
  
    
      Any app, deployed anywhere, at any scale
    
    
      
  
  
    
      
        
          
        
      
      Android
    
  
    
      
        
          
        
      
      Chatbots
    
  
    
      
        
          
        
      
      Robotics
    
  
    
      
        
          
        
      
      AI
    
  
    
      
        
          
        
      
      Mobile
    
  
    
      
        
          
        
      
      Autonomous Vehicles
    
  
    
      
        
          
        
      
      Docker
    
  
    
      
        
          

        
      
      Ruby
    
  
    
      
        
          

        
      
      Heroku
    
  
    
      
        
          
        
      
      Image Recognition
    
  
    
      
        
          
        
      
      Dynamic Web Apps
    
  
    
      
        
          

        
      
      C++
    
  
    
      
        
          
        
      
      MacOS
    
  
    
      
        
          

        
      
      Terraform
    
  
    
      
        
          
        
      
      Wearables
    
  
    
      
        
          
        
      
      Business Intelligence
    
  
    
      
        
          

        
      
      Ansible
    
  
    
      
        
          

        
      
      Python
    
  
    
      
        
          

        
      
      S3
    
  
    
      
        
          
        
      
      Cross-platform
    
  
    
      
        
          
        
      
      AR
    
  
    
      
        
          
        
      
      Health Tech
    
  
    
      
        
          

        
      
      PHP
    
  
    
      
        
          

        
      
      HTML
    
  
    
      
        
          
        
      
      Shell
    
  
    
      
        
          

        
      
      AWS
    
  
    
      
        
          

        
      
      SageMaker
    
  
    
      
        
          
        
      
      Linux
    
  
    
      
        
          

        
      
      Jupyter Notebook
    
  
    
      
        
          

        
      
      Pulumi
    
  
    
      
        
          
        
      
      Windows
    
  
    
      
        
          

        
      
      Elixer
    
  
    
      
        
          

        
      
      Speech recognition
    
  
    
      
        
          
        
      
      Recommendation systems
    
  
    
      
        
          
        
      
      Predictive analytics
    
  
    
      
        
          
        
      
      APIs
    
  
    
      
        
          
        
      
      Databases
    
  
    
      
        
          
        
      
      Container Images
    
  
    
      
        
          
        
      
      VR
    
  
    
      
        
          
        
      
      Natural language processing
    
  
    
      
        
          
        
      
      Single Page Apps
    
  
    
      
        
          
        
      
      Gaming
    
  
    
      
        
          

        
      
      Go
    
  
    
      
        
          

        
      
      Netlify
    
  
  

      
  
  
    
      
        
          

        
      
      Netlify
    
  
    
      
        
          

        
      
      Go
    
  
    
      
        
          
        
      
      Gaming
    
  
    
      
        
          
        
      
      Single Page Apps
    
  
    
      
        
          
        
      
      Natural language processing
    
  
    
      
        
          
        
      
      VR
    
  
    
      
        
          
        
      
      Container Images
    
  
    
      
        
          
        
      
      Databases
    
  
    
      
        
          
        
      
      APIs
    
  
    
      
        
          
        
      
      Predictive analytics
    
  
    
      
        
          
        
      
      Recommendation systems
    
  
    
      
        
          

        
      
      Speech recognition
    
  
    
      
        
          

        
      
      Elixer
    
  
    
      
        
          
        
      
      Windows
    
  
    
      
        
          

        
      
      Pulumi
    
  
    
      
        
          

        
      
      Jupyter Notebook
    
  
    
      
        
          
        
      
      Linux
    
  
    
      
        
          

        
      
      SageMaker
    
  
    
      
        
          

        
      
      AWS
    
  
    
      
        
          
        
      
      Shell
    
  
    
      
        
          

        
      
      HTML
    
  
    
      
        
          

        
      
      PHP
    
  
    
      
        
          
        
      
      Health Tech
    
  
    
      
        
          
        
      
      AR
    
  
    
      
        
          
        
      
      Cross-platform
    
  
    
      
        
          

        
      
      S3
    
  
    
      
        
          

        
      
      Python
    
  
    
      
        
          

        
      
      Ansible
    
  
    
      
        
          
        
      
      Business Intelligence
    
  
    
      
        
          
        
      
      Wearables
    
  
    
      
        
          

        
      
      Terraform
    
  
    
      
        
          
        
      
      MacOS
    
  
    
      
        
          

        
      
      C++
    
  
    
      
        
          
        
      
      Dynamic Web Apps
    
  
    
      
        
          
        
      
      Image Recognition
    
  
    
      
        
          

        
      
      Heroku
    
  
    
      
        
          

        
      
      Ruby
    
  
    
      
        
          
        
      
      Docker
    
  
    
      
        
          
        
      
      Autonomous Vehicles
    
  
    
      
        
          
        
      
      Mobile
    
  
    
      
        
          
        
      
      AI
    
  
    
      
        
          
        
      
      Robotics
    
  
    
      
        
          
        
      
      Chatbots
    
  
    
      
        
          
        
      
      Android
    
  
  

      
  
  
    
      
        
          

        
      
      PHP
    
  
    
      
        
          

        
      
      HTML
    
  
    
      
        
          
        
      
      Shell
    
  
    
      
        
          

        
      
      AWS
    
  
    
      
        
          

        
      
      SageMaker
    
  
    
      
        
          
        
      
      Linux
    
  
    
      
        
          

        
      
      Jupyter Notebook
    
  
    
      
        
          

        
      
      Pulumi
    
  
    
      
        
          
        
      
      Windows
    
  
    
      
        
          

        
      
      Elixer
    
  
    
      
        
          

        
      
      Speech recognition
    
  
    
      
        
          
        
      
      Recommendation systems
    
  
    
      
        
          
        
      
      Predictive analytics
    
  
    
      
        
          
        
      
      APIs
    
  
    
      
        
          
        
      
      Databases
    
  
    
      
        
          
        
      
      Container Images
    
  
    
      
        
          
        
      
      VR
    
  
    
      
        
          
        
      
      Natural language processing
    
  
    
      
        
          
        
      
      Single Page Apps
    
  
    
      
        
          
        
      
      Gaming
    
  
    
      
        
          

        
      
      Go
    
  
    
      
        
          

        
      
      Netlify
    
  
  
    
      
        
          
            
          
        
        Android
      
    
      
        
          
            
          
        
        Chatbots
      
    
      
        
          
            
          
        
        Robotics
      
    
      
        
          
            
          
        
        AI
      
    
      
        
          
            
          
        
        Mobile
      
    
      
        
          
            
          
        
        Autonomous Vehicles
      
    
      
        
          
            
          
        
        Docker
      
    
      
        
          
            

          
        
        Ruby
      
    
      
        
          
            

          
        
        Heroku
      
    
      
        
          
            
          
        
        Image Recognition
      
    
      
        
          
            
          
        
        Dynamic Web Apps
      
    
      
        
          
            

          
        
        C++
      
    
      
        
          
            
          
        
        MacOS
      
    
      
        
          
            

          
        
        Terraform
      
    
      
        
          
            
          
        
        Wearables
      
    
      
        
          
            
          
        
        Business Intelligence
      
    
      
        
          
            

          
        
        Ansible
      
    
      
        
          
            

          
        
        Python
      
    
      
        
          
            

          
        
        S3
      
    
      
        
          
            
          
        
        Cross-platform
      
    
      
        
          
            
          
        
        AR
      
    
      
        
          
            
          
        
        Health Tech
      
    
  

      
  
  
    
      
        
          
        
      
      Health Tech
    
  
    
      
        
          
        
      
      AR
    
  
    
      
        
          
        
      
      Cross-platform
    
  
    
      
        
          

        
      
      S3
    
  
    
      
        
          

        
      
      Python
    
  
    
      
        
          

        
      
      Ansible
    
  
    
      
        
          
        
      
      Business Intelligence
    
  
    
      
        
          
        
      
      Wearables
    
  
    
      
        
          

        
      
      Terraform
    
  
    
      
        
          
        
      
      MacOS
    
  
    
      
        
          

        
      
      C++
    
  
    
      
        
          
        
      
      Dynamic Web Apps
    
  
    
      
        
          
        
      
      Image Recognition
    
  
    
      
        
          

        
      
      Heroku
    
  
    
      
        
          

        
      
      Ruby
    
  
    
      
        
          
        
      
      Docker
    
  
    
      
        
          
        
      
      Autonomous Vehicles
    
  
    
      
        
          
        
      
      Mobile
    
  
    
      
        
          
        
      
      AI
    
  
    
      
        
          
        
      
      Robotics
    
  
    
      
        
          
        
      
      Chatbots
    
  
    
      
        
          
        
      
      Android
    
  
  
    
      
        
          
            

          
        
        Netlify
      
    
      
        
          
            

          
        
        Go
      
    
      
        
          
            
          
        
        Gaming
      
    
      
        
          
            
          
        
        Single Page Apps
      
    
      
        
          
            
          
        
        Natural language processing
      
    
      
        
          
            
          
        
        VR
      
    
      
        
          
            
          
        
        Container Images
      
    
      
        
          
            
          
        
        Databases
      
    
      
        
          
            
          
        
        APIs
      
    
      
        
          
            
          
        
        Predictive analytics
      
    
      
        
          
            
          
        
        Recommendation systems
      
    
      
        
          
            

          
        
        Speech recognition
      
    
      
        
          
            

          
        
        Elixer
      
    
      
        
          
            
          
        
        Windows
      
    
      
        
          
            

          
        
        Pulumi
      
    
      
        
          
            

          
        
        Jupyter Notebook
      
    
      
        
          
            
          
        
        Linux
      
    
      
        
          
            

          
        
        SageMaker
      
    
      
        
          
            

          
        
        AWS
      
    
      
        
          
            
          
        
        Shell
      
    
      
        
          
            

          
        
        HTML
      
    
      
        
          
            

          
        
        PHP
      
    
  

    
  
  
    
      
        
          

        
        
          

        
        
          

        
      
    
    
      

      
        
          
            
          
        
        
          
          Automated testing for every development challenge
          Mobile, web, API, serverless, AI and more: robust CI/CD so you can develop your app with speed and confidence, no matter what you’re building.
        
        
          





        
        
      
    
      

      
        
        
          
          End-to-end visibility from commit to production
          Push updates and debug failures with ease. Progressive delivery lets you monitor changes and roll back to a good state automatically if needed.
        
        
          





        
        
          
            
          
        
      
    
      

      
        
          
            
          
        
        
          
          Automated triggers for every change event
          Respond automatically to changes in your application environment. If it affects your app, you can trigger a pipeline from it on CircleCI.
        
        
          





        
        
      
    
  
  






















  
  
    
      

    
  

  
    
      
        We’re the CI/CD experts (so you don’t have to be)
        Over 50% of customers on CircleCI achieve elite DORA benchmarks.
        

  
    
    
      
        
        Start building for free
      
    
  
    
    
      
        
        Learn more about CircleCI
      
    
  

      
    
  
  
    
      Join 2mil+ devs
      And get that green build feeling
      
        
        
        
          
            
              
              
                






  “The sea change that happened for us over the course of a couple years was removing the fear [of deploying]… It used to be that pushing to production was a really big deal.It’s given people on the executive team and in sales and support more confidence that we can act on information that we get from customers.”
  
    
      





    
    
      Nick Wilson | VP of Technical Operations at GoSpotCheck
    
  

              
            
              
              
                






  “The overall stability of CircleCI is remarkable in comparison to previously used CI providers and other cloud-based development tools.”
  
    
      





    
    
      Adam Renklint | Co-founder and CTO at Pitch
    
  

              
            
              
              
                






  “CircleCI made it easier for us to streamline deployment processes and standardize the way we build, test, and release software.”
  
    
      





    
    
      Lukas Brusokas | Senior AWS Engineer at SaleCycle
    
  

              
            
              
              
                






  “CircleCI enables choice for developers, without spending time on infrastructure.”
  
    
      





    
    
      Steven Reynolds | Principal Engineer at Eventbrite
    
  

              
            
              
              
                






  “CircleCI has enabled us to make DevOps a shared responsibility that can be done by everyone.”
  
    
      





    
    
      Adam Lyons | VP of Engineering at Tanda
    
  

              
            
              
              
                






  “[We’ve] built a powerful system to automatically run security updates… engineers merge the PR, and builds run security updates on all servers.”
  
    
      





    
    
      Toshimasa Ishibashi | Co-founder and CTO at Kaizen Platform
    
  

              
            
              
              
                






  “I set up CI/CD for #ReactNative app this week, I used #CircleCI #Fastlane and connected it to #Firebase Distribution! It works well! Now all tests, builds and code signing are done automatically! #IOS #Android #mobile #ContinuousIntegration #DevOps #FirebaseDistribution”
  
    
      





    
    
      Iryna Kreichmann | @Lucky_girl_____ at Twitter
    
  

              
            
              
              
                






  “It used to be that pushing to production was a really big deal … doing releases more frequently, [has] reduced that fear.”
  
    
      





    
    
      Nick Wilson | VP of Technical Operations at GoSpotCheck
    
  

              
            
              
              
                






  “We are so proud to partner with CircleCI again and deepen our relationship to further support girls and women in STEM,” said Oakland Soul Vice President, Brand Partnerships Andrea Lepore.”
  
    
      





    
    
      Andrea Lepore | Vice President, Brand Partnerships  at Oakland Soul SC
    
  

              
            
              
              
                






  “CircleCI orbs just magically work.”
  
    
      





    
    
      Nicholas Duffy | Engineering Manager at Axios
    
  

              
            
              
              
                






  “Workflows + Docker caching are great with CircleCI.”
  
    
      





    
    
      Josh Dover | Senior Software Engineer at CrateJoy
    
  

              
            
              
              
                






  “CircleCI … [is] critical to making sure we ship code with quality, and it automates all our deployments.”
  
    
      





    
    
      Thomas Groutars | Staff Software Engineer at Maze
    
  

              
            
              
              
                






  “CircleCI enables us to … deliver the best value to our customers with total confidence.”
  
    
      





    
    
      Hemal Shah | Product Manager at fastlane
    
  

              
            
              
              
                






  “There is a growing awareness within the company to introduce CI from the early stages of projects.”
  
    
    
      Tsunashi Iguchi | DeNA
    
  

              
            
              
              
                






  “CircleCI is one of my stress-free tools.”
  
    
      





    
    
      Maksim Pecherskiy  | Chief Data Officer at City of San Diego
    
  

              
            
              
              
                






  “CircleCI helps us pivot more quickly when business priorities shift.”
  
    
      





    
    
      Carlos Villavicencio | Software Developer at Stack Builders
    
  

              
            
              
              
                






  “CircleCI is an essential tool for us.”
  
    
      





    
    
      Yuta Kimura | ANDPAD
    
  

              
            
              
              
                






  “Even on the day of transitioning to production with CircleCI Server version 3, CircleCI was on standby with a video conferencing tool in case any problems arose.”
  
    
      





    
    
      Sodai Kitamura | Data Science and Engineering at LINE
    
  

              
            
              
              
                






  “CircleCI helps us identify the areas that need improvements and quickly address them – developers only have to worry about building the product.”
  
    
      





    
    
      Thomas Groutars | Staff Software Engineer at Maze
    
  

              
            
              
              
                






  “We strive to have at least an 80 percent success rate on all of our projects and CircleCI helps us maintain this average.”
  
    
      





    
    
      Jon Anderson | Senior Software Engineer at Outreach
    
  

              
            
          
        
        
          
            
              
            
              
            
              
            
              
            
              
            
              
            
              
            
              
            
              
            
              
            
              
            
              
            
              
            
              
            
              
            
              
            
              
            
              
            
              
            
              
                
                
                  






  “We strive to have at least an 80 percent success rate on all of our projects and CircleCI helps us maintain this average.”
  
    
      





    
    
      Jon Anderson | Senior Software Engineer at Outreach
    
  

                
              
            
              
                
                
                  






  “There were so many of our customers that were already using orbs and already using CircleCI that their ability to take the orb and adopt it was trivial.”
  
    
      





    
    
      Cory Virok | Co-founder and CTO at Rollbar
    
  

                
              
            
              
                
                
                  






  “CircleCI significantly increased the productivity of the team to be able to ship more features, more confidently, and in less time.”
  
    
      





    
    
      Rawan Moukalled | Senior Front End Engineer at gtlogic
    
  

                
              
            
              
                
                
                  






  “With CircleCI’s features, our team is shifting from ‘keeping the lights on’ to ‘building something new and better.’”
  
    
      





    
    
      Anthony Carr-Smith | Software Development Manager at i2
    
  

                
              
            
              
                
                
                  






  “The integration with GitLab worked flawlessly; it was easy, fast and productive.”
  
    
    
      Yoel Astanovsky | Software Engineer at Moneytor
    
  

                
              
            
              
                
                
                  






  “CircleCI’s default mode was a game changer for us … some of our processes have improved from nearly 24 hours to 1 hour!”
  
    
      





    
    
      Anthony Carr-Smith | Software Development Manager at i2
    
  

                
              
            
              
                
                
                  






  “Switching to CircleCI has allowed our engineers to build and release mobile and web projects with far greater simplicity, speed and performance.”
  
    
      





    
    
      Matt Wise | Senior Systems Architect at Nextdoor
    
  

                
              
            
              
                
                
                  






  “The rise of GenAI is putting pressure on developers to test more frequently because every single application needs to be up and running at 100%, making effective CI/CD essential.”
  
    
      





    
    
      Xavier Portilla Edo | Infrastructure Team Lead at Voiceflow
    
  

                
              
            
              
                
                
                  






  “CircleCI connects our processes and pipelines and brings visibility into our coding environment, offering efficiency and rapid, high performance.”
  
    
      





    
    
      Valentin Ranshakov | QA Lead at Klara
    
  

                
              
            
              
                
                
                  






  “Having a partner like CircleCI that is consistent and reliable enables us to not only deliver the best value to our customers, but deliver it with total confidence.”
  
    
      





    
    
      Hemal Shah | Product Manager at fastlane
    
  

                
              
            
              
                
                
                  






  “Before CircleCI, it would take us an hour and 40 minutes to deploy — currently, it takes us 10 minutes.”
  
    
      





    
    
      Fergus McDonald | Senior Site Reliability Engineer at Procurify
    
  

                
              
            
              
                
                
                  






  “The previous CI/CD tool required manual deployments.”
  
    
      





    
    
      Seiichi Sato | Lead Engineer at Bandai Namco Studios
    
  

                
              
            
              
                
                
                  






  “We’ve reduced the time needed to manage CI/CD infrastructure, while we deliver new projects with high confidence.”
  
    
      





    
    
      Austin Brown | DevOps Engineer at Ground X
    
  

                
              
            
              
                
                
                  






  “CircleCI has significantly simplified setup and maintenance of our test environment and this allows us to run and maintain a stable test suite increasing the team’s confidence in the test results.”
  
    
      





    
    
      Jason Bosco | VP of Engineering at Dollar Shave Club
    
  

                
              
            
              
                
                
                  






  “We can still allow developers to do custom work if they want to, when they want to; developers are in complete control.”
  
    
      





    
    
      Steven Reynolds | Principal Engineer at Eventbrite
    
  

                
              
            
              
                
                
                  






  “With CircleCI our testing and deployments are running at about two minutes.”
  
    
      





    
    
      Sojin Park | Frontend Developer at Toss
    
  

                
              
            
              
                
                
                  






  “CircleCI helped us improve build system simplicity and stability, which reduced the support requests from our teams by 90%.”
  
    
      





    
    
      Matic Miklavčič | DevOps Engineer at Outfit7
    
  

                
              
            
              
                
                
                  






  “Our growth and the offering we provide our clients are simply much better with CircleCI than without it.”
  
    
      





    
    
      Adam Nowak | Software Development Practice Lead at Netguru
    
  

                
              
            
              
                
                
                  






  “With CircleCI, things can move through the release process more quickly.”
  
    
      





    
    
      Josh Bazemore | Engineering Manager at Greenhouse
    
  

                
              
            
              
                
                
                  






  “Of all the solutions we tried, I think CircleCI still provides the best caching flow.”
  
    
      





    
    
      Denis Prysukhin | Co-founder and CTO at Corewide
    
  

                
              
            
              
                
                
                  






  “Before switching to CircleCI, [the] team waited up to an hour to get through testing.”
  
    
      





    
    
      Adam Nowak | Software Development Practice Lead at Netguru
    
  

                
              
            
          
        
        
        
      
    
  
  

  
    
      Learn more
      

  Previous
  
  Next

    
  
  
    
      
        
        
          
            
            
          
          
            
              Report
              2024 State of Software Delivery
            
            Learn more
          
        
      
        
        
          
            
            
          
          
            
              Tutorial
              CircleCI onboarding toolkit
            
            Learn more
          
        
      
        
        
          
            
            
          
          
            
              Blog post
              CircleCI delivers 664% ROI
            
            Learn more
          
        
      
    
  



    




  




  
  

  
  
    
      
        NEW
        
          Actionable insights from 15 million+ datapoints.

        
        
          Get the newsletter 
        
      
    
    
  


  







  
    
      Manage your deploys from one dashboard
      
        
          Gain immediate visibility into org wide deployments; no infra access required.

        
      
      
        

  
    
    
      
        
        Learn more
      
    
  

      
    
    
      
        
          

        

        
          





          
        
      
    
  



  
    
      
        

      
      
        
        
          
            
              New
            
            Expanded support for AI-enabled applications
            New resource classes, model deployment, custom triggers along with tips for testing your LLMs in the CI.
            


Learn more 

          
          
            
          
        
          
            
              New
            
            Monitor soft fails from your config policies
            Improved visibility of config policies for all your organization with soft fails notification by pipeline in your dashboard.
            


Review changelog 

          
          
            
          
        
          
            
              New
            
            Machine Runner 3.0 released
            Enabling faster feature enhancements, improved usability, and easier setup. Check our documentation to upgrade.
            


Learn more 

          
          
        
      
    
    
    
  
  
  
  
    
    
    
    
      
        
          
            Changelog
          
          
            Keep up with the latest releases
          
          


Go to our changelog 

        
        
          
            
            
              
              
                April 16, 2025
                
                  
                    MCP Server Updated w/ Config Validation and Flaky Test Detection
                  
                
              
              
            
              
              
                April 11, 2025
                
                  
                    Server Release 4.7.3
                  
                
              
              
            
              
              
                April 09, 2025
                
                  
                    MCP Server for CircleCI now available
                  
                
              
              
            
              
              
                April 09, 2025
                
                  
                    Changes to dropdown options in "Add trigger" and "Add pipeline" forms
                  
                
              
              
            
              
              
                April 09, 2025
                
                  
                    Update - Breaking Change- April 28th 2025 - Skipped Status Will Now Return Success 
                  
                
              
              
            
          
        
      
      
      
    
  
  






















  
  
    
      

    
  

  
    
      
        
          
            
          
          
            Product Roadmap
          
        
        
          Discover what's around the corner in CircleCI's product roadmap. Our teams are working on exciting new features to help you ship faster and securely.
        
        
        


Check out CircleCI’s roadmap 

      
      
      
        
          
            
          
          
            Key milestones
          
        
        
          A look back at CircleCI’s key milestones, from our marquee releases to press moments, and everything in between.
        
        
        
        


View CircleCI’s milestones\n\nNEW
        
          Actionable insights from 15 million+ datapoints.

        
        
          Get the newsletter 
        
      
    
    
  


  
    
      
        
          
            Confidence in every
            
              
                rollback
              
              
                
                  
                  change
                
              
                
                  
                  release
                
              
                
                  
                  rollback
                
              
                
                  
                  prompt
                
              
                
                  
                  eval
                
              
                
                  
                  deploy
                
              
            
          
          Engineering teams of all sizes use CircleCI to easily build, test, and deploy production-ready code.
          

  
    
    
      
        
        Start building for free
      
    
  
    
    
      
        
        Watch a demo
      
    
  

        
        
          





          
            
          
        
      
    
  
  


  
    
    
      

Trusted by




  
  
  
    
    
    
      
      
      
      
        
          
          Meta
        
      
    
  
    
    
    
      
      
      
      
        
          

          Nextdoor
        
      
    
  
    
    
    
      
      
      
      
        
          
          Adobe
        
      
    
  
    
    
    
      
      
      
      
        
          

          Okta
        
      
    
  
    
    
    
      
      
      
      
        
          
          Hinge
        
      
    
  

    
  


  
    
      
        





      
      
        
        With CircleCI, you can capture every change.
        Focus on your code, and beyond. Trigger automatic tests whenever anything in your ecosystem changes: libraries, images, even LLMs.

        

  
    
    
      
        
        Explore the product
      
    
  

      
    
  
  
    
      Any app, deployed anywhere, at any scale
    
    
      
  
  
    
      
        
          
        
      
      Android
    
  
    
      
        
          
        
      
      Chatbots
    
  
    
      
        
          
        
      
      Robotics
    
  
    
      
        
          
        
      
      AI
    
  
    
      
        
          
        
      
      Mobile
    
  
    
      
        
          
        
      
      Autonomous Vehicles
    
  
    
      
        
          
        
      
      Docker
    
  
    
      
        
          

        
      
      Ruby
    
  
    
      
        
          

        
      
      Heroku
    
  
    
      
        
          
        
      
      Image Recognition
    
  
    
      
        
          
        
      
      Dynamic Web Apps
    
  
    
      
        
          

        
      
      C++
    
  
    
      
        
          
        
      
      MacOS
    
  
    
      
        
          

        
      
      Terraform
    
  
    
      
        
          
        
      
      Wearables
    
  
    
      
        
          
        
      
      Business Intelligence
    
  
    
      
        
          

        
      
      Ansible
    
  
    
      
        
          

        
      
      Python
    
  
    
      
        
          

        
      
      S3
    
  
    
      
        
          
        
      
      Cross-platform
    
  
    
      
        
          
        
      
      AR
    
  
    
      
        
          
        
      
      Health Tech
    
  
    
      
        
          

        
      
      PHP
    
  
    
      
        
          

        
      
      HTML
    
  
    
      
        
          
        
      
      Shell
    
  
    
      
        
          

        
      
      AWS
    
  
    
      
        
          

        
      
      SageMaker
    
  
    
      
        
          
        
      
      Linux
    
  
    
      
        
          

        
      
      Jupyter Notebook
    
  
    
      
        
          

        
      
      Pulumi
    
  
    
      
        
          
        
      
      Windows
    
  
    
      
        
          

        
      
      Elixer
    
  
    
      
        
          

        
      
      Speech recognition
    
  
    
      
        
          
        
      
      Recommendation systems
    
  
    
      
        
          
        
      
      Predictive analytics
    
  
    
      
        
          
        
      
      APIs
    
  
    
      
        
          
        
      
      Databases
    
  
    
      
        
          
        
      
      Container Images
    
  
    
      
        
          
        
      
      VR
    
  
    
      
        
          
        
      
      Natural language processing
    
  
    
      
        
          
        
      
      Single Page Apps
    
  
    
      
        
          
        
      
      Gaming
    
  
    
      
        
          

        
      
      Go
    
  
    
      
        
          

        
      
      Netlify
    
  
  

      
  
  
    
      
        
          

        
      
      Netlify
    
  
    
      
        
          

        
      
      Go
    
  
    
      
        
          
        
      
      Gaming
    
  
    
      
        
          
        
      
      Single Page Apps
    
  
    
      
        
          
        
      
      Natural language processing
    
  
    
      
        
          
        
      
      VR
    
  
    
      
        
          
        
      
      Container Images
    
  
    
      
        
          
        
      
      Databases
    
  
    
      
        
          
        
      
      APIs
    
  
    
      
        
          
        
      
      Predictive analytics
    
  
    
      
        
          
        
      
      Recommendation systems
    
  
    
      
        
          

        
      
      Speech recognition
    
  
    
      
        
          

        
      
      Elixer
    
  
    
      
        
          
        
      
      Windows
    
  
    
      
        
          

        
      
      Pulumi
    
  
    
      
        
          

        
      
      Jupyter Notebook
    
  
    
      
        
          
        
      
      Linux
    
  
    
      
        
          

        
      
      SageMaker
    
  
    
      
        
          

        
      
      AWS
    
  
    
      
        
          
        
      
      Shell
    
  
    
      
        
          

        
      
      HTML
    
  
    
      
        
          

        
      
      PHP
    
  
    
      
        
          
        
      
      Health Tech
    
  
    
      
        
          
        
      
      AR
    
  
    
      
        
          
        
      
      Cross-platform
    
  
    
      
        
          

        
      
      S3
    
  
    
      
        
          

        
      
      Python
    
  
    
      
        
          

        
      
      Ansible
    
  
    
      
        
          
        
      
      Business Intelligence
    
  
    
      
        
          
        
      
      Wearables
    
  
    
      
        
          

        
      
      Terraform
    
  
    
      
        
          
        
      
      MacOS
    
  
    
      
        
          

        
      
      C++
    
  
    
      
        
          
        
      
      Dynamic Web Apps
    
  
    
      
        
          
        
      
      Image Recognition
    
  
    
      
        
          

        
      
      Heroku
    
  
    
      
        
          

        
      
      Ruby
    
  
    
      
        
          
        
      
      Docker
    
  
    
      
        
          
        
      
      Autonomous Vehicles
    
  
    
      
        
          
        
      
      Mobile
    
  
    
      
        
          
        
      
      AI
    
  
    
      
        
          
        
      
      Robotics
    
  
    
      
        
          
        
      
      Chatbots
    
  
    
      
        
          
        
      
      Android
    
  
  

      
  
  
    
      
        
          

        
      
      PHP
    
  
    
      
        
          

        
      
      HTML
    
  
    
      
        
          
        
      
      Shell
    
  
    
      
        
          

        
      
      AWS
    
  
    
      
        
          

        
      
      SageMaker
    
  
    
      
        
          
        
      
      Linux
    
  
    
      
        
          

        
      
      Jupyter Notebook
    
  
    
      
        
          

        
      
      Pulumi
    
  
    
      
        
          
        
      
      Windows
    
  
    
      
        
          

        
      
      Elixer
    
  
    
      
        
          

        
      
      Speech recognition
    
  
    
      
        
          
        
      
      Recommendation systems
    
  
    
      
        
          
        
      
      Predictive analytics
    
  
    
      
        
          
        
      
      APIs
    
  
    
      
        
          
        
      
      Databases
    
  
    
      
        
          
        
      
      Container Images
    
  
    
      
        
          
        
      
      VR
    
  
    
      
        
          
        
      
      Natural language processing
    
  
    
      
        
          
        
      
      Single Page Apps
    
  
    
      
        
          
        
      
      Gaming
    
  
    
      
        
          

        
      
      Go
    
  
    
      
        
          

        
      
      Netlify
    
  
  
    
      
        
          
            
          
        
        Android
      
    
      
        
          
            
          
        
        Chatbots
      
    
      
        
          
            
          
        
        Robotics
      
    
      
        
          
            
          
        
        AI
      
    
      
        
          
            
          
        
        Mobile
      
    
      
        
          
            
          
        
        Autonomous Vehicles
      
    
      
        
          
            
          
        
        Docker
      
    
      
        
          
            

          
        
        Ruby
      
    
      
        
          
            

          
        
        Heroku
      
    
      
        
          
            
          
        
        Image Recognition
      
    
      
        
          
            
          
        
        Dynamic Web Apps
      
    
      
        
          
            

          
        
        C++
      
    
      
        
          
            
          
        
        MacOS
      
    
      
        
          
            

          
        
        Terraform
      
    
      
        
          
            
          
        
        Wearables
      
    
      
        
          
            
          
        
        Business Intelligence
      
    
      
        
          
            

          
        
        Ansible
      
    
      
        
          
            

          
        
        Python
      
    
      
        
          
            

          
        
        S3
      
    
      
        
          
            
          
        
        Cross-platform
      
    
      
        
          
            
          
        
        AR
      
    
      
        
          
            
          
        
        Health Tech
      
    
  

      
  
  
    
      
        
          
        
      
      Health Tech
    
  
    
      
        
          
        
      
      AR
    
  
    
      
        
          
        
      
      Cross-platform
    
  
    
      
        
          

        
      
      S3
    
  
    
      
        
          

        
      
      Python
    
  
    
      
        
          

        
      
      Ansible
    
  
    
      
        
          
        
      
      Business Intelligence
    
  
    
      
        
          
        
      
      Wearables
    
  
    
      
        
          

        
      
      Terraform
    
  
    
      
        
          
        
      
      MacOS
    
  
    
      
        
          

        
      
      C++
    
  
    
      
        
          
        
      
      Dynamic Web Apps
    
  
    
      
        
          
        
      
      Image Recognition
    
  
    
      
        
          

        
      
      Heroku
    
  
    
      
        
          

        
      
      Ruby
    
  
    
      
        
          
        
      
      Docker
    
  
    
      
        
          
        
      
      Autonomous Vehicles
    
  
    
      
        
          
        
      
      Mobile
    
  
    
      
        
          
        
      
      AI
    
  
    
      
        
          
        
      
      Robotics
    
  
    
      
        
          
        
      
      Chatbots
    
  
    
      
        
          
        
      
      Android
    
  
  
    
      
        
          
            

          
        
        Netlify
      
    
      
        
          
            

          
        
        Go
      
    
      
        
          
            
          
        
        Gaming
      
    
      
        
          
            
          
        
        Single Page Apps
      
    
      
        
          
            
          
        
        Natural language processing
      
    
      
        
          
            
          
        
        VR
      
    
      
        
          
            
          
        
        Container Images
      
    
      
        
          
            
          
        
        Databases
      
    
      
        
          
            
          
        
        APIs
      
    
      
        
          
            
          
        
        Predictive analytics
      
    
      
        
          
            
          
        
        Recommendation systems
      
    
      
        
          
            

          
        
        Speech recognition
      
    
      
        
          
            

          
        
        Elixer
      
    
      
        
          
            
          
        
        Windows
      
    
      
        
          
            

          
        
        Pulumi
      
    
      
        
          
            

          
        
        Jupyter Notebook
      
    
      
        
          
            
          
        
        Linux
      
    
      
        
          
            

          
        
        SageMaker
      
    
      
        
          
            

          
        
        AWS
      
    
      
        
          
            
          
        
        Shell
      
    
      
        
          
            

          
        
        HTML
      
    
      
        
          
            

          
        
        PHP
      
    
  

    
  
  
    
      
        
          

        
        
          

        
        
          

        
      
    
    
      

      
        
          
            
          
        
        
          
          Automated testing for every development challenge
          Mobile, web, API, serverless, AI and more: robust CI/CD so you can develop your app with speed and confidence, no matter what you’re building.
        
        
          





        
        
      
    
      

      
        
        
          
          End-to-end visibility from commit to production
          Push updates and debug failures with ease. Progressive delivery lets you monitor changes and roll back to a good state automatically if needed.
        
        
          





        
        
          
            
          
        
      
    
      

      
        
          
            
          
        
        
          
          Automated triggers for every change event
          Respond automatically to changes in your application environment. If it affects your app, you can trigger a pipeline from it on CircleCI.
        
        
          





        
        
      
    
  
  






















  
  
    
      

    
  

  
    
      
        We’re the CI/CD experts (so you don’t have to be)
        Over 50% of customers on CircleCI achieve elite DORA benchmarks.
        

  
    
    
      
        
        Start building for free
      
    
  
    
    
      
        
        Learn more about CircleCI
      
    
  

      
    
  
  
    
      Join 2mil+ devs
      And get that green build feeling
      
        
        
        
          
            
              
              
                






  “The sea change that happened for us over the course of a couple years was removing the fear [of deploying]… It used to be that pushing to production was a really big deal.It’s given people on the executive team and in sales and support more confidence that we can act on information that we get from customers.”
  
    
      





    
    
      Nick Wilson | VP of Technical Operations at GoSpotCheck
    
  

              
            
              
              
                






  “The overall stability of CircleCI is remarkable in comparison to previously used CI providers and other cloud-based development tools.”
  
    
      





    
    
      Adam Renklint | Co-founder and CTO at Pitch
    
  

              
            
              
              
                






  “CircleCI made it easier for us to streamline deployment processes and standardize the way we build, test, and release software.”
  
    
      





    
    
      Lukas Brusokas | Senior AWS Engineer at SaleCycle
    
  

              
            
              
              
                






  “CircleCI enables choice for developers, without spending time on infrastructure.”
  
    
      





    
    
      Steven Reynolds | Principal Engineer at Eventbrite
    
  

              
            
              
              
                






  “CircleCI has enabled us to make DevOps a shared responsibility that can be done by everyone.”
  
    
      





    
    
      Adam Lyons | VP of Engineering at Tanda
    
  

              
            
              
              
                






  “[We’ve] built a powerful system to automatically run security updates… engineers merge the PR, and builds run security updates on all servers.”
  
    
      





    
    
      Toshimasa Ishibashi | Co-founder and CTO at Kaizen Platform
    
  

              
            
              
              
                






  “I set up CI/CD for #ReactNative app this week, I used #CircleCI #Fastlane and connected it to #Firebase Distribution! It works well! Now all tests, builds and code signing are done automatically! #IOS #Android #mobile #ContinuousIntegration #DevOps #FirebaseDistribution”
  
    
      





    
    
      Iryna Kreichmann | @Lucky_girl_____ at Twitter
    
  

              
            
              
              
                






  “It used to be that pushing to production was a really big deal … doing releases more frequently, [has] reduced that fear.”
  
    
      





    
    
      Nick Wilson | VP of Technical Operations at GoSpotCheck
    
  

              
            
              
              
                






  “We are so proud to partner with CircleCI again and deepen our relationship to further support girls and women in STEM,” said Oakland Soul Vice President, Brand Partnerships Andrea Lepore.”
  
    
      





    
    
      Andrea Lepore | Vice President, Brand Partnerships  at Oakland Soul SC
    
  

              
            
              
              
                






  “CircleCI orbs just magically work.”
  
    
      





    
    
      Nicholas Duffy | Engineering Manager at Axios
    
  

              
            
              
              
                






  “Workflows + Docker caching are great with CircleCI.”
  
    
      





    
    
      Josh Dover | Senior Software Engineer at CrateJoy
    
  

              
            
              
              
                






  “CircleCI … [is] critical to making sure we ship code with quality, and it automates all our deployments.”
  
    
      





    
    
      Thomas Groutars | Staff Software Engineer at Maze
    
  

              
            
              
              
                






  “CircleCI enables us to … deliver the best value to our customers with total confidence.”
  
    
      





    
    
      Hemal Shah | Product Manager at fastlane
    
  

              
            
              
              
                






  “There is a growing awareness within the company to introduce CI from the early stages of projects.”
  
    
    
      Tsunashi Iguchi | DeNA
    
  

              
            
              
              
                






  “CircleCI is one of my stress-free tools.”
  
    
      





    
    
      Maksim Pecherskiy  | Chief Data Officer at City of San Diego
    
  

              
            
              
              
                






  “CircleCI helps us pivot more quickly when business priorities shift.”
  
    
      





    
    
      Carlos Villavicencio | Software Developer at Stack Builders
    
  

              
            
              
              
                






  “CircleCI is an essential tool for us.”
  
    
      





    
    
      Yuta Kimura | ANDPAD
    
  

              
            
              
              
                






  “Even on the day of transitioning to production with CircleCI Server version 3, CircleCI was on standby with a video conferencing tool in case any problems arose.”
  
    
      





    
    
      Sodai Kitamura | Data Science and Engineering at LINE
    
  

              
            
              
              
                






  “CircleCI helps us identify the areas that need improvements and quickly address them – developers only have to worry about building the product.”
  
    
      





    
    
      Thomas Groutars | Staff Software Engineer at Maze
    
  

              
            
              
              
                






  “We strive to have at least an 80 percent success rate on all of our projects and CircleCI helps us maintain this average.”
  
    
      





    
    
      Jon Anderson | Senior Software Engineer at Outreach
    
  

              
            
          
        
        
          
            
              
            
              
            
              
            
              
            
              
            
              
            
              
            
              
            
              
            
              
            
              
            
              
            
              
            
              
            
              
            
              
            
              
            
              
            
              
            
              
                
                
                  






  “We strive to have at least an 80 percent success rate on all of our projects and CircleCI helps us maintain this average.”
  
    
      





    
    
      Jon Anderson | Senior Software Engineer at Outreach
    
  

                
              
            
              
                
                
                  






  “There were so many of our customers that were already using orbs and already using CircleCI that their ability to take the orb and adopt it was trivial.”
  
    
      





    
    
      Cory Virok | Co-founder and CTO at Rollbar
    
  

                
              
            
              
                
                
                  






  “CircleCI significantly increased the productivity of the team to be able to ship more features, more confidently, and in less time.”
  
    
      





    
    
      Rawan Moukalled | Senior Front End Engineer at gtlogic
    
  

                
              
            
              
                
                
                  






  “With CircleCI’s features, our team is shifting from ‘keeping the lights on’ to ‘building something new and better.’”
  
    
      





    
    
      Anthony Carr-Smith | Software Development Manager at i2
    
  

                
              
            
              
                
                
                  






  “The integration with GitLab worked flawlessly; it was easy, fast and productive.”
  
    
    
      Yoel Astanovsky | Software Engineer at Moneytor
    
  

                
              
            
              
                
                
                  






  “CircleCI’s default mode was a game changer for us … some of our processes have improved from nearly 24 hours to 1 hour!”
  
    
      





    
    
      Anthony Carr-Smith | Software Development Manager at i2
    
  

                
              
            
              
                
                
                  






  “Switching to CircleCI has allowed our engineers to build and release mobile and web projects with far greater simplicity, speed and performance.”
  
    
      





    
    
      Matt Wise | Senior Systems Architect at Nextdoor
    
  

                
              
            
              
                
                
                  






  “The rise of GenAI is putting pressure on developers to test more frequently because every single application needs to be up and running at 100%, making effective CI/CD essential.”
  
    
      





    
    
      Xavier Portilla Edo | Infrastructure Team Lead at Voiceflow
    
  

                
              
            
              
                
                
                  






  “CircleCI connects our processes and pipelines and brings visibility into our coding environment, offering efficiency and rapid, high performance.”
  
    
      





    
    
      Valentin Ranshakov | QA Lead at Klara
    
  

                
              
            
              
                
                
                  






  “Having a partner like CircleCI that is consistent and reliable enables us to not only deliver the best value to our customers, but deliver it with total confidence.”
  
    
      





    
    
      Hemal Shah | Product Manager at fastlane
    
  

                
              
            
              
                
                
                  






  “Before CircleCI, it would take us an hour and 40 minutes to deploy — currently, it takes us 10 minutes.”
  
    
      





    
    
      Fergus McDonald | Senior Site Reliability Engineer at Procurify
    
  

                
              
            
              
                
                
                  






  “The previous CI/CD tool required manual deployments.”
  
    
      





    
    
      Seiichi Sato | Lead Engineer at Bandai Namco Studios
    
  

                
              
            
              
                
                
                  






  “We’ve reduced the time needed to manage CI/CD infrastructure, while we deliver new projects with high confidence.”
  
    
      





    
    
      Austin Brown | DevOps Engineer at Ground X
    
  

                
              
            
              
                
                
                  






  “CircleCI has significantly simplified setup and maintenance of our test environment and this allows us to run and maintain a stable test suite increasing the team’s confidence in the test results.”
  
    
      





    
    
      Jason Bosco | VP of Engineering at Dollar Shave Club
    
  

                
              
            
              
                
                
                  






  “We can still allow developers to do custom work if they want to, when they want to; developers are in complete control.”
  
    
      





    
    
      Steven Reynolds | Principal Engineer at Eventbrite
    
  

                
              
            
              
                
                
                  






  “With CircleCI our testing and deployments are running at about two minutes.”
  
    
      





    
    
      Sojin Park | Frontend Developer at Toss
    
  

                
              
            
              
                
                
                  






  “CircleCI helped us improve build system simplicity and stability, which reduced the support requests from our teams by 90%.”
  
    
      





    
    
      Matic Miklavčič | DevOps Engineer at Outfit7
    
  

                
              
            
              
                
                
                  






  “Our growth and the offering we provide our clients are simply much better with CircleCI than without it.”
  
    
      





    
    
      Adam Nowak | Software Development Practice Lead at Netguru
    
  

                
              
            
              
                
                
                  






  “With CircleCI, things can move through the release process more quickly.”
  
    
      





    
    
      Josh Bazemore | Engineering Manager at Greenhouse
    
  

                
              
            
              
                
                
                  






  “Of all the solutions we tried, I think CircleCI still provides the best caching flow.”
  
    
      





    
    
      Denis Prysukhin | Co-founder and CTO at Corewide
    
  

                
              
            
              
                
                
                  






  “Before switching to CircleCI, [the] team waited up to an hour to get through testing.”
  
    
      





    
    
      Adam Nowak | Software Development Practice Lead at Netguru
    
  

                
              
            
          
        
        
        
      
    
  
  

  
    
      Learn more
      

  Previous
  
  Next

    
  
  
    
      
        
        
          
            
            
          
          
            
              Report
              2024 State of Software Delivery
            
            Learn more
          
        
      
        
        
          
            
            
          
          
            
              Tutorial
              CircleCI onboarding toolkit
            
            Learn more
          
        
      
        
        
          
            
            
          
          
            
              Blog post
              CircleCI delivers 664% ROI
            
            Learn more
          
        
      
    
  



    




  




  
  

  
  
    
      
        NEW
        
          Actionable insights from 15 million+ datapoints.

        
        
          Get the newsletter 
        
      
    
    
  


  







  
    
      Manage your deploys from one dashboard
      
        
          Gain immediate visibility into org wide deployments; no infra access required.

        
      
      
        

  
    
    
      
        
        Learn more
      
    
  

      
    
    
      
        
          

        

        
          





          
        
      
    
  



  
    
      
        

      
      
        
        
          
            
              New
            
            Expanded support for AI-enabled applications
            New resource classes, model deployment, custom triggers along with tips for testing your LLMs in the CI.
            


Learn more 

          
          
            
          
        
          
            
              New
            
            Monitor soft fails from your config policies
            Improved visibility of config policies for all your organization with soft fails notification by pipeline in your dashboard.
            


Review changelog 

          
          
            
          
        
          
            
              New
            
            Machine Runner 3.0 released
            Enabling faster feature enhancements, improved usability, and easier setup. Check our documentation to upgrade.
            


Learn more 

          
          
        
      
    
    
    
  
  
  
  
    
    
    
    
      
        
          
            Changelog
          
          
            Keep up with the latest releases
          
          


Go to our changelog 

        
        
          
            
            
              
              
                April 16, 2025
                
                  
                    MCP Server Updated w/ Config Validation and Flaky Test Detection
                  
                
              
              
            
              
              
                April 11, 2025
                
                  
                    Server Release 4.7.3
                  
                
              
              
            
              
              
                April 09, 2025
                
                  
                    MCP Server for CircleCI now available
                  
                
              
              
            
              
              
                April 09, 2025
                
                  
                    Changes to dropdown options in "Add trigger" and "Add pipeline" forms
                  
                
              
              
            
              
              
                April 09, 2025
                
                  
                    Update - Breaking Change- April 28th 2025 - Skipped Status Will Now Return Success 
                  
                
              
              
            
          
        
      
      
      
    
  
  






















  
  
    
      

    
  

  
    
      
        
          
            
          
          
            Product Roadmap
          
        
        
          Discover what's around the corner in CircleCI's product roadmap. Our teams are working on exciting new features to help you ship faster and securely.
        
        
        


Check out CircleCI’s roadmap 

      
      
      
        
          
            
          
          
            Key milestones
          
        
        
          A look back at CircleCI’s key milestones, from our marquee releases to press moments, and everything in between.
        
        
        
        


View CircleCI’s milestones\n\n\n\nCancel
      
      
    
  
  
    
  


      







  
  
    
      
        New
        
          CircleCI now supports GitLab SaaS and self-managed code repositories.

        
        
          Connect now 
        
      
    
    
  






  
    
    
      






  DevOps 101
  


See all 


      
        
        

        
          
            
              



            
          
          
            What is a CI/CD pipeline?
            8 min read
          
        
      
      
        

        

        
          
            
              



            
          
          
            What is platform engineering? A quick introduction
            8 min read
          
        
      
        

        

        
          
            
              



            
          
          
            6 optimization tips for your CI configuration
            11 min read
          
        
      
    
  
  
    
      
      
        






  CircleCI News
  


See all 


        
          
            
            

            
              
                
                  



                
              
              
                CircleCI MCP server: Natural language CI for AI-driven workflows
                5 min read
              
            
          
            
            

            
              
                
                  



                
              
              
                Why CircleCI? Or: Falling in love (with change) again
                7 min read
              
            
          
            
            

            
              
                
                  



                
              
              
                CI/CD at scale: A performance analysis of CircleCI vs GitHub Actions
                5 min read
              
            
          
        
      
    
      
      
        






  Engineering Productivity
  


See all 


        
          
            
            

            
              
                
                  



                
              
              
                How to use LLMs to generate test data (and why it matters more than ever)
                6 min read
              
            
          
            
            

            
              
                
                  



                
              
              
                Machine learning vs AI: Key differences and how they work together
                8 min read
              
            
          
            
            

            
              
                
                  



                
              
              
                7 tips for effective system prompting: A developer's guide to building better AI applications
                4 min read
              
            
          
        
      
    
      
      
        






  Engineering Management
  


See all 


        
          
            
            

            
              
                
                  



                
              
              
                Understanding enterprise application development
                9 min read
              
            
          
            
            

            
              
                
                  



                
              
              
                DORA metrics: How to measure DevOps performance
                10 min read
              
            
          
            
            

            
              
                
                  



                
              
              
                Goodbye, GitOps: Getting to green in an AI-powered world
                5 min read
              
            
          
        
      
    
    
  


  
    See all posts
  





  
    
      Most popular
      
      
        Previous
        
        Next
      
    
  
  
    
      
        

  
    
      



    
  

  
  
    
      CI for machine learning: Build, test, train
    
    
      
        17 min read
      
    
  
  

  
    








  
    
      



    
  
  
    
      
        Jacob Schmitt
      
    
    
      
        Senior Technical Content Marketing Manager
      
    
  


  

      
        

  
    
      



    
  

  
  
    
      Setting up continuous integration (CI) with GitLab and CircleCI
    
    
      
        6 min read
      
    
  
  

  
    








  
    
      



    
  
  
    
      
        Zan Markan
      
    
    
      
        Developer Advocate
      
    
  


  

      
        

  
    
      



    
  

  
  
    
      Build on Apple silicon with M1 support for CI/CD pipelines
    
    
      
        5 min read
      
    
  
  

  
    








  
    
      



    
  
  
    
      
        Alexa Zeazas Loper
      
    
    
      
        Senior Product Manager
      
    
  


  

      
        

  
    
      



    
  

  
  
    
      How to successfully work from home: strategies for remote work
    
    
      
        3 min read
      
    
  
  

  
    








  
    
      



    
  
  
    
      
        Rosalind Lutsky
      
    
    
      
        Lifecycle Marketing Manager
      
    
  


  

      
    
  



      
  
    >Subscribe
    
      

  
    
    
      
        
          
        
        Get the newsletter
      
    
  

    
  





  
    
      
        
        CircleCI
      
    
    
      
        © 2025 Circle Internet Services, Inc.
        
          
            Terms of Use
          
            Privacy Policy
          
            Cookie Policy
          
        
      
      
  
    
    RSS
  
  
    
    LinkedIn
  
  
    
    GitHub
  
  
    

    X
  
  
    
    Twitch\n\nCancel
      
      
    
  
  
    
  


      







  
  
    
      
        New
        
          CircleCI now supports GitLab SaaS and self-managed code repositories.

        
        
          Connect now 
        
      
    
    
  






  
    
    
      






  DevOps 101
  


See all 


      
        
        

        
          
            
              



            
          
          
            What is a CI/CD pipeline?
            8 min read
          
        
      
      
        

        

        
          
            
              



            
          
          
            What is platform engineering? A quick introduction
            8 min read
          
        
      
        

        

        
          
            
              



            
          
          
            6 optimization tips for your CI configuration
            11 min read
          
        
      
    
  
  
    
      
      
        






  CircleCI News
  


See all 


        
          
            
            

            
              
                
                  



                
              
              
                CircleCI MCP server: Natural language CI for AI-driven workflows
                5 min read
              
            
          
            
            

            
              
                
                  



                
              
              
                Why CircleCI? Or: Falling in love (with change) again
                7 min read
              
            
          
            
            

            
              
                
                  



                
              
              
                CI/CD at scale: A performance analysis of CircleCI vs GitHub Actions
                5 min read
              
            
          
        
      
    
      
      
        






  Engineering Productivity
  


See all 


        
          
            
            

            
              
                
                  



                
              
              
                How to use LLMs to generate test data (and why it matters more than ever)
                6 min read
              
            
          
            
            

            
              
                
                  



                
              
              
                Machine learning vs AI: Key differences and how they work together
                8 min read
              
            
          
            
            

            
              
                
                  



                
              
              
                7 tips for effective system prompting: A developer's guide to building better AI applications
                4 min read
              
            
          
        
      
    
      
      
        






  Engineering Management
  


See all 


        
          
            
            

            
              
                
                  



                
              
              
                Understanding enterprise application development
                9 min read
              
            
          
            
            

            
              
                
                  



                
              
              
                DORA metrics: How to measure DevOps performance
                10 min read
              
            
          
            
            

            
              
                
                  



                
              
              
                Goodbye, GitOps: Getting to green in an AI-powered world
                5 min read
              
            
          
        
      
    
    
  


  
    See all posts
  





  
    
      Most popular
      
      
        Previous
        
        Next
      
    
  
  
    
      
        

  
    
      



    
  

  
  
    
      CI for machine learning: Build, test, train
    
    
      
        17 min read
      
    
  
  

  
    








  
    
      



    
  
  
    
      
        Jacob Schmitt
      
    
    
      
        Senior Technical Content Marketing Manager
      
    
  


  

      
        

  
    
      



    
  

  
  
    
      Setting up continuous integration (CI) with GitLab and CircleCI
    
    
      
        6 min read
      
    
  
  

  
    








  
    
      



    
  
  
    
      
        Zan Markan
      
    
    
      
        Developer Advocate
      
    
  


  

      
        

  
    
      



    
  

  
  
    
      Build on Apple silicon with M1 support for CI/CD pipelines
    
    
      
        5 min read
      
    
  
  

  
    








  
    
      



    
  
  
    
      
        Alexa Zeazas Loper
      
    
    
      
        Senior Product Manager
      
    
  


  

      
        

  
    
      



    
  

  
  
    
      How to successfully work from home: strategies for remote work
    
    
      
        3 min read
      
    
  
  

  
    








  
    
      



    
  
  
    
      
        Rosalind Lutsky
      
    
    
      
        Lifecycle Marketing Manager
      
    
  


  

      
    
  



      
  
    >Subscribe
    
      

  
    
    
      
        
          
        
        Get the newsletter
      
    
  

    
  





  
    
      
        
        CircleCI
      
    
    
      
        © 2025 Circle Internet Services, Inc.
        
          
            Terms of Use
          
            Privacy Policy
          
            Cookie Policy
          
        
      
      
  
    
    RSS
  
  
    
    LinkedIn
  
  
    
    GitHub
  
  
    

    X
  
  
    
    Twitch\n\n\n\nSign up and try CircleCI2 months ago3 min readCloudOn This PageSign upBuilding GitHub, GitLab, Bitbucket Data Center projects?Building Bitbucket Cloud projects?Create an orgSign up with an inviteTermsNext steps   To start building on CircleCI, go to the  Sign Up page or follow an email invite link from your team, and create an account. After signing up you can create an organization or find your teammates.       CircleCI supports GitHub, Bitbucket, and GitLab projects.   If you use GitHub, GitLab, or Bitbucket Data Center and are creating a CircleCI organization for your team, you will set the version control system (VCS) integration type, and authenticate with your VCS provider during the signup process. Team members that you invite to your CircleCI org can join without authenticating with your VCS. However, if they are to create new projects, they will authenticate during the project creation process.   If you use Bitbucket Cloud, every team member signing up for a new account and joining your org will authenticate with Bitbucket during the signup process.           Sign up   From the  Sign Up page, do one of the following:   Building GitHub, GitLab, Bitbucket Data Center projects?  If you want to build mainly GitHub, GitLab or Bitbucket Data Center projects, sign up with your email address to create an account.      Bitbucket Data Center support is in closed preview. To get access, sign up  here.           If you want to collaborate on an existing org you can create an account and request an invite later.          Select Sign Up.   Enter your email address and create a password.   Answer a few questions about how you plan to use CircleCI.   You can now choose one of the following:    Use the  Find Your Team option to connect your account to a shared org    Create an org         Building Bitbucket Cloud projects?  If you want to primarily build Bitbucket Cloud projects, sign up with your Bitbucket account. After you connect your Bitbucket account you can go ahead and start setting up projects, following the  Create a project in CircleCI page. Your org in CircleCI maps directly to your Bitbucket workspace.     Select Sign Up With Bitbucket.   Log in to your Bitbucket Cloud account   Enter your email address and create a password.   Choose between creating an organization or joining your teammates in an existing org:    If you are creating a new CircleCI org for your team, follow the  Create an org steps below.   If you want to join an existing shared organization, follow the steps on the  Join your teammates page.           Create an org   This section covers creating a new CircleCI organization. Once your organization is created, you can start building right away or invite your teammates to join.     From your user homepage select Get Started in the "Start a new organization" card.   Give your organization a name and select Let’s Go.   Create a project to get started. Select Get Started in the "Create a project" card, and refer to the  Create a project page for further steps.      If you choose not to connect your code at this time, you can still explore some example projects within the CircleCI app.     You can take a look at a popular open source project building on CircleCI,  React by Facebook.   Or some of our own sample projects: a  sample JavaScript app, and a  sample Python app.            Invite your team by navigating to Organization Settings  People. For more information on inviting people to your org, see the  Join your teammates page.       Sign up with an invite   If you are signing up using an invite from your team, you will be joining an existing CircleCI organization.     To create an account for free with CircleCI, follow the link in your invite email and enter your email address and create a password.   On the next screen, respond to prompts that best describe your role and your engineering organization.   Finally, you will be taken to your organization’s pipelines dashboard in the CircleCI web app. From here, you can follow projects or trigger pipelines in projects to which you have access in your organization, or  create new projects.        If you are setting up a project for the first time, you may need to authenticate with your VCS provider. Once you have completed a one-time authentication, you will be able to set up subsequent projects in CircleCI more quickly. Refer to the  Creating a Project guide for more information.        Guides for integrating GitHub, Bitbucket, or GitLab projects are available as follows:      GitHub App integration    GitHub OAuth app integration    Bitbucket Cloud integration    GitLab integration    Bitbucket Data Center integration       Terms   By signing up, you are agreeing to our  SaaS Agreement and  Privacy Policy. We ask for read/write access to make your experience seamless on CircleCI. If you are a GitHub user and aren’t ready to share access to your private projects, you can choose public repositories instead. Protected by reCAPTCHA, Google  Privacy Policy and  Terms of Service apply.     Next steps     Read the  Join your teammates page for steps on adding team members to your CircleCI org.   Go to the  Hello World page to learn the basics of setting up a CircleCI configuration file.   Read the  Concepts page for an overview of foundational CircleCI concepts such as pipelines, executors.   Refer to the full  CircleCI configuration reference for creating a .circleci/config.yml file, which determines your execution environment and automates your tests.     Suggest an edit to this pageMake a contribution Learn how to contributeStill need help? Ask the CircleCI community Join the research community Visit our Support site\n\nSign up and try CircleCI2 months ago3 min readCloudOn This PageSign upBuilding GitHub, GitLab, Bitbucket Data Center projects?Building Bitbucket Cloud projects?Create an orgSign up with an inviteTermsNext steps   To start building on CircleCI, go to the  Sign Up page or follow an email invite link from your team, and create an account. After signing up you can create an organization or find your teammates.       CircleCI supports GitHub, Bitbucket, and GitLab projects.   If you use GitHub, GitLab, or Bitbucket Data Center and are creating a CircleCI organization for your team, you will set the version control system (VCS) integration type, and authenticate with your VCS provider during the signup process. Team members that you invite to your CircleCI org can join without authenticating with your VCS. However, if they are to create new projects, they will authenticate during the project creation process.   If you use Bitbucket Cloud, every team member signing up for a new account and joining your org will authenticate with Bitbucket during the signup process.           Sign up   From the  Sign Up page, do one of the following:   Building GitHub, GitLab, Bitbucket Data Center projects?  If you want to build mainly GitHub, GitLab or Bitbucket Data Center projects, sign up with your email address to create an account.      Bitbucket Data Center support is in closed preview. To get access, sign up  here.           If you want to collaborate on an existing org you can create an account and request an invite later.          Select Sign Up.   Enter your email address and create a password.   Answer a few questions about how you plan to use CircleCI.   You can now choose one of the following:    Use the  Find Your Team option to connect your account to a shared org    Create an org         Building Bitbucket Cloud projects?  If you want to primarily build Bitbucket Cloud projects, sign up with your Bitbucket account. After you connect your Bitbucket account you can go ahead and start setting up projects, following the  Create a project in CircleCI page. Your org in CircleCI maps directly to your Bitbucket workspace.     Select Sign Up With Bitbucket.   Log in to your Bitbucket Cloud account   Enter your email address and create a password.   Choose between creating an organization or joining your teammates in an existing org:    If you are creating a new CircleCI org for your team, follow the  Create an org steps below.   If you want to join an existing shared organization, follow the steps on the  Join your teammates page.           Create an org   This section covers creating a new CircleCI organization. Once your organization is created, you can start building right away or invite your teammates to join.     From your user homepage select Get Started in the "Start a new organization" card.   Give your organization a name and select Let’s Go.   Create a project to get started. Select Get Started in the "Create a project" card, and refer to the  Create a project page for further steps.      If you choose not to connect your code at this time, you can still explore some example projects within the CircleCI app.     You can take a look at a popular open source project building on CircleCI,  React by Facebook.   Or some of our own sample projects: a  sample JavaScript app, and a  sample Python app.            Invite your team by navigating to Organization Settings  People. For more information on inviting people to your org, see the  Join your teammates page.       Sign up with an invite   If you are signing up using an invite from your team, you will be joining an existing CircleCI organization.     To create an account for free with CircleCI, follow the link in your invite email and enter your email address and create a password.   On the next screen, respond to prompts that best describe your role and your engineering organization.   Finally, you will be taken to your organization’s pipelines dashboard in the CircleCI web app. From here, you can follow projects or trigger pipelines in projects to which you have access in your organization, or  create new projects.        If you are setting up a project for the first time, you may need to authenticate with your VCS provider. Once you have completed a one-time authentication, you will be able to set up subsequent projects in CircleCI more quickly. Refer to the  Creating a Project guide for more information.        Guides for integrating GitHub, Bitbucket, or GitLab projects are available as follows:      GitHub App integration    GitHub OAuth app integration    Bitbucket Cloud integration    GitLab integration    Bitbucket Data Center integration       Terms   By signing up, you are agreeing to our  SaaS Agreement and  Privacy Policy. We ask for read/write access to make your experience seamless on CircleCI. If you are a GitHub user and aren’t ready to share access to your private projects, you can choose public repositories instead. Protected by reCAPTCHA, Google  Privacy Policy and  Terms of Service apply.     Next steps     Read the  Join your teammates page for steps on adding team members to your CircleCI org.   Go to the  Hello World page to learn the basics of setting up a CircleCI configuration file.   Read the  Concepts page for an overview of foundational CircleCI concepts such as pipelines, executors.   Refer to the full  CircleCI configuration reference for creating a .circleci/config.yml file, which determines your execution environment and automates your tests.     Suggest an edit to this pageMake a contribution Learn how to contributeStill need help? Ask the CircleCI community Join the research community Visit our Support site DocsTerms of UsePrivacy PolicyCookie PolicySecurity© 2025 Circle Internet Services, Inc., All Rights Reserved.\n\nCircleCI supports GitHub, Bitbucket, and GitLab projects.   If you use GitHub, GitLab, or Bitbucket Data Center and are creating a CircleCI organization for your team, you will set the version control system (VCS) integration type, and authenticate with your VCS provider during the signup process. Team members that you invite to your CircleCI org can join without authenticating with your VCS. However, if they are to create new projects, they will authenticate during the project creation process.   If you use Bitbucket Cloud, every team member signing up for a new account and joining your org will authenticate with Bitbucket during the signup process.   Bitbucket Data Center support is in closed preview. To get access, sign up  here.  If you want to collaborate on an existing org you can create an account and request an invite later.   If you choose not to connect your code at this time, you can still explore some example projects within the CircleCI app.     You can take a look at a popular open source project building on CircleCI,  React by Facebook.   Or some of our own sample projects: a  sample JavaScript app, and a  sample Python app.     If you are setting up a project for the first time, you may need to authenticate with your VCS provider. Once you have completed a one-time authentication, you will be able to set up subsequent projects in CircleCI more quickly. Refer to the  Creating a Project guide for more information.\n\n\n\nCreate a project in CircleCI2 months ago8 min readCloudServer v4+On This PagePrerequisitesBuild a new project on CircleCICreate a projectSet up a projectSee also   This guide gets you started with creating a new project in CircleCI.     Prerequisites     A CircleCI account connected to your code. You can  sign up for free.   Code you want to build on CircleCI.       Build a new project on CircleCI   The authorization method used to set up your CircleCI account determines the definition of "project" in CircleCI, as well as the permissions management processes available to you:   On the Organization Home page, check which option you see:     If you see a Set up a project button, follow steps to  Set up a project below.   If you see a Create Project button, follow steps to  Create a project below.        Using CircleCI server? Use the  Set up a project steps below. Rather than Organization Home you will see Dashboard in the web app sidebar.        Create a project     If you have integrated your code with the  CircleCI GitHub App,  GitLab, or  Bitbucket Data Center, the steps in this section apply to you.        Choose steps to follow below, depending on where your code is stored:  GitHub AppGitLab CloudGitLab self-managedBitbucket Data Center   Follow these steps to create a new project in CircleCI:     In the  CircleCI web app, select Organization Home in the sidebar.   Select Create Project at the top of the page, or anywhere in the Create a project card if this is your first project.     Figure 1. Create a project button      Figure 2. Create a project card view when creating your first project    Choose an option to match the work you want to do in your project.     Figure 3. Tell CircleCI what your project is for    Give your project a descriptive name and then select Next: Set up a pipeline.      Project names must meet the following requirements:     Begin with a letter.   Be 3-40 characters long.   Contain only letters, numbers, or the following characters: " - _ . : ! & + [ ] " ;.              Figure 4. Name your project    Next, set up your first pipeline for your project. Pipelines orchestrate executable commands and scripts for your CI/CD processes. The first step is to name your pipeline. Use a name that describes the purpose of the pipeline, for example, build-and-test. Then select Next: Choose a repo.     Figure 5. Set up a pipeline    Choose a repo to connect to your project.  If you do not see your repo listed, select Add to access repositories from GitHub. Select GitHub and then Authorize in GitHub      First GitHub project? If this is the first GitHub project you are creating, you will be redirected to GitHub and asked to install and authorise the CircleCI GitHub App. At this point you can choose to connect CircleCI to all your repositories, or select a subset of repositories to connect. This is a one-time action that can be done by an organization administrator or someone who has admin access to a repository in your org.           Figure 6. Choose a repo to connect your code to your project    In this next step CircleCI will prepare a config file for you, unless your repo already contains a CircleCI config file. In a later step you will commit this config to your repo on a new branch. If you do already have a CircleCI config file in your repo it will be displayed. Once you have your config, select Next: set up your triggers.     Figure 7. Set up your CircleCI config file    Set up triggers for your pipeline. A single GitHub App trigger is set up by default to build your project on every commit to your repo. You can  add more triggers at this point too.     Figure 8. Set up triggers for your pipeline    Next you can review everything you have just set up, then select Commit config and run, or Finish setup if you already have a config file in your repo.     Figure 9. Review and finish setup      Once your project is created you will land on your pipelines page.      Follow these steps to create a new project in CircleCI:     In the  CircleCI web app, select Organization Home in the sidebar.   Select Create Project at the top of the page, or anywhere in the Create a project card if this is your first project.     Figure 10. Create a project button      Figure 11. Create a project card view when creating your first project    Choose an option to match the work you want to do in your project.     Figure 12. Tell CircleCI what your project is for    Give your project a descriptive name and then select Next: Set up a pipeline.      Project names must meet the following requirements:     Begin with a letter.   Be 3-40 characters long.   Contain only letters, numbers, or the following characters: " - _ . : ! & + [ ] " ;.              Figure 13. Name your project    Next, set up your first pipeline for your project. Pipelines orchestrate executable commands and scripts for your CI/CD processes. The first step is to name your pipeline. Use a name that describes the purpose of the pipeline, for example, build-and-test. Then select Next: Choose a repo.     Figure 14. Set up a pipeline    Choose a repo to connect to your project. If you do not see your repo listed, select Add or Connect to GitLab Cloud to authorise access to your GitLab repositories.  Choose a repo to connect your code to your project      Figure 15. Choose a repo to connect your code to your project      First GitLab project? If you are creating the first GitLab project for your org, you will be redirected to GitLab to authorise the integration. This is a one-time action that can be done by an organization administrator or someone who has admin access to a repository in your org.         In the Create New Project window, ensure you have the right repo selected in the dropdown. If you have a CircleCI config file already available in your repo, CircleCI will detect it. If not you can select an option for adding one:     Figure 16. Set up a new GitLab project     Fastest: Use a config file that already exists in your repository.   Faster: Let CircleCI pick a configuration file for you, and commit this to a new branch in you repository.   Fast: View and edit a starter config file in the CircleCI web app and commit that to your repository yourself.      Select Create Project at the bottom of the window.   If you chose the fastest/faster options you will now be on the pipelines page of the CircleCI web app. If you chose "fast" you have some options:    Select Commit and Run to commit your custom configuration file on a new branch called circleci-project-setup.     Figure 17. Use a generated config file    Select Use Existing Config for the option to download the generated config and instructions to commit this or another CircleCI configuration file to your repository directly. The select Start Building.     Figure 18. Instructions for using an existing config file            Follow these steps to create a new project in CircleCI:     In the  CircleCI web app, select Organization Home in the sidebar.   Select Create Project at the top of the page, or anywhere in the Create a project card if this is your first project.     Figure 19. Create a project button      Figure 20. Create a project card view when creating your first project    Choose an option to match the work you want to do in your project.     Figure 21. Tell CircleCI what your project is for    Give your project a descriptive name and then select Next: Set up a pipeline.      Project names must meet the following requirements:     Begin with a letter.   Be 3-40 characters long.   Contain only letters, numbers, or the following characters: " - _ . : ! & + [ ] " ;.              Figure 22. Name your project    Next, set up your first pipeline for your project. Pipelines orchestrate executable commands and scripts for your CI/CD processes. The first step is to name your pipeline. Use a name that describes the purpose of the pipeline, for example, build-and-test. Then select Next: Choose a repo.     Figure 23. Set up a pipeline    Choose a repo to connect to your project. If you do not see your repo listed, select Add or Connect to GitLab self-managed to access repositories from your GitLab self-managed instance. Select GitLab self-managed and then Authorize in GitLab self-managed     Figure 24. Choose a repo to connect your code to your project      Figure 25. Authorize GitLab self-managed    In the Create New Project window, you have some options:     Figure 26. Set up your new GitLab self-managed project       If this is your first GitLab self-managed project you will now set up your integration:     Verify your GitLab URL   Generate an add a personal access token   Add your known hosts, following the instructions in the app             Use the repository dropdown menu to tell CircleCI where your code is stored.   Select Create Project. You will then be redirected to the Pipelines page.   The express CircleCI configuration setup is not currently available for GitLab self-managed projects. You will need to add a .circleci/config.yml file in your repository if it has not yet been set up. If the repository you selected already contains a .circleci/config.yml, push a commit to see your pipeline on the dashboard.      For guidance on creating a config.yml file, see the following pages:      Configuration introduction    Sample config.yml files    Configuration reference                       Bitbucket Data Center support is in closed preview. To get access, sign up  here.        Follow these steps to create a new project in CircleCI:     In the  CircleCI web app, select Organization Home in the sidebar.   Select Create Project at the top of the page, or anywhere in the Create a project card if this is your first project.     Figure 27. Create a project button      Figure 28. Create a project card view when creating your first project    Choose an option to match the work you want to do in your project.     Figure 29. Tell CircleCI what your project is for    Give your project a descriptive name and then select Next: Set up a pipeline.      Project names must meet the following requirements:     Begin with a letter.   Be 3-40 characters long.   Contain only letters, numbers, or the following characters: " - _ . : ! & + [ ] " ;.              Figure 30. Name your project    Next, set up your first pipeline for your project. Pipelines orchestrate executable commands and scripts for your CI/CD processes. The first step is to name your pipeline. Use a name that describes the purpose of the pipeline, for example, build-and-test. Then select Next: Choose a repo.     Figure 31. Set up a pipeline    Choose a repo to connect to your project. If you do not see your repo listed, select Add to access repositories from GitHub. Select Bitbucket Data Center and then Authorize in Bitbucket Data Center     Figure 32. Access Bitbucket data center repos    Next, follow the steps on the  Bitbucket integration setup page to set up the following:    An integration with your Bitbucket Data Center instance (if not already set up for your org).   Set up a pipeline and trigger for your project.   Add a configuration file to your repo.             CircleCI uses the specified .circleci/config.yml file to run your pipeline. You can see the output on the pipelines page. To make changes to your pipeline, edit the .circleci/config.yml file in your repository.   Through creating a project and connecting your code you have set up your pipeline and a trigger. The default trigger runs your pipeline when a change is committed to your code. You can create more triggers at Project settings  Triggers. For more information, see the  Pipelines overview.    Set up a project     If you authenticated CircleCI with either the  GitHub OAuth app or  Bitbucket Cloud, or if you use CircleCI server, the steps in this section apply to you.        Follow these steps to set up a new project in CircleCI:     In the CircleCI web app, select Organization Home in the sidebar. The equivalent option in CircleCI server is Dashboard   Select Set up a project.     Figure 33. Set up a project    Find your project in the list and select Set Up Project.      Can’t see your project? Select the CircleCI logo at the top of the window to navigate to your user homepage and select an organization.      Figure 34. Access your user homepage          Choose a config.yml option in the modal. You can choose from the following:    Fastest: Use a CircleCI .circleci/config.yml you have already committed to your repository. For guidance on creating a config.yml file, see the  Configuration Introduction. You will also need to specify a branch.   Faster: Commit a starter CI pipeline to a new circleci-project-setup branch of your repository.   Fast: View, edit, and commit a template config.yml.      Select Set Up Project.     CircleCI uses the specified .circleci/config.yml file to run your pipeline. You can see the output in the CircleCI dashboard.   To make changes to your pipeline, choose one of the following:     Edit the config file in your repository,   Select the ellipsis () next your project in the Pipelines or Projects dashboard and choose Configuration File. This opens the CircleCI configuration editor, from where you can edit and commit your config.yml file.   Access the configuration editor using the Edit Config button from a the Pipelines page when you have a project and branch selected.        Figure 35. Access and edit a config file      See also      Configuration Introduction    Sample config.yml files    Configuration reference    Using the CircleCI Configuration Editor     Suggest an edit to this pageMake a contribution Learn how to contributeStill need help? Ask the CircleCI community Join the research community Visit our Support site\n\nCreate a project in CircleCI2 months ago8 min readCloudServer v4+On This PagePrerequisitesBuild a new project on CircleCICreate a projectSet up a projectSee also   This guide gets you started with creating a new project in CircleCI.     Prerequisites     A CircleCI account connected to your code. You can  sign up for free.   Code you want to build on CircleCI.       Build a new project on CircleCI   The authorization method used to set up your CircleCI account determines the definition of "project" in CircleCI, as well as the permissions management processes available to you:   On the Organization Home page, check which option you see:     If you see a Set up a project button, follow steps to  Set up a project below.   If you see a Create Project button, follow steps to  Create a project below.        Using CircleCI server? Use the  Set up a project steps below. Rather than Organization Home you will see Dashboard in the web app sidebar.        Create a project     If you have integrated your code with the  CircleCI GitHub App,  GitLab, or  Bitbucket Data Center, the steps in this section apply to you.        Choose steps to follow below, depending on where your code is stored:  GitHub AppGitLab CloudGitLab self-managedBitbucket Data Center   Follow these steps to create a new project in CircleCI:     In the  CircleCI web app, select Organization Home in the sidebar.   Select Create Project at the top of the page, or anywhere in the Create a project card if this is your first project.     Figure 1. Create a project button      Figure 2. Create a project card view when creating your first project    Choose an option to match the work you want to do in your project.     Figure 3. Tell CircleCI what your project is for    Give your project a descriptive name and then select Next: Set up a pipeline.      Project names must meet the following requirements:     Begin with a letter.   Be 3-40 characters long.   Contain only letters, numbers, or the following characters: " - _ . : ! & + [ ] " ;.              Figure 4. Name your project    Next, set up your first pipeline for your project. Pipelines orchestrate executable commands and scripts for your CI/CD processes. The first step is to name your pipeline. Use a name that describes the purpose of the pipeline, for example, build-and-test. Then select Next: Choose a repo.     Figure 5. Set up a pipeline    Choose a repo to connect to your project.  If you do not see your repo listed, select Add to access repositories from GitHub. Select GitHub and then Authorize in GitHub      First GitHub project? If this is the first GitHub project you are creating, you will be redirected to GitHub and asked to install and authorise the CircleCI GitHub App. At this point you can choose to connect CircleCI to all your repositories, or select a subset of repositories to connect. This is a one-time action that can be done by an organization administrator or someone who has admin access to a repository in your org.           Figure 6. Choose a repo to connect your code to your project    In this next step CircleCI will prepare a config file for you, unless your repo already contains a CircleCI config file. In a later step you will commit this config to your repo on a new branch. If you do already have a CircleCI config file in your repo it will be displayed. Once you have your config, select Next: set up your triggers.     Figure 7. Set up your CircleCI config file    Set up triggers for your pipeline. A single GitHub App trigger is set up by default to build your project on every commit to your repo. You can  add more triggers at this point too.     Figure 8. Set up triggers for your pipeline    Next you can review everything you have just set up, then select Commit config and run, or Finish setup if you already have a config file in your repo.     Figure 9. Review and finish setup      Once your project is created you will land on your pipelines page.      Follow these steps to create a new project in CircleCI:     In the  CircleCI web app, select Organization Home in the sidebar.   Select Create Project at the top of the page, or anywhere in the Create a project card if this is your first project.     Figure 10. Create a project button      Figure 11. Create a project card view when creating your first project    Choose an option to match the work you want to do in your project.     Figure 12. Tell CircleCI what your project is for    Give your project a descriptive name and then select Next: Set up a pipeline.      Project names must meet the following requirements:     Begin with a letter.   Be 3-40 characters long.   Contain only letters, numbers, or the following characters: " - _ . : ! & + [ ] " ;.              Figure 13. Name your project    Next, set up your first pipeline for your project. Pipelines orchestrate executable commands and scripts for your CI/CD processes. The first step is to name your pipeline. Use a name that describes the purpose of the pipeline, for example, build-and-test. Then select Next: Choose a repo.     Figure 14. Set up a pipeline    Choose a repo to connect to your project. If you do not see your repo listed, select Add or Connect to GitLab Cloud to authorise access to your GitLab repositories.  Choose a repo to connect your code to your project      Figure 15. Choose a repo to connect your code to your project      First GitLab project? If you are creating the first GitLab project for your org, you will be redirected to GitLab to authorise the integration. This is a one-time action that can be done by an organization administrator or someone who has admin access to a repository in your org.         In the Create New Project window, ensure you have the right repo selected in the dropdown. If you have a CircleCI config file already available in your repo, CircleCI will detect it. If not you can select an option for adding one:     Figure 16. Set up a new GitLab project     Fastest: Use a config file that already exists in your repository.   Faster: Let CircleCI pick a configuration file for you, and commit this to a new branch in you repository.   Fast: View and edit a starter config file in the CircleCI web app and commit that to your repository yourself.      Select Create Project at the bottom of the window.   If you chose the fastest/faster options you will now be on the pipelines page of the CircleCI web app. If you chose "fast" you have some options:    Select Commit and Run to commit your custom configuration file on a new branch called circleci-project-setup.     Figure 17. Use a generated config file    Select Use Existing Config for the option to download the generated config and instructions to commit this or another CircleCI configuration file to your repository directly. The select Start Building.     Figure 18. Instructions for using an existing config file            Follow these steps to create a new project in CircleCI:     In the  CircleCI web app, select Organization Home in the sidebar.   Select Create Project at the top of the page, or anywhere in the Create a project card if this is your first project.     Figure 19. Create a project button      Figure 20. Create a project card view when creating your first project    Choose an option to match the work you want to do in your project.     Figure 21. Tell CircleCI what your project is for    Give your project a descriptive name and then select Next: Set up a pipeline.      Project names must meet the following requirements:     Begin with a letter.   Be 3-40 characters long.   Contain only letters, numbers, or the following characters: " - _ . : ! & + [ ] " ;.              Figure 22. Name your project    Next, set up your first pipeline for your project. Pipelines orchestrate executable commands and scripts for your CI/CD processes. The first step is to name your pipeline. Use a name that describes the purpose of the pipeline, for example, build-and-test. Then select Next: Choose a repo.     Figure 23. Set up a pipeline    Choose a repo to connect to your project. If you do not see your repo listed, select Add or Connect to GitLab self-managed to access repositories from your GitLab self-managed instance. Select GitLab self-managed and then Authorize in GitLab self-managed     Figure 24. Choose a repo to connect your code to your project      Figure 25. Authorize GitLab self-managed    In the Create New Project window, you have some options:     Figure 26. Set up your new GitLab self-managed project       If this is your first GitLab self-managed project you will now set up your integration:     Verify your GitLab URL   Generate an add a personal access token   Add your known hosts, following the instructions in the app             Use the repository dropdown menu to tell CircleCI where your code is stored.   Select Create Project. You will then be redirected to the Pipelines page.   The express CircleCI configuration setup is not currently available for GitLab self-managed projects. You will need to add a .circleci/config.yml file in your repository if it has not yet been set up. If the repository you selected already contains a .circleci/config.yml, push a commit to see your pipeline on the dashboard.      For guidance on creating a config.yml file, see the following pages:      Configuration introduction    Sample config.yml files    Configuration reference                       Bitbucket Data Center support is in closed preview. To get access, sign up  here.        Follow these steps to create a new project in CircleCI:     In the  CircleCI web app, select Organization Home in the sidebar.   Select Create Project at the top of the page, or anywhere in the Create a project card if this is your first project.     Figure 27. Create a project button      Figure 28. Create a project card view when creating your first project    Choose an option to match the work you want to do in your project.     Figure 29. Tell CircleCI what your project is for    Give your project a descriptive name and then select Next: Set up a pipeline.      Project names must meet the following requirements:     Begin with a letter.   Be 3-40 characters long.   Contain only letters, numbers, or the following characters: " - _ . : ! & + [ ] " ;.              Figure 30. Name your project    Next, set up your first pipeline for your project. Pipelines orchestrate executable commands and scripts for your CI/CD processes. The first step is to name your pipeline. Use a name that describes the purpose of the pipeline, for example, build-and-test. Then select Next: Choose a repo.     Figure 31. Set up a pipeline    Choose a repo to connect to your project. If you do not see your repo listed, select Add to access repositories from GitHub. Select Bitbucket Data Center and then Authorize in Bitbucket Data Center     Figure 32. Access Bitbucket data center repos    Next, follow the steps on the  Bitbucket integration setup page to set up the following:    An integration with your Bitbucket Data Center instance (if not already set up for your org).   Set up a pipeline and trigger for your project.   Add a configuration file to your repo.             CircleCI uses the specified .circleci/config.yml file to run your pipeline. You can see the output on the pipelines page. To make changes to your pipeline, edit the .circleci/config.yml file in your repository.   Through creating a project and connecting your code you have set up your pipeline and a trigger. The default trigger runs your pipeline when a change is committed to your code. You can create more triggers at Project settings  Triggers. For more information, see the  Pipelines overview.    Set up a project     If you authenticated CircleCI with either the  GitHub OAuth app or  Bitbucket Cloud, or if you use CircleCI server, the steps in this section apply to you.        Follow these steps to set up a new project in CircleCI:     In the CircleCI web app, select Organization Home in the sidebar. The equivalent option in CircleCI server is Dashboard   Select Set up a project.     Figure 33. Set up a project    Find your project in the list and select Set Up Project.      Can’t see your project? Select the CircleCI logo at the top of the window to navigate to your user homepage and select an organization.      Figure 34. Access your user homepage          Choose a config.yml option in the modal. You can choose from the following:    Fastest: Use a CircleCI .circleci/config.yml you have already committed to your repository. For guidance on creating a config.yml file, see the  Configuration Introduction. You will also need to specify a branch.   Faster: Commit a starter CI pipeline to a new circleci-project-setup branch of your repository.   Fast: View, edit, and commit a template config.yml.      Select Set Up Project.     CircleCI uses the specified .circleci/config.yml file to run your pipeline. You can see the output in the CircleCI dashboard.   To make changes to your pipeline, choose one of the following:     Edit the config file in your repository,   Select the ellipsis () next your project in the Pipelines or Projects dashboard and choose Configuration File. This opens the CircleCI configuration editor, from where you can edit and commit your config.yml file.   Access the configuration editor using the Edit Config button from a the Pipelines page when you have a project and branch selected.        Figure 35. Access and edit a config file      See also      Configuration Introduction    Sample config.yml files    Configuration reference    Using the CircleCI Configuration Editor     Suggest an edit to this pageMake a contribution Learn how to contributeStill need help? Ask the CircleCI community Join the research community Visit our Support site DocsTerms of UsePrivacy PolicyCookie PolicySecurity© 2025 Circle Internet Services, Inc., All Rights Reserved.\n\nUsing CircleCI server? Use the  Set up a project steps below. Rather than Organization Home you will see Dashboard in the web app sidebar.  If you have integrated your code with the  CircleCI GitHub App,  GitLab, or  Bitbucket Data Center, the steps in this section apply to you.   Follow these steps to create a new project in CircleCI:     In the  CircleCI web app, select Organization Home in the sidebar.   Select Create Project at the top of the page, or anywhere in the Create a project card if this is your first project.     Figure 1. Create a project button      Figure 2. Create a project card view when creating your first project    Choose an option to match the work you want to do in your project.     Figure 3. Tell CircleCI what your project is for    Give your project a descriptive name and then select Next: Set up a pipeline.      Project names must meet the following requirements:     Begin with a letter.   Be 3-40 characters long.   Contain only letters, numbers, or the following characters: " - _ . : ! & + [ ] " ;.              Figure 4. Name your project    Next, set up your first pipeline for your project. Pipelines orchestrate executable commands and scripts for your CI/CD processes. The first step is to name your pipeline. Use a name that describes the purpose of the pipeline, for example, build-and-test. Then select Next: Choose a repo.     Figure 5. Set up a pipeline    Choose a repo to connect to your project.  If you do not see your repo listed, select Add to access repositories from GitHub. Select GitHub and then Authorize in GitHub      First GitHub project? If this is the first GitHub project you are creating, you will be redirected to GitHub and asked to install and authorise the CircleCI GitHub App. At this point you can choose to connect CircleCI to all your repositories, or select a subset of repositories to connect. This is a one-time action that can be done by an organization administrator or someone who has admin access to a repository in your org.           Figure 6. Choose a repo to connect your code to your project    In this next step CircleCI will prepare a config file for you, unless your repo already contains a CircleCI config file. In a later step you will commit this config to your repo on a new branch. If you do already have a CircleCI config file in your repo it will be displayed. Once you have your config, select Next: set up your triggers.     Figure 7. Set up your CircleCI config file    Set up triggers for your pipeline. A single GitHub App trigger is set up by default to build your project on every commit to your repo. You can  add more triggers at this point too.     Figure 8. Set up triggers for your pipeline    Next you can review everything you have just set up, then select Commit config and run, or Finish setup if you already have a config file in your repo.     Figure 9. Review and finish setup      Once your project is created you will land on your pipelines page.          Project names must meet the following requirements:     Begin with a letter.   Be 3-40 characters long.   Contain only letters, numbers, or the following characters: " - _ . : ! & + [ ] " ;.         First GitHub project? If this is the first GitHub project you are creating, you will be redirected to GitHub and asked to install and authorise the CircleCI GitHub App. At this point you can choose to connect CircleCI to all your repositories, or select a subset of repositories to connect. This is a one-time action that can be done by an organization administrator or someone who has admin access to a repository in your org.           Follow these steps to create a new project in CircleCI:     In the  CircleCI web app, select Organization Home in the sidebar.   Select Create Project at the top of the page, or anywhere in the Create a project card if this is your first project.     Figure 10. Create a project button      Figure 11. Create a project card view when creating your first project    Choose an option to match the work you want to do in your project.     Figure 12. Tell CircleCI what your project is for    Give your project a descriptive name and then select Next: Set up a pipeline.      Project names must meet the following requirements:     Begin with a letter.   Be 3-40 characters long.   Contain only letters, numbers, or the following characters: " - _ . : ! & + [ ] " ;.              Figure 13. Name your project    Next, set up your first pipeline for your project. Pipelines orchestrate executable commands and scripts for your CI/CD processes. The first step is to name your pipeline. Use a name that describes the purpose of the pipeline, for example, build-and-test. Then select Next: Choose a repo.     Figure 14. Set up a pipeline    Choose a repo to connect to your project. If you do not see your repo listed, select Add or Connect to GitLab Cloud to authorise access to your GitLab repositories.  Choose a repo to connect your code to your project      Figure 15. Choose a repo to connect your code to your project      First GitLab project? If you are creating the first GitLab project for your org, you will be redirected to GitLab to authorise the integration. This is a one-time action that can be done by an organization administrator or someone who has admin access to a repository in your org.         In the Create New Project window, ensure you have the right repo selected in the dropdown. If you have a CircleCI config file already available in your repo, CircleCI will detect it. If not you can select an option for adding one:     Figure 16. Set up a new GitLab project     Fastest: Use a config file that already exists in your repository.   Faster: Let CircleCI pick a configuration file for you, and commit this to a new branch in you repository.   Fast: View and edit a starter config file in the CircleCI web app and commit that to your repository yourself.      Select Create Project at the bottom of the window.   If you chose the fastest/faster options you will now be on the pipelines page of the CircleCI web app. If you chose "fast" you have some options:    Select Commit and Run to commit your custom configuration file on a new branch called circleci-project-setup.     Figure 17. Use a generated config file    Select Use Existing Config for the option to download the generated config and instructions to commit this or another CircleCI configuration file to your repository directly. The select Start Building.     Figure 18. Instructions for using an existing config file                Project names must meet the following requirements:     Begin with a letter.   Be 3-40 characters long.   Contain only letters, numbers, or the following characters: " - _ . : ! & + [ ] " ;.           First GitLab project? If you are creating the first GitLab project for your org, you will be redirected to GitLab to authorise the integration. This is a one-time action that can be done by an organization administrator or someone who has admin access to a repository in your org.         Follow these steps to create a new project in CircleCI:     In the  CircleCI web app, select Organization Home in the sidebar.   Select Create Project at the top of the page, or anywhere in the Create a project card if this is your first project.     Figure 19. Create a project button      Figure 20. Create a project card view when creating your first project    Choose an option to match the work you want to do in your project.     Figure 21. Tell CircleCI what your project is for    Give your project a descriptive name and then select Next: Set up a pipeline.      Project names must meet the following requirements:     Begin with a letter.   Be 3-40 characters long.   Contain only letters, numbers, or the following characters: " - _ . : ! & + [ ] " ;.              Figure 22. Name your project    Next, set up your first pipeline for your project. Pipelines orchestrate executable commands and scripts for your CI/CD processes. The first step is to name your pipeline. Use a name that describes the purpose of the pipeline, for example, build-and-test. Then select Next: Choose a repo.     Figure 23. Set up a pipeline    Choose a repo to connect to your project. If you do not see your repo listed, select Add or Connect to GitLab self-managed to access repositories from your GitLab self-managed instance. Select GitLab self-managed and then Authorize in GitLab self-managed     Figure 24. Choose a repo to connect your code to your project      Figure 25. Authorize GitLab self-managed    In the Create New Project window, you have some options:     Figure 26. Set up your new GitLab self-managed project       If this is your first GitLab self-managed project you will now set up your integration:     Verify your GitLab URL   Generate an add a personal access token   Add your known hosts, following the instructions in the app             Use the repository dropdown menu to tell CircleCI where your code is stored.   Select Create Project. You will then be redirected to the Pipelines page.   The express CircleCI configuration setup is not currently available for GitLab self-managed projects. You will need to add a .circleci/config.yml file in your repository if it has not yet been set up. If the repository you selected already contains a .circleci/config.yml, push a commit to see your pipeline on the dashboard.      For guidance on creating a config.yml file, see the following pages:      Configuration introduction    Sample config.yml files    Configuration reference                        Project names must meet the following requirements:     Begin with a letter.   Be 3-40 characters long.   Contain only letters, numbers, or the following characters: " - _ . : ! & + [ ] " ;.                If this is your first GitLab self-managed project you will now set up your integration:     Verify your GitLab URL   Generate an add a personal access token   Add your known hosts, following the instructions in the app      For guidance on creating a config.yml file, see the following pages:      Configuration introduction    Sample config.yml files    Configuration reference         Bitbucket Data Center support is in closed preview. To get access, sign up  here.        Follow these steps to create a new project in CircleCI:     In the  CircleCI web app, select Organization Home in the sidebar.   Select Create Project at the top of the page, or anywhere in the Create a project card if this is your first project.     Figure 27. Create a project button      Figure 28. Create a project card view when creating your first project    Choose an option to match the work you want to do in your project.     Figure 29. Tell CircleCI what your project is for    Give your project a descriptive name and then select Next: Set up a pipeline.      Project names must meet the following requirements:     Begin with a letter.   Be 3-40 characters long.   Contain only letters, numbers, or the following characters: " - _ . : ! & + [ ] " ;.              Figure 30. Name your project    Next, set up your first pipeline for your project. Pipelines orchestrate executable commands and scripts for your CI/CD processes. The first step is to name your pipeline. Use a name that describes the purpose of the pipeline, for example, build-and-test. Then select Next: Choose a repo.     Figure 31. Set up a pipeline    Choose a repo to connect to your project. If you do not see your repo listed, select Add to access repositories from GitHub. Select Bitbucket Data Center and then Authorize in Bitbucket Data Center     Figure 32. Access Bitbucket data center repos    Next, follow the steps on the  Bitbucket integration setup page to set up the following:    An integration with your Bitbucket Data Center instance (if not already set up for your org).   Set up a pipeline and trigger for your project.   Add a configuration file to your repo.        Bitbucket Data Center support is in closed preview. To get access, sign up  here.         Project names must meet the following requirements:     Begin with a letter.   Be 3-40 characters long.   Contain only letters, numbers, or the following characters: " - _ . : ! & + [ ] " ;.           If you authenticated CircleCI with either the  GitHub OAuth app or  Bitbucket Cloud, or if you use CircleCI server, the steps in this section apply to you.     Can’t see your project? Select the CircleCI logo at the top of the window to navigate to your user homepage and select an organization.      Figure 34. Access your user homepage\n\n\n\nJoin teammates on CircleCI2 months ago2 min readCloudOn This PagePrerequisitesFind your teamJoin an existing CircleCI organization via an inviteJoin an existing CircleCI organization with a GitHub OAuth app integrationJoin an existing CircleCI organization with a Bitbucket Cloud integrationInvite teammates to join your organizationSee also   After setting up an organization in CircleCI, ensure your whole team get access.     Prerequisites     A CircleCI account connected to your code. You can  sign up for free.   At least one project created in your organization. See the  Create a project page for instructions.       Find your team   After creating an account, you can join an existing CircleCI organization using the Find Your Team dropdown menu in the Join Your Teammates card on the  homepage.        To join an organization, there are three options:      Join via an invite    Search via GitHub    Search via Bitbucket Cloud     These options are also available at any time using the Join Organization menu on your  homepage. Steps for each option are outlined in the following sections.   Join an existing CircleCI organization via an invite    Reach out to your organization admin to request an invite   Your organization admin will need to follow the steps below in the  Invite teammates to join your organization section to send you an email invite. Once you receive your invitation, follow the link to log in and join your organization      Join an existing CircleCI organization with a GitHub OAuth app integration    Select "Search via GitHub" from the Find Your Team dropdown   Authorize the GitHub OAuth app for read access to your GitHub organization membership   After authorization, you will be redirected to CircleCI where we will list all matching CircleCI organizations that you are eligible to join. Select Join Organizations to successfully complete joining these organizations in CircleCI.     If you do not see the organization you would like to join listed, you will need to receive an invite to join from an organization admin. Reach out to your admin to request an invite, and send them a link to this help doc for reference.            Join an existing CircleCI organization with a Bitbucket Cloud integration    Select "Search via Bitbucket" from the Find Your Team dropdown to be redirected to Bitbucket Cloud.   Enter your Bitbucket Cloud credentials to authorize CircleCI to your Bitbucket Cloud account.   After authorization, you will be redirected back to CircleCI and will be added to your organization.        Invite teammates to join your organization   The steps in this section show how an org admin can invite teammates to join their organization.       To find out which GitHub integration type you have, check your Organization slug at Organization settings  Overview. OAuth authenticated orgs are structured as follows:     github/<your-org-name> or gh/<your-org-name>   bitbucket/<your-org-name> or bb/<your-org-name>     An organization slug for a GitHub App integration is in the following format:     circleci/<UID>          GitHub App / GitLab / Bitbucket Data CenterGitHub OAuth / Bitbucket Cloud      Bitbucket Data Center support is in closed preview. To get access, sign up  here.          In the CircleCI web app, select your org from the org cards on your user homepage.   Navigate to Organization Settings  People, then select Invite.   To send out email invites, enter your team members' email addresses. Multiple emails can be separated by a space. Then, assign their role in your CircleCI organization. If you need to assign different roles to different team members, add team members in the Invite form based on role.   Once they join your org, you can then also assign each team member a role on an individual project level. See the  Manage roles and permissions page for more details.               In the CircleCI web app, select your org from the org cards on your user homepage.   Select Organization Setting from the sidebar and select People.   Select Copy Invite Link — an invite message is now copied to your clipboard.   Past the invite message to your teammates via email or whatever method you prefer.               See also      CircleCI roles and permissions overview     Suggest an edit to this pageMake a contribution Learn how to contributeStill need help? Ask the CircleCI community Join the research community Visit our Support site\n\nJoin teammates on CircleCI2 months ago2 min readCloudOn This PagePrerequisitesFind your teamJoin an existing CircleCI organization via an inviteJoin an existing CircleCI organization with a GitHub OAuth app integrationJoin an existing CircleCI organization with a Bitbucket Cloud integrationInvite teammates to join your organizationSee also   After setting up an organization in CircleCI, ensure your whole team get access.     Prerequisites     A CircleCI account connected to your code. You can  sign up for free.   At least one project created in your organization. See the  Create a project page for instructions.       Find your team   After creating an account, you can join an existing CircleCI organization using the Find Your Team dropdown menu in the Join Your Teammates card on the  homepage.        To join an organization, there are three options:      Join via an invite    Search via GitHub    Search via Bitbucket Cloud     These options are also available at any time using the Join Organization menu on your  homepage. Steps for each option are outlined in the following sections.   Join an existing CircleCI organization via an invite    Reach out to your organization admin to request an invite   Your organization admin will need to follow the steps below in the  Invite teammates to join your organization section to send you an email invite. Once you receive your invitation, follow the link to log in and join your organization      Join an existing CircleCI organization with a GitHub OAuth app integration    Select "Search via GitHub" from the Find Your Team dropdown   Authorize the GitHub OAuth app for read access to your GitHub organization membership   After authorization, you will be redirected to CircleCI where we will list all matching CircleCI organizations that you are eligible to join. Select Join Organizations to successfully complete joining these organizations in CircleCI.     If you do not see the organization you would like to join listed, you will need to receive an invite to join from an organization admin. Reach out to your admin to request an invite, and send them a link to this help doc for reference.            Join an existing CircleCI organization with a Bitbucket Cloud integration    Select "Search via Bitbucket" from the Find Your Team dropdown to be redirected to Bitbucket Cloud.   Enter your Bitbucket Cloud credentials to authorize CircleCI to your Bitbucket Cloud account.   After authorization, you will be redirected back to CircleCI and will be added to your organization.        Invite teammates to join your organization   The steps in this section show how an org admin can invite teammates to join their organization.       To find out which GitHub integration type you have, check your Organization slug at Organization settings  Overview. OAuth authenticated orgs are structured as follows:     github/<your-org-name> or gh/<your-org-name>   bitbucket/<your-org-name> or bb/<your-org-name>     An organization slug for a GitHub App integration is in the following format:     circleci/<UID>          GitHub App / GitLab / Bitbucket Data CenterGitHub OAuth / Bitbucket Cloud      Bitbucket Data Center support is in closed preview. To get access, sign up  here.          In the CircleCI web app, select your org from the org cards on your user homepage.   Navigate to Organization Settings  People, then select Invite.   To send out email invites, enter your team members' email addresses. Multiple emails can be separated by a space. Then, assign their role in your CircleCI organization. If you need to assign different roles to different team members, add team members in the Invite form based on role.   Once they join your org, you can then also assign each team member a role on an individual project level. See the  Manage roles and permissions page for more details.               In the CircleCI web app, select your org from the org cards on your user homepage.   Select Organization Setting from the sidebar and select People.   Select Copy Invite Link — an invite message is now copied to your clipboard.   Past the invite message to your teammates via email or whatever method you prefer.               See also      CircleCI roles and permissions overview     Suggest an edit to this pageMake a contribution Learn how to contributeStill need help? Ask the CircleCI community Join the research community Visit our Support site DocsTerms of UsePrivacy PolicyCookie PolicySecurity© 2025 Circle Internet Services, Inc., All Rights Reserved.\n\nIf you do not see the organization you would like to join listed, you will need to receive an invite to join from an organization admin. Reach out to your admin to request an invite, and send them a link to this help doc for reference.   To find out which GitHub integration type you have, check your Organization slug at Organization settings  Overview. OAuth authenticated orgs are structured as follows:     github/<your-org-name> or gh/<your-org-name>   bitbucket/<your-org-name> or bb/<your-org-name>     An organization slug for a GitHub App integration is in the following format:     circleci/<UID>         Bitbucket Data Center support is in closed preview. To get access, sign up  here.          In the CircleCI web app, select your org from the org cards on your user homepage.   Navigate to Organization Settings  People, then select Invite.   To send out email invites, enter your team members' email addresses. Multiple emails can be separated by a space. Then, assign their role in your CircleCI organization. If you need to assign different roles to different team members, add team members in the Invite form based on role.   Once they join your org, you can then also assign each team member a role on an individual project level. See the  Manage roles and permissions page for more details.          Bitbucket Data Center support is in closed preview. To get access, sign up  here.       In the CircleCI web app, select your org from the org cards on your user homepage.   Select Organization Setting from the sidebar and select People.   Select Copy Invite Link — an invite message is now copied to your clipboard.   Past the invite message to your teammates via email or whatever method you prefer.\n\n\n\nQuickstart guide1 month ago3 min readCloudOn This PagePrerequisites1. Connect your code2. Dig into your first pipeline3. Debug and iterateNext steps   This quickstart provides a guided tour through setting up a project, collaborating, and tools to iterate on and debug your build configuration. The following sections cover the following:     Create a project, connecting some existing code to CircleCI.   Inviting team members to collaborate on your new project.   Use the VS Code extension to debug and extend your config.   SSH into a build to debug your project.     If you would rather jump to a full list of CircleCI config.yml options, see the  Configuration reference.     Prerequisites     A CircleCI account. You can  sign up for free.   A code repository you want to build on CircleCI.        1. Connect your code    Create a project, connect your new code repository, and commit a CircleCI configuration file. View your project build in the CircleCI app.            This guide assumes you have signed up and   connected to GitHub, Bitbucket or GitLab          Check your project slug to discover which GitHub integration you have set up:     Head to the  CircleCI web app and select your org from the cards on your user homepage.   Select Projects from the sidebar and locate your project from the list. You can use the search to help.   Select the ellipsis menu () next to your project and select Project Settings. The project slug is listed on the project settings homepage.    GitHub App: Project slug starts with circleci followed by UUIDs. For example, circleci/34R3kN5RtfEE7v4sa4nWAU/4nYdoKGkb6RXn7JGt8SQtg).   GitHub OAuth app: Project slug is human readable. For example, github/circleci/circleci-demo-workflows.        For more information about the differences, see the  VCS integration overview.        GitHub AppGitLab & Bitbucket Data CenterGitHub OAuth app & Bitbucket Cloud    1. Create a project In the  CircleCI web app select your org, then select Create Project, then follow the instructions in the app. Don’t see these options? Select the CircleCI logo in the top bar to get back to your user homepage and check you have the correct org selected.        2. Set up a pipeline Follow the in-app instructions to set up your pipelinem including connecting your code, preparing a config file and reviewing triggers. For a more detailed look at this process see the  Create a project guide.        3. Commit and run Once you have gone through the pipeline setup process in the app you have everything you need to commit your config (unless you have a config in your repo already) and build. Review your project details and select Commit config and run.        4. Congratulations 🎉 You should soon have a passing pipeline. In the next sections we will cover ways to modify and debug your config.           1. Create a project In the CircleCI web app, select  Projects from the sidebar. Click Create Project, then select the repository you would like to connect from the dropdown. Don’t see these options? Use the org selector in the top left corner to find the correct organization.        2. Select a config.yml In the “Select your  config.yml file” modal, select Fast, then give your project a name, and click Create Project. If you are authenticated through the GitHub App, you also need to set up SSH access for your project at this point.        3. CircleCI config editor You are now in the  CircleCI config editor, pre-populated with a sample config.yml file. You can swap out this config for an alternative by clicking Change: Hello World.        4. Commit your config Click Commit and Run. This will create a .circleci/config.yml file at the root of your repository on a new branch called update-circleci-config.        5. Congratulations 🎉 You should soon have a passing pipeline. If you are happy with this configuration, merge it into your main branch, or continue to make changes.           1. Set up a project In the  CircleCI web app select your org, then select Set up a Project, then select Set up Project next to your project in the list. Don’t see these options? Select the CircleCI logo in the top bar to get back to your user homepage and check you have the correct org selected.        2. Select a config.yml In the “Select your config.yml file” modal, select Faster, then click Set Up Project.        3. Congratulations 🎉 You should soon have a passing pipeline. In the next sections we will cover ways to modify and debug your config.           2. Dig into your first pipeline    Explore your passing pipeline and invite your teammates to join you, for free. By collaborating, you can troubleshoot, get pull requests approved, and build and test faster.       1. So, what just happened? Expand your workflow and select a job to view the steps that ran. Use the tabs along the top to access test results, timing data, artifacts, and resource usage metrics.        2. View step output Exand any step to view the build output. You can search, share or download the output for collaboration and debugging. If a step fails, use the  Explain this error button for help.        3. Invite teammates Invite teammates to collaborate on your projects. Navigate to Organization Settings > People to generate invites and get further instructions. Collaborators can view and follow your projects. Teammates can make a free CircleCI account at any time to view your pipelines, even if they are not committing any code.       3. Debug and iterate    Discover CircleCI features to help debug and configure your builds.       1. Rerun with SSH To access a job's build environment for troubleshooting, rerun the job with SSH access. The VM remains active for 10 minutes after the pipeline finishes. For full details, see the  Debug with SSH page.        2. VS Code extention Using the  CircleCI VS Code extention, validate your CircleCI config file. Get help with troubleshooting config updates and help keeping dependencies up to date.            Next steps      CircleCI foundation videos    Introduction to configuration    CircleCI concepts    Benefits of CircleCI Free Plan     Suggest an edit to this pageMake a contribution Learn how to contributeStill need help? Ask the CircleCI community Join the research community Visit our Support site\n\nQuickstart guide1 month ago3 min readCloudOn This PagePrerequisites1. Connect your code2. Dig into your first pipeline3. Debug and iterateNext steps   This quickstart provides a guided tour through setting up a project, collaborating, and tools to iterate on and debug your build configuration. The following sections cover the following:     Create a project, connecting some existing code to CircleCI.   Inviting team members to collaborate on your new project.   Use the VS Code extension to debug and extend your config.   SSH into a build to debug your project.     If you would rather jump to a full list of CircleCI config.yml options, see the  Configuration reference.     Prerequisites     A CircleCI account. You can  sign up for free.   A code repository you want to build on CircleCI.        1. Connect your code    Create a project, connect your new code repository, and commit a CircleCI configuration file. View your project build in the CircleCI app.            This guide assumes you have signed up and   connected to GitHub, Bitbucket or GitLab          Check your project slug to discover which GitHub integration you have set up:     Head to the  CircleCI web app and select your org from the cards on your user homepage.   Select Projects from the sidebar and locate your project from the list. You can use the search to help.   Select the ellipsis menu () next to your project and select Project Settings. The project slug is listed on the project settings homepage.    GitHub App: Project slug starts with circleci followed by UUIDs. For example, circleci/34R3kN5RtfEE7v4sa4nWAU/4nYdoKGkb6RXn7JGt8SQtg).   GitHub OAuth app: Project slug is human readable. For example, github/circleci/circleci-demo-workflows.        For more information about the differences, see the  VCS integration overview.        GitHub AppGitLab & Bitbucket Data CenterGitHub OAuth app & Bitbucket Cloud    1. Create a project In the  CircleCI web app select your org, then select Create Project, then follow the instructions in the app. Don’t see these options? Select the CircleCI logo in the top bar to get back to your user homepage and check you have the correct org selected.        2. Set up a pipeline Follow the in-app instructions to set up your pipelinem including connecting your code, preparing a config file and reviewing triggers. For a more detailed look at this process see the  Create a project guide.        3. Commit and run Once you have gone through the pipeline setup process in the app you have everything you need to commit your config (unless you have a config in your repo already) and build. Review your project details and select Commit config and run.        4. Congratulations 🎉 You should soon have a passing pipeline. In the next sections we will cover ways to modify and debug your config.           1. Create a project In the CircleCI web app, select  Projects from the sidebar. Click Create Project, then select the repository you would like to connect from the dropdown. Don’t see these options? Use the org selector in the top left corner to find the correct organization.        2. Select a config.yml In the “Select your  config.yml file” modal, select Fast, then give your project a name, and click Create Project. If you are authenticated through the GitHub App, you also need to set up SSH access for your project at this point.        3. CircleCI config editor You are now in the  CircleCI config editor, pre-populated with a sample config.yml file. You can swap out this config for an alternative by clicking Change: Hello World.        4. Commit your config Click Commit and Run. This will create a .circleci/config.yml file at the root of your repository on a new branch called update-circleci-config.        5. Congratulations 🎉 You should soon have a passing pipeline. If you are happy with this configuration, merge it into your main branch, or continue to make changes.           1. Set up a project In the  CircleCI web app select your org, then select Set up a Project, then select Set up Project next to your project in the list. Don’t see these options? Select the CircleCI logo in the top bar to get back to your user homepage and check you have the correct org selected.        2. Select a config.yml In the “Select your config.yml file” modal, select Faster, then click Set Up Project.        3. Congratulations 🎉 You should soon have a passing pipeline. In the next sections we will cover ways to modify and debug your config.           2. Dig into your first pipeline    Explore your passing pipeline and invite your teammates to join you, for free. By collaborating, you can troubleshoot, get pull requests approved, and build and test faster.       1. So, what just happened? Expand your workflow and select a job to view the steps that ran. Use the tabs along the top to access test results, timing data, artifacts, and resource usage metrics.        2. View step output Exand any step to view the build output. You can search, share or download the output for collaboration and debugging. If a step fails, use the  Explain this error button for help.        3. Invite teammates Invite teammates to collaborate on your projects. Navigate to Organization Settings > People to generate invites and get further instructions. Collaborators can view and follow your projects. Teammates can make a free CircleCI account at any time to view your pipelines, even if they are not committing any code.       3. Debug and iterate    Discover CircleCI features to help debug and configure your builds.       1. Rerun with SSH To access a job's build environment for troubleshooting, rerun the job with SSH access. The VM remains active for 10 minutes after the pipeline finishes. For full details, see the  Debug with SSH page.        2. VS Code extention Using the  CircleCI VS Code extention, validate your CircleCI config file. Get help with troubleshooting config updates and help keeping dependencies up to date.            Next steps      CircleCI foundation videos    Introduction to configuration    CircleCI concepts    Benefits of CircleCI Free Plan     Suggest an edit to this pageMake a contribution Learn how to contributeStill need help? Ask the CircleCI community Join the research community Visit our Support site DocsTerms of UsePrivacy PolicyCookie PolicySecurity© 2025 Circle Internet Services, Inc., All Rights Reserved.\n\nCheck your project slug to discover which GitHub integration you have set up:     Head to the  CircleCI web app and select your org from the cards on your user homepage.   Select Projects from the sidebar and locate your project from the list. You can use the search to help.   Select the ellipsis menu () next to your project and select Project Settings. The project slug is listed on the project settings homepage.    GitHub App: Project slug starts with circleci followed by UUIDs. For example, circleci/34R3kN5RtfEE7v4sa4nWAU/4nYdoKGkb6RXn7JGt8SQtg).   GitHub OAuth app: Project slug is human readable. For example, github/circleci/circleci-demo-workflows.        For more information about the differences, see the  VCS integration overview.     1. Create a project In the  CircleCI web app select your org, then select Create Project, then follow the instructions in the app. Don’t see these options? Select the CircleCI logo in the top bar to get back to your user homepage and check you have the correct org selected.        2. Set up a pipeline Follow the in-app instructions to set up your pipelinem including connecting your code, preparing a config file and reviewing triggers. For a more detailed look at this process see the  Create a project guide.        3. Commit and run Once you have gone through the pipeline setup process in the app you have everything you need to commit your config (unless you have a config in your repo already) and build. Review your project details and select Commit config and run.        4. Congratulations 🎉 You should soon have a passing pipeline. In the next sections we will cover ways to modify and debug your config.         1. Create a project In the CircleCI web app, select  Projects from the sidebar. Click Create Project, then select the repository you would like to connect from the dropdown. Don’t see these options? Use the org selector in the top left corner to find the correct organization.        2. Select a config.yml In the “Select your  config.yml file” modal, select Fast, then give your project a name, and click Create Project. If you are authenticated through the GitHub App, you also need to set up SSH access for your project at this point.        3. CircleCI config editor You are now in the  CircleCI config editor, pre-populated with a sample config.yml file. You can swap out this config for an alternative by clicking Change: Hello World.        4. Commit your config Click Commit and Run. This will create a .circleci/config.yml file at the root of your repository on a new branch called update-circleci-config.        5. Congratulations 🎉 You should soon have a passing pipeline. If you are happy with this configuration, merge it into your main branch, or continue to make changes.         1. Set up a project In the  CircleCI web app select your org, then select Set up a Project, then select Set up Project next to your project in the list. Don’t see these options? Select the CircleCI logo in the top bar to get back to your user homepage and check you have the correct org selected.        2. Select a config.yml In the “Select your config.yml file” modal, select Faster, then click Set Up Project.        3. Congratulations 🎉 You should soon have a passing pipeline. In the next sections we will cover ways to modify and debug your config.\n\n\n\nConfigure a Node.js application on CircleCI1 month ago3 min readCloudServer v4+On This PagePrerequisitesConfiguration walkthrough1. Specify a version2. Use the Node orb3. Create jobsa. Build and test the appb. Deploy the app3. Create a workflow4. Add jobs to the workflow5. ConclusionFull configuration fileSee also   This quickstart guide covers integrating a Node.JS project with CircleCI. This guide is designed to help you create a basic CircleCI configuration file to build, test and deploy your Node.JS project. After completing this quickstart you can edit and optimize the config to fit the requirements of your project.     Prerequisites      A CircleCI account   A Node.JS project located in a supported VCS       Configuration walkthrough   Every CircleCI project requires a configuration file called  .circleci/config.yml. Follow the steps below to create a complete config.yml file.   1. Specify a version  Every CircleCI config.yml starts with the version key. This key is used to issue warnings about breaking changes.    version: 2.1    2.1 is the latest CircleCI version, and it ensures you have access to all our latest features and improvements.    2. Use the Node orb  The Node.js  orb contains a set of prepackaged CircleCI configurations you can use to install Node.js and its package managers (npm, yarn). Best of all, packages are installed with caching by default, and support for Linux x86_64, macOS x86_64, and Arm64 is automatically included. Learn more about  orbs.   To add the orb to your config, insert:    orbs:
  node: circleci/node@5.0.2       When using an orb, it is a good idea to check the  Orb Registry to ensure you are using the most recent version, or the version that fits best with your specific project.         3. Create jobs  Jobs are the building blocks of your config. Jobs are collections of steps, which run commands/scripts as required. All of the steps in the job are executed in a single unit, either within a fresh container or Virtual Machine. Learn more about jobs on the  Jobs and Steps page.   A common ask from developers who are getting started with CircleCI is to perform 3 basic tasks: build, test and deploy. This section guides you through each of the config changes needed. Because we are using the official Node orb, we can use commands that are built into the orb to keep our config simple and succinct:   a. Build and test the app  If you are using yarn:    jobs:
  build_and_test: # this can be any name you choose
    executor: node/default # use the default executor defined within the orb
    steps:
      - checkout
      - node/install-packages:
          pkg-manager: yarn
      - run:
          command: yarn test
          name: Run tests
      - run:
          command: yarn build
          name: Build app
      - persist_to_workspace:
          root: ~/project
          paths: .    Similarly, if you are using npm:    jobs:
  build_and_test: # this can be any name you choose
    executor: node/default # use the default executor defined within the orb
    steps:
      - checkout
      - node/install-packages:
          pkg-manager: npm
      - run:
          command: npm run test
          name: Run tests
      - run:
          command: npm run build
          name: Build app
      - persist_to_workspace:
          root: ~/project
          paths:
            - .    Because we are using the Node orb, this job will install your Node packages with automated caching and best practices applied. Note that it requires a lock file.    b. Deploy the app  In this quickstart guide, we will deploy to  Heroku. We can do this using the official Heroku orb by adding a new line into our orb section. The Heroku orb contains a set of prepackaged CircleCI configurations you can use to deploy applications to Heroku. Learn more about the  Heroku orb.    orbs:
  node: circleci/node@4.7.0
  heroku: circleci/heroku@1.2.6    We then need to add a job to our list to take care of the deploy step:    jobs:
  # ...previous job(s)...
  deploy: # this can be any name you choose
    executor: heroku/default
    steps:
      - attach_workspace:
          at: ~/project
      - heroku/deploy-via-git:
          force: true # force push when pushing to the heroku remote, see: https://devcenter.heroku.com/articles/git       Environment variables containing the necessary secrets such as HEROKU_API_KEY and HEROKU_APP_NAME can be set up in the CircleCI web app. Learn more about  environment variables.          3. Create a workflow  A workflow is a set of rules for defining a collection of jobs and their run order. Workflows support complex job orchestration using a set of configuration keys to help you resolve failures sooner. Inside the workflow, you define the jobs you want to run. CircleCI will run this workflow on every commit. Learn more about  workflow configuration.    workflows:
  build_test_deploy: # this can be any name you choose     4. Add jobs to the workflow  Now that we have our workflow, build_test_deploy, we can use it to orchestrate the running of our build_and_test and deploy jobs. Refer to the  Using Workflows to Orchestrate Jobs page for more details about orchestrating jobs with concurrent, sequential, and manual approval workflows.    workflows:
  build_test_deploy: # this can be any name you choose
    jobs:
      - build_and_test
      - deploy:
          requires:
            - build_and_test # only deploy if the build_and_test job has completed
          filters:
            branches:
              only: main # only deploy when on main     5. Conclusion  You just set up a Node.js app to build on CircleCI. Check out your project’s  pipeline page to see how this looks when building on CircleCI.      Deploy options? For alternative deployment targets, search the  orb registry, where you will find integrations such as  Kubernetes,  AWS ECS,  GCP GKE, and more.           Full configuration file    version: 2.1
orbs:
  node: circleci/node@5.0.2
  heroku: circleci/heroku@1.2.6

jobs:
  build_and_test:
    executor: node/default
    steps:
      - checkout
      - node/install-packages:
          pkg-manager: yarn
      - run:
          command: yarn test
          name: Run tests
      - run:
          command: yarn build
          name: Build app
      - persist_to_workspace:
          root: ~/project
          paths:
            - .

  deploy: # this can be any name you choose
    executor: heroku/default
    steps:
      - attach_workspace:
          at: ~/project
      - heroku/deploy-via-git:
          force: true # force push when pushing to the heroku remote, see: https://devcenter.heroku.com/articles/git

workflows:
  test_my_app:
    jobs:
      - build_and_test
      - deploy:
          requires:
            - build_and_test # only deploy if the build_and_test job has completed
          filters:
            branches:
              only: main # only deploy when on main      See also      Continuous deployment of Node apps to Heroku    Continuous deployment of Node.js to Azure VM    Troubleshoot Node.js build and test suite timeouts   Tutorial:  Test splitting to speed up your pipelines     Suggest an edit to this pageMake a contribution Learn how to contributeStill need help? Ask the CircleCI community Join the research community Visit our Support site\n\nConfigure a Node.js application on CircleCI1 month ago3 min readCloudServer v4+On This PagePrerequisitesConfiguration walkthrough1. Specify a version2. Use the Node orb3. Create jobsa. Build and test the appb. Deploy the app3. Create a workflow4. Add jobs to the workflow5. ConclusionFull configuration fileSee also   This quickstart guide covers integrating a Node.JS project with CircleCI. This guide is designed to help you create a basic CircleCI configuration file to build, test and deploy your Node.JS project. After completing this quickstart you can edit and optimize the config to fit the requirements of your project.     Prerequisites      A CircleCI account   A Node.JS project located in a supported VCS       Configuration walkthrough   Every CircleCI project requires a configuration file called  .circleci/config.yml. Follow the steps below to create a complete config.yml file.   1. Specify a version  Every CircleCI config.yml starts with the version key. This key is used to issue warnings about breaking changes.    version: 2.1    2.1 is the latest CircleCI version, and it ensures you have access to all our latest features and improvements.    2. Use the Node orb  The Node.js  orb contains a set of prepackaged CircleCI configurations you can use to install Node.js and its package managers (npm, yarn). Best of all, packages are installed with caching by default, and support for Linux x86_64, macOS x86_64, and Arm64 is automatically included. Learn more about  orbs.   To add the orb to your config, insert:    orbs:
  node: circleci/node@5.0.2       When using an orb, it is a good idea to check the  Orb Registry to ensure you are using the most recent version, or the version that fits best with your specific project.         3. Create jobs  Jobs are the building blocks of your config. Jobs are collections of steps, which run commands/scripts as required. All of the steps in the job are executed in a single unit, either within a fresh container or Virtual Machine. Learn more about jobs on the  Jobs and Steps page.   A common ask from developers who are getting started with CircleCI is to perform 3 basic tasks: build, test and deploy. This section guides you through each of the config changes needed. Because we are using the official Node orb, we can use commands that are built into the orb to keep our config simple and succinct:   a. Build and test the app  If you are using yarn:    jobs:
  build_and_test: # this can be any name you choose
    executor: node/default # use the default executor defined within the orb
    steps:
      - checkout
      - node/install-packages:
          pkg-manager: yarn
      - run:
          command: yarn test
          name: Run tests
      - run:
          command: yarn build
          name: Build app
      - persist_to_workspace:
          root: ~/project
          paths: .    Similarly, if you are using npm:    jobs:
  build_and_test: # this can be any name you choose
    executor: node/default # use the default executor defined within the orb
    steps:
      - checkout
      - node/install-packages:
          pkg-manager: npm
      - run:
          command: npm run test
          name: Run tests
      - run:
          command: npm run build
          name: Build app
      - persist_to_workspace:
          root: ~/project
          paths:
            - .    Because we are using the Node orb, this job will install your Node packages with automated caching and best practices applied. Note that it requires a lock file.    b. Deploy the app  In this quickstart guide, we will deploy to  Heroku. We can do this using the official Heroku orb by adding a new line into our orb section. The Heroku orb contains a set of prepackaged CircleCI configurations you can use to deploy applications to Heroku. Learn more about the  Heroku orb.    orbs:
  node: circleci/node@4.7.0
  heroku: circleci/heroku@1.2.6    We then need to add a job to our list to take care of the deploy step:    jobs:
  # ...previous job(s)...
  deploy: # this can be any name you choose
    executor: heroku/default
    steps:
      - attach_workspace:
          at: ~/project
      - heroku/deploy-via-git:
          force: true # force push when pushing to the heroku remote, see: https://devcenter.heroku.com/articles/git       Environment variables containing the necessary secrets such as HEROKU_API_KEY and HEROKU_APP_NAME can be set up in the CircleCI web app. Learn more about  environment variables.          3. Create a workflow  A workflow is a set of rules for defining a collection of jobs and their run order. Workflows support complex job orchestration using a set of configuration keys to help you resolve failures sooner. Inside the workflow, you define the jobs you want to run. CircleCI will run this workflow on every commit. Learn more about  workflow configuration.    workflows:
  build_test_deploy: # this can be any name you choose     4. Add jobs to the workflow  Now that we have our workflow, build_test_deploy, we can use it to orchestrate the running of our build_and_test and deploy jobs. Refer to the  Using Workflows to Orchestrate Jobs page for more details about orchestrating jobs with concurrent, sequential, and manual approval workflows.    workflows:
  build_test_deploy: # this can be any name you choose
    jobs:
      - build_and_test
      - deploy:
          requires:
            - build_and_test # only deploy if the build_and_test job has completed
          filters:
            branches:
              only: main # only deploy when on main     5. Conclusion  You just set up a Node.js app to build on CircleCI. Check out your project’s  pipeline page to see how this looks when building on CircleCI.      Deploy options? For alternative deployment targets, search the  orb registry, where you will find integrations such as  Kubernetes,  AWS ECS,  GCP GKE, and more.           Full configuration file    version: 2.1
orbs:
  node: circleci/node@5.0.2
  heroku: circleci/heroku@1.2.6

jobs:
  build_and_test:
    executor: node/default
    steps:
      - checkout
      - node/install-packages:
          pkg-manager: yarn
      - run:
          command: yarn test
          name: Run tests
      - run:
          command: yarn build
          name: Build app
      - persist_to_workspace:
          root: ~/project
          paths:
            - .

  deploy: # this can be any name you choose
    executor: heroku/default
    steps:
      - attach_workspace:
          at: ~/project
      - heroku/deploy-via-git:
          force: true # force push when pushing to the heroku remote, see: https://devcenter.heroku.com/articles/git

workflows:
  test_my_app:
    jobs:
      - build_and_test
      - deploy:
          requires:
            - build_and_test # only deploy if the build_and_test job has completed
          filters:
            branches:
              only: main # only deploy when on main      See also      Continuous deployment of Node apps to Heroku    Continuous deployment of Node.js to Azure VM    Troubleshoot Node.js build and test suite timeouts   Tutorial:  Test splitting to speed up your pipelines     Suggest an edit to this pageMake a contribution Learn how to contributeStill need help? Ask the CircleCI community Join the research community Visit our Support site DocsTerms of UsePrivacy PolicyCookie PolicySecurity© 2025 Circle Internet Services, Inc., All Rights Reserved.\n\nversion: 2.1  orbs:
  node: circleci/node@5.0.2  When using an orb, it is a good idea to check the  Orb Registry to ensure you are using the most recent version, or the version that fits best with your specific project.  jobs:
  build_and_test: # this can be any name you choose
    executor: node/default # use the default executor defined within the orb
    steps:
      - checkout
      - node/install-packages:
          pkg-manager: yarn
      - run:
          command: yarn test
          name: Run tests
      - run:
          command: yarn build
          name: Build app
      - persist_to_workspace:
          root: ~/project
          paths: .  jobs:
  build_and_test: # this can be any name you choose
    executor: node/default # use the default executor defined within the orb
    steps:
      - checkout
      - node/install-packages:
          pkg-manager: npm
      - run:
          command: npm run test
          name: Run tests
      - run:
          command: npm run build
          name: Build app
      - persist_to_workspace:
          root: ~/project
          paths:
            - .  orbs:
  node: circleci/node@4.7.0
  heroku: circleci/heroku@1.2.6  jobs:
  # ...previous job(s)...
  deploy: # this can be any name you choose
    executor: heroku/default
    steps:
      - attach_workspace:
          at: ~/project
      - heroku/deploy-via-git:
          force: true # force push when pushing to the heroku remote, see: https://devcenter.heroku.com/articles/git  Environment variables containing the necessary secrets such as HEROKU_API_KEY and HEROKU_APP_NAME can be set up in the CircleCI web app. Learn more about  environment variables.  workflows:
  build_test_deploy: # this can be any name you choose  workflows:
  build_test_deploy: # this can be any name you choose
    jobs:
      - build_and_test
      - deploy:
          requires:
            - build_and_test # only deploy if the build_and_test job has completed
          filters:
            branches:
              only: main # only deploy when on main  Deploy options? For alternative deployment targets, search the  orb registry, where you will find integrations such as  Kubernetes,  AWS ECS,  GCP GKE, and more.  version: 2.1
orbs:
  node: circleci/node@5.0.2
  heroku: circleci/heroku@1.2.6

jobs:
  build_and_test:
    executor: node/default
    steps:
      - checkout
      - node/install-packages:
          pkg-manager: yarn
      - run:
          command: yarn test
          name: Run tests
      - run:
          command: yarn build
          name: Build app
      - persist_to_workspace:
          root: ~/project
          paths:
            - .

  deploy: # this can be any name you choose
    executor: heroku/default
    steps:
      - attach_workspace:
          at: ~/project
      - heroku/deploy-via-git:
          force: true # force push when pushing to the heroku remote, see: https://devcenter.heroku.com/articles/git

workflows:
  test_my_app:
    jobs:
      - build_and_test
      - deploy:
          requires:
            - build_and_test # only deploy if the build_and_test job has completed
          filters:
            branches:
              only: main # only deploy when on main\n\n\n\nConfigure a Python application on CircleCI1 month ago3 min readCloudServer v4+On This PagePrerequisitesConfiguration walkthrough1. Specify a version2. Use the Python orb3. Create jobsa. Build and test the appb. Deploy the app4. Create a workflow5. Add jobs to the workflow6. ConclusionFull configuration fileSee also   This quickstart guide covers integrating a Python project with CircleCI. This guide is designed to help you create a basic CircleCI configuration file to build, test and deploy your Python project. After completing this quickstart you can edit and optimize the config to fit the requirements of your project.     Prerequisites      A CircleCI account   A Python project located in a supported VCS       Configuration walkthrough   Every CircleCI project requires a configuration file called  .circleci/config.yml. Follow the steps below to create a working config.yml file.   1. Specify a version  Every CircleCI config.yml starts with the version key. This key is used to issue warnings about breaking changes.    version: 2.1    2.1 is the latest CircleCI version, and it ensures you have access to all our latest features and improvements.    2. Use the Python orb  The Python  orb contains a set of prepackaged CircleCI configurations you can use to do common CircleCI tasks for the Python programming language. It supports Linux x86_64, macOS x86_64, and Arm64. Learn more about  orbs.   To add the orb to your config, insert:    orbs:
  python: circleci/python@2.0.3       When using an orb, it is a good idea to check the  Orb Registry to ensure you are using the most recent version, or the version that fits best with your specific project.         3. Create jobs  Jobs are the building blocks of your config. Jobs are collections of steps, which run commands/scripts as required. All of the steps in the job are executed in a single unit, either within a fresh container or virtual machine. Learn more about jobs on the  Jobs and Steps page.   A common ask from developers who are getting started with CircleCI is to perform three basic tasks: build, test and deploy. This section guides you through each of the config changes needed. Because we are using the official Python orb, we can use commands that are built into the orb to keep our config simple and succinct:   a. Build and test the app  For this step, we are using the python/install-packages command that comes from the Python  orb. This command automatically sets up a Python environment and installs the packages for your project either globally with pip or in a virtualenv with poetry or pipenv.    jobs:
  build_and_test: # this can be any name you choose
    executor: python/default # use the default executor defined within the orb
    steps:
      - checkout # checkout source code
      - python/install-packages:
          pkg-manager: pip
      - run:
          name: Run tests
          command: python -m pytest
      - persist_to_workspace:
          root: ~/project
          paths:
            - .     b. Deploy the app  In this quickstart guide, we will deploy to  Heroku. We can do this using the official Heroku orb by adding a new line into our orb section. The Heroku orb contains a set of prepackaged CircleCI configurations you can use to deploy applications to Heroku. Learn more about the  Heroku orb.    orbs:
  python: circleci/python@2.0.3
  heroku: circleci/heroku@1.2.6    We then need to add a job to our list to take care of the deploy step:    jobs:
  # ...previous job(s)...
  deploy: # this can be any name you choose
    executor: heroku/default # use the default executor defined within the orb
    steps:
      - attach_workspace:
          at: ~/project
      - heroku/deploy-via-git:
          force: true # force push when pushing to the heroku remote, see: https://devcenter.heroku.com/articles/git       Environment variables containing the necessary secrets such as HEROKU_API_KEY and HEROKU_APP_NAME can be set up in the CircleCI web app. Learn more about  environment variables.          4. Create a workflow  A workflow is a set of rules for defining a collection of jobs and their run order. Workflows support complex job orchestration using a set of configuration keys to help you resolve failures sooner. Inside the workflow, you define the jobs you want to run. CircleCI will run this workflow on every commit. Learn more about  workflow configuration.    workflows:
  build_test_deploy: # this can be any name you choose     5. Add jobs to the workflow  Now that we have our workflow, build_test_deploy, we can use it to orchestrate the running of our build_and_test and deploy jobs. Refer to the  Using Workflows to Orchestrate Jobs page for more details about orchestrating jobs with concurrent, sequential, and manual approval workflows.    workflows:
  build_test_deploy:
    jobs:
      - build_and_test
      - deploy:
          requires:
            - build_and_test # only deploy if the build_and_test job has completed
          filters:
            branches:
              only: main # only deploy when on main     6. Conclusion  You just set up a Python app to build on CircleCI. Check out your project’s  pipeline page to see how this looks when building on CircleCI.      Deploy options? For alternative deployment targets, search the  orb registry, where you will find integrations such as  Kubernetes,  AWS ECS,  GCP GKE, and more.           Full configuration file    version: 2.1
orbs:
  python: circleci/python@2.0.3
  heroku: circleci/heroku@1.2.6

jobs:
  build_and_test: # this can be any name you choose
    executor: python/default
    steps:
      - checkout
      - python/install-packages:
          pkg-manager: pip
      - run:
          name: Run tests
          command: python -m pytest
      - persist_to_workspace:
          root: ~/project
          paths:
            - .

  deploy: # this can be any name you choose
    executor: heroku/default
    steps:
      - attach_workspace:
          at: ~/project
      - heroku/deploy-via-git:
          force: true # force push when pushing to the heroku remote, see: https://devcenter.heroku.com/articles/git

workflows:
  test_my_app:
    jobs:
      - build_and_test
      - deploy:
          requires:
            - build_and_test # only deploy if the build_and_test job has completed
          filters:
            branches:
              only: main # only deploy when on main      See also      Use test splitting with Python Django tests    Testing Flask framework with pytest    How do I use Django on CircleCI?   Tutorial:  Test splitting to speed up your pipelines     Suggest an edit to this pageMake a contribution Learn how to contributeStill need help? Ask the CircleCI community Join the research community Visit our Support site\n\nConfigure a Python application on CircleCI1 month ago3 min readCloudServer v4+On This PagePrerequisitesConfiguration walkthrough1. Specify a version2. Use the Python orb3. Create jobsa. Build and test the appb. Deploy the app4. Create a workflow5. Add jobs to the workflow6. ConclusionFull configuration fileSee also   This quickstart guide covers integrating a Python project with CircleCI. This guide is designed to help you create a basic CircleCI configuration file to build, test and deploy your Python project. After completing this quickstart you can edit and optimize the config to fit the requirements of your project.     Prerequisites      A CircleCI account   A Python project located in a supported VCS       Configuration walkthrough   Every CircleCI project requires a configuration file called  .circleci/config.yml. Follow the steps below to create a working config.yml file.   1. Specify a version  Every CircleCI config.yml starts with the version key. This key is used to issue warnings about breaking changes.    version: 2.1    2.1 is the latest CircleCI version, and it ensures you have access to all our latest features and improvements.    2. Use the Python orb  The Python  orb contains a set of prepackaged CircleCI configurations you can use to do common CircleCI tasks for the Python programming language. It supports Linux x86_64, macOS x86_64, and Arm64. Learn more about  orbs.   To add the orb to your config, insert:    orbs:
  python: circleci/python@2.0.3       When using an orb, it is a good idea to check the  Orb Registry to ensure you are using the most recent version, or the version that fits best with your specific project.         3. Create jobs  Jobs are the building blocks of your config. Jobs are collections of steps, which run commands/scripts as required. All of the steps in the job are executed in a single unit, either within a fresh container or virtual machine. Learn more about jobs on the  Jobs and Steps page.   A common ask from developers who are getting started with CircleCI is to perform three basic tasks: build, test and deploy. This section guides you through each of the config changes needed. Because we are using the official Python orb, we can use commands that are built into the orb to keep our config simple and succinct:   a. Build and test the app  For this step, we are using the python/install-packages command that comes from the Python  orb. This command automatically sets up a Python environment and installs the packages for your project either globally with pip or in a virtualenv with poetry or pipenv.    jobs:
  build_and_test: # this can be any name you choose
    executor: python/default # use the default executor defined within the orb
    steps:
      - checkout # checkout source code
      - python/install-packages:
          pkg-manager: pip
      - run:
          name: Run tests
          command: python -m pytest
      - persist_to_workspace:
          root: ~/project
          paths:
            - .     b. Deploy the app  In this quickstart guide, we will deploy to  Heroku. We can do this using the official Heroku orb by adding a new line into our orb section. The Heroku orb contains a set of prepackaged CircleCI configurations you can use to deploy applications to Heroku. Learn more about the  Heroku orb.    orbs:
  python: circleci/python@2.0.3
  heroku: circleci/heroku@1.2.6    We then need to add a job to our list to take care of the deploy step:    jobs:
  # ...previous job(s)...
  deploy: # this can be any name you choose
    executor: heroku/default # use the default executor defined within the orb
    steps:
      - attach_workspace:
          at: ~/project
      - heroku/deploy-via-git:
          force: true # force push when pushing to the heroku remote, see: https://devcenter.heroku.com/articles/git       Environment variables containing the necessary secrets such as HEROKU_API_KEY and HEROKU_APP_NAME can be set up in the CircleCI web app. Learn more about  environment variables.          4. Create a workflow  A workflow is a set of rules for defining a collection of jobs and their run order. Workflows support complex job orchestration using a set of configuration keys to help you resolve failures sooner. Inside the workflow, you define the jobs you want to run. CircleCI will run this workflow on every commit. Learn more about  workflow configuration.    workflows:
  build_test_deploy: # this can be any name you choose     5. Add jobs to the workflow  Now that we have our workflow, build_test_deploy, we can use it to orchestrate the running of our build_and_test and deploy jobs. Refer to the  Using Workflows to Orchestrate Jobs page for more details about orchestrating jobs with concurrent, sequential, and manual approval workflows.    workflows:
  build_test_deploy:
    jobs:
      - build_and_test
      - deploy:
          requires:
            - build_and_test # only deploy if the build_and_test job has completed
          filters:
            branches:
              only: main # only deploy when on main     6. Conclusion  You just set up a Python app to build on CircleCI. Check out your project’s  pipeline page to see how this looks when building on CircleCI.      Deploy options? For alternative deployment targets, search the  orb registry, where you will find integrations such as  Kubernetes,  AWS ECS,  GCP GKE, and more.           Full configuration file    version: 2.1
orbs:
  python: circleci/python@2.0.3
  heroku: circleci/heroku@1.2.6

jobs:
  build_and_test: # this can be any name you choose
    executor: python/default
    steps:
      - checkout
      - python/install-packages:
          pkg-manager: pip
      - run:
          name: Run tests
          command: python -m pytest
      - persist_to_workspace:
          root: ~/project
          paths:
            - .

  deploy: # this can be any name you choose
    executor: heroku/default
    steps:
      - attach_workspace:
          at: ~/project
      - heroku/deploy-via-git:
          force: true # force push when pushing to the heroku remote, see: https://devcenter.heroku.com/articles/git

workflows:
  test_my_app:
    jobs:
      - build_and_test
      - deploy:
          requires:
            - build_and_test # only deploy if the build_and_test job has completed
          filters:
            branches:
              only: main # only deploy when on main      See also      Use test splitting with Python Django tests    Testing Flask framework with pytest    How do I use Django on CircleCI?   Tutorial:  Test splitting to speed up your pipelines     Suggest an edit to this pageMake a contribution Learn how to contributeStill need help? Ask the CircleCI community Join the research community Visit our Support site DocsTerms of UsePrivacy PolicyCookie PolicySecurity© 2025 Circle Internet Services, Inc., All Rights Reserved.\n\nversion: 2.1  orbs:
  python: circleci/python@2.0.3  When using an orb, it is a good idea to check the  Orb Registry to ensure you are using the most recent version, or the version that fits best with your specific project.  jobs:
  build_and_test: # this can be any name you choose
    executor: python/default # use the default executor defined within the orb
    steps:
      - checkout # checkout source code
      - python/install-packages:
          pkg-manager: pip
      - run:
          name: Run tests
          command: python -m pytest
      - persist_to_workspace:
          root: ~/project
          paths:
            - .  orbs:
  python: circleci/python@2.0.3
  heroku: circleci/heroku@1.2.6  jobs:
  # ...previous job(s)...
  deploy: # this can be any name you choose
    executor: heroku/default # use the default executor defined within the orb
    steps:
      - attach_workspace:
          at: ~/project
      - heroku/deploy-via-git:
          force: true # force push when pushing to the heroku remote, see: https://devcenter.heroku.com/articles/git  Environment variables containing the necessary secrets such as HEROKU_API_KEY and HEROKU_APP_NAME can be set up in the CircleCI web app. Learn more about  environment variables.  workflows:
  build_test_deploy: # this can be any name you choose  workflows:
  build_test_deploy:
    jobs:
      - build_and_test
      - deploy:
          requires:
            - build_and_test # only deploy if the build_and_test job has completed
          filters:
            branches:
              only: main # only deploy when on main  Deploy options? For alternative deployment targets, search the  orb registry, where you will find integrations such as  Kubernetes,  AWS ECS,  GCP GKE, and more.  version: 2.1
orbs:
  python: circleci/python@2.0.3
  heroku: circleci/heroku@1.2.6

jobs:
  build_and_test: # this can be any name you choose
    executor: python/default
    steps:
      - checkout
      - python/install-packages:
          pkg-manager: pip
      - run:
          name: Run tests
          command: python -m pytest
      - persist_to_workspace:
          root: ~/project
          paths:
            - .

  deploy: # this can be any name you choose
    executor: heroku/default
    steps:
      - attach_workspace:
          at: ~/project
      - heroku/deploy-via-git:
          force: true # force push when pushing to the heroku remote, see: https://devcenter.heroku.com/articles/git

workflows:
  test_my_app:
    jobs:
      - build_and_test
      - deploy:
          requires:
            - build_and_test # only deploy if the build_and_test job has completed
          filters:
            branches:
              only: main # only deploy when on main\n\n\n\nConfigure a Go application on CircleCI1 month ago3 min readCloudServer v4+On This PagePrerequisitesConfiguration walkthrough1. Specify a version2. Use the Go orb3. Create jobsa. Build and test the appb. Deploy the app4. Create a workflow5. Add jobs to the workflow6. ConclusionFull configuration fileSee also   This quickstart guide covers integrating a Go project with CircleCI. This guide is designed to help you create a basic CircleCI configuration file to build, test, and deploy your Go project. After completing this quickstart you can edit and optimize the config to fit the requirements of your project.     Prerequisites      A CircleCI account   A Go project located in a supported VCS       Configuration walkthrough   Every CircleCI project requires a configuration file called  .circleci/config.yml. Follow the steps below to create a working config.yml file.   1. Specify a version  Every CircleCI config.yml starts with the version key. This key is used to issue warnings about breaking changes.    version: 2.1    2.1 is the latest CircleCI version, and it ensures you have access to all our latest features and improvements.    2. Use the Go orb  The Go  orb contains a set of prepackaged CircleCI configurations you can use to perform common CircleCI tasks for the Go programming language. It supports Linux x86_64, macOS x86_64, and Arm64. Learn more about  orbs.   To add the orb to your config, insert:    orbs:
  go: circleci/go@1.7.3       When using an orb, it is a good idea to check the  Orb Registry to ensure you are using the most recent version, or the version that fits best with your specific project.         3. Create jobs  Jobs are the building blocks of your config. Jobs are collections of steps, which run commands/scripts as required. All of the steps in the job are executed in a single unit, either within a fresh container or virtual machine. Learn more about jobs on the  Jobs and Steps page.   A common ask from developers who are getting started with CircleCI is to perform three basic tasks: build, test and deploy. This section guides you through each of the config changes needed. Because we are using the official Go orb, we can use commands that are built into the orb to keep our config simple and succinct.   a. Build and test the app  For this step, we use commands that come preconfigured in the Go  orb. Go modules are downloaded and cached and tests are run.    jobs:
  build_and_test: # this can be any name you choose
    executor:
      name: go/default # Use the default executor from the orb
      tag: '1.19.2' # Specify a version tag
    steps:
      - checkout # checkout source code
      - go/load-cache # Load cached Go modules.
      - go/mod-download # Run 'go mod download'.
      - go/save-cache # Save Go modules to cache.
      - go/test: # Runs 'go test ./...' but includes extensive parameterization for finer tuning.
          covermode: atomic
          failfast: true
          race: true
      - persist_to_workspace:
          root: ~/project
          paths: .     b. Deploy the app  In this quickstart guide, we will deploy to  Heroku. We can do this using the official Heroku orb by adding a new line into our orb section. The Heroku orb contains a set of prepackaged CircleCI configurations you can use to deploy applications to Heroku. Learn more about the  Heroku orb.    orbs:
  go: circleci/go@1.7.3
  heroku: circleci/heroku@1.2.6    We then need to add a job to our list to take care of the deploy step:    jobs:
  # ...previous job(s)...
  deploy: # this can be any name you choose
    executor: heroku/default # use the default executor defined within the orb
    steps:
      - attach_workspace:
          at: ~/project
      - heroku/deploy-via-git:
          force: true # force push when pushing to the heroku remote, see: https://devcenter.heroku.com/articles/git       Environment variables containing the necessary secrets such as HEROKU_API_KEY and HEROKU_APP_NAME can be set up in the CircleCI web app. Learn more about  environment variables.          4. Create a workflow  A workflow is a set of rules for defining a collection of jobs and their run order. Workflows support complex job orchestration using a set of configuration keys to help you resolve failures sooner. Inside the workflow, you define the jobs you want to run. CircleCI will run this workflow on every commit. Learn more about  workflow configuration.    workflows:
  build_test_deploy: # this can be any name you choose     5. Add jobs to the workflow  Now that we have our workflow, build_test_deploy, we can use it to orchestrate the running of our build_and_test and deploy jobs. Refer to the  Using Workflows to Orchestrate Jobs page for more details about orchestrating jobs with concurrent, sequential, and manual approval workflows.    workflows:
  build_test_deploy:
    jobs:
      - build_and_test
      - deploy:
          requires:
            - build_and_test # only deploy if the build_and_test job has completed
          filters:
            branches:
              only: main # only deploy when on main     6. Conclusion  You just set up a Go app to build on CircleCI, and deploy to Heroku. Check out your project’s  pipeline page to see how this looks when building on CircleCI.      Deploy options? For alternative deployment targets, search the  orb registry, where you will find integrations such as  Kubernetes,  AWS ECS,  GCP GKE, and more.           Full configuration file    version: 2.1
orbs:
  go: circleci/go@1.7.3
  heroku: circleci/heroku@1.2.6

jobs:
  build_and_test: # this can be any name you choose
    executor:
      name: go/default # Use the default executor from the orb
      tag: '1.19.2' # Specify a version tag
    steps:
      - checkout # checkout source code
      - go/load-cache # Load cached Go modules.
      - go/mod-download # Run 'go mod download'.
      - go/save-cache # Save Go modules to cache.
      - go/test: # Runs 'go test ./...' but includes extensive parameterization for finer tuning.
          covermode: atomic
          failfast: true
          race: true
      - persist_to_workspace:
          root: ~/project
          paths: .

  deploy: # this can be any name you choose
    executor: heroku/default
    steps:
      - attach_workspace:
          at: ~/project
      - heroku/deploy-via-git:
          force: true # force push when pushing to the heroku remote, see: https://devcenter.heroku.com/articles/git

workflows:
  test_my_app:
    jobs:
      - build_and_test
      - deploy:
          requires:
            - build_and_test # only deploy if the build_and_test job has completed
          filters:
            branches:
              only: main # only deploy when on main      See also      Test splitting and rerun failed tests for Go    Continuous integration for Go applications   Tutorial:  Test splitting to speed up your pipelines     Suggest an edit to this pageMake a contribution Learn how to contributeStill need help? Ask the CircleCI community Join the research community Visit our Support site\n\nConfigure a Go application on CircleCI1 month ago3 min readCloudServer v4+On This PagePrerequisitesConfiguration walkthrough1. Specify a version2. Use the Go orb3. Create jobsa. Build and test the appb. Deploy the app4. Create a workflow5. Add jobs to the workflow6. ConclusionFull configuration fileSee also   This quickstart guide covers integrating a Go project with CircleCI. This guide is designed to help you create a basic CircleCI configuration file to build, test, and deploy your Go project. After completing this quickstart you can edit and optimize the config to fit the requirements of your project.     Prerequisites      A CircleCI account   A Go project located in a supported VCS       Configuration walkthrough   Every CircleCI project requires a configuration file called  .circleci/config.yml. Follow the steps below to create a working config.yml file.   1. Specify a version  Every CircleCI config.yml starts with the version key. This key is used to issue warnings about breaking changes.    version: 2.1    2.1 is the latest CircleCI version, and it ensures you have access to all our latest features and improvements.    2. Use the Go orb  The Go  orb contains a set of prepackaged CircleCI configurations you can use to perform common CircleCI tasks for the Go programming language. It supports Linux x86_64, macOS x86_64, and Arm64. Learn more about  orbs.   To add the orb to your config, insert:    orbs:
  go: circleci/go@1.7.3       When using an orb, it is a good idea to check the  Orb Registry to ensure you are using the most recent version, or the version that fits best with your specific project.         3. Create jobs  Jobs are the building blocks of your config. Jobs are collections of steps, which run commands/scripts as required. All of the steps in the job are executed in a single unit, either within a fresh container or virtual machine. Learn more about jobs on the  Jobs and Steps page.   A common ask from developers who are getting started with CircleCI is to perform three basic tasks: build, test and deploy. This section guides you through each of the config changes needed. Because we are using the official Go orb, we can use commands that are built into the orb to keep our config simple and succinct.   a. Build and test the app  For this step, we use commands that come preconfigured in the Go  orb. Go modules are downloaded and cached and tests are run.    jobs:
  build_and_test: # this can be any name you choose
    executor:
      name: go/default # Use the default executor from the orb
      tag: '1.19.2' # Specify a version tag
    steps:
      - checkout # checkout source code
      - go/load-cache # Load cached Go modules.
      - go/mod-download # Run 'go mod download'.
      - go/save-cache # Save Go modules to cache.
      - go/test: # Runs 'go test ./...' but includes extensive parameterization for finer tuning.
          covermode: atomic
          failfast: true
          race: true
      - persist_to_workspace:
          root: ~/project
          paths: .     b. Deploy the app  In this quickstart guide, we will deploy to  Heroku. We can do this using the official Heroku orb by adding a new line into our orb section. The Heroku orb contains a set of prepackaged CircleCI configurations you can use to deploy applications to Heroku. Learn more about the  Heroku orb.    orbs:
  go: circleci/go@1.7.3
  heroku: circleci/heroku@1.2.6    We then need to add a job to our list to take care of the deploy step:    jobs:
  # ...previous job(s)...
  deploy: # this can be any name you choose
    executor: heroku/default # use the default executor defined within the orb
    steps:
      - attach_workspace:
          at: ~/project
      - heroku/deploy-via-git:
          force: true # force push when pushing to the heroku remote, see: https://devcenter.heroku.com/articles/git       Environment variables containing the necessary secrets such as HEROKU_API_KEY and HEROKU_APP_NAME can be set up in the CircleCI web app. Learn more about  environment variables.          4. Create a workflow  A workflow is a set of rules for defining a collection of jobs and their run order. Workflows support complex job orchestration using a set of configuration keys to help you resolve failures sooner. Inside the workflow, you define the jobs you want to run. CircleCI will run this workflow on every commit. Learn more about  workflow configuration.    workflows:
  build_test_deploy: # this can be any name you choose     5. Add jobs to the workflow  Now that we have our workflow, build_test_deploy, we can use it to orchestrate the running of our build_and_test and deploy jobs. Refer to the  Using Workflows to Orchestrate Jobs page for more details about orchestrating jobs with concurrent, sequential, and manual approval workflows.    workflows:
  build_test_deploy:
    jobs:
      - build_and_test
      - deploy:
          requires:
            - build_and_test # only deploy if the build_and_test job has completed
          filters:
            branches:
              only: main # only deploy when on main     6. Conclusion  You just set up a Go app to build on CircleCI, and deploy to Heroku. Check out your project’s  pipeline page to see how this looks when building on CircleCI.      Deploy options? For alternative deployment targets, search the  orb registry, where you will find integrations such as  Kubernetes,  AWS ECS,  GCP GKE, and more.           Full configuration file    version: 2.1
orbs:
  go: circleci/go@1.7.3
  heroku: circleci/heroku@1.2.6

jobs:
  build_and_test: # this can be any name you choose
    executor:
      name: go/default # Use the default executor from the orb
      tag: '1.19.2' # Specify a version tag
    steps:
      - checkout # checkout source code
      - go/load-cache # Load cached Go modules.
      - go/mod-download # Run 'go mod download'.
      - go/save-cache # Save Go modules to cache.
      - go/test: # Runs 'go test ./...' but includes extensive parameterization for finer tuning.
          covermode: atomic
          failfast: true
          race: true
      - persist_to_workspace:
          root: ~/project
          paths: .

  deploy: # this can be any name you choose
    executor: heroku/default
    steps:
      - attach_workspace:
          at: ~/project
      - heroku/deploy-via-git:
          force: true # force push when pushing to the heroku remote, see: https://devcenter.heroku.com/articles/git

workflows:
  test_my_app:
    jobs:
      - build_and_test
      - deploy:
          requires:
            - build_and_test # only deploy if the build_and_test job has completed
          filters:
            branches:
              only: main # only deploy when on main      See also      Test splitting and rerun failed tests for Go    Continuous integration for Go applications   Tutorial:  Test splitting to speed up your pipelines     Suggest an edit to this pageMake a contribution Learn how to contributeStill need help? Ask the CircleCI community Join the research community Visit our Support site DocsTerms of UsePrivacy PolicyCookie PolicySecurity© 2025 Circle Internet Services, Inc., All Rights Reserved.\n\nversion: 2.1  orbs:
  go: circleci/go@1.7.3  When using an orb, it is a good idea to check the  Orb Registry to ensure you are using the most recent version, or the version that fits best with your specific project.  jobs:
  build_and_test: # this can be any name you choose
    executor:
      name: go/default # Use the default executor from the orb
      tag: '1.19.2' # Specify a version tag
    steps:
      - checkout # checkout source code
      - go/load-cache # Load cached Go modules.
      - go/mod-download # Run 'go mod download'.
      - go/save-cache # Save Go modules to cache.
      - go/test: # Runs 'go test ./...' but includes extensive parameterization for finer tuning.
          covermode: atomic
          failfast: true
          race: true
      - persist_to_workspace:
          root: ~/project
          paths: .  orbs:
  go: circleci/go@1.7.3
  heroku: circleci/heroku@1.2.6  jobs:
  # ...previous job(s)...
  deploy: # this can be any name you choose
    executor: heroku/default # use the default executor defined within the orb
    steps:
      - attach_workspace:
          at: ~/project
      - heroku/deploy-via-git:
          force: true # force push when pushing to the heroku remote, see: https://devcenter.heroku.com/articles/git  Environment variables containing the necessary secrets such as HEROKU_API_KEY and HEROKU_APP_NAME can be set up in the CircleCI web app. Learn more about  environment variables.  workflows:
  build_test_deploy: # this can be any name you choose  workflows:
  build_test_deploy:
    jobs:
      - build_and_test
      - deploy:
          requires:
            - build_and_test # only deploy if the build_and_test job has completed
          filters:
            branches:
              only: main # only deploy when on main  Deploy options? For alternative deployment targets, search the  orb registry, where you will find integrations such as  Kubernetes,  AWS ECS,  GCP GKE, and more.  version: 2.1
orbs:
  go: circleci/go@1.7.3
  heroku: circleci/heroku@1.2.6

jobs:
  build_and_test: # this can be any name you choose
    executor:
      name: go/default # Use the default executor from the orb
      tag: '1.19.2' # Specify a version tag
    steps:
      - checkout # checkout source code
      - go/load-cache # Load cached Go modules.
      - go/mod-download # Run 'go mod download'.
      - go/save-cache # Save Go modules to cache.
      - go/test: # Runs 'go test ./...' but includes extensive parameterization for finer tuning.
          covermode: atomic
          failfast: true
          race: true
      - persist_to_workspace:
          root: ~/project
          paths: .

  deploy: # this can be any name you choose
    executor: heroku/default
    steps:
      - attach_workspace:
          at: ~/project
      - heroku/deploy-via-git:
          force: true # force push when pushing to the heroku remote, see: https://devcenter.heroku.com/articles/git

workflows:
  test_my_app:
    jobs:
      - build_and_test
      - deploy:
          requires:
            - build_and_test # only deploy if the build_and_test job has completed
          filters:
            branches:
              only: main # only deploy when on main\n\n\n\nHello world2 weeks ago2 min readCloudServer v4+On This PagePrerequisitesEcho hello worldEcho hello world on CircleCI serverNext steps   This page provides configuration examples to get started with a basic pipeline using any execution environment.     Prerequisites     A CircleCI account connected to your code. You can  sign up for free.   A code repository you want to build on CircleCI.   Follow the  Create a Project guide to connect your repository to CircleCI. You can then use the examples below to configure a basic pipeline using any execution environment.        Using Docker? Authenticating Docker pulls from image registries is recommended when using the Docker execution environment. Authenticated pulls allow access to private Docker images, and may also grant higher rate limits, depending on your registry provider. For further information see  Using Docker authenticated pulls.          Echo hello world   These examples adds a job called hello-job that prints hello world to the console.  DockerLinux VMmacOSWindowsGPUArm VM   The job hello-job spins up a container running a pre-built CircleCI Docker image for Node. Refer to  Using the Docker execution environment page for more information.    version: 2.1

jobs:
  hello-job:
    docker:
      - image: cimg/node:17.2.0 # the primary container, where your job's commands are run
    steps:
      - checkout # check out the code in the project directory
      - run: echo "hello world" # run the `echo` command

workflows:
  my-workflow:
    jobs:
      - hello-job       The job hello-job spins up a Linux vir†ual machine running a  Ubuntu machine image. Refer to  Using the Linux VM execution environment page for more information.    version: 2.1

jobs:
  hello-job:
    machine:
      image: ubuntu-2204:2022.07.1
    steps:
      - checkout # check out the code in the project directory
      - run: echo "hello world" # run the `echo` command

workflows:
  my-workflow:
    jobs:
      - hello-job       The job hello-job spins up a macOS virtual machine running the specified Xcode version. Refer to  Using the macOS execution environment page for more information.    version: 2.1

jobs:
  hello-job:
    macos:
      xcode: 15.4.0
    resource_class: m2pro.medium
    steps:
      - checkout # check out the code in the project directory
      - run: echo "hello world" # run the `echo` command

workflows:
  my-workflow:
    jobs:
      - hello-job       The job hello-job spins up a Windows virtual machine using the default executor specified by the  Windows orb. Refer to  Using the Windows execution environment page for more information.    version: 2.1

orbs:
  win: circleci/windows@5.0.0 # The Windows orb gives you everything you need to start using the Windows executor.

jobs:
  hello-job:
    executor:
      name: win/default # executor type
      size: "medium" # resource class, can be "medium", "large", "xlarge", "2xlarge", defaults to "medium" if not specified

    steps:
      # Commands are run in a Windows virtual machine environment
      - checkout
      - run: Write-Host 'Hello, Windows'

workflows:
  my-workflow:
    jobs:
      - hello-job          The GPU execution environment is available on the  Scale Plan.        The job hello-job spins up a GPU-enabled virtual machine using the machine executor. GPU images are available for  Windows and  Linux. Refer to  Using the GPU execution environment page for more information.    version: 2.1

jobs:
  hello-job:
    machine:
      image: linux-cuda-12:default
      resource_class: gpu.nvidia.medium
    steps:
      - checkout # check out the code in the project directory
      - run: echo "hello world" # run the `echo` command

workflows:
  my-workflow:
    jobs:
      - hello-job       The job hello-job spins up an [Arm (Linux) virtual machine] using the machine executor. Refer to  Using the Arm VM execution environment page for more information.    version: 2.1

jobs:
  hello-job:
    machine:
      image: ubuntu-2004:202101-01
    resource_class: arm.medium
    steps:
      - checkout # check out the code in the project directory
      - run: echo "hello world" # run the `echo` command

workflows:
  my-workflow:
    jobs:
      - hello-job                 If you get a No Config Found error, it may be that you used .yaml file extension. Be sure to use .yml file extension to resolve this error.          Echo hello world on CircleCI server      To build in a macOS execution environment on server use  Self-Hosted Runner.        These examples add a job called hello-job that prints hello world to the console.  DockerLinux VMWindowsArm   The job hello-job spins up a container running a pre-built CircleCI Docker image for Node. Refer to  Using the Docker execution environment page for more information.    version: 2.1

jobs:
  hello-job:
    docker:
      - image: cimg/node:17.2.0 # the primary container, where your job's commands are run
    steps:
      - checkout # check out the code in the project directory
      - run: echo "hello world" # run the `echo` command

workflows:
  my-workflow:
    jobs:
      - hello-job       The job hello-job spins up a Linux vir†ual machine running a  Ubuntu machine image. Refer to  Using the Linux VM execution environment page for more information.    version: 2.1

jobs:
  hello-job:
    machine: true
    steps:
      - checkout # check out the code in the project directory
      - run: echo "hello world" # run the `echo` command

workflows:
  my-workflow:
    jobs:
      - hello-job       The job hello-job spins up a Windows virtual machine using the default executor specified by the  Windows orb. Refer to  Using the Windows execution environment page for more information.    version: 2.1

jobs:
  hello-job:
    machine:
      image: windows-default

    steps:
      # Commands are run in a Windows virtual machine environment
      - checkout
      - run: Write-Host 'Hello, Windows'

workflows:
  my-workflow:
    jobs:
      - hello-job       The job hello-job spins up an Arm (Ubuntu 22.04) virtual machine. Refer to  Using the Arm VM execution environment page for more information.    version: 2.1

jobs:
  hello-job:
    machine:
      image: arm-default
    resource_class: arm.medium
    steps:
      - checkout # check out the code in the project directory
      - run: echo "hello world" # run the `echo` command

workflows:
  my-workflow:
    jobs:
      - hello-job               If you get a No Config Found error, it may be that you used .yaml file extension. Be sure to use .yml file extension to resolve this error.          Next steps     See the  Concepts page for a summary of CircleCI-specific concepts.   Refer to the  Workflows page for examples of orchestrating job runs with concurrent, sequential, scheduled, and manual approval workflows.   Find complete reference information for all keys and execution environments in the  CircleCI Configuration Reference.     Suggest an edit to this pageMake a contribution Learn how to contributeStill need help? Ask the CircleCI community Join the research community Visit our Support site\n\nHello world2 weeks ago2 min readCloudServer v4+On This PagePrerequisitesEcho hello worldEcho hello world on CircleCI serverNext steps   This page provides configuration examples to get started with a basic pipeline using any execution environment.     Prerequisites     A CircleCI account connected to your code. You can  sign up for free.   A code repository you want to build on CircleCI.   Follow the  Create a Project guide to connect your repository to CircleCI. You can then use the examples below to configure a basic pipeline using any execution environment.        Using Docker? Authenticating Docker pulls from image registries is recommended when using the Docker execution environment. Authenticated pulls allow access to private Docker images, and may also grant higher rate limits, depending on your registry provider. For further information see  Using Docker authenticated pulls.          Echo hello world   These examples adds a job called hello-job that prints hello world to the console.  DockerLinux VMmacOSWindowsGPUArm VM   The job hello-job spins up a container running a pre-built CircleCI Docker image for Node. Refer to  Using the Docker execution environment page for more information.    version: 2.1

jobs:
  hello-job:
    docker:
      - image: cimg/node:17.2.0 # the primary container, where your job's commands are run
    steps:
      - checkout # check out the code in the project directory
      - run: echo "hello world" # run the `echo` command

workflows:
  my-workflow:
    jobs:
      - hello-job       The job hello-job spins up a Linux vir†ual machine running a  Ubuntu machine image. Refer to  Using the Linux VM execution environment page for more information.    version: 2.1

jobs:
  hello-job:
    machine:
      image: ubuntu-2204:2022.07.1
    steps:
      - checkout # check out the code in the project directory
      - run: echo "hello world" # run the `echo` command

workflows:
  my-workflow:
    jobs:
      - hello-job       The job hello-job spins up a macOS virtual machine running the specified Xcode version. Refer to  Using the macOS execution environment page for more information.    version: 2.1

jobs:
  hello-job:
    macos:
      xcode: 15.4.0
    resource_class: m2pro.medium
    steps:
      - checkout # check out the code in the project directory
      - run: echo "hello world" # run the `echo` command

workflows:
  my-workflow:
    jobs:
      - hello-job       The job hello-job spins up a Windows virtual machine using the default executor specified by the  Windows orb. Refer to  Using the Windows execution environment page for more information.    version: 2.1

orbs:
  win: circleci/windows@5.0.0 # The Windows orb gives you everything you need to start using the Windows executor.

jobs:
  hello-job:
    executor:
      name: win/default # executor type
      size: "medium" # resource class, can be "medium", "large", "xlarge", "2xlarge", defaults to "medium" if not specified

    steps:
      # Commands are run in a Windows virtual machine environment
      - checkout
      - run: Write-Host 'Hello, Windows'

workflows:
  my-workflow:
    jobs:
      - hello-job          The GPU execution environment is available on the  Scale Plan.        The job hello-job spins up a GPU-enabled virtual machine using the machine executor. GPU images are available for  Windows and  Linux. Refer to  Using the GPU execution environment page for more information.    version: 2.1

jobs:
  hello-job:
    machine:
      image: linux-cuda-12:default
      resource_class: gpu.nvidia.medium
    steps:
      - checkout # check out the code in the project directory
      - run: echo "hello world" # run the `echo` command

workflows:
  my-workflow:
    jobs:
      - hello-job       The job hello-job spins up an [Arm (Linux) virtual machine] using the machine executor. Refer to  Using the Arm VM execution environment page for more information.    version: 2.1

jobs:
  hello-job:
    machine:
      image: ubuntu-2004:202101-01
    resource_class: arm.medium
    steps:
      - checkout # check out the code in the project directory
      - run: echo "hello world" # run the `echo` command

workflows:
  my-workflow:
    jobs:
      - hello-job                 If you get a No Config Found error, it may be that you used .yaml file extension. Be sure to use .yml file extension to resolve this error.          Echo hello world on CircleCI server      To build in a macOS execution environment on server use  Self-Hosted Runner.        These examples add a job called hello-job that prints hello world to the console.  DockerLinux VMWindowsArm   The job hello-job spins up a container running a pre-built CircleCI Docker image for Node. Refer to  Using the Docker execution environment page for more information.    version: 2.1

jobs:
  hello-job:
    docker:
      - image: cimg/node:17.2.0 # the primary container, where your job's commands are run
    steps:
      - checkout # check out the code in the project directory
      - run: echo "hello world" # run the `echo` command

workflows:
  my-workflow:
    jobs:
      - hello-job       The job hello-job spins up a Linux vir†ual machine running a  Ubuntu machine image. Refer to  Using the Linux VM execution environment page for more information.    version: 2.1

jobs:
  hello-job:
    machine: true
    steps:
      - checkout # check out the code in the project directory
      - run: echo "hello world" # run the `echo` command

workflows:
  my-workflow:
    jobs:
      - hello-job       The job hello-job spins up a Windows virtual machine using the default executor specified by the  Windows orb. Refer to  Using the Windows execution environment page for more information.    version: 2.1

jobs:
  hello-job:
    machine:
      image: windows-default

    steps:
      # Commands are run in a Windows virtual machine environment
      - checkout
      - run: Write-Host 'Hello, Windows'

workflows:
  my-workflow:
    jobs:
      - hello-job       The job hello-job spins up an Arm (Ubuntu 22.04) virtual machine. Refer to  Using the Arm VM execution environment page for more information.    version: 2.1

jobs:
  hello-job:
    machine:
      image: arm-default
    resource_class: arm.medium
    steps:
      - checkout # check out the code in the project directory
      - run: echo "hello world" # run the `echo` command

workflows:
  my-workflow:
    jobs:
      - hello-job               If you get a No Config Found error, it may be that you used .yaml file extension. Be sure to use .yml file extension to resolve this error.          Next steps     See the  Concepts page for a summary of CircleCI-specific concepts.   Refer to the  Workflows page for examples of orchestrating job runs with concurrent, sequential, scheduled, and manual approval workflows.   Find complete reference information for all keys and execution environments in the  CircleCI Configuration Reference.     Suggest an edit to this pageMake a contribution Learn how to contributeStill need help? Ask the CircleCI community Join the research community Visit our Support site DocsTerms of UsePrivacy PolicyCookie PolicySecurity© 2025 Circle Internet Services, Inc., All Rights Reserved.\n\nUsing Docker? Authenticating Docker pulls from image registries is recommended when using the Docker execution environment. Authenticated pulls allow access to private Docker images, and may also grant higher rate limits, depending on your registry provider. For further information see  Using Docker authenticated pulls.   The job hello-job spins up a container running a pre-built CircleCI Docker image for Node. Refer to  Using the Docker execution environment page for more information.    version: 2.1

jobs:
  hello-job:
    docker:
      - image: cimg/node:17.2.0 # the primary container, where your job's commands are run
    steps:
      - checkout # check out the code in the project directory
      - run: echo "hello world" # run the `echo` command

workflows:
  my-workflow:
    jobs:
      - hello-job    version: 2.1

jobs:
  hello-job:
    docker:
      - image: cimg/node:17.2.0 # the primary container, where your job's commands are run
    steps:
      - checkout # check out the code in the project directory
      - run: echo "hello world" # run the `echo` command

workflows:
  my-workflow:
    jobs:
      - hello-job   The job hello-job spins up a Linux vir†ual machine running a  Ubuntu machine image. Refer to  Using the Linux VM execution environment page for more information.    version: 2.1

jobs:
  hello-job:
    machine:
      image: ubuntu-2204:2022.07.1
    steps:
      - checkout # check out the code in the project directory
      - run: echo "hello world" # run the `echo` command

workflows:
  my-workflow:
    jobs:
      - hello-job    version: 2.1

jobs:
  hello-job:
    machine:
      image: ubuntu-2204:2022.07.1
    steps:
      - checkout # check out the code in the project directory
      - run: echo "hello world" # run the `echo` command

workflows:
  my-workflow:
    jobs:
      - hello-job   The job hello-job spins up a macOS virtual machine running the specified Xcode version. Refer to  Using the macOS execution environment page for more information.    version: 2.1

jobs:
  hello-job:
    macos:
      xcode: 15.4.0
    resource_class: m2pro.medium
    steps:
      - checkout # check out the code in the project directory
      - run: echo "hello world" # run the `echo` command

workflows:
  my-workflow:
    jobs:
      - hello-job    version: 2.1

jobs:
  hello-job:
    macos:
      xcode: 15.4.0
    resource_class: m2pro.medium
    steps:
      - checkout # check out the code in the project directory
      - run: echo "hello world" # run the `echo` command

workflows:
  my-workflow:
    jobs:
      - hello-job   The job hello-job spins up a Windows virtual machine using the default executor specified by the  Windows orb. Refer to  Using the Windows execution environment page for more information.    version: 2.1

orbs:
  win: circleci/windows@5.0.0 # The Windows orb gives you everything you need to start using the Windows executor.

jobs:
  hello-job:
    executor:
      name: win/default # executor type
      size: "medium" # resource class, can be "medium", "large", "xlarge", "2xlarge", defaults to "medium" if not specified

    steps:
      # Commands are run in a Windows virtual machine environment
      - checkout
      - run: Write-Host 'Hello, Windows'

workflows:
  my-workflow:
    jobs:
      - hello-job    version: 2.1

orbs:
  win: circleci/windows@5.0.0 # The Windows orb gives you everything you need to start using the Windows executor.

jobs:
  hello-job:
    executor:
      name: win/default # executor type
      size: "medium" # resource class, can be "medium", "large", "xlarge", "2xlarge", defaults to "medium" if not specified

    steps:
      # Commands are run in a Windows virtual machine environment
      - checkout
      - run: Write-Host 'Hello, Windows'

workflows:
  my-workflow:
    jobs:
      - hello-job      The GPU execution environment is available on the  Scale Plan.        The job hello-job spins up a GPU-enabled virtual machine using the machine executor. GPU images are available for  Windows and  Linux. Refer to  Using the GPU execution environment page for more information.    version: 2.1

jobs:
  hello-job:
    machine:
      image: linux-cuda-12:default
      resource_class: gpu.nvidia.medium
    steps:
      - checkout # check out the code in the project directory
      - run: echo "hello world" # run the `echo` command

workflows:
  my-workflow:
    jobs:
      - hello-job    The GPU execution environment is available on the  Scale Plan.  version: 2.1

jobs:
  hello-job:
    machine:
      image: linux-cuda-12:default
      resource_class: gpu.nvidia.medium
    steps:
      - checkout # check out the code in the project directory
      - run: echo "hello world" # run the `echo` command

workflows:
  my-workflow:
    jobs:
      - hello-job   The job hello-job spins up an [Arm (Linux) virtual machine] using the machine executor. Refer to  Using the Arm VM execution environment page for more information.    version: 2.1

jobs:
  hello-job:
    machine:
      image: ubuntu-2004:202101-01
    resource_class: arm.medium
    steps:
      - checkout # check out the code in the project directory
      - run: echo "hello world" # run the `echo` command

workflows:
  my-workflow:
    jobs:
      - hello-job    version: 2.1

jobs:
  hello-job:
    machine:
      image: ubuntu-2004:202101-01
    resource_class: arm.medium
    steps:
      - checkout # check out the code in the project directory
      - run: echo "hello world" # run the `echo` command

workflows:
  my-workflow:
    jobs:
      - hello-job  If you get a No Config Found error, it may be that you used .yaml file extension. Be sure to use .yml file extension to resolve this error.  To build in a macOS execution environment on server use  Self-Hosted Runner.   The job hello-job spins up a container running a pre-built CircleCI Docker image for Node. Refer to  Using the Docker execution environment page for more information.    version: 2.1

jobs:
  hello-job:
    docker:
      - image: cimg/node:17.2.0 # the primary container, where your job's commands are run
    steps:
      - checkout # check out the code in the project directory
      - run: echo "hello world" # run the `echo` command

workflows:
  my-workflow:
    jobs:
      - hello-job    version: 2.1

jobs:
  hello-job:
    docker:
      - image: cimg/node:17.2.0 # the primary container, where your job's commands are run
    steps:
      - checkout # check out the code in the project directory
      - run: echo "hello world" # run the `echo` command

workflows:
  my-workflow:
    jobs:
      - hello-job   The job hello-job spins up a Linux vir†ual machine running a  Ubuntu machine image. Refer to  Using the Linux VM execution environment page for more information.    version: 2.1

jobs:
  hello-job:
    machine: true
    steps:
      - checkout # check out the code in the project directory
      - run: echo "hello world" # run the `echo` command

workflows:
  my-workflow:
    jobs:
      - hello-job    version: 2.1

jobs:
  hello-job:
    machine: true
    steps:
      - checkout # check out the code in the project directory
      - run: echo "hello world" # run the `echo` command

workflows:
  my-workflow:
    jobs:
      - hello-job   The job hello-job spins up a Windows virtual machine using the default executor specified by the  Windows orb. Refer to  Using the Windows execution environment page for more information.    version: 2.1

jobs:
  hello-job:
    machine:
      image: windows-default

    steps:
      # Commands are run in a Windows virtual machine environment
      - checkout
      - run: Write-Host 'Hello, Windows'

workflows:
  my-workflow:
    jobs:
      - hello-job    version: 2.1

jobs:
  hello-job:
    machine:
      image: windows-default

    steps:
      # Commands are run in a Windows virtual machine environment
      - checkout
      - run: Write-Host 'Hello, Windows'

workflows:
  my-workflow:
    jobs:
      - hello-job   The job hello-job spins up an Arm (Ubuntu 22.04) virtual machine. Refer to  Using the Arm VM execution environment page for more information.    version: 2.1

jobs:
  hello-job:
    machine:
      image: arm-default
    resource_class: arm.medium
    steps:
      - checkout # check out the code in the project directory
      - run: echo "hello world" # run the `echo` command

workflows:
  my-workflow:
    jobs:
      - hello-job    version: 2.1

jobs:
  hello-job:
    machine:
      image: arm-default
    resource_class: arm.medium
    steps:
      - checkout # check out the code in the project directory
      - run: echo "hello world" # run the `echo` command

workflows:
  my-workflow:
    jobs:
      - hello-job  If you get a No Config Found error, it may be that you used .yaml file extension. Be sure to use .yml file extension to resolve this error.\n\n\n\nUse the Slack orb to set up notifications4 months ago6 min readCloudServer v4+On This PageIntroduction1. Create your config.yml file2. Connect CircleCI with Slacka. Authenticate your applicationi. Create a Slack appii. Set your app permissionsiii. Install your appb. Create a contextc. Trigger an alert3. Use message templatesa. Including additional parametersb. Use the Slack Block Kit BuilderConclusion   This guide gets you started with the CircleCI Slack orb.     Introduction   Orbs are shareable packages of reusable configuration elements. They help you reduce complexity, integrate your software with third-party apps, and save time.   One of CircleCI’s most popular orbs is the Slack orb. The Slack orb allows you to implement event-based notifications across all your CI/CD pipelines. Using either built-in message templates or Slack’s visual Block Kit Builder, you can create and customize notifications specific to your organization’s needs.   In this tutorial, you will learn how to:     Create a config.yml file using the Slack orb.   Store your Slack credentials securely in a context.   Use templates to create alerts for successful and failed builds.   Alert specific channels, teams, or people.   Access the Slack Block Kit Builder to create your own customized alerts.     To follow this tutorial, you need:     A CircleCI account (you can  sign up for free) connected to either GitHub, Bitbucket, or GitLab.   A  Slack workspace (you can create your own for testing purposes, if you do not want to use your company workspace).   A project you are following in CircleCI for which you want to integrate Slack notifications. See the  Quickstart guide for help with following a project.       1. Create your config.yml file   If you have not already done so, create a .circleci folder at the root of your repo. Inside the .circleci folder, create a config.yml file.   The sample code below shows the basics you need to set up Slack notifications into your config.yml file. You can copy and paste the whole thing or take the individual elements and incorporate into your project config.yml file:    version: 2.1
orbs:
  slack: circleci/slack@4.9.3
jobs:
  notify:
    docker:
      - image: cimg/base:current
    steps:
      - slack/notify:
          custom: |
            {
              "blocks": [
                {
                  "type": "section",
                  "fields": [
                    {
                      "type": "plain_text",
                      "text": "*This is a text notification*",
                      "emoji": true
                    }
                  ]
                }
              ]
            }
          event: always
workflows:
  send-notification:
    jobs:
      - notify    The following commentary describes what occurs in the main elements of the sample code:     Line 1: This indicates the config version you are using. 2.1 is the most recent version.   Lines 2-3: This is the orbs stanza. You are using the slack: circleci/slack@4.9.3 orb.   Lines 5-7: This is a job called notify, which is executed in a basic Docker container.   Lines 8-9: This is a step which must be called slack/notify to work with the Slack orb.   Lines 10-24: This custom block includes a basic notification from the Slack Block Kit Builder. As you can see, it is in JSON format. In Part 3, you will use more sophisticated templates.   Line 25: The event: always parameter means this notification is triggered for all event types. In Part 3, you will use different notifications for different events.   Line 30: This references a CircleCI context where you will save your Slack credentials in Step 2.     Now you have a basic config.yml file set up, you can connect CircleCI with Slack.      If you commit your config.yml file at this point and trigger a pipeline, your build will fail. This is because you need to add your Slack credentials in the next step.          2. Connect CircleCI with Slack   In this step, you will:     Obtain an API token from Slack.   Create a context to store those credentials in CircleCI.   Trigger the pipeline so you receive a notification.     a. Authenticate your application  The Slack orb is an application that executes as part of your job on CircleCI. Before you can receive notifications, you need to authenticate your application.   i. Create a Slack app    Visit  Your Apps on the Slack API website and select the green Create an App button.        Choose From scratch.        Give your app a name, for example, CircleCI, and select the Slack workspace in which you want to use it. You cannot change this workspace afterwards.        Select the green Create App button.      ii. Set your app permissions    On the Basic Information page, locate the Permissions tile under Add features and functionality.        On the OAuth & Permissions page, scroll down to Scopes. This is where you need to create the permissions for your Slack app.        Under Bot Token Scopes, select Add an OAuth Scope.   The Slack orb needs permission to post chat messages and upload files, so create the following scopes:    chat:write   chat:write.public   files:write                To receive Slack notifications in a private channel, you need to add your Slack app to that channel. Open the channel, select the photos of the channel members in the top right-hand corner, then select the Integrations tab. From here, you can add an app.         iii. Install your app    Once you have created your scopes, scroll up to the top of the page and select the Install to Workspace button.        You will then be asked to grant permission for the app to access your Slack workspace.        Select the disclosure triangle to double-check the permissions, then select the green Allow button.   You should see a Bot User OAuth Token. Copy this token to your clipboard, ready to add it to CircleCI. Make sure you keep this private.            b. Create a context  In CircleCI, contexts allow you to secure and share environment variables across projects. Once you have created a context with your Slack credentials, you and your colleagues will be able to reuse them.   In CircleCI:     Select the Organization Settings page.        Under Context, select the blue Create Context button and add a unique name, such as slack-secrets (that is the name specified in the config.yml file above).        Select the blue Create Context button.   Select the name of the context you just created.   Select the blue Add Environment Variable button and enter your first key value pair.    The Environment Variable Name is SLACK_ACCESS_TOKEN.   The value is your Slack Bot User OAuth Access Token.           Select the Add Environment Variable button to save it.   Select the blue Add Environment Variable button again.    The Environment Variable Name is SLACK_DEFAULT_CHANNEL.   The value is the ID of the default Slack channel for posting your notifications. You can override this setting in your individual jobs.     To get the ID for your Slack channel, right-click the channel in Slack and choose Copy Link. The ID will be visible at the end of the URL and will be in this format: C034R26AM36.                 Include the slack-secrets context in your notify job as follows:   workflows:
  send-notification:
    jobs:
      - notify:
          context: slack-secrets          You can reuse this context in other jobs and projects.         c. Trigger an alert    Commit your config.yml file (and push it, if you are working remotely). This triggers your CircleCI pipeline, which uses the Slack orb with your credentials.  You should then see a green Success badge and a green tick next to your notify job.         Select your job to see what just happened. You should see the message body that was sent to Slack.   Now open your Slack workspace. In the default channel you specified earlier, you should see the alert triggered by your CircleCI pipeline.          Although this is a basic alert, you have achieved a lot already:     Created a .circleci/config.yml file with the Slack orb.   Created a context to store your Slack-related environment variables.   Created a Slack app.        3. Use message templates   The Slack orb includes several notification templates you can use to notify your channel of various CircleCI events:     basic_success_1 - for pass events where the job succeeded.   basic_fail_1 - for fail events, where the job failed.   success_tagged_deploy_1 - for successful deployments.   basic_on_hold_1 - for on-hold jobs that are awaiting approval.     To use these templates in your job, include the event and template parameters under steps in the config.yml file. For example:    jobs:
  notify:
    docker:
      - image: cimg/base:current
    steps:
- slack/notify:
	  event: fail
	  template: basic_fail_1
- slack/notify:
	  event: pass
	  template: success_tagged_deploy_1      Line 7 specifies that the template on the next line is used for failed events.   Line 8 specifies the template to be used, in this case basic_fail_1.   Line 9 specifies that the template on the next line is used for pass events.   Line 10 specifies the template to be used, in this case basic_success_1.     Whereas in Step 1 you used an all-purpose alert, now you have included different steps according to whether the job has passed or failed. The Slack orb triggers the appropriate step.   Commit your updated config.yml file (and push it, if you are working remotely). Once the pipeline is complete, you should see a more sophisticated alert in your Slack channel.        a. Including additional parameters  You can also include a mention for a failed job, to alert a specific person or team:    - slack/notify:
	event: fail
	mentions: '@EngineeringTeam'
	template: basic_fail_1    To notify multiple channels, place the IDs in quotes and separate them with a comma:    - slack/notify:
    channel: 'ABCXYZ, ZXCBN'
    event: fail
    template: basic_fail_1    To restrict your alert to a specific branch, add a branch_pattern parameter:     - slack/notify:
      branch_pattern: main
      event: fail
      template: basic_fail_1    Restricting your alert to a specific branch is useful if, for example, you do not want to receive alerts for feature branches.    b. Use the Slack Block Kit Builder  If you would like to further customize your notifications, you can use the  Slack Block Kit Builder. This framework allows you to create sophisticated notifications, using images, form fields, and other interactive elements.   Once you have created your block (which is a JSON object), copy and paste it into your config.yml file within the custom parameter:    - slack/notify:
    event: always
    custom: | # your custom notification goes here
      {
        "blocks": [
          {
            "type": "section",
            "fields": [
              {
                "type": "plain_text",
                "text": "*This is a text notification*",
                "emoji": true
              }
            ]
          }
        ]
      }       Conclusion   In this tutorial, you have configured the Slack orb to send CircleCI notifications to your Slack channel. You created a basic notification, built and authenticated your Slack app, and used templates.   For further configuration options, take a look at the  Slack orb documentation. You can also find many more orbs in the  Orb Registry.   Suggest an edit to this pageMake a contribution Learn how to contributeStill need help? Ask the CircleCI community Join the research community Visit our Support site\n\nUse the Slack orb to set up notifications4 months ago6 min readCloudServer v4+On This PageIntroduction1. Create your config.yml file2. Connect CircleCI with Slacka. Authenticate your applicationi. Create a Slack appii. Set your app permissionsiii. Install your appb. Create a contextc. Trigger an alert3. Use message templatesa. Including additional parametersb. Use the Slack Block Kit BuilderConclusion   This guide gets you started with the CircleCI Slack orb.     Introduction   Orbs are shareable packages of reusable configuration elements. They help you reduce complexity, integrate your software with third-party apps, and save time.   One of CircleCI’s most popular orbs is the Slack orb. The Slack orb allows you to implement event-based notifications across all your CI/CD pipelines. Using either built-in message templates or Slack’s visual Block Kit Builder, you can create and customize notifications specific to your organization’s needs.   In this tutorial, you will learn how to:     Create a config.yml file using the Slack orb.   Store your Slack credentials securely in a context.   Use templates to create alerts for successful and failed builds.   Alert specific channels, teams, or people.   Access the Slack Block Kit Builder to create your own customized alerts.     To follow this tutorial, you need:     A CircleCI account (you can  sign up for free) connected to either GitHub, Bitbucket, or GitLab.   A  Slack workspace (you can create your own for testing purposes, if you do not want to use your company workspace).   A project you are following in CircleCI for which you want to integrate Slack notifications. See the  Quickstart guide for help with following a project.       1. Create your config.yml file   If you have not already done so, create a .circleci folder at the root of your repo. Inside the .circleci folder, create a config.yml file.   The sample code below shows the basics you need to set up Slack notifications into your config.yml file. You can copy and paste the whole thing or take the individual elements and incorporate into your project config.yml file:    version: 2.1
orbs:
  slack: circleci/slack@4.9.3
jobs:
  notify:
    docker:
      - image: cimg/base:current
    steps:
      - slack/notify:
          custom: |
            {
              "blocks": [
                {
                  "type": "section",
                  "fields": [
                    {
                      "type": "plain_text",
                      "text": "*This is a text notification*",
                      "emoji": true
                    }
                  ]
                }
              ]
            }
          event: always
workflows:
  send-notification:
    jobs:
      - notify    The following commentary describes what occurs in the main elements of the sample code:     Line 1: This indicates the config version you are using. 2.1 is the most recent version.   Lines 2-3: This is the orbs stanza. You are using the slack: circleci/slack@4.9.3 orb.   Lines 5-7: This is a job called notify, which is executed in a basic Docker container.   Lines 8-9: This is a step which must be called slack/notify to work with the Slack orb.   Lines 10-24: This custom block includes a basic notification from the Slack Block Kit Builder. As you can see, it is in JSON format. In Part 3, you will use more sophisticated templates.   Line 25: The event: always parameter means this notification is triggered for all event types. In Part 3, you will use different notifications for different events.   Line 30: This references a CircleCI context where you will save your Slack credentials in Step 2.     Now you have a basic config.yml file set up, you can connect CircleCI with Slack.      If you commit your config.yml file at this point and trigger a pipeline, your build will fail. This is because you need to add your Slack credentials in the next step.          2. Connect CircleCI with Slack   In this step, you will:     Obtain an API token from Slack.   Create a context to store those credentials in CircleCI.   Trigger the pipeline so you receive a notification.     a. Authenticate your application  The Slack orb is an application that executes as part of your job on CircleCI. Before you can receive notifications, you need to authenticate your application.   i. Create a Slack app    Visit  Your Apps on the Slack API website and select the green Create an App button.        Choose From scratch.        Give your app a name, for example, CircleCI, and select the Slack workspace in which you want to use it. You cannot change this workspace afterwards.        Select the green Create App button.      ii. Set your app permissions    On the Basic Information page, locate the Permissions tile under Add features and functionality.        On the OAuth & Permissions page, scroll down to Scopes. This is where you need to create the permissions for your Slack app.        Under Bot Token Scopes, select Add an OAuth Scope.   The Slack orb needs permission to post chat messages and upload files, so create the following scopes:    chat:write   chat:write.public   files:write                To receive Slack notifications in a private channel, you need to add your Slack app to that channel. Open the channel, select the photos of the channel members in the top right-hand corner, then select the Integrations tab. From here, you can add an app.         iii. Install your app    Once you have created your scopes, scroll up to the top of the page and select the Install to Workspace button.        You will then be asked to grant permission for the app to access your Slack workspace.        Select the disclosure triangle to double-check the permissions, then select the green Allow button.   You should see a Bot User OAuth Token. Copy this token to your clipboard, ready to add it to CircleCI. Make sure you keep this private.            b. Create a context  In CircleCI, contexts allow you to secure and share environment variables across projects. Once you have created a context with your Slack credentials, you and your colleagues will be able to reuse them.   In CircleCI:     Select the Organization Settings page.        Under Context, select the blue Create Context button and add a unique name, such as slack-secrets (that is the name specified in the config.yml file above).        Select the blue Create Context button.   Select the name of the context you just created.   Select the blue Add Environment Variable button and enter your first key value pair.    The Environment Variable Name is SLACK_ACCESS_TOKEN.   The value is your Slack Bot User OAuth Access Token.           Select the Add Environment Variable button to save it.   Select the blue Add Environment Variable button again.    The Environment Variable Name is SLACK_DEFAULT_CHANNEL.   The value is the ID of the default Slack channel for posting your notifications. You can override this setting in your individual jobs.     To get the ID for your Slack channel, right-click the channel in Slack and choose Copy Link. The ID will be visible at the end of the URL and will be in this format: C034R26AM36.                 Include the slack-secrets context in your notify job as follows:   workflows:
  send-notification:
    jobs:
      - notify:
          context: slack-secrets          You can reuse this context in other jobs and projects.         c. Trigger an alert    Commit your config.yml file (and push it, if you are working remotely). This triggers your CircleCI pipeline, which uses the Slack orb with your credentials.  You should then see a green Success badge and a green tick next to your notify job.         Select your job to see what just happened. You should see the message body that was sent to Slack.   Now open your Slack workspace. In the default channel you specified earlier, you should see the alert triggered by your CircleCI pipeline.          Although this is a basic alert, you have achieved a lot already:     Created a .circleci/config.yml file with the Slack orb.   Created a context to store your Slack-related environment variables.   Created a Slack app.        3. Use message templates   The Slack orb includes several notification templates you can use to notify your channel of various CircleCI events:     basic_success_1 - for pass events where the job succeeded.   basic_fail_1 - for fail events, where the job failed.   success_tagged_deploy_1 - for successful deployments.   basic_on_hold_1 - for on-hold jobs that are awaiting approval.     To use these templates in your job, include the event and template parameters under steps in the config.yml file. For example:    jobs:
  notify:
    docker:
      - image: cimg/base:current
    steps:
- slack/notify:
	  event: fail
	  template: basic_fail_1
- slack/notify:
	  event: pass
	  template: success_tagged_deploy_1      Line 7 specifies that the template on the next line is used for failed events.   Line 8 specifies the template to be used, in this case basic_fail_1.   Line 9 specifies that the template on the next line is used for pass events.   Line 10 specifies the template to be used, in this case basic_success_1.     Whereas in Step 1 you used an all-purpose alert, now you have included different steps according to whether the job has passed or failed. The Slack orb triggers the appropriate step.   Commit your updated config.yml file (and push it, if you are working remotely). Once the pipeline is complete, you should see a more sophisticated alert in your Slack channel.        a. Including additional parameters  You can also include a mention for a failed job, to alert a specific person or team:    - slack/notify:
	event: fail
	mentions: '@EngineeringTeam'
	template: basic_fail_1    To notify multiple channels, place the IDs in quotes and separate them with a comma:    - slack/notify:
    channel: 'ABCXYZ, ZXCBN'
    event: fail
    template: basic_fail_1    To restrict your alert to a specific branch, add a branch_pattern parameter:     - slack/notify:
      branch_pattern: main
      event: fail
      template: basic_fail_1    Restricting your alert to a specific branch is useful if, for example, you do not want to receive alerts for feature branches.    b. Use the Slack Block Kit Builder  If you would like to further customize your notifications, you can use the  Slack Block Kit Builder. This framework allows you to create sophisticated notifications, using images, form fields, and other interactive elements.   Once you have created your block (which is a JSON object), copy and paste it into your config.yml file within the custom parameter:    - slack/notify:
    event: always
    custom: | # your custom notification goes here
      {
        "blocks": [
          {
            "type": "section",
            "fields": [
              {
                "type": "plain_text",
                "text": "*This is a text notification*",
                "emoji": true
              }
            ]
          }
        ]
      }       Conclusion   In this tutorial, you have configured the Slack orb to send CircleCI notifications to your Slack channel. You created a basic notification, built and authenticated your Slack app, and used templates.   For further configuration options, take a look at the  Slack orb documentation. You can also find many more orbs in the  Orb Registry.   Suggest an edit to this pageMake a contribution Learn how to contributeStill need help? Ask the CircleCI community Join the research community Visit our Support site DocsTerms of UsePrivacy PolicyCookie PolicySecurity© 2025 Circle Internet Services, Inc., All Rights Reserved.\n\nversion: 2.1
orbs:
  slack: circleci/slack@4.9.3
jobs:
  notify:
    docker:
      - image: cimg/base:current
    steps:
      - slack/notify:
          custom: |
            {
              "blocks": [
                {
                  "type": "section",
                  "fields": [
                    {
                      "type": "plain_text",
                      "text": "*This is a text notification*",
                      "emoji": true
                    }
                  ]
                }
              ]
            }
          event: always
workflows:
  send-notification:
    jobs:
      - notify  If you commit your config.yml file at this point and trigger a pipeline, your build will fail. This is because you need to add your Slack credentials in the next step.              To receive Slack notifications in a private channel, you need to add your Slack app to that channel. Open the channel, select the photos of the channel members in the top right-hand corner, then select the Integrations tab. From here, you can add an app.              To get the ID for your Slack channel, right-click the channel in Slack and choose Copy Link. The ID will be visible at the end of the URL and will be in this format: C034R26AM36.    workflows:
  send-notification:
    jobs:
      - notify:
          context: slack-secrets  You can reuse this context in other jobs and projects.      jobs:
  notify:
    docker:
      - image: cimg/base:current
    steps:
- slack/notify:
	  event: fail
	  template: basic_fail_1
- slack/notify:
	  event: pass
	  template: success_tagged_deploy_1    - slack/notify:
	event: fail
	mentions: '@EngineeringTeam'
	template: basic_fail_1  - slack/notify:
    channel: 'ABCXYZ, ZXCBN'
    event: fail
    template: basic_fail_1   - slack/notify:
      branch_pattern: main
      event: fail
      template: basic_fail_1  - slack/notify:
    event: always
    custom: | # your custom notification goes here
      {
        "blocks": [
          {
            "type": "section",
            "fields": [
              {
                "type": "plain_text",
                "text": "*This is a text notification*",
                "emoji": true
              }
            ]
          }
        ]
      }\n\n\n\nExecution environments overview4 months ago3 min readCloudServer v4+On This PageExecutorsImages, containers, and virtual machinesResource classDockerLinux VMmacOSWindowsGPUArm VMSelf-hosted runnerPort rangesNext steps   CircleCI offers several execution environments:     Docker (x86 or Arm)   Linux VM (virtual machine)   macOS   Windows   GPU   Arm VM     Each job defined in your project configuration is run in a separate execution environment, either a Docker container or a virtual machine.     Executors   For each job in your project config you will specify an execution environment by assigning it an executor. An executor defines the underlying technology or environment in which to run a job, and which image to use to suit your job.   It is possible to specify a different executor and image for each job in your  .configuration file.   Images, containers, and virtual machines  An image is a packaged system that has the instructions for creating a running environment.   A container or virtual machine is the term used for a running instance of an image.   For example:     Jobs that require Docker images (docker) may use an image for Node.js, Python etc. The  pre-built CircleCI Docker image (convenience images) will help you get started. CircleCI convenience images are not a full operating system, so they generally make building your software more efficient.   Jobs that require a complete Linux virtual machine (VM) image (machine) may use an Ubuntu version supported by the  list of available machine images.   Jobs that require a macOS VM image (macos) may use an Xcode version. A full list is available on the  Using macOS page.      Resource class  When you configure an executor it is recommended that you also specify a resource class to specify compute resource size (CPU and RAM).     For an overview of resource classes, see the  Resource class overview page.   For an overview of available resource classes per Plan, see the  Pricing page.        Docker      Legacy images with the prefix "circleci/" were  deprecated on December 31, 2021. For faster builds, upgrade your projects with  next-generation convenience images.        To access the Docker execution environment, use the docker executor and specify an image. For a full list of convenience images, which are built by CircleCI, see the  CircleCI Developer Hub    jobs:
  build: # name of your job
    docker: # executor type
      - image: cimg/base:stable # primary container will run the latest, production-ready base image

    steps:
        # Commands run in the primary container    Find out more about the Docker execution environment on the  Using Docker page.     Linux VM      CircleCI cloud The use of machine: true is deprecated. You must specify an image to use.        To access the Linux VM execution environment, use the machine executor and specify a Linux image. For a full list of machine images, see the  CircleCI Developer Hub  CloudServer    jobs:
  build: # name of your job
    machine: # executor type
      image: ubuntu-2204:current

    steps:
        # Commands run in a Linux virtual machine environment        jobs:
  build: # name of your job
    machine: true # executor type
    steps:
      # Commands run in a Linux virtual machine environment       Find out more about the Linux VM execution environment in the  Using Linux Virtual Machines page.     macOS   To access the macOS execution environment, use the macos executor and specify an image using the xcode key. For a full list of macOS images, see the  CircleCI Developer Hub.      If you want to run a macOS build on CircleCI server, you will need to use  self-hosted runner.         jobs:
  build: # name of your job
    macos: # executor type
      xcode: 14.2.0

    steps:
      # Commands run in a macOS virtual machine environment
      # with Xcode 14.2.0 installed    Find out more about the macOS execution environment on the  Using macOS page.     Windows   To access the Windows execution environment, you can either:     Use the Windows orb and specify one of the default executors.   Use the machine executor and specify a Windows image.     For a full list of machine images, see the  CircleCI Developer Hub.  Cloud with orbCloudServer    version: 2.1

orbs:
  win: circleci/windows@4.1.1 # The Windows orb gives you everything you need to start using the Windows executor

jobs:
  build: # name of your job
    executor: win/server-2022 # use one of the executors defined within the windows orb

    steps:
      # Commands are run in a Windows virtual machine environment
      - checkout
      - run: Write-Host 'Hello, Windows'        version: 2.1

jobs:
  build: # name of your job
    resource_class: 'windows.medium'
    machine:
      image: 'windows-server-2022-gui:current'
      shell: 'powershell.exe -ExecutionPolicy Bypass'
    steps:
      # Commands are run in a Windows virtual machine environment
        - checkout
        - run: Write-Host 'Hello, Windows'        version: 2.1

jobs:
  build: # name of your job
    machine:
      image: windows-default
    steps:
      # Commands are run in a Windows virtual machine environment
        - checkout
        - run: Write-Host 'Hello, Windows'        Find out more about the Windows execution environment in the  Using the Windows Execution Environment page. See  the Windows orb page in the developer hub for the list of options available in the Windows orb.     GPU   To access the GPU execution environment, use one of the following:     The Windows orb and specify the GPU-enabled executor.   The machine executor and specify a Linux or Windows GPU-enabled image.     For a full list of machine images, see the  CircleCI Developer Hub.      It is not possible to run a GPU build on CircleCI server.       LinuxWindows without orbWindows with orb    version: 2.1

jobs:
  build:
    machine:
      image: linux-cuda-12:default
    resource_class: gpu.nvidia.medium
    steps:
      - run: nvidia-smi        version: 2.1

jobs:
  build:
    machine:
      image: windows-server-2019-cuda
    resource_class: gpu.nvidia.small
    steps:
      - run: nvidia-smi        version: 2.1

orbs:
  win: circleci/windows@4.1.1

jobs:
  build:
    executor: win/server-2019-cuda
    steps:
      - run: 'Write-Host ''Hello, Windows'''        Find out more about the GPU execution environment on the  Using the GPU Execution Environment page.     Arm VM   To access the Arm VM execution environment, use the machine executor as detailed below, and specify either the arm.medium or the arm.large resource class. For a full list of machine images, see the  CircleCI Developer Hub.  CloudServer on AWS    # .circleci/config.yml
version: 2.1

jobs:
  build-medium:
    machine:
      image: ubuntu-2204:current
    resource_class: arm.medium
    steps:
      - run: uname -a
      - run: echo "Hello, Arm!"

  build-large:
    machine:
      image: ubuntu-2204:current
    resource_class: arm.large
    steps:
      - run: uname -a
      - run: echo "Hello, Arm!"

workflows:
  build:
    jobs:
      - build-medium
      - build-large        # .circleci/config.yml
version: 2.1

jobs:
  build-medium:
    machine:
      image: arm-default
    resource_class: arm.medium
    steps:
      - run: uname -a
      - run: echo "Hello, Arm!"

  build-large:
    machine:
      image: arm-default
    resource_class: arm.large
    steps:
      - run: uname -a
      - run: echo "Hello, Arm!"

workflows:
  build:
    jobs:
      - build-medium
      - build-large       Find out more about the Arm VM execution environment in the  Using the Arm VM Execution Environment page. You can also use  Arm on Docker.     Self-hosted runner   CircleCI provides the ability to have self-hosted runners:      Container runner using Kubernetes.    Machine runner using Linux, Windows, and macOS virtual machines.       Port ranges   When using a machine executor, if a port range is hard coded, the range in /proc/sys/net/ipv4/ip_local_reserved_ports should be avoided. Port range 32768 - 60999 is used by the TCP stack to allocate ephemeral ports for connections. Ports in that range may have already been allocated by a previous connection, so collisions are possible.     Next steps     Read more about  Pre-built CircleCI convenience images for the Docker execution environment.     Suggest an edit to this pageMake a contribution Learn how to contributeStill need help? Ask the CircleCI community Join the research community Visit our Support site\n\nExecution environments overview4 months ago3 min readCloudServer v4+On This PageExecutorsImages, containers, and virtual machinesResource classDockerLinux VMmacOSWindowsGPUArm VMSelf-hosted runnerPort rangesNext steps   CircleCI offers several execution environments:     Docker (x86 or Arm)   Linux VM (virtual machine)   macOS   Windows   GPU   Arm VM     Each job defined in your project configuration is run in a separate execution environment, either a Docker container or a virtual machine.     Executors   For each job in your project config you will specify an execution environment by assigning it an executor. An executor defines the underlying technology or environment in which to run a job, and which image to use to suit your job.   It is possible to specify a different executor and image for each job in your  .configuration file.   Images, containers, and virtual machines  An image is a packaged system that has the instructions for creating a running environment.   A container or virtual machine is the term used for a running instance of an image.   For example:     Jobs that require Docker images (docker) may use an image for Node.js, Python etc. The  pre-built CircleCI Docker image (convenience images) will help you get started. CircleCI convenience images are not a full operating system, so they generally make building your software more efficient.   Jobs that require a complete Linux virtual machine (VM) image (machine) may use an Ubuntu version supported by the  list of available machine images.   Jobs that require a macOS VM image (macos) may use an Xcode version. A full list is available on the  Using macOS page.      Resource class  When you configure an executor it is recommended that you also specify a resource class to specify compute resource size (CPU and RAM).     For an overview of resource classes, see the  Resource class overview page.   For an overview of available resource classes per Plan, see the  Pricing page.        Docker      Legacy images with the prefix "circleci/" were  deprecated on December 31, 2021. For faster builds, upgrade your projects with  next-generation convenience images.        To access the Docker execution environment, use the docker executor and specify an image. For a full list of convenience images, which are built by CircleCI, see the  CircleCI Developer Hub    jobs:
  build: # name of your job
    docker: # executor type
      - image: cimg/base:stable # primary container will run the latest, production-ready base image

    steps:
        # Commands run in the primary container    Find out more about the Docker execution environment on the  Using Docker page.     Linux VM      CircleCI cloud The use of machine: true is deprecated. You must specify an image to use.        To access the Linux VM execution environment, use the machine executor and specify a Linux image. For a full list of machine images, see the  CircleCI Developer Hub  CloudServer    jobs:
  build: # name of your job
    machine: # executor type
      image: ubuntu-2204:current

    steps:
        # Commands run in a Linux virtual machine environment        jobs:
  build: # name of your job
    machine: true # executor type
    steps:
      # Commands run in a Linux virtual machine environment       Find out more about the Linux VM execution environment in the  Using Linux Virtual Machines page.     macOS   To access the macOS execution environment, use the macos executor and specify an image using the xcode key. For a full list of macOS images, see the  CircleCI Developer Hub.      If you want to run a macOS build on CircleCI server, you will need to use  self-hosted runner.         jobs:
  build: # name of your job
    macos: # executor type
      xcode: 14.2.0

    steps:
      # Commands run in a macOS virtual machine environment
      # with Xcode 14.2.0 installed    Find out more about the macOS execution environment on the  Using macOS page.     Windows   To access the Windows execution environment, you can either:     Use the Windows orb and specify one of the default executors.   Use the machine executor and specify a Windows image.     For a full list of machine images, see the  CircleCI Developer Hub.  Cloud with orbCloudServer    version: 2.1

orbs:
  win: circleci/windows@4.1.1 # The Windows orb gives you everything you need to start using the Windows executor

jobs:
  build: # name of your job
    executor: win/server-2022 # use one of the executors defined within the windows orb

    steps:
      # Commands are run in a Windows virtual machine environment
      - checkout
      - run: Write-Host 'Hello, Windows'        version: 2.1

jobs:
  build: # name of your job
    resource_class: 'windows.medium'
    machine:
      image: 'windows-server-2022-gui:current'
      shell: 'powershell.exe -ExecutionPolicy Bypass'
    steps:
      # Commands are run in a Windows virtual machine environment
        - checkout
        - run: Write-Host 'Hello, Windows'        version: 2.1

jobs:
  build: # name of your job
    machine:
      image: windows-default
    steps:
      # Commands are run in a Windows virtual machine environment
        - checkout
        - run: Write-Host 'Hello, Windows'        Find out more about the Windows execution environment in the  Using the Windows Execution Environment page. See  the Windows orb page in the developer hub for the list of options available in the Windows orb.     GPU   To access the GPU execution environment, use one of the following:     The Windows orb and specify the GPU-enabled executor.   The machine executor and specify a Linux or Windows GPU-enabled image.     For a full list of machine images, see the  CircleCI Developer Hub.      It is not possible to run a GPU build on CircleCI server.       LinuxWindows without orbWindows with orb    version: 2.1

jobs:
  build:
    machine:
      image: linux-cuda-12:default
    resource_class: gpu.nvidia.medium
    steps:
      - run: nvidia-smi        version: 2.1

jobs:
  build:
    machine:
      image: windows-server-2019-cuda
    resource_class: gpu.nvidia.small
    steps:
      - run: nvidia-smi        version: 2.1

orbs:
  win: circleci/windows@4.1.1

jobs:
  build:
    executor: win/server-2019-cuda
    steps:
      - run: 'Write-Host ''Hello, Windows'''        Find out more about the GPU execution environment on the  Using the GPU Execution Environment page.     Arm VM   To access the Arm VM execution environment, use the machine executor as detailed below, and specify either the arm.medium or the arm.large resource class. For a full list of machine images, see the  CircleCI Developer Hub.  CloudServer on AWS    # .circleci/config.yml
version: 2.1

jobs:
  build-medium:
    machine:
      image: ubuntu-2204:current
    resource_class: arm.medium
    steps:
      - run: uname -a
      - run: echo "Hello, Arm!"

  build-large:
    machine:
      image: ubuntu-2204:current
    resource_class: arm.large
    steps:
      - run: uname -a
      - run: echo "Hello, Arm!"

workflows:
  build:
    jobs:
      - build-medium
      - build-large        # .circleci/config.yml
version: 2.1

jobs:
  build-medium:
    machine:
      image: arm-default
    resource_class: arm.medium
    steps:
      - run: uname -a
      - run: echo "Hello, Arm!"

  build-large:
    machine:
      image: arm-default
    resource_class: arm.large
    steps:
      - run: uname -a
      - run: echo "Hello, Arm!"

workflows:
  build:
    jobs:
      - build-medium
      - build-large       Find out more about the Arm VM execution environment in the  Using the Arm VM Execution Environment page. You can also use  Arm on Docker.     Self-hosted runner   CircleCI provides the ability to have self-hosted runners:      Container runner using Kubernetes.    Machine runner using Linux, Windows, and macOS virtual machines.       Port ranges   When using a machine executor, if a port range is hard coded, the range in /proc/sys/net/ipv4/ip_local_reserved_ports should be avoided. Port range 32768 - 60999 is used by the TCP stack to allocate ephemeral ports for connections. Ports in that range may have already been allocated by a previous connection, so collisions are possible.     Next steps     Read more about  Pre-built CircleCI convenience images for the Docker execution environment.     Suggest an edit to this pageMake a contribution Learn how to contributeStill need help? Ask the CircleCI community Join the research community Visit our Support site DocsTerms of UsePrivacy PolicyCookie PolicySecurity© 2025 Circle Internet Services, Inc., All Rights Reserved.\n\nLegacy images with the prefix "circleci/" were  deprecated on December 31, 2021. For faster builds, upgrade your projects with  next-generation convenience images.  jobs:
  build: # name of your job
    docker: # executor type
      - image: cimg/base:stable # primary container will run the latest, production-ready base image

    steps:
        # Commands run in the primary container  CircleCI cloud The use of machine: true is deprecated. You must specify an image to use.    jobs:
  build: # name of your job
    machine: # executor type
      image: ubuntu-2204:current

    steps:
        # Commands run in a Linux virtual machine environment    jobs:
  build: # name of your job
    machine: # executor type
      image: ubuntu-2204:current

    steps:
        # Commands run in a Linux virtual machine environment    jobs:
  build: # name of your job
    machine: true # executor type
    steps:
      # Commands run in a Linux virtual machine environment    jobs:
  build: # name of your job
    machine: true # executor type
    steps:
      # Commands run in a Linux virtual machine environment  If you want to run a macOS build on CircleCI server, you will need to use  self-hosted runner.  jobs:
  build: # name of your job
    macos: # executor type
      xcode: 14.2.0

    steps:
      # Commands run in a macOS virtual machine environment
      # with Xcode 14.2.0 installed    version: 2.1

orbs:
  win: circleci/windows@4.1.1 # The Windows orb gives you everything you need to start using the Windows executor

jobs:
  build: # name of your job
    executor: win/server-2022 # use one of the executors defined within the windows orb

    steps:
      # Commands are run in a Windows virtual machine environment
      - checkout
      - run: Write-Host 'Hello, Windows'    version: 2.1

orbs:
  win: circleci/windows@4.1.1 # The Windows orb gives you everything you need to start using the Windows executor

jobs:
  build: # name of your job
    executor: win/server-2022 # use one of the executors defined within the windows orb

    steps:
      # Commands are run in a Windows virtual machine environment
      - checkout
      - run: Write-Host 'Hello, Windows'    version: 2.1

jobs:
  build: # name of your job
    resource_class: 'windows.medium'
    machine:
      image: 'windows-server-2022-gui:current'
      shell: 'powershell.exe -ExecutionPolicy Bypass'
    steps:
      # Commands are run in a Windows virtual machine environment
        - checkout
        - run: Write-Host 'Hello, Windows'    version: 2.1

jobs:
  build: # name of your job
    resource_class: 'windows.medium'
    machine:
      image: 'windows-server-2022-gui:current'
      shell: 'powershell.exe -ExecutionPolicy Bypass'
    steps:
      # Commands are run in a Windows virtual machine environment
        - checkout
        - run: Write-Host 'Hello, Windows'    version: 2.1

jobs:
  build: # name of your job
    machine:
      image: windows-default
    steps:
      # Commands are run in a Windows virtual machine environment
        - checkout
        - run: Write-Host 'Hello, Windows'    version: 2.1

jobs:
  build: # name of your job
    machine:
      image: windows-default
    steps:
      # Commands are run in a Windows virtual machine environment
        - checkout
        - run: Write-Host 'Hello, Windows'  It is not possible to run a GPU build on CircleCI server.    version: 2.1

jobs:
  build:
    machine:
      image: linux-cuda-12:default
    resource_class: gpu.nvidia.medium
    steps:
      - run: nvidia-smi    version: 2.1

jobs:
  build:
    machine:
      image: linux-cuda-12:default
    resource_class: gpu.nvidia.medium
    steps:
      - run: nvidia-smi    version: 2.1

jobs:
  build:
    machine:
      image: windows-server-2019-cuda
    resource_class: gpu.nvidia.small
    steps:
      - run: nvidia-smi    version: 2.1

jobs:
  build:
    machine:
      image: windows-server-2019-cuda
    resource_class: gpu.nvidia.small
    steps:
      - run: nvidia-smi    version: 2.1

orbs:
  win: circleci/windows@4.1.1

jobs:
  build:
    executor: win/server-2019-cuda
    steps:
      - run: 'Write-Host ''Hello, Windows'''    version: 2.1

orbs:
  win: circleci/windows@4.1.1

jobs:
  build:
    executor: win/server-2019-cuda
    steps:
      - run: 'Write-Host ''Hello, Windows'''    # .circleci/config.yml
version: 2.1

jobs:
  build-medium:
    machine:
      image: ubuntu-2204:current
    resource_class: arm.medium
    steps:
      - run: uname -a
      - run: echo "Hello, Arm!"

  build-large:
    machine:
      image: ubuntu-2204:current
    resource_class: arm.large
    steps:
      - run: uname -a
      - run: echo "Hello, Arm!"

workflows:
  build:
    jobs:
      - build-medium
      - build-large    # .circleci/config.yml
version: 2.1

jobs:
  build-medium:
    machine:
      image: ubuntu-2204:current
    resource_class: arm.medium
    steps:
      - run: uname -a
      - run: echo "Hello, Arm!"

  build-large:
    machine:
      image: ubuntu-2204:current
    resource_class: arm.large
    steps:
      - run: uname -a
      - run: echo "Hello, Arm!"

workflows:
  build:
    jobs:
      - build-medium
      - build-large    # .circleci/config.yml
version: 2.1

jobs:
  build-medium:
    machine:
      image: arm-default
    resource_class: arm.medium
    steps:
      - run: uname -a
      - run: echo "Hello, Arm!"

  build-large:
    machine:
      image: arm-default
    resource_class: arm.large
    steps:
      - run: uname -a
      - run: echo "Hello, Arm!"

workflows:
  build:
    jobs:
      - build-medium
      - build-large    # .circleci/config.yml
version: 2.1

jobs:
  build-medium:
    machine:
      image: arm-default
    resource_class: arm.medium
    steps:
      - run: uname -a
      - run: echo "Hello, Arm!"

  build-large:
    machine:
      image: arm-default
    resource_class: arm.large
    steps:
      - run: uname -a
      - run: echo "Hello, Arm!"

workflows:
  build:
    jobs:
      - build-medium
      - build-large\n\n\n\nPipelines and triggers overview1 week ago14 min readCloudServer v4+On This PagePipelines dashboardPipelines and triggersPipelinesAdd or edit a pipelineTriggersAdd a triggerPipeline parametersVS Code extensionTroubleshootingConfig could not be located errorWhy is my scheduled pipeline not running?Why are my jobs not running when I push commits?Why is my job queued?Why are my jobs queuing even though I am on the Performance Plan?Why can I not find my project on the Projects dashboard?How do Docker image names work? Where do they come from?What is the best practice for specifying image versions?How can I set the timezone in Docker images?FAQsIs it possible to split the .circleci/config.yml into different files?Can I trigger forked PRs using pipelines?Next steps   CircleCI pipelines are the highest-level unit of work in your CI/CD process. Defined by a configuration file (typically .circleci/config.yml), pipelines orchestrate the execution of workflows which run jobs to build, test, and deploy your code.   Pipelines can be triggered in the following ways:     Automatically: Git events, scheduled events, custom webhooks   Manually: CircleCI app or API     Pipelines provide a flexible framework for creating conditional workflows based on  filters,  job requirements, and  pipeline parameters, allowing you to customize your CI/CD process to fit your project’s needs.     Pipelines dashboard   Your pipelines dashboard displays recently-triggered pipelines for your organization. Use the various filters to find the pipelines you need. Select workflow and job names to  view workflow maps and individual job steps. Use the quick controls on the right of the screen to rerun and cancel workflows.        From the pipelines dashboard you can find the pipeline ID. The pipeline ID is a unique ID for a pipeline that has been triggered. You can use the pipeline ID to access pipeline information via the  API.          Pipelines and triggers      The pipeline and trigger features available to you depend on how your code is integrated and where it is stored. For a feature availability overview, see the  VCS integration overview page.           Using CircleCI server? The Pipeline and Trigger pages under Project Settings and pipeline and trigger add/edit functionality is not available.        Set up pipelines to define the various CI/CD "units" that make up your project.   Set up triggers to define when and how each of your pipelines should be run. Triggers may be from external services (custom webhooks), from commits or tags on a version control system, or set up to run on a schedule.   Pipelines  A pipeline defines a unit of work that can be run within your projects. Each pipeline is defined by two key characteristics:     A config source, which is a configuration file stored in a repository. The default config source location is .circleci/config.yml within the same repository as your code.     For GitHub App and Bitbucket Data Center pipelines you can choose any file path (with extension *.yml) in any repository.         A checkout source, which determines which repository will be checked out when running a  checkout step.     This model allows your CircleCI config to be stored in a different repository from your code. This is currently supported for GitHub App and Bitbucket Data Center pipelines.           A project can have one or more pipelines, and each pipeline can be associated with zero or more triggers.   When you create a project in CircleCI and follow the in-app project creation flow to connect it to a repository, a first pipeline is set up for you automatically. The config file used for your first pipeline is either a file you commit yourself or one generated by CircleCI based on the code in your project. You can identify the type (GitHub App, GitHub OAuth) of a pipeline using the badges in the Config Source column on the Project Settings  Pipelines page.   Each pipeline has a Definition ID, which is a UUID for the pipeline, which can be used to refer to a specific pipeline when triggering it  via the API.        Add or edit a pipeline     If you created a project  in the CircleCI web app you will find a pipeline is already set up.           GitHub and Bitbucket OAuth pipelines are created automatically when setting up a project and they cannot be edited.        The steps and options described in this section are for setting up a GitHub App pipeline. If you are setting up a pipeline for a different version control system the options you see may vary but the process is mostly the same.        To add or edit a pipeline, follow these steps:     In the CircleCI web app, select Projects in the sidebar.   Select the ellipsis next to your project () and choose Project Settings.   Select Pipelines in the sidebar.   Select Add Pipeline, or, if you wish to edit an existing pipeline select the pencil icon on the right.   Complete the form fields and options:    Give your pipeline a descriptive name, for example Run tests and deploy.   Under Integration select the platform that matches where your project is set up (for example, GitHub App).     If you integrate with  CircleCI’s GitHub OAuth App you can select GitHub App here to install the App into your org and access  improved security and new features. This is a one-time step, which can be done by an organization admin or a user who has admin access to at least one repository in the organization. Once installed, further GitHub App pipelines can be setup without this installation step.           For GitLab self-managed, you can input any instance that you have previously set up in CircleCI. If you wish to set a different feature branch or repository from a self-managed instance as a new pipeline, you will first need to add a new connection via your  Organization Settings  Integrations. In either case, you will also need to enter your personal access token again to authorize this connection.         Authorize your connection if this is not already showing with a check mark ().   Define where the config file for this pipeline is stored:    Select a repository from the dropdown.   Enter the path to the config file.      Under Build Assets, select a Checkout Source for this pipeline. This is the repository that will be checked out when a  checkout step is run. If your config is stored in the same repository as your code, pick the same repository you selected for the Config Source.      Select Save.     Once you have set up a pipeline you need to set up a trigger to connect it to. Setting up a trigger is described in the following section.     Triggers     If you created a project  in the CircleCI web app you will find a trigger is already set up.           GitHub and Bitbucket OAuth triggers are created automatically when setting up a project and they cannot be edited. The only trigger you can create and edit for an OAuth pipeline is a  scheduled pipeline trigger.        Triggers are configurable rules that determine when to automatically run a pipeline based on specific events and conditions. A project can have one or more triggers, which are associated with events from a source of change. The most common type of trigger is a VCS event, for example a push to a branch on a GitHub repository, but any system that can emit outbound webhooks can also be set up as a trigger. A trigger can have only one pipeline but a pipeline can have multiple triggers.   A trigger kicks off a pipeline to run the workflows defined in your connected config source.   Add a trigger  To add a trigger for a pipeline, follow these steps:  GitHub AppCustom webhookGitLabBitbucket Data CenterScheduled   When the CircleCI GitHub App is installed for your organization, GitHub starts to send events for the repositories you have granted access to. CircleCI listens for push and tag events. When a trigger is created CircleCI has enough information to use the event data to determine if a pipeline should be triggered.        To add a trigger for a pipeline, follow these steps:     In the  CircleCI web app select Projects in the sidebar   Find your project in the list, select the ellipsis () next to it and choose Project Settings.   Select Triggers in the sidebar.   Select Add Trigger.   Select GitHub App in the "Trigger type" menu and select Next.   Complete the form fields and options:    Authorize your connection if this is not already showing with a .   Give your trigger a descriptive name.   Select the trigger source repository.   Choose your pipeline from the "Choose pipeline to run" menu.   Select a "Run on" option. This setting determines the type of event that will trigger the pipeline. For full details of the available option, see the  GitHub trigger event options page.   If prompted, enter a Config branch. This is the name of the branch that should be used to fetch your config file when a pipeline is triggered. This field is only required if your config is stored in a repository that is not the source of your trigger.   If prompted, enter a Checkout branch. This is the name of the branch that should be used to check out your code when a  checkout step is run. This field is only required if your chosen pipeline’s Checkout source repository is not the source of your trigger.      Select Save.     To verify your trigger is set up correctly, trigger an event from your repository.         Custom webhooks are available for projects integrated via the GitHub App. Custom webhooks are not available on CircleCI server.        Setting up a custom webhook trigger allows you to trigger pipelines from external services. Any service that can emit a webhook or make a cURL request can be set up in this way to trigger a pipeline. For more information, see the  Triggers overview page.      Custom webhook triggers can only be associated with GitHub App pipelines. You can check if you have a GitHub App pipeline by going to Project Settings  Pipelines and checking if any of your pipelines have a GitHub App badge in the Config Source column. If needed, create a new pipeline by selecting Add pipeline.        To add a trigger for a custom webhook, follow these steps:     In the  CircleCI web app select Projects in the sidebar.   Find your project in the list, select the ellipsis (), select Project Settings, and select Pipelines in the sidebar.   If there is already a GitHub App pipeline set up and it uses the desired YAML configuration file, proceed to the Triggers step below (step 5). If not, select Set up pipeline. If there is a Connect button, select it and follow the steps to install the CircleCI GitHub App into your GitHub organization (this step is compatible with orgs that integrate with  CircleCI’s GitHub OAuth app).   Name the new pipeline and select the repository where the CircleCI YAML configuration file is stored. Enter the file path (including the .circleci directory). The file path can be different than .circleci/config.yml (for example, .circleci/webhook.yml). Save the pipeline.   Select Triggers in the sidebar.   Select Add Trigger.   Select Custom Webhook from the dropdown menu.   Select Next.        Complete the form fields and options:    Enter a descriptive name for the trigger. For example, if you are setting up a custom webhook to run pipelines on events from Datadog, enter "Datadog" here.   (Optional) Add a description.   In the field "Pipeline to run", at the bottom of the page, select the pipeline that you created in the step above.   Enter the branch to use to fetch your config file when a Custom Webhook is received.   Enter the branch to use to check out your code when using the  checkout step in config. If your config is stored in the same repository as your code, then your Config branch and your Checkout branch should be the same.      Select Save.   You will see a webhook endpoint URL and secret. You can use these to set up your webhook trigger from your external source. Copy the Webhook URL and use it in your trigger source appended with the secret.     The secret will not be shown again so be sure to copy the URL before clicking Done.                To verify your trigger is set up correctly, trigger an event from your third party system.      When a trigger is created, CircleCI registers a webhook with GitLab. Push events from GitLab are sent to CircleCI. CircleCI then uses the event data to determine if a pipeline should run, and if so, which pipeline should be run.   In addition to a pipeline, each trigger includes the webhook URL, and in this scenario, a CircleCI-created GitLab token. The webhook URL and GitLab token are used to securely register the webhook within GitLab in order to receive push events from your GitLab repository. You can view webhooks for a project in GitLab at Settings  Webhooks.        To add a trigger for a pipeline, follow these steps:     In the  CircleCI web app select Projects in the sidebar   Find your project in the list, select the ellipsis () next to it and choose Project Settings.   Select Triggers in the sidebar.     If you do not see Triggers in the sidebar, your project is integrated using either  GitHub OAuth or  Bitbucket Cloud and these steps do not apply.         Select Add Trigger.   Select the same location in the "Connect to" dropdown menu that you selected for your pipeline (for example, GitLab).   Select Next.   Complete the form fields and options:    Give your trigger a descriptive name.   Authorize your connection if this is not already showing with a  (Not required for custom webhooks).     For GitLab self-managed you can enter the URL for an instance you have previously set up with CircleCI. You will need to enter the relevant personal access token again here to authorize the connection.         Select your repository from the dropdown menu. This should match the repository your pipeline is connected to (not required for custom webhooks).   Choose your pipeline from the "Choose config to run" menu.   (Optional) You can configure trigger filters to configure the event types that will trigger the pipeline. For more information, see the  GitLab trigger options page.      Select Save     When setting up a trigger you will see a modal titled Webhook URL requesting that you set up a webhook in GitLab. You do not need to take action. The webhook is set up automatically by CircleCI. This is a known issue and will be fixed.           To verify your trigger is set up correctly, trigger an event from your repository.      For steps to add a trigger for a pipeline using Bitbucket Data Center, see the  Bitbucket Data Center page.          This feature is supported for orgs that use OAuth authentication.   Check your Organization slug at Organization settings  Overview. OAuth authenticated orgs are structured as follows:     github/<your-org-name> or gh/<your-org-name>   bitbucket/<your-org-name> or bb/<your-org-name>     This feature is not supported if your organization slug is in the following format:     circleci/<UID>.     For an overview of feature support, see the  VCS integration overview page.           In the  CircleCI web app, select your org from the org cards on your user homepage.   Select Projects from the sidebar and locate your project from the list. You can use the search to help.   Select the ellipsis () next to your project and select Project Settings.   Select Triggers in the sidebar.   Select Add Trigger.     The "Pipeline to run" menu only shows the OAuth pipelines, you cannot schedule GitHub App, GitLab or Bitbucket Data Center pipelines.          Give your trigger a descriptive name.   Enter an optional trigger description.   Select the pipeline to run.   Select a release frequencies (weekly/monthly, which days/months/time etc.).   Enter a branch or tag name to determine when to trigger the pipeline.   Optionally, enter pipeline parameters. If you declare pipeline parameters in the form, you need to make sure they are configured in your project’s .circleci/config.yml. See the  Pipeline values and parameters page for more information.   Select an actor to initiate the trigger.      Define the new schedule by filling out the form, then select Save Trigger.     The form also provides the option of adding  pipeline parameters, which are typed pipeline variables that you declare at the top level of a configuration.   If you would like to manage common schedules for multiple workflows, you will need to manually set this in your .circleci/config.yml file. See the  Schedule pipelines with multiple workflows page for examples.             Pipeline parameters   Pipeline parameters are declared using the parameters key at the top level of a .circleci/config.yml file. Pipeline parameters can be referenced by value and used as a configuration variable under the scope pipeline.parameters.   The example below shows a configuration with two pipeline parameters (image-tag and workingdir) defined at the top of the configuration, and then subsequently referenced in the build job:    version: 2.1

parameters:
  image-tag:
    type: string
    default: "current"
  workingdir:
    type: string
    default: "~/main"

jobs:
  build:
    docker:
      - image: cimg/node:<< pipeline.parameters.image-tag >>
    environment:
      IMAGETAG: << pipeline.parameters.image-tag >>
    working_directory: << pipeline.parameters.workingdir >>
    steps:
      - run: echo "Image tag used was ${IMAGETAG}"
      - run: echo "$(pwd) == << pipeline.parameters.workingdir >>"    A pipeline can be triggered with specific parameter values using the API v2 or via the CircleCI web app.   See the  Pipeline values and parameters page for more information.     VS Code extension   If you use Visual Studio Code, you can also monitor and interact with your pipelines directly from VS Code with the  official CircleCI extension. The extension allows you to customize which projects and pipelines you want to follow, as well as view job logs and test results, download artifacts, approve, re-run, and debug jobs with SSH, and get notified when your workflows fail or need approval.        The CircleCI VS Code extension is available to download on the  VS Code marketplace.     Troubleshooting   Config could not be located error  If you see the following error message, check the steps below to remediate the issue.    config file .circleci/sample-filename.yml could not be located on branch sample-branch-name in repository sample-repo-name      Ensure that there is a CircleCI configuration file in the repository on the branch that uses the filename specified in the error message. If there is not one present, add a CircleCI configuration file.   If there is a config file present:    Navigate to Project Settings  Pipelines in the CircleCI web app for the project where you are seeing this error message.   Select the pencil icon for each pipeline listed and ensure that the "Config File Path" field matches the filepath of the config file that is in your repository. If you changed the name of the config file in your repository, the reference to that filepath must also be changed in the Project Settings  Pipelines section for any pipeline that uses that configuration file.         Why is my scheduled pipeline not running?  If your scheduled pipeline is not running, verify the following things:     Is the actor who is set for the scheduled pipelines still part of the organization? You can find this setting is under Attribution in the Triggers section of the web app.   Is the branch set for the schedule deleted?   Is your VCS organization using SAML protection? SAML tokens expire often, which can cause requests to fail.      Why are my jobs not running when I push commits?  In the CircleCI application, check the individual job and workflow views for error messages. More often than not, the error is because of formatting errors in your .circleci/config.yml file.   See the  YAML Introduction page for more details.   After checking your .circleci/config.yml for formatting errors, search for your issue in the  CircleCI support center.    Why is my job queued?  A job might end up being queued because of a concurrency limit being imposed due your organization’s plan. If your jobs are queuing often, you can consider  upgrading your plan.    Why are my jobs queuing even though I am on the Performance Plan?  In order to keep the system stable for all CircleCI customers, we implement different soft concurrency limits on each of the  Resource classes. If you are experiencing queuing on your jobs, it is possible you are hitting these limits.  Contact CircleCI support to request raises on these limits.    Why can I not find my project on the Projects dashboard?  If you are not seeing a project you would like to build, and it is not currently building on CircleCI, check your org in the top left corner of the CircleCI application. For instance, if the top left shows your user my-user, only projects belonging to my-user will be available under Projects. If you want to build the project your-org/project, you must switch your organization on the application’s organization switcher menu to your-org.    How do Docker image names work? Where do they come from?  CircleCI currently supports pulling (and pushing with Docker Engine) Docker images from  Docker Hub. For  official images, you can pull by simply specifying the name of the image and a tag:    golang:1.7.1-jessie
redis:3.0.7-jessie    For public images on Docker Hub, you can pull the image by prefixing the account or team username:    my-user/couchdb:1.6.1     What is the best practice for specifying image versions?  It is best practice not to use the latest tag for specifying image versions. It is also best practice to use a specific version and tag, for example cimg/ruby:3.0.4-browsers, to pin down the image and prevent upstream changes to your containers when the underlying base distribution changes. For example, specifying only cimg/ruby:3.0.4 could result in unexpected changes from browsers to node. For more context, refer to  Docker image best practices, and  CircleCI image best practices.    How can I set the timezone in Docker images?  You can set the timezone in Docker images with the TZ environment variable. A sample .circleci/config.yml with a defined TZ variable would look like the following:    version: 2.1
jobs:
  build:
    docker:
      - image: your/primary-image:version-tag
        auth:
          username: mydockerhub-user
          password: $DOCKERHUB_PASSWORD  # context / project UI env-var reference
      - image: mysql:5.7
        auth:
          username: mydockerhub-user
          password: $DOCKERHUB_PASSWORD  # context / project UI env-var reference
        environment:
           TZ: "America/Los_Angeles"
    working_directory: ~/your-dir
    environment:
      TZ: "America/Los_Angeles"    In this example, the timezone is set for both the primary image and an additional mySQL image.   A full list of available timezone options is  available on Wikipedia.      FAQs   Is it possible to split the .circleci/config.yml into different files?  If your code is stored in GitHub you can split your configuration into multiple files using the CircleCI GitHub App integration. For steps, see the  Set up multiple configuration files how-to guide.       To find out which GitHub integration type you have, check your Organization slug at Organization settings  Overview. OAuth authenticated orgs are structured as follows:     github/<your-org-name> or gh/<your-org-name>   bitbucket/<your-org-name> or bb/<your-org-name>     An organization slug for a GitHub App integration is in the following format:     circleci/<UID>           If your organization is currently integrated with GitHub only through OAuth, an admin can take the one-time action of installing the CircleCI GitHub App to enable this functionality. For more information, see the  GitHub integration page.   While splitting configuration files is only available for GitHub App integrations, CircleCI does support dynamic configuration, which allows you to create configuration files based on specific pipeline values or paths, and continue one pipeline to another. See the  Dynamic configuration page for more information.    Can I trigger forked PRs using pipelines?     The "build forked PRs" settings is not currently supported for GitLab or GitHub App projects. To find out if you authorized through the GitHub OAuth app or the CircleCI GitHub App, see the  GitHub App integration page.        You can trigger pipelines to build PRs from forked repositories with CircleCI  API v2. However, by default, CircleCI will not build a PR from a forked repository. If you would like to turn this feature on, navigate to Project Settings  Advanced in the web app. If you would like more information, you can view this  support article.      Next steps   Find out more about triggering pipelines in the  Triggers Overview.   Suggest an edit to this pageMake a contribution Learn how to contributeStill need help? Ask the CircleCI community Join the research community Visit our Support site\n\nPipelines and triggers overview1 week ago14 min readCloudServer v4+On This PagePipelines dashboardPipelines and triggersPipelinesAdd or edit a pipelineTriggersAdd a triggerPipeline parametersVS Code extensionTroubleshootingConfig could not be located errorWhy is my scheduled pipeline not running?Why are my jobs not running when I push commits?Why is my job queued?Why are my jobs queuing even though I am on the Performance Plan?Why can I not find my project on the Projects dashboard?How do Docker image names work? Where do they come from?What is the best practice for specifying image versions?How can I set the timezone in Docker images?FAQsIs it possible to split the .circleci/config.yml into different files?Can I trigger forked PRs using pipelines?Next steps   CircleCI pipelines are the highest-level unit of work in your CI/CD process. Defined by a configuration file (typically .circleci/config.yml), pipelines orchestrate the execution of workflows which run jobs to build, test, and deploy your code.   Pipelines can be triggered in the following ways:     Automatically: Git events, scheduled events, custom webhooks   Manually: CircleCI app or API     Pipelines provide a flexible framework for creating conditional workflows based on  filters,  job requirements, and  pipeline parameters, allowing you to customize your CI/CD process to fit your project’s needs.     Pipelines dashboard   Your pipelines dashboard displays recently-triggered pipelines for your organization. Use the various filters to find the pipelines you need. Select workflow and job names to  view workflow maps and individual job steps. Use the quick controls on the right of the screen to rerun and cancel workflows.        From the pipelines dashboard you can find the pipeline ID. The pipeline ID is a unique ID for a pipeline that has been triggered. You can use the pipeline ID to access pipeline information via the  API.          Pipelines and triggers      The pipeline and trigger features available to you depend on how your code is integrated and where it is stored. For a feature availability overview, see the  VCS integration overview page.           Using CircleCI server? The Pipeline and Trigger pages under Project Settings and pipeline and trigger add/edit functionality is not available.        Set up pipelines to define the various CI/CD "units" that make up your project.   Set up triggers to define when and how each of your pipelines should be run. Triggers may be from external services (custom webhooks), from commits or tags on a version control system, or set up to run on a schedule.   Pipelines  A pipeline defines a unit of work that can be run within your projects. Each pipeline is defined by two key characteristics:     A config source, which is a configuration file stored in a repository. The default config source location is .circleci/config.yml within the same repository as your code.     For GitHub App and Bitbucket Data Center pipelines you can choose any file path (with extension *.yml) in any repository.         A checkout source, which determines which repository will be checked out when running a  checkout step.     This model allows your CircleCI config to be stored in a different repository from your code. This is currently supported for GitHub App and Bitbucket Data Center pipelines.           A project can have one or more pipelines, and each pipeline can be associated with zero or more triggers.   When you create a project in CircleCI and follow the in-app project creation flow to connect it to a repository, a first pipeline is set up for you automatically. The config file used for your first pipeline is either a file you commit yourself or one generated by CircleCI based on the code in your project. You can identify the type (GitHub App, GitHub OAuth) of a pipeline using the badges in the Config Source column on the Project Settings  Pipelines page.   Each pipeline has a Definition ID, which is a UUID for the pipeline, which can be used to refer to a specific pipeline when triggering it  via the API.        Add or edit a pipeline     If you created a project  in the CircleCI web app you will find a pipeline is already set up.           GitHub and Bitbucket OAuth pipelines are created automatically when setting up a project and they cannot be edited.        The steps and options described in this section are for setting up a GitHub App pipeline. If you are setting up a pipeline for a different version control system the options you see may vary but the process is mostly the same.        To add or edit a pipeline, follow these steps:     In the CircleCI web app, select Projects in the sidebar.   Select the ellipsis next to your project () and choose Project Settings.   Select Pipelines in the sidebar.   Select Add Pipeline, or, if you wish to edit an existing pipeline select the pencil icon on the right.   Complete the form fields and options:    Give your pipeline a descriptive name, for example Run tests and deploy.   Under Integration select the platform that matches where your project is set up (for example, GitHub App).     If you integrate with  CircleCI’s GitHub OAuth App you can select GitHub App here to install the App into your org and access  improved security and new features. This is a one-time step, which can be done by an organization admin or a user who has admin access to at least one repository in the organization. Once installed, further GitHub App pipelines can be setup without this installation step.           For GitLab self-managed, you can input any instance that you have previously set up in CircleCI. If you wish to set a different feature branch or repository from a self-managed instance as a new pipeline, you will first need to add a new connection via your  Organization Settings  Integrations. In either case, you will also need to enter your personal access token again to authorize this connection.         Authorize your connection if this is not already showing with a check mark ().   Define where the config file for this pipeline is stored:    Select a repository from the dropdown.   Enter the path to the config file.      Under Build Assets, select a Checkout Source for this pipeline. This is the repository that will be checked out when a  checkout step is run. If your config is stored in the same repository as your code, pick the same repository you selected for the Config Source.      Select Save.     Once you have set up a pipeline you need to set up a trigger to connect it to. Setting up a trigger is described in the following section.     Triggers     If you created a project  in the CircleCI web app you will find a trigger is already set up.           GitHub and Bitbucket OAuth triggers are created automatically when setting up a project and they cannot be edited. The only trigger you can create and edit for an OAuth pipeline is a  scheduled pipeline trigger.        Triggers are configurable rules that determine when to automatically run a pipeline based on specific events and conditions. A project can have one or more triggers, which are associated with events from a source of change. The most common type of trigger is a VCS event, for example a push to a branch on a GitHub repository, but any system that can emit outbound webhooks can also be set up as a trigger. A trigger can have only one pipeline but a pipeline can have multiple triggers.   A trigger kicks off a pipeline to run the workflows defined in your connected config source.   Add a trigger  To add a trigger for a pipeline, follow these steps:  GitHub AppCustom webhookGitLabBitbucket Data CenterScheduled   When the CircleCI GitHub App is installed for your organization, GitHub starts to send events for the repositories you have granted access to. CircleCI listens for push and tag events. When a trigger is created CircleCI has enough information to use the event data to determine if a pipeline should be triggered.        To add a trigger for a pipeline, follow these steps:     In the  CircleCI web app select Projects in the sidebar   Find your project in the list, select the ellipsis () next to it and choose Project Settings.   Select Triggers in the sidebar.   Select Add Trigger.   Select GitHub App in the "Trigger type" menu and select Next.   Complete the form fields and options:    Authorize your connection if this is not already showing with a .   Give your trigger a descriptive name.   Select the trigger source repository.   Choose your pipeline from the "Choose pipeline to run" menu.   Select a "Run on" option. This setting determines the type of event that will trigger the pipeline. For full details of the available option, see the  GitHub trigger event options page.   If prompted, enter a Config branch. This is the name of the branch that should be used to fetch your config file when a pipeline is triggered. This field is only required if your config is stored in a repository that is not the source of your trigger.   If prompted, enter a Checkout branch. This is the name of the branch that should be used to check out your code when a  checkout step is run. This field is only required if your chosen pipeline’s Checkout source repository is not the source of your trigger.      Select Save.     To verify your trigger is set up correctly, trigger an event from your repository.         Custom webhooks are available for projects integrated via the GitHub App. Custom webhooks are not available on CircleCI server.        Setting up a custom webhook trigger allows you to trigger pipelines from external services. Any service that can emit a webhook or make a cURL request can be set up in this way to trigger a pipeline. For more information, see the  Triggers overview page.      Custom webhook triggers can only be associated with GitHub App pipelines. You can check if you have a GitHub App pipeline by going to Project Settings  Pipelines and checking if any of your pipelines have a GitHub App badge in the Config Source column. If needed, create a new pipeline by selecting Add pipeline.        To add a trigger for a custom webhook, follow these steps:     In the  CircleCI web app select Projects in the sidebar.   Find your project in the list, select the ellipsis (), select Project Settings, and select Pipelines in the sidebar.   If there is already a GitHub App pipeline set up and it uses the desired YAML configuration file, proceed to the Triggers step below (step 5). If not, select Set up pipeline. If there is a Connect button, select it and follow the steps to install the CircleCI GitHub App into your GitHub organization (this step is compatible with orgs that integrate with  CircleCI’s GitHub OAuth app).   Name the new pipeline and select the repository where the CircleCI YAML configuration file is stored. Enter the file path (including the .circleci directory). The file path can be different than .circleci/config.yml (for example, .circleci/webhook.yml). Save the pipeline.   Select Triggers in the sidebar.   Select Add Trigger.   Select Custom Webhook from the dropdown menu.   Select Next.        Complete the form fields and options:    Enter a descriptive name for the trigger. For example, if you are setting up a custom webhook to run pipelines on events from Datadog, enter "Datadog" here.   (Optional) Add a description.   In the field "Pipeline to run", at the bottom of the page, select the pipeline that you created in the step above.   Enter the branch to use to fetch your config file when a Custom Webhook is received.   Enter the branch to use to check out your code when using the  checkout step in config. If your config is stored in the same repository as your code, then your Config branch and your Checkout branch should be the same.      Select Save.   You will see a webhook endpoint URL and secret. You can use these to set up your webhook trigger from your external source. Copy the Webhook URL and use it in your trigger source appended with the secret.     The secret will not be shown again so be sure to copy the URL before clicking Done.                To verify your trigger is set up correctly, trigger an event from your third party system.      When a trigger is created, CircleCI registers a webhook with GitLab. Push events from GitLab are sent to CircleCI. CircleCI then uses the event data to determine if a pipeline should run, and if so, which pipeline should be run.   In addition to a pipeline, each trigger includes the webhook URL, and in this scenario, a CircleCI-created GitLab token. The webhook URL and GitLab token are used to securely register the webhook within GitLab in order to receive push events from your GitLab repository. You can view webhooks for a project in GitLab at Settings  Webhooks.        To add a trigger for a pipeline, follow these steps:     In the  CircleCI web app select Projects in the sidebar   Find your project in the list, select the ellipsis () next to it and choose Project Settings.   Select Triggers in the sidebar.     If you do not see Triggers in the sidebar, your project is integrated using either  GitHub OAuth or  Bitbucket Cloud and these steps do not apply.         Select Add Trigger.   Select the same location in the "Connect to" dropdown menu that you selected for your pipeline (for example, GitLab).   Select Next.   Complete the form fields and options:    Give your trigger a descriptive name.   Authorize your connection if this is not already showing with a  (Not required for custom webhooks).     For GitLab self-managed you can enter the URL for an instance you have previously set up with CircleCI. You will need to enter the relevant personal access token again here to authorize the connection.         Select your repository from the dropdown menu. This should match the repository your pipeline is connected to (not required for custom webhooks).   Choose your pipeline from the "Choose config to run" menu.   (Optional) You can configure trigger filters to configure the event types that will trigger the pipeline. For more information, see the  GitLab trigger options page.      Select Save     When setting up a trigger you will see a modal titled Webhook URL requesting that you set up a webhook in GitLab. You do not need to take action. The webhook is set up automatically by CircleCI. This is a known issue and will be fixed.           To verify your trigger is set up correctly, trigger an event from your repository.      For steps to add a trigger for a pipeline using Bitbucket Data Center, see the  Bitbucket Data Center page.          This feature is supported for orgs that use OAuth authentication.   Check your Organization slug at Organization settings  Overview. OAuth authenticated orgs are structured as follows:     github/<your-org-name> or gh/<your-org-name>   bitbucket/<your-org-name> or bb/<your-org-name>     This feature is not supported if your organization slug is in the following format:     circleci/<UID>.     For an overview of feature support, see the  VCS integration overview page.           In the  CircleCI web app, select your org from the org cards on your user homepage.   Select Projects from the sidebar and locate your project from the list. You can use the search to help.   Select the ellipsis () next to your project and select Project Settings.   Select Triggers in the sidebar.   Select Add Trigger.     The "Pipeline to run" menu only shows the OAuth pipelines, you cannot schedule GitHub App, GitLab or Bitbucket Data Center pipelines.          Give your trigger a descriptive name.   Enter an optional trigger description.   Select the pipeline to run.   Select a release frequencies (weekly/monthly, which days/months/time etc.).   Enter a branch or tag name to determine when to trigger the pipeline.   Optionally, enter pipeline parameters. If you declare pipeline parameters in the form, you need to make sure they are configured in your project’s .circleci/config.yml. See the  Pipeline values and parameters page for more information.   Select an actor to initiate the trigger.      Define the new schedule by filling out the form, then select Save Trigger.     The form also provides the option of adding  pipeline parameters, which are typed pipeline variables that you declare at the top level of a configuration.   If you would like to manage common schedules for multiple workflows, you will need to manually set this in your .circleci/config.yml file. See the  Schedule pipelines with multiple workflows page for examples.             Pipeline parameters   Pipeline parameters are declared using the parameters key at the top level of a .circleci/config.yml file. Pipeline parameters can be referenced by value and used as a configuration variable under the scope pipeline.parameters.   The example below shows a configuration with two pipeline parameters (image-tag and workingdir) defined at the top of the configuration, and then subsequently referenced in the build job:    version: 2.1

parameters:
  image-tag:
    type: string
    default: "current"
  workingdir:
    type: string
    default: "~/main"

jobs:
  build:
    docker:
      - image: cimg/node:<< pipeline.parameters.image-tag >>
    environment:
      IMAGETAG: << pipeline.parameters.image-tag >>
    working_directory: << pipeline.parameters.workingdir >>
    steps:
      - run: echo "Image tag used was ${IMAGETAG}"
      - run: echo "$(pwd) == << pipeline.parameters.workingdir >>"    A pipeline can be triggered with specific parameter values using the API v2 or via the CircleCI web app.   See the  Pipeline values and parameters page for more information.     VS Code extension   If you use Visual Studio Code, you can also monitor and interact with your pipelines directly from VS Code with the  official CircleCI extension. The extension allows you to customize which projects and pipelines you want to follow, as well as view job logs and test results, download artifacts, approve, re-run, and debug jobs with SSH, and get notified when your workflows fail or need approval.        The CircleCI VS Code extension is available to download on the  VS Code marketplace.     Troubleshooting   Config could not be located error  If you see the following error message, check the steps below to remediate the issue.    config file .circleci/sample-filename.yml could not be located on branch sample-branch-name in repository sample-repo-name      Ensure that there is a CircleCI configuration file in the repository on the branch that uses the filename specified in the error message. If there is not one present, add a CircleCI configuration file.   If there is a config file present:    Navigate to Project Settings  Pipelines in the CircleCI web app for the project where you are seeing this error message.   Select the pencil icon for each pipeline listed and ensure that the "Config File Path" field matches the filepath of the config file that is in your repository. If you changed the name of the config file in your repository, the reference to that filepath must also be changed in the Project Settings  Pipelines section for any pipeline that uses that configuration file.         Why is my scheduled pipeline not running?  If your scheduled pipeline is not running, verify the following things:     Is the actor who is set for the scheduled pipelines still part of the organization? You can find this setting is under Attribution in the Triggers section of the web app.   Is the branch set for the schedule deleted?   Is your VCS organization using SAML protection? SAML tokens expire often, which can cause requests to fail.      Why are my jobs not running when I push commits?  In the CircleCI application, check the individual job and workflow views for error messages. More often than not, the error is because of formatting errors in your .circleci/config.yml file.   See the  YAML Introduction page for more details.   After checking your .circleci/config.yml for formatting errors, search for your issue in the  CircleCI support center.    Why is my job queued?  A job might end up being queued because of a concurrency limit being imposed due your organization’s plan. If your jobs are queuing often, you can consider  upgrading your plan.    Why are my jobs queuing even though I am on the Performance Plan?  In order to keep the system stable for all CircleCI customers, we implement different soft concurrency limits on each of the  Resource classes. If you are experiencing queuing on your jobs, it is possible you are hitting these limits.  Contact CircleCI support to request raises on these limits.    Why can I not find my project on the Projects dashboard?  If you are not seeing a project you would like to build, and it is not currently building on CircleCI, check your org in the top left corner of the CircleCI application. For instance, if the top left shows your user my-user, only projects belonging to my-user will be available under Projects. If you want to build the project your-org/project, you must switch your organization on the application’s organization switcher menu to your-org.    How do Docker image names work? Where do they come from?  CircleCI currently supports pulling (and pushing with Docker Engine) Docker images from  Docker Hub. For  official images, you can pull by simply specifying the name of the image and a tag:    golang:1.7.1-jessie
redis:3.0.7-jessie    For public images on Docker Hub, you can pull the image by prefixing the account or team username:    my-user/couchdb:1.6.1     What is the best practice for specifying image versions?  It is best practice not to use the latest tag for specifying image versions. It is also best practice to use a specific version and tag, for example cimg/ruby:3.0.4-browsers, to pin down the image and prevent upstream changes to your containers when the underlying base distribution changes. For example, specifying only cimg/ruby:3.0.4 could result in unexpected changes from browsers to node. For more context, refer to  Docker image best practices, and  CircleCI image best practices.    How can I set the timezone in Docker images?  You can set the timezone in Docker images with the TZ environment variable. A sample .circleci/config.yml with a defined TZ variable would look like the following:    version: 2.1
jobs:
  build:
    docker:
      - image: your/primary-image:version-tag
        auth:
          username: mydockerhub-user
          password: $DOCKERHUB_PASSWORD  # context / project UI env-var reference
      - image: mysql:5.7
        auth:
          username: mydockerhub-user
          password: $DOCKERHUB_PASSWORD  # context / project UI env-var reference
        environment:
           TZ: "America/Los_Angeles"
    working_directory: ~/your-dir
    environment:
      TZ: "America/Los_Angeles"    In this example, the timezone is set for both the primary image and an additional mySQL image.   A full list of available timezone options is  available on Wikipedia.      FAQs   Is it possible to split the .circleci/config.yml into different files?  If your code is stored in GitHub you can split your configuration into multiple files using the CircleCI GitHub App integration. For steps, see the  Set up multiple configuration files how-to guide.       To find out which GitHub integration type you have, check your Organization slug at Organization settings  Overview. OAuth authenticated orgs are structured as follows:     github/<your-org-name> or gh/<your-org-name>   bitbucket/<your-org-name> or bb/<your-org-name>     An organization slug for a GitHub App integration is in the following format:     circleci/<UID>           If your organization is currently integrated with GitHub only through OAuth, an admin can take the one-time action of installing the CircleCI GitHub App to enable this functionality. For more information, see the  GitHub integration page.   While splitting configuration files is only available for GitHub App integrations, CircleCI does support dynamic configuration, which allows you to create configuration files based on specific pipeline values or paths, and continue one pipeline to another. See the  Dynamic configuration page for more information.    Can I trigger forked PRs using pipelines?     The "build forked PRs" settings is not currently supported for GitLab or GitHub App projects. To find out if you authorized through the GitHub OAuth app or the CircleCI GitHub App, see the  GitHub App integration page.        You can trigger pipelines to build PRs from forked repositories with CircleCI  API v2. However, by default, CircleCI will not build a PR from a forked repository. If you would like to turn this feature on, navigate to Project Settings  Advanced in the web app. If you would like more information, you can view this  support article.      Next steps   Find out more about triggering pipelines in the  Triggers Overview.   Suggest an edit to this pageMake a contribution Learn how to contributeStill need help? Ask the CircleCI community Join the research community Visit our Support site DocsTerms of UsePrivacy PolicyCookie PolicySecurity© 2025 Circle Internet Services, Inc., All Rights Reserved.\n\nThe pipeline and trigger features available to you depend on how your code is integrated and where it is stored. For a feature availability overview, see the  VCS integration overview page.  Using CircleCI server? The Pipeline and Trigger pages under Project Settings and pipeline and trigger add/edit functionality is not available.  For GitHub App and Bitbucket Data Center pipelines you can choose any file path (with extension *.yml) in any repository.  This model allows your CircleCI config to be stored in a different repository from your code. This is currently supported for GitHub App and Bitbucket Data Center pipelines.    If you created a project  in the CircleCI web app you will find a pipeline is already set up.  GitHub and Bitbucket OAuth pipelines are created automatically when setting up a project and they cannot be edited.    If you integrate with  CircleCI’s GitHub OAuth App you can select GitHub App here to install the App into your org and access  improved security and new features. This is a one-time step, which can be done by an organization admin or a user who has admin access to at least one repository in the organization. Once installed, further GitHub App pipelines can be setup without this installation step.  For GitLab self-managed, you can input any instance that you have previously set up in CircleCI. If you wish to set a different feature branch or repository from a self-managed instance as a new pipeline, you will first need to add a new connection via your  Organization Settings  Integrations. In either case, you will also need to enter your personal access token again to authorize this connection.  If you created a project  in the CircleCI web app you will find a trigger is already set up.  GitHub and Bitbucket OAuth triggers are created automatically when setting up a project and they cannot be edited. The only trigger you can create and edit for an OAuth pipeline is a  scheduled pipeline trigger.   When the CircleCI GitHub App is installed for your organization, GitHub starts to send events for the repositories you have granted access to. CircleCI listens for push and tag events. When a trigger is created CircleCI has enough information to use the event data to determine if a pipeline should be triggered.        To add a trigger for a pipeline, follow these steps:     In the  CircleCI web app select Projects in the sidebar   Find your project in the list, select the ellipsis () next to it and choose Project Settings.   Select Triggers in the sidebar.   Select Add Trigger.   Select GitHub App in the "Trigger type" menu and select Next.   Complete the form fields and options:    Authorize your connection if this is not already showing with a .   Give your trigger a descriptive name.   Select the trigger source repository.   Choose your pipeline from the "Choose pipeline to run" menu.   Select a "Run on" option. This setting determines the type of event that will trigger the pipeline. For full details of the available option, see the  GitHub trigger event options page.   If prompted, enter a Config branch. This is the name of the branch that should be used to fetch your config file when a pipeline is triggered. This field is only required if your config is stored in a repository that is not the source of your trigger.   If prompted, enter a Checkout branch. This is the name of the branch that should be used to check out your code when a  checkout step is run. This field is only required if your chosen pipeline’s Checkout source repository is not the source of your trigger.      Select Save.     To verify your trigger is set up correctly, trigger an event from your repository.         Custom webhooks are available for projects integrated via the GitHub App. Custom webhooks are not available on CircleCI server.        Setting up a custom webhook trigger allows you to trigger pipelines from external services. Any service that can emit a webhook or make a cURL request can be set up in this way to trigger a pipeline. For more information, see the  Triggers overview page.      Custom webhook triggers can only be associated with GitHub App pipelines. You can check if you have a GitHub App pipeline by going to Project Settings  Pipelines and checking if any of your pipelines have a GitHub App badge in the Config Source column. If needed, create a new pipeline by selecting Add pipeline.        To add a trigger for a custom webhook, follow these steps:     In the  CircleCI web app select Projects in the sidebar.   Find your project in the list, select the ellipsis (), select Project Settings, and select Pipelines in the sidebar.   If there is already a GitHub App pipeline set up and it uses the desired YAML configuration file, proceed to the Triggers step below (step 5). If not, select Set up pipeline. If there is a Connect button, select it and follow the steps to install the CircleCI GitHub App into your GitHub organization (this step is compatible with orgs that integrate with  CircleCI’s GitHub OAuth app).   Name the new pipeline and select the repository where the CircleCI YAML configuration file is stored. Enter the file path (including the .circleci directory). The file path can be different than .circleci/config.yml (for example, .circleci/webhook.yml). Save the pipeline.   Select Triggers in the sidebar.   Select Add Trigger.   Select Custom Webhook from the dropdown menu.   Select Next.        Complete the form fields and options:    Enter a descriptive name for the trigger. For example, if you are setting up a custom webhook to run pipelines on events from Datadog, enter "Datadog" here.   (Optional) Add a description.   In the field "Pipeline to run", at the bottom of the page, select the pipeline that you created in the step above.   Enter the branch to use to fetch your config file when a Custom Webhook is received.   Enter the branch to use to check out your code when using the  checkout step in config. If your config is stored in the same repository as your code, then your Config branch and your Checkout branch should be the same.      Select Save.   You will see a webhook endpoint URL and secret. You can use these to set up your webhook trigger from your external source. Copy the Webhook URL and use it in your trigger source appended with the secret.     The secret will not be shown again so be sure to copy the URL before clicking Done.                To verify your trigger is set up correctly, trigger an event from your third party system.   Custom webhooks are available for projects integrated via the GitHub App. Custom webhooks are not available on CircleCI server.  Custom webhook triggers can only be associated with GitHub App pipelines. You can check if you have a GitHub App pipeline by going to Project Settings  Pipelines and checking if any of your pipelines have a GitHub App badge in the Config Source column. If needed, create a new pipeline by selecting Add pipeline.    The secret will not be shown again so be sure to copy the URL before clicking Done.     When a trigger is created, CircleCI registers a webhook with GitLab. Push events from GitLab are sent to CircleCI. CircleCI then uses the event data to determine if a pipeline should run, and if so, which pipeline should be run.   In addition to a pipeline, each trigger includes the webhook URL, and in this scenario, a CircleCI-created GitLab token. The webhook URL and GitLab token are used to securely register the webhook within GitLab in order to receive push events from your GitLab repository. You can view webhooks for a project in GitLab at Settings  Webhooks.        To add a trigger for a pipeline, follow these steps:     In the  CircleCI web app select Projects in the sidebar   Find your project in the list, select the ellipsis () next to it and choose Project Settings.   Select Triggers in the sidebar.     If you do not see Triggers in the sidebar, your project is integrated using either  GitHub OAuth or  Bitbucket Cloud and these steps do not apply.         Select Add Trigger.   Select the same location in the "Connect to" dropdown menu that you selected for your pipeline (for example, GitLab).   Select Next.   Complete the form fields and options:    Give your trigger a descriptive name.   Authorize your connection if this is not already showing with a  (Not required for custom webhooks).     For GitLab self-managed you can enter the URL for an instance you have previously set up with CircleCI. You will need to enter the relevant personal access token again here to authorize the connection.         Select your repository from the dropdown menu. This should match the repository your pipeline is connected to (not required for custom webhooks).   Choose your pipeline from the "Choose config to run" menu.   (Optional) You can configure trigger filters to configure the event types that will trigger the pipeline. For more information, see the  GitLab trigger options page.      Select Save     When setting up a trigger you will see a modal titled Webhook URL requesting that you set up a webhook in GitLab. You do not need to take action. The webhook is set up automatically by CircleCI. This is a known issue and will be fixed.           To verify your trigger is set up correctly, trigger an event from your repository.     If you do not see Triggers in the sidebar, your project is integrated using either  GitHub OAuth or  Bitbucket Cloud and these steps do not apply.  For GitLab self-managed you can enter the URL for an instance you have previously set up with CircleCI. You will need to enter the relevant personal access token again here to authorize the connection.  When setting up a trigger you will see a modal titled Webhook URL requesting that you set up a webhook in GitLab. You do not need to take action. The webhook is set up automatically by CircleCI. This is a known issue and will be fixed.   For steps to add a trigger for a pipeline using Bitbucket Data Center, see the  Bitbucket Data Center page.        This feature is supported for orgs that use OAuth authentication.   Check your Organization slug at Organization settings  Overview. OAuth authenticated orgs are structured as follows:     github/<your-org-name> or gh/<your-org-name>   bitbucket/<your-org-name> or bb/<your-org-name>     This feature is not supported if your organization slug is in the following format:     circleci/<UID>.     For an overview of feature support, see the  VCS integration overview page.           In the  CircleCI web app, select your org from the org cards on your user homepage.   Select Projects from the sidebar and locate your project from the list. You can use the search to help.   Select the ellipsis () next to your project and select Project Settings.   Select Triggers in the sidebar.   Select Add Trigger.     The "Pipeline to run" menu only shows the OAuth pipelines, you cannot schedule GitHub App, GitLab or Bitbucket Data Center pipelines.          Give your trigger a descriptive name.   Enter an optional trigger description.   Select the pipeline to run.   Select a release frequencies (weekly/monthly, which days/months/time etc.).   Enter a branch or tag name to determine when to trigger the pipeline.   Optionally, enter pipeline parameters. If you declare pipeline parameters in the form, you need to make sure they are configured in your project’s .circleci/config.yml. See the  Pipeline values and parameters page for more information.   Select an actor to initiate the trigger.      Define the new schedule by filling out the form, then select Save Trigger.     The form also provides the option of adding  pipeline parameters, which are typed pipeline variables that you declare at the top level of a configuration.   If you would like to manage common schedules for multiple workflows, you will need to manually set this in your .circleci/config.yml file. See the  Schedule pipelines with multiple workflows page for examples.    This feature is supported for orgs that use OAuth authentication.   Check your Organization slug at Organization settings  Overview. OAuth authenticated orgs are structured as follows:     github/<your-org-name> or gh/<your-org-name>   bitbucket/<your-org-name> or bb/<your-org-name>     This feature is not supported if your organization slug is in the following format:     circleci/<UID>.     For an overview of feature support, see the  VCS integration overview page.   The "Pipeline to run" menu only shows the OAuth pipelines, you cannot schedule GitHub App, GitLab or Bitbucket Data Center pipelines.  version: 2.1

parameters:
  image-tag:
    type: string
    default: "current"
  workingdir:
    type: string
    default: "~/main"

jobs:
  build:
    docker:
      - image: cimg/node:<< pipeline.parameters.image-tag >>
    environment:
      IMAGETAG: << pipeline.parameters.image-tag >>
    working_directory: << pipeline.parameters.workingdir >>
    steps:
      - run: echo "Image tag used was ${IMAGETAG}"
      - run: echo "$(pwd) == << pipeline.parameters.workingdir >>"    config file .circleci/sample-filename.yml could not be located on branch sample-branch-name in repository sample-repo-name  golang:1.7.1-jessie
redis:3.0.7-jessie  my-user/couchdb:1.6.1  version: 2.1
jobs:
  build:
    docker:
      - image: your/primary-image:version-tag
        auth:
          username: mydockerhub-user
          password: $DOCKERHUB_PASSWORD  # context / project UI env-var reference
      - image: mysql:5.7
        auth:
          username: mydockerhub-user
          password: $DOCKERHUB_PASSWORD  # context / project UI env-var reference
        environment:
           TZ: "America/Los_Angeles"
    working_directory: ~/your-dir
    environment:
      TZ: "America/Los_Angeles"   To find out which GitHub integration type you have, check your Organization slug at Organization settings  Overview. OAuth authenticated orgs are structured as follows:     github/<your-org-name> or gh/<your-org-name>   bitbucket/<your-org-name> or bb/<your-org-name>     An organization slug for a GitHub App integration is in the following format:     circleci/<UID>     The "build forked PRs" settings is not currently supported for GitLab or GitHub App projects. To find out if you authorized through the GitHub OAuth app or the CircleCI GitHub App, see the  GitHub App integration page.\n\n\n\nDeployment overview2 weeks ago2 min readCloudServer v4+On This PageIntroductionThe basics of deploymentUsing orbs to simplify deploymentUsing images to simplify deploymentHandling common deployment scenarios Introduction   Once a software application has been developed and tested, it needs to be deployed and made available for its intended audience. With CircleCI, you can deploy to virtually any target.   You can also configure CircleCI to integrate with other services for:     QA and testing   Feature management   Deployment strategies such as blue-green or canary deployment     Customize your configuration to match your requirements, whether you need a fully automated process or one that requires manual approval.      Deploy to Kubernetes? Refer to our  Deploys overview page to start managing your deployments in the CircleCI web app.          The basics of deployment   Here are the core concepts you need to get a deployment set up:     Deployment job: To deploy your application, add a  job to your .circleci/config.yml file and configure the job to run the steps you require.     Add a deployment log step to your deployment job to view a log of deployments in the CircleCI web app. See the  Deployment markers guide to learn more.         Deployment parameters: You may need to add environment variables and SSH keys to fulfill your deployment steps. Environment variables can be:    Defined within your configuration   Added to the project itself through the CircleCI web app:    Add project-level  environment variables   Add project-level  SSH keys.         Manual approval: If your deployment strategy requires a manual approval step, you can include a  hold/approve job in your workflow. This job will create a manual approval button visible in the CircleCI web app workflows map.     If you need to restrict connections, consider enabling  IP ranges for your deployment job.     Using orbs to simplify deployment    Orbs are packages of reusable configuration. For simpler deployment pipelines, you can use orbs to achieve the results you need with minimal configuration. Orbs are available for many common deployment targets.   For example, the  AWS CodeDeploy orb has a pre-configured deploy job that you can include in your configuration with the single line: aws-code-deploy/deploy. Orb jobs can be used once the orb has been invoked by adding the orbs stanza:    version: 2.1

orbs:
  aws-code-deploy: circleci/aws-code-deploy@x.y
  aws-cli: circleci/aws-cli@x.z
workflows:
  deploy_application:
    jobs:
      - aws-code-deploy/deploy:
          auth:
            - aws-cli/setup
          application-name: myApplication
          bundle-bucket: myApplicationS3Bucket
          bundle-key: myS3BucketKey
          deployment-group: myDeploymentGroup
          service-role-arn: myDeploymentGroupRoleARN    Under the hood, this orb creates, bundles, and deploys your application using your specified parameters set under the aws-code-deploy/deploy job declaration.   Check out the full range of available orbs in the  orbs registry. If the orb you need has not been created yet, consider  authoring one!     Using images to simplify deployment   CircleCI provides maintained Docker images (convenience images) that contain the tools required for common deployment scenarios. Convenience images provide fast spin-up times, reliability, and stability. Visit the  CircleCI Developer Hub to learn more about each convenience image:      cimg/deploy    cimg/aws    cimg/azure    cimg/gcp       Handling common deployment scenarios   Use the following how-to guides to manage common deployment use cases:     For examples of deploying to Kubernetes, see the guides in the  Continuous deployment config examples repo.    Deploy to Amazon SageMaker    Deploy Android applications    Deploy to Artifactory    Deploy to AWS    Deploy to AWS ECS    Deploy to AWS ECR/ECS    Deploy to Azure Container Registry    Deploy to Capistrano    Deploy to Cloud Foundry    Deploy to Firebase    Deploy to Google Cloud Platform    Deploy to Heroku    Deploy iOS applications    Deploy to npm registry    Deploy over SSH    Authorize Google Cloud SDK    Publish packages to Packagecloud     Go to the  orbs registry to simplify your configuration by using an orb for your deployment target.   Suggest an edit to this pageMake a contribution Learn how to contributeStill need help? Ask the CircleCI community Join the research community Visit our Support site\n\nDeployment overview2 weeks ago2 min readCloudServer v4+On This PageIntroductionThe basics of deploymentUsing orbs to simplify deploymentUsing images to simplify deploymentHandling common deployment scenarios Introduction   Once a software application has been developed and tested, it needs to be deployed and made available for its intended audience. With CircleCI, you can deploy to virtually any target.   You can also configure CircleCI to integrate with other services for:     QA and testing   Feature management   Deployment strategies such as blue-green or canary deployment     Customize your configuration to match your requirements, whether you need a fully automated process or one that requires manual approval.      Deploy to Kubernetes? Refer to our  Deploys overview page to start managing your deployments in the CircleCI web app.          The basics of deployment   Here are the core concepts you need to get a deployment set up:     Deployment job: To deploy your application, add a  job to your .circleci/config.yml file and configure the job to run the steps you require.     Add a deployment log step to your deployment job to view a log of deployments in the CircleCI web app. See the  Deployment markers guide to learn more.         Deployment parameters: You may need to add environment variables and SSH keys to fulfill your deployment steps. Environment variables can be:    Defined within your configuration   Added to the project itself through the CircleCI web app:    Add project-level  environment variables   Add project-level  SSH keys.         Manual approval: If your deployment strategy requires a manual approval step, you can include a  hold/approve job in your workflow. This job will create a manual approval button visible in the CircleCI web app workflows map.     If you need to restrict connections, consider enabling  IP ranges for your deployment job.     Using orbs to simplify deployment    Orbs are packages of reusable configuration. For simpler deployment pipelines, you can use orbs to achieve the results you need with minimal configuration. Orbs are available for many common deployment targets.   For example, the  AWS CodeDeploy orb has a pre-configured deploy job that you can include in your configuration with the single line: aws-code-deploy/deploy. Orb jobs can be used once the orb has been invoked by adding the orbs stanza:    version: 2.1

orbs:
  aws-code-deploy: circleci/aws-code-deploy@x.y
  aws-cli: circleci/aws-cli@x.z
workflows:
  deploy_application:
    jobs:
      - aws-code-deploy/deploy:
          auth:
            - aws-cli/setup
          application-name: myApplication
          bundle-bucket: myApplicationS3Bucket
          bundle-key: myS3BucketKey
          deployment-group: myDeploymentGroup
          service-role-arn: myDeploymentGroupRoleARN    Under the hood, this orb creates, bundles, and deploys your application using your specified parameters set under the aws-code-deploy/deploy job declaration.   Check out the full range of available orbs in the  orbs registry. If the orb you need has not been created yet, consider  authoring one!     Using images to simplify deployment   CircleCI provides maintained Docker images (convenience images) that contain the tools required for common deployment scenarios. Convenience images provide fast spin-up times, reliability, and stability. Visit the  CircleCI Developer Hub to learn more about each convenience image:      cimg/deploy    cimg/aws    cimg/azure    cimg/gcp       Handling common deployment scenarios   Use the following how-to guides to manage common deployment use cases:     For examples of deploying to Kubernetes, see the guides in the  Continuous deployment config examples repo.    Deploy to Amazon SageMaker    Deploy Android applications    Deploy to Artifactory    Deploy to AWS    Deploy to AWS ECS    Deploy to AWS ECR/ECS    Deploy to Azure Container Registry    Deploy to Capistrano    Deploy to Cloud Foundry    Deploy to Firebase    Deploy to Google Cloud Platform    Deploy to Heroku    Deploy iOS applications    Deploy to npm registry    Deploy over SSH    Authorize Google Cloud SDK    Publish packages to Packagecloud     Go to the  orbs registry to simplify your configuration by using an orb for your deployment target.   Suggest an edit to this pageMake a contribution Learn how to contributeStill need help? Ask the CircleCI community Join the research community Visit our Support site DocsTerms of UsePrivacy PolicyCookie PolicySecurity© 2025 Circle Internet Services, Inc., All Rights Reserved.\n\nDeploy to Kubernetes? Refer to our  Deploys overview page to start managing your deployments in the CircleCI web app.  Add a deployment log step to your deployment job to view a log of deployments in the CircleCI web app. See the  Deployment markers guide to learn more.  version: 2.1

orbs:
  aws-code-deploy: circleci/aws-code-deploy@x.y
  aws-cli: circleci/aws-cli@x.z
workflows:
  deploy_application:
    jobs:
      - aws-code-deploy/deploy:
          auth:
            - aws-cli/setup
          application-name: myApplication
          bundle-bucket: myApplicationS3Bucket
          bundle-key: myS3BucketKey
          deployment-group: myDeploymentGroup
          service-role-arn: myDeploymentGroupRoleARN\n\n\n\nUsing the Docker execution environment1 week ago6 min readCloudServer v4+On This PageSpecifying Docker imagesCircleCI’s public convenience images on Docker HubPublic images on Docker HubPublic images on Docker registriesAvailable Docker resource classesx86ArmView resource usageDocker benefits and limitationsDocker image best practicesUsing multiple Docker imagesRAM disksCaching Docker imagesNext steps      Legacy images with the prefix circleci/` were  deprecated on December 31, 2021. For faster builds, upgrade your projects with  next-generation convenience images.        You can use the Docker execution environment to run your  jobs in Docker containers. The Docker execution environment is accessed using the  Docker executor. Using Docker increases performance by building only what is required for your application.   Specify a Docker image in your  .circleci/config.yml file to spin up a container. All steps in your job will be run in this container.      Using Docker? Authenticating Docker pulls from image registries is recommended when using the Docker execution environment. Authenticated pulls allow access to private Docker images, and may also grant higher rate limits, depending on your registry provider. For further information see  Using Docker authenticated pulls.         jobs:
  my-job:
    docker:
      - image: cimg/node:lts    A container is an instance of a specified Docker image. The first image listed in your configuration for a job is referred to as the primary container image and this is where all steps in the job will run. Secondary containers can also be specified to run alongside for running services, such as, databases. If you are new to Docker, see the  Docker Overview documentation for concepts.   CircleCI maintains convenience images on Docker Hub for popular languages. See  the CircleCI Developer Hub for a complete list of image names and tags.      If you need a Docker image that installs Docker and has Git, consider using cimg/base:current.          Specifying Docker images   Docker images may be specified in a few ways:     By the image name and version tag on Docker Hub, or   By using the URL to an image in a registry.     Nearly all of the public images on Docker Hub and other Docker registries are supported by default when you specify the docker: key in your config.yml file. If you want to work with private images/registries, refer to  Using Docker Authenticated Pulls.   The following examples show how you can use public images from various sources:   CircleCI’s public convenience images on Docker Hub    name:tag    cimg/node:14.17-browsers      name@digest    cimg/node@sha256:aa6d08a04d13dd8a...         Public images on Docker Hub    name:tag    alpine:3.13      name@digest    alpine@sha256:e15947432b813e8f...         Public images on Docker registries    image_full_url:tag    gcr.io/google-containers/busybox:1.24      image_full_url@digest    gcr.io/google-containers/busybox@sha256:4bdd623e848417d9612...           Available Docker resource classes   The  resource_class key allows you to configure CPU and RAM resources for each job.   Specify a resource class using the resource_class key, as follows:    jobs:
  build:
    docker:
      - image: cimg/base:current
    resource_class: xlarge
    steps:
    #  ...  other config    x86  For the Docker execution environment, the following resources classes are available for the x86 architecture:      For credit and access information, see the  Resource classes page. Resource class access is dependent on your  Plan.       ClassvCPUsRAMCloudServersmall12GBmedium24GBmedium+36GBlarge48GBxlarge816GB2xlarge1632GB2xlarge+2040GB   Arm  The following resource classes are available for Arm with Docker:       Arm on Docker For credit and access information see the  Resource classes page. Resource class access is dependent on your  Plan   To find out which CircleCI Docker convenience images support Arm resource classes, you can refer to  Docker hub:     Select the image (for example, cimg/python).   Select the tags tab.   View what is supported under OS/ARCH for the latest tags. For example, cimg/python has linux/amd64 and linux/arm64, which means Arm is supported.          ClassvCPUsRAMCloudServerarm.medium28 GBarm.large416 GBarm.xlarge832 GBarm.2xlarge1664 GB   View resource usage  To view the compute resource usage for the duration of a job in the CircleCI web app:     Select Dashboard from the sidebar menu   Use the dropdown menus to select a project, and a branch   Expand your workflow (  )   Select a job by clicking on the job name   Select the Resources tab to view CPU and RAM usage for the duration of the job     You can use these insights to decide whether to make changes to the job’s configured resource class. You can also access  resource class Insights.           Docker benefits and limitations   Docker also has built-in image caching and enables you to build, run, and publish Docker images via  Remote Docker. Consider the requirements of your application as well. If the following are true for your application, Docker may be the right choice:     Your application is self-sufficient.   Your application requires additional services to be tested.   Your application is distributed as a Docker image (requires using  Remote Docker).   You want to use docker compose (requires using  Remote Docker).     Choosing Docker limits your runs to what is possible from within a Docker container (including our  Remote Docker feature). For instance, if you require low-level access to the network or need to mount external volumes, consider using machine.   The table below shows tradeoffs between using a docker image versus an Ubuntu-based machine image as the environment for the container:  CapabilitydockermachineStart timeInstantInstant for most (1)Clean environmentYesYesCustom imagesYes (2)NoBuild Docker imagesYes (3)YesFull control over job environmentNoYesFull root accessNoYesRun multiple databasesYes (4)YesRun multiple versions of the same softwareNoYes Docker layer cachingYesYesRun privileged containersNoYesUse Docker compose with volumesNoYes Configurable resources (CPU/RAM)YesYes  (1) Some less commonly used execution environments may see up to 90 seconds of start time.   (2) See  Using Custom Docker Images.   (3) Requires using  Remote Docker.   (4) While you can run multiple databases with Docker, all images (primary and secondary) share the underlying resource limits. Performance in this regard will be dictated by the compute capacities of your plan.   For more information on machine, see the next section below.     Docker image best practices     If you encounter problems with rate limits imposed by your registry provider, using  authenticated Docker pulls may grant higher limits.   CircleCI has partnered with Docker to ensure that our users can continue to access Docker Hub without rate limits. As of November 1st 2020, with few exceptions, you should not be impacted by any rate limits when pulling images from Docker Hub through CircleCI. However, these rate limits may go into effect for CircleCI users in the future. We encourage you to  add Docker Hub authentication to your CircleCI configuration and consider upgrading your Docker Hub plan, as appropriate, to prevent any impact from rate limits in the future.   Avoid using mutable tags like latest or 1 as the image version in your config.yml file. It is best practice to use precise image versions or digests, like redis:3.2.7 or redis@sha256:95f0c9434f37db0a4f... as shown in the examples. Mutable tags often lead to unexpected changes in your job environment. CircleCI cannot guarantee that mutable tags will return an up-to-date version of an image. You could specify alpine:latest and actually get a stale cache from a month ago.   If you experience increases in your run times due to installing additional tools during execution, consider creating and using a custom-built image that comes with those tools pre-installed. See the  Using Custom-Built Docker Images page for more information.   When you use  AWS ECR images, it is best practice to use us-east-1 region. Our job execution infrastructure is in us-east-1 region, so having your image on the same region reduces the image download time.   If your pipelines are failing despite there being little to no changes in your project, you may need to investigate upstream issues with the Docker images being used.     More details on the Docker executor are available on the  Configuration reference page.     Using multiple Docker images   It is possible to specify multiple images for your job. Each image will be used to spin up a separate container.   Using multiple containers for a job will be useful if you need to use a database for your tests, or for some other required service.   When using a multi-container job setup, all containers run in a common network and every exposed port will be available on localhost. All containers can communicate with one another. It is also possible to change this hostname using the name key. For a full list of options, see the  Configuration reference.   In a multi-image configuration job, all steps are executed in the container created by the first image listed.    jobs:
  build:
    docker:
    # Primary container image where all steps run.
     - image: cimg/base:current
    # Secondary container image on common network.
     - image: cimg/mariadb:10.6

    steps:
      # command will execute in an Ubuntu-based container
      # and can access MariaDB on localhost
      - run: sleep 5 && nc -vz localhost 3306      RAM disks   A RAM disk is available at /mnt/ramdisk that offers a  temporary file storage paradigm, similar to using /dev/shm. Using the RAM disk can help speed up your build, provided that the resource_class you are using has enough memory to fit the entire contents of your project (all files checked out from git, dependencies, assets generated etc).   The simplest way to use this RAM disk is to configure the working_directory of a job to be /mnt/ramdisk:    jobs:
  build:
    docker:
     - image: alpine

    working_directory: /mnt/ramdisk

    steps:
      - run: |
          echo '#!/bin/sh' > run.sh
          echo 'echo Hello world!' >> run.sh
          chmod +x run.sh
      - run: ./run.sh      Caching Docker images      This section discusses caching the Docker images used to spin up a Docker execution environment. It does not apply to  Docker layer caching, which is a feature used to speed up building new Docker images in your projects.        The time it takes to spin up a Docker container to run a job can vary based on several different factors, such as the size of the image and if some, or all, of the layers are already cached on the underlying Docker host machine.   If you are using a more popular image, such as CircleCI convenience images, then cache hits are more likely for a larger number of layers. Most of the popular CircleCI images use the same base image. The majority of the base layers are the same between images, so you have a greater chance of having a cache hit.   The environment has to spin up for every new job, regardless of whether it is in the same workflow or if it is a re-run/subsequent run. (CircleCI never reuses containers, for security reasons.) Once the job is finished, the container is destroyed. There is no guarantee that jobs, even in the same workflow, will run on the same Docker host machine. This implies that the cache status may differ.   In all cases, cache hits are not guaranteed, but are a bonus convenience when available. With this in mind, a worst-case scenario of a full image pull should be accounted for in all jobs.   In summary, the availability of caching is not something that can be controlled via settings or configuration, but by choosing a popular image, such as  CircleCI convenience images, you will have more chances of hitting cached layers in the "Spin Up Environment" step.     Next steps   Find out more about using  Convenience Images with the Docker executor.   Suggest an edit to this pageMake a contribution Learn how to contributeStill need help? Ask the CircleCI community Join the research community Visit our Support site\n\nUsing the Docker execution environment1 week ago6 min readCloudServer v4+On This PageSpecifying Docker imagesCircleCI’s public convenience images on Docker HubPublic images on Docker HubPublic images on Docker registriesAvailable Docker resource classesx86ArmView resource usageDocker benefits and limitationsDocker image best practicesUsing multiple Docker imagesRAM disksCaching Docker imagesNext steps      Legacy images with the prefix circleci/` were  deprecated on December 31, 2021. For faster builds, upgrade your projects with  next-generation convenience images.        You can use the Docker execution environment to run your  jobs in Docker containers. The Docker execution environment is accessed using the  Docker executor. Using Docker increases performance by building only what is required for your application.   Specify a Docker image in your  .circleci/config.yml file to spin up a container. All steps in your job will be run in this container.      Using Docker? Authenticating Docker pulls from image registries is recommended when using the Docker execution environment. Authenticated pulls allow access to private Docker images, and may also grant higher rate limits, depending on your registry provider. For further information see  Using Docker authenticated pulls.         jobs:
  my-job:
    docker:
      - image: cimg/node:lts    A container is an instance of a specified Docker image. The first image listed in your configuration for a job is referred to as the primary container image and this is where all steps in the job will run. Secondary containers can also be specified to run alongside for running services, such as, databases. If you are new to Docker, see the  Docker Overview documentation for concepts.   CircleCI maintains convenience images on Docker Hub for popular languages. See  the CircleCI Developer Hub for a complete list of image names and tags.      If you need a Docker image that installs Docker and has Git, consider using cimg/base:current.          Specifying Docker images   Docker images may be specified in a few ways:     By the image name and version tag on Docker Hub, or   By using the URL to an image in a registry.     Nearly all of the public images on Docker Hub and other Docker registries are supported by default when you specify the docker: key in your config.yml file. If you want to work with private images/registries, refer to  Using Docker Authenticated Pulls.   The following examples show how you can use public images from various sources:   CircleCI’s public convenience images on Docker Hub    name:tag    cimg/node:14.17-browsers      name@digest    cimg/node@sha256:aa6d08a04d13dd8a...         Public images on Docker Hub    name:tag    alpine:3.13      name@digest    alpine@sha256:e15947432b813e8f...         Public images on Docker registries    image_full_url:tag    gcr.io/google-containers/busybox:1.24      image_full_url@digest    gcr.io/google-containers/busybox@sha256:4bdd623e848417d9612...           Available Docker resource classes   The  resource_class key allows you to configure CPU and RAM resources for each job.   Specify a resource class using the resource_class key, as follows:    jobs:
  build:
    docker:
      - image: cimg/base:current
    resource_class: xlarge
    steps:
    #  ...  other config    x86  For the Docker execution environment, the following resources classes are available for the x86 architecture:      For credit and access information, see the  Resource classes page. Resource class access is dependent on your  Plan.       ClassvCPUsRAMCloudServersmall12GBmedium24GBmedium+36GBlarge48GBxlarge816GB2xlarge1632GB2xlarge+2040GB   Arm  The following resource classes are available for Arm with Docker:       Arm on Docker For credit and access information see the  Resource classes page. Resource class access is dependent on your  Plan   To find out which CircleCI Docker convenience images support Arm resource classes, you can refer to  Docker hub:     Select the image (for example, cimg/python).   Select the tags tab.   View what is supported under OS/ARCH for the latest tags. For example, cimg/python has linux/amd64 and linux/arm64, which means Arm is supported.          ClassvCPUsRAMCloudServerarm.medium28 GBarm.large416 GBarm.xlarge832 GBarm.2xlarge1664 GB   View resource usage  To view the compute resource usage for the duration of a job in the CircleCI web app:     Select Dashboard from the sidebar menu   Use the dropdown menus to select a project, and a branch   Expand your workflow (  )   Select a job by clicking on the job name   Select the Resources tab to view CPU and RAM usage for the duration of the job     You can use these insights to decide whether to make changes to the job’s configured resource class. You can also access  resource class Insights.           Docker benefits and limitations   Docker also has built-in image caching and enables you to build, run, and publish Docker images via  Remote Docker. Consider the requirements of your application as well. If the following are true for your application, Docker may be the right choice:     Your application is self-sufficient.   Your application requires additional services to be tested.   Your application is distributed as a Docker image (requires using  Remote Docker).   You want to use docker compose (requires using  Remote Docker).     Choosing Docker limits your runs to what is possible from within a Docker container (including our  Remote Docker feature). For instance, if you require low-level access to the network or need to mount external volumes, consider using machine.   The table below shows tradeoffs between using a docker image versus an Ubuntu-based machine image as the environment for the container:  CapabilitydockermachineStart timeInstantInstant for most (1)Clean environmentYesYesCustom imagesYes (2)NoBuild Docker imagesYes (3)YesFull control over job environmentNoYesFull root accessNoYesRun multiple databasesYes (4)YesRun multiple versions of the same softwareNoYes Docker layer cachingYesYesRun privileged containersNoYesUse Docker compose with volumesNoYes Configurable resources (CPU/RAM)YesYes  (1) Some less commonly used execution environments may see up to 90 seconds of start time.   (2) See  Using Custom Docker Images.   (3) Requires using  Remote Docker.   (4) While you can run multiple databases with Docker, all images (primary and secondary) share the underlying resource limits. Performance in this regard will be dictated by the compute capacities of your plan.   For more information on machine, see the next section below.     Docker image best practices     If you encounter problems with rate limits imposed by your registry provider, using  authenticated Docker pulls may grant higher limits.   CircleCI has partnered with Docker to ensure that our users can continue to access Docker Hub without rate limits. As of November 1st 2020, with few exceptions, you should not be impacted by any rate limits when pulling images from Docker Hub through CircleCI. However, these rate limits may go into effect for CircleCI users in the future. We encourage you to  add Docker Hub authentication to your CircleCI configuration and consider upgrading your Docker Hub plan, as appropriate, to prevent any impact from rate limits in the future.   Avoid using mutable tags like latest or 1 as the image version in your config.yml file. It is best practice to use precise image versions or digests, like redis:3.2.7 or redis@sha256:95f0c9434f37db0a4f... as shown in the examples. Mutable tags often lead to unexpected changes in your job environment. CircleCI cannot guarantee that mutable tags will return an up-to-date version of an image. You could specify alpine:latest and actually get a stale cache from a month ago.   If you experience increases in your run times due to installing additional tools during execution, consider creating and using a custom-built image that comes with those tools pre-installed. See the  Using Custom-Built Docker Images page for more information.   When you use  AWS ECR images, it is best practice to use us-east-1 region. Our job execution infrastructure is in us-east-1 region, so having your image on the same region reduces the image download time.   If your pipelines are failing despite there being little to no changes in your project, you may need to investigate upstream issues with the Docker images being used.     More details on the Docker executor are available on the  Configuration reference page.     Using multiple Docker images   It is possible to specify multiple images for your job. Each image will be used to spin up a separate container.   Using multiple containers for a job will be useful if you need to use a database for your tests, or for some other required service.   When using a multi-container job setup, all containers run in a common network and every exposed port will be available on localhost. All containers can communicate with one another. It is also possible to change this hostname using the name key. For a full list of options, see the  Configuration reference.   In a multi-image configuration job, all steps are executed in the container created by the first image listed.    jobs:
  build:
    docker:
    # Primary container image where all steps run.
     - image: cimg/base:current
    # Secondary container image on common network.
     - image: cimg/mariadb:10.6

    steps:
      # command will execute in an Ubuntu-based container
      # and can access MariaDB on localhost
      - run: sleep 5 && nc -vz localhost 3306      RAM disks   A RAM disk is available at /mnt/ramdisk that offers a  temporary file storage paradigm, similar to using /dev/shm. Using the RAM disk can help speed up your build, provided that the resource_class you are using has enough memory to fit the entire contents of your project (all files checked out from git, dependencies, assets generated etc).   The simplest way to use this RAM disk is to configure the working_directory of a job to be /mnt/ramdisk:    jobs:
  build:
    docker:
     - image: alpine

    working_directory: /mnt/ramdisk

    steps:
      - run: |
          echo '#!/bin/sh' > run.sh
          echo 'echo Hello world!' >> run.sh
          chmod +x run.sh
      - run: ./run.sh      Caching Docker images      This section discusses caching the Docker images used to spin up a Docker execution environment. It does not apply to  Docker layer caching, which is a feature used to speed up building new Docker images in your projects.        The time it takes to spin up a Docker container to run a job can vary based on several different factors, such as the size of the image and if some, or all, of the layers are already cached on the underlying Docker host machine.   If you are using a more popular image, such as CircleCI convenience images, then cache hits are more likely for a larger number of layers. Most of the popular CircleCI images use the same base image. The majority of the base layers are the same between images, so you have a greater chance of having a cache hit.   The environment has to spin up for every new job, regardless of whether it is in the same workflow or if it is a re-run/subsequent run. (CircleCI never reuses containers, for security reasons.) Once the job is finished, the container is destroyed. There is no guarantee that jobs, even in the same workflow, will run on the same Docker host machine. This implies that the cache status may differ.   In all cases, cache hits are not guaranteed, but are a bonus convenience when available. With this in mind, a worst-case scenario of a full image pull should be accounted for in all jobs.   In summary, the availability of caching is not something that can be controlled via settings or configuration, but by choosing a popular image, such as  CircleCI convenience images, you will have more chances of hitting cached layers in the "Spin Up Environment" step.     Next steps   Find out more about using  Convenience Images with the Docker executor.   Suggest an edit to this pageMake a contribution Learn how to contributeStill need help? Ask the CircleCI community Join the research community Visit our Support site DocsTerms of UsePrivacy PolicyCookie PolicySecurity© 2025 Circle Internet Services, Inc., All Rights Reserved.\n\nLegacy images with the prefix circleci/` were  deprecated on December 31, 2021. For faster builds, upgrade your projects with  next-generation convenience images.  Using Docker? Authenticating Docker pulls from image registries is recommended when using the Docker execution environment. Authenticated pulls allow access to private Docker images, and may also grant higher rate limits, depending on your registry provider. For further information see  Using Docker authenticated pulls.  jobs:
  my-job:
    docker:
      - image: cimg/node:lts  If you need a Docker image that installs Docker and has Git, consider using cimg/base:current.  jobs:
  build:
    docker:
      - image: cimg/base:current
    resource_class: xlarge
    steps:
    #  ...  other config  For credit and access information, see the  Resource classes page. Resource class access is dependent on your  Plan.   Arm on Docker For credit and access information see the  Resource classes page. Resource class access is dependent on your  Plan   To find out which CircleCI Docker convenience images support Arm resource classes, you can refer to  Docker hub:     Select the image (for example, cimg/python).   Select the tags tab.   View what is supported under OS/ARCH for the latest tags. For example, cimg/python has linux/amd64 and linux/arm64, which means Arm is supported.       jobs:
  build:
    docker:
    # Primary container image where all steps run.
     - image: cimg/base:current
    # Secondary container image on common network.
     - image: cimg/mariadb:10.6

    steps:
      # command will execute in an Ubuntu-based container
      # and can access MariaDB on localhost
      - run: sleep 5 && nc -vz localhost 3306  jobs:
  build:
    docker:
     - image: alpine

    working_directory: /mnt/ramdisk

    steps:
      - run: |
          echo '#!/bin/sh' > run.sh
          echo 'echo Hello world!' >> run.sh
          chmod +x run.sh
      - run: ./run.sh  This section discusses caching the Docker images used to spin up a Docker execution environment. It does not apply to  Docker layer caching, which is a feature used to speed up building new Docker images in your projects.\n\n\n\nOrbs overview1 month ago3 min readCloudServer v4+On This PageIntroductionQuickstartUse an orbNode exampleBenefits of using orbsThe orb registryOrb designationsPublic or privateOrbs page in the CircleCI appSee also   Use orbs to:     Simplify configuration (.circleci/_config.yml)   Automate repeated processes   Accelerate project setup   Simplify integration with third-party tools       Introduction   Orbs are reusable packages of parameterizable configuration that can be used in any project. They are made up of reusable configuration elements, for example,  jobs,  commands, and  executors. Orbs are available for many languages, platforms, services, and tools. Visit the  Orbs Registry to search for orbs to help simplify your configuration.   If you would like to author your own orb, read more on the  Introduction to Authoring Orbs page.     Quickstart     Follow our  Node.js project quickstart guide.   Follow our  Python project quickstart guide.   Set up notifications using the  Slack orb.       Use an orb   An orb is identified by its slug which contains the namespace, and orb name. A namespace is a unique identifier referring to the organization authoring a set of orbs. The orb name will be followed by an @ symbol and a  semantic version string, identifying which version of the orb is being used. For example: <namespace>/<orb-name>@1.2.3.   Each orb within the  registry provides a  quickstart guide, which contains a sample code snippet for importing that specific orb, with its most recent version, into your .circleci/config.yml.   The example below shows how to import any orb into your CircleCI configuration file. Use the tabs to switch between a generic layout for importing any orb, and a specific example of importing the Node.JS orb:  NodeGeneric    version: 2.1

orbs:
  node: circleci/node@5.0.3        version: 2.1

orbs:
  <orb-name>: <namespace>/<orb-name>@x.y.z       After the orb has been imported into the configuration file, the elements provided by the orb are available as <orb-name>/<element>. Orb elements can include jobs, commands, and executors. The parameters available for each element are listed in the orb registry in a table under each element.   Most orbs will also include usage examples detailing common functionality, to further simplify the process of incorporating them into your projects. If you would like to contribute to an existing orb, or file an issue on the orb’s repository, many orb authors will include the git repository link.   Orb elements can be used in the same way as  reusable configuration elements. The Node example below shows how to use an orb’s default executor, and an orb command.   Node example  The Node orb provides a command,  install-packages, to install your node packages, automatically enable caching, and provide additional options through the use of parameters. To use the install-packages command, reference it in a job’s  steps.    version: 2.1

orbs:
  node: circleci/node@x.y # replace orb version

jobs:
  test:
    executor: node/default # use the default executor specified by the orb
    steps:
      - checkout
      - node/install-packages # Use a command from the orb in a job's steps       Benefits of using orbs   Orbs provide parameterizable configuration elements that can greatly simplify your configuration. To illustrate this, the following example shows a typical configuration for testing a Node.js application using the Node.JS orb (using the test job provided by the  circleci/node orb), compared to the configuration required without using the orb (defining a job with the required steps for testing the application).   Orbs let you pull in pre-defined, parameterized configuration elements into your project configuration. Taking it a step further, authoring your own orb lets you define parameterized configuration elements once and utilize them across multiple similar projects.  With OrbsWithout orbs    version: 2.1

orbs:
  node: circleci/node@x.y # replace orb version https://circleci.com/developer/orbs/orb/circleci/node#quick-start

workflows:
  test_my_app:
    jobs:
      - node/test:
          version: <node-version> # replace node version        version: 2.1

jobs:
  test:
    docker:
      - image: cimg/node:<node-version>
    steps:
      - checkout
      - restore_cache:
          keys:
            - node-deps-v1-{{ .Branch }}-{{checksum "package-lock.json"}}
      - run:
          name: install packages
          command: npm ci
      - save_cache:
          key: node-deps-v1-{{ .Branch }}-{{checksum "package-lock.json"}}
          paths:
            - ~/.npm
      - run:
          name: Run Tests
          command: npm run test

workflows:
  test_my_app:
    jobs:
      - test         The orb registry   The  Orb Registry is an open repository of all published orbs. Find the orb for your stack or consider developing and  publishing your own orb.        Orb designations     In order to use uncertified orbs (partner or community), your organization’s administrator must opt-in to allow uncertified orb usage on the Organization Settings  Security page for your org.        Orbs in the registry will appear with one of three different namespace designations:  DesignationDescriptionCertifiedWritten and tested by the CircleCI teamPartnerWritten by our technology partnersCommunityWritten by the community   Public or private  Orbs can be published in one of two ways:     Public: Searchable in the orb registry, and available for anyone to use   Private: Only available to use within your organization, and only findable in the registry with a direct URL and when authenticated     To understand these concepts further, read the  Public Orbs vs Private Orbs section of the Orb Concepts page.      Orbs page in the CircleCI app      The orbs page in the CircleCI web app is not currently available on CircleCI server.           Private orb details pages may only be viewed by logged-in members of your organization. Unpublished orbs will not have linked details pages.        To access the orbs page in the web app, navigate to Organization Settings and select Orbs from the sidebar.   The orbs page lists orbs created within your organization. You can view:     Orb type (public or private)   Orb usage (how many times the orb is used across all configurations)   Latest version   Description     Full orb details, including orb source, are accessible by clicking on the orb name. The orb details page is similar to the CircleCI orb registry in that the details page provides the orb’s contents, commands, and usage examples.     See also     Refer to  Orbs Concepts for high-level information about CircleCI orbs.   Refer to  Orbs FAQ for information on known issues and questions that have been addressed when using CircleCI orbs.   Refer to  Reusable Configuration Reference for examples of reusable orbs, commands, parameters, and executors.   Refer to  Orb Testing Methodologies for information on how to test orbs you have created.     Suggest an edit to this pageMake a contribution Learn how to contributeStill need help? Ask the CircleCI community Join the research community Visit our Support site\n\nOrbs overview1 month ago3 min readCloudServer v4+On This PageIntroductionQuickstartUse an orbNode exampleBenefits of using orbsThe orb registryOrb designationsPublic or privateOrbs page in the CircleCI appSee also   Use orbs to:     Simplify configuration (.circleci/_config.yml)   Automate repeated processes   Accelerate project setup   Simplify integration with third-party tools       Introduction   Orbs are reusable packages of parameterizable configuration that can be used in any project. They are made up of reusable configuration elements, for example,  jobs,  commands, and  executors. Orbs are available for many languages, platforms, services, and tools. Visit the  Orbs Registry to search for orbs to help simplify your configuration.   If you would like to author your own orb, read more on the  Introduction to Authoring Orbs page.     Quickstart     Follow our  Node.js project quickstart guide.   Follow our  Python project quickstart guide.   Set up notifications using the  Slack orb.       Use an orb   An orb is identified by its slug which contains the namespace, and orb name. A namespace is a unique identifier referring to the organization authoring a set of orbs. The orb name will be followed by an @ symbol and a  semantic version string, identifying which version of the orb is being used. For example: <namespace>/<orb-name>@1.2.3.   Each orb within the  registry provides a  quickstart guide, which contains a sample code snippet for importing that specific orb, with its most recent version, into your .circleci/config.yml.   The example below shows how to import any orb into your CircleCI configuration file. Use the tabs to switch between a generic layout for importing any orb, and a specific example of importing the Node.JS orb:  NodeGeneric    version: 2.1

orbs:
  node: circleci/node@5.0.3        version: 2.1

orbs:
  <orb-name>: <namespace>/<orb-name>@x.y.z       After the orb has been imported into the configuration file, the elements provided by the orb are available as <orb-name>/<element>. Orb elements can include jobs, commands, and executors. The parameters available for each element are listed in the orb registry in a table under each element.   Most orbs will also include usage examples detailing common functionality, to further simplify the process of incorporating them into your projects. If you would like to contribute to an existing orb, or file an issue on the orb’s repository, many orb authors will include the git repository link.   Orb elements can be used in the same way as  reusable configuration elements. The Node example below shows how to use an orb’s default executor, and an orb command.   Node example  The Node orb provides a command,  install-packages, to install your node packages, automatically enable caching, and provide additional options through the use of parameters. To use the install-packages command, reference it in a job’s  steps.    version: 2.1

orbs:
  node: circleci/node@x.y # replace orb version

jobs:
  test:
    executor: node/default # use the default executor specified by the orb
    steps:
      - checkout
      - node/install-packages # Use a command from the orb in a job's steps       Benefits of using orbs   Orbs provide parameterizable configuration elements that can greatly simplify your configuration. To illustrate this, the following example shows a typical configuration for testing a Node.js application using the Node.JS orb (using the test job provided by the  circleci/node orb), compared to the configuration required without using the orb (defining a job with the required steps for testing the application).   Orbs let you pull in pre-defined, parameterized configuration elements into your project configuration. Taking it a step further, authoring your own orb lets you define parameterized configuration elements once and utilize them across multiple similar projects.  With OrbsWithout orbs    version: 2.1

orbs:
  node: circleci/node@x.y # replace orb version https://circleci.com/developer/orbs/orb/circleci/node#quick-start

workflows:
  test_my_app:
    jobs:
      - node/test:
          version: <node-version> # replace node version        version: 2.1

jobs:
  test:
    docker:
      - image: cimg/node:<node-version>
    steps:
      - checkout
      - restore_cache:
          keys:
            - node-deps-v1-{{ .Branch }}-{{checksum "package-lock.json"}}
      - run:
          name: install packages
          command: npm ci
      - save_cache:
          key: node-deps-v1-{{ .Branch }}-{{checksum "package-lock.json"}}
          paths:
            - ~/.npm
      - run:
          name: Run Tests
          command: npm run test

workflows:
  test_my_app:
    jobs:
      - test         The orb registry   The  Orb Registry is an open repository of all published orbs. Find the orb for your stack or consider developing and  publishing your own orb.        Orb designations     In order to use uncertified orbs (partner or community), your organization’s administrator must opt-in to allow uncertified orb usage on the Organization Settings  Security page for your org.        Orbs in the registry will appear with one of three different namespace designations:  DesignationDescriptionCertifiedWritten and tested by the CircleCI teamPartnerWritten by our technology partnersCommunityWritten by the community   Public or private  Orbs can be published in one of two ways:     Public: Searchable in the orb registry, and available for anyone to use   Private: Only available to use within your organization, and only findable in the registry with a direct URL and when authenticated     To understand these concepts further, read the  Public Orbs vs Private Orbs section of the Orb Concepts page.      Orbs page in the CircleCI app      The orbs page in the CircleCI web app is not currently available on CircleCI server.           Private orb details pages may only be viewed by logged-in members of your organization. Unpublished orbs will not have linked details pages.        To access the orbs page in the web app, navigate to Organization Settings and select Orbs from the sidebar.   The orbs page lists orbs created within your organization. You can view:     Orb type (public or private)   Orb usage (how many times the orb is used across all configurations)   Latest version   Description     Full orb details, including orb source, are accessible by clicking on the orb name. The orb details page is similar to the CircleCI orb registry in that the details page provides the orb’s contents, commands, and usage examples.     See also     Refer to  Orbs Concepts for high-level information about CircleCI orbs.   Refer to  Orbs FAQ for information on known issues and questions that have been addressed when using CircleCI orbs.   Refer to  Reusable Configuration Reference for examples of reusable orbs, commands, parameters, and executors.   Refer to  Orb Testing Methodologies for information on how to test orbs you have created.     Suggest an edit to this pageMake a contribution Learn how to contributeStill need help? Ask the CircleCI community Join the research community Visit our Support site DocsTerms of UsePrivacy PolicyCookie PolicySecurity© 2025 Circle Internet Services, Inc., All Rights Reserved.\n\nversion: 2.1

orbs:
  node: circleci/node@5.0.3    version: 2.1

orbs:
  node: circleci/node@5.0.3    version: 2.1

orbs:
  <orb-name>: <namespace>/<orb-name>@x.y.z    version: 2.1

orbs:
  <orb-name>: <namespace>/<orb-name>@x.y.z  version: 2.1

orbs:
  node: circleci/node@x.y # replace orb version

jobs:
  test:
    executor: node/default # use the default executor specified by the orb
    steps:
      - checkout
      - node/install-packages # Use a command from the orb in a job's steps    version: 2.1

orbs:
  node: circleci/node@x.y # replace orb version https://circleci.com/developer/orbs/orb/circleci/node#quick-start

workflows:
  test_my_app:
    jobs:
      - node/test:
          version: <node-version> # replace node version    version: 2.1

orbs:
  node: circleci/node@x.y # replace orb version https://circleci.com/developer/orbs/orb/circleci/node#quick-start

workflows:
  test_my_app:
    jobs:
      - node/test:
          version: <node-version> # replace node version    version: 2.1

jobs:
  test:
    docker:
      - image: cimg/node:<node-version>
    steps:
      - checkout
      - restore_cache:
          keys:
            - node-deps-v1-{{ .Branch }}-{{checksum "package-lock.json"}}
      - run:
          name: install packages
          command: npm ci
      - save_cache:
          key: node-deps-v1-{{ .Branch }}-{{checksum "package-lock.json"}}
          paths:
            - ~/.npm
      - run:
          name: Run Tests
          command: npm run test

workflows:
  test_my_app:
    jobs:
      - test    version: 2.1

jobs:
  test:
    docker:
      - image: cimg/node:<node-version>
    steps:
      - checkout
      - restore_cache:
          keys:
            - node-deps-v1-{{ .Branch }}-{{checksum "package-lock.json"}}
      - run:
          name: install packages
          command: npm ci
      - save_cache:
          key: node-deps-v1-{{ .Branch }}-{{checksum "package-lock.json"}}
          paths:
            - ~/.npm
      - run:
          name: Run Tests
          command: npm run test

workflows:
  test_my_app:
    jobs:
      - test    In order to use uncertified orbs (partner or community), your organization’s administrator must opt-in to allow uncertified orb usage on the Organization Settings  Security page for your org.  The orbs page in the CircleCI web app is not currently available on CircleCI server.  Private orb details pages may only be viewed by logged-in members of your organization. Unpublished orbs will not have linked details pages.\n\n\n\nUsing contexts1 week ago16 min readCloudServer v4+On This PageOverviewQuickstart: Create and use a contextContexts and environment variable constraintsContext naming for CircleCI serverCombine contextsRestrict a contextRun workflows with a restricted contextApprove jobs that use restricted contextsDelete a contextSecurity group restrictionsRestrict a context to a security group or groupsMake changes to security group context restrictionsRemove groups from contextsAdd and remove users from teams and groupsAdd and remove environment variables from restricted contextsProject restrictionsRun workflows with a project restricted contextRestrict a context to a projectRemove project restrictions from contextsExpression restrictionsSet an expression restrictionExamplesVariablesErrorsOperatorsPrecedenceLiteralsNumbersStringsBooleansEvaluationContext management with the CLIEnvironment variable usageAdd an environment variable to a contextRemove an environment variable from a contextRotate environment variables with the CLI or APISecrets maskingSee also   Contexts provide a mechanism for securing and sharing environment variables across projects. The environment variables are defined as name/value pairs and are injected at runtime. This document describes creating and using contexts in CircleCI.   If you have existing contexts (or environment variables) and you would like to rename your organization or repository, follow the  Rename organizations and repositories guide to make sure you do not lose access to contexts or environment variables in the process.     Overview   Manage contexts on the Organization Settings page of the  CircleCI web app, or via the  API. You must be an organization member to view, create, or edit contexts.   Create a context and then add environment variables to it. You can use the  context key in the workflows section of a project’s .circleci/config.yml file to give any job(s) access to the environment variables associated with the context, as shown in the image below.        To use environment variables set within a context, the person running the workflow must be a member of the organization for which the context is set.      Context names must be unique for each VCS organization. The default name for a context is org-global. Contexts created with the initial default name of org-global will continue to work.          Quickstart: Create and use a context     Using the CircleCI web app, select Organization Settings  Contexts on the left side navigation.  Be aware that organization members can create contexts, but only organization administrators can restrict them using security groups. The one exception to this case is Bitbucket organizations, which require a user to have the create repositories workspace permission, regardless of their other permissions on the workspace or the repositories it contains.         Select Create Context, add a unique name for your context and select Create Context in the modal to finalize. The new context will appear in a list with security set to All members to show that anyone in your organization can access this context at runtime.   You can now select any context created in your list to add environment variables. Once you have a context selected, select Add Environment Variable to enter the variable name and value. Select Add Environment Variable in the modal to finalize.   To allow a job to access the environment variables stored in a context, add a context key to that job’s entry in the  workflows section of the .circleci/config.yml file. For example, in the following example, the run-tests job has access to the environment variables set in the org-global and my-context contexts.   version: 2.1

workflows:
  my-workflow:
    jobs:
      - run-tests:
          context:
            - org-global
            - my-context

jobs:
  run-tests:
    docker:
      - image: cimg/base:2020.01
    steps:
      - checkout
      - run:
          name: "echo environment variables from org-global context"
          command: echo $MY_ENV_VAR          If you move your repository to a new organization, you must also have the context with that unique name set in the new organization.          Contexts and environment variable constraints   When creating contexts and environment variables, note the following:     The context name must be:    200 or fewer characters   Must contain at least one non-whitespace character   Must not contain leading, trailing, or vertical whitespace      The environment variable name must be:    300 or fewer characters   Begin with an alpha (a-z, A-Z) or _ as the first character, and use alphanumeric or _ for the remaining characters      An environment variable value must have 32k or fewer characters.   An empty environment variable is considered valid.   Each context is limited to 100 environment variables.   Each configuration file is limited to 100 contexts.   Each organization is limited to 500 contexts.       Context naming for CircleCI server   For any VCS enterprise installation that includes multiple organizations, the context names across those organizations must be unique. For example, if your GitHub Enterprise installation is named Kiwi and includes two organizations, you cannot add a context called deploy to both organizations. That is, the deploy context name cannot be duplicated in two organizations that exist in the same GitHub Enterprise installation for the Kiwi account. Duplicate contexts within an account will fail with an error.     Combine contexts   You can combine several contexts for a single job by adding them to the context list. Contexts are applied in order, so in the case of overlaps, later contexts override earlier ones. This way, you can scope contexts to be as small and granular as you like.     Restrict a context      Bitbucket repositories do not provide an API that allows CircleCI contexts to be restricted, only GitHub OAuth app accounts support security group restrictions. To find out which GitHub account type you have, refer to the  GitHub OAuth integration page.        CircleCI enables you to restrict contexts at run time in the following ways:     Using security groups   Using project restrictions   Using expression restrictions     Only organization administrators may add restrictions to new or existing contexts.   Security groups are your organization’s VCS teams. After a security group is added to a context, only members of that security group who are also CircleCI users may access the context and use the associated environment variables. The default security group is All members, and enables any member of the organization who uses CircleCI to use the context.   Organization administrators have read/write access to all projects and have unrestricted access to all contexts.   Run workflows with a restricted context  To invoke a job that uses a restricted context, a user must be a member of one of the security groups or projects assigned to the context, or the expressions assigned to the context must be true. If the user running the workflow does not have access to the context or an expression evaluates to false, the workflow will fail with the Unauthorized status.    Approve jobs that use restricted contexts  Adding an  approval job to a workflow gives the option to require manual approval of the use of a restricted context. To restrict running of jobs that are downstream from an approval job, add a restricted context to those downstream jobs, as shown in the example below:    version: 2.1

# Jobs declaration for build, test and deploy not displayed

workflows:
  build-test-deploy:
    jobs:
      - build
      - test:
          context: my-restricted-context
          requires:
            - build
      - hold:
          type: approval # presents manual approval button in the UI
          requires:
            - build
      - deploy:
          context: deploy-key-restricted-context
          requires:
            - build
            - hold
            - test    In this example, the jobs test and deploy are restricted, and deploy will only run if the user who approves the hold job is a member of the security group assigned to the context and deploy-key-restricted-context. When the workflow build-test-deploy runs, the jobs build and test will run, then the hold job will run, which will present a manual approval button in the CircleCI application. This approval job may be approved by any member of the project, but the deploy job will fail as unauthorized if the approver is not part of the restricted context security group.    Delete a context  If the context is restricted with a group other than All members, you must be a member of that security group to complete this task. To delete a context, follow the steps below:     Navigate to the Organization Settings  Contexts in the CircleCI web app.   Select the X icon in the row of the context you want to delete. A confirmation dialog box will appear.   Type "DELETE" in the field and then select Delete Context. The context and all associated environment variables will be deleted.        If a deleted context is used in a job, the job will fail and show an error.           Security group restrictions   Restrict a context to a security group or groups     To use security group context restrictions you must be an organization administrator, and your code must be integrated with CircleCI via the GitHub OAuth app.          Navigate to Organization Settings  Contexts in the CircleCI web app to see the list of contexts. The default security group is All members, and allows all users in the organization to invoke jobs with that context.   Select Create Context if you wish to use a new context, or select the name of an existing context (if using an existing context, you will need to remove the All members security group before adding a new one).   Select Add Security Group button to view the dialog box.   Make your choices in the dialog box and then select the Add Security Group or Add Project Restriction button to finalize. Contexts will now be restricted to the selections you have made.   Select Add Environment Variables to add environment variables to the context if none exist, fill out your desired name and value in the dialogue box, then select the Add Environment Variables button to finalize. Use of the environment variables for this context is now limited to members of the security groups.   Navigate back to Organization Settings  Contexts in the CircleCI app. The security groups appear in the Security column for the context.     Only members of the selected groups may now use the context in their workflows or add or remove environment variables for the context.    Make changes to security group context restrictions  Changes to security group restrictions for contexts might not take effect immediately due to caching. To make sure settings are applied immediately, it is best practice for the organization administrator to refresh permissions once the change has been made. The Refresh Permissions button can be found on the  Account Integrations page.   Administrators of CircleCI server installations can find the Refresh Permissions button at <circleci-hostname>/account.    Remove groups from contexts  To make a context available only to the administrators of the organization, you may remove all of the groups associated with a context. All other users will lose access to that context.    Add and remove users from teams and groups  GitHub OAuth app users: CircleCI syncs GitHub team and LDAP groups every few hours. If a user is added or removed from a GitHub team or LDAP group, it can take up to a few hours to update the CircleCI records and remove access to the context.    Add and remove environment variables from restricted contexts  Addition and deletion of environment variables from a restricted context is limited to members of the context groups.      Project restrictions   CircleCI enables you to restrict secret environment variables by adding project restrictions to contexts. Only  organization admins may add or remove project restrictions to a new or existing context. After a project restriction is added to a context, only workflows associated with the specified project(s) will have access to the context and its environment variables.      API support for project restricted contexts is coming soon.        Organization Admins have read/write access to all projects, and have unrestricted access to all contexts.   Run workflows with a project restricted context  To invoke a workflow that uses a restricted context, the workflow must be part of the project the context is restricted to. If the workflow does not have access to the context, the workflow will fail with the Unauthorized status.    Restrict a context to a project  You must be an organization admin to restrict a context though the method detailed below.     Navigate to the Organization Settings  Contexts page of your organization in the  CircleCI web app. The list of contexts will be visible.   Select the name of an existing context, or select Create Context if you want to use a new context.   Select Add Project Restriction to view the dialog box.   Select the project name to add to the context, and select Add. Use of the context is now limited to the specified project. Currently, multiple projects must be added individually.   You should now see a list of the defined project restrictions on the context page.   If you have environment variables, they should appear on the page. If there are none, you can select Add Environment Variables to add them to the context. Then select Add to finish. Use of the environment variables for this context is now limited to the specified projects.     Only workflows under the specified projects may now use the context and its environment variables.    Remove project restrictions from contexts  You must be an organization admin to remove projects from contexts though the method detailed below.     Navigate to Organization Settings  Contexts page in the  CircleCI web app. The list of contexts will be visible.   Select the name of the existing context for which you would like to modify restrictions.   Select X next to the project restriction you would like to remove. The project restriction will be removed for the context.   If there are no longer any project restrictions for the context, the context and its environment variables are now effectively unrestricted.        Expression restrictions   Restrict contexts by setting up expression restrictions. Expression restrictions are rules that  pipeline values must match. Using expression restrictions allows you to create arbitrary constraints on the circumstances in which a context is available for use. For example, you may have a context containing credentials that should only be used for deploying your code from your protected main branch:    pipeline.git.branch == "main" and not job.ssh.enabled and not (pipeline.config_source starts-with "api"")    Tabs and new lines are considered whitespace so can be used to break long lines, but have no other significance. For example, the snippet above could also be written:    pipeline.git.branch == "main"
and not job.ssh.enabled
and not (pipeline.config_source starts-with "api")    You can set up expression restrictions using the context restriction API, or via the Context page (Organization Settings  Contexts  Expression Restrictions) in the CircleCI web app.   Rules are expressed in a small language that supports equality checks, numeric comparisons, and boolean and, or, and not operators.   Set an expression restriction     You must be an organization administrator to set an expression restriction.        Follow these steps to set an expression restriction on a context:  CircleCI UIAPI     Navigate to the Organization Settings  Contexts page of your organization in the  CircleCI web app   Select the context you want to add an expression restriction to   Select Add Expression Restriction   Enter your expression in the text box and select Add Expression Restriction again to confirm           Using server? If you are using CircleCI server, replace https://circleci.com with your server hostname when interacting with the CircleCI API.          Set up your API authentication. Steps are available in the  API developers guide.   You are going to need your organization ID. In the  CircleCI web app select Organization Settings in the sidebar and copy your "Organization ID" somewhere safe.   To get the ID for your context, list your contexts, as follows, substituting your organization ID:   curl --request GET \
  --url 'https://circleci.com/api/v2/context?owner-id=<your-org-ID>&page-token=NEXT_PAGE_TOKEN' \
  --header "Circle-Token: ${CIRCLE_TOKEN}" \
  --header "Accept: application/json" \
  --header "Content-Type: application/json" | jq     Copy the ID for your context from the previous API response   Create your context expression restriction, as follows, substituting your context ID and expression restriction:   curl --request POST \
  --url https://circleci.com/api/v2/context/<your-context-ID>/restrictions \
  --header "Circle-Token: ${CIRCLE_TOKEN}" \
  --header 'content-type: application/json' \
  --data '{"restriction_type":"expression","restriction_value":"<your-expression-restriction>"}'           Examples  Allow the context only on the project’s main branch:    pipeline.git.branch == "main"    Allow the context only on the project’s main branch, or branches starting with integration-test:    pipeline.git.branch == "main" or pipeline.git.branch starts-with "integration-test"    Restrict a context to the main branch, disallow use in an SSH rerun, and disallow use with pipelines  triggered with unversioned configuration:    pipeline.git.branch == "main" and not job.ssh.enabled and not (pipeline.config_source starts-with "api")     Variables   Pipeline values can be used as variables in an expression restriction. The exception to this is that pipeline.trigger_parameters.* pipeline values cannot be used.  Pipeline parameters cannot be used in expression restrictions.   Job-specific variables are also available to use in expressions, as follows:  nametypedescriptionjob.ssh.enabledbooleantrue if SSH is enabled for the job, false otherwise  If an expression references a variable that has no value set in the pipeline, the expression will fail closed and prevent use of the context.    Errors  Any errors evaluating an expression will fail closed and prevent use of the context. Errors include the following:     Using a variable that does not exist   Using a non-numeric value as an operand to the numeric comparison operators   Using a non-string value as an operand to the starts-with operator      Operators  The operators you can use are described in the following table. You can also group sub-expressions with parentheses (, ). as in the example above.  Operator typeOperatorsDescriptionLogicaland, orThese are short-circuiting boolean operators.Equality==, !=String, numeric, and boolean equality. If the operands are of different types then == will evaluate false, and != will evaluate true.Equalitystarts-withString prefix equality, "hello world" starts-with "hello" evaluates as true. It is an error to use a non-string type as an operand.Numeric comparison>=, >, ⇐, <Numeric comparisons. It is an error to use a non-numeric type as an operand.Negationnot Boolean negation.   Note that not has very high precedence and so binds very tightly. Use sub-expressions to apply not to more complex expressions. For example, with foo being true and bar being false:     not foo and bar evaluates to false   not (foo and bar) evaluates to true      Precedence  The following table shows operator precedence table, from weakest to strongest binding.      All operators are left associative. In practice, you should avoid operator chaining for anything other than and or or. This is because evaluation may cause type mismatches for other operators (see  Evaluation).       OperatorAssociativityorleftandleft== !=leftstarts-with>= > ⇐ <leftnot !   Literals  Numbers  Numeric literals are whole integers (longs). For example, 1 or 768.    Strings  String literals are enclosed within double-quotes " ". The \ character is used to escape an embedded quote, or to escape an embedded \.   For example, "the quick brown fox", "You can embed \" and \\ characters"    Booleans  The boolean literals are true and false.     Evaluation  An expression is evaluated to produce a single boolean true or false value.   Other than the boolean value false, all values ultimately evaluate as true.   A variable evaluates to the variable’s value. If the variable does not exist then the expression is immediately considered to have evaluated as false. In other words, expression evaluation will fail closed when it encounters an unknown variable.   As an expression is evaluated, the result of an operator is effectively embedded "in place" as the evaluation continues. For example, to evaluate the following:    pipeline.git.branch == "main"
and not job.ssh.enabled
and not (pipeline.config_source starts-with "api")    where the values are:     pipeline.git.branch is "main"   job.ssh.enabled is false   pipeline.config_source is "api"    Variable lookup: replace pipeline.git.branch with its value:    "main" == "main" and not job.ssh.enabled and not (pipeline.config_source starts-with "api")      Evaluate "main" == "main":    true and not job.ssh.enabled and not (pipeline.config_source starts-with "api")      Variable lookup: replace job.ssh.enabled with its value:    true and not false and not (pipeline.config_source starts-with "api")      Evaluate not false:    true and true and not (pipeline.config_source starts-with "api")      Evaluate true and true:    true and not (pipeline.config_source starts-with "api")      Variable lookup: replace pipeline.config_source with its value:    true and not ("api" starts-with "api")      Evaluate ("api" starts-with "api")    true and not true      Evaluate not true:    true and false      Evaluate true and false:    false      The result is false           Context management with the CLI      Before using the CLI ensure you have  configured the CLI with a token.        You can use the  CircleCI CLI to manage contexts, as an alternative to the web app and the API. With the CLI, you can execute several  context-oriented commands.     create - Create a new context   delete - Delete a named context   list - List all contexts   remove-secret - Remove an environment variable from the named context   show - Show a context   store-secret - Store a new environment variable in the named context     The above list are "sub-commands" in the CLI, which would be executed like so:    circleci context create --org-id <org-id> <context-name> [flags]    Refer to the  CLI docs for full details for each command. Many commands require that you include additional information as indicated by parameters delimited by < >. For example, when running circleci context create, you will need to provide a name for the context and your org ID.       To find your organization/user ID, select Organization Settings in the CircleCI web app side bar.              Environment variable usage   Environment variables are used according to a specific precedence order, as follows:     Environment variables declared  inside a shell command in a run step, for example FOO=bar make install.   Environment variables declared with the environment key  for a run step   Environment variables set with the environment key  for a job.   Special CircleCI environment variables defined on the  Project values and variables page.   Context environment variables (assuming the user has access to the context).    Project-level environment variables set on the Project Settings page in the web app.     Environment variables declared inside a shell command run step, for example FOO=bar make install, will override environment variables declared with the environment and contexts keys. Environment variables added on the contexts page will take precedence over variables added on the Project Settings page.   Add an environment variable to a context CLIAPI      Before using the CLI ensure you have  configured the CLI with a token.        To create an environment variable using our CLI, perform the following steps:     If you have not already done so, find the right context name that will contain the new environment variable by executing this command:   circleci context list --org-id <org-id>     Store a new environment variable under that context by executing this command:   circleci context store-secret --org-id <org-id> <context-name> <environment-variable-name>    The CLI will prompt you to input the secret value, rather than accepting it as an argument. This approach is designed to avoid unintentional secret exposure.         To create an environment variable using the API, call the  Add Environment Variable endpoint with the appropriate request body. For this request, replace the context-id and the env-var-name with the ID for the context and the new environment variable name. The request body should include a value key containing the plain text secret as a string.       Remove an environment variable from a context  Removing an environment variable from a context deletes the environment variable from your account.  CLIAPI      Before using the CLI ensure you have  configured the CLI with a token.        To remove an environment variable from a context using the CLI, perform the following steps:     If you have not already done so, find the context name that contains the environment variable you wish to delete by executing this command:   circleci context list --org-id <org-id>     Confirm the environment variable exists within that context. To list all variables under that context, execute this command:   circleci context show --org-id <org-id> <context-name>     Delete the environment variable by executing this command:   circleci context remove-secret --org-id <org-id> <context-name> <secret name>          To delete an environment variable using the API, call the  Delete environment variable endpoint.   For this request, replace the context-id and the env-var-name with the ID for the context and the environment variable name that should be updated.       Rotate environment variables with the CLI or API  Rotation refers to the process of updating a secret’s value without deleting it or changing its name.   Because environment variables can be shared, passed around between employees and teams, and exposed inadvertently, it is good practice to periodically rotate secrets. You can automate this process, for example, running a script when an employee leaves the company, or when a secret may have been compromised.   Context environment variables can be rotated using CircleCI’s CLI or API.  CLIAPI      Before using the CLI ensure you have  configured the CLI with a token.        To rotate an environment variable using the CLI, perform the following steps:     If you have not already done so, find the context name that contains the variable you would like to rotate by executing this command:   circleci context list --org-id <org-id>     Find the environment variable to rotate within that context by executing this command:   circleci context show --org-id <org-id> <context-name>     Update the existing environment variable under that context. Execute this command and replace the <env-var-name> with the name of the environment variable you chose in Step 2:   circleci context store-secret --org-id <org-id> <context-name> <env-var-name>    Note that the CLI will prompt you to input the new secret value, rather than accepting it as an argument. This approach is designed to avoid unintentional secret exposure.         To rotate an environment variable from the API, call the  Update environment variable endpoint with the appropriate request body. For this request, replace the context-id and the env-var-name with the ID for the context and the environment variable name that should be updated. The request body should include a value key containing the plain text secret as a string.         Secrets masking   Environment variables and contexts may hold project secrets or keys that perform crucial functions for your applications. Secrets masking provides added security within CircleCI by obscuring environment variables in the job output when echo or print is used.   Secrets masking is applied to environment variables set within Project Settings or Contexts in the web app.   The value of the environment variable or context will not be masked in the job output if:     the value of the environment variable is less than 4 characters   the value of the environment variable is equal to one of true, True, false, or False        Secrets masking will only prevent values from appearing in your job output. Invoking a bash shell with the -x or -o xtrace options may inadvertently log unmasked secrets (refer to  Using shell scripts). If your secrets appear elsewhere, such as test results or artifacts, they will not be masked. Additionally, values are still accessible to users  debugging builds with SSH.           The secrets masking feature exists as a preventative measure to catch unintentional display of secrets at the output. Best practice is to avoid printing secrets to the output. The are many ways that secrets masking could be bypassed, either accidentally or maliciously. For example, any process that reformats the output of a command or script could remove secrets masking.          See also      Introduction to environment variables    Using workflows to orchestrate jobs     Suggest an edit to this pageMake a contribution Learn how to contributeStill need help? Ask the CircleCI community Join the research community Visit our Support site\n\nUsing contexts1 week ago16 min readCloudServer v4+On This PageOverviewQuickstart: Create and use a contextContexts and environment variable constraintsContext naming for CircleCI serverCombine contextsRestrict a contextRun workflows with a restricted contextApprove jobs that use restricted contextsDelete a contextSecurity group restrictionsRestrict a context to a security group or groupsMake changes to security group context restrictionsRemove groups from contextsAdd and remove users from teams and groupsAdd and remove environment variables from restricted contextsProject restrictionsRun workflows with a project restricted contextRestrict a context to a projectRemove project restrictions from contextsExpression restrictionsSet an expression restrictionExamplesVariablesErrorsOperatorsPrecedenceLiteralsNumbersStringsBooleansEvaluationContext management with the CLIEnvironment variable usageAdd an environment variable to a contextRemove an environment variable from a contextRotate environment variables with the CLI or APISecrets maskingSee also   Contexts provide a mechanism for securing and sharing environment variables across projects. The environment variables are defined as name/value pairs and are injected at runtime. This document describes creating and using contexts in CircleCI.   If you have existing contexts (or environment variables) and you would like to rename your organization or repository, follow the  Rename organizations and repositories guide to make sure you do not lose access to contexts or environment variables in the process.     Overview   Manage contexts on the Organization Settings page of the  CircleCI web app, or via the  API. You must be an organization member to view, create, or edit contexts.   Create a context and then add environment variables to it. You can use the  context key in the workflows section of a project’s .circleci/config.yml file to give any job(s) access to the environment variables associated with the context, as shown in the image below.        To use environment variables set within a context, the person running the workflow must be a member of the organization for which the context is set.      Context names must be unique for each VCS organization. The default name for a context is org-global. Contexts created with the initial default name of org-global will continue to work.          Quickstart: Create and use a context     Using the CircleCI web app, select Organization Settings  Contexts on the left side navigation.  Be aware that organization members can create contexts, but only organization administrators can restrict them using security groups. The one exception to this case is Bitbucket organizations, which require a user to have the create repositories workspace permission, regardless of their other permissions on the workspace or the repositories it contains.         Select Create Context, add a unique name for your context and select Create Context in the modal to finalize. The new context will appear in a list with security set to All members to show that anyone in your organization can access this context at runtime.   You can now select any context created in your list to add environment variables. Once you have a context selected, select Add Environment Variable to enter the variable name and value. Select Add Environment Variable in the modal to finalize.   To allow a job to access the environment variables stored in a context, add a context key to that job’s entry in the  workflows section of the .circleci/config.yml file. For example, in the following example, the run-tests job has access to the environment variables set in the org-global and my-context contexts.   version: 2.1

workflows:
  my-workflow:
    jobs:
      - run-tests:
          context:
            - org-global
            - my-context

jobs:
  run-tests:
    docker:
      - image: cimg/base:2020.01
    steps:
      - checkout
      - run:
          name: "echo environment variables from org-global context"
          command: echo $MY_ENV_VAR          If you move your repository to a new organization, you must also have the context with that unique name set in the new organization.          Contexts and environment variable constraints   When creating contexts and environment variables, note the following:     The context name must be:    200 or fewer characters   Must contain at least one non-whitespace character   Must not contain leading, trailing, or vertical whitespace      The environment variable name must be:    300 or fewer characters   Begin with an alpha (a-z, A-Z) or _ as the first character, and use alphanumeric or _ for the remaining characters      An environment variable value must have 32k or fewer characters.   An empty environment variable is considered valid.   Each context is limited to 100 environment variables.   Each configuration file is limited to 100 contexts.   Each organization is limited to 500 contexts.       Context naming for CircleCI server   For any VCS enterprise installation that includes multiple organizations, the context names across those organizations must be unique. For example, if your GitHub Enterprise installation is named Kiwi and includes two organizations, you cannot add a context called deploy to both organizations. That is, the deploy context name cannot be duplicated in two organizations that exist in the same GitHub Enterprise installation for the Kiwi account. Duplicate contexts within an account will fail with an error.     Combine contexts   You can combine several contexts for a single job by adding them to the context list. Contexts are applied in order, so in the case of overlaps, later contexts override earlier ones. This way, you can scope contexts to be as small and granular as you like.     Restrict a context      Bitbucket repositories do not provide an API that allows CircleCI contexts to be restricted, only GitHub OAuth app accounts support security group restrictions. To find out which GitHub account type you have, refer to the  GitHub OAuth integration page.        CircleCI enables you to restrict contexts at run time in the following ways:     Using security groups   Using project restrictions   Using expression restrictions     Only organization administrators may add restrictions to new or existing contexts.   Security groups are your organization’s VCS teams. After a security group is added to a context, only members of that security group who are also CircleCI users may access the context and use the associated environment variables. The default security group is All members, and enables any member of the organization who uses CircleCI to use the context.   Organization administrators have read/write access to all projects and have unrestricted access to all contexts.   Run workflows with a restricted context  To invoke a job that uses a restricted context, a user must be a member of one of the security groups or projects assigned to the context, or the expressions assigned to the context must be true. If the user running the workflow does not have access to the context or an expression evaluates to false, the workflow will fail with the Unauthorized status.    Approve jobs that use restricted contexts  Adding an  approval job to a workflow gives the option to require manual approval of the use of a restricted context. To restrict running of jobs that are downstream from an approval job, add a restricted context to those downstream jobs, as shown in the example below:    version: 2.1

# Jobs declaration for build, test and deploy not displayed

workflows:
  build-test-deploy:
    jobs:
      - build
      - test:
          context: my-restricted-context
          requires:
            - build
      - hold:
          type: approval # presents manual approval button in the UI
          requires:
            - build
      - deploy:
          context: deploy-key-restricted-context
          requires:
            - build
            - hold
            - test    In this example, the jobs test and deploy are restricted, and deploy will only run if the user who approves the hold job is a member of the security group assigned to the context and deploy-key-restricted-context. When the workflow build-test-deploy runs, the jobs build and test will run, then the hold job will run, which will present a manual approval button in the CircleCI application. This approval job may be approved by any member of the project, but the deploy job will fail as unauthorized if the approver is not part of the restricted context security group.    Delete a context  If the context is restricted with a group other than All members, you must be a member of that security group to complete this task. To delete a context, follow the steps below:     Navigate to the Organization Settings  Contexts in the CircleCI web app.   Select the X icon in the row of the context you want to delete. A confirmation dialog box will appear.   Type "DELETE" in the field and then select Delete Context. The context and all associated environment variables will be deleted.        If a deleted context is used in a job, the job will fail and show an error.           Security group restrictions   Restrict a context to a security group or groups     To use security group context restrictions you must be an organization administrator, and your code must be integrated with CircleCI via the GitHub OAuth app.          Navigate to Organization Settings  Contexts in the CircleCI web app to see the list of contexts. The default security group is All members, and allows all users in the organization to invoke jobs with that context.   Select Create Context if you wish to use a new context, or select the name of an existing context (if using an existing context, you will need to remove the All members security group before adding a new one).   Select Add Security Group button to view the dialog box.   Make your choices in the dialog box and then select the Add Security Group or Add Project Restriction button to finalize. Contexts will now be restricted to the selections you have made.   Select Add Environment Variables to add environment variables to the context if none exist, fill out your desired name and value in the dialogue box, then select the Add Environment Variables button to finalize. Use of the environment variables for this context is now limited to members of the security groups.   Navigate back to Organization Settings  Contexts in the CircleCI app. The security groups appear in the Security column for the context.     Only members of the selected groups may now use the context in their workflows or add or remove environment variables for the context.    Make changes to security group context restrictions  Changes to security group restrictions for contexts might not take effect immediately due to caching. To make sure settings are applied immediately, it is best practice for the organization administrator to refresh permissions once the change has been made. The Refresh Permissions button can be found on the  Account Integrations page.   Administrators of CircleCI server installations can find the Refresh Permissions button at <circleci-hostname>/account.    Remove groups from contexts  To make a context available only to the administrators of the organization, you may remove all of the groups associated with a context. All other users will lose access to that context.    Add and remove users from teams and groups  GitHub OAuth app users: CircleCI syncs GitHub team and LDAP groups every few hours. If a user is added or removed from a GitHub team or LDAP group, it can take up to a few hours to update the CircleCI records and remove access to the context.    Add and remove environment variables from restricted contexts  Addition and deletion of environment variables from a restricted context is limited to members of the context groups.      Project restrictions   CircleCI enables you to restrict secret environment variables by adding project restrictions to contexts. Only  organization admins may add or remove project restrictions to a new or existing context. After a project restriction is added to a context, only workflows associated with the specified project(s) will have access to the context and its environment variables.      API support for project restricted contexts is coming soon.        Organization Admins have read/write access to all projects, and have unrestricted access to all contexts.   Run workflows with a project restricted context  To invoke a workflow that uses a restricted context, the workflow must be part of the project the context is restricted to. If the workflow does not have access to the context, the workflow will fail with the Unauthorized status.    Restrict a context to a project  You must be an organization admin to restrict a context though the method detailed below.     Navigate to the Organization Settings  Contexts page of your organization in the  CircleCI web app. The list of contexts will be visible.   Select the name of an existing context, or select Create Context if you want to use a new context.   Select Add Project Restriction to view the dialog box.   Select the project name to add to the context, and select Add. Use of the context is now limited to the specified project. Currently, multiple projects must be added individually.   You should now see a list of the defined project restrictions on the context page.   If you have environment variables, they should appear on the page. If there are none, you can select Add Environment Variables to add them to the context. Then select Add to finish. Use of the environment variables for this context is now limited to the specified projects.     Only workflows under the specified projects may now use the context and its environment variables.    Remove project restrictions from contexts  You must be an organization admin to remove projects from contexts though the method detailed below.     Navigate to Organization Settings  Contexts page in the  CircleCI web app. The list of contexts will be visible.   Select the name of the existing context for which you would like to modify restrictions.   Select X next to the project restriction you would like to remove. The project restriction will be removed for the context.   If there are no longer any project restrictions for the context, the context and its environment variables are now effectively unrestricted.        Expression restrictions   Restrict contexts by setting up expression restrictions. Expression restrictions are rules that  pipeline values must match. Using expression restrictions allows you to create arbitrary constraints on the circumstances in which a context is available for use. For example, you may have a context containing credentials that should only be used for deploying your code from your protected main branch:    pipeline.git.branch == "main" and not job.ssh.enabled and not (pipeline.config_source starts-with "api"")    Tabs and new lines are considered whitespace so can be used to break long lines, but have no other significance. For example, the snippet above could also be written:    pipeline.git.branch == "main"
and not job.ssh.enabled
and not (pipeline.config_source starts-with "api")    You can set up expression restrictions using the context restriction API, or via the Context page (Organization Settings  Contexts  Expression Restrictions) in the CircleCI web app.   Rules are expressed in a small language that supports equality checks, numeric comparisons, and boolean and, or, and not operators.   Set an expression restriction     You must be an organization administrator to set an expression restriction.        Follow these steps to set an expression restriction on a context:  CircleCI UIAPI     Navigate to the Organization Settings  Contexts page of your organization in the  CircleCI web app   Select the context you want to add an expression restriction to   Select Add Expression Restriction   Enter your expression in the text box and select Add Expression Restriction again to confirm           Using server? If you are using CircleCI server, replace https://circleci.com with your server hostname when interacting with the CircleCI API.          Set up your API authentication. Steps are available in the  API developers guide.   You are going to need your organization ID. In the  CircleCI web app select Organization Settings in the sidebar and copy your "Organization ID" somewhere safe.   To get the ID for your context, list your contexts, as follows, substituting your organization ID:   curl --request GET \
  --url 'https://circleci.com/api/v2/context?owner-id=<your-org-ID>&page-token=NEXT_PAGE_TOKEN' \
  --header "Circle-Token: ${CIRCLE_TOKEN}" \
  --header "Accept: application/json" \
  --header "Content-Type: application/json" | jq     Copy the ID for your context from the previous API response   Create your context expression restriction, as follows, substituting your context ID and expression restriction:   curl --request POST \
  --url https://circleci.com/api/v2/context/<your-context-ID>/restrictions \
  --header "Circle-Token: ${CIRCLE_TOKEN}" \
  --header 'content-type: application/json' \
  --data '{"restriction_type":"expression","restriction_value":"<your-expression-restriction>"}'           Examples  Allow the context only on the project’s main branch:    pipeline.git.branch == "main"    Allow the context only on the project’s main branch, or branches starting with integration-test:    pipeline.git.branch == "main" or pipeline.git.branch starts-with "integration-test"    Restrict a context to the main branch, disallow use in an SSH rerun, and disallow use with pipelines  triggered with unversioned configuration:    pipeline.git.branch == "main" and not job.ssh.enabled and not (pipeline.config_source starts-with "api")     Variables   Pipeline values can be used as variables in an expression restriction. The exception to this is that pipeline.trigger_parameters.* pipeline values cannot be used.  Pipeline parameters cannot be used in expression restrictions.   Job-specific variables are also available to use in expressions, as follows:  nametypedescriptionjob.ssh.enabledbooleantrue if SSH is enabled for the job, false otherwise  If an expression references a variable that has no value set in the pipeline, the expression will fail closed and prevent use of the context.    Errors  Any errors evaluating an expression will fail closed and prevent use of the context. Errors include the following:     Using a variable that does not exist   Using a non-numeric value as an operand to the numeric comparison operators   Using a non-string value as an operand to the starts-with operator      Operators  The operators you can use are described in the following table. You can also group sub-expressions with parentheses (, ). as in the example above.  Operator typeOperatorsDescriptionLogicaland, orThese are short-circuiting boolean operators.Equality==, !=String, numeric, and boolean equality. If the operands are of different types then == will evaluate false, and != will evaluate true.Equalitystarts-withString prefix equality, "hello world" starts-with "hello" evaluates as true. It is an error to use a non-string type as an operand.Numeric comparison>=, >, ⇐, <Numeric comparisons. It is an error to use a non-numeric type as an operand.Negationnot Boolean negation.   Note that not has very high precedence and so binds very tightly. Use sub-expressions to apply not to more complex expressions. For example, with foo being true and bar being false:     not foo and bar evaluates to false   not (foo and bar) evaluates to true      Precedence  The following table shows operator precedence table, from weakest to strongest binding.      All operators are left associative. In practice, you should avoid operator chaining for anything other than and or or. This is because evaluation may cause type mismatches for other operators (see  Evaluation).       OperatorAssociativityorleftandleft== !=leftstarts-with>= > ⇐ <leftnot !   Literals  Numbers  Numeric literals are whole integers (longs). For example, 1 or 768.    Strings  String literals are enclosed within double-quotes " ". The \ character is used to escape an embedded quote, or to escape an embedded \.   For example, "the quick brown fox", "You can embed \" and \\ characters"    Booleans  The boolean literals are true and false.     Evaluation  An expression is evaluated to produce a single boolean true or false value.   Other than the boolean value false, all values ultimately evaluate as true.   A variable evaluates to the variable’s value. If the variable does not exist then the expression is immediately considered to have evaluated as false. In other words, expression evaluation will fail closed when it encounters an unknown variable.   As an expression is evaluated, the result of an operator is effectively embedded "in place" as the evaluation continues. For example, to evaluate the following:    pipeline.git.branch == "main"
and not job.ssh.enabled
and not (pipeline.config_source starts-with "api")    where the values are:     pipeline.git.branch is "main"   job.ssh.enabled is false   pipeline.config_source is "api"    Variable lookup: replace pipeline.git.branch with its value:    "main" == "main" and not job.ssh.enabled and not (pipeline.config_source starts-with "api")      Evaluate "main" == "main":    true and not job.ssh.enabled and not (pipeline.config_source starts-with "api")      Variable lookup: replace job.ssh.enabled with its value:    true and not false and not (pipeline.config_source starts-with "api")      Evaluate not false:    true and true and not (pipeline.config_source starts-with "api")      Evaluate true and true:    true and not (pipeline.config_source starts-with "api")      Variable lookup: replace pipeline.config_source with its value:    true and not ("api" starts-with "api")      Evaluate ("api" starts-with "api")    true and not true      Evaluate not true:    true and false      Evaluate true and false:    false      The result is false           Context management with the CLI      Before using the CLI ensure you have  configured the CLI with a token.        You can use the  CircleCI CLI to manage contexts, as an alternative to the web app and the API. With the CLI, you can execute several  context-oriented commands.     create - Create a new context   delete - Delete a named context   list - List all contexts   remove-secret - Remove an environment variable from the named context   show - Show a context   store-secret - Store a new environment variable in the named context     The above list are "sub-commands" in the CLI, which would be executed like so:    circleci context create --org-id <org-id> <context-name> [flags]    Refer to the  CLI docs for full details for each command. Many commands require that you include additional information as indicated by parameters delimited by < >. For example, when running circleci context create, you will need to provide a name for the context and your org ID.       To find your organization/user ID, select Organization Settings in the CircleCI web app side bar.              Environment variable usage   Environment variables are used according to a specific precedence order, as follows:     Environment variables declared  inside a shell command in a run step, for example FOO=bar make install.   Environment variables declared with the environment key  for a run step   Environment variables set with the environment key  for a job.   Special CircleCI environment variables defined on the  Project values and variables page.   Context environment variables (assuming the user has access to the context).    Project-level environment variables set on the Project Settings page in the web app.     Environment variables declared inside a shell command run step, for example FOO=bar make install, will override environment variables declared with the environment and contexts keys. Environment variables added on the contexts page will take precedence over variables added on the Project Settings page.   Add an environment variable to a context CLIAPI      Before using the CLI ensure you have  configured the CLI with a token.        To create an environment variable using our CLI, perform the following steps:     If you have not already done so, find the right context name that will contain the new environment variable by executing this command:   circleci context list --org-id <org-id>     Store a new environment variable under that context by executing this command:   circleci context store-secret --org-id <org-id> <context-name> <environment-variable-name>    The CLI will prompt you to input the secret value, rather than accepting it as an argument. This approach is designed to avoid unintentional secret exposure.         To create an environment variable using the API, call the  Add Environment Variable endpoint with the appropriate request body. For this request, replace the context-id and the env-var-name with the ID for the context and the new environment variable name. The request body should include a value key containing the plain text secret as a string.       Remove an environment variable from a context  Removing an environment variable from a context deletes the environment variable from your account.  CLIAPI      Before using the CLI ensure you have  configured the CLI with a token.        To remove an environment variable from a context using the CLI, perform the following steps:     If you have not already done so, find the context name that contains the environment variable you wish to delete by executing this command:   circleci context list --org-id <org-id>     Confirm the environment variable exists within that context. To list all variables under that context, execute this command:   circleci context show --org-id <org-id> <context-name>     Delete the environment variable by executing this command:   circleci context remove-secret --org-id <org-id> <context-name> <secret name>          To delete an environment variable using the API, call the  Delete environment variable endpoint.   For this request, replace the context-id and the env-var-name with the ID for the context and the environment variable name that should be updated.       Rotate environment variables with the CLI or API  Rotation refers to the process of updating a secret’s value without deleting it or changing its name.   Because environment variables can be shared, passed around between employees and teams, and exposed inadvertently, it is good practice to periodically rotate secrets. You can automate this process, for example, running a script when an employee leaves the company, or when a secret may have been compromised.   Context environment variables can be rotated using CircleCI’s CLI or API.  CLIAPI      Before using the CLI ensure you have  configured the CLI with a token.        To rotate an environment variable using the CLI, perform the following steps:     If you have not already done so, find the context name that contains the variable you would like to rotate by executing this command:   circleci context list --org-id <org-id>     Find the environment variable to rotate within that context by executing this command:   circleci context show --org-id <org-id> <context-name>     Update the existing environment variable under that context. Execute this command and replace the <env-var-name> with the name of the environment variable you chose in Step 2:   circleci context store-secret --org-id <org-id> <context-name> <env-var-name>    Note that the CLI will prompt you to input the new secret value, rather than accepting it as an argument. This approach is designed to avoid unintentional secret exposure.         To rotate an environment variable from the API, call the  Update environment variable endpoint with the appropriate request body. For this request, replace the context-id and the env-var-name with the ID for the context and the environment variable name that should be updated. The request body should include a value key containing the plain text secret as a string.         Secrets masking   Environment variables and contexts may hold project secrets or keys that perform crucial functions for your applications. Secrets masking provides added security within CircleCI by obscuring environment variables in the job output when echo or print is used.   Secrets masking is applied to environment variables set within Project Settings or Contexts in the web app.   The value of the environment variable or context will not be masked in the job output if:     the value of the environment variable is less than 4 characters   the value of the environment variable is equal to one of true, True, false, or False        Secrets masking will only prevent values from appearing in your job output. Invoking a bash shell with the -x or -o xtrace options may inadvertently log unmasked secrets (refer to  Using shell scripts). If your secrets appear elsewhere, such as test results or artifacts, they will not be masked. Additionally, values are still accessible to users  debugging builds with SSH.           The secrets masking feature exists as a preventative measure to catch unintentional display of secrets at the output. Best practice is to avoid printing secrets to the output. The are many ways that secrets masking could be bypassed, either accidentally or maliciously. For example, any process that reformats the output of a command or script could remove secrets masking.          See also      Introduction to environment variables    Using workflows to orchestrate jobs     Suggest an edit to this pageMake a contribution Learn how to contributeStill need help? Ask the CircleCI community Join the research community Visit our Support site DocsTerms of UsePrivacy PolicyCookie PolicySecurity© 2025 Circle Internet Services, Inc., All Rights Reserved.\n\nContext names must be unique for each VCS organization. The default name for a context is org-global. Contexts created with the initial default name of org-global will continue to work.    version: 2.1

workflows:
  my-workflow:
    jobs:
      - run-tests:
          context:
            - org-global
            - my-context

jobs:
  run-tests:
    docker:
      - image: cimg/base:2020.01
    steps:
      - checkout
      - run:
          name: "echo environment variables from org-global context"
          command: echo $MY_ENV_VAR  If you move your repository to a new organization, you must also have the context with that unique name set in the new organization.  Bitbucket repositories do not provide an API that allows CircleCI contexts to be restricted, only GitHub OAuth app accounts support security group restrictions. To find out which GitHub account type you have, refer to the  GitHub OAuth integration page.  version: 2.1

# Jobs declaration for build, test and deploy not displayed

workflows:
  build-test-deploy:
    jobs:
      - build
      - test:
          context: my-restricted-context
          requires:
            - build
      - hold:
          type: approval # presents manual approval button in the UI
          requires:
            - build
      - deploy:
          context: deploy-key-restricted-context
          requires:
            - build
            - hold
            - test  If a deleted context is used in a job, the job will fail and show an error.  To use security group context restrictions you must be an organization administrator, and your code must be integrated with CircleCI via the GitHub OAuth app.  API support for project restricted contexts is coming soon.  pipeline.git.branch == "main" and not job.ssh.enabled and not (pipeline.config_source starts-with "api"")  pipeline.git.branch == "main"
and not job.ssh.enabled
and not (pipeline.config_source starts-with "api")  You must be an organization administrator to set an expression restriction.     Navigate to the Organization Settings  Contexts page of your organization in the  CircleCI web app   Select the context you want to add an expression restriction to   Select Add Expression Restriction   Enter your expression in the text box and select Add Expression Restriction again to confirm         Using server? If you are using CircleCI server, replace https://circleci.com with your server hostname when interacting with the CircleCI API.          Set up your API authentication. Steps are available in the  API developers guide.   You are going to need your organization ID. In the  CircleCI web app select Organization Settings in the sidebar and copy your "Organization ID" somewhere safe.   To get the ID for your context, list your contexts, as follows, substituting your organization ID:   curl --request GET \
  --url 'https://circleci.com/api/v2/context?owner-id=<your-org-ID>&page-token=NEXT_PAGE_TOKEN' \
  --header "Circle-Token: ${CIRCLE_TOKEN}" \
  --header "Accept: application/json" \
  --header "Content-Type: application/json" | jq     Copy the ID for your context from the previous API response   Create your context expression restriction, as follows, substituting your context ID and expression restriction:   curl --request POST \
  --url https://circleci.com/api/v2/context/<your-context-ID>/restrictions \
  --header "Circle-Token: ${CIRCLE_TOKEN}" \
  --header 'content-type: application/json' \
  --data '{"restriction_type":"expression","restriction_value":"<your-expression-restriction>"}'       Using server? If you are using CircleCI server, replace https://circleci.com with your server hostname when interacting with the CircleCI API.  curl --request GET \
  --url 'https://circleci.com/api/v2/context?owner-id=<your-org-ID>&page-token=NEXT_PAGE_TOKEN' \
  --header "Circle-Token: ${CIRCLE_TOKEN}" \
  --header "Accept: application/json" \
  --header "Content-Type: application/json" | jq  curl --request POST \
  --url https://circleci.com/api/v2/context/<your-context-ID>/restrictions \
  --header "Circle-Token: ${CIRCLE_TOKEN}" \
  --header 'content-type: application/json' \
  --data '{"restriction_type":"expression","restriction_value":"<your-expression-restriction>"}'  pipeline.git.branch == "main"  pipeline.git.branch == "main" or pipeline.git.branch starts-with "integration-test"  pipeline.git.branch == "main" and not job.ssh.enabled and not (pipeline.config_source starts-with "api")  Boolean negation.   Note that not has very high precedence and so binds very tightly. Use sub-expressions to apply not to more complex expressions. For example, with foo being true and bar being false:     not foo and bar evaluates to false   not (foo and bar) evaluates to true    All operators are left associative. In practice, you should avoid operator chaining for anything other than and or or. This is because evaluation may cause type mismatches for other operators (see  Evaluation).  pipeline.git.branch == "main"
and not job.ssh.enabled
and not (pipeline.config_source starts-with "api")  Before using the CLI ensure you have  configured the CLI with a token.  circleci context create --org-id <org-id> <context-name> [flags]   To find your organization/user ID, select Organization Settings in the CircleCI web app side bar.          Before using the CLI ensure you have  configured the CLI with a token.        To create an environment variable using our CLI, perform the following steps:     If you have not already done so, find the right context name that will contain the new environment variable by executing this command:   circleci context list --org-id <org-id>     Store a new environment variable under that context by executing this command:   circleci context store-secret --org-id <org-id> <context-name> <environment-variable-name>    The CLI will prompt you to input the secret value, rather than accepting it as an argument. This approach is designed to avoid unintentional secret exposure.      Before using the CLI ensure you have  configured the CLI with a token.  circleci context list --org-id <org-id>  circleci context store-secret --org-id <org-id> <context-name> <environment-variable-name>   To create an environment variable using the API, call the  Add Environment Variable endpoint with the appropriate request body. For this request, replace the context-id and the env-var-name with the ID for the context and the new environment variable name. The request body should include a value key containing the plain text secret as a string.       Before using the CLI ensure you have  configured the CLI with a token.        To remove an environment variable from a context using the CLI, perform the following steps:     If you have not already done so, find the context name that contains the environment variable you wish to delete by executing this command:   circleci context list --org-id <org-id>     Confirm the environment variable exists within that context. To list all variables under that context, execute this command:   circleci context show --org-id <org-id> <context-name>     Delete the environment variable by executing this command:   circleci context remove-secret --org-id <org-id> <context-name> <secret name>       Before using the CLI ensure you have  configured the CLI with a token.  circleci context list --org-id <org-id>  circleci context show --org-id <org-id> <context-name>  circleci context remove-secret --org-id <org-id> <context-name> <secret name>   To delete an environment variable using the API, call the  Delete environment variable endpoint.   For this request, replace the context-id and the env-var-name with the ID for the context and the environment variable name that should be updated.       Before using the CLI ensure you have  configured the CLI with a token.        To rotate an environment variable using the CLI, perform the following steps:     If you have not already done so, find the context name that contains the variable you would like to rotate by executing this command:   circleci context list --org-id <org-id>     Find the environment variable to rotate within that context by executing this command:   circleci context show --org-id <org-id> <context-name>     Update the existing environment variable under that context. Execute this command and replace the <env-var-name> with the name of the environment variable you chose in Step 2:   circleci context store-secret --org-id <org-id> <context-name> <env-var-name>    Note that the CLI will prompt you to input the new secret value, rather than accepting it as an argument. This approach is designed to avoid unintentional secret exposure.      Before using the CLI ensure you have  configured the CLI with a token.  circleci context list --org-id <org-id>  circleci context show --org-id <org-id> <context-name>  circleci context store-secret --org-id <org-id> <context-name> <env-var-name>   To rotate an environment variable from the API, call the  Update environment variable endpoint with the appropriate request body. For this request, replace the context-id and the env-var-name with the ID for the context and the environment variable name that should be updated. The request body should include a value key containing the plain text secret as a string.   Secrets masking will only prevent values from appearing in your job output. Invoking a bash shell with the -x or -o xtrace options may inadvertently log unmasked secrets (refer to  Using shell scripts). If your secrets appear elsewhere, such as test results or artifacts, they will not be masked. Additionally, values are still accessible to users  debugging builds with SSH.  The secrets masking feature exists as a preventative measure to catch unintentional display of secrets at the output. Best practice is to avoid printing secrets to the output. The are many ways that secrets masking could be bypassed, either accidentally or maliciously. For example, any process that reformats the output of a command or script could remove secrets masking.\n\n\n\nTest splitting and parallelism1 month ago6 min readCloudServer v4+On This PageIntroductionQuickstartSpecify parallel environments for a test jobUse parallelism with self-hosted runnersHow test splitting worksExample using timing-based test splittingThe tests run commandThe tests split commandJUnit XML report formattingManual allocationOther ways to split testsNext steps   Use parallelism and test splitting to:     Reduce the time taken for the testing portion of your CI/CD pipeline.   Specify a number of  executors across which to split your tests.   Split your test suite using one of the options provided by the CircleCI CLI: by name, size or by using timing data.     If you are interested to read about concurrent job runs, see the  Concurrency overview page.     Introduction   Pipelines are often configured so that a set of tests are run each time code is committed. The more tests your project has, the longer it will take for them to complete using a single compute resource. To reduce this time, you can split your tests and run them across multiple, parallel-running execution environments. Test splitting is a great way to speed up the testing portion of your CI/CD pipeline.   CircleCI test splitting lets you intelligently define where splits happen across a test suite:     By name   By size   Using timing data     It is also possible to use the CLI to  manually allocate tests across parallel environments.     Quickstart   The following how-to guide walks you through the steps required to glob your test files, split your tests evenly across parallel containers or VMs, and then run your tests in parallel:     How-to:  Use the CircleCI CLI to split tests       Specify parallel environments for a test job   Test suites are conventionally defined at the  job level in your .circleci/config.yml file. The parallelism key specifies how many independent executors are set up to run the job.   To run a job’s steps in multiple, parallel execution environments, set the parallelism key to a value greater than 1. In the example below, parallelism is set to 4, meaning four identical execution environments will be set up for the job, in this case, four Docker containers using the cimg/base:2023.09 image.   Use the circleci tests run command to split and run your tests. Your tests will be split up, and a portion of your tests run in each execution environment. This reduces the overall time taken to run the full test suite. In this example tests will be split up into four, and the split points are calculated based on historic timing data.    # ~/.circleci/config.yml
jobs:
  build:
    docker:
      - image: cimg/go:1.18.1
    parallelism: 4
    resource_class: large
    steps:
      - run: go list ./... | circleci tests run --command "xargs gotestsum --junitfile junit.xml --format testname --" --split-by=timings --timings-type=name         Use parallelism with self-hosted runners  To use the parallelism feature with jobs that use  self-hosted runners, ensure that you have at least two self-hosted machine runners associated with the runner resource class that your job will run on. If you set the parallelism value to be greater than the number of active self-hosted runners in a given resource class, the excess parallel tasks that do not have a self-hosted runner on which to execute will queue until a self-hosted runner is available.   If you are using parallelism on  Container Runner, you will need to make sure that agent.maxConcurrentTasks and your Kubernetes cluster can accommodate the number of parallel tasks you want to run. If you do not have adequate resources, your parallel runs will be subject to queuing.   For more information, see the  Configuration reference page.      How test splitting works   CircleCI’s test splitting feature allows you to specify a number of identical execution environments for a job (parallelism), and then split your test suite into an equal number of portions so that the tests can be run in parallel to reduce the length of time taken for your test pipeline. You can split your tests up in a few different ways:     Alphabetically, by name. This is the default:   # ~/.circleci/config.yml
jobs:
  build:
    docker:
      - image: cimg/go:1.18.1
    parallelism: 4
    resource_class: large
    steps:
      - run: go list ./... | circleci tests run --command "xargs gotestsum --junitfile junit.xml --format testname --"     By size:   # ~/.circleci/config.yml
jobs:
  build:
    docker:
      - image: cimg/go:1.18.1
    parallelism: 4
    resource_class: large
    steps:
      - run: go list ./... | circleci tests run --command "xargs gotestsum --junitfile junit.xml --format testname --" --split-by=filesize     By using historic timing data:   jobs:
  build:
    docker:
      - image: cimg/go:1.18.1
    parallelism: 4
    resource_class: large
    steps:
      - run: go list ./... | circleci tests run --command "xargs gotestsum --junitfile junit.xml --format testname --" --split-by=timings --timings-type=name       When using timing-based test splitting, the CLI attempts to auto detect the granularity of the test split (for example, whether to split by file name, or down to class name) based on the input to the split command. You may need to choose a different timing type depending on how your test coverage output is formatted, using the --timings-type option. Valid timing types are:     name - test name   classname class name   file - file name     Example using timing-based test splitting  Using timing-based test splitting as an example, timing data from the previous test run is used to split a test suite as evenly as possible over a specified number of test environments running in parallel. This delivers the lowest possible test time for the compute power in use.        Timings-based test splitting gives the most accurate split, and is guaranteed to optimize with each test suite run. The most recent timings data is always used to define where splits are made.   As an example, take a Go test suite. Here, all tests run sequentially in a single test environment, a Docker container:    jobs:
  build:
    docker:
      - image: cimg/go:1.18.1
    resource_class: large
    steps:
      - run: go test    To split these tests using timing data:     Introduce parallelism to spin up a number of identical test environments (4 in this example)   Use the circleci tests run command, with the --split-by=timings flag to split the tests evenly across all executors.      jobs:
  build:
    docker:
      - image: cimg/go:1.18.1
    parallelism: 4
    resource_class: large
    steps:
      - run: go list ./... | circleci tests run --command "xargs gotestsum --junitfile junit.xml --format testname --" --split-by=timings --timings-type=name    For a more detailed walkthrough, read the  guide to using the CLI to split tests, or follow our  Test splitting tutorial.   The first time the tests are run there will be no timing data for the command to use, but on subsequent runs the test time will be optimized.    The tests run command  Use the circleci tests run command to run your tests, split your tests across parallel executors and take advantage of the  rerun failed tests options.   The following table show a full list of option flags available when using circleci tests run.  FlagTypeDescriptionRequired?--commandstringThe command string is the script that will be run for a list of tests determined by the options provided to the pluginYes--indexuintindex of node can also be set with CIRCLE_NODE_INDEX. (default 1)No--split-bystringhow to weight the split, allowed values are name, filesize, and timings. (default name)No--timings-typestringname of the field to use from historical test results when matching against the test names given to the command in order to determine their historical timings, previous status and flakiness. Available values: classname, name, file (default).No--totaluintnumber of nodes can also be set with CIRCLE_NODE_TOTAL. (default 2)No-v, --verbose — enable verbose logging output.No   The tests split command  It is also possible to split tests using the circleci tests split command. Using the example from above, splitting the Go tests would be done as follows:    jobs:
  build:
    docker:
      - image: cimg/go:1.18.1
    parallelism: 4
    resource_class: large
    steps:
      - run: go test -v $(go list ./... | circleci tests split --split-by=timings)    The circleci tests split command has been superseded by circleci tests run as this command also gives you access to the  rerun failed tests options.   Integrating with some  third party tools might still require you to use circleci tests split. For usage steps see,  Use the CircleCI CLI to split tests.    JUnit XML report formatting  In order to use the test splitting feature, CircleCI requires test results to be uploaded as JUnit XML reports. The following formatting allows CircleCI to parse timing data from test results and use the data for test splitting:     The file attribute, either on the <testsuite> or <testcase> tag   The time attribute, on the <testcase> tag     The following example is a snippet from an XML file with a format that CircleCI can parse:    <?xml version="1.0" encoding="UTF-8"?>
<testsuites name="Mocha Tests" tests="3" failures="1">
  <testsuite tests="3">
    <testcase classname="foo1" name="ASuccessfulTest" time="10" file="src/__tests__/App.test.js" />
    <testcase classname="foo2" name="AnotherSuccessfulTest" time="5" file="src/__tests__/App.test.js" />
    <testcase classname="foo3" name="AFailingTest" time="1.1050" file="src/__tests__/App.test.js">
        <failure type="NotEnoughFoo"> details about failure </failure>
    </testcase>
  </testsuite>
</testsuites>       Manual allocation   For full control over how tests are split across parallel executors, CircleCI provides two environment variables that you can use in place of the CLI to configure each container individually.     $CIRCLE_NODE_TOTAL is the total number of parallel containers being used to run your job.   $CIRCLE_NODE_INDEX is the index of the specific container that is currently running.     The CLI looks up the number of available execution environments ($CIRCLE_NODE_TOTAL), along with the current container index ($CIRCLE_NODE_INDEX). Then, it uses deterministic splitting algorithms to split the test files across all available containers.   The number of containers is specified by the  parallelism key in the project configuration file.   The current container index is automatically picked up from the $CIRCLE_NODE_INDEX environment variable, but can be manually set by using the --index flag.    cat test_filenames.txt | circleci tests run --command=">index0.txt xargs echo" --index=0 --split-by=name    Refer to the  Project values and variables page for more details.     Other ways to split tests   Some third party applications and libraries might help you to split your test suite. These applications are not developed or supported by CircleCI. Check with the owner if you have issues using it with CircleCI. If you are unable to resolve the issue you can search and ask on our forum,  Discuss.     Knapsack Pro  Enables allocating tests dynamically across parallel CI nodes, allowing your test suite execution to run faster. See  CI build time graph examples.   PHPUnit Finder  A helper CLI tool that queries phpunit.xml files to get a list of test filenames and print them. PHPUnit Finder is useful if you want to split tests to run them in parallel based on timings on CI tools.   go list  Use the built-in Go command go list ./... to glob Golang packages. This allows splitting package tests across multiple containers.   go test -v $(go list ./... | circleci tests split)     Playwright  A framework for web testing and automation and allows running sharded tests out of the box. For more details see  Playwright docs.   job-name:
  executor: pw-focal-development
  parallelism: 4
  steps:
    - run: SHARD="$((${CIRCLE_NODE_INDEX}+1))"; npx playwright test --shard=${SHARD}/${CIRCLE_NODE_TOTAL}         Next steps      Use the CircleCI CLI to split tests    Test splitting to speed up your pipelines    Troubleshooting Test Splitting    Collecting Test Data    Test Insights     Suggest an edit to this pageMake a contribution Learn how to contributeStill need help? Ask the CircleCI community Join the research community Visit our Support site\n\nTest splitting and parallelism1 month ago6 min readCloudServer v4+On This PageIntroductionQuickstartSpecify parallel environments for a test jobUse parallelism with self-hosted runnersHow test splitting worksExample using timing-based test splittingThe tests run commandThe tests split commandJUnit XML report formattingManual allocationOther ways to split testsNext steps   Use parallelism and test splitting to:     Reduce the time taken for the testing portion of your CI/CD pipeline.   Specify a number of  executors across which to split your tests.   Split your test suite using one of the options provided by the CircleCI CLI: by name, size or by using timing data.     If you are interested to read about concurrent job runs, see the  Concurrency overview page.     Introduction   Pipelines are often configured so that a set of tests are run each time code is committed. The more tests your project has, the longer it will take for them to complete using a single compute resource. To reduce this time, you can split your tests and run them across multiple, parallel-running execution environments. Test splitting is a great way to speed up the testing portion of your CI/CD pipeline.   CircleCI test splitting lets you intelligently define where splits happen across a test suite:     By name   By size   Using timing data     It is also possible to use the CLI to  manually allocate tests across parallel environments.     Quickstart   The following how-to guide walks you through the steps required to glob your test files, split your tests evenly across parallel containers or VMs, and then run your tests in parallel:     How-to:  Use the CircleCI CLI to split tests       Specify parallel environments for a test job   Test suites are conventionally defined at the  job level in your .circleci/config.yml file. The parallelism key specifies how many independent executors are set up to run the job.   To run a job’s steps in multiple, parallel execution environments, set the parallelism key to a value greater than 1. In the example below, parallelism is set to 4, meaning four identical execution environments will be set up for the job, in this case, four Docker containers using the cimg/base:2023.09 image.   Use the circleci tests run command to split and run your tests. Your tests will be split up, and a portion of your tests run in each execution environment. This reduces the overall time taken to run the full test suite. In this example tests will be split up into four, and the split points are calculated based on historic timing data.    # ~/.circleci/config.yml
jobs:
  build:
    docker:
      - image: cimg/go:1.18.1
    parallelism: 4
    resource_class: large
    steps:
      - run: go list ./... | circleci tests run --command "xargs gotestsum --junitfile junit.xml --format testname --" --split-by=timings --timings-type=name         Use parallelism with self-hosted runners  To use the parallelism feature with jobs that use  self-hosted runners, ensure that you have at least two self-hosted machine runners associated with the runner resource class that your job will run on. If you set the parallelism value to be greater than the number of active self-hosted runners in a given resource class, the excess parallel tasks that do not have a self-hosted runner on which to execute will queue until a self-hosted runner is available.   If you are using parallelism on  Container Runner, you will need to make sure that agent.maxConcurrentTasks and your Kubernetes cluster can accommodate the number of parallel tasks you want to run. If you do not have adequate resources, your parallel runs will be subject to queuing.   For more information, see the  Configuration reference page.      How test splitting works   CircleCI’s test splitting feature allows you to specify a number of identical execution environments for a job (parallelism), and then split your test suite into an equal number of portions so that the tests can be run in parallel to reduce the length of time taken for your test pipeline. You can split your tests up in a few different ways:     Alphabetically, by name. This is the default:   # ~/.circleci/config.yml
jobs:
  build:
    docker:
      - image: cimg/go:1.18.1
    parallelism: 4
    resource_class: large
    steps:
      - run: go list ./... | circleci tests run --command "xargs gotestsum --junitfile junit.xml --format testname --"     By size:   # ~/.circleci/config.yml
jobs:
  build:
    docker:
      - image: cimg/go:1.18.1
    parallelism: 4
    resource_class: large
    steps:
      - run: go list ./... | circleci tests run --command "xargs gotestsum --junitfile junit.xml --format testname --" --split-by=filesize     By using historic timing data:   jobs:
  build:
    docker:
      - image: cimg/go:1.18.1
    parallelism: 4
    resource_class: large
    steps:
      - run: go list ./... | circleci tests run --command "xargs gotestsum --junitfile junit.xml --format testname --" --split-by=timings --timings-type=name       When using timing-based test splitting, the CLI attempts to auto detect the granularity of the test split (for example, whether to split by file name, or down to class name) based on the input to the split command. You may need to choose a different timing type depending on how your test coverage output is formatted, using the --timings-type option. Valid timing types are:     name - test name   classname class name   file - file name     Example using timing-based test splitting  Using timing-based test splitting as an example, timing data from the previous test run is used to split a test suite as evenly as possible over a specified number of test environments running in parallel. This delivers the lowest possible test time for the compute power in use.        Timings-based test splitting gives the most accurate split, and is guaranteed to optimize with each test suite run. The most recent timings data is always used to define where splits are made.   As an example, take a Go test suite. Here, all tests run sequentially in a single test environment, a Docker container:    jobs:
  build:
    docker:
      - image: cimg/go:1.18.1
    resource_class: large
    steps:
      - run: go test    To split these tests using timing data:     Introduce parallelism to spin up a number of identical test environments (4 in this example)   Use the circleci tests run command, with the --split-by=timings flag to split the tests evenly across all executors.      jobs:
  build:
    docker:
      - image: cimg/go:1.18.1
    parallelism: 4
    resource_class: large
    steps:
      - run: go list ./... | circleci tests run --command "xargs gotestsum --junitfile junit.xml --format testname --" --split-by=timings --timings-type=name    For a more detailed walkthrough, read the  guide to using the CLI to split tests, or follow our  Test splitting tutorial.   The first time the tests are run there will be no timing data for the command to use, but on subsequent runs the test time will be optimized.    The tests run command  Use the circleci tests run command to run your tests, split your tests across parallel executors and take advantage of the  rerun failed tests options.   The following table show a full list of option flags available when using circleci tests run.  FlagTypeDescriptionRequired?--commandstringThe command string is the script that will be run for a list of tests determined by the options provided to the pluginYes--indexuintindex of node can also be set with CIRCLE_NODE_INDEX. (default 1)No--split-bystringhow to weight the split, allowed values are name, filesize, and timings. (default name)No--timings-typestringname of the field to use from historical test results when matching against the test names given to the command in order to determine their historical timings, previous status and flakiness. Available values: classname, name, file (default).No--totaluintnumber of nodes can also be set with CIRCLE_NODE_TOTAL. (default 2)No-v, --verbose — enable verbose logging output.No   The tests split command  It is also possible to split tests using the circleci tests split command. Using the example from above, splitting the Go tests would be done as follows:    jobs:
  build:
    docker:
      - image: cimg/go:1.18.1
    parallelism: 4
    resource_class: large
    steps:
      - run: go test -v $(go list ./... | circleci tests split --split-by=timings)    The circleci tests split command has been superseded by circleci tests run as this command also gives you access to the  rerun failed tests options.   Integrating with some  third party tools might still require you to use circleci tests split. For usage steps see,  Use the CircleCI CLI to split tests.    JUnit XML report formatting  In order to use the test splitting feature, CircleCI requires test results to be uploaded as JUnit XML reports. The following formatting allows CircleCI to parse timing data from test results and use the data for test splitting:     The file attribute, either on the <testsuite> or <testcase> tag   The time attribute, on the <testcase> tag     The following example is a snippet from an XML file with a format that CircleCI can parse:    <?xml version="1.0" encoding="UTF-8"?>
<testsuites name="Mocha Tests" tests="3" failures="1">
  <testsuite tests="3">
    <testcase classname="foo1" name="ASuccessfulTest" time="10" file="src/__tests__/App.test.js" />
    <testcase classname="foo2" name="AnotherSuccessfulTest" time="5" file="src/__tests__/App.test.js" />
    <testcase classname="foo3" name="AFailingTest" time="1.1050" file="src/__tests__/App.test.js">
        <failure type="NotEnoughFoo"> details about failure </failure>
    </testcase>
  </testsuite>
</testsuites>       Manual allocation   For full control over how tests are split across parallel executors, CircleCI provides two environment variables that you can use in place of the CLI to configure each container individually.     $CIRCLE_NODE_TOTAL is the total number of parallel containers being used to run your job.   $CIRCLE_NODE_INDEX is the index of the specific container that is currently running.     The CLI looks up the number of available execution environments ($CIRCLE_NODE_TOTAL), along with the current container index ($CIRCLE_NODE_INDEX). Then, it uses deterministic splitting algorithms to split the test files across all available containers.   The number of containers is specified by the  parallelism key in the project configuration file.   The current container index is automatically picked up from the $CIRCLE_NODE_INDEX environment variable, but can be manually set by using the --index flag.    cat test_filenames.txt | circleci tests run --command=">index0.txt xargs echo" --index=0 --split-by=name    Refer to the  Project values and variables page for more details.     Other ways to split tests   Some third party applications and libraries might help you to split your test suite. These applications are not developed or supported by CircleCI. Check with the owner if you have issues using it with CircleCI. If you are unable to resolve the issue you can search and ask on our forum,  Discuss.     Knapsack Pro  Enables allocating tests dynamically across parallel CI nodes, allowing your test suite execution to run faster. See  CI build time graph examples.   PHPUnit Finder  A helper CLI tool that queries phpunit.xml files to get a list of test filenames and print them. PHPUnit Finder is useful if you want to split tests to run them in parallel based on timings on CI tools.   go list  Use the built-in Go command go list ./... to glob Golang packages. This allows splitting package tests across multiple containers.   go test -v $(go list ./... | circleci tests split)     Playwright  A framework for web testing and automation and allows running sharded tests out of the box. For more details see  Playwright docs.   job-name:
  executor: pw-focal-development
  parallelism: 4
  steps:
    - run: SHARD="$((${CIRCLE_NODE_INDEX}+1))"; npx playwright test --shard=${SHARD}/${CIRCLE_NODE_TOTAL}         Next steps      Use the CircleCI CLI to split tests    Test splitting to speed up your pipelines    Troubleshooting Test Splitting    Collecting Test Data    Test Insights     Suggest an edit to this pageMake a contribution Learn how to contributeStill need help? Ask the CircleCI community Join the research community Visit our Support site DocsTerms of UsePrivacy PolicyCookie PolicySecurity© 2025 Circle Internet Services, Inc., All Rights Reserved.\n\n# ~/.circleci/config.yml
jobs:
  build:
    docker:
      - image: cimg/go:1.18.1
    parallelism: 4
    resource_class: large
    steps:
      - run: go list ./... | circleci tests run --command "xargs gotestsum --junitfile junit.xml --format testname --" --split-by=timings --timings-type=name    # ~/.circleci/config.yml
jobs:
  build:
    docker:
      - image: cimg/go:1.18.1
    parallelism: 4
    resource_class: large
    steps:
      - run: go list ./... | circleci tests run --command "xargs gotestsum --junitfile junit.xml --format testname --"  # ~/.circleci/config.yml
jobs:
  build:
    docker:
      - image: cimg/go:1.18.1
    parallelism: 4
    resource_class: large
    steps:
      - run: go list ./... | circleci tests run --command "xargs gotestsum --junitfile junit.xml --format testname --" --split-by=filesize  jobs:
  build:
    docker:
      - image: cimg/go:1.18.1
    parallelism: 4
    resource_class: large
    steps:
      - run: go list ./... | circleci tests run --command "xargs gotestsum --junitfile junit.xml --format testname --" --split-by=timings --timings-type=name    jobs:
  build:
    docker:
      - image: cimg/go:1.18.1
    resource_class: large
    steps:
      - run: go test  jobs:
  build:
    docker:
      - image: cimg/go:1.18.1
    parallelism: 4
    resource_class: large
    steps:
      - run: go list ./... | circleci tests run --command "xargs gotestsum --junitfile junit.xml --format testname --" --split-by=timings --timings-type=name  jobs:
  build:
    docker:
      - image: cimg/go:1.18.1
    parallelism: 4
    resource_class: large
    steps:
      - run: go test -v $(go list ./... | circleci tests split --split-by=timings)  <?xml version="1.0" encoding="UTF-8"?>
<testsuites name="Mocha Tests" tests="3" failures="1">
  <testsuite tests="3">
    <testcase classname="foo1" name="ASuccessfulTest" time="10" file="src/__tests__/App.test.js" />
    <testcase classname="foo2" name="AnotherSuccessfulTest" time="5" file="src/__tests__/App.test.js" />
    <testcase classname="foo3" name="AFailingTest" time="1.1050" file="src/__tests__/App.test.js">
        <failure type="NotEnoughFoo"> details about failure </failure>
    </testcase>
  </testsuite>
</testsuites>  cat test_filenames.txt | circleci tests run --command=">index0.txt xargs echo" --index=0 --split-by=name  go test -v $(go list ./... | circleci tests split)  job-name:
  executor: pw-focal-development
  parallelism: 4
  steps:
    - run: SHARD="$((${CIRCLE_NODE_INDEX}+1))"; npx playwright test --shard=${SHARD}/${CIRCLE_NODE_TOTAL}\n\n\n\nUsing OpenID Connect tokens in jobs1 week ago9 min readCloudServer v4.4+On This PageOpenID Connect token availabilitySetting up your cloud serviceFormat of the OpenID Connect ID tokenOIDC in open source projectsOIDC on CircleCI serverAuthenticate jobs with cloud providersAWSSet up AWSAdding AWS to the CircleCI configuration fileAdvanced usageLimit role access based on projectLimit role access based on branchGoogle Cloud PlatformSetting up GCPAdding GCP to the CircleCI configuration fileNext steps   CircleCI provides OpenID Connect ID (OIDC) tokens in environment variables. A job can be configured to use these tokens to access compatible cloud services without long-lived credentials being stored in CircleCI.     OpenID Connect token availability   CircleCI OpenID Connect ID tokens are available in the following environment variables:     $CIRCLE_OIDC_TOKEN   $CIRCLE_OIDC_TOKEN_V2 - Includes a different format for the sub claim, See  Format of the OpenID Connect ID token for full details.        What about forks? OIDC tokens will only be generated for forked builds if the Pass secrets to builds from forked pull requests setting is enabled. Find this option at Project settings > Advanced. See  OIDC in open source projects.          Setting up your cloud service   Refer to the documentation for your target cloud service for steps to add an Identity Provider. For example, AWS’s  Creating OpenID Connect (OIDC) identity providers, or Google Cloud Platform’s  Configuring Workload Identity federation.   The  OpenID Provider is unique to your organization. The URL is https://oidc.circleci.com/org/<organization_id>, where organization_id is the organization ID (a universally unique identifier) that represents your organization. You can find your CircleCI organization ID by navigating to Organization Settings > Overview in the  CircleCI web app.   The default OpenID Connect ID tokens issued by CircleCI have a fixed audience (see aud in the table below), which is also the organization ID. To generate tokens with custom audience claims, see the  OIDC tokens with custom claims page.      It is possible to use CircleCI’s OIDC tokens with multiple cloud services.          Format of the OpenID Connect ID token   The OIDC tokens contain the following standard  claims:  ClaimsDescriptionissThe issuer. The issuer is specific to the CircleCI organization in which the job is being run. Its value is "https://oidc.circleci.com/org/<organization_id>", a string, where organization_id is a UUID identifying the current job’s project’s organization.sub The subject. This identifies who is running the CircleCI job and where. $CIRCLE_OIDC_TOKEN_V2 also includes information about the source of change.   For $CIRCLE_OIDC_TOKEN its value is: "org/<organization_id>/project/<project_id>/user/<user_id>", a string, where organization_id, project_id, and user_id are UUIDs that identify the CircleCI organization, project, and user, respectively. The user is the CircleCI user that caused this job to run.   For $CIRCLE_OIDC_TOKEN_V2 its value depends on the  trigger:     If the trigger is an  custom webhook then: "org/<organization_id>/project/<project_id>/user/<user_id>/vcs-origin/<vcs_origin>/vcs-ref/<vcs_ref>", a string, where organization_id, project_id, and user_id are UUIDs that identify the CircleCI organization, project, and user, respectively. The user is the CircleCI user that caused this job to run.   Otherwise it will be: "org/<organization_id>/project/<project_id>/user/<user_id>/vcs-origin/<vcs_origin>/vcs-ref/<vcs_ref>", a string, where organization_id, project_id, and user_id are UUIDs that identify the CircleCI organization, project, and user, respectively. The user is the CircleCI user that caused this job to run. vcs_origin and vcs_ref are strings that identify the repository URL and reference to the change that caused the job to run.   audThe audience. Currently, this is a fixed value "ORGANIZATION_ID", a string containing a UUID that identifies the job’s project’s organization.iatThe time of issuance. This is the time the token was created, which is shortly before the job starts.expThe expiration time. Its value is one hour after the time of issuance.  The OpenID Connect ID tokens also contain some  additional claims with extra metadata about the job:  Additional claimsMetadataoidc.circleci.com/project-idThe ID of the project in which the job is running. Its value is a string containing a UUID identifying the CircleCI project.oidc.circleci.com/vcs-originThe URL of the repository that triggered the pipeline. Its value is a string similar to github.com/organization-123/repo-1. This is not present for pipelines triggered by custom webhooks.oidc.circleci.com/vcs-refThe reference to the change that triggered the pipeline. Its value is a string similar to refs/heads/main. This is not present for pipelines triggered by custom webhooks.oidc.circleci.com/context-idsAn array of strings containing UUIDs that identify the context(s) used in the job. Currently, just one context is supported.oidc.circleci.com/ssh-rerunA boolean indicating if the CI job is started using the SSH rerun feature.    OIDC in open source projects   OIDC tokens will only be generated for forked builds if the Pass secrets to builds from forked pull requests setting is enabled. Find this option at Project settings > Advanced.   If you do allow OIDC tokens to be generated for forks, you must check the oidc.circleci.com/vcs-origin claims in your policies to avoid forked builds having access to resources outside those that you require.   For more information about building open source projects on CircleCI, see the  Build open source projects page.     OIDC on CircleCI server   OIDC is supported from server v4.4+. However, OIDC is not supported if your server installation is in an air-gapped environment.     Authenticate jobs with cloud providers   The following sections describe how to authenticate CircleCI jobs with Amazon Web Services (AWS) and Google Cloud Platform (GCP).   AWS  The following AWS instructions cover the following:     A one-time configuration of your AWS account to trust CircleCI’s OIDC tokens   Running a job that uses the OIDC token to interact with AWS     Also see the  Pull an image from AWS ECR with OIDC how-to guide, which follows on from this setup section.   Set up AWS  You will need to allow your AWS account to trust CircleCI’s OpenID Connect tokens. To do this, create an Identity and Access Management (IAM) Identity Provider, and an IAM role in AWS. Creating the Identity Provider is a one-time configuration to get set up, and then you can decide how to manage the associated role(s). You can update the role permissions, using policies, to fit your use cases, or you can create roles specific to each use.     Visit the  Creating OpenID Connect (OIDC) identity providers page of the AWS docs and follow the instructions. There are multiple setup options covered on this page, including using the management console, or CLI. You will need to provide the following:    Provider URL: Enter https://oidc.circleci.com/org/<your-organization-id>, where your-organization-id is the ID of your CircleCI organization.   Audience: Enter your organization ID      To find your organization/user ID, select Organization Settings in the CircleCI web app side bar.                Once your have created your Identity Provider, a banner appears at the top of the AWS console with the option to Assign role. Select this button to create a new role, or visit the  Creating a role for web identity or OIDC section of the AWS docs and follow the steps there. You will need to select the following:    The Identity Provider that you just created.   For Audience, choose the only option, which is your organization ID that you entered earlier.   On the Add Permissions page you can specify what your CircleCI jobs can and cannot do. Choose only permissions that your job will need. This is an  AWS best practice. You can also write your own policies to lock down permissions to exactly what you need for a specific use case.         Adding AWS to the CircleCI configuration file  Now that you have set up your trusted Identity Provider and IAM role, you are ready to write a CircleCI job that authenticates with AWS using OIDC. This is accomplished using CircleCI’s  AWS CLI orb to generate temporary keys and configure a profile that uses OIDC.      Orbs are reusable packages of YAML configuration that condense repeated pieces of configuration into a single line of code. In this case, the AWS CLI orb enables you to generate a temporary session token, AWS Access Key ID, and AWS secret access key with a single command in your configuration.          In your .circleci/config, import the aws-cli orb.   version: 2.1

orbs:
  aws-cli: circleci/aws-cli@3.1.5     Configure your job to run the aws-cli/setup command before interacting with any AWS services. You will need to provide the aws-cli/setup command with the role-arn associated with the role you have created in the step above along with your aws-region.   jobs:
  aws-example:
    environment:
      AWS_REGION: us-west-1
    docker:
      - image: cimg/aws:2023.06
    steps:
      - checkout
      # run the aws-cli/setup command from the orb
      - aws-cli/setup:
          role-arn: "arn:aws:iam::123456789012:role/OIDC-ROLE"
          aws-region: ${AWS_REGION}
          # optional parameters
          profile-name: "OIDC-PROFILE"
          role-session-name: "example-session"
          session-duration: "1800"    You can optionally provide a profile-name, role-session-name, and session-duration. If you provide a profile-name, the temporary keys and token will be configured to that specific profile. You must use that same profile-name with the rest of your AWS commands. If a profile-name is not provided, the keys and token will be configured to the default profile.   Additionally, if you do not provide a role-session-name or session-duration, their default values are ${CIRCLE_JOB} (your job’s name) and 3600 seconds respectively.      Below is an example of a complete configuration with a job that configures a profile with OIDC and uses it to log into AWS ECR. The same profile can be used to run other AWS commands, such as S3, EKS, ECS, and more, as long as the role-arn has been configured with appropriate permissions.    version: 2.1

orbs:
  aws-cli: circleci/aws-cli@5.1.1

jobs:
  aws-example:
    environment:
      AWS_REGION: us-west-1
    docker:
      - image: cimg/aws:2022.06
    steps:
      - checkout
      # run the aws-cli/setup command from the orb
      - aws-cli/setup:
          role_arn: "arn:aws:iam::123456789012:role/OIDC-ROLE"
          region: AWS_REGION
          # optional parameters
          profile_name: "OIDC-PROFILE"
          role_session_name: "example-session"
          session_duration: "1800"
      - run:
        name: Log-into-AWS-ECR
        command: |
          # must use same profile specified in the step above
          aws ecr get-login-password --profile "OIDC-PROFILE"
workflows:
  OIDC-with-AWS:
    jobs:
      - aws-example:
          context: aws     Advanced usage  You can take advantage of the format of the claims in CircleCI’s  OIDC token to limit what your CircleCI jobs can do in AWS.   Limit role access based on project  If certain projects should only be able to access certain AWS resources, you can restrict your IAM role so that only CircleCI jobs in a specific project can assume that role.   To do this, edit your IAM role’s trust policy so that only an OIDC token from your chosen project can assume that role. The trust policy determines under what conditions the role can be assumed.     Go to an individual project’s page in the  CircleCI web app and navigate to Project Settings > Overview to find your Project ID.   Add the following condition to your role’s trust policy, so that only jobs in your chosen project can assume that role. Enter your Organization ID for organization_id and your Project ID for project_id.   "StringLike": {
  "oidc.circleci.com/org/<organization_id>:sub": "org/<organization_id>/project/<project_id>/user/*"
}    This uses  StringLike to match the sub claim of CircleCI’s OIDC token in your chosen project. Now, jobs in your other projects cannot assume this role.       Limit role access based on branch  You can also restrict access to specific branches. The following is an example of a trust policy that restricts the AssumeRoleWithWebIdentity action to any project pipelines running only on the main branch in the my-org GitHub organization and the CircleCI organization with the ID: organization_id. Note that the sub claim uses the $CIRCLE_OIDC_TOKEN_V2 format.    {
    "Version": "2012-10-17",
    "Statement": [
        {
            "Effect": "Allow",
            "Principal": {
                "Federated": "arn:aws:iam::123456789012:oidc-provider/oidc.circleci.com/org/<organization_id>"
            },
            "Action": "sts:AssumeRoleWithWebIdentity",
            "Condition": {
                "StringLike": {
                    "oidc.circleci.com/org/<organization_id>:sub": "org/<organization_id>/project/*/user/*/vcs-origin/github.com/my-org/*/vcs-ref/refs/heads/main"
                }
            }
        }
    ]
}       Google Cloud Platform  The following GCP instructions are for:     A one-time configuration of your GCP settings to trust CircleCI’s OIDC tokens   Running a job that uses the OIDC token to interact with GCP     The Google Cloud CLI reads your configuration file, which contains necessary information instructing Google Cloud to authenticate. You can read about external identity providers on  Google Cloud’s docs.   Setting up GCP  The GCP configuration file can be set up using the GCP web UI. In the Workload Identity Federation UI, navigate to Grant Access, which will prompt the configuration, which can then be downloaded. You will need to create a file named CIRCLE_OIDC_TOKEN_FILE, which Google Cloud will read your identity token from (the file name can be anything, as long as it matches what is in the configuration under credential_source).   You will need your CircleCI organization ID, which can be found by navigating to Organization Settings > Overview on the  CircleCI web app.   After navigating to the Grant Access section of the GCP web UI, follow these steps to add CircleCI as an external Identity Provider:     Navigate to the IAM & Admin panel.   On the side panel, navigate to Workload Identity Federation.   Select Add Provider.   Select OpenID Connect (OIDC) from the "Select a provider" dropdown and select Save.   Fill out the Provider details form.    Select Allowed audiences since the aud claim in the JSON Web Token is a UUID (your CircleCI organization ID). The audience will be your CircleCI organization ID.   The issuer is https://oidc.circleci.com/org/<organization_id>, where organization_id is your CircleCI organization ID.      Select Continue to configure provider attributes.  Configuring the provider attributes provides an opportunity to map claims in CircleCI’s Token to Google’s "understanding". Use this mapping:  google.subjectassertion.subattribute.org_idassertion.audattribute.projectassertion['oidc.circleci.com/project-id']   Navigate to Service Account in the IAM & Admin Panel to create a service account, and give appropriate permission.   Navigate back to Workload Identity Federation and select the provider from the table.   Select Grant access.   A modal will open and you will select the service account you created from the dropdown. This is the account that the token will impersonate, which grants all the associated permissions.   Under Select principals, you can add conditions, or leave the default.   Select Save. A pop-up will appear to ask you configure and download the configuration file. This file can also be downloaded later by navigating to Connected Service Accounts.   Save the downloaded configuration file in your repository. This file will be referenced in your CircleCI configuration.     An example of the configuration file is shown below. Note, the audience has not been set up yet with the following:     project_number (the unique identifying number generated for your project)   pool_id (an ID that references the Workload Identity pool, for example circleci_oidc)   provider_id (an ID that references the Workload Identity pool provider, for example, circleci)       {
  "type": "external_account",
  "audience": "//iam.googleapis.com/projects/<project_number>/locations/global/workloadIdentityPools/<pool_id>/providers/<provider_id>",
  "subject_token_type": "urn:ietf:params:oauth:token-type:jwt",
  "token_url": "https://sts.googleapis.com/v1/token",
  "service_account_impersonation_url": "https://iamcredentials.googleapis.com/v1/projects/-/serviceAccounts/circleci-test@incubator-344312.iam.gserviceaccount.com:generateAccessToken",
  "credential_source": {
    "file": "CIRCLE_OIDC_TOKEN_FILE",
    "format": {
      "type": "text"
    }
  }
}    In this configuration, credential_source will attempt to find your identity token in the CIRCLE_OIDC_TOKEN_FILE, as noted in the ( token availability section).   If your token comes from an API response, it might be useful to set up the configuration to read a JSON file. In this case, the type will need to be set to json and you will need to provide a valid path, for example, response.id_token.      "credential_source": {
    "file": "CIRCLE_OIDC_TOKEN_FILE",
    "format": {
      "type": "json",
      "path": "response.id_token"
    }
  }       If needed, you can also attempt to generate the GCP configuration file by running the following script:         gcloud iam workload-identity-pools create-cred-config \
  "${GCP_WORKLOAD_IDENTITY_POOL_AUDIENCE}" \
  --output-file="${GCP_CREDENTIAL_CONFIGURATION_FILE}" \
  --service-account="${GCP_SERVICE_ACCOUNT_EMAIL}" \
  --credential-source-file="${GCP_CREDENTIAL_SOURCE_FILE}"     Adding GCP to the CircleCI configuration file  You will need to export the $CIRCLE_OIDC_TOKEN to the file named CIRCLE_OIDC_TOKEN_FILE by running the following:    echo $CIRCLE_OIDC_TOKEN >> CIRCLE_OIDC_TOKEN_FILE    You will also need to add the following environment variables to a  context.  Context var nameExample valueNotesGCP_PROJECT_ID123456789012 GCP project numberGCP_WIP_IDmyworkloadpoolid Workload Identity pool IDGCP_WIP_PROVIDER_IDmyproviderid Workload Identity pool provider nameGCP_SERVICE_ACCOUNT_EMAILmyserviceacct@myproject.iam.gserviceaccount.com User-managed Service Accounts  Below is a full example configuration adding GCP to a job and demonstrating that authentication works with the gcp-oidc-authenticate command. This example uses the  circleci/gcp-cli orb. Note that you can enable the use of OIDC token when using circleci/gcp-cli orb version 3.0.0 or later.    version: 2.1

orbs:
  gcp-cli: circleci/gcp-cli@2.4.1

commands:
  gcp-oidc-generate-cred-config-file:
    description: "Authenticate with GCP using a CircleCI OIDC token."
    parameters:
      project_id:
        type: env_var_name
        default: GCP_PROJECT_ID
      workload_identity_pool_id:
        type: env_var_name
        default: GCP_WIP_ID
      workload_identity_pool_provider_id:
        type: env_var_name
        default: GCP_WIP_PROVIDER_ID
      service_account_email:
        type: env_var_name
        default: GCP_SERVICE_ACCOUNT_EMAIL
      gcp_cred_config_file_path:
        type: string
        default: /home/circleci/gcp_cred_config.json
      oidc_token_file_path:
        type: string
        default: /home/circleci/oidc_token.json
    steps:
      - run:
          command: |
            # Store OIDC token in temp file
            echo $CIRCLE_OIDC_TOKEN > << parameters.oidc_token_file_path >>
            # Create a credential configuration for the generated OIDC ID Token
            gcloud iam workload-identity-pools create-cred-config \
                "projects/${<< parameters.project_id >>}/locations/global/workloadIdentityPools/${<< parameters.workload_identity_pool_id >>}/providers/${<< parameters.workload_identity_pool_provider_id >>}"\
                --output-file="<< parameters.gcp_cred_config_file_path >>" \
                --service-account="${<< parameters.service_account_email >>}" \
                --credential-source-file=<< parameters.oidc_token_file_path >>

  gcp-oidc-authenticate:
    description: "Authenticate with GCP using a GCP credentials file."
    parameters:
      gcp_cred_config_file_path:
        type: string
        default: /home/circleci/gcp_cred_config.json
    steps:
      - run:
          command: |
            # Configure gcloud to leverage the generated credential configuration
            gcloud auth login --brief --cred-file "<< parameters.gcp_cred_config_file_path >>"
            # Configure ADC
            echo "export GOOGLE_APPLICATION_CREDENTIALS='<< parameters.gcp_cred_config_file_path >>'" | tee -a "$BASH_ENV"

jobs:
  gcp-oidc-defaults:
    executor: gcp-cli/default
    steps:
      - gcp-cli/install
      - gcp-oidc-generate-cred-config-file
      - gcp-oidc-authenticate
      - run:
          name: Verify that gcloud is authenticated
          environment:
            GCP_SERVICE_ACCOUNT_EMAIL: jennings-oidc-test@makoto-workbench.iam.gserviceaccount.com
          command: gcloud iam service-accounts get-iam-policy "${GCP_SERVICE_ACCOUNT_EMAIL}"

workflows:
  main:
    jobs:
      - gcp-oidc-defaults:
          name: Generate Creds File and Authenticate
          context:
          - gcp-oidc-dev    You have the ability to use multiple service accounts from the same GCP project, or multiple service accounts from multiple GCP projects. You can read about these methods and find an example in CircleCI’s  example repository.       Next steps      OpenID Connect tokens with custom claims     Suggest an edit to this pageMake a contribution Learn how to contributeStill need help? Ask the CircleCI community Join the research community Visit our Support site\n\nUsing OpenID Connect tokens in jobs1 week ago9 min readCloudServer v4.4+On This PageOpenID Connect token availabilitySetting up your cloud serviceFormat of the OpenID Connect ID tokenOIDC in open source projectsOIDC on CircleCI serverAuthenticate jobs with cloud providersAWSSet up AWSAdding AWS to the CircleCI configuration fileAdvanced usageLimit role access based on projectLimit role access based on branchGoogle Cloud PlatformSetting up GCPAdding GCP to the CircleCI configuration fileNext steps   CircleCI provides OpenID Connect ID (OIDC) tokens in environment variables. A job can be configured to use these tokens to access compatible cloud services without long-lived credentials being stored in CircleCI.     OpenID Connect token availability   CircleCI OpenID Connect ID tokens are available in the following environment variables:     $CIRCLE_OIDC_TOKEN   $CIRCLE_OIDC_TOKEN_V2 - Includes a different format for the sub claim, See  Format of the OpenID Connect ID token for full details.        What about forks? OIDC tokens will only be generated for forked builds if the Pass secrets to builds from forked pull requests setting is enabled. Find this option at Project settings > Advanced. See  OIDC in open source projects.          Setting up your cloud service   Refer to the documentation for your target cloud service for steps to add an Identity Provider. For example, AWS’s  Creating OpenID Connect (OIDC) identity providers, or Google Cloud Platform’s  Configuring Workload Identity federation.   The  OpenID Provider is unique to your organization. The URL is https://oidc.circleci.com/org/<organization_id>, where organization_id is the organization ID (a universally unique identifier) that represents your organization. You can find your CircleCI organization ID by navigating to Organization Settings > Overview in the  CircleCI web app.   The default OpenID Connect ID tokens issued by CircleCI have a fixed audience (see aud in the table below), which is also the organization ID. To generate tokens with custom audience claims, see the  OIDC tokens with custom claims page.      It is possible to use CircleCI’s OIDC tokens with multiple cloud services.          Format of the OpenID Connect ID token   The OIDC tokens contain the following standard  claims:  ClaimsDescriptionissThe issuer. The issuer is specific to the CircleCI organization in which the job is being run. Its value is "https://oidc.circleci.com/org/<organization_id>", a string, where organization_id is a UUID identifying the current job’s project’s organization.sub The subject. This identifies who is running the CircleCI job and where. $CIRCLE_OIDC_TOKEN_V2 also includes information about the source of change.   For $CIRCLE_OIDC_TOKEN its value is: "org/<organization_id>/project/<project_id>/user/<user_id>", a string, where organization_id, project_id, and user_id are UUIDs that identify the CircleCI organization, project, and user, respectively. The user is the CircleCI user that caused this job to run.   For $CIRCLE_OIDC_TOKEN_V2 its value depends on the  trigger:     If the trigger is an  custom webhook then: "org/<organization_id>/project/<project_id>/user/<user_id>/vcs-origin/<vcs_origin>/vcs-ref/<vcs_ref>", a string, where organization_id, project_id, and user_id are UUIDs that identify the CircleCI organization, project, and user, respectively. The user is the CircleCI user that caused this job to run.   Otherwise it will be: "org/<organization_id>/project/<project_id>/user/<user_id>/vcs-origin/<vcs_origin>/vcs-ref/<vcs_ref>", a string, where organization_id, project_id, and user_id are UUIDs that identify the CircleCI organization, project, and user, respectively. The user is the CircleCI user that caused this job to run. vcs_origin and vcs_ref are strings that identify the repository URL and reference to the change that caused the job to run.   audThe audience. Currently, this is a fixed value "ORGANIZATION_ID", a string containing a UUID that identifies the job’s project’s organization.iatThe time of issuance. This is the time the token was created, which is shortly before the job starts.expThe expiration time. Its value is one hour after the time of issuance.  The OpenID Connect ID tokens also contain some  additional claims with extra metadata about the job:  Additional claimsMetadataoidc.circleci.com/project-idThe ID of the project in which the job is running. Its value is a string containing a UUID identifying the CircleCI project.oidc.circleci.com/vcs-originThe URL of the repository that triggered the pipeline. Its value is a string similar to github.com/organization-123/repo-1. This is not present for pipelines triggered by custom webhooks.oidc.circleci.com/vcs-refThe reference to the change that triggered the pipeline. Its value is a string similar to refs/heads/main. This is not present for pipelines triggered by custom webhooks.oidc.circleci.com/context-idsAn array of strings containing UUIDs that identify the context(s) used in the job. Currently, just one context is supported.oidc.circleci.com/ssh-rerunA boolean indicating if the CI job is started using the SSH rerun feature.    OIDC in open source projects   OIDC tokens will only be generated for forked builds if the Pass secrets to builds from forked pull requests setting is enabled. Find this option at Project settings > Advanced.   If you do allow OIDC tokens to be generated for forks, you must check the oidc.circleci.com/vcs-origin claims in your policies to avoid forked builds having access to resources outside those that you require.   For more information about building open source projects on CircleCI, see the  Build open source projects page.     OIDC on CircleCI server   OIDC is supported from server v4.4+. However, OIDC is not supported if your server installation is in an air-gapped environment.     Authenticate jobs with cloud providers   The following sections describe how to authenticate CircleCI jobs with Amazon Web Services (AWS) and Google Cloud Platform (GCP).   AWS  The following AWS instructions cover the following:     A one-time configuration of your AWS account to trust CircleCI’s OIDC tokens   Running a job that uses the OIDC token to interact with AWS     Also see the  Pull an image from AWS ECR with OIDC how-to guide, which follows on from this setup section.   Set up AWS  You will need to allow your AWS account to trust CircleCI’s OpenID Connect tokens. To do this, create an Identity and Access Management (IAM) Identity Provider, and an IAM role in AWS. Creating the Identity Provider is a one-time configuration to get set up, and then you can decide how to manage the associated role(s). You can update the role permissions, using policies, to fit your use cases, or you can create roles specific to each use.     Visit the  Creating OpenID Connect (OIDC) identity providers page of the AWS docs and follow the instructions. There are multiple setup options covered on this page, including using the management console, or CLI. You will need to provide the following:    Provider URL: Enter https://oidc.circleci.com/org/<your-organization-id>, where your-organization-id is the ID of your CircleCI organization.   Audience: Enter your organization ID      To find your organization/user ID, select Organization Settings in the CircleCI web app side bar.                Once your have created your Identity Provider, a banner appears at the top of the AWS console with the option to Assign role. Select this button to create a new role, or visit the  Creating a role for web identity or OIDC section of the AWS docs and follow the steps there. You will need to select the following:    The Identity Provider that you just created.   For Audience, choose the only option, which is your organization ID that you entered earlier.   On the Add Permissions page you can specify what your CircleCI jobs can and cannot do. Choose only permissions that your job will need. This is an  AWS best practice. You can also write your own policies to lock down permissions to exactly what you need for a specific use case.         Adding AWS to the CircleCI configuration file  Now that you have set up your trusted Identity Provider and IAM role, you are ready to write a CircleCI job that authenticates with AWS using OIDC. This is accomplished using CircleCI’s  AWS CLI orb to generate temporary keys and configure a profile that uses OIDC.      Orbs are reusable packages of YAML configuration that condense repeated pieces of configuration into a single line of code. In this case, the AWS CLI orb enables you to generate a temporary session token, AWS Access Key ID, and AWS secret access key with a single command in your configuration.          In your .circleci/config, import the aws-cli orb.   version: 2.1

orbs:
  aws-cli: circleci/aws-cli@3.1.5     Configure your job to run the aws-cli/setup command before interacting with any AWS services. You will need to provide the aws-cli/setup command with the role-arn associated with the role you have created in the step above along with your aws-region.   jobs:
  aws-example:
    environment:
      AWS_REGION: us-west-1
    docker:
      - image: cimg/aws:2023.06
    steps:
      - checkout
      # run the aws-cli/setup command from the orb
      - aws-cli/setup:
          role-arn: "arn:aws:iam::123456789012:role/OIDC-ROLE"
          aws-region: ${AWS_REGION}
          # optional parameters
          profile-name: "OIDC-PROFILE"
          role-session-name: "example-session"
          session-duration: "1800"    You can optionally provide a profile-name, role-session-name, and session-duration. If you provide a profile-name, the temporary keys and token will be configured to that specific profile. You must use that same profile-name with the rest of your AWS commands. If a profile-name is not provided, the keys and token will be configured to the default profile.   Additionally, if you do not provide a role-session-name or session-duration, their default values are ${CIRCLE_JOB} (your job’s name) and 3600 seconds respectively.      Below is an example of a complete configuration with a job that configures a profile with OIDC and uses it to log into AWS ECR. The same profile can be used to run other AWS commands, such as S3, EKS, ECS, and more, as long as the role-arn has been configured with appropriate permissions.    version: 2.1

orbs:
  aws-cli: circleci/aws-cli@5.1.1

jobs:
  aws-example:
    environment:
      AWS_REGION: us-west-1
    docker:
      - image: cimg/aws:2022.06
    steps:
      - checkout
      # run the aws-cli/setup command from the orb
      - aws-cli/setup:
          role_arn: "arn:aws:iam::123456789012:role/OIDC-ROLE"
          region: AWS_REGION
          # optional parameters
          profile_name: "OIDC-PROFILE"
          role_session_name: "example-session"
          session_duration: "1800"
      - run:
        name: Log-into-AWS-ECR
        command: |
          # must use same profile specified in the step above
          aws ecr get-login-password --profile "OIDC-PROFILE"
workflows:
  OIDC-with-AWS:
    jobs:
      - aws-example:
          context: aws     Advanced usage  You can take advantage of the format of the claims in CircleCI’s  OIDC token to limit what your CircleCI jobs can do in AWS.   Limit role access based on project  If certain projects should only be able to access certain AWS resources, you can restrict your IAM role so that only CircleCI jobs in a specific project can assume that role.   To do this, edit your IAM role’s trust policy so that only an OIDC token from your chosen project can assume that role. The trust policy determines under what conditions the role can be assumed.     Go to an individual project’s page in the  CircleCI web app and navigate to Project Settings > Overview to find your Project ID.   Add the following condition to your role’s trust policy, so that only jobs in your chosen project can assume that role. Enter your Organization ID for organization_id and your Project ID for project_id.   "StringLike": {
  "oidc.circleci.com/org/<organization_id>:sub": "org/<organization_id>/project/<project_id>/user/*"
}    This uses  StringLike to match the sub claim of CircleCI’s OIDC token in your chosen project. Now, jobs in your other projects cannot assume this role.       Limit role access based on branch  You can also restrict access to specific branches. The following is an example of a trust policy that restricts the AssumeRoleWithWebIdentity action to any project pipelines running only on the main branch in the my-org GitHub organization and the CircleCI organization with the ID: organization_id. Note that the sub claim uses the $CIRCLE_OIDC_TOKEN_V2 format.    {
    "Version": "2012-10-17",
    "Statement": [
        {
            "Effect": "Allow",
            "Principal": {
                "Federated": "arn:aws:iam::123456789012:oidc-provider/oidc.circleci.com/org/<organization_id>"
            },
            "Action": "sts:AssumeRoleWithWebIdentity",
            "Condition": {
                "StringLike": {
                    "oidc.circleci.com/org/<organization_id>:sub": "org/<organization_id>/project/*/user/*/vcs-origin/github.com/my-org/*/vcs-ref/refs/heads/main"
                }
            }
        }
    ]
}       Google Cloud Platform  The following GCP instructions are for:     A one-time configuration of your GCP settings to trust CircleCI’s OIDC tokens   Running a job that uses the OIDC token to interact with GCP     The Google Cloud CLI reads your configuration file, which contains necessary information instructing Google Cloud to authenticate. You can read about external identity providers on  Google Cloud’s docs.   Setting up GCP  The GCP configuration file can be set up using the GCP web UI. In the Workload Identity Federation UI, navigate to Grant Access, which will prompt the configuration, which can then be downloaded. You will need to create a file named CIRCLE_OIDC_TOKEN_FILE, which Google Cloud will read your identity token from (the file name can be anything, as long as it matches what is in the configuration under credential_source).   You will need your CircleCI organization ID, which can be found by navigating to Organization Settings > Overview on the  CircleCI web app.   After navigating to the Grant Access section of the GCP web UI, follow these steps to add CircleCI as an external Identity Provider:     Navigate to the IAM & Admin panel.   On the side panel, navigate to Workload Identity Federation.   Select Add Provider.   Select OpenID Connect (OIDC) from the "Select a provider" dropdown and select Save.   Fill out the Provider details form.    Select Allowed audiences since the aud claim in the JSON Web Token is a UUID (your CircleCI organization ID). The audience will be your CircleCI organization ID.   The issuer is https://oidc.circleci.com/org/<organization_id>, where organization_id is your CircleCI organization ID.      Select Continue to configure provider attributes.  Configuring the provider attributes provides an opportunity to map claims in CircleCI’s Token to Google’s "understanding". Use this mapping:  google.subjectassertion.subattribute.org_idassertion.audattribute.projectassertion['oidc.circleci.com/project-id']   Navigate to Service Account in the IAM & Admin Panel to create a service account, and give appropriate permission.   Navigate back to Workload Identity Federation and select the provider from the table.   Select Grant access.   A modal will open and you will select the service account you created from the dropdown. This is the account that the token will impersonate, which grants all the associated permissions.   Under Select principals, you can add conditions, or leave the default.   Select Save. A pop-up will appear to ask you configure and download the configuration file. This file can also be downloaded later by navigating to Connected Service Accounts.   Save the downloaded configuration file in your repository. This file will be referenced in your CircleCI configuration.     An example of the configuration file is shown below. Note, the audience has not been set up yet with the following:     project_number (the unique identifying number generated for your project)   pool_id (an ID that references the Workload Identity pool, for example circleci_oidc)   provider_id (an ID that references the Workload Identity pool provider, for example, circleci)       {
  "type": "external_account",
  "audience": "//iam.googleapis.com/projects/<project_number>/locations/global/workloadIdentityPools/<pool_id>/providers/<provider_id>",
  "subject_token_type": "urn:ietf:params:oauth:token-type:jwt",
  "token_url": "https://sts.googleapis.com/v1/token",
  "service_account_impersonation_url": "https://iamcredentials.googleapis.com/v1/projects/-/serviceAccounts/circleci-test@incubator-344312.iam.gserviceaccount.com:generateAccessToken",
  "credential_source": {
    "file": "CIRCLE_OIDC_TOKEN_FILE",
    "format": {
      "type": "text"
    }
  }
}    In this configuration, credential_source will attempt to find your identity token in the CIRCLE_OIDC_TOKEN_FILE, as noted in the ( token availability section).   If your token comes from an API response, it might be useful to set up the configuration to read a JSON file. In this case, the type will need to be set to json and you will need to provide a valid path, for example, response.id_token.      "credential_source": {
    "file": "CIRCLE_OIDC_TOKEN_FILE",
    "format": {
      "type": "json",
      "path": "response.id_token"
    }
  }       If needed, you can also attempt to generate the GCP configuration file by running the following script:         gcloud iam workload-identity-pools create-cred-config \
  "${GCP_WORKLOAD_IDENTITY_POOL_AUDIENCE}" \
  --output-file="${GCP_CREDENTIAL_CONFIGURATION_FILE}" \
  --service-account="${GCP_SERVICE_ACCOUNT_EMAIL}" \
  --credential-source-file="${GCP_CREDENTIAL_SOURCE_FILE}"     Adding GCP to the CircleCI configuration file  You will need to export the $CIRCLE_OIDC_TOKEN to the file named CIRCLE_OIDC_TOKEN_FILE by running the following:    echo $CIRCLE_OIDC_TOKEN >> CIRCLE_OIDC_TOKEN_FILE    You will also need to add the following environment variables to a  context.  Context var nameExample valueNotesGCP_PROJECT_ID123456789012 GCP project numberGCP_WIP_IDmyworkloadpoolid Workload Identity pool IDGCP_WIP_PROVIDER_IDmyproviderid Workload Identity pool provider nameGCP_SERVICE_ACCOUNT_EMAILmyserviceacct@myproject.iam.gserviceaccount.com User-managed Service Accounts  Below is a full example configuration adding GCP to a job and demonstrating that authentication works with the gcp-oidc-authenticate command. This example uses the  circleci/gcp-cli orb. Note that you can enable the use of OIDC token when using circleci/gcp-cli orb version 3.0.0 or later.    version: 2.1

orbs:
  gcp-cli: circleci/gcp-cli@2.4.1

commands:
  gcp-oidc-generate-cred-config-file:
    description: "Authenticate with GCP using a CircleCI OIDC token."
    parameters:
      project_id:
        type: env_var_name
        default: GCP_PROJECT_ID
      workload_identity_pool_id:
        type: env_var_name
        default: GCP_WIP_ID
      workload_identity_pool_provider_id:
        type: env_var_name
        default: GCP_WIP_PROVIDER_ID
      service_account_email:
        type: env_var_name
        default: GCP_SERVICE_ACCOUNT_EMAIL
      gcp_cred_config_file_path:
        type: string
        default: /home/circleci/gcp_cred_config.json
      oidc_token_file_path:
        type: string
        default: /home/circleci/oidc_token.json
    steps:
      - run:
          command: |
            # Store OIDC token in temp file
            echo $CIRCLE_OIDC_TOKEN > << parameters.oidc_token_file_path >>
            # Create a credential configuration for the generated OIDC ID Token
            gcloud iam workload-identity-pools create-cred-config \
                "projects/${<< parameters.project_id >>}/locations/global/workloadIdentityPools/${<< parameters.workload_identity_pool_id >>}/providers/${<< parameters.workload_identity_pool_provider_id >>}"\
                --output-file="<< parameters.gcp_cred_config_file_path >>" \
                --service-account="${<< parameters.service_account_email >>}" \
                --credential-source-file=<< parameters.oidc_token_file_path >>

  gcp-oidc-authenticate:
    description: "Authenticate with GCP using a GCP credentials file."
    parameters:
      gcp_cred_config_file_path:
        type: string
        default: /home/circleci/gcp_cred_config.json
    steps:
      - run:
          command: |
            # Configure gcloud to leverage the generated credential configuration
            gcloud auth login --brief --cred-file "<< parameters.gcp_cred_config_file_path >>"
            # Configure ADC
            echo "export GOOGLE_APPLICATION_CREDENTIALS='<< parameters.gcp_cred_config_file_path >>'" | tee -a "$BASH_ENV"

jobs:
  gcp-oidc-defaults:
    executor: gcp-cli/default
    steps:
      - gcp-cli/install
      - gcp-oidc-generate-cred-config-file
      - gcp-oidc-authenticate
      - run:
          name: Verify that gcloud is authenticated
          environment:
            GCP_SERVICE_ACCOUNT_EMAIL: jennings-oidc-test@makoto-workbench.iam.gserviceaccount.com
          command: gcloud iam service-accounts get-iam-policy "${GCP_SERVICE_ACCOUNT_EMAIL}"

workflows:
  main:
    jobs:
      - gcp-oidc-defaults:
          name: Generate Creds File and Authenticate
          context:
          - gcp-oidc-dev    You have the ability to use multiple service accounts from the same GCP project, or multiple service accounts from multiple GCP projects. You can read about these methods and find an example in CircleCI’s  example repository.       Next steps      OpenID Connect tokens with custom claims     Suggest an edit to this pageMake a contribution Learn how to contributeStill need help? Ask the CircleCI community Join the research community Visit our Support site DocsTerms of UsePrivacy PolicyCookie PolicySecurity© 2025 Circle Internet Services, Inc., All Rights Reserved.\n\nWhat about forks? OIDC tokens will only be generated for forked builds if the Pass secrets to builds from forked pull requests setting is enabled. Find this option at Project settings > Advanced. See  OIDC in open source projects.  It is possible to use CircleCI’s OIDC tokens with multiple cloud services.  The subject. This identifies who is running the CircleCI job and where. $CIRCLE_OIDC_TOKEN_V2 also includes information about the source of change.   For $CIRCLE_OIDC_TOKEN its value is: "org/<organization_id>/project/<project_id>/user/<user_id>", a string, where organization_id, project_id, and user_id are UUIDs that identify the CircleCI organization, project, and user, respectively. The user is the CircleCI user that caused this job to run.   For $CIRCLE_OIDC_TOKEN_V2 its value depends on the  trigger:     If the trigger is an  custom webhook then: "org/<organization_id>/project/<project_id>/user/<user_id>/vcs-origin/<vcs_origin>/vcs-ref/<vcs_ref>", a string, where organization_id, project_id, and user_id are UUIDs that identify the CircleCI organization, project, and user, respectively. The user is the CircleCI user that caused this job to run.   Otherwise it will be: "org/<organization_id>/project/<project_id>/user/<user_id>/vcs-origin/<vcs_origin>/vcs-ref/<vcs_ref>", a string, where organization_id, project_id, and user_id are UUIDs that identify the CircleCI organization, project, and user, respectively. The user is the CircleCI user that caused this job to run. vcs_origin and vcs_ref are strings that identify the repository URL and reference to the change that caused the job to run.     To find your organization/user ID, select Organization Settings in the CircleCI web app side bar.      Orbs are reusable packages of YAML configuration that condense repeated pieces of configuration into a single line of code. In this case, the AWS CLI orb enables you to generate a temporary session token, AWS Access Key ID, and AWS secret access key with a single command in your configuration.  version: 2.1

orbs:
  aws-cli: circleci/aws-cli@3.1.5  jobs:
  aws-example:
    environment:
      AWS_REGION: us-west-1
    docker:
      - image: cimg/aws:2023.06
    steps:
      - checkout
      # run the aws-cli/setup command from the orb
      - aws-cli/setup:
          role-arn: "arn:aws:iam::123456789012:role/OIDC-ROLE"
          aws-region: ${AWS_REGION}
          # optional parameters
          profile-name: "OIDC-PROFILE"
          role-session-name: "example-session"
          session-duration: "1800"  version: 2.1

orbs:
  aws-cli: circleci/aws-cli@5.1.1

jobs:
  aws-example:
    environment:
      AWS_REGION: us-west-1
    docker:
      - image: cimg/aws:2022.06
    steps:
      - checkout
      # run the aws-cli/setup command from the orb
      - aws-cli/setup:
          role_arn: "arn:aws:iam::123456789012:role/OIDC-ROLE"
          region: AWS_REGION
          # optional parameters
          profile_name: "OIDC-PROFILE"
          role_session_name: "example-session"
          session_duration: "1800"
      - run:
        name: Log-into-AWS-ECR
        command: |
          # must use same profile specified in the step above
          aws ecr get-login-password --profile "OIDC-PROFILE"
workflows:
  OIDC-with-AWS:
    jobs:
      - aws-example:
          context: aws  "StringLike": {
  "oidc.circleci.com/org/<organization_id>:sub": "org/<organization_id>/project/<project_id>/user/*"
}  {
    "Version": "2012-10-17",
    "Statement": [
        {
            "Effect": "Allow",
            "Principal": {
                "Federated": "arn:aws:iam::123456789012:oidc-provider/oidc.circleci.com/org/<organization_id>"
            },
            "Action": "sts:AssumeRoleWithWebIdentity",
            "Condition": {
                "StringLike": {
                    "oidc.circleci.com/org/<organization_id>:sub": "org/<organization_id>/project/*/user/*/vcs-origin/github.com/my-org/*/vcs-ref/refs/heads/main"
                }
            }
        }
    ]
}   {
  "type": "external_account",
  "audience": "//iam.googleapis.com/projects/<project_number>/locations/global/workloadIdentityPools/<pool_id>/providers/<provider_id>",
  "subject_token_type": "urn:ietf:params:oauth:token-type:jwt",
  "token_url": "https://sts.googleapis.com/v1/token",
  "service_account_impersonation_url": "https://iamcredentials.googleapis.com/v1/projects/-/serviceAccounts/circleci-test@incubator-344312.iam.gserviceaccount.com:generateAccessToken",
  "credential_source": {
    "file": "CIRCLE_OIDC_TOKEN_FILE",
    "format": {
      "type": "text"
    }
  }
}    "credential_source": {
    "file": "CIRCLE_OIDC_TOKEN_FILE",
    "format": {
      "type": "json",
      "path": "response.id_token"
    }
  }  If needed, you can also attempt to generate the GCP configuration file by running the following script:  gcloud iam workload-identity-pools create-cred-config \
  "${GCP_WORKLOAD_IDENTITY_POOL_AUDIENCE}" \
  --output-file="${GCP_CREDENTIAL_CONFIGURATION_FILE}" \
  --service-account="${GCP_SERVICE_ACCOUNT_EMAIL}" \
  --credential-source-file="${GCP_CREDENTIAL_SOURCE_FILE}"  echo $CIRCLE_OIDC_TOKEN >> CIRCLE_OIDC_TOKEN_FILE  version: 2.1

orbs:
  gcp-cli: circleci/gcp-cli@2.4.1

commands:
  gcp-oidc-generate-cred-config-file:
    description: "Authenticate with GCP using a CircleCI OIDC token."
    parameters:
      project_id:
        type: env_var_name
        default: GCP_PROJECT_ID
      workload_identity_pool_id:
        type: env_var_name
        default: GCP_WIP_ID
      workload_identity_pool_provider_id:
        type: env_var_name
        default: GCP_WIP_PROVIDER_ID
      service_account_email:
        type: env_var_name
        default: GCP_SERVICE_ACCOUNT_EMAIL
      gcp_cred_config_file_path:
        type: string
        default: /home/circleci/gcp_cred_config.json
      oidc_token_file_path:
        type: string
        default: /home/circleci/oidc_token.json
    steps:
      - run:
          command: |
            # Store OIDC token in temp file
            echo $CIRCLE_OIDC_TOKEN > << parameters.oidc_token_file_path >>
            # Create a credential configuration for the generated OIDC ID Token
            gcloud iam workload-identity-pools create-cred-config \
                "projects/${<< parameters.project_id >>}/locations/global/workloadIdentityPools/${<< parameters.workload_identity_pool_id >>}/providers/${<< parameters.workload_identity_pool_provider_id >>}"\
                --output-file="<< parameters.gcp_cred_config_file_path >>" \
                --service-account="${<< parameters.service_account_email >>}" \
                --credential-source-file=<< parameters.oidc_token_file_path >>

  gcp-oidc-authenticate:
    description: "Authenticate with GCP using a GCP credentials file."
    parameters:
      gcp_cred_config_file_path:
        type: string
        default: /home/circleci/gcp_cred_config.json
    steps:
      - run:
          command: |
            # Configure gcloud to leverage the generated credential configuration
            gcloud auth login --brief --cred-file "<< parameters.gcp_cred_config_file_path >>"
            # Configure ADC
            echo "export GOOGLE_APPLICATION_CREDENTIALS='<< parameters.gcp_cred_config_file_path >>'" | tee -a "$BASH_ENV"

jobs:
  gcp-oidc-defaults:
    executor: gcp-cli/default
    steps:
      - gcp-cli/install
      - gcp-oidc-generate-cred-config-file
      - gcp-oidc-authenticate
      - run:
          name: Verify that gcloud is authenticated
          environment:
            GCP_SERVICE_ACCOUNT_EMAIL: jennings-oidc-test@makoto-workbench.iam.gserviceaccount.com
          command: gcloud iam service-accounts get-iam-policy "${GCP_SERVICE_ACCOUNT_EMAIL}"

workflows:
  main:
    jobs:
      - gcp-oidc-defaults:
          name: Generate Creds File and Authenticate
          context:
          - gcp-oidc-dev\n\n\n\nConfig policies overview1 week ago11 min readCloudServer v4+On This PageIntroductionQuickstartHow config policies workUse the CLI with config policiesWriting Rego policies using CircleCI domain-specific languagePackage and nameRulesDefine a ruleEvaluationEnforcementEnablementUsing pipeline metadataConfig policies with parameterization and reusable configExamplePolicing config 2.1 constructsAllowlists vs banlists with parameterizationUse sets and variablesTesting policiesConfig policies and dynamic configurationExample policyNext steps      The config policies feature is available on the Scale Plan and from CircleCI server v4.2. You must be an organization admin in order to create and manage config policies.        Use config policies to create organization-level policies to impose rules and scopes to govern which configuration elements are required, allowed, not allowed etc.     Introduction   Config policies allow you to create policies for governing CircleCI project configurations. In its strictest case, if a project configuration does not comply with the rules set out in the associated policy, that project’s pipelines cannot be triggered until it does comply.   CircleCI uses config.yml files to define CI/CD pipelines at the project level. This is a convenient way of developing and iterating quickly, as each pipeline can be made to meet the needs of the project as it grows. However, it can be difficult to manage and enforce organization-wide conventions and security policies. Config policies adds in this layer of control.   Config policy decisions are stored, and can be audited. This provides useful data about the pipeline definitions being run within your organization.     Quickstart   If you already have a  CircleCI account connected to your VCS, and you would like to get started with config policies right away, check out the steps in the  Create a policy how-to guide to get started.   The following how-to guides are available for config policies:      Create and manage config policies    Test config policies    Use the CLI for config and policy development    Config policies for self-hosted runner       How config policies work   Config policies use a decision engine based on  Open Policy Agent (OPA). Policies are written in the Rego query language, as defined by OPA. Rule violations are surfaced when pipeline triggers are applied.   Policies can be developed locally and pushed to CircleCI using the CircleCI CLI. Policies can be saved to a repository within your VCS. For more information see the  Create and manage config policies page.   CircleCI uses the result of OPA output to generate decisions from policy executions. Those decisions have the following outputs:    status:           PASS | SOFT_FAIL | HARD_FAIL | ERROR
reason:           string                                      (optional, only present when status is ERROR)
enabled_rules:    Array<string>
soft_failures:    Array<{ rule: string, reason: string }>
hard_failures:    Array<{ rule: string, reason: string }>    The decision result tracks which rules were included in the making of the decision, and any violations, both soft and hard, that were found.     Use the CLI with config policies       Using server? When using the circleci policy commands with CircleCI server, you will need to use the policy-base-url flag to provide your CircleCI server domain. For example:    circleci policy settings --enabled=true --owner-id <your-organization-ID> --policy-base-url <your-circleci-server-domain>          Use the CircleCI CLI to manage your organization’s policies programmatically. Config policies sub-commands are grouped under the circleci policy command.   The following config policies sub-commands are currently supported within the CLI:     diff - shows the difference between local and remote policy bundles   fetch - fetches the policy bundle (or one policy, based on name) from remote   push - pushes the policy bundle (activate policy bundle)  For example, running the following command activates a policy bundle stored at ./policy_bundle_dir_path:    circleci policy push ./policy_bundle_dir_path --owner-id <your-organization-ID>     settings - used to modify config policies settings as required.  When the settings sub-command is called without any flags, current settings are fetched and printed on console.    circleci policy settings --owner-id <your-organization-ID>    Example output:    {
  "enabled": false
}     test - used to run tests on your policies.  For example, running the following command runs all defined tests in the policies directory:    circleci policy test ./policies    Example output:    ok    policies    0.001s

3/3 tests passed (0.001s)           To find your organization/user ID, select Organization Settings in the CircleCI web app side bar.              Writing Rego policies using CircleCI domain-specific language   Policies are written in Rego, a purpose-built declarative policy language that supports OPA. You can find more about Rego in the  rego language docs.   In order for CircleCI to make decisions about your configs, it needs to be able to interpret the output generated when your policies are evaluated. Therefore, policies must be written to meet the CircleCI specifications detailed on this page.   Package and name  All policies must belong to the org package and declare the policy name as the first rule. All policy Rego files should include:    package org

policy_name["unique_policy_name"]    The policy_name is an alphanumeric string with a maximum length of 80 characters. It is used to uniquely identify the policy by name within the system (similar to a Kubernetes named resource). Policy names must be unique. Two policies cannot have the same name within an organization.   The policy_name must be declared using a partial rule and declare the name as a rego key: policy_name["NAME"].    Rules  After declaring the org package and policy_name rule, policies can then be defined as a list of rules. Each rule is composed of three parts:     Evaluation - Evaluates whether the config contains the policy violation.   Enforcement status - Determines how a violation should be enforced.   Enablement - Determines if a policy violation should be enabled.     Using this format allows policy writers to create custom helper functions without impacting CircleCI’s ability to parse policy evaluation output. You can create your own helper functions, but also CircleCI provides a set of helpers by importing data.circleci.config in your policies. For more information, see the  Config policy reference.      Helpers in the context of config policies are rules like any other, but rules that are not individually enabled for the process of determining policy violation. Helpers can be written and used as building blocks for your policies.        Policies all have access to config data through the input variable. The input is the project config being evaluated. Since the input matches the CircleCI config, you can write rules to enforce a desired state on any available config element, for example, jobs or workflows.    input.workflows     # an array of nested structures mirroring workflows in the CircleCI config
input.jobs          # an array of nested structures mirroring jobs in the CircleCI config    Define a rule  In OPA, rules can produce any type of output. At CircleCI, rules that produce violations must have outputs of the following types:     String   String array   Map of string to string     This restriction is in place so that rule violations produce error messages that individual contributors and SecOps can act upon. Helper rules that produce differently typed outputs can still be defined, but rules that will be considered when making CircleCI decisions must have the output types specified above. For more information see the  Enablement section below.   Evaluation  Evaluation is how the decision engine determines if a config violates the given policy. The evaluation defines the name and ID of the rule, checks a condition, and returns a user-friendly string describing the violation. Rule evaluations include the rule name and an optional rule ID. The rule name will be used to enable and set the enforcement level for a rule.    RULE_NAME = reason {
  ... # some comparison
  reason := "..."
}     RULE_NAME[RULE_ID] = reason {
  ... # some comparison
  reason := "..."
}    Here is an example of a simple evaluation that checks that a config includes at least one workflow:    contains_workflows = reason {
    count(input.workflows) > 0
    reason := "config must contain at least one workflow"
}    The rule ID can be used to differentiate between multiple violations of the same rule. For example, if a config uses multiple unofficial Docker images, this might lead to multiple violations of a use_official_docker_image rule. Rule IDs should only be used when multiple violations are expected. In some cases, the customer may only need to know if a rule passes or not. In this case, the rule will not need a rule ID.    use_official_docker_image[image] = reason {
  some image in docker_images   # docker_images are parsed below
  not startswith(image, "circleci")
  not startswith(image, "cimg")
  reason := sprintf("%s is not an approved Docker image", [image])
}

# helper to parse docker images from the config
docker_images := {image | walk(input, [path, value])  # walk the entire config tree
                          path[_] == "docker"         # find any settings that match 'docker'
                          image := value[_].image}    # grab the images from that section     Enforcement  The policy service allows rules to be enforced at different levels.    ENFORCEMENT_STATUS["RULE_NAME"]    The two available enforcement levels are:     hard_fail - If the policy-service detects that the config violated a rule set as hard_fail, the pipeline will not be triggered.   soft_fail - If the policy-service detects that the config violated a rule set as soft_fail, the pipeline will be triggered and the violation will be logged in the policy-service decision log.     An example of setting the use_official_docker_image rule to hard_fail:    hard_fail["use_official_docker_image"]     Enablement  A rule must be enabled for it to be inspected for policy violations. Rules that are not enabled do not need to match CircleCI violation output formats, and can be used as helpers for other rules.    enable_rule["RULE_NAME"]    To enable a rule, add the rule as a key in the enable_rule object. For example, to enable the rule use_official_docker_image, use the following:    enable_rule["use_official_docker_image"]    Use enable_hard to enable a rule and set its enforcement level to hard in a single statement.   The following statements are equivalent:    enable_hard["use_official_docker_image"]     enable_rule["use_official_docker_image"]

hard_fail["use_official_docker_image"]       Using pipeline metadata  When writing policies for CircleCI config, it is often desirable to have policies that vary slightly in behaviour by project or branch. This is possible using the data.meta Rego property.   When a policy is evaluated in the context of a triggered pipeline the following properties will be available on data.meta:     project_id (CircleCI Project UUID)   build_number (number)   ssh_rerun (boolean) - indicates if CI job is started using the SSH rerun feature   vcs.branch (string)   vcs.release_tag (string)   vcs.origin_repository_url (string) - URL to the repository where the commit was made (this will only be different in the case of a forked pull request)   vcs.target_repository_url (string) - URL to the repository building the commit     This metadata can be used to activate/deactivate rules, modify enforcement statuses, and be part of the rule definitions themselves.   The following is an example of a policy that only runs its rule for a single project and enforces it as hard_fail only on branch main.    package org

policy_name["example"]

# specific project UUID
# use care to avoid naming collisions as assignments are global across the entire policy bundle
sample_project_id := "c2af7012-076a-11ed-84e6-f7fa45ad0fd1"

# this rule is enabled only if the body evaluates to true
enable_rule["custom_rule"] { data.meta.project_id == sample_project_id }

# "custom_rule" evaluates to a hard_failure condition only if run in the context of branch main
hard_fail["custom_rule"] { data.meta.vcs.branch == "main" }    The following is an example of a policy that blocks pull request builds from untrusted origins.    package org

import future.keywords

policy_name["forked_pull_requests"]

# this rule is enabled only if the body evaluates to true (origin_repository_url and target_repository_url will be different in case of a forked pull request)
enable_rule["check_forked_builds"] {
	data.meta.vcs.origin_repository_url != data.meta.vcs.target_repository_url
}

# enable hard failure
hard_fail["check_forked_builds"]

check_forked_builds = reason {
	not from_trusted_origin(data.meta.vcs.origin_repository_url)
	reason := sprintf("pipeline triggered from untrusted origin: %s", [data.meta.vcs.origin_repository_url])
}

from_trusted_origin(origin) {
	some trusted_origin in {
		"https://github.com/trusted_org/",
		"https://bitbucket.org/trusted_org/",
	}

	startswith(origin, trusted_origin)
}    The following is an example of a policy that blocks SSH reruns on configs where a job uses sensitive contexts.    package org

import future.keywords
import data.circleci.utils

policy_name["ssh_rerun"]

enable_hard["disallow_ssh_rerun"]

sensitive_contexts := { "secops", "deploy_keys", "access_tokens", "security" }

disallow_ssh_rerun = "Cannot perform ssh_rerun with sensitive contexts" {
    data.meta.ssh_rerun
    some _, job in input.workflows[_].jobs[_]
    count(utils.to_set(job.context) & sensitive_contexts) > 0
}       Config policies with parameterization and reusable config   Writing policies for CircleCI version 2.1 configuration introduces some challenges due to the parameterization and reusable configuration options. To read more about these options, see the  Reusable config reference guide.   Before executing any pipelines, config version 2.1 is compiled into config version 2.0. This compilation expands all parameters and reusable config blocks (jobs, executors, commands, orbs) into workflows and jobs.   To write highly effective policies, it is essential to reference the compiled version of the config (input.compiled).   Example  Consider the following example policy and configuration:   Policy    import future.keywords

policy_name["example_mistake"]

enable_hard["enforce_not_large_resource"]

# check every job in input config, and if any job has resource_class equal to "large" set a violation message.
enforce_not_large_resource[reason] {
  some job_name, job in input.jobs
  job.resource_class == "large"
  reason = sprintf("job %s using banned large resource class", [job_name])
}    Configuration with reusable executor    version: 2.1

executors: # Define reusable executor
  lg-executor:
    docker:
      - image: my-image
    resource_class: large # Resource class configured in reusable executor

jobs:
  test:
    executor: lg-executor
    steps:
      - checkout

workflows:
  my-workflow:
    jobs:
      - test    In the above example, the policy is bypassed and will not trigger. The policy inspects jobs and does not find a resource_class == "large".   This example is problematic because once the configuration is compiled, the job test will have a resource_class == "large".   Another way this policy could be unintentionally bypassed is by using parameters. Consider the following configuration, which uses a parameter to set the resource class for an executor:   Configuration using a parameter    version: 2.1

jobs:
  test:
    docker:
      - image: my-image
    parameters:
      size:
        type: string
    resource_class: << parameters.size >> # parameterized definition of resource_class
    steps:
      - checkout

workflows:
  main:
    jobs:
      - test: # invokation of parameterized job "test" with a size equal to "large".
          size: large    The same situation applies as for the first configuration presented above. The policy inspects the jobs and does not find a resource_class == "large", but instead finds << parameters.size >>, which is acceptable for the policy.   However, once the config is compiled, the job test will have a resource_class == "large".   To resolve both of these issues, it is important to acknowledge that we want to apply the policy to all jobs, which is a configuration version: 2.0 construct, and write the policy to target the compiled version accordingly, as follows:   Policy rule that inspects compiled configuration    # check all jobs in the compiled config and if any use a resource_class equal to "large" return a violation message.
enforce_not_large_resource[reason] {
  some job_name, job in input.compiled.jobs
  job.resource_class == "large"
  reason = sprintf("job %s using banned large resource class", [job_name])
}    Notice the rule now validates input.compiled.jobs. Regardless of parameters or reusable blocks (executors in this example), the policy is applied to all compiled jobs and functions as intended.    Policing config 2.1 constructs  Writing policies against config version 2.1 constructs (orbs, executors, jobs, commands) introduces the same parameterization challenges as described in the previous section. However, we cannot rely on writing policies against the compiled input because these constructs do not exist in configuration version 2.0.   Consider another example to illustrate this:   Policy to ban orbs from a specific namespace    import future.keywords

policy_name["example_mistake"]

enable_hard["ban_bad_orb_namespace"]

# check if any orb is namespaced with `bad`. If so, set a violation message for each of those orbs.
ban_bad_orb_namespace[reason] {
  some key, orb_ref in input.orbs
  startswith(orb_ref, "bad/")
  reason := sprintf("orb %s is defined with a banned namespace: bad", [key])
}    Configuration    version: 2.1

# top level pipeline parameters that can have a default set, or be modified by API based pipeline triggers.
parameters:
  evil_orb:
    type: string
    default: bad/orb

orbs:
  security: << pipeline.parameters.evil_orb >> # parameterized orb definition    In the above example, the rule does not raise a violation because the string << pipeline.parameters.evil_orb >> does not have the bad/ prefix that the policy aims to detect.   We cannot rely on input.compiled because orbs are compiled away at that stage.   The best approach here is to detect if an orb reference is a parameterized expression and raise a violation accordingly. To do this we can use the is_parameterized_expression  helper.   Policy to ban orbs from a specific namespace and detect parameterized orb references    import future.keywords
import data.circleci.config

policy_name["example"]

enable_hard["ban_bad_orb_namespace"]

# checks for orbs that are namespaced in "bad/" and set a violation for each orb.
# also detects and raises a violation for any orb defined with a parameter.
ban_bad_orb_namespace = { reason |
  some key, orb_ref in input.orbs
  startswith(orb_ref, "bad/")
  reason := sprintf("orb %s is defined with a banned namespace: bad", [key])
} | { reason |
  some key, orb_ref in input.orbs
  config.is_parameterized_expression(orb_ref) # helper for detecting parameterized expressions.
  reason := sprintf("orb %s is not allowed to contain a parameterized expression", ["key"])
}     Allowlists vs banlists with parameterization  Policies and their rules can be categorized into two main types:     Allowlists: Assert that the input must match a specific value, or fall within a defined set of values   Banlists: Assert that the input must not match a particular value nor be within a set of prohibited values     When working with configuration version 2.1 constructs and parameterization, it is crucial to understand how these two rule types interact with your policies.     Banlist rules are susceptible to being bypassed using parameterization and reusable constructs. This is because the literal parameter value is unlikely to match the banned value, and during config compilation, the values intended to be banned can be reintroduced. All parameterization examples provided above fall into this category. To address this, you can either utilize input.compiled or detect parameterization and handle it appropriately.   Allowlist rules are incompatible with parameterization. They reject configurations that could otherwise be considered valid but do not cause invalid configurations to pass.     Consider an example to illustrate this:      This example is artificial and for illustration purposes only. The appropriate policy for enforcing job resource classes should target the compiled input (input.compiled). This ensures proper validation against the resolved values.        Policy using an allowlist to restrict resource classes    import future.keywords

policy_name["allowlist"]

enable_hard["restrict_resource_classes"]

# check all jobs in config input and if the job is not "small" or "large" set a violation message.
restrict_resource_classes[reason] {
  some job_name, job in input.jobs
  not job.resource_class in {"small", "large"}
  reason := sprintf("job %s must have resource class of small or large but has: %s", [job_name, job.resource_class])
}    Configuration    version: 2.1

jobs:
  test:
    parameters:
      size:
        type: string
    docker:
      - image: my-image
    resource_class: << parameters.size >>
    steps:
      - checkout

workflows:
  main:
    jobs:
      - test:
          size: small    The rule (restrict_resource_classes) raises a violation because << parameters.size >> does not conform to the allowlist values of small or large. Even if this configuration would compile to a job that uses the correct small resource class, the violation is still triggered.   When working with allowlist-type rules, it is essential to recognize how they can restrict parameterization, so you can strike the right balance between configurational reusability and rule enforcement.      Use sets and variables   It is best practice to avoid hard coding values in code, and the same goes for your config policies. Hard coding data, such as project IDs, makes it difficult to read code, and can be confusing when collaborating with wider team members ("what is 99ada477-7029-44bb-b675-5b2d6448d1ab?"). Because using rego means your policies are defined in code, you can define sets and variables in rego files external to your individual policies, and reference these sets and variables across multiple policies. For an example of this in practice, see the  Manage contexts with config policies page.   For further reading, see the  Config policies blog post.     Testing policies   It is important to be able to deploy new policies with confidence, knowing how they will be applied, and the decisions they will generate ahead of time. To enable this process, the circleci policy test command is available. The test subcommand is inspired by the golang and OPA test commands. For more information on setting up testing, see the  Test config policies guide.   The circleci policy test command is intended for testing the validity of the policy when adding and updating your config policies only within your config policy repo. Usage outside of adding/updating your config policy repo could result in false responses resulting from race conditions when reading and writing to the config policy service at the same time.     Config policies and dynamic configuration   You can write config policies to govern projects that use dynamic configuration too. Policies are evaluated against:     Setup configurations   Continuation configurations   Standard configurations     If required for your project, you can encode rules to apply only to setup configs, or only to non-setup configs, as follows:    enable_hard["setup_rule"] { input.setup } # only applied to configs with `setup: true`     enable_hard["not_setup_rule"] { not input.setup } # only applied to configs that do not have `setup: true`     enable_hard["some_rule"] # rule applied to all configs    For more information about dynamic configuration, see the  Dynamic configuration overview.     Example policy   The following is an example of a complete policy with one rule, use_official_docker_image, which checks that all Docker images in a config are prefixed by circleci or cimg. It uses some helper code to find all the docker_images in the config. It then sets the enforcement status of use_official_docker_image to hard_fail and enables the rule.   This example also imports future.keywords, for more information see the  OPA docs.    package org

import future.keywords

policy_name["example"]

use_official_docker_image[image] = reason {
  some image in docker_images   # docker_images are parsed below
  not startswith(image, "circleci")
  not startswith(image, "cimg")
  reason := sprintf("%s is not an approved Docker image", [image])
}

# helper to parse docker images from the config
docker_images := {image | walk(input, [path, value])  # walk the entire config tree
                          path[_] == "docker"         # find any settings that match 'docker'
                          image := value[_].image}    # grab the images from that section

enable_hard["use_official_docker_image"]      Next steps      Create and manage config policies    Test config policies    Use the CircleCI CLI for config and policy development    Config policy reference     Suggest an edit to this pageMake a contribution Learn how to contributeStill need help? Ask the CircleCI community Join the research community Visit our Support site\n\nConfig policies overview1 week ago11 min readCloudServer v4+On This PageIntroductionQuickstartHow config policies workUse the CLI with config policiesWriting Rego policies using CircleCI domain-specific languagePackage and nameRulesDefine a ruleEvaluationEnforcementEnablementUsing pipeline metadataConfig policies with parameterization and reusable configExamplePolicing config 2.1 constructsAllowlists vs banlists with parameterizationUse sets and variablesTesting policiesConfig policies and dynamic configurationExample policyNext steps      The config policies feature is available on the Scale Plan and from CircleCI server v4.2. You must be an organization admin in order to create and manage config policies.        Use config policies to create organization-level policies to impose rules and scopes to govern which configuration elements are required, allowed, not allowed etc.     Introduction   Config policies allow you to create policies for governing CircleCI project configurations. In its strictest case, if a project configuration does not comply with the rules set out in the associated policy, that project’s pipelines cannot be triggered until it does comply.   CircleCI uses config.yml files to define CI/CD pipelines at the project level. This is a convenient way of developing and iterating quickly, as each pipeline can be made to meet the needs of the project as it grows. However, it can be difficult to manage and enforce organization-wide conventions and security policies. Config policies adds in this layer of control.   Config policy decisions are stored, and can be audited. This provides useful data about the pipeline definitions being run within your organization.     Quickstart   If you already have a  CircleCI account connected to your VCS, and you would like to get started with config policies right away, check out the steps in the  Create a policy how-to guide to get started.   The following how-to guides are available for config policies:      Create and manage config policies    Test config policies    Use the CLI for config and policy development    Config policies for self-hosted runner       How config policies work   Config policies use a decision engine based on  Open Policy Agent (OPA). Policies are written in the Rego query language, as defined by OPA. Rule violations are surfaced when pipeline triggers are applied.   Policies can be developed locally and pushed to CircleCI using the CircleCI CLI. Policies can be saved to a repository within your VCS. For more information see the  Create and manage config policies page.   CircleCI uses the result of OPA output to generate decisions from policy executions. Those decisions have the following outputs:    status:           PASS | SOFT_FAIL | HARD_FAIL | ERROR
reason:           string                                      (optional, only present when status is ERROR)
enabled_rules:    Array<string>
soft_failures:    Array<{ rule: string, reason: string }>
hard_failures:    Array<{ rule: string, reason: string }>    The decision result tracks which rules were included in the making of the decision, and any violations, both soft and hard, that were found.     Use the CLI with config policies       Using server? When using the circleci policy commands with CircleCI server, you will need to use the policy-base-url flag to provide your CircleCI server domain. For example:    circleci policy settings --enabled=true --owner-id <your-organization-ID> --policy-base-url <your-circleci-server-domain>          Use the CircleCI CLI to manage your organization’s policies programmatically. Config policies sub-commands are grouped under the circleci policy command.   The following config policies sub-commands are currently supported within the CLI:     diff - shows the difference between local and remote policy bundles   fetch - fetches the policy bundle (or one policy, based on name) from remote   push - pushes the policy bundle (activate policy bundle)  For example, running the following command activates a policy bundle stored at ./policy_bundle_dir_path:    circleci policy push ./policy_bundle_dir_path --owner-id <your-organization-ID>     settings - used to modify config policies settings as required.  When the settings sub-command is called without any flags, current settings are fetched and printed on console.    circleci policy settings --owner-id <your-organization-ID>    Example output:    {
  "enabled": false
}     test - used to run tests on your policies.  For example, running the following command runs all defined tests in the policies directory:    circleci policy test ./policies    Example output:    ok    policies    0.001s

3/3 tests passed (0.001s)           To find your organization/user ID, select Organization Settings in the CircleCI web app side bar.              Writing Rego policies using CircleCI domain-specific language   Policies are written in Rego, a purpose-built declarative policy language that supports OPA. You can find more about Rego in the  rego language docs.   In order for CircleCI to make decisions about your configs, it needs to be able to interpret the output generated when your policies are evaluated. Therefore, policies must be written to meet the CircleCI specifications detailed on this page.   Package and name  All policies must belong to the org package and declare the policy name as the first rule. All policy Rego files should include:    package org

policy_name["unique_policy_name"]    The policy_name is an alphanumeric string with a maximum length of 80 characters. It is used to uniquely identify the policy by name within the system (similar to a Kubernetes named resource). Policy names must be unique. Two policies cannot have the same name within an organization.   The policy_name must be declared using a partial rule and declare the name as a rego key: policy_name["NAME"].    Rules  After declaring the org package and policy_name rule, policies can then be defined as a list of rules. Each rule is composed of three parts:     Evaluation - Evaluates whether the config contains the policy violation.   Enforcement status - Determines how a violation should be enforced.   Enablement - Determines if a policy violation should be enabled.     Using this format allows policy writers to create custom helper functions without impacting CircleCI’s ability to parse policy evaluation output. You can create your own helper functions, but also CircleCI provides a set of helpers by importing data.circleci.config in your policies. For more information, see the  Config policy reference.      Helpers in the context of config policies are rules like any other, but rules that are not individually enabled for the process of determining policy violation. Helpers can be written and used as building blocks for your policies.        Policies all have access to config data through the input variable. The input is the project config being evaluated. Since the input matches the CircleCI config, you can write rules to enforce a desired state on any available config element, for example, jobs or workflows.    input.workflows     # an array of nested structures mirroring workflows in the CircleCI config
input.jobs          # an array of nested structures mirroring jobs in the CircleCI config    Define a rule  In OPA, rules can produce any type of output. At CircleCI, rules that produce violations must have outputs of the following types:     String   String array   Map of string to string     This restriction is in place so that rule violations produce error messages that individual contributors and SecOps can act upon. Helper rules that produce differently typed outputs can still be defined, but rules that will be considered when making CircleCI decisions must have the output types specified above. For more information see the  Enablement section below.   Evaluation  Evaluation is how the decision engine determines if a config violates the given policy. The evaluation defines the name and ID of the rule, checks a condition, and returns a user-friendly string describing the violation. Rule evaluations include the rule name and an optional rule ID. The rule name will be used to enable and set the enforcement level for a rule.    RULE_NAME = reason {
  ... # some comparison
  reason := "..."
}     RULE_NAME[RULE_ID] = reason {
  ... # some comparison
  reason := "..."
}    Here is an example of a simple evaluation that checks that a config includes at least one workflow:    contains_workflows = reason {
    count(input.workflows) > 0
    reason := "config must contain at least one workflow"
}    The rule ID can be used to differentiate between multiple violations of the same rule. For example, if a config uses multiple unofficial Docker images, this might lead to multiple violations of a use_official_docker_image rule. Rule IDs should only be used when multiple violations are expected. In some cases, the customer may only need to know if a rule passes or not. In this case, the rule will not need a rule ID.    use_official_docker_image[image] = reason {
  some image in docker_images   # docker_images are parsed below
  not startswith(image, "circleci")
  not startswith(image, "cimg")
  reason := sprintf("%s is not an approved Docker image", [image])
}

# helper to parse docker images from the config
docker_images := {image | walk(input, [path, value])  # walk the entire config tree
                          path[_] == "docker"         # find any settings that match 'docker'
                          image := value[_].image}    # grab the images from that section     Enforcement  The policy service allows rules to be enforced at different levels.    ENFORCEMENT_STATUS["RULE_NAME"]    The two available enforcement levels are:     hard_fail - If the policy-service detects that the config violated a rule set as hard_fail, the pipeline will not be triggered.   soft_fail - If the policy-service detects that the config violated a rule set as soft_fail, the pipeline will be triggered and the violation will be logged in the policy-service decision log.     An example of setting the use_official_docker_image rule to hard_fail:    hard_fail["use_official_docker_image"]     Enablement  A rule must be enabled for it to be inspected for policy violations. Rules that are not enabled do not need to match CircleCI violation output formats, and can be used as helpers for other rules.    enable_rule["RULE_NAME"]    To enable a rule, add the rule as a key in the enable_rule object. For example, to enable the rule use_official_docker_image, use the following:    enable_rule["use_official_docker_image"]    Use enable_hard to enable a rule and set its enforcement level to hard in a single statement.   The following statements are equivalent:    enable_hard["use_official_docker_image"]     enable_rule["use_official_docker_image"]

hard_fail["use_official_docker_image"]       Using pipeline metadata  When writing policies for CircleCI config, it is often desirable to have policies that vary slightly in behaviour by project or branch. This is possible using the data.meta Rego property.   When a policy is evaluated in the context of a triggered pipeline the following properties will be available on data.meta:     project_id (CircleCI Project UUID)   build_number (number)   ssh_rerun (boolean) - indicates if CI job is started using the SSH rerun feature   vcs.branch (string)   vcs.release_tag (string)   vcs.origin_repository_url (string) - URL to the repository where the commit was made (this will only be different in the case of a forked pull request)   vcs.target_repository_url (string) - URL to the repository building the commit     This metadata can be used to activate/deactivate rules, modify enforcement statuses, and be part of the rule definitions themselves.   The following is an example of a policy that only runs its rule for a single project and enforces it as hard_fail only on branch main.    package org

policy_name["example"]

# specific project UUID
# use care to avoid naming collisions as assignments are global across the entire policy bundle
sample_project_id := "c2af7012-076a-11ed-84e6-f7fa45ad0fd1"

# this rule is enabled only if the body evaluates to true
enable_rule["custom_rule"] { data.meta.project_id == sample_project_id }

# "custom_rule" evaluates to a hard_failure condition only if run in the context of branch main
hard_fail["custom_rule"] { data.meta.vcs.branch == "main" }    The following is an example of a policy that blocks pull request builds from untrusted origins.    package org

import future.keywords

policy_name["forked_pull_requests"]

# this rule is enabled only if the body evaluates to true (origin_repository_url and target_repository_url will be different in case of a forked pull request)
enable_rule["check_forked_builds"] {
	data.meta.vcs.origin_repository_url != data.meta.vcs.target_repository_url
}

# enable hard failure
hard_fail["check_forked_builds"]

check_forked_builds = reason {
	not from_trusted_origin(data.meta.vcs.origin_repository_url)
	reason := sprintf("pipeline triggered from untrusted origin: %s", [data.meta.vcs.origin_repository_url])
}

from_trusted_origin(origin) {
	some trusted_origin in {
		"https://github.com/trusted_org/",
		"https://bitbucket.org/trusted_org/",
	}

	startswith(origin, trusted_origin)
}    The following is an example of a policy that blocks SSH reruns on configs where a job uses sensitive contexts.    package org

import future.keywords
import data.circleci.utils

policy_name["ssh_rerun"]

enable_hard["disallow_ssh_rerun"]

sensitive_contexts := { "secops", "deploy_keys", "access_tokens", "security" }

disallow_ssh_rerun = "Cannot perform ssh_rerun with sensitive contexts" {
    data.meta.ssh_rerun
    some _, job in input.workflows[_].jobs[_]
    count(utils.to_set(job.context) & sensitive_contexts) > 0
}       Config policies with parameterization and reusable config   Writing policies for CircleCI version 2.1 configuration introduces some challenges due to the parameterization and reusable configuration options. To read more about these options, see the  Reusable config reference guide.   Before executing any pipelines, config version 2.1 is compiled into config version 2.0. This compilation expands all parameters and reusable config blocks (jobs, executors, commands, orbs) into workflows and jobs.   To write highly effective policies, it is essential to reference the compiled version of the config (input.compiled).   Example  Consider the following example policy and configuration:   Policy    import future.keywords

policy_name["example_mistake"]

enable_hard["enforce_not_large_resource"]

# check every job in input config, and if any job has resource_class equal to "large" set a violation message.
enforce_not_large_resource[reason] {
  some job_name, job in input.jobs
  job.resource_class == "large"
  reason = sprintf("job %s using banned large resource class", [job_name])
}    Configuration with reusable executor    version: 2.1

executors: # Define reusable executor
  lg-executor:
    docker:
      - image: my-image
    resource_class: large # Resource class configured in reusable executor

jobs:
  test:
    executor: lg-executor
    steps:
      - checkout

workflows:
  my-workflow:
    jobs:
      - test    In the above example, the policy is bypassed and will not trigger. The policy inspects jobs and does not find a resource_class == "large".   This example is problematic because once the configuration is compiled, the job test will have a resource_class == "large".   Another way this policy could be unintentionally bypassed is by using parameters. Consider the following configuration, which uses a parameter to set the resource class for an executor:   Configuration using a parameter    version: 2.1

jobs:
  test:
    docker:
      - image: my-image
    parameters:
      size:
        type: string
    resource_class: << parameters.size >> # parameterized definition of resource_class
    steps:
      - checkout

workflows:
  main:
    jobs:
      - test: # invokation of parameterized job "test" with a size equal to "large".
          size: large    The same situation applies as for the first configuration presented above. The policy inspects the jobs and does not find a resource_class == "large", but instead finds << parameters.size >>, which is acceptable for the policy.   However, once the config is compiled, the job test will have a resource_class == "large".   To resolve both of these issues, it is important to acknowledge that we want to apply the policy to all jobs, which is a configuration version: 2.0 construct, and write the policy to target the compiled version accordingly, as follows:   Policy rule that inspects compiled configuration    # check all jobs in the compiled config and if any use a resource_class equal to "large" return a violation message.
enforce_not_large_resource[reason] {
  some job_name, job in input.compiled.jobs
  job.resource_class == "large"
  reason = sprintf("job %s using banned large resource class", [job_name])
}    Notice the rule now validates input.compiled.jobs. Regardless of parameters or reusable blocks (executors in this example), the policy is applied to all compiled jobs and functions as intended.    Policing config 2.1 constructs  Writing policies against config version 2.1 constructs (orbs, executors, jobs, commands) introduces the same parameterization challenges as described in the previous section. However, we cannot rely on writing policies against the compiled input because these constructs do not exist in configuration version 2.0.   Consider another example to illustrate this:   Policy to ban orbs from a specific namespace    import future.keywords

policy_name["example_mistake"]

enable_hard["ban_bad_orb_namespace"]

# check if any orb is namespaced with `bad`. If so, set a violation message for each of those orbs.
ban_bad_orb_namespace[reason] {
  some key, orb_ref in input.orbs
  startswith(orb_ref, "bad/")
  reason := sprintf("orb %s is defined with a banned namespace: bad", [key])
}    Configuration    version: 2.1

# top level pipeline parameters that can have a default set, or be modified by API based pipeline triggers.
parameters:
  evil_orb:
    type: string
    default: bad/orb

orbs:
  security: << pipeline.parameters.evil_orb >> # parameterized orb definition    In the above example, the rule does not raise a violation because the string << pipeline.parameters.evil_orb >> does not have the bad/ prefix that the policy aims to detect.   We cannot rely on input.compiled because orbs are compiled away at that stage.   The best approach here is to detect if an orb reference is a parameterized expression and raise a violation accordingly. To do this we can use the is_parameterized_expression  helper.   Policy to ban orbs from a specific namespace and detect parameterized orb references    import future.keywords
import data.circleci.config

policy_name["example"]

enable_hard["ban_bad_orb_namespace"]

# checks for orbs that are namespaced in "bad/" and set a violation for each orb.
# also detects and raises a violation for any orb defined with a parameter.
ban_bad_orb_namespace = { reason |
  some key, orb_ref in input.orbs
  startswith(orb_ref, "bad/")
  reason := sprintf("orb %s is defined with a banned namespace: bad", [key])
} | { reason |
  some key, orb_ref in input.orbs
  config.is_parameterized_expression(orb_ref) # helper for detecting parameterized expressions.
  reason := sprintf("orb %s is not allowed to contain a parameterized expression", ["key"])
}     Allowlists vs banlists with parameterization  Policies and their rules can be categorized into two main types:     Allowlists: Assert that the input must match a specific value, or fall within a defined set of values   Banlists: Assert that the input must not match a particular value nor be within a set of prohibited values     When working with configuration version 2.1 constructs and parameterization, it is crucial to understand how these two rule types interact with your policies.     Banlist rules are susceptible to being bypassed using parameterization and reusable constructs. This is because the literal parameter value is unlikely to match the banned value, and during config compilation, the values intended to be banned can be reintroduced. All parameterization examples provided above fall into this category. To address this, you can either utilize input.compiled or detect parameterization and handle it appropriately.   Allowlist rules are incompatible with parameterization. They reject configurations that could otherwise be considered valid but do not cause invalid configurations to pass.     Consider an example to illustrate this:      This example is artificial and for illustration purposes only. The appropriate policy for enforcing job resource classes should target the compiled input (input.compiled). This ensures proper validation against the resolved values.        Policy using an allowlist to restrict resource classes    import future.keywords

policy_name["allowlist"]

enable_hard["restrict_resource_classes"]

# check all jobs in config input and if the job is not "small" or "large" set a violation message.
restrict_resource_classes[reason] {
  some job_name, job in input.jobs
  not job.resource_class in {"small", "large"}
  reason := sprintf("job %s must have resource class of small or large but has: %s", [job_name, job.resource_class])
}    Configuration    version: 2.1

jobs:
  test:
    parameters:
      size:
        type: string
    docker:
      - image: my-image
    resource_class: << parameters.size >>
    steps:
      - checkout

workflows:
  main:
    jobs:
      - test:
          size: small    The rule (restrict_resource_classes) raises a violation because << parameters.size >> does not conform to the allowlist values of small or large. Even if this configuration would compile to a job that uses the correct small resource class, the violation is still triggered.   When working with allowlist-type rules, it is essential to recognize how they can restrict parameterization, so you can strike the right balance between configurational reusability and rule enforcement.      Use sets and variables   It is best practice to avoid hard coding values in code, and the same goes for your config policies. Hard coding data, such as project IDs, makes it difficult to read code, and can be confusing when collaborating with wider team members ("what is 99ada477-7029-44bb-b675-5b2d6448d1ab?"). Because using rego means your policies are defined in code, you can define sets and variables in rego files external to your individual policies, and reference these sets and variables across multiple policies. For an example of this in practice, see the  Manage contexts with config policies page.   For further reading, see the  Config policies blog post.     Testing policies   It is important to be able to deploy new policies with confidence, knowing how they will be applied, and the decisions they will generate ahead of time. To enable this process, the circleci policy test command is available. The test subcommand is inspired by the golang and OPA test commands. For more information on setting up testing, see the  Test config policies guide.   The circleci policy test command is intended for testing the validity of the policy when adding and updating your config policies only within your config policy repo. Usage outside of adding/updating your config policy repo could result in false responses resulting from race conditions when reading and writing to the config policy service at the same time.     Config policies and dynamic configuration   You can write config policies to govern projects that use dynamic configuration too. Policies are evaluated against:     Setup configurations   Continuation configurations   Standard configurations     If required for your project, you can encode rules to apply only to setup configs, or only to non-setup configs, as follows:    enable_hard["setup_rule"] { input.setup } # only applied to configs with `setup: true`     enable_hard["not_setup_rule"] { not input.setup } # only applied to configs that do not have `setup: true`     enable_hard["some_rule"] # rule applied to all configs    For more information about dynamic configuration, see the  Dynamic configuration overview.     Example policy   The following is an example of a complete policy with one rule, use_official_docker_image, which checks that all Docker images in a config are prefixed by circleci or cimg. It uses some helper code to find all the docker_images in the config. It then sets the enforcement status of use_official_docker_image to hard_fail and enables the rule.   This example also imports future.keywords, for more information see the  OPA docs.    package org

import future.keywords

policy_name["example"]

use_official_docker_image[image] = reason {
  some image in docker_images   # docker_images are parsed below
  not startswith(image, "circleci")
  not startswith(image, "cimg")
  reason := sprintf("%s is not an approved Docker image", [image])
}

# helper to parse docker images from the config
docker_images := {image | walk(input, [path, value])  # walk the entire config tree
                          path[_] == "docker"         # find any settings that match 'docker'
                          image := value[_].image}    # grab the images from that section

enable_hard["use_official_docker_image"]      Next steps      Create and manage config policies    Test config policies    Use the CircleCI CLI for config and policy development    Config policy reference     Suggest an edit to this pageMake a contribution Learn how to contributeStill need help? Ask the CircleCI community Join the research community Visit our Support site DocsTerms of UsePrivacy PolicyCookie PolicySecurity© 2025 Circle Internet Services, Inc., All Rights Reserved.\n\nThe config policies feature is available on the Scale Plan and from CircleCI server v4.2. You must be an organization admin in order to create and manage config policies.  status:           PASS | SOFT_FAIL | HARD_FAIL | ERROR
reason:           string                                      (optional, only present when status is ERROR)
enabled_rules:    Array<string>
soft_failures:    Array<{ rule: string, reason: string }>
hard_failures:    Array<{ rule: string, reason: string }>   Using server? When using the circleci policy commands with CircleCI server, you will need to use the policy-base-url flag to provide your CircleCI server domain. For example:    circleci policy settings --enabled=true --owner-id <your-organization-ID> --policy-base-url <your-circleci-server-domain>    circleci policy settings --enabled=true --owner-id <your-organization-ID> --policy-base-url <your-circleci-server-domain>  circleci policy push ./policy_bundle_dir_path --owner-id <your-organization-ID>  circleci policy settings --owner-id <your-organization-ID>  {
  "enabled": false
}  circleci policy test ./policies  ok    policies    0.001s

3/3 tests passed (0.001s)   To find your organization/user ID, select Organization Settings in the CircleCI web app side bar.      package org

policy_name["unique_policy_name"]  Helpers in the context of config policies are rules like any other, but rules that are not individually enabled for the process of determining policy violation. Helpers can be written and used as building blocks for your policies.  input.workflows     # an array of nested structures mirroring workflows in the CircleCI config
input.jobs          # an array of nested structures mirroring jobs in the CircleCI config  RULE_NAME = reason {
  ... # some comparison
  reason := "..."
}  RULE_NAME[RULE_ID] = reason {
  ... # some comparison
  reason := "..."
}  contains_workflows = reason {
    count(input.workflows) > 0
    reason := "config must contain at least one workflow"
}  use_official_docker_image[image] = reason {
  some image in docker_images   # docker_images are parsed below
  not startswith(image, "circleci")
  not startswith(image, "cimg")
  reason := sprintf("%s is not an approved Docker image", [image])
}

# helper to parse docker images from the config
docker_images := {image | walk(input, [path, value])  # walk the entire config tree
                          path[_] == "docker"         # find any settings that match 'docker'
                          image := value[_].image}    # grab the images from that section  ENFORCEMENT_STATUS["RULE_NAME"]  hard_fail["use_official_docker_image"]  enable_rule["RULE_NAME"]  enable_rule["use_official_docker_image"]  enable_hard["use_official_docker_image"]  enable_rule["use_official_docker_image"]

hard_fail["use_official_docker_image"]  package org

policy_name["example"]

# specific project UUID
# use care to avoid naming collisions as assignments are global across the entire policy bundle
sample_project_id := "c2af7012-076a-11ed-84e6-f7fa45ad0fd1"

# this rule is enabled only if the body evaluates to true
enable_rule["custom_rule"] { data.meta.project_id == sample_project_id }

# "custom_rule" evaluates to a hard_failure condition only if run in the context of branch main
hard_fail["custom_rule"] { data.meta.vcs.branch == "main" }  package org

import future.keywords

policy_name["forked_pull_requests"]

# this rule is enabled only if the body evaluates to true (origin_repository_url and target_repository_url will be different in case of a forked pull request)
enable_rule["check_forked_builds"] {
	data.meta.vcs.origin_repository_url != data.meta.vcs.target_repository_url
}

# enable hard failure
hard_fail["check_forked_builds"]

check_forked_builds = reason {
	not from_trusted_origin(data.meta.vcs.origin_repository_url)
	reason := sprintf("pipeline triggered from untrusted origin: %s", [data.meta.vcs.origin_repository_url])
}

from_trusted_origin(origin) {
	some trusted_origin in {
		"https://github.com/trusted_org/",
		"https://bitbucket.org/trusted_org/",
	}

	startswith(origin, trusted_origin)
}  package org

import future.keywords
import data.circleci.utils

policy_name["ssh_rerun"]

enable_hard["disallow_ssh_rerun"]

sensitive_contexts := { "secops", "deploy_keys", "access_tokens", "security" }

disallow_ssh_rerun = "Cannot perform ssh_rerun with sensitive contexts" {
    data.meta.ssh_rerun
    some _, job in input.workflows[_].jobs[_]
    count(utils.to_set(job.context) & sensitive_contexts) > 0
}  import future.keywords

policy_name["example_mistake"]

enable_hard["enforce_not_large_resource"]

# check every job in input config, and if any job has resource_class equal to "large" set a violation message.
enforce_not_large_resource[reason] {
  some job_name, job in input.jobs
  job.resource_class == "large"
  reason = sprintf("job %s using banned large resource class", [job_name])
}  version: 2.1

executors: # Define reusable executor
  lg-executor:
    docker:
      - image: my-image
    resource_class: large # Resource class configured in reusable executor

jobs:
  test:
    executor: lg-executor
    steps:
      - checkout

workflows:
  my-workflow:
    jobs:
      - test  version: 2.1

jobs:
  test:
    docker:
      - image: my-image
    parameters:
      size:
        type: string
    resource_class: << parameters.size >> # parameterized definition of resource_class
    steps:
      - checkout

workflows:
  main:
    jobs:
      - test: # invokation of parameterized job "test" with a size equal to "large".
          size: large  # check all jobs in the compiled config and if any use a resource_class equal to "large" return a violation message.
enforce_not_large_resource[reason] {
  some job_name, job in input.compiled.jobs
  job.resource_class == "large"
  reason = sprintf("job %s using banned large resource class", [job_name])
}  import future.keywords

policy_name["example_mistake"]

enable_hard["ban_bad_orb_namespace"]

# check if any orb is namespaced with `bad`. If so, set a violation message for each of those orbs.
ban_bad_orb_namespace[reason] {
  some key, orb_ref in input.orbs
  startswith(orb_ref, "bad/")
  reason := sprintf("orb %s is defined with a banned namespace: bad", [key])
}  version: 2.1

# top level pipeline parameters that can have a default set, or be modified by API based pipeline triggers.
parameters:
  evil_orb:
    type: string
    default: bad/orb

orbs:
  security: << pipeline.parameters.evil_orb >> # parameterized orb definition  import future.keywords
import data.circleci.config

policy_name["example"]

enable_hard["ban_bad_orb_namespace"]

# checks for orbs that are namespaced in "bad/" and set a violation for each orb.
# also detects and raises a violation for any orb defined with a parameter.
ban_bad_orb_namespace = { reason |
  some key, orb_ref in input.orbs
  startswith(orb_ref, "bad/")
  reason := sprintf("orb %s is defined with a banned namespace: bad", [key])
} | { reason |
  some key, orb_ref in input.orbs
  config.is_parameterized_expression(orb_ref) # helper for detecting parameterized expressions.
  reason := sprintf("orb %s is not allowed to contain a parameterized expression", ["key"])
}  This example is artificial and for illustration purposes only. The appropriate policy for enforcing job resource classes should target the compiled input (input.compiled). This ensures proper validation against the resolved values.  import future.keywords

policy_name["allowlist"]

enable_hard["restrict_resource_classes"]

# check all jobs in config input and if the job is not "small" or "large" set a violation message.
restrict_resource_classes[reason] {
  some job_name, job in input.jobs
  not job.resource_class in {"small", "large"}
  reason := sprintf("job %s must have resource class of small or large but has: %s", [job_name, job.resource_class])
}  version: 2.1

jobs:
  test:
    parameters:
      size:
        type: string
    docker:
      - image: my-image
    resource_class: << parameters.size >>
    steps:
      - checkout

workflows:
  main:
    jobs:
      - test:
          size: small  enable_hard["setup_rule"] { input.setup } # only applied to configs with `setup: true`  enable_hard["not_setup_rule"] { not input.setup } # only applied to configs that do not have `setup: true`  enable_hard["some_rule"] # rule applied to all configs  package org

import future.keywords

policy_name["example"]

use_official_docker_image[image] = reason {
  some image in docker_images   # docker_images are parsed below
  not startswith(image, "circleci")
  not startswith(image, "cimg")
  reason := sprintf("%s is not an approved Docker image", [image])
}

# helper to parse docker images from the config
docker_images := {image | walk(input, [path, value])  # walk the entire config tree
                          path[_] == "docker"         # find any settings that match 'docker'
                          image := value[_].image}    # grab the images from that section

enable_hard["use_official_docker_image"]\n\n\n\nDeploys overview1 week ago13 min readCloudOn This PageIntroductionQuickstartHow it worksConceptsComponentDeliveryDeploymentCommandReleaseThe deploys UIThe dashboardFilter and group components and environments with labelsUse labels to filter components and environmentsAdd or edit labelsComponent labelsEnvironment labelsView all deployments for an environmentView all commands run for an environmentView all deployments for a componentView all commands run for a componentRequirementsToolingLabels and annotationsAutomatic deployment detection and deploy markersAutomatic detection of deploymentsManual configuration of automatically detected deploysOpt out of automatic deploy detectionRetention PolicyManual deploy marker setupDeploy statusKnown limitationsTroubleshootingWhy is my Deployment/Rollout not showing up in the components tab or releases timeline view?Why is my release is stuck in the Running state?Why are no new releases are showing up? and/or why are component versions not being updated?Why is restore version using Helm is timing out?Why is the restore version button not available for a component version?Why are all buttons disabled for a release?Why are all commands for my component failing?Next steps   Visualize and control your deployments with CircleCI deploys. The CircleCI deploys dashboard supports any deployment, and the deploys management tooling works with deployments to Kubernetes and Amazon SageMaker.     Introduction   CircleCI deploys gives you visibility into your Kubernetes deployments within the CircleCI web app, as well as access to commands and visualisations for managing deployments. From the CircleCI web app, you can:     Restore version   Scale component   Restart component     We support  Argo Rollouts for progressive delivery. Currently the  canary deployment strategy is supported, but in a future release  blue-green will also be supported. Some further controls are available for projects that use Argo Rollouts:     Retry Rollout   Promote Rollout   Cancel Rollout       Quickstart   To get started with CircleCI deploys for Kubernetes right away, refer to the following guides:      Tutorial 1: Set up CircleCI deploys    Tutorial 2: Configure your Kubernetes components    How-to: Manage deploys     To get set up with deploys for Amazon SageMaker, refer to the  Deploy to Amazon SageMaker page.     How it works   CircleCI integrates with your Kubernetes cluster to give you visibility and control over your release process through the CircleCI web app. We currently support Kubernetes Deployments and Argo Rollouts.        Configure environment integrations to install the CircleCI release agent into your Kubernetes clusters. Configure the release agent to only monitor the namespaces you require.   Developers can monitor deployments in the CircleCI web app, and run commands to manage those deployments from the UI. Commands are monitored by CircleCI and relayed to the release agent, which then runs the commands for you.     Concepts   The sections below explain some key software delivery concepts. Understanding these concepts will help you take full advantage of CircleCI deploys.   Component  A component in CircleCI is a collection of code and configuration that is deployed and released as a single unit. In Kubernetes terms, this would be a Deployment or Rollout object along with the related objects such as Pods, ReplicaSets, etc. that share a common circleci.com/component-name label.    Delivery  Delivery is the act of packaging code changes and making them available for Deployment. Continuous delivery is the prerequisite step for continuous deployment. With some variations on the technologies being used, the delivery process creates executables from code and then makes them available to be deployed to an environment at a subsequent time.    Deployment  Deployment is the act of putting a new component version into an environment, regardless of whether users and other services interact with the new version or a previous one. Depending on the deployment type, a release may happen either:     As a later task, such as switching over traffic shaping rules for a blue/green deployment.   As a direct consequence of the deployment, such as a standard Kubernetes rolling update.      Command  A command is a user-initiated action CircleCI performs on the user’s behalf to manipulate a specific component. Actions are run asynchronously via our release agent and the results are reported back to the CircleCI web app. You can see the results in the deployments dashboard, similarly to how step output works for CI jobs.   Some commands are available for all components. These are:     Restore version   Scale component   Restart component     A subset of commands are available for progressive deployments (when using Argo Rollouts). These are:     Retry deployment   Promote deployment   Cancel deployment      Release  A release is the act of updating a component to a new version in a specific environment, causing it to become available to an audience of users and other services.   A release can happen when an existing component is updated or when the first version for a new component is deployed.   In the deploys dashboard, deployments are tagged as Progressive if they refer to an Argo Rollout.   A deployment starts when the component version is updated, and ends when the new version has reached 100% availability, and all associated validations have been completed. In the case of a progressive deployment, this happens when the Rollout completes. In the case of a Kubernetes Deployment, this happens when the Deployment replicas are all available and ready.      The deploys UI   The CircleCI deploys UI is a powerful tool for visualising, monitoring and managing your deployments. The pages included in the deploys UI are described below.   The dashboard       Select Deploys in the CircleCI web app sidebar to enter the deploys dashboard. The dashboard shows the following:     Timeline: A timeline of deploys across your organization’s components and environments. You can use the filter dropdown menus at the top of the page to select a component and/or environment. You will see live status updates, deployment trigger source, deployment version version, deployment type (for example, progressive, when you are using an Argo Rollout). From here you can access the following:    The deployment details page for a specific deployment by clicking on the status badge or version number.   The component or environment details pages by clicking on the respective names.   The project dashboard for the CircleCI project associated with a deployment.   The job details page for the job that started the deployment.   The commit details page in your VCS for the commit that started the deployment.      Environments: List of environment integrations set up for your organization. From here you can:    Set up a new environment integration by selecting Create Environment Integration.   Access settings for each environment ().   Access the environment details view by selecting an environment name.      Components: A list of components and their associated projects. From here you can:    Set up a new component by selecting Create Component. From here you can select and environment that has a successful environment integration set up, and from there you can add a new component.   Get straight to the component’s project building on CircleCI by selecting the project name.   Access setting for each component ().         Filter and group components and environments with labels  Add labels to your components and environments to provide teams with a way to filter and group content in the deploys UI. Once a label is added, you can use this to filter your view to focus on the content relevant to your team.   Labels are composed of two values separated by a colon, for example, team:my-team-name. To specify multiple labels for a component or environment, you can separate them with a comma. For example, team:my-team-name, role:web. You can add up to 20 labels to a component or environment.   Use labels to filter components and environments  Once you have added labels to your components and environments, you can use them to filter your view in the deploys UI. In the timeline, environments, or components view, select a filter to reduce the content in the tab to only your selection. You can also use the label filter dropdown menu at the top of the page.    Add or edit labels  To add or edit labels follow the steps below.      Figure 1. Add and Edit environment and component labels   Component labels  To add or edit labels for a component, follow these steps:     Select Deploys in the CircleCI web app sidebar.   You are now in the timeline view. Select the Components tab.   Select the cog icon () for your component. You can use the filter at the top of the page to help find the component you want.   You are now on the component settings page. Select the edit button () in the labels panel.   Enter or edit your label(s) and select Done.      Environment labels  To add or edit labels for an environment, follow these steps:     Select Deploys in the CircleCI web app sidebar.   You are now in the timeline view. Select the Environments tab.   Select the cog icon () for your environment.   You are now on the environment settings page. Select the edit button () in the labels panel.   Enter or edit your label(s) and select Done.        View all deployments for an environment  To view all deployments for an environment, follow these steps:     Select Deploys in the CircleCI web app sidebar.   You are now in the timeline view. Select the Environments tab.   Select your environment by name.   You are now on the environment details page. Select the Deployments tab to view a list of all deployments for your chosen environment.      View all commands run for an environment  To view all commands run for an environment, follow these steps:     Select Deploys in the CircleCI web app sidebar.   You are now in the timeline view. Select the Environments tab.   Select your environment by name.   You are now on the environment details page. Select the Commands tab to view a list of all commands that have been run for your chosen environment.      View all deployments for a component  To view all deployments for a component, follow these steps:     Select Deploys in the CircleCI web app sidebar.   You are now in the timeline view. Select the Components tab.   Select your component by name. You can use the filter at the top of the page to help.   You are now on the component details page. Select the Deployments tab to view a list of all deployments for your chosen component.      View all commands run for a component  To view all commands run for a component, follow these steps:     Select Deploys in the CircleCI web app sidebar.   You are now in the timeline view. Select the Components tab.   Select your component by name. You can use the filter at the top of the page to help.   You are now on the component details page. Select the Commands tab to view a list of all commands run for your chosen component.        Requirements   Tooling  We test the versions listed here. Older versions may work but are not guaranteed.  ToolTested versionsKubernetes 1.29.0 1.28.0 1.27.0 Helm 3.12.0 3.11.0 Argo Rollouts (optional) 1.6.0 1.5.0    Labels and annotations  The following table shows a complete list of labels and annotations either required or available for configuring your environment integration.  Label/annotationValueRequired?Metadata.Labelscircleci.com/component-nameA name for your applicationYesMetadata.Labelscircleci.com/versionCurrent versionYesSpec.Template.Metadata.Labelscircleci.com/component-nameSee aboveYesSpec.Template.Metadata.Labelscircleci.com/versionSee aboveYesMetadata.Annotationscircleci.com/project-idProject ID for the CircleCI project associated with the job that deploys your componentYesMetadata.Annotationscircleci.com/operation-timeoutA  Go duration string, for example, 5m, 10m15sNo. Only needed to set a custom timeout duration. This option is only available if you are using Helm to configure your Kubernetes resources.Metadata.Annotationscircleci.com/restore-version-enabledfalseNo. Only set if you want to disable the restore version feature for your component.Metadata.Annotationscircleci.com/scale-component-enabledfalseNo. Only set if you want to disable the scale component feature for your component.Metadata.Annotationscircleci.com/restart-component-enabledfalseNo. Only set if you want to disable the restart component feature for your component.Metadata.Annotationscircleci.com/retry-release-enabledfalseNo. Only set if you want to disable the retry deployment feature for your component.Metadata.Annotationscircleci.com/promote-release-enabledfalseNo. Only set if you want to disable the promote deployment feature for your component.Metadata.Annotationscircleci.com/cancel-release-enabledfalseNo. Only set if you want to disable the cancel deployment feature for your component.     Automatic deployment detection and deploy markers   CircleCI automatically generates deploy markers for your deployment pipelines. Deploy markers provide a lightweight way to log your deployments without requiring a full CircleCI deploys setup. Deploy markers generate a log of all deployments in one place, for a clear overview of what has changed, without the need to search through your CI/CD pipelines. Deploy markers log all new deployments in one place and link back to the CI/CD pipelines that caused them. You can use deploy markers independently, without installing the CircleCI release agent.   Automatic detection of deployments  CircleCI looks for the word deploy in your job names to detect when a deployment may have happened and creates an auto-detected deploy marker.   When CircleCI creates a deploy marker for you automatically, we use the information available in your pipeline configuration to create the following:     Component: CircleCI created a component for the deployment and uses your project name to create a component name.   Environment integration: CircleCI creates an environment for you, using your job and workflow names to attempt to create a relevant name. If an environment name cannot be generated, the name will be autogenerated, and you can edit it later. The environment has the type AUTODETECTED.   Version: CircleCI uses the build number to populate the version for the purposes of displaying the deployment in the CircleCI web app.     If any of the following conditions are true, CircleCI will not automatically generate a deploy marker for a job even if the name contains the word deploy:     The job has a status other than SUCCESS.   Any of the following keywords and keyword combinations are present in the job name:    dry run   skip deploy   bypass deploy   deployed   validation   validate      The project related to the job has deployments created via the Kubernetes release agent or manual release-type jobs in the last two months.   You have opted out of the automatic deploy detection feature.   The detected environment integration name collides with an integration you have already set up.     Manual configuration of automatically detected deploys  Some points to consider when manually configuring an automatically detected deploy are as follows:     If you decide you would like to manually configure a deploy marker for an environment integration that was created as part of an automatically detected deploy, refer to the  Configure deploy markers page to set up a deploy marker and a new environment integration.   If you change a component name that was originally autodetected by CircleCI, we create a new component and the history will not carry over. If you do not update the component name, the history will carry over.   If your environment integration has an autogenerated name, you can edit the name as follows:    In the  CircleCI web app, select your organization.   Select Deploys in the sidebar.   Select the Environments tab.   Find your environment and select cog icon () to enter the environment integration settings page.   Select Edit.   Enter a new name and select Update.          Opt out of automatic deploy detection  If you do not want CircleCI to automatically create deploy markers for you, you can opt out of this feature either for a whole organization or per-project.   To opt out of automatic deploy detection for an entire organization, follow these steps:     In the  CircleCI web app, select your organization.   Select Organization settings in the sidebar.   Select Deploys.   Toggle the "Enable automatic deploy marker detection" option left. You will see a confirmation message in the bottom right hand corner of the app. To re-enable the feature, toggle the option to the right.     To opt out of automatic deploy detection for a project, follow these steps:     In the  CircleCI web app, select your organization.   Select Projects in the sidebar.   Find your project in the list, select the ellipsis (), select Project Settings.   Select Deploys.   Toggle the "Enable automatic deploy marker detection" option left. You will see a confirmation message in the bottom right hand corner of the app. To re-enable the feature, toggle the option to the right.      Retention Policy  Automatically detected deploys are retained for 30 days.    Manual deploy marker setup  If you would rather set up deploy markers yourself, see the  Configure deploy markers page.      Deploy status   A deployment can be in one of the following states:  StatusNotesRUNNINGThe deployment is currently in progress.FAILEDResources have reached an unhealthy status (pods for the new version of a Kubernetes component).SUCCESSThe Deployment or Rollout has all desired resources available (all pods specified by a Kubernetes Deployment or Argo Rollout).CANCELLEDThe deployment has been cancelled, either using the cancel deployment option, or by being superseded by another deployment.EXPIREDDeployment commands failed to be picked up by the release agent within the required time window.LOGGEDDeployment has been logged using a deploy marker and is available in the CircleCI deploys UI.    Known limitations     Restarting the release agent while a deployment is ongoing causes the release agent to lose track of the deployment status and fail to update the CircleCI services accordingly.   In the CircleCI deploys UI it is currently possible for you to attempt to restore a version that does not exist. All deployments are presented in the UI, including those outside of the scope of any version history limits you might have set. We do not currently filter out deployments for which there is no longer any data.  Depending on your setup, you will have options for configuring revision history limits: revisionHistoryLimit for Kubernetes and Argo Rollouts, and $HELM_MAX_HISTORY for Helm.   If you have these limits set, you can’t restore a version outside the limit. For example, if your limit is set to the last 10 deployments, you can not restore the 11th deployment back.   We are working on updates to:     Indicate out-of-scope deployments.   Prevent you from attempting to restore unavailable deployments   Provide a manual way for you to mark deployments as unavailable          Troubleshooting   Why is my Deployment/Rollout not showing up in the components tab or releases timeline view?    Check that the Deployment/Rollout is annotated with the required labels. More information is available in the  Set up guides. If the required labels were not present, then adding them should solve the problem.   If you are using a Deployment, check that the desired replicas is not set to 0. Deployments with 0 replicas are not reported as releases, even if they are scaled up subsequently. The configured value can be seen on the release agent deployment in the circleci-release-agent-system namespace. Here is an example in which the number of desired replicas is 2:   apiVersion: apps/v1
kind: Deployment
metadata:
  name: sample-deployment
  namespace: sample-namespace
spec:
  replicas: 2     Check that the Deployment/Rollout is in a namespace managed by the release agent. This can be verified by checking the MANAGED_NAMESPACES environment variable on the release agent deployment in the circleci-release-agent-system namespace. Here is an example in which only the default namespace is being managed:   apiVersion: apps/v1
kind: Deployment
metadata:
  name: circleci-release-agent
  namespace: circleci-release-agent-system
spec:
  template:
    spec:
      containers:
      - env:
        - name: MANAGED_NAMESPACES
          value: default        Why is my release is stuck in the Running state?    If you are using a Deployment, check whether it was deleted before the release could complete. In this scenario, this is an expected behavior. This experience will be improved upon in future release agent updates.   If you are using a Deployment, check whether the release agent restarted before all pods for the deployment could become ready. This is a known limitation that will be addressed in future updates of the release agent. Restarting a release agent while a release is ongoing will cause the release agent to lose track of the release status and fail to update the CircleCI services accordingly.      Why are no new releases are showing up? and/or why are component versions not being updated?    Check whether the token used by the release agent has been revoked:    Select Releases in the CircleCI web app sidebar   Select Configure Environments to enter the release environments view   Select your environment to view valid token details, including when the token was last used.  If the token has been last used longer than a minute ago, then this is likely to be the problem.       Check whether tokens are being shared between multiple release environments. This is not supported. Check this by following these steps:    Retrieve the token value from the token field in the circleci-release-agent secret in the circleci-release-agent-system namespace   Compare the value with the partially obscured value for the available Tokens in the CircleCI web app  If the token does not show up in the list, then it has been revoked or the value configured on the release agent is incorrect. In either case, creating a new token and reinstalling the Release Agent with the new value should solve the issue.          Why is restore version using Helm is timing out?  The time required for a Helm-based restore version to complete successfully is dependent on the specific configuration of the target component. For example, a large number of replicas will lead to a longer duration, which could cause a timeout. It is possible to specify a different timeout by adding the circleci.com/operation-timeout annotation to the Rollout or Deployment. The default value for this is 10 minutes. For steps see the  Configure your Kubernetes components page.    Why is the restore version button not available for a component version?  Check whether the component has been undeployed. If there are currently no live versions for a component, the Restore Version button will not be visible for that component until at least one version has been deployed.    Why are all buttons disabled for a release?  Check whether the release is a Rollback. If this is the case, then this is a known issue that will be solved in a future update to the CircleCI release agent.    Why are all commands for my component failing?  Check if the error message is “invalid or missing project ID“. In this case the component is missing a valid  Project ID.      Next steps      Set up CircleCI deploys   To try out CircleCI deploys for a Kubernetes deployment, visit the  Continuous delivery config examples repo.     Suggest an edit to this pageMake a contribution Learn how to contributeStill need help? Ask the CircleCI community Join the research community Visit our Support site\n\nDeploys overview1 week ago13 min readCloudOn This PageIntroductionQuickstartHow it worksConceptsComponentDeliveryDeploymentCommandReleaseThe deploys UIThe dashboardFilter and group components and environments with labelsUse labels to filter components and environmentsAdd or edit labelsComponent labelsEnvironment labelsView all deployments for an environmentView all commands run for an environmentView all deployments for a componentView all commands run for a componentRequirementsToolingLabels and annotationsAutomatic deployment detection and deploy markersAutomatic detection of deploymentsManual configuration of automatically detected deploysOpt out of automatic deploy detectionRetention PolicyManual deploy marker setupDeploy statusKnown limitationsTroubleshootingWhy is my Deployment/Rollout not showing up in the components tab or releases timeline view?Why is my release is stuck in the Running state?Why are no new releases are showing up? and/or why are component versions not being updated?Why is restore version using Helm is timing out?Why is the restore version button not available for a component version?Why are all buttons disabled for a release?Why are all commands for my component failing?Next steps   Visualize and control your deployments with CircleCI deploys. The CircleCI deploys dashboard supports any deployment, and the deploys management tooling works with deployments to Kubernetes and Amazon SageMaker.     Introduction   CircleCI deploys gives you visibility into your Kubernetes deployments within the CircleCI web app, as well as access to commands and visualisations for managing deployments. From the CircleCI web app, you can:     Restore version   Scale component   Restart component     We support  Argo Rollouts for progressive delivery. Currently the  canary deployment strategy is supported, but in a future release  blue-green will also be supported. Some further controls are available for projects that use Argo Rollouts:     Retry Rollout   Promote Rollout   Cancel Rollout       Quickstart   To get started with CircleCI deploys for Kubernetes right away, refer to the following guides:      Tutorial 1: Set up CircleCI deploys    Tutorial 2: Configure your Kubernetes components    How-to: Manage deploys     To get set up with deploys for Amazon SageMaker, refer to the  Deploy to Amazon SageMaker page.     How it works   CircleCI integrates with your Kubernetes cluster to give you visibility and control over your release process through the CircleCI web app. We currently support Kubernetes Deployments and Argo Rollouts.        Configure environment integrations to install the CircleCI release agent into your Kubernetes clusters. Configure the release agent to only monitor the namespaces you require.   Developers can monitor deployments in the CircleCI web app, and run commands to manage those deployments from the UI. Commands are monitored by CircleCI and relayed to the release agent, which then runs the commands for you.     Concepts   The sections below explain some key software delivery concepts. Understanding these concepts will help you take full advantage of CircleCI deploys.   Component  A component in CircleCI is a collection of code and configuration that is deployed and released as a single unit. In Kubernetes terms, this would be a Deployment or Rollout object along with the related objects such as Pods, ReplicaSets, etc. that share a common circleci.com/component-name label.    Delivery  Delivery is the act of packaging code changes and making them available for Deployment. Continuous delivery is the prerequisite step for continuous deployment. With some variations on the technologies being used, the delivery process creates executables from code and then makes them available to be deployed to an environment at a subsequent time.    Deployment  Deployment is the act of putting a new component version into an environment, regardless of whether users and other services interact with the new version or a previous one. Depending on the deployment type, a release may happen either:     As a later task, such as switching over traffic shaping rules for a blue/green deployment.   As a direct consequence of the deployment, such as a standard Kubernetes rolling update.      Command  A command is a user-initiated action CircleCI performs on the user’s behalf to manipulate a specific component. Actions are run asynchronously via our release agent and the results are reported back to the CircleCI web app. You can see the results in the deployments dashboard, similarly to how step output works for CI jobs.   Some commands are available for all components. These are:     Restore version   Scale component   Restart component     A subset of commands are available for progressive deployments (when using Argo Rollouts). These are:     Retry deployment   Promote deployment   Cancel deployment      Release  A release is the act of updating a component to a new version in a specific environment, causing it to become available to an audience of users and other services.   A release can happen when an existing component is updated or when the first version for a new component is deployed.   In the deploys dashboard, deployments are tagged as Progressive if they refer to an Argo Rollout.   A deployment starts when the component version is updated, and ends when the new version has reached 100% availability, and all associated validations have been completed. In the case of a progressive deployment, this happens when the Rollout completes. In the case of a Kubernetes Deployment, this happens when the Deployment replicas are all available and ready.      The deploys UI   The CircleCI deploys UI is a powerful tool for visualising, monitoring and managing your deployments. The pages included in the deploys UI are described below.   The dashboard       Select Deploys in the CircleCI web app sidebar to enter the deploys dashboard. The dashboard shows the following:     Timeline: A timeline of deploys across your organization’s components and environments. You can use the filter dropdown menus at the top of the page to select a component and/or environment. You will see live status updates, deployment trigger source, deployment version version, deployment type (for example, progressive, when you are using an Argo Rollout). From here you can access the following:    The deployment details page for a specific deployment by clicking on the status badge or version number.   The component or environment details pages by clicking on the respective names.   The project dashboard for the CircleCI project associated with a deployment.   The job details page for the job that started the deployment.   The commit details page in your VCS for the commit that started the deployment.      Environments: List of environment integrations set up for your organization. From here you can:    Set up a new environment integration by selecting Create Environment Integration.   Access settings for each environment ().   Access the environment details view by selecting an environment name.      Components: A list of components and their associated projects. From here you can:    Set up a new component by selecting Create Component. From here you can select and environment that has a successful environment integration set up, and from there you can add a new component.   Get straight to the component’s project building on CircleCI by selecting the project name.   Access setting for each component ().         Filter and group components and environments with labels  Add labels to your components and environments to provide teams with a way to filter and group content in the deploys UI. Once a label is added, you can use this to filter your view to focus on the content relevant to your team.   Labels are composed of two values separated by a colon, for example, team:my-team-name. To specify multiple labels for a component or environment, you can separate them with a comma. For example, team:my-team-name, role:web. You can add up to 20 labels to a component or environment.   Use labels to filter components and environments  Once you have added labels to your components and environments, you can use them to filter your view in the deploys UI. In the timeline, environments, or components view, select a filter to reduce the content in the tab to only your selection. You can also use the label filter dropdown menu at the top of the page.    Add or edit labels  To add or edit labels follow the steps below.      Figure 1. Add and Edit environment and component labels   Component labels  To add or edit labels for a component, follow these steps:     Select Deploys in the CircleCI web app sidebar.   You are now in the timeline view. Select the Components tab.   Select the cog icon () for your component. You can use the filter at the top of the page to help find the component you want.   You are now on the component settings page. Select the edit button () in the labels panel.   Enter or edit your label(s) and select Done.      Environment labels  To add or edit labels for an environment, follow these steps:     Select Deploys in the CircleCI web app sidebar.   You are now in the timeline view. Select the Environments tab.   Select the cog icon () for your environment.   You are now on the environment settings page. Select the edit button () in the labels panel.   Enter or edit your label(s) and select Done.        View all deployments for an environment  To view all deployments for an environment, follow these steps:     Select Deploys in the CircleCI web app sidebar.   You are now in the timeline view. Select the Environments tab.   Select your environment by name.   You are now on the environment details page. Select the Deployments tab to view a list of all deployments for your chosen environment.      View all commands run for an environment  To view all commands run for an environment, follow these steps:     Select Deploys in the CircleCI web app sidebar.   You are now in the timeline view. Select the Environments tab.   Select your environment by name.   You are now on the environment details page. Select the Commands tab to view a list of all commands that have been run for your chosen environment.      View all deployments for a component  To view all deployments for a component, follow these steps:     Select Deploys in the CircleCI web app sidebar.   You are now in the timeline view. Select the Components tab.   Select your component by name. You can use the filter at the top of the page to help.   You are now on the component details page. Select the Deployments tab to view a list of all deployments for your chosen component.      View all commands run for a component  To view all commands run for a component, follow these steps:     Select Deploys in the CircleCI web app sidebar.   You are now in the timeline view. Select the Components tab.   Select your component by name. You can use the filter at the top of the page to help.   You are now on the component details page. Select the Commands tab to view a list of all commands run for your chosen component.        Requirements   Tooling  We test the versions listed here. Older versions may work but are not guaranteed.  ToolTested versionsKubernetes 1.29.0 1.28.0 1.27.0 Helm 3.12.0 3.11.0 Argo Rollouts (optional) 1.6.0 1.5.0    Labels and annotations  The following table shows a complete list of labels and annotations either required or available for configuring your environment integration.  Label/annotationValueRequired?Metadata.Labelscircleci.com/component-nameA name for your applicationYesMetadata.Labelscircleci.com/versionCurrent versionYesSpec.Template.Metadata.Labelscircleci.com/component-nameSee aboveYesSpec.Template.Metadata.Labelscircleci.com/versionSee aboveYesMetadata.Annotationscircleci.com/project-idProject ID for the CircleCI project associated with the job that deploys your componentYesMetadata.Annotationscircleci.com/operation-timeoutA  Go duration string, for example, 5m, 10m15sNo. Only needed to set a custom timeout duration. This option is only available if you are using Helm to configure your Kubernetes resources.Metadata.Annotationscircleci.com/restore-version-enabledfalseNo. Only set if you want to disable the restore version feature for your component.Metadata.Annotationscircleci.com/scale-component-enabledfalseNo. Only set if you want to disable the scale component feature for your component.Metadata.Annotationscircleci.com/restart-component-enabledfalseNo. Only set if you want to disable the restart component feature for your component.Metadata.Annotationscircleci.com/retry-release-enabledfalseNo. Only set if you want to disable the retry deployment feature for your component.Metadata.Annotationscircleci.com/promote-release-enabledfalseNo. Only set if you want to disable the promote deployment feature for your component.Metadata.Annotationscircleci.com/cancel-release-enabledfalseNo. Only set if you want to disable the cancel deployment feature for your component.     Automatic deployment detection and deploy markers   CircleCI automatically generates deploy markers for your deployment pipelines. Deploy markers provide a lightweight way to log your deployments without requiring a full CircleCI deploys setup. Deploy markers generate a log of all deployments in one place, for a clear overview of what has changed, without the need to search through your CI/CD pipelines. Deploy markers log all new deployments in one place and link back to the CI/CD pipelines that caused them. You can use deploy markers independently, without installing the CircleCI release agent.   Automatic detection of deployments  CircleCI looks for the word deploy in your job names to detect when a deployment may have happened and creates an auto-detected deploy marker.   When CircleCI creates a deploy marker for you automatically, we use the information available in your pipeline configuration to create the following:     Component: CircleCI created a component for the deployment and uses your project name to create a component name.   Environment integration: CircleCI creates an environment for you, using your job and workflow names to attempt to create a relevant name. If an environment name cannot be generated, the name will be autogenerated, and you can edit it later. The environment has the type AUTODETECTED.   Version: CircleCI uses the build number to populate the version for the purposes of displaying the deployment in the CircleCI web app.     If any of the following conditions are true, CircleCI will not automatically generate a deploy marker for a job even if the name contains the word deploy:     The job has a status other than SUCCESS.   Any of the following keywords and keyword combinations are present in the job name:    dry run   skip deploy   bypass deploy   deployed   validation   validate      The project related to the job has deployments created via the Kubernetes release agent or manual release-type jobs in the last two months.   You have opted out of the automatic deploy detection feature.   The detected environment integration name collides with an integration you have already set up.     Manual configuration of automatically detected deploys  Some points to consider when manually configuring an automatically detected deploy are as follows:     If you decide you would like to manually configure a deploy marker for an environment integration that was created as part of an automatically detected deploy, refer to the  Configure deploy markers page to set up a deploy marker and a new environment integration.   If you change a component name that was originally autodetected by CircleCI, we create a new component and the history will not carry over. If you do not update the component name, the history will carry over.   If your environment integration has an autogenerated name, you can edit the name as follows:    In the  CircleCI web app, select your organization.   Select Deploys in the sidebar.   Select the Environments tab.   Find your environment and select cog icon () to enter the environment integration settings page.   Select Edit.   Enter a new name and select Update.          Opt out of automatic deploy detection  If you do not want CircleCI to automatically create deploy markers for you, you can opt out of this feature either for a whole organization or per-project.   To opt out of automatic deploy detection for an entire organization, follow these steps:     In the  CircleCI web app, select your organization.   Select Organization settings in the sidebar.   Select Deploys.   Toggle the "Enable automatic deploy marker detection" option left. You will see a confirmation message in the bottom right hand corner of the app. To re-enable the feature, toggle the option to the right.     To opt out of automatic deploy detection for a project, follow these steps:     In the  CircleCI web app, select your organization.   Select Projects in the sidebar.   Find your project in the list, select the ellipsis (), select Project Settings.   Select Deploys.   Toggle the "Enable automatic deploy marker detection" option left. You will see a confirmation message in the bottom right hand corner of the app. To re-enable the feature, toggle the option to the right.      Retention Policy  Automatically detected deploys are retained for 30 days.    Manual deploy marker setup  If you would rather set up deploy markers yourself, see the  Configure deploy markers page.      Deploy status   A deployment can be in one of the following states:  StatusNotesRUNNINGThe deployment is currently in progress.FAILEDResources have reached an unhealthy status (pods for the new version of a Kubernetes component).SUCCESSThe Deployment or Rollout has all desired resources available (all pods specified by a Kubernetes Deployment or Argo Rollout).CANCELLEDThe deployment has been cancelled, either using the cancel deployment option, or by being superseded by another deployment.EXPIREDDeployment commands failed to be picked up by the release agent within the required time window.LOGGEDDeployment has been logged using a deploy marker and is available in the CircleCI deploys UI.    Known limitations     Restarting the release agent while a deployment is ongoing causes the release agent to lose track of the deployment status and fail to update the CircleCI services accordingly.   In the CircleCI deploys UI it is currently possible for you to attempt to restore a version that does not exist. All deployments are presented in the UI, including those outside of the scope of any version history limits you might have set. We do not currently filter out deployments for which there is no longer any data.  Depending on your setup, you will have options for configuring revision history limits: revisionHistoryLimit for Kubernetes and Argo Rollouts, and $HELM_MAX_HISTORY for Helm.   If you have these limits set, you can’t restore a version outside the limit. For example, if your limit is set to the last 10 deployments, you can not restore the 11th deployment back.   We are working on updates to:     Indicate out-of-scope deployments.   Prevent you from attempting to restore unavailable deployments   Provide a manual way for you to mark deployments as unavailable          Troubleshooting   Why is my Deployment/Rollout not showing up in the components tab or releases timeline view?    Check that the Deployment/Rollout is annotated with the required labels. More information is available in the  Set up guides. If the required labels were not present, then adding them should solve the problem.   If you are using a Deployment, check that the desired replicas is not set to 0. Deployments with 0 replicas are not reported as releases, even if they are scaled up subsequently. The configured value can be seen on the release agent deployment in the circleci-release-agent-system namespace. Here is an example in which the number of desired replicas is 2:   apiVersion: apps/v1
kind: Deployment
metadata:
  name: sample-deployment
  namespace: sample-namespace
spec:
  replicas: 2     Check that the Deployment/Rollout is in a namespace managed by the release agent. This can be verified by checking the MANAGED_NAMESPACES environment variable on the release agent deployment in the circleci-release-agent-system namespace. Here is an example in which only the default namespace is being managed:   apiVersion: apps/v1
kind: Deployment
metadata:
  name: circleci-release-agent
  namespace: circleci-release-agent-system
spec:
  template:
    spec:
      containers:
      - env:
        - name: MANAGED_NAMESPACES
          value: default        Why is my release is stuck in the Running state?    If you are using a Deployment, check whether it was deleted before the release could complete. In this scenario, this is an expected behavior. This experience will be improved upon in future release agent updates.   If you are using a Deployment, check whether the release agent restarted before all pods for the deployment could become ready. This is a known limitation that will be addressed in future updates of the release agent. Restarting a release agent while a release is ongoing will cause the release agent to lose track of the release status and fail to update the CircleCI services accordingly.      Why are no new releases are showing up? and/or why are component versions not being updated?    Check whether the token used by the release agent has been revoked:    Select Releases in the CircleCI web app sidebar   Select Configure Environments to enter the release environments view   Select your environment to view valid token details, including when the token was last used.  If the token has been last used longer than a minute ago, then this is likely to be the problem.       Check whether tokens are being shared between multiple release environments. This is not supported. Check this by following these steps:    Retrieve the token value from the token field in the circleci-release-agent secret in the circleci-release-agent-system namespace   Compare the value with the partially obscured value for the available Tokens in the CircleCI web app  If the token does not show up in the list, then it has been revoked or the value configured on the release agent is incorrect. In either case, creating a new token and reinstalling the Release Agent with the new value should solve the issue.          Why is restore version using Helm is timing out?  The time required for a Helm-based restore version to complete successfully is dependent on the specific configuration of the target component. For example, a large number of replicas will lead to a longer duration, which could cause a timeout. It is possible to specify a different timeout by adding the circleci.com/operation-timeout annotation to the Rollout or Deployment. The default value for this is 10 minutes. For steps see the  Configure your Kubernetes components page.    Why is the restore version button not available for a component version?  Check whether the component has been undeployed. If there are currently no live versions for a component, the Restore Version button will not be visible for that component until at least one version has been deployed.    Why are all buttons disabled for a release?  Check whether the release is a Rollback. If this is the case, then this is a known issue that will be solved in a future update to the CircleCI release agent.    Why are all commands for my component failing?  Check if the error message is “invalid or missing project ID“. In this case the component is missing a valid  Project ID.      Next steps      Set up CircleCI deploys   To try out CircleCI deploys for a Kubernetes deployment, visit the  Continuous delivery config examples repo.     Suggest an edit to this pageMake a contribution Learn how to contributeStill need help? Ask the CircleCI community Join the research community Visit our Support site DocsTerms of UsePrivacy PolicyCookie PolicySecurity© 2025 Circle Internet Services, Inc., All Rights Reserved.\n\n1.29.0 1.28.0 1.27.0  3.12.0 3.11.0  1.6.0 1.5.0  apiVersion: apps/v1
kind: Deployment
metadata:
  name: sample-deployment
  namespace: sample-namespace
spec:
  replicas: 2  apiVersion: apps/v1
kind: Deployment
metadata:
  name: circleci-release-agent
  namespace: circleci-release-agent-system
spec:
  template:
    spec:
      containers:
      - env:
        - name: MANAGED_NAMESPACES
          value: default\n\n\n\nExample Public Repos2 months ago2 min readCloudServer v4+On This PageExample CircleCI files and public reposOpen source projects by featureOpen source projects by language   Refer to the following documents and linked .circleci/config.yml files for complete examples of public and open source projects that run on CircleCI.     Example CircleCI files and public repos  Example NameDescriptionLinkSample config.yml FilesFour sample config.yml files using concurrent Workflows, sequential Workflows, fan-in/fan-out Workflows, and building Linux and iOS in one configuration file. Sample config.yml FilesExample Database ConfigurationsThree example config.yml files using PostgreSQL/Rails, Go/PostgreSQL, and Ruby/MySQL Example Database ConfigurationsParallelConcurrent job run workflow configuration. Parallel jobs configSequentialSequential job run workflow configuration Sequential jobs configFan-in / Fan-outWorkflow configuration with sequenced jobs followed by concurrent jobs chained to a final sequenced job. Fan-in-out configWorkspace ForwardingJobs configured to share data with workspaces. Workspace forwarding configCircleCI docsA static website generated by Jekyll for CircleCI documentation. CircleCI docs configCircleCI image builderUses Docker for building container images. Image builder configCircleCI Docker demoExample application showcasing how to build Docker images in CircleCI. CircleCI Docker demo config    Open source projects by feature   The following projects provide examples of using features and functionality of CircleCI configuration syntax:  Example DescriptionProjectconfig.yml linkBuild, test, and upload run for macOS and Linux ArmConda is a platform- and language-independent package manager that sports distribution, installation and version management of software. Bioconda CircleCI configBuild and register a Docker image, deploy to AWS ECSTaco is a next generation repository system for DLSS. Taco CircleCI configDocker compose and docker cp with store_artifactsMayflower is the enterprise design system for the Commonwealth of Massachusetts. Mayflower CircleCI configDynamic config, Remote Docker, Docker Layer Caching, build and push Docker imagesAeternity node is a new blockchain for æpps. Aeternity CircleCI configBuild and test on multiple platforms with tagged releasesCrystal is a programming language. Crystal CircleCI config    Open source projects by language   The following projects provide examples for particular programming languages, testing mechanisms, and deployment targets:  Example DescriptionProjectconfig.yml linkSalesforce DXThis repository shows one way you can successfully set up Salesforce DX with CircleCI. SFDX CircleCI configGolang build with junit and Kubernetes tests for prod and master job workflowThe Azure Container Service Engine (acs-engine) generates Azure Resource Manager templates for Docker enabled clusters on Microsoft Azure with your choice of DC/OS, Kubernetes, Swarm Mode, or Swarm orchestrators. ACS engine CircleCI configGo and Node build, package, and deploy runIgnition is a landing page for developers to self-service their way onto your Pivotal Cloud Foundry (PCF) deployment(s). Ignition CircleCI configJavaScript Node frontend build with junit and end-to-end WebDriver screenshot testsFrontend code for cBioPortal using React, MobX and TypeScript. cBioPortal CircleCI configNode and Yarn test and deploy website with cachingNEO•ONE makes coding, testing and deploying your NEO blockchain solutions easier. Neo One CircleCI configBuild and test with npm and Yarn, deploy to S3The official CLARK Platform client Clark CircleCI configPython build with PostgreSQL database, Selenium tests, and CodeClimateCALC (formerly known as "Hourglass"), which stands for Contracts Awarded Labor Category, is a tool to help contracting personnel estimate their per-hour labor costs for a contract, based on historical pricing information. CALC CircleCI configPython build with apt for concurrent job run with webhooks notificationSunPy is an open-source Python library for solar physics data analysis. SunPy CircleCI configScala and sbt build, test, and release with three workflowsArweave4s is a lightweight modular HTTP client for the Arweave blockchain. Arweave4s CircleCI config  Suggest an edit to this pageMake a contribution Learn how to contributeStill need help? Ask the CircleCI community Join the research community Visit our Support site\n\nExample Public Repos2 months ago2 min readCloudServer v4+On This PageExample CircleCI files and public reposOpen source projects by featureOpen source projects by language   Refer to the following documents and linked .circleci/config.yml files for complete examples of public and open source projects that run on CircleCI.     Example CircleCI files and public repos  Example NameDescriptionLinkSample config.yml FilesFour sample config.yml files using concurrent Workflows, sequential Workflows, fan-in/fan-out Workflows, and building Linux and iOS in one configuration file. Sample config.yml FilesExample Database ConfigurationsThree example config.yml files using PostgreSQL/Rails, Go/PostgreSQL, and Ruby/MySQL Example Database ConfigurationsParallelConcurrent job run workflow configuration. Parallel jobs configSequentialSequential job run workflow configuration Sequential jobs configFan-in / Fan-outWorkflow configuration with sequenced jobs followed by concurrent jobs chained to a final sequenced job. Fan-in-out configWorkspace ForwardingJobs configured to share data with workspaces. Workspace forwarding configCircleCI docsA static website generated by Jekyll for CircleCI documentation. CircleCI docs configCircleCI image builderUses Docker for building container images. Image builder configCircleCI Docker demoExample application showcasing how to build Docker images in CircleCI. CircleCI Docker demo config    Open source projects by feature   The following projects provide examples of using features and functionality of CircleCI configuration syntax:  Example DescriptionProjectconfig.yml linkBuild, test, and upload run for macOS and Linux ArmConda is a platform- and language-independent package manager that sports distribution, installation and version management of software. Bioconda CircleCI configBuild and register a Docker image, deploy to AWS ECSTaco is a next generation repository system for DLSS. Taco CircleCI configDocker compose and docker cp with store_artifactsMayflower is the enterprise design system for the Commonwealth of Massachusetts. Mayflower CircleCI configDynamic config, Remote Docker, Docker Layer Caching, build and push Docker imagesAeternity node is a new blockchain for æpps. Aeternity CircleCI configBuild and test on multiple platforms with tagged releasesCrystal is a programming language. Crystal CircleCI config    Open source projects by language   The following projects provide examples for particular programming languages, testing mechanisms, and deployment targets:  Example DescriptionProjectconfig.yml linkSalesforce DXThis repository shows one way you can successfully set up Salesforce DX with CircleCI. SFDX CircleCI configGolang build with junit and Kubernetes tests for prod and master job workflowThe Azure Container Service Engine (acs-engine) generates Azure Resource Manager templates for Docker enabled clusters on Microsoft Azure with your choice of DC/OS, Kubernetes, Swarm Mode, or Swarm orchestrators. ACS engine CircleCI configGo and Node build, package, and deploy runIgnition is a landing page for developers to self-service their way onto your Pivotal Cloud Foundry (PCF) deployment(s). Ignition CircleCI configJavaScript Node frontend build with junit and end-to-end WebDriver screenshot testsFrontend code for cBioPortal using React, MobX and TypeScript. cBioPortal CircleCI configNode and Yarn test and deploy website with cachingNEO•ONE makes coding, testing and deploying your NEO blockchain solutions easier. Neo One CircleCI configBuild and test with npm and Yarn, deploy to S3The official CLARK Platform client Clark CircleCI configPython build with PostgreSQL database, Selenium tests, and CodeClimateCALC (formerly known as "Hourglass"), which stands for Contracts Awarded Labor Category, is a tool to help contracting personnel estimate their per-hour labor costs for a contract, based on historical pricing information. CALC CircleCI configPython build with apt for concurrent job run with webhooks notificationSunPy is an open-source Python library for solar physics data analysis. SunPy CircleCI configScala and sbt build, test, and release with three workflowsArweave4s is a lightweight modular HTTP client for the Arweave blockchain. Arweave4s CircleCI config  Suggest an edit to this pageMake a contribution Learn how to contributeStill need help? Ask the CircleCI community Join the research community Visit our Support site DocsTerms of UsePrivacy PolicyCookie PolicySecurity© 2025 Circle Internet Services, Inc., All Rights Reserved.\n\n\n\nSample config.yml Files2 weeks ago6 min readCloudServer v4+On This PageTools for editing configuration filesSimple configuration examplesConcurrent workflowSequential workflowApproval jobHello worldSample configuration with sequential workflow and secondary Docker containerSample configuration with fan-in/fan-out workflowSample configuration with multiple executor typesSee also   This document provides sample .circleci/config.yml files that you can use as a starting point when setting up projects, or to better understand different ways to orchestrate jobs using workflows and filters. For information on all configuration elements available to you, see the  Configuration reference page.   If you would like to get set up quickly, see our language-specific quickstart guides:      Node    Python    Go       Tools for editing configuration files   CircleCI has created an  extension for Visual Studio Code that reduces context switching between the web app and VS Code through a set of helpful features.   The VS Code extension reduces the time to create, modify, and troubleshoot configuration files through real-time syntax validation, highlighting, and autocomplete suggestions. Authenticating the extension with your CircleCI account will also allow you to visualize and manage your CircleCI pipelines directly from your code editor, and be notified of workflow status changes.   The CircleCI VS Code extension is available to download on the  VS Code marketplace.     Simple configuration examples      Using Docker? Authenticating Docker pulls from image registries is recommended when using the Docker execution environment. Authenticated pulls allow access to private Docker images, and may also grant higher rate limits, depending on your registry provider. For further information see  Using Docker authenticated pulls.        Concurrent workflow  The configuration example below shows a concurrent workflow in which the build and test jobs run at the same time. Both jobs are run in Docker containers using the base image provided by CircleCI.     Refer to the  Workflows document for complete details about orchestrating job runs with concurrent, sequential, and manual approval workflows.   Refer to the  Developer Hub convenience images page to find out about available Docker images for running your jobs.     This image shows the workflow view for the following configuration example:         version: 2.1

# Define the jobs we want to run for this project
jobs:
  build:
    docker:
      - image: cimg/base:2023.03
    steps:
      - checkout
      - run: echo "this is the build job"
  test:
    docker:
      - image: cimg/base:2023.03
    steps:
      - checkout
      - run: echo "this is the test job"

# Orchestrate our job run sequence
workflows:
  build_and_test:
    jobs:
      - build
      - test     Sequential workflow  The configuration example below shows a sequential workflow where the build job runs, and then the test job runs once build has completed. Configure sequential workflows using the  requires key, and specifying the test job "requires" the build job in order to run. Both jobs are run in Docker containers using the base image provided by CircleCI.     Refer to the  Workflows document for complete details about orchestrating job runs with concurrent, sequential, and manual approval workflows.   Refer to the  developer hub convenience images page to find out about available Docker images for running your jobs.     This image shows the workflow view for the following configuration example, in which jobs run sequentially (one after the other):         version: 2.1

# Define the jobs we want to run for this project
jobs:
  build:
    docker:
      - image: cimg/base:2023.03
    steps:
      - checkout
      - run: echo "this is the build job"
  test:
    docker:
      - image: cimg/base:2023.03
    steps:
      - checkout
      - run: echo "this is the test job"

# Orchestrate our job run sequence
workflows:
  build_and_test:
    jobs:
      - build
      - test:
          requires:
            - build     Approval job  The example below shows a sequential workflow with an  approval job. Use an approval job to require manual approval before downstream jobs may proceed.    version: 2.1

executors: # Define an executor
  my-executor:
    docker:
      - image: cimg/base:2024.01
# Define the jobs we want to run for this project
jobs:
  build:
    executor: my-executor
    steps:
      - checkout
      - run: echo "build"
  test:
    executor: my-executor
    steps:
      - checkout
      - run: echo "test"
  deploy:
    executor: my-executor
    steps:
      - checkout
      - run: echo "deploy"

# Orchestrate our job run sequence
workflows:
  build_and_test:
    jobs:
      - build
      - test:
          requires:
            - build
      - hold:
          type: approval
          requires:
            - build
      - deploy:
          requires:
            - hold    The workflow runs as follows:     build job runs   test job runs   hold job, with type: approval ensures the workflow waits for manual approval in the CircleCI web app   Once hold job is approved the deploy job runs     An approval job can have any name. In the example above the approval job is named hold. The name you choose for an approval job should not be used to define a job in the main configuration. An approval job only exists as a workflow orchestration devise.   The image below shows the workflow view for the following configuration example. This image has three parts to show:     The workflow graph with the hold job paused   The "Needs Approval" popup that appears when you click on a hold job   The workflow view again once the hold job has been approved and the deploy job has run            Refer to the  Workflows document for complete details about orchestrating job runs with concurrent, sequential, and manual approval workflows.   Refer to the  developer hub convenience images page to find out about available Docker images for running your jobs.      Hello world   # Use the latest 2.1 version of CircleCI pipeline process engine.
# See: https://circleci.com/docs/configuration-reference
version: 2.1

# Define a job to be invoked later in a workflow.
# See: https://circleci.com/docs/jobs-steps/#jobs-overview & https://circleci.com/docs/configuration-reference/#jobs
jobs:
  say-hello:
    # Specify the execution environment. You can specify an image from Docker Hub or use one of our convenience images from CircleCI's Developer Hub.
    # See: https://circleci.com/docs/executor-intro/ & https://circleci.com/docs/configuration-reference/#executor-job
    docker:
      # Specify the version you desire here
      # See: https://circleci.com/developer/images/image/cimg/base
      - image: cimg/base:current

    # Add steps to the job
    # See: https://circleci.com/docs/jobs-steps/#steps-overview & https://circleci.com/docs/configuration-reference/#steps
    steps:
      # Checkout the code as the first step.
      - checkout
      - run:
          name: "Say hello"
          command: "echo Hello, World!"

# Orchestrate jobs using workflows
# See: https://circleci.com/docs/workflows/ & https://circleci.com/docs/configuration-reference/#workflows
workflows:
  say-hello-workflow: # This is the name of the workflow, feel free to change it to better match your workflow.
    # Inside the workflow, you define the jobs you want to run.
    jobs:
      - say-hello       Sample configuration with sequential workflow and secondary Docker container   Following is a sample .circleci/config.yml file using the following configuration features:     A sequential workflow   An orb   A secondary services container   Workspaces   Storing artifacts      version: 2.1

orbs:
  node: circleci/node@3.0.0

jobs:
  build:
    working_directory: ~/mern-starter
    # Reuse Docker container specification given by the node Orb
    executor: node/default
    steps:
      - checkout
      # Install the latest npm - the node Orb takes care of it
      - node/install-npm
      # Install dependencies - the node Orb take care of installation and dependency caching
      - node/install-packages:
          app-dir: ~/mern-starter
          cache-path: node_modules
          override-ci-command: npm i
      # Save workspace for subsequent jobs (i.e. test)
      - persist_to_workspace:
          root: .
          paths:
            - .

  test:
    docker:
      # The primary container is an instance of the first image listed. The job's commands run in this container.
      - image: cimg/node:current
      # The secondary container is an instance of the second listed image which is run in a common network where ports exposed on the primary container are available on localhost.
      - image: mongo:4.2
    steps:
      # Reuse the workspace from the build job
      - attach_workspace:
          at: .
      - run:
          name: Demonstrate that Mongo DB is available as localhost
          command: |
            curl -sSJL https://www.mongodb.org/static/pgp/server-4.2.asc | sudo apt-key add -
            echo "deb [ arch=amd64,arm64 ] https://repo.mongodb.org/apt/ubuntu bionic/mongodb-org/4.2 multiverse" | sudo tee /etc/apt/sources.list.d/mongodb-org-4.2.list
            sudo apt update
            sudo apt install mongodb-org
            mongo localhost --eval "db.serverStatus()"
      - run:
          name: Test
          command: npm test
      - run:
          name: Generate code coverage
          command: './node_modules/.bin/nyc report --reporter=text-lcov'
      # You can specify either a single file or a directory to store as artifacts
      - store_artifacts:
          path: test-results.xml
          destination: deliverable.xml
      - store_artifacts:
          path: coverage
          destination: coverage

workflows:
  build_and_test:
    jobs:
      - build
      - test:
          requires:
            - build    This example shows a sequential workflow with the test job configured to run only on the main branch. Refer to the  Workflows document for complete details about orchestrating job runs with concurrent, sequential, and manual approval workflows.     Sample configuration with fan-in/fan-out workflow   Below are two sample configurations for a Fan-in/Fan-out workflow.         version: 2.1

orbs:
    docker: circleci/docker@1.0.1

jobs:
    prepare-dependencies:
        docker:
            - image: node:current-alpine
        steps:
            - checkout
            - run:
                  name: Compute version number
                  command: echo "0.0.${CIRCLE_BUILD_NUM}-${CIRCLE_SHA1:0:7}" | tee version.txt
            - restore_cache:
                  keys:
                      - yarn-deps-{{ checksum "yarn.lock" }}
                      - yarn-deps
            - run:
                  name: yarn install
                  command: yarn install
            - save_cache:
                  paths:
                      - node_modules
                  key: yarn-deps-{{ checksum "yarn.lock" }}-{{ epoch }}
            - store_artifacts:
                  path: yarn.lock
            - persist_to_workspace:
                  root: .
                  paths:
                      - .

    build-production:
        docker:
            - image: node:current-alpine
        steps:
            - attach_workspace:
                  at: .
            - run:
                  name: Production build
                  command: |
                      export __BUILD_VERSION="$(cat version.txt)"
                      yarn build
            - store_artifacts:
                  path: dist/server.js
            - persist_to_workspace:
                  root: .
                  paths:
                      - .

    build-docker-image:
        machine:
            # The image uses the current tag, which always points to the most recent
            # supported release. If stability and determinism are crucial for your CI
            # pipeline, use a release date tag with your image, e.g. ubuntu-2004:202201-02
            image: ubuntu-2004:current
        steps:
            - attach_workspace:
                  at: .
            - run:
                  name: Setup __BUILD_VERSION envvar
                  command: |
                      echo 'export __BUILD_VERSION="$(cat version.txt)"' >> "$BASH_ENV"
            - docker/check:
                  registry: $DOCKER_REGISTRY
            - docker/build:
                  image: $DOCKER_IMAGE_NAME
                  tag: $__BUILD_VERSION
                  registry: $DOCKER_REGISTRY
            - docker/push:
                  image: $DOCKER_IMAGE_NAME
                  tag: $__BUILD_VERSION
                  registry: $DOCKER_REGISTRY

    test:
        docker:
            - image: node:current-alpine
        parallelism: 2
        steps:
            - attach_workspace:
                  at: .
            - run:
                  name: Run tests
                  command: |
                      circleci tests glob '**/*.test.ts' | circleci tests split --split-by timings | xargs yarn test:ci
            - store_artifacts:
                  path: test-results
            - store_test_results:
                  path: test-results

    deploy-docker-image:
        machine:
            image: ubuntu-2004:current
        steps:
            - attach_workspace:
                  at: .
            - run:
                  name: Setup __BUILD_VERSION envvar
                  command: |
                      echo 'export __BUILD_VERSION="$(cat version.txt)"' >> "$BASH_ENV"
            - docker/check:
                  registry: $DOCKER_REGISTRY
            - docker/pull:
                  images: $DOCKER_REGISTRY/$DOCKER_IMAGE_NAME:$__BUILD_VERSION
            - run:
                  name: Tag the image as latest
                  command: docker tag $DOCKER_REGISTRY/$DOCKER_IMAGE_NAME:$__BUILD_VERSION $DOCKER_REGISTRY/$DOCKER_IMAGE_NAME:latest
            - docker/push:
                  image: $DOCKER_IMAGE_NAME
                  tag: latest
                  registry: $DOCKER_REGISTRY

workflows:
    build-test-deploy:
        jobs:
            - prepare-dependencies
            - build-production:
                  requires:
                      - prepare-dependencies
            - build-docker-image:
                  context: docker-hub
                  requires:
                      - build-production
            - test:
                  requires:
                      - prepare-dependencies
            - deploy-docker-image:
                  context: docker-hub
                  requires:
                      - build-docker-image
                      - test       A job can only run when its dependencies are satisfied therefore it requires the dependencies of all upstream jobs. This means only the immediate upstream dependencies need to be specified in the requires: blocks.          Sample configuration with multiple executor types   It is possible to use multiple  executor types in the same workflow.   In Example-1 each push will build and test the project on Linux, Windows and macOS.   In Example-2 each push of an iOS project will be built on macOS, and additional iOS tools ( SwiftLint and  Danger) will be run in Docker.  Example 1Example 2    version: 2.1

orbs:
  github-release: haskell-works/github-release@1.3.3

parameters:
  src-repo-url:
    type: string
    default: https://github.com/esnet/iperf.git
  branch-name:
    type: string
    default: "3.8.1"
  common-build-params:
    type: string
    default: "--disable-shared --disable-static"

jobs:
  build-linux:
    docker:
      - image: archlinux/base
    parameters:
      label:
        type: string
        default: iperf3-linux
    steps:
      - run:
          name: Install dependencies
          command: pacman -Syu --noconfirm openssl git gcc make awk tar
      - run:
          name: Clone iperf3
          command: git clone << pipeline.parameters.src-repo-url >> -b << pipeline.parameters.branch-name >>
      - run:
          name: Build iperf3
          working_directory: iperf
          command: |
            CIRCLE_WORKING_DIRECTORY=$(eval "echo $CIRCLE_WORKING_DIRECTORY")
            IPERF3_MAKE_PREFIX=$CIRCLE_WORKING_DIRECTORY/<< parameters.label >>
            ./configure --prefix=$IPERF3_MAKE_PREFIX << pipeline.parameters.common-build-params >>
            make
            mkdir -p $IPERF3_MAKE_PREFIX
            make install
      - run:
          name: Create a tarball
          command: tar -cJf << parameters.label >>.tar.xz << parameters.label >>
      - persist_to_workspace:
          root: .
          paths:
            - << parameters.label >>.tar.xz
      - store_artifacts:
          path: << parameters.label >>.tar.xz

  build-windows:
    machine:
      image: windows-server-2019-vs2019:stable
      shell: powershell.exe
    resource_class: windows.medium
    parameters:
      label:
        type: string
        default: iperf3-cygwin64
    steps:
      - run:
          name: Download Cygwin installer
          shell: bash.exe
          command: |
            curl -sSJOL https://cygwin.com/setup-x86_64.exe
      - run:
          name: Install Cygwin and required packages
          command: . etup-x86_64.exe -q -s https://mirrors.kernel.org/sourceware/cygwin/ -P libssl-devel,git,gcc-core,make
      - run:
          name: Build iperf3 with Cygwin
          shell: C:\\cygwin64\\bin\\bash.exe --login -eo pipefail
          command: |
            CIRCLE_WORKING_DIRECTORY=$(eval "echo $CIRCLE_WORKING_DIRECTORY")
            IPERF3_MAKE_PREFIX=$CIRCLE_WORKING_DIRECTORY/<< parameters.label >>
            cd $CIRCLE_WORKING_DIRECTORY
            git clone << pipeline.parameters.src-repo-url >> -b << pipeline.parameters.branch-name >>
            cd iperf
            ./configure --prefix=$IPERF3_MAKE_PREFIX << pipeline.parameters.common-build-params >>
            make
            mkdir -p $IPERF3_MAKE_PREFIX
            make install
            cp /usr/bin/cygwin1.dll /usr/bin/cygcrypto-1.1.dll /usr/bin/cygz.dll -t $IPERF3_MAKE_PREFIX/bin
      - run:
          name: Create a Zip file
          command: |
            $ProgressPreference = "SilentlyContinue"
            Compress-Archive .\\<< parameters.label >> .\\<< parameters.label >>.zip
      - persist_to_workspace:
          root: .
          paths:
            - << parameters.label >>.zip
      - store_artifacts:
          path: << parameters.label >>.zip

  build-macos:
    macos:
      xcode: 14.2.0
    parameters:
      label:
        type: string
        default: iperf3-macos
    steps:
      - run:
          name: Clone iperf3
          command: git clone << pipeline.parameters.src-repo-url >> -b << pipeline.parameters.branch-name >>
      - run:
          name: Build iperf3
          working_directory: iperf
          command: |
            CIRCLE_WORKING_DIRECTORY=$(eval "echo $CIRCLE_WORKING_DIRECTORY")
            IPERF3_MAKE_PREFIX=$CIRCLE_WORKING_DIRECTORY/<< parameters.label >>
            ./configure --prefix=$IPERF3_MAKE_PREFIX --with-openssl=$(brew --prefix openssl) << pipeline.parameters.common-build-params >>
            make
            mkdir -p $IPERF3_MAKE_PREFIX
            make install
            # Postruns
            cd $IPERF3_MAKE_PREFIX/bin
            # Copy linked OpenSSL libraris to the current directory
            # and tell the linker to refer to them
            otool -L iperf3 | grep openssl | awk '{ print $1 }' | while read dylib
            do
              name=$(basename $dylib)
              cp $dylib ./
              chmod u+w $name
              install_name_tool -change $dylib @executable_path/$name iperf3
            done
            # Modify libssl as well
            otool -L libssl.1.1.dylib | grep openssl | awk '{ print $1 }' | while read dylib
            do
              install_name_tool -change $dylib @executable_path/$(basename $dylib) libssl.1.1.dylib
            done
      - run:
          name: Create a Zip file
          command: zip -r << parameters.label >>.zip << parameters.label >>
      - persist_to_workspace:
          root: .
          paths:
            - << parameters.label >>.zip
      - store_artifacts:
          path: << parameters.label >>.zip

  test-linux:
    docker:
      - image: cimg/base:stable
    parameters:
      label:
        type: string
        default: iperf3-linux
    steps:
      - attach_workspace:
          at: ./
      - run:
          name: Extract << parameters.label >>.tar.xz
          command: tar -xf << parameters.label >>.tar.xz
      - run:
          name: Test executable
          command: << parameters.label >>/bin/iperf3 -v
      - run:
          name: Run as a server
          command: << parameters.label >>/bin/iperf3 -s
          background: true
      - run:
          name: Run as a client
          command: << parameters.label >>/bin/iperf3 -c localhost -R

  test-windows:
    machine:
      image: windows-server-2019-vs2019:stable
      shell: powershell.exe
    resource_class: windows.medium
    parameters:
      label:
        type: string
        default: iperf3-cygwin64
    steps:
      - attach_workspace:
          at: .
      - run:
          name: Extract iperf3-cygwin64.zip
          command: |
            $ProgressPreference = "SilentlyContinue"
            Expand-Archive .\\<< parameters.label >>.zip .
      - run:
          name: Test executable
          command: .\\<< parameters.label >>\bin\iperf3.exe -v
      - run:
          name: Run as a server
          command: .\\<< parameters.label >>\bin\iperf3.exe -s
          background: true
      - run:
          name: Run as a client
          command: .\\<< parameters.label >>\bin\iperf3.exe -c localhost -R

  test-macos:
    macos:
      xcode: 14.2.0
    parameters:
      label:
        type: string
        default: iperf3-macos
    steps:
      - attach_workspace:
          at: .
      - run:
          name: Uninstall pre-installed OpenSSL
          command: brew uninstall --ignore-dependencies openssl
      - run:
          name: Extract << parameters.label >>
          command: unzip << parameters.label >>
      - run:
          name: Test executable
          command: << parameters.label >>/bin/iperf3 -v
      - run:
          name: Run as a server
          command: << parameters.label >>/bin/iperf3 -s
          background: true
      - run:
          name: Run as a client
          command: << parameters.label >>/bin/iperf3 -c localhost -R

  release:
    executor: github-release/default
    steps:
      - attach_workspace:
          at: .
      - run:
          name: Compute version number
          command: |
            echo 'export IPERF3_BUILD_VERSION="<< pipeline.parameters.branch-name>>-${CIRCLE_BUILD_NUM}-${CIRCLE_SHA1:0:7}"' | tee -a "$BASH_ENV"
      - github-release/release:
          tag: v$IPERF3_BUILD_VERSION
          title: $IPERF3_BUILD_VERSION
          artefacts-folder: .

workflows:
  build-test-release:
    jobs:
      - build-linux
      - build-windows
      - build-macos
      - test-linux:
          requires:
            - build-linux
      - test-windows:
          requires:
            - build-windows
      - test-macos:
          requires:
            - build-macos
      - release:
          requires:
            - test-linux
            - test-windows
            - test-macos
          context: github
          filters:
            branches:
              only: main        version: 2.1

jobs:
  build-and-test:
    macos:
      xcode: 14.2.0
    steps:
      - checkout
      - run:
          name: Install CocoaPods
          command: pod install --verbose
      - run:
          name: Build and run tests
          command: fastlane scan
          environment:
            SCAN_DEVICE: iPhone 8
            SCAN_SCHEME: WebTests
      - store_test_results:
          path: test_output/report.xml
      - store_artifacts:
          path: /tmp/test-results
          destination: scan-test-results
      - store_artifacts:
          path: ~/Library/Logs/scan
          destination: scan-logs

  swiftlint:
    docker:
      - image: dantoml/swiftlint:latest
    steps:
      - checkout
      - run: swiftlint lint --reporter junit | tee result.xml
      - store_artifacts:
          path: result.xml
      - store_test_results:
          path: result.xml

  danger:
    docker:
      - image: dantoml/danger:latest
    steps:
      - checkout
      - run: danger

workflows:
  build-test-lint:
    jobs:
      - swiftlint
      - danger
      - build-and-test         See also     See the  Concepts document and  Workflows for more details of the concepts covered in this example.   See the  Configuration Reference document for full details of each individual configuration key.   See the  Example Public Repos document for a list of public projects that use CircleCI.     Suggest an edit to this pageMake a contribution Learn how to contributeStill need help? Ask the CircleCI community Join the research community Visit our Support site\n\nSample config.yml Files2 weeks ago6 min readCloudServer v4+On This PageTools for editing configuration filesSimple configuration examplesConcurrent workflowSequential workflowApproval jobHello worldSample configuration with sequential workflow and secondary Docker containerSample configuration with fan-in/fan-out workflowSample configuration with multiple executor typesSee also   This document provides sample .circleci/config.yml files that you can use as a starting point when setting up projects, or to better understand different ways to orchestrate jobs using workflows and filters. For information on all configuration elements available to you, see the  Configuration reference page.   If you would like to get set up quickly, see our language-specific quickstart guides:      Node    Python    Go       Tools for editing configuration files   CircleCI has created an  extension for Visual Studio Code that reduces context switching between the web app and VS Code through a set of helpful features.   The VS Code extension reduces the time to create, modify, and troubleshoot configuration files through real-time syntax validation, highlighting, and autocomplete suggestions. Authenticating the extension with your CircleCI account will also allow you to visualize and manage your CircleCI pipelines directly from your code editor, and be notified of workflow status changes.   The CircleCI VS Code extension is available to download on the  VS Code marketplace.     Simple configuration examples      Using Docker? Authenticating Docker pulls from image registries is recommended when using the Docker execution environment. Authenticated pulls allow access to private Docker images, and may also grant higher rate limits, depending on your registry provider. For further information see  Using Docker authenticated pulls.        Concurrent workflow  The configuration example below shows a concurrent workflow in which the build and test jobs run at the same time. Both jobs are run in Docker containers using the base image provided by CircleCI.     Refer to the  Workflows document for complete details about orchestrating job runs with concurrent, sequential, and manual approval workflows.   Refer to the  Developer Hub convenience images page to find out about available Docker images for running your jobs.     This image shows the workflow view for the following configuration example:         version: 2.1

# Define the jobs we want to run for this project
jobs:
  build:
    docker:
      - image: cimg/base:2023.03
    steps:
      - checkout
      - run: echo "this is the build job"
  test:
    docker:
      - image: cimg/base:2023.03
    steps:
      - checkout
      - run: echo "this is the test job"

# Orchestrate our job run sequence
workflows:
  build_and_test:
    jobs:
      - build
      - test     Sequential workflow  The configuration example below shows a sequential workflow where the build job runs, and then the test job runs once build has completed. Configure sequential workflows using the  requires key, and specifying the test job "requires" the build job in order to run. Both jobs are run in Docker containers using the base image provided by CircleCI.     Refer to the  Workflows document for complete details about orchestrating job runs with concurrent, sequential, and manual approval workflows.   Refer to the  developer hub convenience images page to find out about available Docker images for running your jobs.     This image shows the workflow view for the following configuration example, in which jobs run sequentially (one after the other):         version: 2.1

# Define the jobs we want to run for this project
jobs:
  build:
    docker:
      - image: cimg/base:2023.03
    steps:
      - checkout
      - run: echo "this is the build job"
  test:
    docker:
      - image: cimg/base:2023.03
    steps:
      - checkout
      - run: echo "this is the test job"

# Orchestrate our job run sequence
workflows:
  build_and_test:
    jobs:
      - build
      - test:
          requires:
            - build     Approval job  The example below shows a sequential workflow with an  approval job. Use an approval job to require manual approval before downstream jobs may proceed.    version: 2.1

executors: # Define an executor
  my-executor:
    docker:
      - image: cimg/base:2024.01
# Define the jobs we want to run for this project
jobs:
  build:
    executor: my-executor
    steps:
      - checkout
      - run: echo "build"
  test:
    executor: my-executor
    steps:
      - checkout
      - run: echo "test"
  deploy:
    executor: my-executor
    steps:
      - checkout
      - run: echo "deploy"

# Orchestrate our job run sequence
workflows:
  build_and_test:
    jobs:
      - build
      - test:
          requires:
            - build
      - hold:
          type: approval
          requires:
            - build
      - deploy:
          requires:
            - hold    The workflow runs as follows:     build job runs   test job runs   hold job, with type: approval ensures the workflow waits for manual approval in the CircleCI web app   Once hold job is approved the deploy job runs     An approval job can have any name. In the example above the approval job is named hold. The name you choose for an approval job should not be used to define a job in the main configuration. An approval job only exists as a workflow orchestration devise.   The image below shows the workflow view for the following configuration example. This image has three parts to show:     The workflow graph with the hold job paused   The "Needs Approval" popup that appears when you click on a hold job   The workflow view again once the hold job has been approved and the deploy job has run            Refer to the  Workflows document for complete details about orchestrating job runs with concurrent, sequential, and manual approval workflows.   Refer to the  developer hub convenience images page to find out about available Docker images for running your jobs.      Hello world   # Use the latest 2.1 version of CircleCI pipeline process engine.
# See: https://circleci.com/docs/configuration-reference
version: 2.1

# Define a job to be invoked later in a workflow.
# See: https://circleci.com/docs/jobs-steps/#jobs-overview & https://circleci.com/docs/configuration-reference/#jobs
jobs:
  say-hello:
    # Specify the execution environment. You can specify an image from Docker Hub or use one of our convenience images from CircleCI's Developer Hub.
    # See: https://circleci.com/docs/executor-intro/ & https://circleci.com/docs/configuration-reference/#executor-job
    docker:
      # Specify the version you desire here
      # See: https://circleci.com/developer/images/image/cimg/base
      - image: cimg/base:current

    # Add steps to the job
    # See: https://circleci.com/docs/jobs-steps/#steps-overview & https://circleci.com/docs/configuration-reference/#steps
    steps:
      # Checkout the code as the first step.
      - checkout
      - run:
          name: "Say hello"
          command: "echo Hello, World!"

# Orchestrate jobs using workflows
# See: https://circleci.com/docs/workflows/ & https://circleci.com/docs/configuration-reference/#workflows
workflows:
  say-hello-workflow: # This is the name of the workflow, feel free to change it to better match your workflow.
    # Inside the workflow, you define the jobs you want to run.
    jobs:
      - say-hello       Sample configuration with sequential workflow and secondary Docker container   Following is a sample .circleci/config.yml file using the following configuration features:     A sequential workflow   An orb   A secondary services container   Workspaces   Storing artifacts      version: 2.1

orbs:
  node: circleci/node@3.0.0

jobs:
  build:
    working_directory: ~/mern-starter
    # Reuse Docker container specification given by the node Orb
    executor: node/default
    steps:
      - checkout
      # Install the latest npm - the node Orb takes care of it
      - node/install-npm
      # Install dependencies - the node Orb take care of installation and dependency caching
      - node/install-packages:
          app-dir: ~/mern-starter
          cache-path: node_modules
          override-ci-command: npm i
      # Save workspace for subsequent jobs (i.e. test)
      - persist_to_workspace:
          root: .
          paths:
            - .

  test:
    docker:
      # The primary container is an instance of the first image listed. The job's commands run in this container.
      - image: cimg/node:current
      # The secondary container is an instance of the second listed image which is run in a common network where ports exposed on the primary container are available on localhost.
      - image: mongo:4.2
    steps:
      # Reuse the workspace from the build job
      - attach_workspace:
          at: .
      - run:
          name: Demonstrate that Mongo DB is available as localhost
          command: |
            curl -sSJL https://www.mongodb.org/static/pgp/server-4.2.asc | sudo apt-key add -
            echo "deb [ arch=amd64,arm64 ] https://repo.mongodb.org/apt/ubuntu bionic/mongodb-org/4.2 multiverse" | sudo tee /etc/apt/sources.list.d/mongodb-org-4.2.list
            sudo apt update
            sudo apt install mongodb-org
            mongo localhost --eval "db.serverStatus()"
      - run:
          name: Test
          command: npm test
      - run:
          name: Generate code coverage
          command: './node_modules/.bin/nyc report --reporter=text-lcov'
      # You can specify either a single file or a directory to store as artifacts
      - store_artifacts:
          path: test-results.xml
          destination: deliverable.xml
      - store_artifacts:
          path: coverage
          destination: coverage

workflows:
  build_and_test:
    jobs:
      - build
      - test:
          requires:
            - build    This example shows a sequential workflow with the test job configured to run only on the main branch. Refer to the  Workflows document for complete details about orchestrating job runs with concurrent, sequential, and manual approval workflows.     Sample configuration with fan-in/fan-out workflow   Below are two sample configurations for a Fan-in/Fan-out workflow.         version: 2.1

orbs:
    docker: circleci/docker@1.0.1

jobs:
    prepare-dependencies:
        docker:
            - image: node:current-alpine
        steps:
            - checkout
            - run:
                  name: Compute version number
                  command: echo "0.0.${CIRCLE_BUILD_NUM}-${CIRCLE_SHA1:0:7}" | tee version.txt
            - restore_cache:
                  keys:
                      - yarn-deps-{{ checksum "yarn.lock" }}
                      - yarn-deps
            - run:
                  name: yarn install
                  command: yarn install
            - save_cache:
                  paths:
                      - node_modules
                  key: yarn-deps-{{ checksum "yarn.lock" }}-{{ epoch }}
            - store_artifacts:
                  path: yarn.lock
            - persist_to_workspace:
                  root: .
                  paths:
                      - .

    build-production:
        docker:
            - image: node:current-alpine
        steps:
            - attach_workspace:
                  at: .
            - run:
                  name: Production build
                  command: |
                      export __BUILD_VERSION="$(cat version.txt)"
                      yarn build
            - store_artifacts:
                  path: dist/server.js
            - persist_to_workspace:
                  root: .
                  paths:
                      - .

    build-docker-image:
        machine:
            # The image uses the current tag, which always points to the most recent
            # supported release. If stability and determinism are crucial for your CI
            # pipeline, use a release date tag with your image, e.g. ubuntu-2004:202201-02
            image: ubuntu-2004:current
        steps:
            - attach_workspace:
                  at: .
            - run:
                  name: Setup __BUILD_VERSION envvar
                  command: |
                      echo 'export __BUILD_VERSION="$(cat version.txt)"' >> "$BASH_ENV"
            - docker/check:
                  registry: $DOCKER_REGISTRY
            - docker/build:
                  image: $DOCKER_IMAGE_NAME
                  tag: $__BUILD_VERSION
                  registry: $DOCKER_REGISTRY
            - docker/push:
                  image: $DOCKER_IMAGE_NAME
                  tag: $__BUILD_VERSION
                  registry: $DOCKER_REGISTRY

    test:
        docker:
            - image: node:current-alpine
        parallelism: 2
        steps:
            - attach_workspace:
                  at: .
            - run:
                  name: Run tests
                  command: |
                      circleci tests glob '**/*.test.ts' | circleci tests split --split-by timings | xargs yarn test:ci
            - store_artifacts:
                  path: test-results
            - store_test_results:
                  path: test-results

    deploy-docker-image:
        machine:
            image: ubuntu-2004:current
        steps:
            - attach_workspace:
                  at: .
            - run:
                  name: Setup __BUILD_VERSION envvar
                  command: |
                      echo 'export __BUILD_VERSION="$(cat version.txt)"' >> "$BASH_ENV"
            - docker/check:
                  registry: $DOCKER_REGISTRY
            - docker/pull:
                  images: $DOCKER_REGISTRY/$DOCKER_IMAGE_NAME:$__BUILD_VERSION
            - run:
                  name: Tag the image as latest
                  command: docker tag $DOCKER_REGISTRY/$DOCKER_IMAGE_NAME:$__BUILD_VERSION $DOCKER_REGISTRY/$DOCKER_IMAGE_NAME:latest
            - docker/push:
                  image: $DOCKER_IMAGE_NAME
                  tag: latest
                  registry: $DOCKER_REGISTRY

workflows:
    build-test-deploy:
        jobs:
            - prepare-dependencies
            - build-production:
                  requires:
                      - prepare-dependencies
            - build-docker-image:
                  context: docker-hub
                  requires:
                      - build-production
            - test:
                  requires:
                      - prepare-dependencies
            - deploy-docker-image:
                  context: docker-hub
                  requires:
                      - build-docker-image
                      - test       A job can only run when its dependencies are satisfied therefore it requires the dependencies of all upstream jobs. This means only the immediate upstream dependencies need to be specified in the requires: blocks.          Sample configuration with multiple executor types   It is possible to use multiple  executor types in the same workflow.   In Example-1 each push will build and test the project on Linux, Windows and macOS.   In Example-2 each push of an iOS project will be built on macOS, and additional iOS tools ( SwiftLint and  Danger) will be run in Docker.  Example 1Example 2    version: 2.1

orbs:
  github-release: haskell-works/github-release@1.3.3

parameters:
  src-repo-url:
    type: string
    default: https://github.com/esnet/iperf.git
  branch-name:
    type: string
    default: "3.8.1"
  common-build-params:
    type: string
    default: "--disable-shared --disable-static"

jobs:
  build-linux:
    docker:
      - image: archlinux/base
    parameters:
      label:
        type: string
        default: iperf3-linux
    steps:
      - run:
          name: Install dependencies
          command: pacman -Syu --noconfirm openssl git gcc make awk tar
      - run:
          name: Clone iperf3
          command: git clone << pipeline.parameters.src-repo-url >> -b << pipeline.parameters.branch-name >>
      - run:
          name: Build iperf3
          working_directory: iperf
          command: |
            CIRCLE_WORKING_DIRECTORY=$(eval "echo $CIRCLE_WORKING_DIRECTORY")
            IPERF3_MAKE_PREFIX=$CIRCLE_WORKING_DIRECTORY/<< parameters.label >>
            ./configure --prefix=$IPERF3_MAKE_PREFIX << pipeline.parameters.common-build-params >>
            make
            mkdir -p $IPERF3_MAKE_PREFIX
            make install
      - run:
          name: Create a tarball
          command: tar -cJf << parameters.label >>.tar.xz << parameters.label >>
      - persist_to_workspace:
          root: .
          paths:
            - << parameters.label >>.tar.xz
      - store_artifacts:
          path: << parameters.label >>.tar.xz

  build-windows:
    machine:
      image: windows-server-2019-vs2019:stable
      shell: powershell.exe
    resource_class: windows.medium
    parameters:
      label:
        type: string
        default: iperf3-cygwin64
    steps:
      - run:
          name: Download Cygwin installer
          shell: bash.exe
          command: |
            curl -sSJOL https://cygwin.com/setup-x86_64.exe
      - run:
          name: Install Cygwin and required packages
          command: . etup-x86_64.exe -q -s https://mirrors.kernel.org/sourceware/cygwin/ -P libssl-devel,git,gcc-core,make
      - run:
          name: Build iperf3 with Cygwin
          shell: C:\\cygwin64\\bin\\bash.exe --login -eo pipefail
          command: |
            CIRCLE_WORKING_DIRECTORY=$(eval "echo $CIRCLE_WORKING_DIRECTORY")
            IPERF3_MAKE_PREFIX=$CIRCLE_WORKING_DIRECTORY/<< parameters.label >>
            cd $CIRCLE_WORKING_DIRECTORY
            git clone << pipeline.parameters.src-repo-url >> -b << pipeline.parameters.branch-name >>
            cd iperf
            ./configure --prefix=$IPERF3_MAKE_PREFIX << pipeline.parameters.common-build-params >>
            make
            mkdir -p $IPERF3_MAKE_PREFIX
            make install
            cp /usr/bin/cygwin1.dll /usr/bin/cygcrypto-1.1.dll /usr/bin/cygz.dll -t $IPERF3_MAKE_PREFIX/bin
      - run:
          name: Create a Zip file
          command: |
            $ProgressPreference = "SilentlyContinue"
            Compress-Archive .\\<< parameters.label >> .\\<< parameters.label >>.zip
      - persist_to_workspace:
          root: .
          paths:
            - << parameters.label >>.zip
      - store_artifacts:
          path: << parameters.label >>.zip

  build-macos:
    macos:
      xcode: 14.2.0
    parameters:
      label:
        type: string
        default: iperf3-macos
    steps:
      - run:
          name: Clone iperf3
          command: git clone << pipeline.parameters.src-repo-url >> -b << pipeline.parameters.branch-name >>
      - run:
          name: Build iperf3
          working_directory: iperf
          command: |
            CIRCLE_WORKING_DIRECTORY=$(eval "echo $CIRCLE_WORKING_DIRECTORY")
            IPERF3_MAKE_PREFIX=$CIRCLE_WORKING_DIRECTORY/<< parameters.label >>
            ./configure --prefix=$IPERF3_MAKE_PREFIX --with-openssl=$(brew --prefix openssl) << pipeline.parameters.common-build-params >>
            make
            mkdir -p $IPERF3_MAKE_PREFIX
            make install
            # Postruns
            cd $IPERF3_MAKE_PREFIX/bin
            # Copy linked OpenSSL libraris to the current directory
            # and tell the linker to refer to them
            otool -L iperf3 | grep openssl | awk '{ print $1 }' | while read dylib
            do
              name=$(basename $dylib)
              cp $dylib ./
              chmod u+w $name
              install_name_tool -change $dylib @executable_path/$name iperf3
            done
            # Modify libssl as well
            otool -L libssl.1.1.dylib | grep openssl | awk '{ print $1 }' | while read dylib
            do
              install_name_tool -change $dylib @executable_path/$(basename $dylib) libssl.1.1.dylib
            done
      - run:
          name: Create a Zip file
          command: zip -r << parameters.label >>.zip << parameters.label >>
      - persist_to_workspace:
          root: .
          paths:
            - << parameters.label >>.zip
      - store_artifacts:
          path: << parameters.label >>.zip

  test-linux:
    docker:
      - image: cimg/base:stable
    parameters:
      label:
        type: string
        default: iperf3-linux
    steps:
      - attach_workspace:
          at: ./
      - run:
          name: Extract << parameters.label >>.tar.xz
          command: tar -xf << parameters.label >>.tar.xz
      - run:
          name: Test executable
          command: << parameters.label >>/bin/iperf3 -v
      - run:
          name: Run as a server
          command: << parameters.label >>/bin/iperf3 -s
          background: true
      - run:
          name: Run as a client
          command: << parameters.label >>/bin/iperf3 -c localhost -R

  test-windows:
    machine:
      image: windows-server-2019-vs2019:stable
      shell: powershell.exe
    resource_class: windows.medium
    parameters:
      label:
        type: string
        default: iperf3-cygwin64
    steps:
      - attach_workspace:
          at: .
      - run:
          name: Extract iperf3-cygwin64.zip
          command: |
            $ProgressPreference = "SilentlyContinue"
            Expand-Archive .\\<< parameters.label >>.zip .
      - run:
          name: Test executable
          command: .\\<< parameters.label >>\bin\iperf3.exe -v
      - run:
          name: Run as a server
          command: .\\<< parameters.label >>\bin\iperf3.exe -s
          background: true
      - run:
          name: Run as a client
          command: .\\<< parameters.label >>\bin\iperf3.exe -c localhost -R

  test-macos:
    macos:
      xcode: 14.2.0
    parameters:
      label:
        type: string
        default: iperf3-macos
    steps:
      - attach_workspace:
          at: .
      - run:
          name: Uninstall pre-installed OpenSSL
          command: brew uninstall --ignore-dependencies openssl
      - run:
          name: Extract << parameters.label >>
          command: unzip << parameters.label >>
      - run:
          name: Test executable
          command: << parameters.label >>/bin/iperf3 -v
      - run:
          name: Run as a server
          command: << parameters.label >>/bin/iperf3 -s
          background: true
      - run:
          name: Run as a client
          command: << parameters.label >>/bin/iperf3 -c localhost -R

  release:
    executor: github-release/default
    steps:
      - attach_workspace:
          at: .
      - run:
          name: Compute version number
          command: |
            echo 'export IPERF3_BUILD_VERSION="<< pipeline.parameters.branch-name>>-${CIRCLE_BUILD_NUM}-${CIRCLE_SHA1:0:7}"' | tee -a "$BASH_ENV"
      - github-release/release:
          tag: v$IPERF3_BUILD_VERSION
          title: $IPERF3_BUILD_VERSION
          artefacts-folder: .

workflows:
  build-test-release:
    jobs:
      - build-linux
      - build-windows
      - build-macos
      - test-linux:
          requires:
            - build-linux
      - test-windows:
          requires:
            - build-windows
      - test-macos:
          requires:
            - build-macos
      - release:
          requires:
            - test-linux
            - test-windows
            - test-macos
          context: github
          filters:
            branches:
              only: main        version: 2.1

jobs:
  build-and-test:
    macos:
      xcode: 14.2.0
    steps:
      - checkout
      - run:
          name: Install CocoaPods
          command: pod install --verbose
      - run:
          name: Build and run tests
          command: fastlane scan
          environment:
            SCAN_DEVICE: iPhone 8
            SCAN_SCHEME: WebTests
      - store_test_results:
          path: test_output/report.xml
      - store_artifacts:
          path: /tmp/test-results
          destination: scan-test-results
      - store_artifacts:
          path: ~/Library/Logs/scan
          destination: scan-logs

  swiftlint:
    docker:
      - image: dantoml/swiftlint:latest
    steps:
      - checkout
      - run: swiftlint lint --reporter junit | tee result.xml
      - store_artifacts:
          path: result.xml
      - store_test_results:
          path: result.xml

  danger:
    docker:
      - image: dantoml/danger:latest
    steps:
      - checkout
      - run: danger

workflows:
  build-test-lint:
    jobs:
      - swiftlint
      - danger
      - build-and-test         See also     See the  Concepts document and  Workflows for more details of the concepts covered in this example.   See the  Configuration Reference document for full details of each individual configuration key.   See the  Example Public Repos document for a list of public projects that use CircleCI.     Suggest an edit to this pageMake a contribution Learn how to contributeStill need help? Ask the CircleCI community Join the research community Visit our Support site DocsTerms of UsePrivacy PolicyCookie PolicySecurity© 2025 Circle Internet Services, Inc., All Rights Reserved.\n\nUsing Docker? Authenticating Docker pulls from image registries is recommended when using the Docker execution environment. Authenticated pulls allow access to private Docker images, and may also grant higher rate limits, depending on your registry provider. For further information see  Using Docker authenticated pulls.    version: 2.1

# Define the jobs we want to run for this project
jobs:
  build:
    docker:
      - image: cimg/base:2023.03
    steps:
      - checkout
      - run: echo "this is the build job"
  test:
    docker:
      - image: cimg/base:2023.03
    steps:
      - checkout
      - run: echo "this is the test job"

# Orchestrate our job run sequence
workflows:
  build_and_test:
    jobs:
      - build
      - test    version: 2.1

# Define the jobs we want to run for this project
jobs:
  build:
    docker:
      - image: cimg/base:2023.03
    steps:
      - checkout
      - run: echo "this is the build job"
  test:
    docker:
      - image: cimg/base:2023.03
    steps:
      - checkout
      - run: echo "this is the test job"

# Orchestrate our job run sequence
workflows:
  build_and_test:
    jobs:
      - build
      - test:
          requires:
            - build  version: 2.1

executors: # Define an executor
  my-executor:
    docker:
      - image: cimg/base:2024.01
# Define the jobs we want to run for this project
jobs:
  build:
    executor: my-executor
    steps:
      - checkout
      - run: echo "build"
  test:
    executor: my-executor
    steps:
      - checkout
      - run: echo "test"
  deploy:
    executor: my-executor
    steps:
      - checkout
      - run: echo "deploy"

# Orchestrate our job run sequence
workflows:
  build_and_test:
    jobs:
      - build
      - test:
          requires:
            - build
      - hold:
          type: approval
          requires:
            - build
      - deploy:
          requires:
            - hold    # Use the latest 2.1 version of CircleCI pipeline process engine.
# See: https://circleci.com/docs/configuration-reference
version: 2.1

# Define a job to be invoked later in a workflow.
# See: https://circleci.com/docs/jobs-steps/#jobs-overview & https://circleci.com/docs/configuration-reference/#jobs
jobs:
  say-hello:
    # Specify the execution environment. You can specify an image from Docker Hub or use one of our convenience images from CircleCI's Developer Hub.
    # See: https://circleci.com/docs/executor-intro/ & https://circleci.com/docs/configuration-reference/#executor-job
    docker:
      # Specify the version you desire here
      # See: https://circleci.com/developer/images/image/cimg/base
      - image: cimg/base:current

    # Add steps to the job
    # See: https://circleci.com/docs/jobs-steps/#steps-overview & https://circleci.com/docs/configuration-reference/#steps
    steps:
      # Checkout the code as the first step.
      - checkout
      - run:
          name: "Say hello"
          command: "echo Hello, World!"

# Orchestrate jobs using workflows
# See: https://circleci.com/docs/workflows/ & https://circleci.com/docs/configuration-reference/#workflows
workflows:
  say-hello-workflow: # This is the name of the workflow, feel free to change it to better match your workflow.
    # Inside the workflow, you define the jobs you want to run.
    jobs:
      - say-hello  version: 2.1

orbs:
  node: circleci/node@3.0.0

jobs:
  build:
    working_directory: ~/mern-starter
    # Reuse Docker container specification given by the node Orb
    executor: node/default
    steps:
      - checkout
      # Install the latest npm - the node Orb takes care of it
      - node/install-npm
      # Install dependencies - the node Orb take care of installation and dependency caching
      - node/install-packages:
          app-dir: ~/mern-starter
          cache-path: node_modules
          override-ci-command: npm i
      # Save workspace for subsequent jobs (i.e. test)
      - persist_to_workspace:
          root: .
          paths:
            - .

  test:
    docker:
      # The primary container is an instance of the first image listed. The job's commands run in this container.
      - image: cimg/node:current
      # The secondary container is an instance of the second listed image which is run in a common network where ports exposed on the primary container are available on localhost.
      - image: mongo:4.2
    steps:
      # Reuse the workspace from the build job
      - attach_workspace:
          at: .
      - run:
          name: Demonstrate that Mongo DB is available as localhost
          command: |
            curl -sSJL https://www.mongodb.org/static/pgp/server-4.2.asc | sudo apt-key add -
            echo "deb [ arch=amd64,arm64 ] https://repo.mongodb.org/apt/ubuntu bionic/mongodb-org/4.2 multiverse" | sudo tee /etc/apt/sources.list.d/mongodb-org-4.2.list
            sudo apt update
            sudo apt install mongodb-org
            mongo localhost --eval "db.serverStatus()"
      - run:
          name: Test
          command: npm test
      - run:
          name: Generate code coverage
          command: './node_modules/.bin/nyc report --reporter=text-lcov'
      # You can specify either a single file or a directory to store as artifacts
      - store_artifacts:
          path: test-results.xml
          destination: deliverable.xml
      - store_artifacts:
          path: coverage
          destination: coverage

workflows:
  build_and_test:
    jobs:
      - build
      - test:
          requires:
            - build    version: 2.1

orbs:
    docker: circleci/docker@1.0.1

jobs:
    prepare-dependencies:
        docker:
            - image: node:current-alpine
        steps:
            - checkout
            - run:
                  name: Compute version number
                  command: echo "0.0.${CIRCLE_BUILD_NUM}-${CIRCLE_SHA1:0:7}" | tee version.txt
            - restore_cache:
                  keys:
                      - yarn-deps-{{ checksum "yarn.lock" }}
                      - yarn-deps
            - run:
                  name: yarn install
                  command: yarn install
            - save_cache:
                  paths:
                      - node_modules
                  key: yarn-deps-{{ checksum "yarn.lock" }}-{{ epoch }}
            - store_artifacts:
                  path: yarn.lock
            - persist_to_workspace:
                  root: .
                  paths:
                      - .

    build-production:
        docker:
            - image: node:current-alpine
        steps:
            - attach_workspace:
                  at: .
            - run:
                  name: Production build
                  command: |
                      export __BUILD_VERSION="$(cat version.txt)"
                      yarn build
            - store_artifacts:
                  path: dist/server.js
            - persist_to_workspace:
                  root: .
                  paths:
                      - .

    build-docker-image:
        machine:
            # The image uses the current tag, which always points to the most recent
            # supported release. If stability and determinism are crucial for your CI
            # pipeline, use a release date tag with your image, e.g. ubuntu-2004:202201-02
            image: ubuntu-2004:current
        steps:
            - attach_workspace:
                  at: .
            - run:
                  name: Setup __BUILD_VERSION envvar
                  command: |
                      echo 'export __BUILD_VERSION="$(cat version.txt)"' >> "$BASH_ENV"
            - docker/check:
                  registry: $DOCKER_REGISTRY
            - docker/build:
                  image: $DOCKER_IMAGE_NAME
                  tag: $__BUILD_VERSION
                  registry: $DOCKER_REGISTRY
            - docker/push:
                  image: $DOCKER_IMAGE_NAME
                  tag: $__BUILD_VERSION
                  registry: $DOCKER_REGISTRY

    test:
        docker:
            - image: node:current-alpine
        parallelism: 2
        steps:
            - attach_workspace:
                  at: .
            - run:
                  name: Run tests
                  command: |
                      circleci tests glob '**/*.test.ts' | circleci tests split --split-by timings | xargs yarn test:ci
            - store_artifacts:
                  path: test-results
            - store_test_results:
                  path: test-results

    deploy-docker-image:
        machine:
            image: ubuntu-2004:current
        steps:
            - attach_workspace:
                  at: .
            - run:
                  name: Setup __BUILD_VERSION envvar
                  command: |
                      echo 'export __BUILD_VERSION="$(cat version.txt)"' >> "$BASH_ENV"
            - docker/check:
                  registry: $DOCKER_REGISTRY
            - docker/pull:
                  images: $DOCKER_REGISTRY/$DOCKER_IMAGE_NAME:$__BUILD_VERSION
            - run:
                  name: Tag the image as latest
                  command: docker tag $DOCKER_REGISTRY/$DOCKER_IMAGE_NAME:$__BUILD_VERSION $DOCKER_REGISTRY/$DOCKER_IMAGE_NAME:latest
            - docker/push:
                  image: $DOCKER_IMAGE_NAME
                  tag: latest
                  registry: $DOCKER_REGISTRY

workflows:
    build-test-deploy:
        jobs:
            - prepare-dependencies
            - build-production:
                  requires:
                      - prepare-dependencies
            - build-docker-image:
                  context: docker-hub
                  requires:
                      - build-production
            - test:
                  requires:
                      - prepare-dependencies
            - deploy-docker-image:
                  context: docker-hub
                  requires:
                      - build-docker-image
                      - test  A job can only run when its dependencies are satisfied therefore it requires the dependencies of all upstream jobs. This means only the immediate upstream dependencies need to be specified in the requires: blocks.    version: 2.1

orbs:
  github-release: haskell-works/github-release@1.3.3

parameters:
  src-repo-url:
    type: string
    default: https://github.com/esnet/iperf.git
  branch-name:
    type: string
    default: "3.8.1"
  common-build-params:
    type: string
    default: "--disable-shared --disable-static"

jobs:
  build-linux:
    docker:
      - image: archlinux/base
    parameters:
      label:
        type: string
        default: iperf3-linux
    steps:
      - run:
          name: Install dependencies
          command: pacman -Syu --noconfirm openssl git gcc make awk tar
      - run:
          name: Clone iperf3
          command: git clone << pipeline.parameters.src-repo-url >> -b << pipeline.parameters.branch-name >>
      - run:
          name: Build iperf3
          working_directory: iperf
          command: |
            CIRCLE_WORKING_DIRECTORY=$(eval "echo $CIRCLE_WORKING_DIRECTORY")
            IPERF3_MAKE_PREFIX=$CIRCLE_WORKING_DIRECTORY/<< parameters.label >>
            ./configure --prefix=$IPERF3_MAKE_PREFIX << pipeline.parameters.common-build-params >>
            make
            mkdir -p $IPERF3_MAKE_PREFIX
            make install
      - run:
          name: Create a tarball
          command: tar -cJf << parameters.label >>.tar.xz << parameters.label >>
      - persist_to_workspace:
          root: .
          paths:
            - << parameters.label >>.tar.xz
      - store_artifacts:
          path: << parameters.label >>.tar.xz

  build-windows:
    machine:
      image: windows-server-2019-vs2019:stable
      shell: powershell.exe
    resource_class: windows.medium
    parameters:
      label:
        type: string
        default: iperf3-cygwin64
    steps:
      - run:
          name: Download Cygwin installer
          shell: bash.exe
          command: |
            curl -sSJOL https://cygwin.com/setup-x86_64.exe
      - run:
          name: Install Cygwin and required packages
          command: . etup-x86_64.exe -q -s https://mirrors.kernel.org/sourceware/cygwin/ -P libssl-devel,git,gcc-core,make
      - run:
          name: Build iperf3 with Cygwin
          shell: C:\\cygwin64\\bin\\bash.exe --login -eo pipefail
          command: |
            CIRCLE_WORKING_DIRECTORY=$(eval "echo $CIRCLE_WORKING_DIRECTORY")
            IPERF3_MAKE_PREFIX=$CIRCLE_WORKING_DIRECTORY/<< parameters.label >>
            cd $CIRCLE_WORKING_DIRECTORY
            git clone << pipeline.parameters.src-repo-url >> -b << pipeline.parameters.branch-name >>
            cd iperf
            ./configure --prefix=$IPERF3_MAKE_PREFIX << pipeline.parameters.common-build-params >>
            make
            mkdir -p $IPERF3_MAKE_PREFIX
            make install
            cp /usr/bin/cygwin1.dll /usr/bin/cygcrypto-1.1.dll /usr/bin/cygz.dll -t $IPERF3_MAKE_PREFIX/bin
      - run:
          name: Create a Zip file
          command: |
            $ProgressPreference = "SilentlyContinue"
            Compress-Archive .\\<< parameters.label >> .\\<< parameters.label >>.zip
      - persist_to_workspace:
          root: .
          paths:
            - << parameters.label >>.zip
      - store_artifacts:
          path: << parameters.label >>.zip

  build-macos:
    macos:
      xcode: 14.2.0
    parameters:
      label:
        type: string
        default: iperf3-macos
    steps:
      - run:
          name: Clone iperf3
          command: git clone << pipeline.parameters.src-repo-url >> -b << pipeline.parameters.branch-name >>
      - run:
          name: Build iperf3
          working_directory: iperf
          command: |
            CIRCLE_WORKING_DIRECTORY=$(eval "echo $CIRCLE_WORKING_DIRECTORY")
            IPERF3_MAKE_PREFIX=$CIRCLE_WORKING_DIRECTORY/<< parameters.label >>
            ./configure --prefix=$IPERF3_MAKE_PREFIX --with-openssl=$(brew --prefix openssl) << pipeline.parameters.common-build-params >>
            make
            mkdir -p $IPERF3_MAKE_PREFIX
            make install
            # Postruns
            cd $IPERF3_MAKE_PREFIX/bin
            # Copy linked OpenSSL libraris to the current directory
            # and tell the linker to refer to them
            otool -L iperf3 | grep openssl | awk '{ print $1 }' | while read dylib
            do
              name=$(basename $dylib)
              cp $dylib ./
              chmod u+w $name
              install_name_tool -change $dylib @executable_path/$name iperf3
            done
            # Modify libssl as well
            otool -L libssl.1.1.dylib | grep openssl | awk '{ print $1 }' | while read dylib
            do
              install_name_tool -change $dylib @executable_path/$(basename $dylib) libssl.1.1.dylib
            done
      - run:
          name: Create a Zip file
          command: zip -r << parameters.label >>.zip << parameters.label >>
      - persist_to_workspace:
          root: .
          paths:
            - << parameters.label >>.zip
      - store_artifacts:
          path: << parameters.label >>.zip

  test-linux:
    docker:
      - image: cimg/base:stable
    parameters:
      label:
        type: string
        default: iperf3-linux
    steps:
      - attach_workspace:
          at: ./
      - run:
          name: Extract << parameters.label >>.tar.xz
          command: tar -xf << parameters.label >>.tar.xz
      - run:
          name: Test executable
          command: << parameters.label >>/bin/iperf3 -v
      - run:
          name: Run as a server
          command: << parameters.label >>/bin/iperf3 -s
          background: true
      - run:
          name: Run as a client
          command: << parameters.label >>/bin/iperf3 -c localhost -R

  test-windows:
    machine:
      image: windows-server-2019-vs2019:stable
      shell: powershell.exe
    resource_class: windows.medium
    parameters:
      label:
        type: string
        default: iperf3-cygwin64
    steps:
      - attach_workspace:
          at: .
      - run:
          name: Extract iperf3-cygwin64.zip
          command: |
            $ProgressPreference = "SilentlyContinue"
            Expand-Archive .\\<< parameters.label >>.zip .
      - run:
          name: Test executable
          command: .\\<< parameters.label >>\bin\iperf3.exe -v
      - run:
          name: Run as a server
          command: .\\<< parameters.label >>\bin\iperf3.exe -s
          background: true
      - run:
          name: Run as a client
          command: .\\<< parameters.label >>\bin\iperf3.exe -c localhost -R

  test-macos:
    macos:
      xcode: 14.2.0
    parameters:
      label:
        type: string
        default: iperf3-macos
    steps:
      - attach_workspace:
          at: .
      - run:
          name: Uninstall pre-installed OpenSSL
          command: brew uninstall --ignore-dependencies openssl
      - run:
          name: Extract << parameters.label >>
          command: unzip << parameters.label >>
      - run:
          name: Test executable
          command: << parameters.label >>/bin/iperf3 -v
      - run:
          name: Run as a server
          command: << parameters.label >>/bin/iperf3 -s
          background: true
      - run:
          name: Run as a client
          command: << parameters.label >>/bin/iperf3 -c localhost -R

  release:
    executor: github-release/default
    steps:
      - attach_workspace:
          at: .
      - run:
          name: Compute version number
          command: |
            echo 'export IPERF3_BUILD_VERSION="<< pipeline.parameters.branch-name>>-${CIRCLE_BUILD_NUM}-${CIRCLE_SHA1:0:7}"' | tee -a "$BASH_ENV"
      - github-release/release:
          tag: v$IPERF3_BUILD_VERSION
          title: $IPERF3_BUILD_VERSION
          artefacts-folder: .

workflows:
  build-test-release:
    jobs:
      - build-linux
      - build-windows
      - build-macos
      - test-linux:
          requires:
            - build-linux
      - test-windows:
          requires:
            - build-windows
      - test-macos:
          requires:
            - build-macos
      - release:
          requires:
            - test-linux
            - test-windows
            - test-macos
          context: github
          filters:
            branches:
              only: main    version: 2.1

orbs:
  github-release: haskell-works/github-release@1.3.3

parameters:
  src-repo-url:
    type: string
    default: https://github.com/esnet/iperf.git
  branch-name:
    type: string
    default: "3.8.1"
  common-build-params:
    type: string
    default: "--disable-shared --disable-static"

jobs:
  build-linux:
    docker:
      - image: archlinux/base
    parameters:
      label:
        type: string
        default: iperf3-linux
    steps:
      - run:
          name: Install dependencies
          command: pacman -Syu --noconfirm openssl git gcc make awk tar
      - run:
          name: Clone iperf3
          command: git clone << pipeline.parameters.src-repo-url >> -b << pipeline.parameters.branch-name >>
      - run:
          name: Build iperf3
          working_directory: iperf
          command: |
            CIRCLE_WORKING_DIRECTORY=$(eval "echo $CIRCLE_WORKING_DIRECTORY")
            IPERF3_MAKE_PREFIX=$CIRCLE_WORKING_DIRECTORY/<< parameters.label >>
            ./configure --prefix=$IPERF3_MAKE_PREFIX << pipeline.parameters.common-build-params >>
            make
            mkdir -p $IPERF3_MAKE_PREFIX
            make install
      - run:
          name: Create a tarball
          command: tar -cJf << parameters.label >>.tar.xz << parameters.label >>
      - persist_to_workspace:
          root: .
          paths:
            - << parameters.label >>.tar.xz
      - store_artifacts:
          path: << parameters.label >>.tar.xz

  build-windows:
    machine:
      image: windows-server-2019-vs2019:stable
      shell: powershell.exe
    resource_class: windows.medium
    parameters:
      label:
        type: string
        default: iperf3-cygwin64
    steps:
      - run:
          name: Download Cygwin installer
          shell: bash.exe
          command: |
            curl -sSJOL https://cygwin.com/setup-x86_64.exe
      - run:
          name: Install Cygwin and required packages
          command: . etup-x86_64.exe -q -s https://mirrors.kernel.org/sourceware/cygwin/ -P libssl-devel,git,gcc-core,make
      - run:
          name: Build iperf3 with Cygwin
          shell: C:\\cygwin64\\bin\\bash.exe --login -eo pipefail
          command: |
            CIRCLE_WORKING_DIRECTORY=$(eval "echo $CIRCLE_WORKING_DIRECTORY")
            IPERF3_MAKE_PREFIX=$CIRCLE_WORKING_DIRECTORY/<< parameters.label >>
            cd $CIRCLE_WORKING_DIRECTORY
            git clone << pipeline.parameters.src-repo-url >> -b << pipeline.parameters.branch-name >>
            cd iperf
            ./configure --prefix=$IPERF3_MAKE_PREFIX << pipeline.parameters.common-build-params >>
            make
            mkdir -p $IPERF3_MAKE_PREFIX
            make install
            cp /usr/bin/cygwin1.dll /usr/bin/cygcrypto-1.1.dll /usr/bin/cygz.dll -t $IPERF3_MAKE_PREFIX/bin
      - run:
          name: Create a Zip file
          command: |
            $ProgressPreference = "SilentlyContinue"
            Compress-Archive .\\<< parameters.label >> .\\<< parameters.label >>.zip
      - persist_to_workspace:
          root: .
          paths:
            - << parameters.label >>.zip
      - store_artifacts:
          path: << parameters.label >>.zip

  build-macos:
    macos:
      xcode: 14.2.0
    parameters:
      label:
        type: string
        default: iperf3-macos
    steps:
      - run:
          name: Clone iperf3
          command: git clone << pipeline.parameters.src-repo-url >> -b << pipeline.parameters.branch-name >>
      - run:
          name: Build iperf3
          working_directory: iperf
          command: |
            CIRCLE_WORKING_DIRECTORY=$(eval "echo $CIRCLE_WORKING_DIRECTORY")
            IPERF3_MAKE_PREFIX=$CIRCLE_WORKING_DIRECTORY/<< parameters.label >>
            ./configure --prefix=$IPERF3_MAKE_PREFIX --with-openssl=$(brew --prefix openssl) << pipeline.parameters.common-build-params >>
            make
            mkdir -p $IPERF3_MAKE_PREFIX
            make install
            # Postruns
            cd $IPERF3_MAKE_PREFIX/bin
            # Copy linked OpenSSL libraris to the current directory
            # and tell the linker to refer to them
            otool -L iperf3 | grep openssl | awk '{ print $1 }' | while read dylib
            do
              name=$(basename $dylib)
              cp $dylib ./
              chmod u+w $name
              install_name_tool -change $dylib @executable_path/$name iperf3
            done
            # Modify libssl as well
            otool -L libssl.1.1.dylib | grep openssl | awk '{ print $1 }' | while read dylib
            do
              install_name_tool -change $dylib @executable_path/$(basename $dylib) libssl.1.1.dylib
            done
      - run:
          name: Create a Zip file
          command: zip -r << parameters.label >>.zip << parameters.label >>
      - persist_to_workspace:
          root: .
          paths:
            - << parameters.label >>.zip
      - store_artifacts:
          path: << parameters.label >>.zip

  test-linux:
    docker:
      - image: cimg/base:stable
    parameters:
      label:
        type: string
        default: iperf3-linux
    steps:
      - attach_workspace:
          at: ./
      - run:
          name: Extract << parameters.label >>.tar.xz
          command: tar -xf << parameters.label >>.tar.xz
      - run:
          name: Test executable
          command: << parameters.label >>/bin/iperf3 -v
      - run:
          name: Run as a server
          command: << parameters.label >>/bin/iperf3 -s
          background: true
      - run:
          name: Run as a client
          command: << parameters.label >>/bin/iperf3 -c localhost -R

  test-windows:
    machine:
      image: windows-server-2019-vs2019:stable
      shell: powershell.exe
    resource_class: windows.medium
    parameters:
      label:
        type: string
        default: iperf3-cygwin64
    steps:
      - attach_workspace:
          at: .
      - run:
          name: Extract iperf3-cygwin64.zip
          command: |
            $ProgressPreference = "SilentlyContinue"
            Expand-Archive .\\<< parameters.label >>.zip .
      - run:
          name: Test executable
          command: .\\<< parameters.label >>\bin\iperf3.exe -v
      - run:
          name: Run as a server
          command: .\\<< parameters.label >>\bin\iperf3.exe -s
          background: true
      - run:
          name: Run as a client
          command: .\\<< parameters.label >>\bin\iperf3.exe -c localhost -R

  test-macos:
    macos:
      xcode: 14.2.0
    parameters:
      label:
        type: string
        default: iperf3-macos
    steps:
      - attach_workspace:
          at: .
      - run:
          name: Uninstall pre-installed OpenSSL
          command: brew uninstall --ignore-dependencies openssl
      - run:
          name: Extract << parameters.label >>
          command: unzip << parameters.label >>
      - run:
          name: Test executable
          command: << parameters.label >>/bin/iperf3 -v
      - run:
          name: Run as a server
          command: << parameters.label >>/bin/iperf3 -s
          background: true
      - run:
          name: Run as a client
          command: << parameters.label >>/bin/iperf3 -c localhost -R

  release:
    executor: github-release/default
    steps:
      - attach_workspace:
          at: .
      - run:
          name: Compute version number
          command: |
            echo 'export IPERF3_BUILD_VERSION="<< pipeline.parameters.branch-name>>-${CIRCLE_BUILD_NUM}-${CIRCLE_SHA1:0:7}"' | tee -a "$BASH_ENV"
      - github-release/release:
          tag: v$IPERF3_BUILD_VERSION
          title: $IPERF3_BUILD_VERSION
          artefacts-folder: .

workflows:
  build-test-release:
    jobs:
      - build-linux
      - build-windows
      - build-macos
      - test-linux:
          requires:
            - build-linux
      - test-windows:
          requires:
            - build-windows
      - test-macos:
          requires:
            - build-macos
      - release:
          requires:
            - test-linux
            - test-windows
            - test-macos
          context: github
          filters:
            branches:
              only: main    version: 2.1

jobs:
  build-and-test:
    macos:
      xcode: 14.2.0
    steps:
      - checkout
      - run:
          name: Install CocoaPods
          command: pod install --verbose
      - run:
          name: Build and run tests
          command: fastlane scan
          environment:
            SCAN_DEVICE: iPhone 8
            SCAN_SCHEME: WebTests
      - store_test_results:
          path: test_output/report.xml
      - store_artifacts:
          path: /tmp/test-results
          destination: scan-test-results
      - store_artifacts:
          path: ~/Library/Logs/scan
          destination: scan-logs

  swiftlint:
    docker:
      - image: dantoml/swiftlint:latest
    steps:
      - checkout
      - run: swiftlint lint --reporter junit | tee result.xml
      - store_artifacts:
          path: result.xml
      - store_test_results:
          path: result.xml

  danger:
    docker:
      - image: dantoml/danger:latest
    steps:
      - checkout
      - run: danger

workflows:
  build-test-lint:
    jobs:
      - swiftlint
      - danger
      - build-and-test    version: 2.1

jobs:
  build-and-test:
    macos:
      xcode: 14.2.0
    steps:
      - checkout
      - run:
          name: Install CocoaPods
          command: pod install --verbose
      - run:
          name: Build and run tests
          command: fastlane scan
          environment:
            SCAN_DEVICE: iPhone 8
            SCAN_SCHEME: WebTests
      - store_test_results:
          path: test_output/report.xml
      - store_artifacts:
          path: /tmp/test-results
          destination: scan-test-results
      - store_artifacts:
          path: ~/Library/Logs/scan
          destination: scan-logs

  swiftlint:
    docker:
      - image: dantoml/swiftlint:latest
    steps:
      - checkout
      - run: swiftlint lint --reporter junit | tee result.xml
      - store_artifacts:
          path: result.xml
      - store_test_results:
          path: result.xml

  danger:
    docker:
      - image: dantoml/danger:latest
    steps:
      - checkout
      - run: danger

workflows:
  build-test-lint:
    jobs:
      - swiftlint
      - danger
      - build-and-test\n\n\n\nDatabase configuration examples2 weeks ago2 min readCloudServer v4+On This PageExample CircleCI configuration for a rails app with structure.sqlExample environment setupExample go app with PostgreSQLExample MYSQL project.See also   This document provides example database  config.yml files using PostgreSQL/Rails and MySQL/Ruby.      Using Docker? Authenticating Docker pulls from image registries is recommended when using the Docker execution environment. Authenticated pulls allow access to private Docker images, and may also grant higher rate limits, depending on your registry provider. For further information see  Using Docker authenticated pulls.          Example CircleCI configuration for a rails app with structure.sql   If you are migrating a Rails app configured with a structure.sql file make sure that psql is installed in your PATH and has the proper permissions, as follows, because the cimg/ruby:3.0-node image does not have psql installed by default and uses pg gem for database access.    version: 2.1
jobs:
  build:
    working_directory: ~/circleci-demo-ruby-rails

    # Primary container image where all commands run

    docker:
      - image: cimg/ruby:2.6-node
        environment:
          RAILS_ENV: test
          PGHOST: 127.0.0.1
          PGUSER: root

    # Service container image available at `host: localhost`

      - image: cimg/postgres:14.0
        environment:
          POSTGRES_USER: testuser
          POSTGRES_DB: circle-test_test

    steps:
      - checkout

      # Restore bundle cache
      - restore_cache:
          keys:
            - rails-demo-{{ checksum "Gemfile.lock" }}
            - rails-demo-

      # Bundle install dependencies
      - run:
          name: Install dependencies
          command: bundle check --path=vendor/bundle || bundle install --path=vendor/bundle --jobs 4 --retry 3

      - run: sudo apt install -y postgresql-client || true

      # Store bundle cache
      - save_cache:
          key: rails-demo-{{ checksum "Gemfile.lock" }}
          paths:
            - vendor/bundle

      - run:
          name: Database Setup
          command: |
            bundle exec rake db:create
            bundle exec rake db:structure:load

      - run:
          name: Parallel RSpec
          command: bin/rails test

      # Save artifacts
      - store_test_results:
          path: /tmp/test-results       An alternative is to build your own image by extending the current image, installing the needed packages, committing, and pushing it to Docker Hub or the registry of your choosing.        Example environment setup  You must declare your database configuration explicitly because multiple pre-built or custom images may be in use. For example, Rails will try to use a database URL in the following order:     DATABASE_URL environment variable, if set   The test section configuration for the appropriate environment in your config.yml file (usually test for your test suite).     The following example demonstrates this order by combining the environment setting with the image and by also including the environment configuration in the shell command to enable the database connection:    version: 2.1
jobs:
  build:
    working_directory: ~/appName
    docker:
      - image: cimg/ruby:2.6
        environment:
          PG_HOST: localhost
          PG_USER: ubuntu
          RAILS_ENV: test
          RACK_ENV: test
      # The following example uses the official postgres 9.6 image, you may also use cimg/postgres:9.6
      # which includes a few enhancements and modifications. It is possible to use either image.
      - image: cimg/postgres:14.0
        environment:
          POSTGRES_USER: ubuntu
          POSTGRES_DB: db_name
    steps:
      - checkout
      - run:
          name: Install Ruby Dependencies
          command: bundle install
      - run:
          name: Set up DB
          command: |
            bundle exec rake db:create db:schema:load --trace
            bundle exec rake db:migrate
        environment:
          DATABASE_URL: "postgres://ubuntu@localhost:5432/db_name"    This example specifies the $DATABASE_URL as the default user and port for PostgreSQL 9.6. For version 9.5, the default port is 5433 instead of 5432. To specify a different port, change the $DATABASE_URL and all invocations of psql.      Example go app with PostgreSQL   The following configuration example is taken from the CircleCI  Go demo app.    version: 2.1
jobs:
  build:
    docker:
      # CircleCI Go images available at: https://circleci.com/developer/images/image/cimg/go
      - image: cimg/go:1.12
      # CircleCI PostgreSQL images available at: https://circleci.com/developer/images/image/cimg/postgres
      - image: cimg/postgres:14.0
        environment:
          POSTGRES_USER: circleci-demo-go
          POSTGRES_DB: circle_test

    environment:
      TEST_RESULTS: /tmp/test-results

    steps:
      - checkout
      - run: mkdir -p $TEST_RESULTS

      - restore_cache:
          keys:
            - go-mod-v1-{{ checksum "go.sum" }}

      - run:
          name: Get dependencies
          command: |
            go get -v

      - run:
          name: Get go-junit-report for setting up test timings on CircleCI
          command: |
            go get github.com/jstemmer/go-junit-report
            # Remove go-junit-report from go.mod
            go mod tidy

      #  Wait for Postgres to be ready before proceeding
      - run:
          name: Waiting for Postgres to be ready
          command: dockerize -wait tcp://localhost:5432 -timeout 1m

      - run:
          name: Run unit tests
          environment: # environment variables for the database url and path to migration files
            CONTACTS_DB_URL: "postgres://circleci-demo-go@localhost:5432/circle_test?sslmode=disable"
            CONTACTS_DB_MIGRATIONS: /home/circleci/project/db/migrations
          command: |
            trap "go-junit-report <${TEST_RESULTS}/go-test.out > ${TEST_RESULTS}/go-test-report.xml" EXIT
            make test | tee ${TEST_RESULTS}/go-test.out
      - run: make

      - save_cache:
          key: go-mod-v1-{{ checksum "go.sum" }}
          paths:
            - "/go/pkg/mod"

      - run:
          name: Start service
          environment:
            CONTACTS_DB_URL: "postgres://circleci-demo-go@localhost:5432/circle_test?sslmode=disable"
            CONTACTS_DB_MIGRATIONS: /home/circleci/project/db/migrations
          command: ./workdir/contacts
          background: true

      - run:
          name: Validate service is working
          command: |
            sleep 5
            curl --retry 10 --retry-delay 1 -X POST --header "Content-Type: application/json" -d '{"email":"test@example.com","name":"Test User"}' http://localhost:8080/contacts
      - store_artifacts:
          path: /tmp/test-results
          destination: raw-test-output

      - store_test_results:
          path: /tmp/test-results      Example MYSQL project.   The following example sets up MYSQL as a secondary container alongside a PHP container.    version: 2.1
orbs:
  browser-tools: circleci/browser-tools@1.2.3
jobs:
  build:
    docker:
      - image: cimg/php:8.1-browsers # The primary container where steps are run
      - image: cimg/mysql:8.0
        environment:
          MYSQL_ROOT_PASSWORD: rootpw
          MYSQL_DATABASE: test_db
          MYSQL_USER: user
          MYSQL_PASSWORD: passw0rd

    steps:
      - checkout
      - run:
      # Our primary container isn't MYSQL so run a sleep command until it's ready.
          name: Waiting for MySQL to be ready
          command: |
            for i in `seq 1 10`;
            do
              nc -z 127.0.0.1 3306 && echo Success && exit 0
              echo -n .
              sleep 1
            done
            echo Failed waiting for MySQL && exit 1
      - run:
          name: Install MySQL CLI; Import dummy data; run an example query
          command: |
            sudo apt-get install default-mysql-client
            mysql -h 127.0.0.1 -u user -ppassw0rd test_db < sql-data/dummy.sql
            mysql -h 127.0.0.1 -u user -ppassw0rd --execute="SELECT * FROM test_db.Persons"
workflows:
  build-deploy:
    jobs:
      - build    While it is possible to make MySQL as your primary and only container, this example does not. As a more practical use case, the example uses a PHP Docker image as its primary container, and will wait until MySQL is up and running before performing any run commands involving the DB.   Once the DB is up, we install the mysql client into the primary container so that we can run a command to connect and import the dummy data, presumably found at, sql-data/dummy.sql at the root of your project. In this case, that dummy data contains an example set of SQL commands:    DROP TABLE IF EXISTS `Persons`;

CREATE TABLE Persons (
    PersonID int,
    LastName varchar(255),
    FirstName varchar(255),
    Address varchar(255),
    City varchar(255)
);

INSERT INTO Persons
VALUES (
	1,
	"Foo",
	"Baz",
	"123 Bar Street",
	"FooBazBar City"
);      See also   Refer to the  Configuring Databases document for a walkthrough of conceptual information about using service images and database testing steps.   Suggest an edit to this pageMake a contribution Learn how to contributeStill need help? Ask the CircleCI community Join the research community Visit our Support site\n\nDatabase configuration examples2 weeks ago2 min readCloudServer v4+On This PageExample CircleCI configuration for a rails app with structure.sqlExample environment setupExample go app with PostgreSQLExample MYSQL project.See also   This document provides example database  config.yml files using PostgreSQL/Rails and MySQL/Ruby.      Using Docker? Authenticating Docker pulls from image registries is recommended when using the Docker execution environment. Authenticated pulls allow access to private Docker images, and may also grant higher rate limits, depending on your registry provider. For further information see  Using Docker authenticated pulls.          Example CircleCI configuration for a rails app with structure.sql   If you are migrating a Rails app configured with a structure.sql file make sure that psql is installed in your PATH and has the proper permissions, as follows, because the cimg/ruby:3.0-node image does not have psql installed by default and uses pg gem for database access.    version: 2.1
jobs:
  build:
    working_directory: ~/circleci-demo-ruby-rails

    # Primary container image where all commands run

    docker:
      - image: cimg/ruby:2.6-node
        environment:
          RAILS_ENV: test
          PGHOST: 127.0.0.1
          PGUSER: root

    # Service container image available at `host: localhost`

      - image: cimg/postgres:14.0
        environment:
          POSTGRES_USER: testuser
          POSTGRES_DB: circle-test_test

    steps:
      - checkout

      # Restore bundle cache
      - restore_cache:
          keys:
            - rails-demo-{{ checksum "Gemfile.lock" }}
            - rails-demo-

      # Bundle install dependencies
      - run:
          name: Install dependencies
          command: bundle check --path=vendor/bundle || bundle install --path=vendor/bundle --jobs 4 --retry 3

      - run: sudo apt install -y postgresql-client || true

      # Store bundle cache
      - save_cache:
          key: rails-demo-{{ checksum "Gemfile.lock" }}
          paths:
            - vendor/bundle

      - run:
          name: Database Setup
          command: |
            bundle exec rake db:create
            bundle exec rake db:structure:load

      - run:
          name: Parallel RSpec
          command: bin/rails test

      # Save artifacts
      - store_test_results:
          path: /tmp/test-results       An alternative is to build your own image by extending the current image, installing the needed packages, committing, and pushing it to Docker Hub or the registry of your choosing.        Example environment setup  You must declare your database configuration explicitly because multiple pre-built or custom images may be in use. For example, Rails will try to use a database URL in the following order:     DATABASE_URL environment variable, if set   The test section configuration for the appropriate environment in your config.yml file (usually test for your test suite).     The following example demonstrates this order by combining the environment setting with the image and by also including the environment configuration in the shell command to enable the database connection:    version: 2.1
jobs:
  build:
    working_directory: ~/appName
    docker:
      - image: cimg/ruby:2.6
        environment:
          PG_HOST: localhost
          PG_USER: ubuntu
          RAILS_ENV: test
          RACK_ENV: test
      # The following example uses the official postgres 9.6 image, you may also use cimg/postgres:9.6
      # which includes a few enhancements and modifications. It is possible to use either image.
      - image: cimg/postgres:14.0
        environment:
          POSTGRES_USER: ubuntu
          POSTGRES_DB: db_name
    steps:
      - checkout
      - run:
          name: Install Ruby Dependencies
          command: bundle install
      - run:
          name: Set up DB
          command: |
            bundle exec rake db:create db:schema:load --trace
            bundle exec rake db:migrate
        environment:
          DATABASE_URL: "postgres://ubuntu@localhost:5432/db_name"    This example specifies the $DATABASE_URL as the default user and port for PostgreSQL 9.6. For version 9.5, the default port is 5433 instead of 5432. To specify a different port, change the $DATABASE_URL and all invocations of psql.      Example go app with PostgreSQL   The following configuration example is taken from the CircleCI  Go demo app.    version: 2.1
jobs:
  build:
    docker:
      # CircleCI Go images available at: https://circleci.com/developer/images/image/cimg/go
      - image: cimg/go:1.12
      # CircleCI PostgreSQL images available at: https://circleci.com/developer/images/image/cimg/postgres
      - image: cimg/postgres:14.0
        environment:
          POSTGRES_USER: circleci-demo-go
          POSTGRES_DB: circle_test

    environment:
      TEST_RESULTS: /tmp/test-results

    steps:
      - checkout
      - run: mkdir -p $TEST_RESULTS

      - restore_cache:
          keys:
            - go-mod-v1-{{ checksum "go.sum" }}

      - run:
          name: Get dependencies
          command: |
            go get -v

      - run:
          name: Get go-junit-report for setting up test timings on CircleCI
          command: |
            go get github.com/jstemmer/go-junit-report
            # Remove go-junit-report from go.mod
            go mod tidy

      #  Wait for Postgres to be ready before proceeding
      - run:
          name: Waiting for Postgres to be ready
          command: dockerize -wait tcp://localhost:5432 -timeout 1m

      - run:
          name: Run unit tests
          environment: # environment variables for the database url and path to migration files
            CONTACTS_DB_URL: "postgres://circleci-demo-go@localhost:5432/circle_test?sslmode=disable"
            CONTACTS_DB_MIGRATIONS: /home/circleci/project/db/migrations
          command: |
            trap "go-junit-report <${TEST_RESULTS}/go-test.out > ${TEST_RESULTS}/go-test-report.xml" EXIT
            make test | tee ${TEST_RESULTS}/go-test.out
      - run: make

      - save_cache:
          key: go-mod-v1-{{ checksum "go.sum" }}
          paths:
            - "/go/pkg/mod"

      - run:
          name: Start service
          environment:
            CONTACTS_DB_URL: "postgres://circleci-demo-go@localhost:5432/circle_test?sslmode=disable"
            CONTACTS_DB_MIGRATIONS: /home/circleci/project/db/migrations
          command: ./workdir/contacts
          background: true

      - run:
          name: Validate service is working
          command: |
            sleep 5
            curl --retry 10 --retry-delay 1 -X POST --header "Content-Type: application/json" -d '{"email":"test@example.com","name":"Test User"}' http://localhost:8080/contacts
      - store_artifacts:
          path: /tmp/test-results
          destination: raw-test-output

      - store_test_results:
          path: /tmp/test-results      Example MYSQL project.   The following example sets up MYSQL as a secondary container alongside a PHP container.    version: 2.1
orbs:
  browser-tools: circleci/browser-tools@1.2.3
jobs:
  build:
    docker:
      - image: cimg/php:8.1-browsers # The primary container where steps are run
      - image: cimg/mysql:8.0
        environment:
          MYSQL_ROOT_PASSWORD: rootpw
          MYSQL_DATABASE: test_db
          MYSQL_USER: user
          MYSQL_PASSWORD: passw0rd

    steps:
      - checkout
      - run:
      # Our primary container isn't MYSQL so run a sleep command until it's ready.
          name: Waiting for MySQL to be ready
          command: |
            for i in `seq 1 10`;
            do
              nc -z 127.0.0.1 3306 && echo Success && exit 0
              echo -n .
              sleep 1
            done
            echo Failed waiting for MySQL && exit 1
      - run:
          name: Install MySQL CLI; Import dummy data; run an example query
          command: |
            sudo apt-get install default-mysql-client
            mysql -h 127.0.0.1 -u user -ppassw0rd test_db < sql-data/dummy.sql
            mysql -h 127.0.0.1 -u user -ppassw0rd --execute="SELECT * FROM test_db.Persons"
workflows:
  build-deploy:
    jobs:
      - build    While it is possible to make MySQL as your primary and only container, this example does not. As a more practical use case, the example uses a PHP Docker image as its primary container, and will wait until MySQL is up and running before performing any run commands involving the DB.   Once the DB is up, we install the mysql client into the primary container so that we can run a command to connect and import the dummy data, presumably found at, sql-data/dummy.sql at the root of your project. In this case, that dummy data contains an example set of SQL commands:    DROP TABLE IF EXISTS `Persons`;

CREATE TABLE Persons (
    PersonID int,
    LastName varchar(255),
    FirstName varchar(255),
    Address varchar(255),
    City varchar(255)
);

INSERT INTO Persons
VALUES (
	1,
	"Foo",
	"Baz",
	"123 Bar Street",
	"FooBazBar City"
);      See also   Refer to the  Configuring Databases document for a walkthrough of conceptual information about using service images and database testing steps.   Suggest an edit to this pageMake a contribution Learn how to contributeStill need help? Ask the CircleCI community Join the research community Visit our Support site DocsTerms of UsePrivacy PolicyCookie PolicySecurity© 2025 Circle Internet Services, Inc., All Rights Reserved.\n\nUsing Docker? Authenticating Docker pulls from image registries is recommended when using the Docker execution environment. Authenticated pulls allow access to private Docker images, and may also grant higher rate limits, depending on your registry provider. For further information see  Using Docker authenticated pulls.  version: 2.1
jobs:
  build:
    working_directory: ~/circleci-demo-ruby-rails

    # Primary container image where all commands run

    docker:
      - image: cimg/ruby:2.6-node
        environment:
          RAILS_ENV: test
          PGHOST: 127.0.0.1
          PGUSER: root

    # Service container image available at `host: localhost`

      - image: cimg/postgres:14.0
        environment:
          POSTGRES_USER: testuser
          POSTGRES_DB: circle-test_test

    steps:
      - checkout

      # Restore bundle cache
      - restore_cache:
          keys:
            - rails-demo-{{ checksum "Gemfile.lock" }}
            - rails-demo-

      # Bundle install dependencies
      - run:
          name: Install dependencies
          command: bundle check --path=vendor/bundle || bundle install --path=vendor/bundle --jobs 4 --retry 3

      - run: sudo apt install -y postgresql-client || true

      # Store bundle cache
      - save_cache:
          key: rails-demo-{{ checksum "Gemfile.lock" }}
          paths:
            - vendor/bundle

      - run:
          name: Database Setup
          command: |
            bundle exec rake db:create
            bundle exec rake db:structure:load

      - run:
          name: Parallel RSpec
          command: bin/rails test

      # Save artifacts
      - store_test_results:
          path: /tmp/test-results  An alternative is to build your own image by extending the current image, installing the needed packages, committing, and pushing it to Docker Hub or the registry of your choosing.  version: 2.1
jobs:
  build:
    working_directory: ~/appName
    docker:
      - image: cimg/ruby:2.6
        environment:
          PG_HOST: localhost
          PG_USER: ubuntu
          RAILS_ENV: test
          RACK_ENV: test
      # The following example uses the official postgres 9.6 image, you may also use cimg/postgres:9.6
      # which includes a few enhancements and modifications. It is possible to use either image.
      - image: cimg/postgres:14.0
        environment:
          POSTGRES_USER: ubuntu
          POSTGRES_DB: db_name
    steps:
      - checkout
      - run:
          name: Install Ruby Dependencies
          command: bundle install
      - run:
          name: Set up DB
          command: |
            bundle exec rake db:create db:schema:load --trace
            bundle exec rake db:migrate
        environment:
          DATABASE_URL: "postgres://ubuntu@localhost:5432/db_name"  version: 2.1
jobs:
  build:
    docker:
      # CircleCI Go images available at: https://circleci.com/developer/images/image/cimg/go
      - image: cimg/go:1.12
      # CircleCI PostgreSQL images available at: https://circleci.com/developer/images/image/cimg/postgres
      - image: cimg/postgres:14.0
        environment:
          POSTGRES_USER: circleci-demo-go
          POSTGRES_DB: circle_test

    environment:
      TEST_RESULTS: /tmp/test-results

    steps:
      - checkout
      - run: mkdir -p $TEST_RESULTS

      - restore_cache:
          keys:
            - go-mod-v1-{{ checksum "go.sum" }}

      - run:
          name: Get dependencies
          command: |
            go get -v

      - run:
          name: Get go-junit-report for setting up test timings on CircleCI
          command: |
            go get github.com/jstemmer/go-junit-report
            # Remove go-junit-report from go.mod
            go mod tidy

      #  Wait for Postgres to be ready before proceeding
      - run:
          name: Waiting for Postgres to be ready
          command: dockerize -wait tcp://localhost:5432 -timeout 1m

      - run:
          name: Run unit tests
          environment: # environment variables for the database url and path to migration files
            CONTACTS_DB_URL: "postgres://circleci-demo-go@localhost:5432/circle_test?sslmode=disable"
            CONTACTS_DB_MIGRATIONS: /home/circleci/project/db/migrations
          command: |
            trap "go-junit-report <${TEST_RESULTS}/go-test.out > ${TEST_RESULTS}/go-test-report.xml" EXIT
            make test | tee ${TEST_RESULTS}/go-test.out
      - run: make

      - save_cache:
          key: go-mod-v1-{{ checksum "go.sum" }}
          paths:
            - "/go/pkg/mod"

      - run:
          name: Start service
          environment:
            CONTACTS_DB_URL: "postgres://circleci-demo-go@localhost:5432/circle_test?sslmode=disable"
            CONTACTS_DB_MIGRATIONS: /home/circleci/project/db/migrations
          command: ./workdir/contacts
          background: true

      - run:
          name: Validate service is working
          command: |
            sleep 5
            curl --retry 10 --retry-delay 1 -X POST --header "Content-Type: application/json" -d '{"email":"test@example.com","name":"Test User"}' http://localhost:8080/contacts
      - store_artifacts:
          path: /tmp/test-results
          destination: raw-test-output

      - store_test_results:
          path: /tmp/test-results  version: 2.1
orbs:
  browser-tools: circleci/browser-tools@1.2.3
jobs:
  build:
    docker:
      - image: cimg/php:8.1-browsers # The primary container where steps are run
      - image: cimg/mysql:8.0
        environment:
          MYSQL_ROOT_PASSWORD: rootpw
          MYSQL_DATABASE: test_db
          MYSQL_USER: user
          MYSQL_PASSWORD: passw0rd

    steps:
      - checkout
      - run:
      # Our primary container isn't MYSQL so run a sleep command until it's ready.
          name: Waiting for MySQL to be ready
          command: |
            for i in `seq 1 10`;
            do
              nc -z 127.0.0.1 3306 && echo Success && exit 0
              echo -n .
              sleep 1
            done
            echo Failed waiting for MySQL && exit 1
      - run:
          name: Install MySQL CLI; Import dummy data; run an example query
          command: |
            sudo apt-get install default-mysql-client
            mysql -h 127.0.0.1 -u user -ppassw0rd test_db < sql-data/dummy.sql
            mysql -h 127.0.0.1 -u user -ppassw0rd --execute="SELECT * FROM test_db.Persons"
workflows:
  build-deploy:
    jobs:
      - build  DROP TABLE IF EXISTS `Persons`;

CREATE TABLE Persons (
    PersonID int,
    LastName varchar(255),
    FirstName varchar(255),
    Address varchar(255),
    City varchar(255)
);

INSERT INTO Persons
VALUES (
	1,
	"Foo",
	"Baz",
	"123 Bar Street",
	"FooBazBar City"
);\n\n\n\nConfiguration reference1 week agoCloudServer v4+Helpful Resources6 config optimization tipsIntro to dynamic configUsing dynamic configValidate your config using local CLIHow to trigger a single jobOn This Pageversionsetuporbscommandsparametersexecutorsjobs<job_name>typeenvironmentparallelismparametersExecutor docker / machine / macosdockerDocker registry authenticationAWS authenticationUse OIDCUse environment variablesmachineAvailable Linux machine imagesAvailable Linux machine images on serverAvailable Linux GPU machine imagesAvailable Android machine imagesAvailable Windows machine imagesAvailable Windows machine images on serverAvailable Windows GPU machine imagemacosbranches - DEPRECATEDresource_classSelf-hosted runnerDocker execution environmentx86ArmLinuxVM execution environmentmacOS execution environmentmacOS execution environment on serverWindows execution environmentGPU execution environment (Linux)GPU execution-environment (Windows)Arm VM execution-environmentstepsrunDefault shell options-e-o pipefailBackground commandsShorthand syntaxThe when attributeEnding a job from within a stepThe when stepcheckoutsetup_remote_dockersave_cacherestore_cachedeploy - DEPRECATEDstore_artifactsstore_test_resultspersist_to_workspaceattach_workspaceadd_ssh_keysUsing pipeline valuescircleci_ip_rangesworkflowsversion<workflow_name>triggersschedulecronfiltersbranchesUsing when in workflowsjobs<job_name>serial-grouprequiresnamecontexttypefiltersExpression-based job filtersbranchestagsmatrixExcluding sets of parameters from a matrixDependencies and matrix jobspre-steps and post-stepsLogic statementsLogic statement examplesExample full configuration   This document is a reference for the CircleCI 2.x configuration keys that are used in the .circleci/config.yml file.   You can see a complete config.yml in our  full example.      version  KeyRequiredTypeDescriptionversionYString2, 2.0, or 2.1 See the  Reusable configuration page for an overview of 2.1 keys available to simplify your .circleci/config.yml file, reuse, and parameterized jobs.  The version field is intended to be used in order to issue warnings for deprecation or breaking changes.      setup  KeyRequiredTypeDescriptionsetupNBooleanDesignates the config.yaml for use of CircleCI’s  dynamic configuration feature.  The setup field enables you to conditionally trigger configurations from outside the primary .circleci parent directory, update pipeline parameters, or generate customized configurations.      orbs      The orbs key is supported in version: 2.1 configuration       KeyRequiredTypeDescriptionorbsNMapA map of user-selected names to either: orb references (strings) or orb definitions (maps). Orb definitions must be the orb-relevant subset of 2.1 config. See the  Creating Orbs documentation for details.executorsNMapA map of strings to executor definitions. See the  executors section below.commandsNMapA map of command names to command definitions. See the  commands section below.  The following example uses the node orb that exists in the certified circleci namespace. Refer to the Node orb page in the  Orb Registry for more examples and information.    version: 2.1

orbs:
  node: circleci/node@x.y

jobs:
  install-node-example:
    docker:
      - image: cimg/base:stable
    steps:
      - checkout
      - node/install:
          install-yarn: true
          node-version: '16.13'
      - run: node --version
workflows:
  test_my_app:
    jobs:
      - install-node-example    Documentation is available for orbs in the following sections:      Using Orbs    Authoring Orbs.     Public orbs are listed in the  Orb Registry.      commands      The commands key is supported in version: 2.1 configuration        A command defines a sequence of steps as a map to be executed in a job, enabling you to reuse a single command definition across multiple jobs. For more information see the  Reusable Config Reference Guide.  KeyRequiredTypeDescriptionstepsYSequenceA sequence of steps run inside the calling job of the command.parametersNMapA map of parameter keys. See the  Parameter Syntax section of the  Reusing Config document for details.descriptionNStringA string that describes the purpose of the command.  Example:    commands:
  sayhello:
    description: "A very simple command for demonstration purposes"
    parameters:
      to:
        type: string
        default: "Hello World"
    steps:
      - run: echo << parameters.to >>       parameters      The pipeline parameters key is supported in version: 2.1 configuration        Pipeline parameters declared for use in the configuration. See  Pipeline Values and Parameters for usage details.  KeyRequiredTypeDescriptionparametersNMapA map of parameter keys. Supports string, boolean, integer and enum types. See  Parameter Syntax for details.     executors      The executors key is supported in version: 2.1 configuration        Executors define the execution environment in which the steps of a job will be run, allowing you to reuse a single executor definition across multiple jobs.  KeyRequiredTypeDescriptiondockerY (1)ListOptions for  Docker executorresource_classNStringAmount of CPU and RAM allocated to each container in a job.machineY (1)MapOptions for  machine executormacosY (1)MapOptions for  macOS executorwindowsY (1)Map Windows executor currently working with orbs. Check out  the orb.shellNStringShell to use for execution command in all steps. Can be overridden by shell in each step (default: See  Default Shell Options)working_directoryNStringIn which directory to run the steps. Will be interpreted as an absolute path.environmentNMapA map of environment variable names and values.  (1) One executor type should be specified per job. If more than one is set you will receive an error.   Example:    version: 2.1
executors:
  my-executor:
    docker:
      - image: cimg/ruby:3.0.3-browsers

jobs:
  my-job:
    executor: my-executor
    steps:
      - run: echo "Hello executor!"    See the  Using Parameters in Executors section of the  Reusing config page for examples of parameterized executors.      jobs   A Workflow is comprised of one or more uniquely named jobs. Jobs are specified in the jobs map, see  Sample config.yml for two examples of a job map. The name of the job is the key in the map, and the value is a map describing the job.   Jobs have a maximum runtime based on pricing plan, as follows:     1 hour (Free)   3 hours (Performance)   5 hours (Scale)     If your jobs are timing out, consider the following:     A larger  resource_class.   Using  parallelism.   Run some of your jobs concurrently using  workflows.   You can upgrade your pricing plan.      <job_name>  Each job consists of the job’s name as a key and a map as a value. A name should be case insensitive unique within a current jobs list. The value map has the following attributes:  KeyRequiredTypeDescriptiontypeNStringJob type, can be build, release, no-op, or approval. If not specified, defaults to build.dockerY (1)ListOptions for the  Docker executormachineY (1)MapOptions for the  machine executormacosY (1)MapOptions for the  macOS executorshellNStringShell to use for execution command in all steps. Can be overridden by shell in each step (default: See  Default Shell Options)parametersNMap Parameters for making a job explicitly configurable in a workflow.stepsYListA list of  steps to be performedworking_directoryNStringIn which directory to run the steps. Will be interpreted as an absolute path. Default: ~/project (where project is a literal string, not the name of your specific project). Processes run during the job can use the $CIRCLE_WORKING_DIRECTORY environment variable to refer to this directory. Note: Paths written in your YAML configuration file will not be expanded; if your store_test_results.path is $CIRCLE_WORKING_DIRECTORY/tests, then CircleCI will attempt to store the test subdirectory of the directory literally named $CIRCLE_WORKING_DIRECTORY, dollar sign $ and all. working_directory will be created automatically if it doesn’t exist.parallelismNIntegerNumber of parallel instances of this job to run (default: 1)environmentNMapA map of environment variable names and values.branchesNMapThis key is deprecated. Use  workflows filtering to control which jobs run for which branches.resource_classNStringAmount of CPU and RAM allocated to each container in a job.  (1) One executor type should be specified per job. If more than one is set you will receive an error.    type  Configure a job type. Options are release, approval, no-op, build (default).   If a type is not specified, the job defaults to a build type.   Example of a job with a build type. build is the default type and does not need to be configured:    jobs:
  my-job:
    docker:
      - image: cimg/base:2024.12
    resource_class: xlarge
    steps:
      ... // other config    Jobs with the release type are used to  connect your pipeline configuration to a deployment in the CircleCI deploys UI. For full details, see the  Deploys overview page.   Example of a job with a release type:    jobs:
  release-my-service:
    type: release
    plan_name: <my-service-release>    The no-op type is used to configure a job that performs no actions and consumes no credits. no-op is commonly used to organise the order of operations within a workflow and make it easier to maintain. Only the type is required for a no-op type job, no further job configuration is required. For some examples of using no-op jobs, see the  Orchestration cookbook   Example of a job with a no-op type:    jobs:
  my-no-op-job:
    type: no-op    The approval type is used to configure a manual approval step. No job configuration is required or allowed for an approval type job. The approval type is most commonly configured within a workflow rather than under the top-level jobs key. Only approval type jobs can have their type configured under workflows. See  type under workflows section for full details.   Example of a job with an approval type, configured under workflows:    workflows:
  my-workflow:
    jobs:
      - build
      - test:
          requires:
            - build
      - hold:
          type: approval
          requires:
            - test
      - deploy:
          requires:
            - hold      environment  A map of environment variable names and values. For more information on defining and using environment variables, and the order of precedence governing the various ways they can be set, see the  Environment variables page.     parallelism  This feature is used to optimize test steps. If parallelism is set to N > 1, then N independent executors will be set up and each will run the steps of that job in parallel.   You can use the CircleCI CLI to split your test suite across parallel containers so the job completes in a shorter time.     Read more about splitting tests across parallel execution environments on the  Parallelism and test splitting page.   Refer to the  Use the CircleCI CLI to split tests how-to guide.   Follow the  Test splitting tutorial.     Example:    jobs:
  build:
    docker:
      - image: cimg/base:2024.12
    environment:
      FOO: bar
    parallelism: 3
    resource_class: large
    working_directory: ~/my-app
    steps:
      - run: go list ./... | circleci tests run --command "xargs gotestsum --junitfile junit.xml --format testname --" --split-by=timings --timings-type=name      parameters  Job-level parameters can be used when  calling a job in a workflow.   Reserved parameter-names:     name   requires   context   type   filters   matrix     See  Parameter Syntax for definition details.     Executor docker / machine / macos  CircleCI offers several execution environments in which to run your jobs. To specify an execution environment choose an executor, then specify and image and a resource class. An executor defines the underlying technology, environment, and operating system in which to run a job.   Set up your jobs to run using the docker (Linux), machine (LinuxVM, Windows, GPU, Arm), or macos executor, then specify an image with the tools and packages you need, and a resource class.   Learn more about execution environments and executors in the  Introduction to Execution Environments.     docker  Configured by docker key which takes a list of maps:  KeyRequiredTypeDescriptionimageYStringThe name of a custom Docker image to use. The first image listed under a job defines the job’s own primary container image where all steps will run.nameNStringname defines the hostname for the container (the default is localhost), which is used for reaching secondary (service) containers. By default, all services are exposed directly on localhost. This field is useful if you would rather have a different hostname instead of localhost, for example, if you are starting multiple versions of the same service.entrypointNString or ListThe command used as executable when launching the container. entrypoint overrides the image’s  ENTRYPOINT.commandNString or ListThe command used as PID 1 (or arguments for entrypoint) when launching the container. command overrides the image’s COMMAND. It will be used as arguments to the image ENTRYPOINT if it has one, or as the executable if the image has no ENTRYPOINT.userNStringWhich user to run commands as within the Docker containerenvironmentNMapA map of environment variable names and values. The environment settings apply to the entrypoint/command run by the Docker container, not the job steps.authNMapAuthentication for registries using standard docker login credentialsaws_authNMapAuthentication for AWS Elastic Container Registry (ECR)  For a  primary container, (the first container in the list) if neither command nor entrypoint is specified in the configuration, then any ENTRYPOINT and COMMAND in the image are ignored. The primary container is typically only used for running the steps and not for its ENTRYPOINT, and an ENTRYPOINT may consume significant resources or exit prematurely.   A  custom image may disable this behavior and force the ENTRYPOINT to run.   You can specify image versions using tags or digest. You can use any public images from any public Docker registry (defaults to Docker Hub). Learn more about specifying images on the  Using the Docker Execution Environment page.    Docker registry authentication  Some registries, Docker Hub, for example, may rate limit anonymous Docker pulls. We recommend that you authenticate to pull private and public images. The username and password can be specified in the auth field. See  Using Docker Authenticated Pulls for details.   Example:    jobs:
  build:
    docker:
      - image: buildpack-deps:trusty # primary container
        auth:
          username: mydockerhub-user
          password: $DOCKERHUB_PASSWORD  # context / project UI env-var reference
        environment:
          ENV: CI

      - image: mongo:2.6.8
        auth:
          username: mydockerhub-user
          password: $DOCKERHUB_PASSWORD  # context / project UI env-var reference
        command: [--smallfiles]

      - image: postgres:14.2
        auth:
          username: mydockerhub-user
          password: $DOCKERHUB_PASSWORD  # context / project UI env-var reference
        environment:
          POSTGRES_USER: user

      - image: redis@sha256:54057dd7e125ca41afe526a877e8bd35ec2cdd33b9217e022ed37bdcf7d09673
        auth:
          username: mydockerhub-user
          password: $DOCKERHUB_PASSWORD  # context / project UI env-var reference

      - image: acme-private/private-image:321
        auth:
          username: mydockerhub-user
          password: $DOCKERHUB_PASSWORD  # context / project UI env-var reference      AWS authentication  Using an image hosted on  AWS ECR requires authentication using AWS credentials.   Use OIDC  Authenticate using OpenID Connect (OIDC) using the oidc_role_arn field, as follows:    jobs:
  job_name:
    docker:
      - image: <your-image-arn>
        aws_auth:
          oidc_role_arn: <your-iam-role-arn>    For steps to get set up with OIDC to pull images from AWS ECR, see the  Pull and image from AWS ECR with OIDC page.    Use environment variables  By default, CircleCI uses the AWS credentials you provide by setting the AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY project environment variables. It is also possible to set the credentials by using the aws_auth field as in the following example:    jobs:
  build:
    docker:
      - image: account-id.dkr.ecr.us-east-1.amazonaws.com/org/repo:0.1
        aws_auth:
          aws_access_key_id: AKIAQWERVA  # can specify string literal values
          aws_secret_access_key: $ECR_AWS_SECRET_ACCESS_KEY  # or project UI envar reference        machine     CircleCI cloud The use of machine: true is deprecated. You must specify an image to use.        The machine executor is configured using the machine key, which takes a map:  KeyRequiredTypeDescriptionimageYStringThe virtual machine image to use. View  available images. Note: This key is not supported for Linux VMs on installations of CircleCI server. For information about customizing machine executor images on CircleCI installed on your servers, see our  Machine provisioner documentation.docker_layer_cachingNBooleanSet this to true to enable  Docker layer caching.  Example:  CloudServer    jobs:
  build: # name of your job
    machine: # executor type
      image: ubuntu-2004:current # recommended linux image

    steps:
      # Commands run in a Linux virtual machine environment        jobs:
  build: # name of your job
    machine: true # executor type
    steps:
      # Commands run in a Linux virtual machine environment        Available Linux machine images  Specifying an image in your configuration file is strongly recommended. CircleCI supports multiple Linux machine images that can be specified in the image field. For a full list of supported image tags, refer to the following pages in the Developer Hub:      Ubuntu-2004    Ubuntu-2204     More information on the software available in each image can be found in our  Discuss forum.   The machine executor supports  Docker Layer Caching, which is useful when you are building Docker images during your job or Workflow.     Available Linux machine images on server  If you are using CircleCI server, contact your system administrator for details of available Linux machine images.     Available Linux GPU machine images  When using the Linux  GPU executor, the available images are:     linux-cuda-11:default v11.4, v11.6, v11.8 (default), Docker v20.10.24   linux-cuda-12:default v12.0, v12.1 (default), Docker v20.10.24       Available Android machine images  CircleCI supports running jobs on Android for testing and deploying Android applications.   To use the  Android image directly with the machine executor, add the following to your job:    version: 2.1

jobs:
  build:
    machine:
      image: android:2024.11.1    The Android image can also be accessed using the  Android orb.   For examples, refer to the  Using Android Images with the Machine Executor page.     Available Windows machine images  Specifying an image in your configuration file is strongly recommended. CircleCI supports multiple Windows machine images that can be specified in the image field.   For a full list of supported images, refer to one of the following:      windows-server-2022-gui image    windows-server-2019 image     More information on what software is available in each image can be found in our  Discuss forum.   Alternatively, use the  Windows orb to manage your Windows execution environment. For examples, see the  Using the Windows Execution Environment page.     Available Windows machine images on server  If you are using CircleCI server, contact your system administrator for details of available Windows machine images.     Available Windows GPU machine image  When using the Windows  GPU executor, the available image is:      windows-server-2019-cuda     Example    version: 2.1

jobs:
  build:
    machine:
      image: windows-server-2019-cuda:current       macos  CircleCI supports running jobs on  macOS, to allow you to build, test, and deploy apps for macOS,  iOS,  tvOS and  watchOS. To run a job on a macOS virtual machine, add the macos key to the top-level configuration for your job and specify the version of Xcode to use.  KeyRequiredTypeDescriptionxcodeYStringThe version of Xcode that is installed on the virtual machine, see the  Supported Xcode Versions section of the Testing iOS document for the complete list.  Example: Use a macOS virtual machine with Xcode version 14.2.0:    jobs:
  build:
    macos:
      xcode: "14.2.0"      branches - DEPRECATED  This key is deprecated. Use  workflows filtering to control which jobs run for which branches.     resource_class  The resource_class feature allows you to configure CPU and RAM resources for each job. Resource classes are available for each execution environment, as described in the tables below.   We implement soft concurrency limits for each resource class to ensure our system remains stable for all customers. If you are on a Performance or Custom Plan and experience queuing for certain resource classes, it is possible you are hitting these limits.  Contact CircleCI support to request a raise on these limits for your account.   If you do not specify a resource class, CircleCI will use a default value that is subject to change. It is best practice to specify a resource class as opposed to relying on a default.      Java, Erlang and any other languages that introspect the /proc directory for information about CPU count may require additional configuration to prevent them from slowing down when using the CircleCI resource class feature. Programs with this issue may request 32 CPU cores and run slower than they would when requesting one core. Users of languages with this issue should pin their CPU count to their guaranteed CPU resources.           If you want to confirm how much memory you have been allocated, you can check the cgroup memory hierarchy limit with grep hierarchical_memory_limit /sys/fs/cgroup/memory/memory.stat.         Self-hosted runner  Use the resource_class key to configure a  self-hosted runner instance.   For example:    jobs:
  job_name:
    machine: true
    resource_class: <my-namespace>/<my-runner>      Docker execution environment  Example:    jobs:
  build:
    docker:
      - image: cimg/base:2024.12
    resource_class: xlarge
    steps:
      ... // other config    x86     For credit and access information, see the  Resource classes page. Resource class access is dependent on your  Plan.       ClassvCPUsRAMCloudServersmall12GBmedium24GBmedium+36GBlarge48GBxlarge816GB2xlarge1632GB2xlarge+2040GB   Arm  Arm on Docker For pricing information, and a list of CircleCI Docker convenience images that support Arm resource classes, see the  Resource classes page.       Arm on Docker For credit and access information see the  Resource classes page. Resource class access is dependent on your  Plan   To find out which CircleCI Docker convenience images support Arm resource classes, you can refer to  Docker hub:     Select the image (for example, cimg/python).   Select the tags tab.   View what is supported under OS/ARCH for the latest tags. For example, cimg/python has linux/amd64 and linux/arm64, which means Arm is supported.          ClassvCPUsRAMCloudServerarm.medium28 GBarm.large416 GBarm.xlarge832 GBarm.2xlarge1664 GB     LinuxVM execution environment ClassvCPUsRAMDisk SizeCloudServermedium27.5 GB150GBlarge415 GB150GBxlarge832 GB150GB2xlarge1664 GB150GB2xlarge+3264 GB150GB  Example:  CloudServer    jobs:
  build:
    machine:
      image: ubuntu-2004:2024.01.2 # recommended linux image
    resource_class: large
    steps:
      ... // other config        jobs:
  build:
    machine: true
    resource_class: large
    steps:
      ... // other config         macOS execution environment ClassvCPUsRAMCloudServermacos.m1.medium.gen14 @ 3.2 GHz6GBmacos.m1.large.gen18 @ 3.2 GHz12GBm2pro.medium4 @ 3.49 GHz8GBm2pro.large8 @ 3.49 GHz16GB      We have deprecated support for all Intel-based macOS resources.   The macos.x86.medium.gen2 resource class was deprecated on June 28, 2024.   See our  announcement for more details.         Example    jobs:
  build:
    macos:
      xcode: "15.4.0"
    resource_class: m2pro.medium
    steps:
      ... // other config      macOS execution environment on server  If you are working on CircleCI server v3.1 and up, you can access the macOS execution environment using  self-hosted runner.     Windows execution environment ClassvCPUsRAMDisk SizeCloudServerwindows.medium (default)415GB200 GBwindows.large830GB200 GBwindows.xlarge1660GB200 GBwindows.2xlarge32128GB200 GB     Using server? Check with your systems administrator whether you have access to the Windows execution environment.        Example:  CloudServer    version: 2.1

jobs:
  build: # name of your job
    resource_class: 'windows.medium'
    machine:
      image: 'windows-server-2022-gui:current'
      shell: 'powershell.exe -ExecutionPolicy Bypass'
    steps:
      # Commands are run in a Windows virtual machine environment
      - checkout
      - run: Write-Host 'Hello, Windows'        version: 2.1

jobs:
  build: # name of your job
    machine:
      image: windows-default
    steps:
      # Commands are run in a Windows virtual machine environment
      - checkout
      - run: Write-Host 'Hello, Windows'         GPU execution environment (Linux) ClassvCPUsRAMGPUsGPU modelGPU Memory (GiB)Disk Size (GiB)CloudServergpu.nvidia.small4161NVIDIA Tesla P416150gpu.nvidia.small.gen24161NVIDIA A10G24150gpu.nvidia.small.multi4152NVIDIA Tesla T416150gpu.nvidia.medium.multi8304NVIDIA Tesla T416150gpu.nvidia.medium8301NVIDIA Tesla T416150gpu.nvidia.large8301NVIDIA Tesla V10016150  Example:    version: 2.1

jobs:
  build:
    machine:
      image: linux-cuda-12:default
    resource_class: gpu.nvidia.medium
    steps:
      - run: nvidia-smi
      - run: docker run --gpus all nvidia/cuda:9.0-base nvidia-smi    See the  Available Linux GPU images section for the full list of available images.     GPU execution-environment (Windows) ClassvCPUsRAMGPUsGPU modelGPU Memory (GiB)Disk Size (GiB)CloudServerwindows.gpu.nvidia.medium16601NVIDIA Tesla T416200  Example:    version: 2.1
orbs:
  win: circleci/windows@5.0.0

jobs:
  build:
    executor: win/server-2019-cuda
    steps:
      - checkout
      - run: '&"C:\Program Files\NVIDIA Corporation\NVSMI\nvidia-smi.exe"'    (2) This resource requires review by our support team.  Open a support ticket if you would like to request access.     Arm VM execution-environment ClassvCPUsRAMDisk SizeCloudServerarm.medium (default)28GB100 GBarm.large416GB100 GBarm.xlarge832GB100 GBarm.2xlarge1664GB100 GB     Using server? Check with your systems administrator whether you have access to the Arm execution environment.        Example:  CloudServer    jobs:
  my-job:
    machine:
      image: ubuntu-2004:2024.01.2
    resource_class: arm.medium
    steps:
      - run: uname -a
      - run: echo "Hello, Arm!"        jobs:
  my-job:
    machine:
      image: arm-default
    resource_class: arm.medium
    steps:
      - run: uname -a
      - run: echo "Hello, Arm!"          steps  The steps setting in a job should be a list of single key/value pairs, the key of which indicates the step type. The value may be either a configuration map or a string (depending on what that type of step requires). For example, using a map:    jobs:
  build:
    working_directory: ~/canary-python
    environment:
      FOO: bar
    steps:
      - run:
          name: Running tests
          command: make test    Here run is a step type. The name attribute is used by the UI for display purposes. The command attribute is specific for run step and defines command to execute.   Some steps may implement a shorthand semantic. For example, run may be also be called like this:    jobs:
  build:
    steps:
      - run: make test    In its short form, the run step allows us to directly specify which command to execute as a string value. In this case step itself provides default suitable values for other attributes (name here will have the same value as command, for example).   Another shorthand, which is possible for some steps, is to use the step name as a string instead of a key/value pair:    jobs:
  build:
    steps:
      - checkout    In this case, the checkout step will check out project source code into the job’s  working_directory.   In general all steps can be described as:  KeyRequiredTypeDescription<step_type>YMap or StringA configuration map for the step or some string whose semantics are defined by the step.  Each built-in step is described in detail below.    run  The run step is used to invoke command-line programs. The run step takes either a map of configuration values, or, when called in its short-form, a string that will be used as both the command and name. Run commands are executed using non-login shells by default, so you must explicitly source any dotfiles as part of the command.      the run step replaces the deprecated deploy step. If your job has a parallelism of 1, the deprecated deploy step can be swapped out directly for the run step. If your job has parallelism > 1, see  Migrate from deploy to run.       KeyRequiredTypeDescriptioncommandYStringCommand to run via the shellnameNStringTitle of the step to be shown in the CircleCI UI (default: full command)shellNStringShell to use for execution command (default: See  Default Shell Options)environmentNMapAdditional environmental variables, locally scoped to commandbackgroundNBooleanWhether or not this step should run in the background (default: false)working_directoryNStringIn which directory to run this step. Will be interpreted relative to the  working_directory of the job). (default: .)no_output_timeoutNStringElapsed time the command can run without output. The string is a decimal with unit suffix, such as "20m", "1.25h", "5s". The default is 10 minutes and the maximum is governed by the  maximum time a job is allowed to run.whenNString Specify when to enable or disable the step. Takes the following values: always, on_success, on_fail (default: on_success)  Each run declaration represents a new shell. It is possible to specify a multi-line command, each line of which will be run in the same shell:    - run:
    command: |
      echo Running test
      mkdir -p /tmp/test-results
      make test    You can also configure commands to run  in the background if you do not want to wait for the step to complete before moving on to subsequent run steps.    Default shell options  For jobs that run on Linux, the default value of the shell option is /bin/bash -eo pipefail if /bin/bash is present in the build container. Otherwise it is /bin/sh -eo pipefail. The default shell is not a login shell (--login or -l are not specified). Hence, the shell will not source your ~/.bash_profile, ~/.bash_login, ~/.profile files.   For jobs that run on macOS, the default shell is /bin/bash --login -eo pipefail. The shell is a non-interactive login shell. The shell will execute /etc/profile/ followed by ~/.bash_profile before every step.   For more information about which files are executed when Bash is invocated,  see the INVOCATION section of the bash manpage.   Descriptions of the -eo pipefail options are provided below.    -e  Exit immediately if any of the following exits with a non-zero status:     A pipeline (which may consist of a single simple command).   A subshell command enclosed in parentheses.   One of the commands executed as part of a command list enclosed by braces.     In the previous example, mkdir failed to create a directory and returned a non-zero status, then command execution would be terminated, and the whole step would be marked as failed. If you desire the opposite behaviour, you need to add set +e in your command or override the default shell in your configuration map of run. For example:    - run:
    command: |
      echo Running test
      set +e
      mkdir -p /tmp/test-results
      make test

- run:
    shell: /bin/sh
    command: |
      echo Running test
      mkdir -p /tmp/test-results
      make test     -o pipefail  If pipefail is enabled, the pipeline’s return status is the value of the last (rightmost) command to exit with a non-zero status, or zero if all commands exit successfully. The shell waits for all commands in the pipeline to terminate before returning a value.   For example:    - run: make test | tee test-output.log    If make test fails, the -o pipefail option will cause the whole step to fail. Without -o pipefail, the step will always run successfully because the result of the whole pipeline is determined by the last command (tee test-output.log), which will always return a zero status.      If make test fails the rest of pipeline will be executed.        If you want to avoid this behaviour, you can specify set +o pipefail in the command or override the whole shell (see example above).   In general, we recommend using the default options (-eo pipefail) because they show errors in intermediate commands and simplify debugging job failures. For convenience, the UI displays the used shell and all active options for each run step.   For more information, see the  Using Shell Scripts document.     Background commands  The background attribute enables you to configure commands to run in the background. Job execution will immediately proceed to the next step rather than waiting for return of a command with the background attribute set to true. The following example shows the configuration for running the X virtual framebuffer in the background which is commonly required to run Selenium tests:    - run:
    name: Running X virtual framebuffer
    command: Xvfb :99 -screen 0 1280x1024x24
    background: true

- run: make test      Shorthand syntax  run has a very convenient shorthand syntax:    - run: make test

# shorthanded command can also have multiple lines
- run: |
    mkdir -p /tmp/test-results
    make test    In this case, command and name become the string value of run, and the rest of the config map for that run have their default values.     The when attribute  By default, CircleCI will execute job steps one at a time, in the order that they are defined in config.yml, until a step fails (returns a non-zero exit code). After a command fails, no further job steps will be executed.   Adding the when attribute to a job step allows you to override this default behaviour, and selectively run or skip steps depending on the status of the job.   The when attribute accepts the following values:    on_success  The step will run only if all of the previous steps have been successful (returned exit code 0). on_success is the default value.  always  The step will run regardless of the exit status of previous steps. always is useful if you have a task that you want to run regardless of whether the previous steps are successful or not. For example, you might have a job step that needs to upload logs or code-coverage data somewhere.  on_fail  The step will run only if one of the preceding steps has failed (returns a non-zero exit code). A common use of on_fail is to store some diagnostic data to help debug test failures, or to run custom notifications about the failure, such as sending emails or triggering alerts.        Some steps, such as store_artifacts and store_test_results will always run, even if a step has failed (returned a non-zero exit code) previously. The when attribute, store_artifacts and store_test_results are not run if the job has been killed by a cancel request or has reached the runtime timeout limit.         - run:
    name: Upload CodeCov.io Data
    command: bash <(curl -s https://codecov.io/bash) -F unittests
    when: always # Uploads code coverage results, pass or fail      Ending a job from within a step  A job can exit without failing by using run: circleci-agent step halt. However, if a step within the job is already failing then the job will continue to fail. This can be useful in situations where jobs need to conditionally execute.   Here is an example where halt is used to avoid running a job on the develop branch:    - run: |
    if [ "$CIRCLE_BRANCH" = "develop" ]; then
        circleci-agent step halt
    fi       The when step     The when and unless steps are supported in version: 2.1 configuration        A conditional step consists of a step with the key when or unless. Under the when key are the subkeys condition and steps. The purpose of the when step is customizing commands and job configuration to run on custom conditions (determined at config-compile time) that are checked before a workflow runs. See the  Conditional Steps section of the reusable configuration reference for more details.  KeyRequiredTypeDescriptionconditionYLogic A logic statementstepsYSequenceA list of steps to execute when the condition is true  Example:    version: 2.1

jobs: # conditional steps may also be defined in `commands:`
  job_with_optional_custom_checkout:
    parameters:
      custom_checkout:
        type: string
        default: ""
    machine:
      image: ubuntu-2004:2024.11.1
    steps:
      - when:
          condition: <<parameters.custom_checkout>>
          steps:
            - run: echo "my custom checkout"
      - unless:
          condition: <<parameters.custom_checkout>>
          steps:
            - checkout
workflows:
  build-test-deploy:
    jobs:
      - job_with_optional_custom_checkout:
          custom_checkout: "any non-empty string is truthy"
      - job_with_optional_custom_checkout      checkout      Blobless clones   A "blobless" strategy is being rolled out to help improve the performance of code checkouts from Git source code hosts.   Blobless clones reduce the amount of data fetched from the remote, by asking the remote to filter out objects that are not attached to the current commit.   While this improves performance in most cases, if a downstream step requires those objects to exist for scanning or comparisons, it can cause failures. To work around these potential problems, a fetch directly after a checkout will ensure the required data is available:    - checkout
- run: git fetch          A special step used to check out source code to the configured path (defaults to the working_directory). The reason this is a special step is because it is more of a helper function designed to simplify the process of checking out code. If you require doing git over HTTPS you should not use this step as it configures git to checkout over SSH.  KeyRequiredTypeDescriptionpathNStringCheckout directory. Will be interpreted relative to the  working_directory of the job). (default: .)  If path already exists and is:     A git repository - step will not clone whole repository, instead will fetch origin   NOT a git repository - step will fail.     In the case of checkout, the step type is just a string with no additional attributes:    - checkout    The checkout command automatically adds the required authenticity keys for interacting with GitHub and Bitbucket over SSH. These keys are detailed further in the  integration guide. This guide is also helpful if you wish to implement a custom checkout command.   CircleCI does not check out submodules. If your project requires submodules, add run steps with appropriate commands as shown in the following example:    - checkout
- run: git submodule sync
- run: git submodule update --init       The checkout step will configure Git to skip automatic garbage collection. If you are caching your .git directory with  restore_cache and would like to use garbage collection to reduce its size, you may wish to use a  run step with command git gc before doing so.          setup_remote_docker  Allows Docker commands to be run locally. See  Running Docker commands for details.    jobs:
  build:
    docker:
      - image: cimg/base:2024.06
    steps:
      # ... steps for building/testing app ...
      - setup_remote_docker:
          version: default   KeyRequiredTypeDescriptiondocker_layer_cachingNbooleanSet this to true to enable  Docker Layer Caching in the Remote Docker Environment (default: false)versionNStringVersion string of Docker you would like to use (default: 24.0.9). View the list of supported Docker versions  here.        setup_remote_docker is not compatible with the machine executor. See  Docker Layer Caching in Machine Executor for information on how to enable DLC with the machine executor.   The version key is not currently supported on CircleCI server. Contact your system administrator for information about the Docker version installed in your remote Docker environment. If you are on server 4.x, you can find the default AWS AMI  here.             save_cache  Generates and stores a cache of a file or directory of files such as dependencies or source code in our object storage. Later jobs can  restore this cache. Learn more on the  Caching Dependencies page.   Cache retention can be customized on the  CircleCI web app by navigating to Plan  Usage Controls.  KeyRequiredTypeDescriptionpathsYListList of directories which should be added to the cachekeyYStringUnique identifier for this cachenameNStringTitle of the step to be shown in the CircleCI UI (default: "Saving Cache")whenNString Specify when to enable or disable the step. Takes the following values: always, on_success, on_fail (default: on_success)  The cache for a specific key is immutable and cannot be changed once written.      If the cache for the given key already exists it will not be modified, and job execution will proceed to the next step.        When storing a new cache, the key value may contain special, templated, values for your convenience:  TemplateDescription{{ .Branch }}The VCS branch currently being built.{{ .BuildNum }}The CircleCI build number for this build.{{ .Revision }}The VCS revision currently being built.{{ .CheckoutKey }}The SSH key used to checkout the repository.{{ .Environment.variableName }}The environment variable variableName (supports any environment variable  exported by CircleCI or added to a specific  context--not any arbitrary environment variable).{{ checksum "filename" }}A base64 encoded SHA256 hash of the given filename’s contents. This should be a file committed in your repository and may also be referenced as a path that is absolute or relative from the current working directory. Good candidates are dependency manifests, such as package-lock.json, pom.xml or project.clj. It is important that this file does not change between restore_cache and save_cache, otherwise the cache will be saved under a cache key different than the one used at restore_cache time.{{ epoch }}The current time in seconds since the UNIX epoch.{{ arch }}The OS and CPU information. Useful when caching compiled binaries that depend on OS and CPU architecture, for example, darwin amd64 versus linux i386/32-bit.  During step execution, the templates above will be replaced by runtime values and use the resultant string as the key.   Template examples:     myapp-{{ checksum "package-lock.json" }} - cache will be regenerated every time something is changed in package-lock.json file, different branches of this project will generate the same cache key.   myapp-{{ .Branch }}-{{ checksum "package-lock.json" }} - same as the previous one, but each branch will generate separate cache   myapp-{{ epoch }} - every run of a job will generate a separate cache     While choosing suitable templates for your cache key, keep in mind that:     Cache saving is not a free operation. See the billing section on the  FAQ page.   It takes time to upload the cache.     Best practice is to have a key that generates a new cache only if something actually changed and avoid generating a new one every time a job is run.      Given the immutability of caches, it might be helpful to start all your cache keys with a version prefix v1-.... That way you will be able to regenerate all your caches just by incrementing the version in this prefix.        Example:    - save_cache:
    key: v1-myapp-{{ arch }}-{{ checksum "project.clj" }}
    paths:
      - /home/ubuntu/.m2     - save_cache:
    key: v1-{{ checksum "yarn.lock" }}
    paths:
      - node_modules/workspace-a
      - node_modules/workspace-c          Wildcards are not currently supported in save_cache paths. Visit the  Ideas board and vote for this feature if it would be useful for you or your organization.   In some instances, a workaround for this is to save a particular workspace to cache:             restore_cache  Restores a previously saved cache based on a key. Cache needs to have been saved first for this key using the  save_cache step. Learn more in  the caching documentation.  KeyRequiredTypeDescriptionkeyY (1)StringSingle cache key to restorekeysY (1)ListList of cache keys to lookup for a cache to restore. Only first existing key will be restored.nameNStringTitle of the step to be shown in the CircleCI UI (default: "Restoring Cache")  (1) at least one attribute has to be present. If key and keys are both given, key will be checked first, and then keys.   A key is searched against existing keys as a prefix.      When there are multiple matches, the most recent match will be used, even if there is a more precise match.        For example:    steps:
  - save_cache:
      key: v1-myapp-cache
      paths:
        - ~/d1

  - save_cache:
      key: v1-myapp-cache-new
      paths:
        - ~/d2

  - run: rm -f ~/d1 ~/d2

  - restore_cache:
      key: v1-myapp-cache    In this case cache v1-myapp-cache-new will be restored because it’s the most recent match with v1-myapp-cache prefix even if the first key (v1-myapp-cache) has exact match.   For more information on key formatting, see the key section of  save_cache step.   When CircleCI encounters a list of keys, the cache will be restored from the first key matching an existing cache. We recommend you use a more specific key first (for example, cache for exact version of package-lock.json) and more generic keys after (for example, any cache for this project). If no key has a cache that exists, the step will be skipped with a warning.   A path is not required here because the cache will be restored to the location from which it was originally saved.   Example:    - restore_cache:
    keys:
      - v1-myapp-{{ arch }}-{{ checksum "project.clj" }}
      # if cache for exact version of `project.clj` is not present then load any most recent one
      - v1-myapp-

# ... Steps building and testing your application ...

# cache will be saved only once for each version of `project.clj`
- save_cache:
    key: v1-myapp-{{ arch }}-{{ checksum "project.clj" }}
    paths:
      - /foo      deploy - DEPRECATED  See  run for current processes. If you have parallelism > 1 in your job, see the  Migrate from deploy to run guide.     store_artifacts  Step to store artifacts (for example logs, binaries, etc) to be available in the web app or through the API. See the  Uploading Artifacts page for more information.  KeyRequiredTypeDescriptionpathYStringDirectory in the primary container to save as job artifactsdestinationNStringPrefix added to the artifact paths in the artifacts API (default: the directory of the file specified in path)  There can be multiple store_artifacts steps in a job. Using a unique prefix for each step prevents them from overwriting files.   Artifact storage retention can be customized on the  CircleCI web app by navigating to Plan  Usage Controls.   Example:    - run:
    name: Build the Jekyll site
    command: bundle exec jekyll build --source jekyll --destination jekyll/_site/docs/
- store_artifacts:
    path: jekyll/_site/docs/
    destination: circleci-docs      store_test_results  Special step used to upload and store test results for a build. Test results are visible on the CircleCI web application under each build’s Test Summary section. Storing test results is useful for timing analysis of your test suites. For more information on storing test results, see the  Collecting Test Data page.   You can also store test results as build artifacts. For steps, refer to  the store_artifacts step section.  KeyRequiredTypeDescriptionpathYStringPath (absolute, or relative to your working_directory) to directory containing JUnit XML test metadata files, or to a single test file.  Example:   Directory structure:    test-results
├── jest
│   └── results.xml
├── mocha
│   └── results.xml
└── rspec
    └── results.xml    config.yml syntax:    - store_test_results:
    path: test-results      persist_to_workspace  Special step used to persist a temporary file to be used by another job in the workflow. For more information on using workspaces, see the  Using Workspaces to Share Data Between Jobs page.   persist_to_workspace adopts the storage settings from the storage customization controls on the CircleCI web app. If no custom setting is provided, persist_to_workspace defaults to 15 days.   Workspace storage retention can be customized on the  CircleCI web app by navigating to Plan  Usage Controls.  KeyRequiredTypeDescriptionrootYStringEither an absolute path or a path relative to working_directorypathsYListGlob identifying file(s), or a non-glob path to a directory to add to the shared workspace. Interpreted as relative to the workspace root. Must not be the workspace root itself.  The root key is a directory on the container which is taken to be the root directory of the workspace. The path values are all relative to the root.   Example for root Key   For example, the following step syntax persists the specified paths from /tmp/dir into the workspace, relative to the directory /tmp/dir.    - persist_to_workspace:
    root: /tmp/dir
    paths:
      - foo/bar
      - baz    After this step completes, the following directories are added to the workspace:    /tmp/dir/foo/bar
/tmp/dir/baz    Example for paths Key    - persist_to_workspace:
    root: /tmp/workspace
    paths:
      - target/application.jar
      - build/*    The paths list uses Glob from Go, and the pattern matches  filepath.Match.    pattern:
        { term }
term:
        '*' matches any sequence of non-Separator characters
        '?' matches any single non-Separator character
        '[' [ '^' ] { character-range }
        ']' character class (must be non-empty)
        c matches character c (c != '*', '?', '\\', '[')
        '\\' c matches character c
character-range:
        c matches character c (c != '\\', '-', ']')
        '\\' c matches character c
        lo '-' hi matches character c for lo <= c <= hi    The Go documentation states that the pattern may describe hierarchical names such as /usr/*/bin/ed (assuming the Separator is '/').      Everything must be relative to the work space root directory.          attach_workspace  Special step used to attach the workflow’s workspace to the current container. The full contents of the workspace are downloaded and copied into the directory the workspace is being attached at. For more information on using workspaces, see the  Using workspaces page.  KeyRequiredTypeDescriptionatYStringDirectory to attach the workspace to.  Workspace storage retention can be customized on the  CircleCI web app by navigating to Plan  Usage Controls.   Example:    - attach_workspace:
    at: /tmp/workspace       The lifetime of artifacts, workspaces, and caches can be customized on the  CircleCI web app by navigating to Plan  Usage Controls. Here you can control the storage retention periods for these objects. If no storage period is set, the default storage retention period of artifacts is 30 days, while the default storage retention period of workspaces and caches is 15 days.          add_ssh_keys  Special step that adds SSH keys from a project’s settings to a container. Also configures SSH to use these keys. For more information on SSH keys see the  Create additional GitHub SSH keys page.      Using server? only MD5 fingerprints are supported. In CircleCI in Project Settings  SSH keys  Additional SSH keys the MD5 fingerprint will be visible. SHA256 support is planned for an upcoming server release.       KeyRequiredTypeDescriptionfingerprintsNListList of fingerprints corresponding to the keys to be added (default: all keys added)   steps:
  - add_ssh_keys:
      fingerprints:
        - "b7:35:a6:4e:9b:0d:6d:d4:78:1e:9a:97:2a:66:6b:be"
        - "SHA256:NPj4IcXxqQEKGXOghi/QbG2sohoNfvZ30JwCcdSSNM0"       Even though CircleCI uses ssh-agent to sign all added SSH keys, you must use the add_ssh_keys key to actually add keys to a container.          Using pipeline values  Pipeline values are available to all pipeline configurations and can be used without previous declaration. For a list of pipeline values, see the  Pipeline values and parameters page.   Example:    version: 2.1
jobs:
  build:
    docker:
      - image: cimg/node:20.18.1
    environment:
      IMAGETAG: latest
    working_directory: ~/main
    steps:
      - run: echo "This is pipeline ID << pipeline.id >>"       circleci_ip_ranges     A paid account on a  Performance or Scale Plan is required to access IP ranges.        Enables jobs to go through a set of well-defined IP address ranges. See  IP ranges for details.   Example:    version: 2.1

jobs:
  build:
    circleci_ip_ranges: true # opts the job into the IP ranges feature
    docker:
      - image: curlimages/curl
    steps:
      - run: echo “Hello World”
workflows:
  build-workflow:
    jobs:
      - build         workflows   Used for orchestrating all jobs. Each workflow consists of the workflow name as a key and a map as a value. A name should be unique within the current config.yml. The top-level keys for the Workflows configuration are version and jobs. For more information, see the  Using Workflows to Orchestrate Jobs page.    version     The workflows version key is not required for version: 2.1 configuration        The Workflows version field is used to issue warnings for deprecation or breaking changes.  KeyRequiredTypeDescriptionversionY if config version is 2StringShould currently be 2    <workflow_name>  A unique name for your workflow.    triggers  Specifies which triggers will cause this workflow to be executed. Default behavior is to trigger the workflow when pushing to a branch.  KeyRequiredTypeDescriptiontriggersNArrayShould currently be schedule.   workflows:
   nightly:
     triggers:
       - schedule:
           cron: "0 0 * * *"
           filters:
             branches:
               only:
                 - main
                 - beta
     jobs:
       - test     schedule     Scheduled workflows are not available for projects integrated through the GitHub App, GitLab or Bitbucket Data Center.           The scheduled workflows feature is set to be deprecated. Using scheduled pipelines rather than scheduled workflows offers several benefits. Visit the scheduled pipelines  migration guide to find out how to migrate existing scheduled workflows to scheduled pipelines. If you would like to set up scheduled pipelines from scratch, visit the  Scheduled pipelines page.        A workflow may have a schedule indicating it runs at a certain time, for example a nightly build that runs every day at 12am UTC:    workflows:
   nightly:
     triggers:
       - schedule:
           cron: "0 0 * * *"
           filters:
             branches:
               only:
                 - main
                 - beta
     jobs:
       - test     cron  The cron key is defined using POSIX crontab syntax.  KeyRequiredTypeDescriptioncronYStringSee the  crontab man page.   workflows:
   nightly:
     triggers:
       - schedule:
           cron: "0 0 * * *"
           filters:
             branches:
               only:
                 - main
                 - beta
     jobs:
       - test      filters  Trigger filters can have the key branches.  KeyRequiredTypeDescriptionfiltersYMapA map defining rules for execution on specific branches   workflows:
   nightly:
     triggers:
       - schedule:
           cron: "0 0 * * *"
           filters:
             branches:
               only:
                 - main
                 - beta
     jobs:
       - test      branches  The branches key controls whether the current branch should have a schedule trigger created for it, where current branch is the branch containing the config.yml file with the trigger stanza. That is, a push on the main branch will only schedule a  workflow for the main branch.   Branches can have the keys only and ignore which each map to a single string naming a branch. You may also use regular expressions to match against branches by enclosing them with `/’s, or map to a list of such strings. Regular expressions must match the entire string.     Any branches that match only will run the job.   Any branches that match ignore will not run the job.   If neither only nor ignore are specified then all branches will run the job. If both only and ignore are specified, the only is used and ignore will have no effect.      workflows:
  commit:
    jobs:
      - test
      - deploy
  nightly:
    triggers:
      - schedule:
          cron: "0 0 * * *"
          filters:
            branches:
              only:
                - main
                - /^release\/.*/
    jobs:
      - coverage   KeyRequiredTypeDescriptionbranchesYMapA map defining rules for execution on specific branchesonly 1NString, or List of StringsEither a single branch specifier, or a list of branch specifiersignore 1NString, or List of StringsEither a single branch specifier, or a list of branch specifiers  1: One of either only or ignore branch filters must be specified. If both are present, only is used.       Using when in workflows     Using when or unless under workflows is supported in version: 2.1 configuration. Workflows are always run unless there is a when or unless filter that prevents the workflow from being run. If you want a workflow to run in every pipeline, do not add a when or unless filter.        You may use a when clause (the inverse clause unless is also supported) under a workflow declaration with a  logic statement to determine whether or not to run that workflow.   The example configuration below uses a pipeline parameter, run_integration_tests to drive the integration_tests workflow.    version: 2.1

workflows:
  integration_tests:
    when: pipeline.git.branch == "main"
    jobs:
      - mytestjob

jobs:
...    This example prevents the workflow integration_tests from running unless the pipeline is triggered on the main branch.   Refer to the  Workflows for more examples and conceptual information.     jobs  A job can have the keys requires, name, context, type, and filters.  KeyRequiredTypeDescriptionjobsYListA list of jobs to run with their dependencies   <job_name>  A job name that exists in your config.yml.    serial-group  The serial-group key is used to add a property to a job to allow a group of jobs to run in series, rather than concurrently, across an organization. Serial groups control the orchestration of jobs across an organization, not just within projects and pipelines.   The serial-group key is configurable per job. It is not possible to configure the key for a group of jobs at this time.   The value of the serial-group key is a string that is used to group jobs together to run one after another. The key must meet the following requirements:     Must be less than or equal to (≤) 512 characters, once compiled.   Must not be blank.   Must consist of alphanumeric characters plus, ., -, _, /.     Note the following features of serial groups:     You can use pipeline values and parameters in the serial-group key.   Serial groups will wait for five hours. After this jobs waiting in the group will be cancelled. This does not affect the standard limits that apply to a  job’s runtime.         Pipeline order protection in serial groups   Jobs in a serial group follow an order protection mechanism, as follows:     Jobs start in the order they join the queue, but are accepted based on pipeline number.   If a group is waiting/running and another job in the same project attempts to join the queue with a lower pipeline number, the job is skipped.   This immediate skip process exists to maintain order integrity, which is a safety process to avoid unexpected work in a build, for example, a deployment job running a previous version unexpectedly.     If there are no serial groups waiting/running, a pipeline with a lower number can start, such as restoring back to a previous pipeline via a rerun workflow.        KeyRequiredTypeDescriptionserial-groupNStringA string that is used across an org to group jobs together to run one after another. Can include pipeline values and parameters. Use this same serial group across multiple pipelines to control the orchestration of jobs across an organization.  Example:    # Creating multiple pipelines at the same time with the below config will results in
# all pipelines running test and build but only a single pipeline will run deploy at a time.

workflows:
  main-workflow:
    jobs:
      - test
      - build
      - deploy:
          serial-group: << pipeline.project.slug >>/deploy-group
          requires:
            - test
            - build    For more information, see the  Controlling serial execution across your organization page. '''    requires  Jobs are run concurrently by default, so you must explicitly require any dependencies by their job name if you need some jobs to run sequentially.  KeyRequiredTypeDescriptionrequiresNList A list of jobs that must succeed or attain a specified status for the job to start. Note: When jobs in the current workflow that are listed as dependencies are not executed (due to a filter function for example), their requirement as a dependency for other jobs will be ignored by the requires option. However, if all dependencies of a job are filtered, then that job will not be executed either.   Possible types of requires items:     Job name (a required job that must succeed for the job to start)   Map of job name to status (a required job that must attain the specified status for the job to start)   Map of job name to a list of statuses (a required job that must attain one of the specified status for the job to start)     The possible status values are: success, failed and canceled.    workflows:
  my-workflow:
    jobs:
      - build
      - test:
          requires:
            - build
      - deploy:
          requires:
            - build
            - test
      - notify-build-canceled:
          requires:
            - build: canceled
      - cleanup:
          requires:
            - deploy:
              - failed
              - canceled      name  The name key can be used to invoke reusable jobs across any number of workflows. Using the name key ensures numbers are not appended to your job name (for example, sayhello-1 , sayhello-2, etc.). The name you assign to the name key needs to be unique, otherwise the numbers will still be appended to the job name.  KeyRequiredTypeDescriptionnameNStringA replacement for the job name. Useful when calling a job multiple times. If you want to invoke the same job multiple times, and a job requires one of the duplicate jobs, this key is required. (2.1 only)    context  Jobs may be configured to use global environment variables set for an organization, see the  Contexts document for adding a context in the application settings.  KeyRequiredTypeDescriptioncontextNString/ListThe name of the context(s). The initial default name is org-global. Each context name must be unique. If using CircleCI server, only a single context per workflow is supported. Note: A maximum of 100 unique contexts across all workflows is allowed.    type  A job may have a type of approval indicating it must be manually approved before downstream jobs may proceed. For more information see the  Using workflows to orchestrate jobs page.   Jobs run in the dependency order until the workflow processes a job with the type: approval key followed by a job on which it depends, for example:    workflows:
  my-workflow:
    jobs:
      - build
      - test:
          requires:
            - build
      - hold:
          type: approval
          requires:
            - test
      - deploy:
          requires:
            - hold    An approval job can have any name. In the example above the approval job is named hold. The name you choose for an approval job should not be used to define a job in the main configuration. An approval job only exists as a workflow orchestration devise.     filters  Filter job execution within a workflow based on the following:     Branch   Tag   Expression-based condition     Job filters can have the keys branches or tags.      Workflows will ignore job-level branching. If you use job-level branching and later add workflows, you must remove the branching at the job level and instead declare it in the workflows section of your config.yml.       KeyRequiredTypeDescriptionfiltersNMapA map or string to define rules for job execution. Branch and tag filters require a map. Expression-based filters require a string.  The following is an example of how the CircleCI documentation project uses a regular expression to filter running a job in a workflow only on a specific branch:    # ...
workflows:
  build-deploy:
    jobs:
      - js_build
      - build_server_pdfs: # << the job to conditionally run based on the filter-by-branch-name.
          filters:
            branches:
              only: /server\/.*/ # the job build_server_pdfs will only run when the branch being built starts with server/    You can read more about using regular expressions in your config in the  Using workflows to schedule jobs page.     Expression-based job filters  Expression-based job filters allow you to conditionally run jobs based on the following:      Pipeline values    Pipeline parameters     An expression-based job filter is a rule that is evaluated against pipeline values and parameters to decide whether a job should run.   Using expression-based job filters is one way to optimize your pipelines. Optimizations include the following:     Lower costs.   Decrease time to feedback.   Run specific jobs based on the context of the source of change.      workflows:
  deploy:
    jobs:
      - init-service
      - test-service
      - build-service-image:
          requires:
            - init-service
      - dry-run-service:
          requires:
            - init-service
          filters: pipeline.git.branch != "main" and pipeline.git.branch != "canary"
      - publish-service:
          requires:
            - build-service-image
            - test-service
          filters: pipeline.git.branch == "main" or pipeline.git.tag starts-with "release"
      - deploy-service:
          context:
            - org-global
          requires:
            - publish-service
          filters: pipeline.git.branch == "main" and pipeline.parameters.my-custom-param starts-with "DEPLOY:"    Examples   Only run the job on the project’s main branch:    filters: pipeline.git.branch == "main"    Only run the job on the project’s main branch, or branches starting with integration-test:    filters: pipeline.git.branch == "main" or pipeline.git.branch starts-with "integration-test"    Only run the job on the main branch, and disallow use with pipelines  triggered with unversioned configuration:    filters: pipeline.git.branch == "main" and not (pipeline.trigger_source starts-with "api")    Use pipeline parameters and the pipeline value pipeline.git.branch to run a job only on specific branches or when triggered via the API with a pipeline parameter set to true:    version: 2.1

parameters:
  run-storybook-tests:
    type: boolean
    default: false

...
# jobs configuration ommitted for brevity

workflows:
  build:
    jobs:
      - setup
      - storybook-tests:
          requires:
            - setup
          filters: |
            pipeline.parameters.run-storybook-tests
            or pipeline.git.branch == "dry-run-deploy"
            or pipeline.git.branch starts-with "deploy"    You can use the API to trigger a pipeline with a pipeline parameter set to true:      Using server? If you are using CircleCI server, replace https://circleci.com with your server hostname when interacting with the CircleCI API.         curl -X POST https://circleci.com/api/v2/project/circleci/<org-id>/<project-id>/pipeline/run \
  --header "Circle-Token: $CIRCLE_TOKEN" \
  --header "content-type: application/json" \
  --data {
  "definition_id": "<pipeline-definition-id>",
  "config": {"branch": "<your-branch-name>"},
  "checkout": {"branch": "<your-branch-name>"},
  "parameters": {"run-storybook-tests": "true"}
  }    Operators   The operators you can use for expression-based job filters are described in the following table. You can also group sub-expressions with parentheses (, ). as in the examples above.  Operator typeOperatorsDescriptionLogicaland, orThese are short-circuiting boolean operators.Equality==, !=String, numeric, and boolean equality. If the operands are of different types then == will evaluate false, and != will evaluate true.Equalitystarts-withString prefix equality, "hello world" starts-with "hello" evaluates as true. It is an error to use a non-string type as an operand.Numeric comparison>=, >, ⇐, <Numeric comparisons. It is an error to use a non-numeric type as an operand.Negationnot Boolean negation.   Note that not has very high precedence and so binds very tightly. Use sub-expressions to apply not to more complex expressions. For example, with foo being true and bar being false:     not foo and bar evaluates to false   not (foo and bar) evaluates to true       branches  The branches filter can have the keys only and ignore, which map to a single string naming a branch. You may also use regular expressions to match against branches by enclosing them with slashes, or map to a list of such strings. Regular expressions must match the entire string.     Any branches that match only will run the job.   Any branches that match ignore will not run the job.   If neither only nor ignore are specified then all branches will run the job.   If both only and ignore are specified the only is considered before ignore.    KeyRequiredTypeDescriptionbranchesNMapA map defining rules for execution on specific branches.onlyNString, or list of stringsEither a single branch specifier, or a list of branch specifiers.ignoreNString, or list of stringsEither a single branch specifier, or a list of branch specifiers.   workflows:
  dev_stage_pre-prod:
    jobs:
      - test_dev:
          filters:  # using regex filters requires the entire branch to match
            branches:
              only:  # only branches matching the below regex filters will run
                - dev
                - /user-.*/
      - test_stage:
          filters:
            branches:
              only: stage
      - test_pre-prod:
          filters:
            branches:
              only: /pre-prod(?:-.+)?$/      tags  CircleCI does not run workflows for tags unless you explicitly specify tag filters. If a job requires any other jobs (directly or indirectly), you must specify tag filters for those jobs.   Tags can have the keys only and ignore. You may also use regular expressions to match against tags by enclosing them with slashes, or map to a list of such strings. Regular expressions must match the entire string. Both lightweight and annotated tags are supported.     Any tags that match only will run the job.   Any tags that match ignore will not run the job.   If neither only nor ignore are specified then the job is skipped for all tags.   If both only and ignore are specified the only is considered before ignore.    KeyRequiredTypeDescriptiontagsNMapA map defining rules for execution on specific tagsonlyNString, or List of StringsEither a single tag specifier, or a list of tag specifiersignoreNString, or List of StringsEither a single tag specifier, or a list of tag specifiers  For more information, see the  Executing workflows for a git tag section of the Workflows page.    workflows:
  untagged-build:
    jobs:
      - build
  tagged-build:
    jobs:
      - build:
          filters:
            tags:
              only: /^v.*/      matrix     The matrix key is supported in version: 2.1 configuration        The matrix stanza allows you to run a parameterized job multiple times with different arguments. For more information see the how-to guide on  Using Matrix Jobs. In order to use the matrix stanza, you must use parameterized jobs.  KeyRequiredTypeDescriptionparametersYMapA map of parameter names to every value the job should be called withexcludeNListA list of argument maps that should be excluded from the matrixaliasNStringAn alias for the matrix, usable from another job’s requires stanza. Defaults to the name of the job being executed  Example:   The following is a basic example of using matrix jobs.    workflows:
  workflow:
    jobs:
      - build:
          matrix:
            parameters:
              version: ["0.1", "0.2", "0.3"]
              platform: ["macos", "windows", "linux"]    This expands to 9 different build jobs, and could be equivalently written as:    workflows:
  workflow:
    jobs:
      - build:
          name: build-macos-0.1
          version: "0.1"
          platform: macos
      - build:
          name: build-macos-0.2
          version: "0.2"
          platform: macos
      - build:
          name: build-macos-0.3
          version: "0.3"
          platform: macos
      - build:
          name: build-windows-0.1
          version: "0.1"
          platform: windows
      - ...      Excluding sets of parameters from a matrix  Sometimes you may wish to run a job with every combination of arguments except some value or values. You can use an exclude stanza to achieve this:    workflows:
  workflow:
    jobs:
      - build:
          matrix:
            parameters:
              a: [1, 2, 3]
              b: [4, 5, 6]
            exclude:
              - a: 3
                b: 5    The matrix above would expand into 8 jobs: every combination of the parameters a and b, excluding {a: 3, b: 5}     Dependencies and matrix jobs  To require an entire matrix (every job within the matrix), use its alias. The alias defaults to the name of the job being invoked.    workflows:
  workflow:
    jobs:
      - deploy:
          matrix:
            parameters:
              version: ["0.1", "0.2"]
      - another-job:
          requires:
            - deploy    This means that another-job will require both deploy jobs in the matrix to finish before it runs.   Matrix jobs expose their parameter values via << matrix.* >> which can be used to generate more complex workflows. For example, here is a deploy matrix where each job waits for its respective build job in another matrix.    workflows:
  workflow:
    jobs:
      - build:
          name: build-v<< matrix.version >>
          matrix:
            parameters:
              version: ["0.1", "0.2"]
      - deploy:
          name: deploy-v<< matrix.version >>
          matrix:
            parameters:
              version: ["0.1", "0.2"]
          requires:
            - build-v<< matrix.version >>    This workflow will expand to:    workflows:
  workflow:
    jobs:
      - build:
          name: build-v0.1
          version: "0.1"
      - build:
          name: build-v0.2
          version: "0.2"
      - deploy:
          name: deploy-v0.1
          version: "0.1"
          requires:
            - build-v0.1
      - deploy:
          name: deploy-v0.2
          version: "0.2"
          requires:
            - build-v0.2      pre-steps and post-steps     Pre-steps and post-steps are supported in version: 2.1 configuration        Every job invocation in a workflow may optionally accept two special arguments: pre-steps and post-steps.   Steps under pre-steps are executed before any of the other steps in the job. The steps under post-steps are executed after all of the other steps.   Pre and post steps allow you to execute steps in a given job without modifying the job. Pre and post steps are useful, for example, to run custom setup steps before job execution.    version: 2.1

jobs:
  bar:
    machine:
      image: ubuntu-2004:2024.05.1
    steps:
      - checkout
      - run:
          command: echo "building"
      - run:
          command: echo "testing"

workflows:
  build:
    jobs:
      - bar:
          pre-steps: # steps to run before steps defined in the job bar
            - run:
                command: echo "install custom dependency"
          post-steps: # steps to run after steps defined in the job bar
            - run:
                command: echo "upload artifact to s3"           Logic statements   Certain dynamic configuration features accept logic statements as arguments. Logic statements are evaluated to boolean values at configuration compilation time, that is, before the workflow is run. The group of logic statements includes:  TypeArgumentstrue ifExampleYAML literalNoneis truthytrue/42/"a string"YAML aliasNoneresolves to a truthy value*my-alias Pipeline ValueNoneresolves to a truthy value<< pipeline.git.branch >> Pipeline ParameterNoneresolves to a truthy value<< pipeline.parameters.my-parameter >>andN logic statementsall arguments are truthyand: [ true, true, false ]orN logic statementsany argument is truthyor: [ false, true, false ]not1 logic statementthe argument is not truthynot: trueequalN valuesall arguments evaluate to equal valuesequal: [ 42, << pipeline.number >>]matchespattern and valuevalue matches the patternmatches: { pattern: "^feature-.$", value: << pipeline.git.branch >> }+  The following logic values are considered falsy:     false   null   0   NaN   empty strings ("")   statements with no arguments     All other values are truthy. Also note that using logic with an empty list will cause a validation error.   Logic statements always evaluate to a boolean value at the top level, and coerce as necessary. They can be nested in an arbitrary fashion, according to their argument specifications, and to a maximum depth of 100 levels.   matches uses  Java regular expressions for its pattern. A full match pattern must be provided, prefix matching is not an option. Though, it is recommended to enclose a pattern in ^ and $ to avoid accidental partial matches.      When using logic statements at the workflow level, do not include the condition: key (the condition key is only needed for job level logic statements).         workflows:
  my-workflow:
    when:
      or:
        - equal: [ main, << pipeline.git.branch >> ]
        - equal: [ staging, << pipeline.git.branch >> ]    Logic statement examples  You can find usage examples on the  "Orchestration cookbook" page.      Example full configuration      Using Docker? Authenticating Docker pulls from image registries is recommended when using the Docker execution environment. Authenticated pulls allow access to private Docker images, and may also grant higher rate limits, depending on your registry provider. For further information see  Using Docker authenticated pulls.         version: 2.1
jobs:
  build:
    docker:
      - image: ubuntu:23.04

      - image: mongo:6.0.14
        command: [mongod, --smallfiles]

      - image: postgres:14.12
        # some containers require setting environment variables
        environment:
          POSTGRES_USER: user

      - image: redis@sha256:54057dd7e125ca41afe526a877e8bd35ec2cdd33b9217e022ed37bdcf7d09673

      - image: rabbitmq:3.12.12

    environment:
      TEST_REPORTS: /tmp/test-reports

    working_directory: ~/my-project

    steps:
      - checkout

      - run:
          command: echo 127.0.0.1 devhost | sudo tee -a /etc/hosts

      # Create Postgres users and database
      # Note the YAML heredoc '|' for nicer formatting
      - run: |
          sudo -u root createuser -h localhost --superuser ubuntu &&
          sudo createdb -h localhost test_db

      - restore_cache:
          keys:
            - v1-my-project-{{ checksum "project.clj" }}
            - v1-my-project-

      - run:
          environment:
            SSH_TARGET: "localhost"
            TEST_ENV: "linux"
          command: |
            set -xu
            mkdir -p ${TEST_REPORTS}
            run-tests.sh
            cp out/tests/*.xml ${TEST_REPORTS}

      - run: |
          set -xu
          mkdir -p /tmp/artifacts
          create_jars.sh << pipeline.number >>
          cp *.jar /tmp/artifacts

      - save_cache:
          key: v1-my-project-{{ checksum "project.clj" }}
          paths:
            - ~/.m2

      # Save artifacts
      - store_artifacts:
          path: /tmp/artifacts
          destination: build

      # Upload test results
      - store_test_results:
          path: /tmp/test-reports

  deploy-stage:
    docker:
      - image: ubuntu:23.04
    working_directory: /tmp/my-project
    steps:
      - run:
          name: Deploy if tests pass and branch is Staging
          command: ansible-playbook site.yml -i staging

  deploy-prod:
    docker:
      - image: ubuntu:23.04
    working_directory: /tmp/my-project
    steps:
      - run:
          name: Deploy if tests pass and branch is Main
          command: ansible-playbook site.yml -i production

workflows:
  build-deploy:
    jobs:
      - build:
          filters:
            branches:
              ignore:
                - develop
                - /feature-.*/
      - deploy-stage:
          requires:
            - build
          filters:
            branches:
              only: staging
      - deploy-prod:
          requires:
            - build
          filters:
            branches:
              only: main    Suggest an edit to this pageMake a contribution Learn how to contributeStill need help? Ask the CircleCI community Join the research community Visit our Support site\n\nConfiguration reference1 week agoCloudServer v4+Helpful Resources6 config optimization tipsIntro to dynamic configUsing dynamic configValidate your config using local CLIHow to trigger a single jobOn This Pageversionsetuporbscommandsparametersexecutorsjobs<job_name>typeenvironmentparallelismparametersExecutor docker / machine / macosdockerDocker registry authenticationAWS authenticationUse OIDCUse environment variablesmachineAvailable Linux machine imagesAvailable Linux machine images on serverAvailable Linux GPU machine imagesAvailable Android machine imagesAvailable Windows machine imagesAvailable Windows machine images on serverAvailable Windows GPU machine imagemacosbranches - DEPRECATEDresource_classSelf-hosted runnerDocker execution environmentx86ArmLinuxVM execution environmentmacOS execution environmentmacOS execution environment on serverWindows execution environmentGPU execution environment (Linux)GPU execution-environment (Windows)Arm VM execution-environmentstepsrunDefault shell options-e-o pipefailBackground commandsShorthand syntaxThe when attributeEnding a job from within a stepThe when stepcheckoutsetup_remote_dockersave_cacherestore_cachedeploy - DEPRECATEDstore_artifactsstore_test_resultspersist_to_workspaceattach_workspaceadd_ssh_keysUsing pipeline valuescircleci_ip_rangesworkflowsversion<workflow_name>triggersschedulecronfiltersbranchesUsing when in workflowsjobs<job_name>serial-grouprequiresnamecontexttypefiltersExpression-based job filtersbranchestagsmatrixExcluding sets of parameters from a matrixDependencies and matrix jobspre-steps and post-stepsLogic statementsLogic statement examplesExample full configuration   This document is a reference for the CircleCI 2.x configuration keys that are used in the .circleci/config.yml file.   You can see a complete config.yml in our  full example.      version  KeyRequiredTypeDescriptionversionYString2, 2.0, or 2.1 See the  Reusable configuration page for an overview of 2.1 keys available to simplify your .circleci/config.yml file, reuse, and parameterized jobs.  The version field is intended to be used in order to issue warnings for deprecation or breaking changes.      setup  KeyRequiredTypeDescriptionsetupNBooleanDesignates the config.yaml for use of CircleCI’s  dynamic configuration feature.  The setup field enables you to conditionally trigger configurations from outside the primary .circleci parent directory, update pipeline parameters, or generate customized configurations.      orbs      The orbs key is supported in version: 2.1 configuration       KeyRequiredTypeDescriptionorbsNMapA map of user-selected names to either: orb references (strings) or orb definitions (maps). Orb definitions must be the orb-relevant subset of 2.1 config. See the  Creating Orbs documentation for details.executorsNMapA map of strings to executor definitions. See the  executors section below.commandsNMapA map of command names to command definitions. See the  commands section below.  The following example uses the node orb that exists in the certified circleci namespace. Refer to the Node orb page in the  Orb Registry for more examples and information.    version: 2.1

orbs:
  node: circleci/node@x.y

jobs:
  install-node-example:
    docker:
      - image: cimg/base:stable
    steps:
      - checkout
      - node/install:
          install-yarn: true
          node-version: '16.13'
      - run: node --version
workflows:
  test_my_app:
    jobs:
      - install-node-example    Documentation is available for orbs in the following sections:      Using Orbs    Authoring Orbs.     Public orbs are listed in the  Orb Registry.      commands      The commands key is supported in version: 2.1 configuration        A command defines a sequence of steps as a map to be executed in a job, enabling you to reuse a single command definition across multiple jobs. For more information see the  Reusable Config Reference Guide.  KeyRequiredTypeDescriptionstepsYSequenceA sequence of steps run inside the calling job of the command.parametersNMapA map of parameter keys. See the  Parameter Syntax section of the  Reusing Config document for details.descriptionNStringA string that describes the purpose of the command.  Example:    commands:
  sayhello:
    description: "A very simple command for demonstration purposes"
    parameters:
      to:
        type: string
        default: "Hello World"
    steps:
      - run: echo << parameters.to >>       parameters      The pipeline parameters key is supported in version: 2.1 configuration        Pipeline parameters declared for use in the configuration. See  Pipeline Values and Parameters for usage details.  KeyRequiredTypeDescriptionparametersNMapA map of parameter keys. Supports string, boolean, integer and enum types. See  Parameter Syntax for details.     executors      The executors key is supported in version: 2.1 configuration        Executors define the execution environment in which the steps of a job will be run, allowing you to reuse a single executor definition across multiple jobs.  KeyRequiredTypeDescriptiondockerY (1)ListOptions for  Docker executorresource_classNStringAmount of CPU and RAM allocated to each container in a job.machineY (1)MapOptions for  machine executormacosY (1)MapOptions for  macOS executorwindowsY (1)Map Windows executor currently working with orbs. Check out  the orb.shellNStringShell to use for execution command in all steps. Can be overridden by shell in each step (default: See  Default Shell Options)working_directoryNStringIn which directory to run the steps. Will be interpreted as an absolute path.environmentNMapA map of environment variable names and values.  (1) One executor type should be specified per job. If more than one is set you will receive an error.   Example:    version: 2.1
executors:
  my-executor:
    docker:
      - image: cimg/ruby:3.0.3-browsers

jobs:
  my-job:
    executor: my-executor
    steps:
      - run: echo "Hello executor!"    See the  Using Parameters in Executors section of the  Reusing config page for examples of parameterized executors.      jobs   A Workflow is comprised of one or more uniquely named jobs. Jobs are specified in the jobs map, see  Sample config.yml for two examples of a job map. The name of the job is the key in the map, and the value is a map describing the job.   Jobs have a maximum runtime based on pricing plan, as follows:     1 hour (Free)   3 hours (Performance)   5 hours (Scale)     If your jobs are timing out, consider the following:     A larger  resource_class.   Using  parallelism.   Run some of your jobs concurrently using  workflows.   You can upgrade your pricing plan.      <job_name>  Each job consists of the job’s name as a key and a map as a value. A name should be case insensitive unique within a current jobs list. The value map has the following attributes:  KeyRequiredTypeDescriptiontypeNStringJob type, can be build, release, no-op, or approval. If not specified, defaults to build.dockerY (1)ListOptions for the  Docker executormachineY (1)MapOptions for the  machine executormacosY (1)MapOptions for the  macOS executorshellNStringShell to use for execution command in all steps. Can be overridden by shell in each step (default: See  Default Shell Options)parametersNMap Parameters for making a job explicitly configurable in a workflow.stepsYListA list of  steps to be performedworking_directoryNStringIn which directory to run the steps. Will be interpreted as an absolute path. Default: ~/project (where project is a literal string, not the name of your specific project). Processes run during the job can use the $CIRCLE_WORKING_DIRECTORY environment variable to refer to this directory. Note: Paths written in your YAML configuration file will not be expanded; if your store_test_results.path is $CIRCLE_WORKING_DIRECTORY/tests, then CircleCI will attempt to store the test subdirectory of the directory literally named $CIRCLE_WORKING_DIRECTORY, dollar sign $ and all. working_directory will be created automatically if it doesn’t exist.parallelismNIntegerNumber of parallel instances of this job to run (default: 1)environmentNMapA map of environment variable names and values.branchesNMapThis key is deprecated. Use  workflows filtering to control which jobs run for which branches.resource_classNStringAmount of CPU and RAM allocated to each container in a job.  (1) One executor type should be specified per job. If more than one is set you will receive an error.    type  Configure a job type. Options are release, approval, no-op, build (default).   If a type is not specified, the job defaults to a build type.   Example of a job with a build type. build is the default type and does not need to be configured:    jobs:
  my-job:
    docker:
      - image: cimg/base:2024.12
    resource_class: xlarge
    steps:
      ... // other config    Jobs with the release type are used to  connect your pipeline configuration to a deployment in the CircleCI deploys UI. For full details, see the  Deploys overview page.   Example of a job with a release type:    jobs:
  release-my-service:
    type: release
    plan_name: <my-service-release>    The no-op type is used to configure a job that performs no actions and consumes no credits. no-op is commonly used to organise the order of operations within a workflow and make it easier to maintain. Only the type is required for a no-op type job, no further job configuration is required. For some examples of using no-op jobs, see the  Orchestration cookbook   Example of a job with a no-op type:    jobs:
  my-no-op-job:
    type: no-op    The approval type is used to configure a manual approval step. No job configuration is required or allowed for an approval type job. The approval type is most commonly configured within a workflow rather than under the top-level jobs key. Only approval type jobs can have their type configured under workflows. See  type under workflows section for full details.   Example of a job with an approval type, configured under workflows:    workflows:
  my-workflow:
    jobs:
      - build
      - test:
          requires:
            - build
      - hold:
          type: approval
          requires:
            - test
      - deploy:
          requires:
            - hold      environment  A map of environment variable names and values. For more information on defining and using environment variables, and the order of precedence governing the various ways they can be set, see the  Environment variables page.     parallelism  This feature is used to optimize test steps. If parallelism is set to N > 1, then N independent executors will be set up and each will run the steps of that job in parallel.   You can use the CircleCI CLI to split your test suite across parallel containers so the job completes in a shorter time.     Read more about splitting tests across parallel execution environments on the  Parallelism and test splitting page.   Refer to the  Use the CircleCI CLI to split tests how-to guide.   Follow the  Test splitting tutorial.     Example:    jobs:
  build:
    docker:
      - image: cimg/base:2024.12
    environment:
      FOO: bar
    parallelism: 3
    resource_class: large
    working_directory: ~/my-app
    steps:
      - run: go list ./... | circleci tests run --command "xargs gotestsum --junitfile junit.xml --format testname --" --split-by=timings --timings-type=name      parameters  Job-level parameters can be used when  calling a job in a workflow.   Reserved parameter-names:     name   requires   context   type   filters   matrix     See  Parameter Syntax for definition details.     Executor docker / machine / macos  CircleCI offers several execution environments in which to run your jobs. To specify an execution environment choose an executor, then specify and image and a resource class. An executor defines the underlying technology, environment, and operating system in which to run a job.   Set up your jobs to run using the docker (Linux), machine (LinuxVM, Windows, GPU, Arm), or macos executor, then specify an image with the tools and packages you need, and a resource class.   Learn more about execution environments and executors in the  Introduction to Execution Environments.     docker  Configured by docker key which takes a list of maps:  KeyRequiredTypeDescriptionimageYStringThe name of a custom Docker image to use. The first image listed under a job defines the job’s own primary container image where all steps will run.nameNStringname defines the hostname for the container (the default is localhost), which is used for reaching secondary (service) containers. By default, all services are exposed directly on localhost. This field is useful if you would rather have a different hostname instead of localhost, for example, if you are starting multiple versions of the same service.entrypointNString or ListThe command used as executable when launching the container. entrypoint overrides the image’s  ENTRYPOINT.commandNString or ListThe command used as PID 1 (or arguments for entrypoint) when launching the container. command overrides the image’s COMMAND. It will be used as arguments to the image ENTRYPOINT if it has one, or as the executable if the image has no ENTRYPOINT.userNStringWhich user to run commands as within the Docker containerenvironmentNMapA map of environment variable names and values. The environment settings apply to the entrypoint/command run by the Docker container, not the job steps.authNMapAuthentication for registries using standard docker login credentialsaws_authNMapAuthentication for AWS Elastic Container Registry (ECR)  For a  primary container, (the first container in the list) if neither command nor entrypoint is specified in the configuration, then any ENTRYPOINT and COMMAND in the image are ignored. The primary container is typically only used for running the steps and not for its ENTRYPOINT, and an ENTRYPOINT may consume significant resources or exit prematurely.   A  custom image may disable this behavior and force the ENTRYPOINT to run.   You can specify image versions using tags or digest. You can use any public images from any public Docker registry (defaults to Docker Hub). Learn more about specifying images on the  Using the Docker Execution Environment page.    Docker registry authentication  Some registries, Docker Hub, for example, may rate limit anonymous Docker pulls. We recommend that you authenticate to pull private and public images. The username and password can be specified in the auth field. See  Using Docker Authenticated Pulls for details.   Example:    jobs:
  build:
    docker:
      - image: buildpack-deps:trusty # primary container
        auth:
          username: mydockerhub-user
          password: $DOCKERHUB_PASSWORD  # context / project UI env-var reference
        environment:
          ENV: CI

      - image: mongo:2.6.8
        auth:
          username: mydockerhub-user
          password: $DOCKERHUB_PASSWORD  # context / project UI env-var reference
        command: [--smallfiles]

      - image: postgres:14.2
        auth:
          username: mydockerhub-user
          password: $DOCKERHUB_PASSWORD  # context / project UI env-var reference
        environment:
          POSTGRES_USER: user

      - image: redis@sha256:54057dd7e125ca41afe526a877e8bd35ec2cdd33b9217e022ed37bdcf7d09673
        auth:
          username: mydockerhub-user
          password: $DOCKERHUB_PASSWORD  # context / project UI env-var reference

      - image: acme-private/private-image:321
        auth:
          username: mydockerhub-user
          password: $DOCKERHUB_PASSWORD  # context / project UI env-var reference      AWS authentication  Using an image hosted on  AWS ECR requires authentication using AWS credentials.   Use OIDC  Authenticate using OpenID Connect (OIDC) using the oidc_role_arn field, as follows:    jobs:
  job_name:
    docker:
      - image: <your-image-arn>
        aws_auth:
          oidc_role_arn: <your-iam-role-arn>    For steps to get set up with OIDC to pull images from AWS ECR, see the  Pull and image from AWS ECR with OIDC page.    Use environment variables  By default, CircleCI uses the AWS credentials you provide by setting the AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY project environment variables. It is also possible to set the credentials by using the aws_auth field as in the following example:    jobs:
  build:
    docker:
      - image: account-id.dkr.ecr.us-east-1.amazonaws.com/org/repo:0.1
        aws_auth:
          aws_access_key_id: AKIAQWERVA  # can specify string literal values
          aws_secret_access_key: $ECR_AWS_SECRET_ACCESS_KEY  # or project UI envar reference        machine     CircleCI cloud The use of machine: true is deprecated. You must specify an image to use.        The machine executor is configured using the machine key, which takes a map:  KeyRequiredTypeDescriptionimageYStringThe virtual machine image to use. View  available images. Note: This key is not supported for Linux VMs on installations of CircleCI server. For information about customizing machine executor images on CircleCI installed on your servers, see our  Machine provisioner documentation.docker_layer_cachingNBooleanSet this to true to enable  Docker layer caching.  Example:  CloudServer    jobs:
  build: # name of your job
    machine: # executor type
      image: ubuntu-2004:current # recommended linux image

    steps:
      # Commands run in a Linux virtual machine environment        jobs:
  build: # name of your job
    machine: true # executor type
    steps:
      # Commands run in a Linux virtual machine environment        Available Linux machine images  Specifying an image in your configuration file is strongly recommended. CircleCI supports multiple Linux machine images that can be specified in the image field. For a full list of supported image tags, refer to the following pages in the Developer Hub:      Ubuntu-2004    Ubuntu-2204     More information on the software available in each image can be found in our  Discuss forum.   The machine executor supports  Docker Layer Caching, which is useful when you are building Docker images during your job or Workflow.     Available Linux machine images on server  If you are using CircleCI server, contact your system administrator for details of available Linux machine images.     Available Linux GPU machine images  When using the Linux  GPU executor, the available images are:     linux-cuda-11:default v11.4, v11.6, v11.8 (default), Docker v20.10.24   linux-cuda-12:default v12.0, v12.1 (default), Docker v20.10.24       Available Android machine images  CircleCI supports running jobs on Android for testing and deploying Android applications.   To use the  Android image directly with the machine executor, add the following to your job:    version: 2.1

jobs:
  build:
    machine:
      image: android:2024.11.1    The Android image can also be accessed using the  Android orb.   For examples, refer to the  Using Android Images with the Machine Executor page.     Available Windows machine images  Specifying an image in your configuration file is strongly recommended. CircleCI supports multiple Windows machine images that can be specified in the image field.   For a full list of supported images, refer to one of the following:      windows-server-2022-gui image    windows-server-2019 image     More information on what software is available in each image can be found in our  Discuss forum.   Alternatively, use the  Windows orb to manage your Windows execution environment. For examples, see the  Using the Windows Execution Environment page.     Available Windows machine images on server  If you are using CircleCI server, contact your system administrator for details of available Windows machine images.     Available Windows GPU machine image  When using the Windows  GPU executor, the available image is:      windows-server-2019-cuda     Example    version: 2.1

jobs:
  build:
    machine:
      image: windows-server-2019-cuda:current       macos  CircleCI supports running jobs on  macOS, to allow you to build, test, and deploy apps for macOS,  iOS,  tvOS and  watchOS. To run a job on a macOS virtual machine, add the macos key to the top-level configuration for your job and specify the version of Xcode to use.  KeyRequiredTypeDescriptionxcodeYStringThe version of Xcode that is installed on the virtual machine, see the  Supported Xcode Versions section of the Testing iOS document for the complete list.  Example: Use a macOS virtual machine with Xcode version 14.2.0:    jobs:
  build:
    macos:
      xcode: "14.2.0"      branches - DEPRECATED  This key is deprecated. Use  workflows filtering to control which jobs run for which branches.     resource_class  The resource_class feature allows you to configure CPU and RAM resources for each job. Resource classes are available for each execution environment, as described in the tables below.   We implement soft concurrency limits for each resource class to ensure our system remains stable for all customers. If you are on a Performance or Custom Plan and experience queuing for certain resource classes, it is possible you are hitting these limits.  Contact CircleCI support to request a raise on these limits for your account.   If you do not specify a resource class, CircleCI will use a default value that is subject to change. It is best practice to specify a resource class as opposed to relying on a default.      Java, Erlang and any other languages that introspect the /proc directory for information about CPU count may require additional configuration to prevent them from slowing down when using the CircleCI resource class feature. Programs with this issue may request 32 CPU cores and run slower than they would when requesting one core. Users of languages with this issue should pin their CPU count to their guaranteed CPU resources.           If you want to confirm how much memory you have been allocated, you can check the cgroup memory hierarchy limit with grep hierarchical_memory_limit /sys/fs/cgroup/memory/memory.stat.         Self-hosted runner  Use the resource_class key to configure a  self-hosted runner instance.   For example:    jobs:
  job_name:
    machine: true
    resource_class: <my-namespace>/<my-runner>      Docker execution environment  Example:    jobs:
  build:
    docker:
      - image: cimg/base:2024.12
    resource_class: xlarge
    steps:
      ... // other config    x86     For credit and access information, see the  Resource classes page. Resource class access is dependent on your  Plan.       ClassvCPUsRAMCloudServersmall12GBmedium24GBmedium+36GBlarge48GBxlarge816GB2xlarge1632GB2xlarge+2040GB   Arm  Arm on Docker For pricing information, and a list of CircleCI Docker convenience images that support Arm resource classes, see the  Resource classes page.       Arm on Docker For credit and access information see the  Resource classes page. Resource class access is dependent on your  Plan   To find out which CircleCI Docker convenience images support Arm resource classes, you can refer to  Docker hub:     Select the image (for example, cimg/python).   Select the tags tab.   View what is supported under OS/ARCH for the latest tags. For example, cimg/python has linux/amd64 and linux/arm64, which means Arm is supported.          ClassvCPUsRAMCloudServerarm.medium28 GBarm.large416 GBarm.xlarge832 GBarm.2xlarge1664 GB     LinuxVM execution environment ClassvCPUsRAMDisk SizeCloudServermedium27.5 GB150GBlarge415 GB150GBxlarge832 GB150GB2xlarge1664 GB150GB2xlarge+3264 GB150GB  Example:  CloudServer    jobs:
  build:
    machine:
      image: ubuntu-2004:2024.01.2 # recommended linux image
    resource_class: large
    steps:
      ... // other config        jobs:
  build:
    machine: true
    resource_class: large
    steps:
      ... // other config         macOS execution environment ClassvCPUsRAMCloudServermacos.m1.medium.gen14 @ 3.2 GHz6GBmacos.m1.large.gen18 @ 3.2 GHz12GBm2pro.medium4 @ 3.49 GHz8GBm2pro.large8 @ 3.49 GHz16GB      We have deprecated support for all Intel-based macOS resources.   The macos.x86.medium.gen2 resource class was deprecated on June 28, 2024.   See our  announcement for more details.         Example    jobs:
  build:
    macos:
      xcode: "15.4.0"
    resource_class: m2pro.medium
    steps:
      ... // other config      macOS execution environment on server  If you are working on CircleCI server v3.1 and up, you can access the macOS execution environment using  self-hosted runner.     Windows execution environment ClassvCPUsRAMDisk SizeCloudServerwindows.medium (default)415GB200 GBwindows.large830GB200 GBwindows.xlarge1660GB200 GBwindows.2xlarge32128GB200 GB     Using server? Check with your systems administrator whether you have access to the Windows execution environment.        Example:  CloudServer    version: 2.1

jobs:
  build: # name of your job
    resource_class: 'windows.medium'
    machine:
      image: 'windows-server-2022-gui:current'
      shell: 'powershell.exe -ExecutionPolicy Bypass'
    steps:
      # Commands are run in a Windows virtual machine environment
      - checkout
      - run: Write-Host 'Hello, Windows'        version: 2.1

jobs:
  build: # name of your job
    machine:
      image: windows-default
    steps:
      # Commands are run in a Windows virtual machine environment
      - checkout
      - run: Write-Host 'Hello, Windows'         GPU execution environment (Linux) ClassvCPUsRAMGPUsGPU modelGPU Memory (GiB)Disk Size (GiB)CloudServergpu.nvidia.small4161NVIDIA Tesla P416150gpu.nvidia.small.gen24161NVIDIA A10G24150gpu.nvidia.small.multi4152NVIDIA Tesla T416150gpu.nvidia.medium.multi8304NVIDIA Tesla T416150gpu.nvidia.medium8301NVIDIA Tesla T416150gpu.nvidia.large8301NVIDIA Tesla V10016150  Example:    version: 2.1

jobs:
  build:
    machine:
      image: linux-cuda-12:default
    resource_class: gpu.nvidia.medium
    steps:
      - run: nvidia-smi
      - run: docker run --gpus all nvidia/cuda:9.0-base nvidia-smi    See the  Available Linux GPU images section for the full list of available images.     GPU execution-environment (Windows) ClassvCPUsRAMGPUsGPU modelGPU Memory (GiB)Disk Size (GiB)CloudServerwindows.gpu.nvidia.medium16601NVIDIA Tesla T416200  Example:    version: 2.1
orbs:
  win: circleci/windows@5.0.0

jobs:
  build:
    executor: win/server-2019-cuda
    steps:
      - checkout
      - run: '&"C:\Program Files\NVIDIA Corporation\NVSMI\nvidia-smi.exe"'    (2) This resource requires review by our support team.  Open a support ticket if you would like to request access.     Arm VM execution-environment ClassvCPUsRAMDisk SizeCloudServerarm.medium (default)28GB100 GBarm.large416GB100 GBarm.xlarge832GB100 GBarm.2xlarge1664GB100 GB     Using server? Check with your systems administrator whether you have access to the Arm execution environment.        Example:  CloudServer    jobs:
  my-job:
    machine:
      image: ubuntu-2004:2024.01.2
    resource_class: arm.medium
    steps:
      - run: uname -a
      - run: echo "Hello, Arm!"        jobs:
  my-job:
    machine:
      image: arm-default
    resource_class: arm.medium
    steps:
      - run: uname -a
      - run: echo "Hello, Arm!"          steps  The steps setting in a job should be a list of single key/value pairs, the key of which indicates the step type. The value may be either a configuration map or a string (depending on what that type of step requires). For example, using a map:    jobs:
  build:
    working_directory: ~/canary-python
    environment:
      FOO: bar
    steps:
      - run:
          name: Running tests
          command: make test    Here run is a step type. The name attribute is used by the UI for display purposes. The command attribute is specific for run step and defines command to execute.   Some steps may implement a shorthand semantic. For example, run may be also be called like this:    jobs:
  build:
    steps:
      - run: make test    In its short form, the run step allows us to directly specify which command to execute as a string value. In this case step itself provides default suitable values for other attributes (name here will have the same value as command, for example).   Another shorthand, which is possible for some steps, is to use the step name as a string instead of a key/value pair:    jobs:
  build:
    steps:
      - checkout    In this case, the checkout step will check out project source code into the job’s  working_directory.   In general all steps can be described as:  KeyRequiredTypeDescription<step_type>YMap or StringA configuration map for the step or some string whose semantics are defined by the step.  Each built-in step is described in detail below.    run  The run step is used to invoke command-line programs. The run step takes either a map of configuration values, or, when called in its short-form, a string that will be used as both the command and name. Run commands are executed using non-login shells by default, so you must explicitly source any dotfiles as part of the command.      the run step replaces the deprecated deploy step. If your job has a parallelism of 1, the deprecated deploy step can be swapped out directly for the run step. If your job has parallelism > 1, see  Migrate from deploy to run.       KeyRequiredTypeDescriptioncommandYStringCommand to run via the shellnameNStringTitle of the step to be shown in the CircleCI UI (default: full command)shellNStringShell to use for execution command (default: See  Default Shell Options)environmentNMapAdditional environmental variables, locally scoped to commandbackgroundNBooleanWhether or not this step should run in the background (default: false)working_directoryNStringIn which directory to run this step. Will be interpreted relative to the  working_directory of the job). (default: .)no_output_timeoutNStringElapsed time the command can run without output. The string is a decimal with unit suffix, such as "20m", "1.25h", "5s". The default is 10 minutes and the maximum is governed by the  maximum time a job is allowed to run.whenNString Specify when to enable or disable the step. Takes the following values: always, on_success, on_fail (default: on_success)  Each run declaration represents a new shell. It is possible to specify a multi-line command, each line of which will be run in the same shell:    - run:
    command: |
      echo Running test
      mkdir -p /tmp/test-results
      make test    You can also configure commands to run  in the background if you do not want to wait for the step to complete before moving on to subsequent run steps.    Default shell options  For jobs that run on Linux, the default value of the shell option is /bin/bash -eo pipefail if /bin/bash is present in the build container. Otherwise it is /bin/sh -eo pipefail. The default shell is not a login shell (--login or -l are not specified). Hence, the shell will not source your ~/.bash_profile, ~/.bash_login, ~/.profile files.   For jobs that run on macOS, the default shell is /bin/bash --login -eo pipefail. The shell is a non-interactive login shell. The shell will execute /etc/profile/ followed by ~/.bash_profile before every step.   For more information about which files are executed when Bash is invocated,  see the INVOCATION section of the bash manpage.   Descriptions of the -eo pipefail options are provided below.    -e  Exit immediately if any of the following exits with a non-zero status:     A pipeline (which may consist of a single simple command).   A subshell command enclosed in parentheses.   One of the commands executed as part of a command list enclosed by braces.     In the previous example, mkdir failed to create a directory and returned a non-zero status, then command execution would be terminated, and the whole step would be marked as failed. If you desire the opposite behaviour, you need to add set +e in your command or override the default shell in your configuration map of run. For example:    - run:
    command: |
      echo Running test
      set +e
      mkdir -p /tmp/test-results
      make test

- run:
    shell: /bin/sh
    command: |
      echo Running test
      mkdir -p /tmp/test-results
      make test     -o pipefail  If pipefail is enabled, the pipeline’s return status is the value of the last (rightmost) command to exit with a non-zero status, or zero if all commands exit successfully. The shell waits for all commands in the pipeline to terminate before returning a value.   For example:    - run: make test | tee test-output.log    If make test fails, the -o pipefail option will cause the whole step to fail. Without -o pipefail, the step will always run successfully because the result of the whole pipeline is determined by the last command (tee test-output.log), which will always return a zero status.      If make test fails the rest of pipeline will be executed.        If you want to avoid this behaviour, you can specify set +o pipefail in the command or override the whole shell (see example above).   In general, we recommend using the default options (-eo pipefail) because they show errors in intermediate commands and simplify debugging job failures. For convenience, the UI displays the used shell and all active options for each run step.   For more information, see the  Using Shell Scripts document.     Background commands  The background attribute enables you to configure commands to run in the background. Job execution will immediately proceed to the next step rather than waiting for return of a command with the background attribute set to true. The following example shows the configuration for running the X virtual framebuffer in the background which is commonly required to run Selenium tests:    - run:
    name: Running X virtual framebuffer
    command: Xvfb :99 -screen 0 1280x1024x24
    background: true

- run: make test      Shorthand syntax  run has a very convenient shorthand syntax:    - run: make test

# shorthanded command can also have multiple lines
- run: |
    mkdir -p /tmp/test-results
    make test    In this case, command and name become the string value of run, and the rest of the config map for that run have their default values.     The when attribute  By default, CircleCI will execute job steps one at a time, in the order that they are defined in config.yml, until a step fails (returns a non-zero exit code). After a command fails, no further job steps will be executed.   Adding the when attribute to a job step allows you to override this default behaviour, and selectively run or skip steps depending on the status of the job.   The when attribute accepts the following values:    on_success  The step will run only if all of the previous steps have been successful (returned exit code 0). on_success is the default value.  always  The step will run regardless of the exit status of previous steps. always is useful if you have a task that you want to run regardless of whether the previous steps are successful or not. For example, you might have a job step that needs to upload logs or code-coverage data somewhere.  on_fail  The step will run only if one of the preceding steps has failed (returns a non-zero exit code). A common use of on_fail is to store some diagnostic data to help debug test failures, or to run custom notifications about the failure, such as sending emails or triggering alerts.        Some steps, such as store_artifacts and store_test_results will always run, even if a step has failed (returned a non-zero exit code) previously. The when attribute, store_artifacts and store_test_results are not run if the job has been killed by a cancel request or has reached the runtime timeout limit.         - run:
    name: Upload CodeCov.io Data
    command: bash <(curl -s https://codecov.io/bash) -F unittests
    when: always # Uploads code coverage results, pass or fail      Ending a job from within a step  A job can exit without failing by using run: circleci-agent step halt. However, if a step within the job is already failing then the job will continue to fail. This can be useful in situations where jobs need to conditionally execute.   Here is an example where halt is used to avoid running a job on the develop branch:    - run: |
    if [ "$CIRCLE_BRANCH" = "develop" ]; then
        circleci-agent step halt
    fi       The when step     The when and unless steps are supported in version: 2.1 configuration        A conditional step consists of a step with the key when or unless. Under the when key are the subkeys condition and steps. The purpose of the when step is customizing commands and job configuration to run on custom conditions (determined at config-compile time) that are checked before a workflow runs. See the  Conditional Steps section of the reusable configuration reference for more details.  KeyRequiredTypeDescriptionconditionYLogic A logic statementstepsYSequenceA list of steps to execute when the condition is true  Example:    version: 2.1

jobs: # conditional steps may also be defined in `commands:`
  job_with_optional_custom_checkout:
    parameters:
      custom_checkout:
        type: string
        default: ""
    machine:
      image: ubuntu-2004:2024.11.1
    steps:
      - when:
          condition: <<parameters.custom_checkout>>
          steps:
            - run: echo "my custom checkout"
      - unless:
          condition: <<parameters.custom_checkout>>
          steps:
            - checkout
workflows:
  build-test-deploy:
    jobs:
      - job_with_optional_custom_checkout:
          custom_checkout: "any non-empty string is truthy"
      - job_with_optional_custom_checkout      checkout      Blobless clones   A "blobless" strategy is being rolled out to help improve the performance of code checkouts from Git source code hosts.   Blobless clones reduce the amount of data fetched from the remote, by asking the remote to filter out objects that are not attached to the current commit.   While this improves performance in most cases, if a downstream step requires those objects to exist for scanning or comparisons, it can cause failures. To work around these potential problems, a fetch directly after a checkout will ensure the required data is available:    - checkout
- run: git fetch          A special step used to check out source code to the configured path (defaults to the working_directory). The reason this is a special step is because it is more of a helper function designed to simplify the process of checking out code. If you require doing git over HTTPS you should not use this step as it configures git to checkout over SSH.  KeyRequiredTypeDescriptionpathNStringCheckout directory. Will be interpreted relative to the  working_directory of the job). (default: .)  If path already exists and is:     A git repository - step will not clone whole repository, instead will fetch origin   NOT a git repository - step will fail.     In the case of checkout, the step type is just a string with no additional attributes:    - checkout    The checkout command automatically adds the required authenticity keys for interacting with GitHub and Bitbucket over SSH. These keys are detailed further in the  integration guide. This guide is also helpful if you wish to implement a custom checkout command.   CircleCI does not check out submodules. If your project requires submodules, add run steps with appropriate commands as shown in the following example:    - checkout
- run: git submodule sync
- run: git submodule update --init       The checkout step will configure Git to skip automatic garbage collection. If you are caching your .git directory with  restore_cache and would like to use garbage collection to reduce its size, you may wish to use a  run step with command git gc before doing so.          setup_remote_docker  Allows Docker commands to be run locally. See  Running Docker commands for details.    jobs:
  build:
    docker:
      - image: cimg/base:2024.06
    steps:
      # ... steps for building/testing app ...
      - setup_remote_docker:
          version: default   KeyRequiredTypeDescriptiondocker_layer_cachingNbooleanSet this to true to enable  Docker Layer Caching in the Remote Docker Environment (default: false)versionNStringVersion string of Docker you would like to use (default: 24.0.9). View the list of supported Docker versions  here.        setup_remote_docker is not compatible with the machine executor. See  Docker Layer Caching in Machine Executor for information on how to enable DLC with the machine executor.   The version key is not currently supported on CircleCI server. Contact your system administrator for information about the Docker version installed in your remote Docker environment. If you are on server 4.x, you can find the default AWS AMI  here.             save_cache  Generates and stores a cache of a file or directory of files such as dependencies or source code in our object storage. Later jobs can  restore this cache. Learn more on the  Caching Dependencies page.   Cache retention can be customized on the  CircleCI web app by navigating to Plan  Usage Controls.  KeyRequiredTypeDescriptionpathsYListList of directories which should be added to the cachekeyYStringUnique identifier for this cachenameNStringTitle of the step to be shown in the CircleCI UI (default: "Saving Cache")whenNString Specify when to enable or disable the step. Takes the following values: always, on_success, on_fail (default: on_success)  The cache for a specific key is immutable and cannot be changed once written.      If the cache for the given key already exists it will not be modified, and job execution will proceed to the next step.        When storing a new cache, the key value may contain special, templated, values for your convenience:  TemplateDescription{{ .Branch }}The VCS branch currently being built.{{ .BuildNum }}The CircleCI build number for this build.{{ .Revision }}The VCS revision currently being built.{{ .CheckoutKey }}The SSH key used to checkout the repository.{{ .Environment.variableName }}The environment variable variableName (supports any environment variable  exported by CircleCI or added to a specific  context--not any arbitrary environment variable).{{ checksum "filename" }}A base64 encoded SHA256 hash of the given filename’s contents. This should be a file committed in your repository and may also be referenced as a path that is absolute or relative from the current working directory. Good candidates are dependency manifests, such as package-lock.json, pom.xml or project.clj. It is important that this file does not change between restore_cache and save_cache, otherwise the cache will be saved under a cache key different than the one used at restore_cache time.{{ epoch }}The current time in seconds since the UNIX epoch.{{ arch }}The OS and CPU information. Useful when caching compiled binaries that depend on OS and CPU architecture, for example, darwin amd64 versus linux i386/32-bit.  During step execution, the templates above will be replaced by runtime values and use the resultant string as the key.   Template examples:     myapp-{{ checksum "package-lock.json" }} - cache will be regenerated every time something is changed in package-lock.json file, different branches of this project will generate the same cache key.   myapp-{{ .Branch }}-{{ checksum "package-lock.json" }} - same as the previous one, but each branch will generate separate cache   myapp-{{ epoch }} - every run of a job will generate a separate cache     While choosing suitable templates for your cache key, keep in mind that:     Cache saving is not a free operation. See the billing section on the  FAQ page.   It takes time to upload the cache.     Best practice is to have a key that generates a new cache only if something actually changed and avoid generating a new one every time a job is run.      Given the immutability of caches, it might be helpful to start all your cache keys with a version prefix v1-.... That way you will be able to regenerate all your caches just by incrementing the version in this prefix.        Example:    - save_cache:
    key: v1-myapp-{{ arch }}-{{ checksum "project.clj" }}
    paths:
      - /home/ubuntu/.m2     - save_cache:
    key: v1-{{ checksum "yarn.lock" }}
    paths:
      - node_modules/workspace-a
      - node_modules/workspace-c          Wildcards are not currently supported in save_cache paths. Visit the  Ideas board and vote for this feature if it would be useful for you or your organization.   In some instances, a workaround for this is to save a particular workspace to cache:             restore_cache  Restores a previously saved cache based on a key. Cache needs to have been saved first for this key using the  save_cache step. Learn more in  the caching documentation.  KeyRequiredTypeDescriptionkeyY (1)StringSingle cache key to restorekeysY (1)ListList of cache keys to lookup for a cache to restore. Only first existing key will be restored.nameNStringTitle of the step to be shown in the CircleCI UI (default: "Restoring Cache")  (1) at least one attribute has to be present. If key and keys are both given, key will be checked first, and then keys.   A key is searched against existing keys as a prefix.      When there are multiple matches, the most recent match will be used, even if there is a more precise match.        For example:    steps:
  - save_cache:
      key: v1-myapp-cache
      paths:
        - ~/d1

  - save_cache:
      key: v1-myapp-cache-new
      paths:
        - ~/d2

  - run: rm -f ~/d1 ~/d2

  - restore_cache:
      key: v1-myapp-cache    In this case cache v1-myapp-cache-new will be restored because it’s the most recent match with v1-myapp-cache prefix even if the first key (v1-myapp-cache) has exact match.   For more information on key formatting, see the key section of  save_cache step.   When CircleCI encounters a list of keys, the cache will be restored from the first key matching an existing cache. We recommend you use a more specific key first (for example, cache for exact version of package-lock.json) and more generic keys after (for example, any cache for this project). If no key has a cache that exists, the step will be skipped with a warning.   A path is not required here because the cache will be restored to the location from which it was originally saved.   Example:    - restore_cache:
    keys:
      - v1-myapp-{{ arch }}-{{ checksum "project.clj" }}
      # if cache for exact version of `project.clj` is not present then load any most recent one
      - v1-myapp-

# ... Steps building and testing your application ...

# cache will be saved only once for each version of `project.clj`
- save_cache:
    key: v1-myapp-{{ arch }}-{{ checksum "project.clj" }}
    paths:
      - /foo      deploy - DEPRECATED  See  run for current processes. If you have parallelism > 1 in your job, see the  Migrate from deploy to run guide.     store_artifacts  Step to store artifacts (for example logs, binaries, etc) to be available in the web app or through the API. See the  Uploading Artifacts page for more information.  KeyRequiredTypeDescriptionpathYStringDirectory in the primary container to save as job artifactsdestinationNStringPrefix added to the artifact paths in the artifacts API (default: the directory of the file specified in path)  There can be multiple store_artifacts steps in a job. Using a unique prefix for each step prevents them from overwriting files.   Artifact storage retention can be customized on the  CircleCI web app by navigating to Plan  Usage Controls.   Example:    - run:
    name: Build the Jekyll site
    command: bundle exec jekyll build --source jekyll --destination jekyll/_site/docs/
- store_artifacts:
    path: jekyll/_site/docs/
    destination: circleci-docs      store_test_results  Special step used to upload and store test results for a build. Test results are visible on the CircleCI web application under each build’s Test Summary section. Storing test results is useful for timing analysis of your test suites. For more information on storing test results, see the  Collecting Test Data page.   You can also store test results as build artifacts. For steps, refer to  the store_artifacts step section.  KeyRequiredTypeDescriptionpathYStringPath (absolute, or relative to your working_directory) to directory containing JUnit XML test metadata files, or to a single test file.  Example:   Directory structure:    test-results
├── jest
│   └── results.xml
├── mocha
│   └── results.xml
└── rspec
    └── results.xml    config.yml syntax:    - store_test_results:
    path: test-results      persist_to_workspace  Special step used to persist a temporary file to be used by another job in the workflow. For more information on using workspaces, see the  Using Workspaces to Share Data Between Jobs page.   persist_to_workspace adopts the storage settings from the storage customization controls on the CircleCI web app. If no custom setting is provided, persist_to_workspace defaults to 15 days.   Workspace storage retention can be customized on the  CircleCI web app by navigating to Plan  Usage Controls.  KeyRequiredTypeDescriptionrootYStringEither an absolute path or a path relative to working_directorypathsYListGlob identifying file(s), or a non-glob path to a directory to add to the shared workspace. Interpreted as relative to the workspace root. Must not be the workspace root itself.  The root key is a directory on the container which is taken to be the root directory of the workspace. The path values are all relative to the root.   Example for root Key   For example, the following step syntax persists the specified paths from /tmp/dir into the workspace, relative to the directory /tmp/dir.    - persist_to_workspace:
    root: /tmp/dir
    paths:
      - foo/bar
      - baz    After this step completes, the following directories are added to the workspace:    /tmp/dir/foo/bar
/tmp/dir/baz    Example for paths Key    - persist_to_workspace:
    root: /tmp/workspace
    paths:
      - target/application.jar
      - build/*    The paths list uses Glob from Go, and the pattern matches  filepath.Match.    pattern:
        { term }
term:
        '*' matches any sequence of non-Separator characters
        '?' matches any single non-Separator character
        '[' [ '^' ] { character-range }
        ']' character class (must be non-empty)
        c matches character c (c != '*', '?', '\\', '[')
        '\\' c matches character c
character-range:
        c matches character c (c != '\\', '-', ']')
        '\\' c matches character c
        lo '-' hi matches character c for lo <= c <= hi    The Go documentation states that the pattern may describe hierarchical names such as /usr/*/bin/ed (assuming the Separator is '/').      Everything must be relative to the work space root directory.          attach_workspace  Special step used to attach the workflow’s workspace to the current container. The full contents of the workspace are downloaded and copied into the directory the workspace is being attached at. For more information on using workspaces, see the  Using workspaces page.  KeyRequiredTypeDescriptionatYStringDirectory to attach the workspace to.  Workspace storage retention can be customized on the  CircleCI web app by navigating to Plan  Usage Controls.   Example:    - attach_workspace:
    at: /tmp/workspace       The lifetime of artifacts, workspaces, and caches can be customized on the  CircleCI web app by navigating to Plan  Usage Controls. Here you can control the storage retention periods for these objects. If no storage period is set, the default storage retention period of artifacts is 30 days, while the default storage retention period of workspaces and caches is 15 days.          add_ssh_keys  Special step that adds SSH keys from a project’s settings to a container. Also configures SSH to use these keys. For more information on SSH keys see the  Create additional GitHub SSH keys page.      Using server? only MD5 fingerprints are supported. In CircleCI in Project Settings  SSH keys  Additional SSH keys the MD5 fingerprint will be visible. SHA256 support is planned for an upcoming server release.       KeyRequiredTypeDescriptionfingerprintsNListList of fingerprints corresponding to the keys to be added (default: all keys added)   steps:
  - add_ssh_keys:
      fingerprints:
        - "b7:35:a6:4e:9b:0d:6d:d4:78:1e:9a:97:2a:66:6b:be"
        - "SHA256:NPj4IcXxqQEKGXOghi/QbG2sohoNfvZ30JwCcdSSNM0"       Even though CircleCI uses ssh-agent to sign all added SSH keys, you must use the add_ssh_keys key to actually add keys to a container.          Using pipeline values  Pipeline values are available to all pipeline configurations and can be used without previous declaration. For a list of pipeline values, see the  Pipeline values and parameters page.   Example:    version: 2.1
jobs:
  build:
    docker:
      - image: cimg/node:20.18.1
    environment:
      IMAGETAG: latest
    working_directory: ~/main
    steps:
      - run: echo "This is pipeline ID << pipeline.id >>"       circleci_ip_ranges     A paid account on a  Performance or Scale Plan is required to access IP ranges.        Enables jobs to go through a set of well-defined IP address ranges. See  IP ranges for details.   Example:    version: 2.1

jobs:
  build:
    circleci_ip_ranges: true # opts the job into the IP ranges feature
    docker:
      - image: curlimages/curl
    steps:
      - run: echo “Hello World”
workflows:
  build-workflow:
    jobs:
      - build         workflows   Used for orchestrating all jobs. Each workflow consists of the workflow name as a key and a map as a value. A name should be unique within the current config.yml. The top-level keys for the Workflows configuration are version and jobs. For more information, see the  Using Workflows to Orchestrate Jobs page.    version     The workflows version key is not required for version: 2.1 configuration        The Workflows version field is used to issue warnings for deprecation or breaking changes.  KeyRequiredTypeDescriptionversionY if config version is 2StringShould currently be 2    <workflow_name>  A unique name for your workflow.    triggers  Specifies which triggers will cause this workflow to be executed. Default behavior is to trigger the workflow when pushing to a branch.  KeyRequiredTypeDescriptiontriggersNArrayShould currently be schedule.   workflows:
   nightly:
     triggers:
       - schedule:
           cron: "0 0 * * *"
           filters:
             branches:
               only:
                 - main
                 - beta
     jobs:
       - test     schedule     Scheduled workflows are not available for projects integrated through the GitHub App, GitLab or Bitbucket Data Center.           The scheduled workflows feature is set to be deprecated. Using scheduled pipelines rather than scheduled workflows offers several benefits. Visit the scheduled pipelines  migration guide to find out how to migrate existing scheduled workflows to scheduled pipelines. If you would like to set up scheduled pipelines from scratch, visit the  Scheduled pipelines page.        A workflow may have a schedule indicating it runs at a certain time, for example a nightly build that runs every day at 12am UTC:    workflows:
   nightly:
     triggers:
       - schedule:
           cron: "0 0 * * *"
           filters:
             branches:
               only:
                 - main
                 - beta
     jobs:
       - test     cron  The cron key is defined using POSIX crontab syntax.  KeyRequiredTypeDescriptioncronYStringSee the  crontab man page.   workflows:
   nightly:
     triggers:
       - schedule:
           cron: "0 0 * * *"
           filters:
             branches:
               only:
                 - main
                 - beta
     jobs:
       - test      filters  Trigger filters can have the key branches.  KeyRequiredTypeDescriptionfiltersYMapA map defining rules for execution on specific branches   workflows:
   nightly:
     triggers:
       - schedule:
           cron: "0 0 * * *"
           filters:
             branches:
               only:
                 - main
                 - beta
     jobs:
       - test      branches  The branches key controls whether the current branch should have a schedule trigger created for it, where current branch is the branch containing the config.yml file with the trigger stanza. That is, a push on the main branch will only schedule a  workflow for the main branch.   Branches can have the keys only and ignore which each map to a single string naming a branch. You may also use regular expressions to match against branches by enclosing them with `/’s, or map to a list of such strings. Regular expressions must match the entire string.     Any branches that match only will run the job.   Any branches that match ignore will not run the job.   If neither only nor ignore are specified then all branches will run the job. If both only and ignore are specified, the only is used and ignore will have no effect.      workflows:
  commit:
    jobs:
      - test
      - deploy
  nightly:
    triggers:
      - schedule:
          cron: "0 0 * * *"
          filters:
            branches:
              only:
                - main
                - /^release\/.*/
    jobs:
      - coverage   KeyRequiredTypeDescriptionbranchesYMapA map defining rules for execution on specific branchesonly 1NString, or List of StringsEither a single branch specifier, or a list of branch specifiersignore 1NString, or List of StringsEither a single branch specifier, or a list of branch specifiers  1: One of either only or ignore branch filters must be specified. If both are present, only is used.       Using when in workflows     Using when or unless under workflows is supported in version: 2.1 configuration. Workflows are always run unless there is a when or unless filter that prevents the workflow from being run. If you want a workflow to run in every pipeline, do not add a when or unless filter.        You may use a when clause (the inverse clause unless is also supported) under a workflow declaration with a  logic statement to determine whether or not to run that workflow.   The example configuration below uses a pipeline parameter, run_integration_tests to drive the integration_tests workflow.    version: 2.1

workflows:
  integration_tests:
    when: pipeline.git.branch == "main"
    jobs:
      - mytestjob

jobs:
...    This example prevents the workflow integration_tests from running unless the pipeline is triggered on the main branch.   Refer to the  Workflows for more examples and conceptual information.     jobs  A job can have the keys requires, name, context, type, and filters.  KeyRequiredTypeDescriptionjobsYListA list of jobs to run with their dependencies   <job_name>  A job name that exists in your config.yml.    serial-group  The serial-group key is used to add a property to a job to allow a group of jobs to run in series, rather than concurrently, across an organization. Serial groups control the orchestration of jobs across an organization, not just within projects and pipelines.   The serial-group key is configurable per job. It is not possible to configure the key for a group of jobs at this time.   The value of the serial-group key is a string that is used to group jobs together to run one after another. The key must meet the following requirements:     Must be less than or equal to (≤) 512 characters, once compiled.   Must not be blank.   Must consist of alphanumeric characters plus, ., -, _, /.     Note the following features of serial groups:     You can use pipeline values and parameters in the serial-group key.   Serial groups will wait for five hours. After this jobs waiting in the group will be cancelled. This does not affect the standard limits that apply to a  job’s runtime.         Pipeline order protection in serial groups   Jobs in a serial group follow an order protection mechanism, as follows:     Jobs start in the order they join the queue, but are accepted based on pipeline number.   If a group is waiting/running and another job in the same project attempts to join the queue with a lower pipeline number, the job is skipped.   This immediate skip process exists to maintain order integrity, which is a safety process to avoid unexpected work in a build, for example, a deployment job running a previous version unexpectedly.     If there are no serial groups waiting/running, a pipeline with a lower number can start, such as restoring back to a previous pipeline via a rerun workflow.        KeyRequiredTypeDescriptionserial-groupNStringA string that is used across an org to group jobs together to run one after another. Can include pipeline values and parameters. Use this same serial group across multiple pipelines to control the orchestration of jobs across an organization.  Example:    # Creating multiple pipelines at the same time with the below config will results in
# all pipelines running test and build but only a single pipeline will run deploy at a time.

workflows:
  main-workflow:
    jobs:
      - test
      - build
      - deploy:
          serial-group: << pipeline.project.slug >>/deploy-group
          requires:
            - test
            - build    For more information, see the  Controlling serial execution across your organization page. '''    requires  Jobs are run concurrently by default, so you must explicitly require any dependencies by their job name if you need some jobs to run sequentially.  KeyRequiredTypeDescriptionrequiresNList A list of jobs that must succeed or attain a specified status for the job to start. Note: When jobs in the current workflow that are listed as dependencies are not executed (due to a filter function for example), their requirement as a dependency for other jobs will be ignored by the requires option. However, if all dependencies of a job are filtered, then that job will not be executed either.   Possible types of requires items:     Job name (a required job that must succeed for the job to start)   Map of job name to status (a required job that must attain the specified status for the job to start)   Map of job name to a list of statuses (a required job that must attain one of the specified status for the job to start)     The possible status values are: success, failed and canceled.    workflows:
  my-workflow:
    jobs:
      - build
      - test:
          requires:
            - build
      - deploy:
          requires:
            - build
            - test
      - notify-build-canceled:
          requires:
            - build: canceled
      - cleanup:
          requires:
            - deploy:
              - failed
              - canceled      name  The name key can be used to invoke reusable jobs across any number of workflows. Using the name key ensures numbers are not appended to your job name (for example, sayhello-1 , sayhello-2, etc.). The name you assign to the name key needs to be unique, otherwise the numbers will still be appended to the job name.  KeyRequiredTypeDescriptionnameNStringA replacement for the job name. Useful when calling a job multiple times. If you want to invoke the same job multiple times, and a job requires one of the duplicate jobs, this key is required. (2.1 only)    context  Jobs may be configured to use global environment variables set for an organization, see the  Contexts document for adding a context in the application settings.  KeyRequiredTypeDescriptioncontextNString/ListThe name of the context(s). The initial default name is org-global. Each context name must be unique. If using CircleCI server, only a single context per workflow is supported. Note: A maximum of 100 unique contexts across all workflows is allowed.    type  A job may have a type of approval indicating it must be manually approved before downstream jobs may proceed. For more information see the  Using workflows to orchestrate jobs page.   Jobs run in the dependency order until the workflow processes a job with the type: approval key followed by a job on which it depends, for example:    workflows:
  my-workflow:
    jobs:
      - build
      - test:
          requires:
            - build
      - hold:
          type: approval
          requires:
            - test
      - deploy:
          requires:
            - hold    An approval job can have any name. In the example above the approval job is named hold. The name you choose for an approval job should not be used to define a job in the main configuration. An approval job only exists as a workflow orchestration devise.     filters  Filter job execution within a workflow based on the following:     Branch   Tag   Expression-based condition     Job filters can have the keys branches or tags.      Workflows will ignore job-level branching. If you use job-level branching and later add workflows, you must remove the branching at the job level and instead declare it in the workflows section of your config.yml.       KeyRequiredTypeDescriptionfiltersNMapA map or string to define rules for job execution. Branch and tag filters require a map. Expression-based filters require a string.  The following is an example of how the CircleCI documentation project uses a regular expression to filter running a job in a workflow only on a specific branch:    # ...
workflows:
  build-deploy:
    jobs:
      - js_build
      - build_server_pdfs: # << the job to conditionally run based on the filter-by-branch-name.
          filters:
            branches:
              only: /server\/.*/ # the job build_server_pdfs will only run when the branch being built starts with server/    You can read more about using regular expressions in your config in the  Using workflows to schedule jobs page.     Expression-based job filters  Expression-based job filters allow you to conditionally run jobs based on the following:      Pipeline values    Pipeline parameters     An expression-based job filter is a rule that is evaluated against pipeline values and parameters to decide whether a job should run.   Using expression-based job filters is one way to optimize your pipelines. Optimizations include the following:     Lower costs.   Decrease time to feedback.   Run specific jobs based on the context of the source of change.      workflows:
  deploy:
    jobs:
      - init-service
      - test-service
      - build-service-image:
          requires:
            - init-service
      - dry-run-service:
          requires:
            - init-service
          filters: pipeline.git.branch != "main" and pipeline.git.branch != "canary"
      - publish-service:
          requires:
            - build-service-image
            - test-service
          filters: pipeline.git.branch == "main" or pipeline.git.tag starts-with "release"
      - deploy-service:
          context:
            - org-global
          requires:
            - publish-service
          filters: pipeline.git.branch == "main" and pipeline.parameters.my-custom-param starts-with "DEPLOY:"    Examples   Only run the job on the project’s main branch:    filters: pipeline.git.branch == "main"    Only run the job on the project’s main branch, or branches starting with integration-test:    filters: pipeline.git.branch == "main" or pipeline.git.branch starts-with "integration-test"    Only run the job on the main branch, and disallow use with pipelines  triggered with unversioned configuration:    filters: pipeline.git.branch == "main" and not (pipeline.trigger_source starts-with "api")    Use pipeline parameters and the pipeline value pipeline.git.branch to run a job only on specific branches or when triggered via the API with a pipeline parameter set to true:    version: 2.1

parameters:
  run-storybook-tests:
    type: boolean
    default: false

...
# jobs configuration ommitted for brevity

workflows:
  build:
    jobs:
      - setup
      - storybook-tests:
          requires:
            - setup
          filters: |
            pipeline.parameters.run-storybook-tests
            or pipeline.git.branch == "dry-run-deploy"
            or pipeline.git.branch starts-with "deploy"    You can use the API to trigger a pipeline with a pipeline parameter set to true:      Using server? If you are using CircleCI server, replace https://circleci.com with your server hostname when interacting with the CircleCI API.         curl -X POST https://circleci.com/api/v2/project/circleci/<org-id>/<project-id>/pipeline/run \
  --header "Circle-Token: $CIRCLE_TOKEN" \
  --header "content-type: application/json" \
  --data {
  "definition_id": "<pipeline-definition-id>",
  "config": {"branch": "<your-branch-name>"},
  "checkout": {"branch": "<your-branch-name>"},
  "parameters": {"run-storybook-tests": "true"}
  }    Operators   The operators you can use for expression-based job filters are described in the following table. You can also group sub-expressions with parentheses (, ). as in the examples above.  Operator typeOperatorsDescriptionLogicaland, orThese are short-circuiting boolean operators.Equality==, !=String, numeric, and boolean equality. If the operands are of different types then == will evaluate false, and != will evaluate true.Equalitystarts-withString prefix equality, "hello world" starts-with "hello" evaluates as true. It is an error to use a non-string type as an operand.Numeric comparison>=, >, ⇐, <Numeric comparisons. It is an error to use a non-numeric type as an operand.Negationnot Boolean negation.   Note that not has very high precedence and so binds very tightly. Use sub-expressions to apply not to more complex expressions. For example, with foo being true and bar being false:     not foo and bar evaluates to false   not (foo and bar) evaluates to true       branches  The branches filter can have the keys only and ignore, which map to a single string naming a branch. You may also use regular expressions to match against branches by enclosing them with slashes, or map to a list of such strings. Regular expressions must match the entire string.     Any branches that match only will run the job.   Any branches that match ignore will not run the job.   If neither only nor ignore are specified then all branches will run the job.   If both only and ignore are specified the only is considered before ignore.    KeyRequiredTypeDescriptionbranchesNMapA map defining rules for execution on specific branches.onlyNString, or list of stringsEither a single branch specifier, or a list of branch specifiers.ignoreNString, or list of stringsEither a single branch specifier, or a list of branch specifiers.   workflows:
  dev_stage_pre-prod:
    jobs:
      - test_dev:
          filters:  # using regex filters requires the entire branch to match
            branches:
              only:  # only branches matching the below regex filters will run
                - dev
                - /user-.*/
      - test_stage:
          filters:
            branches:
              only: stage
      - test_pre-prod:
          filters:
            branches:
              only: /pre-prod(?:-.+)?$/      tags  CircleCI does not run workflows for tags unless you explicitly specify tag filters. If a job requires any other jobs (directly or indirectly), you must specify tag filters for those jobs.   Tags can have the keys only and ignore. You may also use regular expressions to match against tags by enclosing them with slashes, or map to a list of such strings. Regular expressions must match the entire string. Both lightweight and annotated tags are supported.     Any tags that match only will run the job.   Any tags that match ignore will not run the job.   If neither only nor ignore are specified then the job is skipped for all tags.   If both only and ignore are specified the only is considered before ignore.    KeyRequiredTypeDescriptiontagsNMapA map defining rules for execution on specific tagsonlyNString, or List of StringsEither a single tag specifier, or a list of tag specifiersignoreNString, or List of StringsEither a single tag specifier, or a list of tag specifiers  For more information, see the  Executing workflows for a git tag section of the Workflows page.    workflows:
  untagged-build:
    jobs:
      - build
  tagged-build:
    jobs:
      - build:
          filters:
            tags:
              only: /^v.*/      matrix     The matrix key is supported in version: 2.1 configuration        The matrix stanza allows you to run a parameterized job multiple times with different arguments. For more information see the how-to guide on  Using Matrix Jobs. In order to use the matrix stanza, you must use parameterized jobs.  KeyRequiredTypeDescriptionparametersYMapA map of parameter names to every value the job should be called withexcludeNListA list of argument maps that should be excluded from the matrixaliasNStringAn alias for the matrix, usable from another job’s requires stanza. Defaults to the name of the job being executed  Example:   The following is a basic example of using matrix jobs.    workflows:
  workflow:
    jobs:
      - build:
          matrix:
            parameters:
              version: ["0.1", "0.2", "0.3"]
              platform: ["macos", "windows", "linux"]    This expands to 9 different build jobs, and could be equivalently written as:    workflows:
  workflow:
    jobs:
      - build:
          name: build-macos-0.1
          version: "0.1"
          platform: macos
      - build:
          name: build-macos-0.2
          version: "0.2"
          platform: macos
      - build:
          name: build-macos-0.3
          version: "0.3"
          platform: macos
      - build:
          name: build-windows-0.1
          version: "0.1"
          platform: windows
      - ...      Excluding sets of parameters from a matrix  Sometimes you may wish to run a job with every combination of arguments except some value or values. You can use an exclude stanza to achieve this:    workflows:
  workflow:
    jobs:
      - build:
          matrix:
            parameters:
              a: [1, 2, 3]
              b: [4, 5, 6]
            exclude:
              - a: 3
                b: 5    The matrix above would expand into 8 jobs: every combination of the parameters a and b, excluding {a: 3, b: 5}     Dependencies and matrix jobs  To require an entire matrix (every job within the matrix), use its alias. The alias defaults to the name of the job being invoked.    workflows:
  workflow:
    jobs:
      - deploy:
          matrix:
            parameters:
              version: ["0.1", "0.2"]
      - another-job:
          requires:
            - deploy    This means that another-job will require both deploy jobs in the matrix to finish before it runs.   Matrix jobs expose their parameter values via << matrix.* >> which can be used to generate more complex workflows. For example, here is a deploy matrix where each job waits for its respective build job in another matrix.    workflows:
  workflow:
    jobs:
      - build:
          name: build-v<< matrix.version >>
          matrix:
            parameters:
              version: ["0.1", "0.2"]
      - deploy:
          name: deploy-v<< matrix.version >>
          matrix:
            parameters:
              version: ["0.1", "0.2"]
          requires:
            - build-v<< matrix.version >>    This workflow will expand to:    workflows:
  workflow:
    jobs:
      - build:
          name: build-v0.1
          version: "0.1"
      - build:
          name: build-v0.2
          version: "0.2"
      - deploy:
          name: deploy-v0.1
          version: "0.1"
          requires:
            - build-v0.1
      - deploy:
          name: deploy-v0.2
          version: "0.2"
          requires:
            - build-v0.2      pre-steps and post-steps     Pre-steps and post-steps are supported in version: 2.1 configuration        Every job invocation in a workflow may optionally accept two special arguments: pre-steps and post-steps.   Steps under pre-steps are executed before any of the other steps in the job. The steps under post-steps are executed after all of the other steps.   Pre and post steps allow you to execute steps in a given job without modifying the job. Pre and post steps are useful, for example, to run custom setup steps before job execution.    version: 2.1

jobs:
  bar:
    machine:
      image: ubuntu-2004:2024.05.1
    steps:
      - checkout
      - run:
          command: echo "building"
      - run:
          command: echo "testing"

workflows:
  build:
    jobs:
      - bar:
          pre-steps: # steps to run before steps defined in the job bar
            - run:
                command: echo "install custom dependency"
          post-steps: # steps to run after steps defined in the job bar
            - run:
                command: echo "upload artifact to s3"           Logic statements   Certain dynamic configuration features accept logic statements as arguments. Logic statements are evaluated to boolean values at configuration compilation time, that is, before the workflow is run. The group of logic statements includes:  TypeArgumentstrue ifExampleYAML literalNoneis truthytrue/42/"a string"YAML aliasNoneresolves to a truthy value*my-alias Pipeline ValueNoneresolves to a truthy value<< pipeline.git.branch >> Pipeline ParameterNoneresolves to a truthy value<< pipeline.parameters.my-parameter >>andN logic statementsall arguments are truthyand: [ true, true, false ]orN logic statementsany argument is truthyor: [ false, true, false ]not1 logic statementthe argument is not truthynot: trueequalN valuesall arguments evaluate to equal valuesequal: [ 42, << pipeline.number >>]matchespattern and valuevalue matches the patternmatches: { pattern: "^feature-.$", value: << pipeline.git.branch >> }+  The following logic values are considered falsy:     false   null   0   NaN   empty strings ("")   statements with no arguments     All other values are truthy. Also note that using logic with an empty list will cause a validation error.   Logic statements always evaluate to a boolean value at the top level, and coerce as necessary. They can be nested in an arbitrary fashion, according to their argument specifications, and to a maximum depth of 100 levels.   matches uses  Java regular expressions for its pattern. A full match pattern must be provided, prefix matching is not an option. Though, it is recommended to enclose a pattern in ^ and $ to avoid accidental partial matches.      When using logic statements at the workflow level, do not include the condition: key (the condition key is only needed for job level logic statements).         workflows:
  my-workflow:
    when:
      or:
        - equal: [ main, << pipeline.git.branch >> ]
        - equal: [ staging, << pipeline.git.branch >> ]    Logic statement examples  You can find usage examples on the  "Orchestration cookbook" page.      Example full configuration      Using Docker? Authenticating Docker pulls from image registries is recommended when using the Docker execution environment. Authenticated pulls allow access to private Docker images, and may also grant higher rate limits, depending on your registry provider. For further information see  Using Docker authenticated pulls.         version: 2.1
jobs:
  build:
    docker:
      - image: ubuntu:23.04

      - image: mongo:6.0.14
        command: [mongod, --smallfiles]

      - image: postgres:14.12
        # some containers require setting environment variables
        environment:
          POSTGRES_USER: user

      - image: redis@sha256:54057dd7e125ca41afe526a877e8bd35ec2cdd33b9217e022ed37bdcf7d09673

      - image: rabbitmq:3.12.12

    environment:
      TEST_REPORTS: /tmp/test-reports

    working_directory: ~/my-project

    steps:
      - checkout

      - run:
          command: echo 127.0.0.1 devhost | sudo tee -a /etc/hosts

      # Create Postgres users and database
      # Note the YAML heredoc '|' for nicer formatting
      - run: |
          sudo -u root createuser -h localhost --superuser ubuntu &&
          sudo createdb -h localhost test_db

      - restore_cache:
          keys:
            - v1-my-project-{{ checksum "project.clj" }}
            - v1-my-project-

      - run:
          environment:
            SSH_TARGET: "localhost"
            TEST_ENV: "linux"
          command: |
            set -xu
            mkdir -p ${TEST_REPORTS}
            run-tests.sh
            cp out/tests/*.xml ${TEST_REPORTS}

      - run: |
          set -xu
          mkdir -p /tmp/artifacts
          create_jars.sh << pipeline.number >>
          cp *.jar /tmp/artifacts

      - save_cache:
          key: v1-my-project-{{ checksum "project.clj" }}
          paths:
            - ~/.m2

      # Save artifacts
      - store_artifacts:
          path: /tmp/artifacts
          destination: build

      # Upload test results
      - store_test_results:
          path: /tmp/test-reports

  deploy-stage:
    docker:
      - image: ubuntu:23.04
    working_directory: /tmp/my-project
    steps:
      - run:
          name: Deploy if tests pass and branch is Staging
          command: ansible-playbook site.yml -i staging

  deploy-prod:
    docker:
      - image: ubuntu:23.04
    working_directory: /tmp/my-project
    steps:
      - run:
          name: Deploy if tests pass and branch is Main
          command: ansible-playbook site.yml -i production

workflows:
  build-deploy:
    jobs:
      - build:
          filters:
            branches:
              ignore:
                - develop
                - /feature-.*/
      - deploy-stage:
          requires:
            - build
          filters:
            branches:
              only: staging
      - deploy-prod:
          requires:
            - build
          filters:
            branches:
              only: main    Suggest an edit to this pageMake a contribution Learn how to contributeStill need help? Ask the CircleCI community Join the research community Visit our Support site DocsTerms of UsePrivacy PolicyCookie PolicySecurity© 2025 Circle Internet Services, Inc., All Rights Reserved.\n\nThe orbs key is supported in version: 2.1 configuration  version: 2.1

orbs:
  node: circleci/node@x.y

jobs:
  install-node-example:
    docker:
      - image: cimg/base:stable
    steps:
      - checkout
      - node/install:
          install-yarn: true
          node-version: '16.13'
      - run: node --version
workflows:
  test_my_app:
    jobs:
      - install-node-example  The commands key is supported in version: 2.1 configuration  commands:
  sayhello:
    description: "A very simple command for demonstration purposes"
    parameters:
      to:
        type: string
        default: "Hello World"
    steps:
      - run: echo << parameters.to >>  The pipeline parameters key is supported in version: 2.1 configuration  The executors key is supported in version: 2.1 configuration  version: 2.1
executors:
  my-executor:
    docker:
      - image: cimg/ruby:3.0.3-browsers

jobs:
  my-job:
    executor: my-executor
    steps:
      - run: echo "Hello executor!"  jobs:
  my-job:
    docker:
      - image: cimg/base:2024.12
    resource_class: xlarge
    steps:
      ... // other config  jobs:
  release-my-service:
    type: release
    plan_name: <my-service-release>  jobs:
  my-no-op-job:
    type: no-op  workflows:
  my-workflow:
    jobs:
      - build
      - test:
          requires:
            - build
      - hold:
          type: approval
          requires:
            - test
      - deploy:
          requires:
            - hold  jobs:
  build:
    docker:
      - image: cimg/base:2024.12
    environment:
      FOO: bar
    parallelism: 3
    resource_class: large
    working_directory: ~/my-app
    steps:
      - run: go list ./... | circleci tests run --command "xargs gotestsum --junitfile junit.xml --format testname --" --split-by=timings --timings-type=name  jobs:
  build:
    docker:
      - image: buildpack-deps:trusty # primary container
        auth:
          username: mydockerhub-user
          password: $DOCKERHUB_PASSWORD  # context / project UI env-var reference
        environment:
          ENV: CI

      - image: mongo:2.6.8
        auth:
          username: mydockerhub-user
          password: $DOCKERHUB_PASSWORD  # context / project UI env-var reference
        command: [--smallfiles]

      - image: postgres:14.2
        auth:
          username: mydockerhub-user
          password: $DOCKERHUB_PASSWORD  # context / project UI env-var reference
        environment:
          POSTGRES_USER: user

      - image: redis@sha256:54057dd7e125ca41afe526a877e8bd35ec2cdd33b9217e022ed37bdcf7d09673
        auth:
          username: mydockerhub-user
          password: $DOCKERHUB_PASSWORD  # context / project UI env-var reference

      - image: acme-private/private-image:321
        auth:
          username: mydockerhub-user
          password: $DOCKERHUB_PASSWORD  # context / project UI env-var reference  jobs:
  job_name:
    docker:
      - image: <your-image-arn>
        aws_auth:
          oidc_role_arn: <your-iam-role-arn>  jobs:
  build:
    docker:
      - image: account-id.dkr.ecr.us-east-1.amazonaws.com/org/repo:0.1
        aws_auth:
          aws_access_key_id: AKIAQWERVA  # can specify string literal values
          aws_secret_access_key: $ECR_AWS_SECRET_ACCESS_KEY  # or project UI envar reference  CircleCI cloud The use of machine: true is deprecated. You must specify an image to use.    jobs:
  build: # name of your job
    machine: # executor type
      image: ubuntu-2004:current # recommended linux image

    steps:
      # Commands run in a Linux virtual machine environment    jobs:
  build: # name of your job
    machine: # executor type
      image: ubuntu-2004:current # recommended linux image

    steps:
      # Commands run in a Linux virtual machine environment    jobs:
  build: # name of your job
    machine: true # executor type
    steps:
      # Commands run in a Linux virtual machine environment    jobs:
  build: # name of your job
    machine: true # executor type
    steps:
      # Commands run in a Linux virtual machine environment  version: 2.1

jobs:
  build:
    machine:
      image: android:2024.11.1  version: 2.1

jobs:
  build:
    machine:
      image: windows-server-2019-cuda:current  jobs:
  build:
    macos:
      xcode: "14.2.0"  Java, Erlang and any other languages that introspect the /proc directory for information about CPU count may require additional configuration to prevent them from slowing down when using the CircleCI resource class feature. Programs with this issue may request 32 CPU cores and run slower than they would when requesting one core. Users of languages with this issue should pin their CPU count to their guaranteed CPU resources.  If you want to confirm how much memory you have been allocated, you can check the cgroup memory hierarchy limit with grep hierarchical_memory_limit /sys/fs/cgroup/memory/memory.stat.  jobs:
  job_name:
    machine: true
    resource_class: <my-namespace>/<my-runner>  jobs:
  build:
    docker:
      - image: cimg/base:2024.12
    resource_class: xlarge
    steps:
      ... // other config  For credit and access information, see the  Resource classes page. Resource class access is dependent on your  Plan.   Arm on Docker For credit and access information see the  Resource classes page. Resource class access is dependent on your  Plan   To find out which CircleCI Docker convenience images support Arm resource classes, you can refer to  Docker hub:     Select the image (for example, cimg/python).   Select the tags tab.   View what is supported under OS/ARCH for the latest tags. For example, cimg/python has linux/amd64 and linux/arm64, which means Arm is supported.       jobs:
  build:
    machine:
      image: ubuntu-2004:2024.01.2 # recommended linux image
    resource_class: large
    steps:
      ... // other config    jobs:
  build:
    machine:
      image: ubuntu-2004:2024.01.2 # recommended linux image
    resource_class: large
    steps:
      ... // other config    jobs:
  build:
    machine: true
    resource_class: large
    steps:
      ... // other config    jobs:
  build:
    machine: true
    resource_class: large
    steps:
      ... // other config   We have deprecated support for all Intel-based macOS resources.   The macos.x86.medium.gen2 resource class was deprecated on June 28, 2024.   See our  announcement for more details.   jobs:
  build:
    macos:
      xcode: "15.4.0"
    resource_class: m2pro.medium
    steps:
      ... // other config  Using server? Check with your systems administrator whether you have access to the Windows execution environment.    version: 2.1

jobs:
  build: # name of your job
    resource_class: 'windows.medium'
    machine:
      image: 'windows-server-2022-gui:current'
      shell: 'powershell.exe -ExecutionPolicy Bypass'
    steps:
      # Commands are run in a Windows virtual machine environment
      - checkout
      - run: Write-Host 'Hello, Windows'    version: 2.1

jobs:
  build: # name of your job
    resource_class: 'windows.medium'
    machine:
      image: 'windows-server-2022-gui:current'
      shell: 'powershell.exe -ExecutionPolicy Bypass'
    steps:
      # Commands are run in a Windows virtual machine environment
      - checkout
      - run: Write-Host 'Hello, Windows'    version: 2.1

jobs:
  build: # name of your job
    machine:
      image: windows-default
    steps:
      # Commands are run in a Windows virtual machine environment
      - checkout
      - run: Write-Host 'Hello, Windows'    version: 2.1

jobs:
  build: # name of your job
    machine:
      image: windows-default
    steps:
      # Commands are run in a Windows virtual machine environment
      - checkout
      - run: Write-Host 'Hello, Windows'  version: 2.1

jobs:
  build:
    machine:
      image: linux-cuda-12:default
    resource_class: gpu.nvidia.medium
    steps:
      - run: nvidia-smi
      - run: docker run --gpus all nvidia/cuda:9.0-base nvidia-smi  version: 2.1
orbs:
  win: circleci/windows@5.0.0

jobs:
  build:
    executor: win/server-2019-cuda
    steps:
      - checkout
      - run: '&"C:\Program Files\NVIDIA Corporation\NVSMI\nvidia-smi.exe"'  Using server? Check with your systems administrator whether you have access to the Arm execution environment.    jobs:
  my-job:
    machine:
      image: ubuntu-2004:2024.01.2
    resource_class: arm.medium
    steps:
      - run: uname -a
      - run: echo "Hello, Arm!"    jobs:
  my-job:
    machine:
      image: ubuntu-2004:2024.01.2
    resource_class: arm.medium
    steps:
      - run: uname -a
      - run: echo "Hello, Arm!"    jobs:
  my-job:
    machine:
      image: arm-default
    resource_class: arm.medium
    steps:
      - run: uname -a
      - run: echo "Hello, Arm!"    jobs:
  my-job:
    machine:
      image: arm-default
    resource_class: arm.medium
    steps:
      - run: uname -a
      - run: echo "Hello, Arm!"  jobs:
  build:
    working_directory: ~/canary-python
    environment:
      FOO: bar
    steps:
      - run:
          name: Running tests
          command: make test  jobs:
  build:
    steps:
      - run: make test  jobs:
  build:
    steps:
      - checkout  the run step replaces the deprecated deploy step. If your job has a parallelism of 1, the deprecated deploy step can be swapped out directly for the run step. If your job has parallelism > 1, see  Migrate from deploy to run.  - run:
    command: |
      echo Running test
      mkdir -p /tmp/test-results
      make test  - run:
    command: |
      echo Running test
      set +e
      mkdir -p /tmp/test-results
      make test

- run:
    shell: /bin/sh
    command: |
      echo Running test
      mkdir -p /tmp/test-results
      make test  - run: make test | tee test-output.log  If make test fails the rest of pipeline will be executed.  - run:
    name: Running X virtual framebuffer
    command: Xvfb :99 -screen 0 1280x1024x24
    background: true

- run: make test  - run: make test

# shorthanded command can also have multiple lines
- run: |
    mkdir -p /tmp/test-results
    make test  Some steps, such as store_artifacts and store_test_results will always run, even if a step has failed (returned a non-zero exit code) previously. The when attribute, store_artifacts and store_test_results are not run if the job has been killed by a cancel request or has reached the runtime timeout limit.  - run:
    name: Upload CodeCov.io Data
    command: bash <(curl -s https://codecov.io/bash) -F unittests
    when: always # Uploads code coverage results, pass or fail  - run: |
    if [ "$CIRCLE_BRANCH" = "develop" ]; then
        circleci-agent step halt
    fi  The when and unless steps are supported in version: 2.1 configuration  version: 2.1

jobs: # conditional steps may also be defined in `commands:`
  job_with_optional_custom_checkout:
    parameters:
      custom_checkout:
        type: string
        default: ""
    machine:
      image: ubuntu-2004:2024.11.1
    steps:
      - when:
          condition: <<parameters.custom_checkout>>
          steps:
            - run: echo "my custom checkout"
      - unless:
          condition: <<parameters.custom_checkout>>
          steps:
            - checkout
workflows:
  build-test-deploy:
    jobs:
      - job_with_optional_custom_checkout:
          custom_checkout: "any non-empty string is truthy"
      - job_with_optional_custom_checkout   Blobless clones   A "blobless" strategy is being rolled out to help improve the performance of code checkouts from Git source code hosts.   Blobless clones reduce the amount of data fetched from the remote, by asking the remote to filter out objects that are not attached to the current commit.   While this improves performance in most cases, if a downstream step requires those objects to exist for scanning or comparisons, it can cause failures. To work around these potential problems, a fetch directly after a checkout will ensure the required data is available:    - checkout
- run: git fetch    - checkout
- run: git fetch  - checkout  - checkout
- run: git submodule sync
- run: git submodule update --init  The checkout step will configure Git to skip automatic garbage collection. If you are caching your .git directory with  restore_cache and would like to use garbage collection to reduce its size, you may wish to use a  run step with command git gc before doing so.  jobs:
  build:
    docker:
      - image: cimg/base:2024.06
    steps:
      # ... steps for building/testing app ...
      - setup_remote_docker:
          version: default     setup_remote_docker is not compatible with the machine executor. See  Docker Layer Caching in Machine Executor for information on how to enable DLC with the machine executor.   The version key is not currently supported on CircleCI server. Contact your system administrator for information about the Docker version installed in your remote Docker environment. If you are on server 4.x, you can find the default AWS AMI  here.     If the cache for the given key already exists it will not be modified, and job execution will proceed to the next step.  Given the immutability of caches, it might be helpful to start all your cache keys with a version prefix v1-.... That way you will be able to regenerate all your caches just by incrementing the version in this prefix.  - save_cache:
    key: v1-myapp-{{ arch }}-{{ checksum "project.clj" }}
    paths:
      - /home/ubuntu/.m2  - save_cache:
    key: v1-{{ checksum "yarn.lock" }}
    paths:
      - node_modules/workspace-a
      - node_modules/workspace-c     Wildcards are not currently supported in save_cache paths. Visit the  Ideas board and vote for this feature if it would be useful for you or your organization.   In some instances, a workaround for this is to save a particular workspace to cache:     When there are multiple matches, the most recent match will be used, even if there is a more precise match.  steps:
  - save_cache:
      key: v1-myapp-cache
      paths:
        - ~/d1

  - save_cache:
      key: v1-myapp-cache-new
      paths:
        - ~/d2

  - run: rm -f ~/d1 ~/d2

  - restore_cache:
      key: v1-myapp-cache  - restore_cache:
    keys:
      - v1-myapp-{{ arch }}-{{ checksum "project.clj" }}
      # if cache for exact version of `project.clj` is not present then load any most recent one
      - v1-myapp-

# ... Steps building and testing your application ...

# cache will be saved only once for each version of `project.clj`
- save_cache:
    key: v1-myapp-{{ arch }}-{{ checksum "project.clj" }}
    paths:
      - /foo  - run:
    name: Build the Jekyll site
    command: bundle exec jekyll build --source jekyll --destination jekyll/_site/docs/
- store_artifacts:
    path: jekyll/_site/docs/
    destination: circleci-docs  test-results
├── jest
│   └── results.xml
├── mocha
│   └── results.xml
└── rspec
    └── results.xml  - store_test_results:
    path: test-results  - persist_to_workspace:
    root: /tmp/dir
    paths:
      - foo/bar
      - baz  /tmp/dir/foo/bar
/tmp/dir/baz  - persist_to_workspace:
    root: /tmp/workspace
    paths:
      - target/application.jar
      - build/*  pattern:
        { term }
term:
        '*' matches any sequence of non-Separator characters
        '?' matches any single non-Separator character
        '[' [ '^' ] { character-range }
        ']' character class (must be non-empty)
        c matches character c (c != '*', '?', '\\', '[')
        '\\' c matches character c
character-range:
        c matches character c (c != '\\', '-', ']')
        '\\' c matches character c
        lo '-' hi matches character c for lo <= c <= hi  Everything must be relative to the work space root directory.  - attach_workspace:
    at: /tmp/workspace  The lifetime of artifacts, workspaces, and caches can be customized on the  CircleCI web app by navigating to Plan  Usage Controls. Here you can control the storage retention periods for these objects. If no storage period is set, the default storage retention period of artifacts is 30 days, while the default storage retention period of workspaces and caches is 15 days.  Using server? only MD5 fingerprints are supported. In CircleCI in Project Settings  SSH keys  Additional SSH keys the MD5 fingerprint will be visible. SHA256 support is planned for an upcoming server release.  steps:
  - add_ssh_keys:
      fingerprints:
        - "b7:35:a6:4e:9b:0d:6d:d4:78:1e:9a:97:2a:66:6b:be"
        - "SHA256:NPj4IcXxqQEKGXOghi/QbG2sohoNfvZ30JwCcdSSNM0"  Even though CircleCI uses ssh-agent to sign all added SSH keys, you must use the add_ssh_keys key to actually add keys to a container.  version: 2.1
jobs:
  build:
    docker:
      - image: cimg/node:20.18.1
    environment:
      IMAGETAG: latest
    working_directory: ~/main
    steps:
      - run: echo "This is pipeline ID << pipeline.id >>"  A paid account on a  Performance or Scale Plan is required to access IP ranges.  version: 2.1

jobs:
  build:
    circleci_ip_ranges: true # opts the job into the IP ranges feature
    docker:
      - image: curlimages/curl
    steps:
      - run: echo “Hello World”
workflows:
  build-workflow:
    jobs:
      - build  The workflows version key is not required for version: 2.1 configuration  workflows:
   nightly:
     triggers:
       - schedule:
           cron: "0 0 * * *"
           filters:
             branches:
               only:
                 - main
                 - beta
     jobs:
       - test  Scheduled workflows are not available for projects integrated through the GitHub App, GitLab or Bitbucket Data Center.  The scheduled workflows feature is set to be deprecated. Using scheduled pipelines rather than scheduled workflows offers several benefits. Visit the scheduled pipelines  migration guide to find out how to migrate existing scheduled workflows to scheduled pipelines. If you would like to set up scheduled pipelines from scratch, visit the  Scheduled pipelines page.  workflows:
   nightly:
     triggers:
       - schedule:
           cron: "0 0 * * *"
           filters:
             branches:
               only:
                 - main
                 - beta
     jobs:
       - test  workflows:
   nightly:
     triggers:
       - schedule:
           cron: "0 0 * * *"
           filters:
             branches:
               only:
                 - main
                 - beta
     jobs:
       - test  workflows:
   nightly:
     triggers:
       - schedule:
           cron: "0 0 * * *"
           filters:
             branches:
               only:
                 - main
                 - beta
     jobs:
       - test  workflows:
  commit:
    jobs:
      - test
      - deploy
  nightly:
    triggers:
      - schedule:
          cron: "0 0 * * *"
          filters:
            branches:
              only:
                - main
                - /^release\/.*/
    jobs:
      - coverage  Using when or unless under workflows is supported in version: 2.1 configuration. Workflows are always run unless there is a when or unless filter that prevents the workflow from being run. If you want a workflow to run in every pipeline, do not add a when or unless filter.  version: 2.1

workflows:
  integration_tests:
    when: pipeline.git.branch == "main"
    jobs:
      - mytestjob

jobs:
...   Pipeline order protection in serial groups   Jobs in a serial group follow an order protection mechanism, as follows:     Jobs start in the order they join the queue, but are accepted based on pipeline number.   If a group is waiting/running and another job in the same project attempts to join the queue with a lower pipeline number, the job is skipped.   This immediate skip process exists to maintain order integrity, which is a safety process to avoid unexpected work in a build, for example, a deployment job running a previous version unexpectedly.     If there are no serial groups waiting/running, a pipeline with a lower number can start, such as restoring back to a previous pipeline via a rerun workflow.   # Creating multiple pipelines at the same time with the below config will results in
# all pipelines running test and build but only a single pipeline will run deploy at a time.

workflows:
  main-workflow:
    jobs:
      - test
      - build
      - deploy:
          serial-group: << pipeline.project.slug >>/deploy-group
          requires:
            - test
            - build  A list of jobs that must succeed or attain a specified status for the job to start. Note: When jobs in the current workflow that are listed as dependencies are not executed (due to a filter function for example), their requirement as a dependency for other jobs will be ignored by the requires option. However, if all dependencies of a job are filtered, then that job will not be executed either.   Possible types of requires items:     Job name (a required job that must succeed for the job to start)   Map of job name to status (a required job that must attain the specified status for the job to start)   Map of job name to a list of statuses (a required job that must attain one of the specified status for the job to start)     The possible status values are: success, failed and canceled.  workflows:
  my-workflow:
    jobs:
      - build
      - test:
          requires:
            - build
      - deploy:
          requires:
            - build
            - test
      - notify-build-canceled:
          requires:
            - build: canceled
      - cleanup:
          requires:
            - deploy:
              - failed
              - canceled  workflows:
  my-workflow:
    jobs:
      - build
      - test:
          requires:
            - build
      - hold:
          type: approval
          requires:
            - test
      - deploy:
          requires:
            - hold  Workflows will ignore job-level branching. If you use job-level branching and later add workflows, you must remove the branching at the job level and instead declare it in the workflows section of your config.yml.  # ...
workflows:
  build-deploy:
    jobs:
      - js_build
      - build_server_pdfs: # << the job to conditionally run based on the filter-by-branch-name.
          filters:
            branches:
              only: /server\/.*/ # the job build_server_pdfs will only run when the branch being built starts with server/  workflows:
  deploy:
    jobs:
      - init-service
      - test-service
      - build-service-image:
          requires:
            - init-service
      - dry-run-service:
          requires:
            - init-service
          filters: pipeline.git.branch != "main" and pipeline.git.branch != "canary"
      - publish-service:
          requires:
            - build-service-image
            - test-service
          filters: pipeline.git.branch == "main" or pipeline.git.tag starts-with "release"
      - deploy-service:
          context:
            - org-global
          requires:
            - publish-service
          filters: pipeline.git.branch == "main" and pipeline.parameters.my-custom-param starts-with "DEPLOY:"  filters: pipeline.git.branch == "main"  filters: pipeline.git.branch == "main" or pipeline.git.branch starts-with "integration-test"  filters: pipeline.git.branch == "main" and not (pipeline.trigger_source starts-with "api")  version: 2.1

parameters:
  run-storybook-tests:
    type: boolean
    default: false

...
# jobs configuration ommitted for brevity

workflows:
  build:
    jobs:
      - setup
      - storybook-tests:
          requires:
            - setup
          filters: |
            pipeline.parameters.run-storybook-tests
            or pipeline.git.branch == "dry-run-deploy"
            or pipeline.git.branch starts-with "deploy"  Using server? If you are using CircleCI server, replace https://circleci.com with your server hostname when interacting with the CircleCI API.  curl -X POST https://circleci.com/api/v2/project/circleci/<org-id>/<project-id>/pipeline/run \
  --header "Circle-Token: $CIRCLE_TOKEN" \
  --header "content-type: application/json" \
  --data {
  "definition_id": "<pipeline-definition-id>",
  "config": {"branch": "<your-branch-name>"},
  "checkout": {"branch": "<your-branch-name>"},
  "parameters": {"run-storybook-tests": "true"}
  }  Boolean negation.   Note that not has very high precedence and so binds very tightly. Use sub-expressions to apply not to more complex expressions. For example, with foo being true and bar being false:     not foo and bar evaluates to false   not (foo and bar) evaluates to true    workflows:
  dev_stage_pre-prod:
    jobs:
      - test_dev:
          filters:  # using regex filters requires the entire branch to match
            branches:
              only:  # only branches matching the below regex filters will run
                - dev
                - /user-.*/
      - test_stage:
          filters:
            branches:
              only: stage
      - test_pre-prod:
          filters:
            branches:
              only: /pre-prod(?:-.+)?$/  workflows:
  untagged-build:
    jobs:
      - build
  tagged-build:
    jobs:
      - build:
          filters:
            tags:
              only: /^v.*/  The matrix key is supported in version: 2.1 configuration  workflows:
  workflow:
    jobs:
      - build:
          matrix:
            parameters:
              version: ["0.1", "0.2", "0.3"]
              platform: ["macos", "windows", "linux"]  workflows:
  workflow:
    jobs:
      - build:
          name: build-macos-0.1
          version: "0.1"
          platform: macos
      - build:
          name: build-macos-0.2
          version: "0.2"
          platform: macos
      - build:
          name: build-macos-0.3
          version: "0.3"
          platform: macos
      - build:
          name: build-windows-0.1
          version: "0.1"
          platform: windows
      - ...  workflows:
  workflow:
    jobs:
      - build:
          matrix:
            parameters:
              a: [1, 2, 3]
              b: [4, 5, 6]
            exclude:
              - a: 3
                b: 5  workflows:
  workflow:
    jobs:
      - deploy:
          matrix:
            parameters:
              version: ["0.1", "0.2"]
      - another-job:
          requires:
            - deploy  workflows:
  workflow:
    jobs:
      - build:
          name: build-v<< matrix.version >>
          matrix:
            parameters:
              version: ["0.1", "0.2"]
      - deploy:
          name: deploy-v<< matrix.version >>
          matrix:
            parameters:
              version: ["0.1", "0.2"]
          requires:
            - build-v<< matrix.version >>  workflows:
  workflow:
    jobs:
      - build:
          name: build-v0.1
          version: "0.1"
      - build:
          name: build-v0.2
          version: "0.2"
      - deploy:
          name: deploy-v0.1
          version: "0.1"
          requires:
            - build-v0.1
      - deploy:
          name: deploy-v0.2
          version: "0.2"
          requires:
            - build-v0.2  Pre-steps and post-steps are supported in version: 2.1 configuration  version: 2.1

jobs:
  bar:
    machine:
      image: ubuntu-2004:2024.05.1
    steps:
      - checkout
      - run:
          command: echo "building"
      - run:
          command: echo "testing"

workflows:
  build:
    jobs:
      - bar:
          pre-steps: # steps to run before steps defined in the job bar
            - run:
                command: echo "install custom dependency"
          post-steps: # steps to run after steps defined in the job bar
            - run:
                command: echo "upload artifact to s3"  When using logic statements at the workflow level, do not include the condition: key (the condition key is only needed for job level logic statements).  workflows:
  my-workflow:
    when:
      or:
        - equal: [ main, << pipeline.git.branch >> ]
        - equal: [ staging, << pipeline.git.branch >> ]  Using Docker? Authenticating Docker pulls from image registries is recommended when using the Docker execution environment. Authenticated pulls allow access to private Docker images, and may also grant higher rate limits, depending on your registry provider. For further information see  Using Docker authenticated pulls.  version: 2.1
jobs:
  build:
    docker:
      - image: ubuntu:23.04

      - image: mongo:6.0.14
        command: [mongod, --smallfiles]

      - image: postgres:14.12
        # some containers require setting environment variables
        environment:
          POSTGRES_USER: user

      - image: redis@sha256:54057dd7e125ca41afe526a877e8bd35ec2cdd33b9217e022ed37bdcf7d09673

      - image: rabbitmq:3.12.12

    environment:
      TEST_REPORTS: /tmp/test-reports

    working_directory: ~/my-project

    steps:
      - checkout

      - run:
          command: echo 127.0.0.1 devhost | sudo tee -a /etc/hosts

      # Create Postgres users and database
      # Note the YAML heredoc '|' for nicer formatting
      - run: |
          sudo -u root createuser -h localhost --superuser ubuntu &&
          sudo createdb -h localhost test_db

      - restore_cache:
          keys:
            - v1-my-project-{{ checksum "project.clj" }}
            - v1-my-project-

      - run:
          environment:
            SSH_TARGET: "localhost"
            TEST_ENV: "linux"
          command: |
            set -xu
            mkdir -p ${TEST_REPORTS}
            run-tests.sh
            cp out/tests/*.xml ${TEST_REPORTS}

      - run: |
          set -xu
          mkdir -p /tmp/artifacts
          create_jars.sh << pipeline.number >>
          cp *.jar /tmp/artifacts

      - save_cache:
          key: v1-my-project-{{ checksum "project.clj" }}
          paths:
            - ~/.m2

      # Save artifacts
      - store_artifacts:
          path: /tmp/artifacts
          destination: build

      # Upload test results
      - store_test_results:
          path: /tmp/test-reports

  deploy-stage:
    docker:
      - image: ubuntu:23.04
    working_directory: /tmp/my-project
    steps:
      - run:
          name: Deploy if tests pass and branch is Staging
          command: ansible-playbook site.yml -i staging

  deploy-prod:
    docker:
      - image: ubuntu:23.04
    working_directory: /tmp/my-project
    steps:
      - run:
          name: Deploy if tests pass and branch is Main
          command: ansible-playbook site.yml -i production

workflows:
  build-deploy:
    jobs:
      - build:
          filters:
            branches:
              ignore:
                - develop
                - /feature-.*/
      - deploy-stage:
          requires:
            - build
          filters:
            branches:
              only: staging
      - deploy-prod:
          requires:
            - build
          filters:
            branches:
              only: main\n\n\n\nIntroduction to environment variables1 week ago5 min readCloudServer v4+On This PageIntroductionBuilt-in environment variablesPrivate keys and secretsSecrets maskingEnvironment variable usage optionsOrder of precedenceExample configuration of environment variablesParameters and the Bash environmentEnvironment variable substitutionUsageAlpine LinuxNotes on securityContextsSee also Introduction   Use environment variables to set up various configuration options, and keep your set-up secure with secrets, private keys, and contexts. Environment variables in CircleCI are governed by an  order of precedence, allowing control at each level in your configuration.   See the  Set an environment variable page for guidance on the different ways to set an environment variable.   If you have existing environment variables (or contexts) and you would like to rename your organization or repository, follow the  Rename organizations and repositories guide to make sure you do not lose access to environment variables or contexts in the process.     Built-in environment variables   All projects have access to CircleCI’s built-in environment variables. These environment variables are scoped at the job level, so they can be used with the context key in a job, but they do not exist at a pipeline level.   For a full list of built-in environment variables, see the  Project values and variables page.     Private keys and secrets   To add private keys or secrets as environment variables for use throughout your project, navigate to Project Settings  Environment Variables in the  CircleCI web app. You can find step-by-step instructions of this process on the  Environment variables page. The variable values are neither readable nor editable in the app after they are set. To change the value of an environment variable, delete the current variable, and add it again with the new value.   Private environment variables enable you to store secrets safely, even when your project is public. Refer to the  Building open source projects page for associated security and settings information.     Secrets masking   Environment variables and contexts may hold project secrets or keys that perform crucial functions for your applications. Secrets masking provides added security within CircleCI by obscuring environment variables in the job output when echo or print is used.   Secrets masking is applied to environment variables set within Project Settings or Contexts in the web app.   The value of the environment variable or context will not be masked in the job output if:     the value of the environment variable is less than 4 characters   the value of the environment variable is equal to one of true, True, false, or False        Secrets masking will only prevent values from appearing in your job output. Invoking a bash shell with the -x or -o xtrace options may inadvertently log unmasked secrets (refer to  Using shell scripts). If your secrets appear elsewhere, such as test results or artifacts, they will not be masked. Additionally, values are still accessible to users  debugging builds with SSH.           The secrets masking feature exists as a preventative measure to catch unintentional display of secrets at the output. Best practice is to avoid printing secrets to the output. The are many ways that secrets masking could be bypassed, either accidentally or maliciously. For example, any process that reformats the output of a command or script could remove secrets masking.          Environment variable usage options   CircleCI uses Bash, which follows the POSIX naming convention for environment variables. Valid characters include letters (uppercase and lowercase), digits, and the underscore. The first character of each environment variable name must be an alpha character or an underscore, not a digit.   Order of precedence  Environment variables are used according to a specific precedence order, as follows:     Environment variables declared  inside a shell command in a run step, for example FOO=bar make install.   Environment variables declared with the environment key  for a run step.   Environment variables set with the environment key  for a job.   Special CircleCI environment variables defined in the  CircleCI Built-in environment variables document.   Context environment variables (assuming the user has access to the context). See the  Contexts documentation for more information.    Project-level environment variables set on the Project Settings page in the web app.     Environment variables declared inside a shell command run step, for example FOO=bar make install, will override environment variables declared with the environment and contexts keys. Environment variables added on the Contexts page in the web app will take precedence over variables added on the Project Settings page.         Example configuration of environment variables  Consider the example .circleci/config.yml below:    version: 2.1

jobs: # basic units of work in a run
  build:
    docker: # use the Docker executor
      # CircleCI Node images available at: https://circleci.com/developer/images/image/cimg/node
      - image: cimg/node:18.11.0
    steps: # steps that comprise the `build` job
      - checkout # check out source code to working directory
      # Run a step to setup an environment variable
      # Redirect MY_ENV_VAR into $BASH_ENV
      - run:
          name: "Setup custom environment variables"
          command: echo 'export MY_ENV_VAR="FOO"' >> "$BASH_ENV"
      - run: # print the name of the branch we're on
          name: "What branch am I on?"
          command: echo ${CIRCLE_BRANCH}
      # Run another step, the same as above; note that you can
      # invoke environment variable without curly braces.
      - run:
          name: "What branch am I on now?"
          command: echo $CIRCLE_BRANCH
      - run:
          name: "What was my custom environment variable?"
          command: echo ${MY_ENV_VAR}
      - run:
          name: "Print an env var stored in the Project"
          command: echo ${PROJECT_ENV_VAR}
      - run:
          name: "Print an env var stored in a Context"
          command: echo ${CONTEXT_ENV_VAR}

workflows: # a single workflow with a single job called build
  build:
    jobs:
      - build:
          context: Testing-Env-Vars    The above .circleci/config.yml demonstrates the following:     Setting custom environment variables.   Reading a built-in environment variable that CircleCI provides (CIRCLE_BRANCH).   How variables are used (or interpolated) in your .circleci/config.yml.   Secrets masking, applied to environment variable set in the project or within a context.     When the above configuration runs, the output looks like the image below. Notice the environment variables stored in the project is masked, and displays as ****:        Notice there are two similar steps in the above image and configuration - "What branch am I on?" These steps illustrate two different methods to read environment variables.   In the example configuration above, two syntax variants are used: ${VAR} and $VAR. Both syntax variants are supported. You can read more about shell parameter expansion in the  Bash documentation.    Parameters and the Bash environment  In general, CircleCI does not support interpolating environment variables in the configuration. Values used are treated as literals. This can cause issues when defining working_directory, modifying PATH, and sharing variables across multiple run steps.   In the example below, $ORGNAME and $REPONAME will not be interpolated.    working_directory: /go/src/github.com/$ORGNAME/$REPONAME       An exception to this interpolation rule is using project environment variables to pull  private images.        You can reuse pieces of configuration across your .circleci/config.yml file. By using the parameters declaration, you can pass values into reusable commands, jobs, and executors:    version: 2.1 # version 2.1 is required for reusing configuration

jobs:
  build:
    parameters:
      org_name:
        type: string
        default: my_org
      repo_name:
        type: string
        default: my_repo
    docker:
      - image: cimg/go:1.17.3
    steps:
      - run: echo "project directory is go/src/github.com/<< parameters.org_name >>/<< parameters.repo_name >>"

workflows:
  my_workflow:
    jobs:
      - build:
          org_name: my_organization
          repo_name: project1

      - build:
          org_name: my_organization
          repo_name: project2    For more information, read the documentation on  using the parameters declaration.   Another possible method to interpolate values into your configuration is to use a run step to export environment variables to BASH_ENV, as shown below.      The $BASH_ENV workaround only works with bash, and has not been confirmed to work with other shells.         steps:
  - run:
      name: Setup Environment Variables
      command: |
        echo 'export PATH="$GOPATH"/bin:"$PATH"' >> "$BASH_ENV"
        echo 'export GIT_SHA1="$CIRCLE_SHA1"' >> "$BASH_ENV"    In every step, CircleCI uses bash to source BASH_ENV. This means that BASH_ENV is automatically loaded and run, allowing you to use interpolation and share environment variables across run steps.    Environment variable substitution  The CircleCI CLI offers a wrapper around the  envsubst tool, available both locally as well as in all jobs running on CircleCI. envsubst is a command-line utility used to replace environment variables in text strings.   CLI command:    circleci env subst    Usage  The circleci env subst command can accept text input from stdin or as an argument.   Within your repository create a file such as template.json, with value replaced by environment variable strings    {
  "foo": "$FOO",
  "provider": "${PROVIDER}"
}    envsubst can convert all types of environment variable strings, including those encased in curly braces ({}).   The config example below shows the corresponding environment variables as if they were defined directly within a step in the config. However, we strongly recommend creating the environment variables in the CircleCI app, either in  Project Settings or as a  context.    version: 2.1
jobs:
  process-template:
    docker:
      - image: cimg/base:current
    steps:
      - checkout
      - run:
          name: Process template file
          environment:
            # Environment variables would typically be served via a context
            FOO: bar
            PROVIDER: circleci
          command: |
            circleci env subst < template.json > deploy.json
            cat deploy.json
workflows:
  env-subst-workflow:
    jobs:
      - process-template    In this example, the < symbol is used to redirect the contents of the template.json file as input to the env subst command, while the > symbol is used to redirect the output of the env subst command to the deploy.json.   You could alternatively pass input to the circleci env subst command as an argument: circleci env subst "hello \$WORLD"   Output:    {
  "foo": "bar",
  "provider": "circleci"
}    For instructions on installing the CircleCI CLI locally, read the  Installing the CircleCI local CLI guide.     Alpine Linux  An image that has been based on  Alpine Linux (like  Docker), uses the ash shell.   To use environment variables with bash, add the shell and environment keys to your job.    version: 2.1

jobs:
  build:
    shell: /bin/sh -leo pipefail
    environment:
      BASH_ENV: /etc/profile       Notes on security   Do not add secrets or keys inside the .circleci/config.yml file. The full text of .circleci/config.yml is visible to developers with access to your project on CircleCI. Store secrets or keys in the CircleCI web app under one of the following:     In  Project settings.   In a  context.     For more information, see the  Encryption section of the security page.   Running scripts within configuration may expose secret environment variables. See the  Using shell scripts page for best practices for secure scripts.     Contexts   You can further restrict access to environment variables using  contexts. Contexts are set from the Organization Settings in the CircleCI web app.     See also      Security recommendations    Set an environment variable    Inject variables using the CircleCI API     Suggest an edit to this pageMake a contribution Learn how to contributeStill need help? Ask the CircleCI community Join the research community Visit our Support site\n\nIntroduction to environment variables1 week ago5 min readCloudServer v4+On This PageIntroductionBuilt-in environment variablesPrivate keys and secretsSecrets maskingEnvironment variable usage optionsOrder of precedenceExample configuration of environment variablesParameters and the Bash environmentEnvironment variable substitutionUsageAlpine LinuxNotes on securityContextsSee also Introduction   Use environment variables to set up various configuration options, and keep your set-up secure with secrets, private keys, and contexts. Environment variables in CircleCI are governed by an  order of precedence, allowing control at each level in your configuration.   See the  Set an environment variable page for guidance on the different ways to set an environment variable.   If you have existing environment variables (or contexts) and you would like to rename your organization or repository, follow the  Rename organizations and repositories guide to make sure you do not lose access to environment variables or contexts in the process.     Built-in environment variables   All projects have access to CircleCI’s built-in environment variables. These environment variables are scoped at the job level, so they can be used with the context key in a job, but they do not exist at a pipeline level.   For a full list of built-in environment variables, see the  Project values and variables page.     Private keys and secrets   To add private keys or secrets as environment variables for use throughout your project, navigate to Project Settings  Environment Variables in the  CircleCI web app. You can find step-by-step instructions of this process on the  Environment variables page. The variable values are neither readable nor editable in the app after they are set. To change the value of an environment variable, delete the current variable, and add it again with the new value.   Private environment variables enable you to store secrets safely, even when your project is public. Refer to the  Building open source projects page for associated security and settings information.     Secrets masking   Environment variables and contexts may hold project secrets or keys that perform crucial functions for your applications. Secrets masking provides added security within CircleCI by obscuring environment variables in the job output when echo or print is used.   Secrets masking is applied to environment variables set within Project Settings or Contexts in the web app.   The value of the environment variable or context will not be masked in the job output if:     the value of the environment variable is less than 4 characters   the value of the environment variable is equal to one of true, True, false, or False        Secrets masking will only prevent values from appearing in your job output. Invoking a bash shell with the -x or -o xtrace options may inadvertently log unmasked secrets (refer to  Using shell scripts). If your secrets appear elsewhere, such as test results or artifacts, they will not be masked. Additionally, values are still accessible to users  debugging builds with SSH.           The secrets masking feature exists as a preventative measure to catch unintentional display of secrets at the output. Best practice is to avoid printing secrets to the output. The are many ways that secrets masking could be bypassed, either accidentally or maliciously. For example, any process that reformats the output of a command or script could remove secrets masking.          Environment variable usage options   CircleCI uses Bash, which follows the POSIX naming convention for environment variables. Valid characters include letters (uppercase and lowercase), digits, and the underscore. The first character of each environment variable name must be an alpha character or an underscore, not a digit.   Order of precedence  Environment variables are used according to a specific precedence order, as follows:     Environment variables declared  inside a shell command in a run step, for example FOO=bar make install.   Environment variables declared with the environment key  for a run step.   Environment variables set with the environment key  for a job.   Special CircleCI environment variables defined in the  CircleCI Built-in environment variables document.   Context environment variables (assuming the user has access to the context). See the  Contexts documentation for more information.    Project-level environment variables set on the Project Settings page in the web app.     Environment variables declared inside a shell command run step, for example FOO=bar make install, will override environment variables declared with the environment and contexts keys. Environment variables added on the Contexts page in the web app will take precedence over variables added on the Project Settings page.         Example configuration of environment variables  Consider the example .circleci/config.yml below:    version: 2.1

jobs: # basic units of work in a run
  build:
    docker: # use the Docker executor
      # CircleCI Node images available at: https://circleci.com/developer/images/image/cimg/node
      - image: cimg/node:18.11.0
    steps: # steps that comprise the `build` job
      - checkout # check out source code to working directory
      # Run a step to setup an environment variable
      # Redirect MY_ENV_VAR into $BASH_ENV
      - run:
          name: "Setup custom environment variables"
          command: echo 'export MY_ENV_VAR="FOO"' >> "$BASH_ENV"
      - run: # print the name of the branch we're on
          name: "What branch am I on?"
          command: echo ${CIRCLE_BRANCH}
      # Run another step, the same as above; note that you can
      # invoke environment variable without curly braces.
      - run:
          name: "What branch am I on now?"
          command: echo $CIRCLE_BRANCH
      - run:
          name: "What was my custom environment variable?"
          command: echo ${MY_ENV_VAR}
      - run:
          name: "Print an env var stored in the Project"
          command: echo ${PROJECT_ENV_VAR}
      - run:
          name: "Print an env var stored in a Context"
          command: echo ${CONTEXT_ENV_VAR}

workflows: # a single workflow with a single job called build
  build:
    jobs:
      - build:
          context: Testing-Env-Vars    The above .circleci/config.yml demonstrates the following:     Setting custom environment variables.   Reading a built-in environment variable that CircleCI provides (CIRCLE_BRANCH).   How variables are used (or interpolated) in your .circleci/config.yml.   Secrets masking, applied to environment variable set in the project or within a context.     When the above configuration runs, the output looks like the image below. Notice the environment variables stored in the project is masked, and displays as ****:        Notice there are two similar steps in the above image and configuration - "What branch am I on?" These steps illustrate two different methods to read environment variables.   In the example configuration above, two syntax variants are used: ${VAR} and $VAR. Both syntax variants are supported. You can read more about shell parameter expansion in the  Bash documentation.    Parameters and the Bash environment  In general, CircleCI does not support interpolating environment variables in the configuration. Values used are treated as literals. This can cause issues when defining working_directory, modifying PATH, and sharing variables across multiple run steps.   In the example below, $ORGNAME and $REPONAME will not be interpolated.    working_directory: /go/src/github.com/$ORGNAME/$REPONAME       An exception to this interpolation rule is using project environment variables to pull  private images.        You can reuse pieces of configuration across your .circleci/config.yml file. By using the parameters declaration, you can pass values into reusable commands, jobs, and executors:    version: 2.1 # version 2.1 is required for reusing configuration

jobs:
  build:
    parameters:
      org_name:
        type: string
        default: my_org
      repo_name:
        type: string
        default: my_repo
    docker:
      - image: cimg/go:1.17.3
    steps:
      - run: echo "project directory is go/src/github.com/<< parameters.org_name >>/<< parameters.repo_name >>"

workflows:
  my_workflow:
    jobs:
      - build:
          org_name: my_organization
          repo_name: project1

      - build:
          org_name: my_organization
          repo_name: project2    For more information, read the documentation on  using the parameters declaration.   Another possible method to interpolate values into your configuration is to use a run step to export environment variables to BASH_ENV, as shown below.      The $BASH_ENV workaround only works with bash, and has not been confirmed to work with other shells.         steps:
  - run:
      name: Setup Environment Variables
      command: |
        echo 'export PATH="$GOPATH"/bin:"$PATH"' >> "$BASH_ENV"
        echo 'export GIT_SHA1="$CIRCLE_SHA1"' >> "$BASH_ENV"    In every step, CircleCI uses bash to source BASH_ENV. This means that BASH_ENV is automatically loaded and run, allowing you to use interpolation and share environment variables across run steps.    Environment variable substitution  The CircleCI CLI offers a wrapper around the  envsubst tool, available both locally as well as in all jobs running on CircleCI. envsubst is a command-line utility used to replace environment variables in text strings.   CLI command:    circleci env subst    Usage  The circleci env subst command can accept text input from stdin or as an argument.   Within your repository create a file such as template.json, with value replaced by environment variable strings    {
  "foo": "$FOO",
  "provider": "${PROVIDER}"
}    envsubst can convert all types of environment variable strings, including those encased in curly braces ({}).   The config example below shows the corresponding environment variables as if they were defined directly within a step in the config. However, we strongly recommend creating the environment variables in the CircleCI app, either in  Project Settings or as a  context.    version: 2.1
jobs:
  process-template:
    docker:
      - image: cimg/base:current
    steps:
      - checkout
      - run:
          name: Process template file
          environment:
            # Environment variables would typically be served via a context
            FOO: bar
            PROVIDER: circleci
          command: |
            circleci env subst < template.json > deploy.json
            cat deploy.json
workflows:
  env-subst-workflow:
    jobs:
      - process-template    In this example, the < symbol is used to redirect the contents of the template.json file as input to the env subst command, while the > symbol is used to redirect the output of the env subst command to the deploy.json.   You could alternatively pass input to the circleci env subst command as an argument: circleci env subst "hello \$WORLD"   Output:    {
  "foo": "bar",
  "provider": "circleci"
}    For instructions on installing the CircleCI CLI locally, read the  Installing the CircleCI local CLI guide.     Alpine Linux  An image that has been based on  Alpine Linux (like  Docker), uses the ash shell.   To use environment variables with bash, add the shell and environment keys to your job.    version: 2.1

jobs:
  build:
    shell: /bin/sh -leo pipefail
    environment:
      BASH_ENV: /etc/profile       Notes on security   Do not add secrets or keys inside the .circleci/config.yml file. The full text of .circleci/config.yml is visible to developers with access to your project on CircleCI. Store secrets or keys in the CircleCI web app under one of the following:     In  Project settings.   In a  context.     For more information, see the  Encryption section of the security page.   Running scripts within configuration may expose secret environment variables. See the  Using shell scripts page for best practices for secure scripts.     Contexts   You can further restrict access to environment variables using  contexts. Contexts are set from the Organization Settings in the CircleCI web app.     See also      Security recommendations    Set an environment variable    Inject variables using the CircleCI API     Suggest an edit to this pageMake a contribution Learn how to contributeStill need help? Ask the CircleCI community Join the research community Visit our Support site DocsTerms of UsePrivacy PolicyCookie PolicySecurity© 2025 Circle Internet Services, Inc., All Rights Reserved.\n\nSecrets masking will only prevent values from appearing in your job output. Invoking a bash shell with the -x or -o xtrace options may inadvertently log unmasked secrets (refer to  Using shell scripts). If your secrets appear elsewhere, such as test results or artifacts, they will not be masked. Additionally, values are still accessible to users  debugging builds with SSH.  The secrets masking feature exists as a preventative measure to catch unintentional display of secrets at the output. Best practice is to avoid printing secrets to the output. The are many ways that secrets masking could be bypassed, either accidentally or maliciously. For example, any process that reformats the output of a command or script could remove secrets masking.    version: 2.1

jobs: # basic units of work in a run
  build:
    docker: # use the Docker executor
      # CircleCI Node images available at: https://circleci.com/developer/images/image/cimg/node
      - image: cimg/node:18.11.0
    steps: # steps that comprise the `build` job
      - checkout # check out source code to working directory
      # Run a step to setup an environment variable
      # Redirect MY_ENV_VAR into $BASH_ENV
      - run:
          name: "Setup custom environment variables"
          command: echo 'export MY_ENV_VAR="FOO"' >> "$BASH_ENV"
      - run: # print the name of the branch we're on
          name: "What branch am I on?"
          command: echo ${CIRCLE_BRANCH}
      # Run another step, the same as above; note that you can
      # invoke environment variable without curly braces.
      - run:
          name: "What branch am I on now?"
          command: echo $CIRCLE_BRANCH
      - run:
          name: "What was my custom environment variable?"
          command: echo ${MY_ENV_VAR}
      - run:
          name: "Print an env var stored in the Project"
          command: echo ${PROJECT_ENV_VAR}
      - run:
          name: "Print an env var stored in a Context"
          command: echo ${CONTEXT_ENV_VAR}

workflows: # a single workflow with a single job called build
  build:
    jobs:
      - build:
          context: Testing-Env-Vars    working_directory: /go/src/github.com/$ORGNAME/$REPONAME  An exception to this interpolation rule is using project environment variables to pull  private images.  version: 2.1 # version 2.1 is required for reusing configuration

jobs:
  build:
    parameters:
      org_name:
        type: string
        default: my_org
      repo_name:
        type: string
        default: my_repo
    docker:
      - image: cimg/go:1.17.3
    steps:
      - run: echo "project directory is go/src/github.com/<< parameters.org_name >>/<< parameters.repo_name >>"

workflows:
  my_workflow:
    jobs:
      - build:
          org_name: my_organization
          repo_name: project1

      - build:
          org_name: my_organization
          repo_name: project2  The $BASH_ENV workaround only works with bash, and has not been confirmed to work with other shells.  steps:
  - run:
      name: Setup Environment Variables
      command: |
        echo 'export PATH="$GOPATH"/bin:"$PATH"' >> "$BASH_ENV"
        echo 'export GIT_SHA1="$CIRCLE_SHA1"' >> "$BASH_ENV"  circleci env subst  {
  "foo": "$FOO",
  "provider": "${PROVIDER}"
}  version: 2.1
jobs:
  process-template:
    docker:
      - image: cimg/base:current
    steps:
      - checkout
      - run:
          name: Process template file
          environment:
            # Environment variables would typically be served via a context
            FOO: bar
            PROVIDER: circleci
          command: |
            circleci env subst < template.json > deploy.json
            cat deploy.json
workflows:
  env-subst-workflow:
    jobs:
      - process-template  {
  "foo": "bar",
  "provider": "circleci"
}  version: 2.1

jobs:
  build:
    shell: /bin/sh -leo pipefail
    environment:
      BASH_ENV: /etc/profile\n\n\n\nConfiguration reference1 week agoCloudServer v4+Helpful Resources6 config optimization tipsIntro to dynamic configUsing dynamic configValidate your config using local CLIHow to trigger a single jobOn This Pageversionsetuporbscommandsparametersexecutorsjobs<job_name>typeenvironmentparallelismparametersExecutor docker / machine / macosdockerDocker registry authenticationAWS authenticationUse OIDCUse environment variablesmachineAvailable Linux machine imagesAvailable Linux machine images on serverAvailable Linux GPU machine imagesAvailable Android machine imagesAvailable Windows machine imagesAvailable Windows machine images on serverAvailable Windows GPU machine imagemacosbranches - DEPRECATEDresource_classSelf-hosted runnerDocker execution environmentx86ArmLinuxVM execution environmentmacOS execution environmentmacOS execution environment on serverWindows execution environmentGPU execution environment (Linux)GPU execution-environment (Windows)Arm VM execution-environmentstepsrunDefault shell options-e-o pipefailBackground commandsShorthand syntaxThe when attributeEnding a job from within a stepThe when stepcheckoutsetup_remote_dockersave_cacherestore_cachedeploy - DEPRECATEDstore_artifactsstore_test_resultspersist_to_workspaceattach_workspaceadd_ssh_keysUsing pipeline valuescircleci_ip_rangesworkflowsversion<workflow_name>triggersschedulecronfiltersbranchesUsing when in workflowsjobs<job_name>serial-grouprequiresnamecontexttypefiltersExpression-based job filtersbranchestagsmatrixExcluding sets of parameters from a matrixDependencies and matrix jobspre-steps and post-stepsLogic statementsLogic statement examplesExample full configuration   This document is a reference for the CircleCI 2.x configuration keys that are used in the .circleci/config.yml file.   You can see a complete config.yml in our  full example.      version  KeyRequiredTypeDescriptionversionYString2, 2.0, or 2.1 See the  Reusable configuration page for an overview of 2.1 keys available to simplify your .circleci/config.yml file, reuse, and parameterized jobs.  The version field is intended to be used in order to issue warnings for deprecation or breaking changes.      setup  KeyRequiredTypeDescriptionsetupNBooleanDesignates the config.yaml for use of CircleCI’s  dynamic configuration feature.  The setup field enables you to conditionally trigger configurations from outside the primary .circleci parent directory, update pipeline parameters, or generate customized configurations.      orbs      The orbs key is supported in version: 2.1 configuration       KeyRequiredTypeDescriptionorbsNMapA map of user-selected names to either: orb references (strings) or orb definitions (maps). Orb definitions must be the orb-relevant subset of 2.1 config. See the  Creating Orbs documentation for details.executorsNMapA map of strings to executor definitions. See the  executors section below.commandsNMapA map of command names to command definitions. See the  commands section below.  The following example uses the node orb that exists in the certified circleci namespace. Refer to the Node orb page in the  Orb Registry for more examples and information.    version: 2.1

orbs:
  node: circleci/node@x.y

jobs:
  install-node-example:
    docker:
      - image: cimg/base:stable
    steps:
      - checkout
      - node/install:
          install-yarn: true
          node-version: '16.13'
      - run: node --version
workflows:
  test_my_app:
    jobs:
      - install-node-example    Documentation is available for orbs in the following sections:      Using Orbs    Authoring Orbs.     Public orbs are listed in the  Orb Registry.      commands      The commands key is supported in version: 2.1 configuration        A command defines a sequence of steps as a map to be executed in a job, enabling you to reuse a single command definition across multiple jobs. For more information see the  Reusable Config Reference Guide.  KeyRequiredTypeDescriptionstepsYSequenceA sequence of steps run inside the calling job of the command.parametersNMapA map of parameter keys. See the  Parameter Syntax section of the  Reusing Config document for details.descriptionNStringA string that describes the purpose of the command.  Example:    commands:
  sayhello:
    description: "A very simple command for demonstration purposes"
    parameters:
      to:
        type: string
        default: "Hello World"
    steps:
      - run: echo << parameters.to >>       parameters      The pipeline parameters key is supported in version: 2.1 configuration        Pipeline parameters declared for use in the configuration. See  Pipeline Values and Parameters for usage details.  KeyRequiredTypeDescriptionparametersNMapA map of parameter keys. Supports string, boolean, integer and enum types. See  Parameter Syntax for details.     executors      The executors key is supported in version: 2.1 configuration        Executors define the execution environment in which the steps of a job will be run, allowing you to reuse a single executor definition across multiple jobs.  KeyRequiredTypeDescriptiondockerY (1)ListOptions for  Docker executorresource_classNStringAmount of CPU and RAM allocated to each container in a job.machineY (1)MapOptions for  machine executormacosY (1)MapOptions for  macOS executorwindowsY (1)Map Windows executor currently working with orbs. Check out  the orb.shellNStringShell to use for execution command in all steps. Can be overridden by shell in each step (default: See  Default Shell Options)working_directoryNStringIn which directory to run the steps. Will be interpreted as an absolute path.environmentNMapA map of environment variable names and values.  (1) One executor type should be specified per job. If more than one is set you will receive an error.   Example:    version: 2.1
executors:
  my-executor:
    docker:
      - image: cimg/ruby:3.0.3-browsers

jobs:
  my-job:
    executor: my-executor
    steps:
      - run: echo "Hello executor!"    See the  Using Parameters in Executors section of the  Reusing config page for examples of parameterized executors.      jobs   A Workflow is comprised of one or more uniquely named jobs. Jobs are specified in the jobs map, see  Sample config.yml for two examples of a job map. The name of the job is the key in the map, and the value is a map describing the job.   Jobs have a maximum runtime based on pricing plan, as follows:     1 hour (Free)   3 hours (Performance)   5 hours (Scale)     If your jobs are timing out, consider the following:     A larger  resource_class.   Using  parallelism.   Run some of your jobs concurrently using  workflows.   You can upgrade your pricing plan.      <job_name>  Each job consists of the job’s name as a key and a map as a value. A name should be case insensitive unique within a current jobs list. The value map has the following attributes:  KeyRequiredTypeDescriptiontypeNStringJob type, can be build, release, no-op, or approval. If not specified, defaults to build.dockerY (1)ListOptions for the  Docker executormachineY (1)MapOptions for the  machine executormacosY (1)MapOptions for the  macOS executorshellNStringShell to use for execution command in all steps. Can be overridden by shell in each step (default: See  Default Shell Options)parametersNMap Parameters for making a job explicitly configurable in a workflow.stepsYListA list of  steps to be performedworking_directoryNStringIn which directory to run the steps. Will be interpreted as an absolute path. Default: ~/project (where project is a literal string, not the name of your specific project). Processes run during the job can use the $CIRCLE_WORKING_DIRECTORY environment variable to refer to this directory. Note: Paths written in your YAML configuration file will not be expanded; if your store_test_results.path is $CIRCLE_WORKING_DIRECTORY/tests, then CircleCI will attempt to store the test subdirectory of the directory literally named $CIRCLE_WORKING_DIRECTORY, dollar sign $ and all. working_directory will be created automatically if it doesn’t exist.parallelismNIntegerNumber of parallel instances of this job to run (default: 1)environmentNMapA map of environment variable names and values.branchesNMapThis key is deprecated. Use  workflows filtering to control which jobs run for which branches.resource_classNStringAmount of CPU and RAM allocated to each container in a job.  (1) One executor type should be specified per job. If more than one is set you will receive an error.    type  Configure a job type. Options are release, approval, no-op, build (default).   If a type is not specified, the job defaults to a build type.   Example of a job with a build type. build is the default type and does not need to be configured:    jobs:
  my-job:
    docker:
      - image: cimg/base:2024.12
    resource_class: xlarge
    steps:
      ... // other config    Jobs with the release type are used to  connect your pipeline configuration to a deployment in the CircleCI deploys UI. For full details, see the  Deploys overview page.   Example of a job with a release type:    jobs:
  release-my-service:
    type: release
    plan_name: <my-service-release>    The no-op type is used to configure a job that performs no actions and consumes no credits. no-op is commonly used to organise the order of operations within a workflow and make it easier to maintain. Only the type is required for a no-op type job, no further job configuration is required. For some examples of using no-op jobs, see the  Orchestration cookbook   Example of a job with a no-op type:    jobs:
  my-no-op-job:
    type: no-op    The approval type is used to configure a manual approval step. No job configuration is required or allowed for an approval type job. The approval type is most commonly configured within a workflow rather than under the top-level jobs key. Only approval type jobs can have their type configured under workflows. See  type under workflows section for full details.   Example of a job with an approval type, configured under workflows:    workflows:
  my-workflow:
    jobs:
      - build
      - test:
          requires:
            - build
      - hold:
          type: approval
          requires:
            - test
      - deploy:
          requires:
            - hold      environment  A map of environment variable names and values. For more information on defining and using environment variables, and the order of precedence governing the various ways they can be set, see the  Environment variables page.     parallelism  This feature is used to optimize test steps. If parallelism is set to N > 1, then N independent executors will be set up and each will run the steps of that job in parallel.   You can use the CircleCI CLI to split your test suite across parallel containers so the job completes in a shorter time.     Read more about splitting tests across parallel execution environments on the  Parallelism and test splitting page.   Refer to the  Use the CircleCI CLI to split tests how-to guide.   Follow the  Test splitting tutorial.     Example:    jobs:
  build:
    docker:
      - image: cimg/base:2024.12
    environment:
      FOO: bar
    parallelism: 3
    resource_class: large
    working_directory: ~/my-app
    steps:
      - run: go list ./... | circleci tests run --command "xargs gotestsum --junitfile junit.xml --format testname --" --split-by=timings --timings-type=name      parameters  Job-level parameters can be used when  calling a job in a workflow.   Reserved parameter-names:     name   requires   context   type   filters   matrix     See  Parameter Syntax for definition details.     Executor docker / machine / macos  CircleCI offers several execution environments in which to run your jobs. To specify an execution environment choose an executor, then specify and image and a resource class. An executor defines the underlying technology, environment, and operating system in which to run a job.   Set up your jobs to run using the docker (Linux), machine (LinuxVM, Windows, GPU, Arm), or macos executor, then specify an image with the tools and packages you need, and a resource class.   Learn more about execution environments and executors in the  Introduction to Execution Environments.     docker  Configured by docker key which takes a list of maps:  KeyRequiredTypeDescriptionimageYStringThe name of a custom Docker image to use. The first image listed under a job defines the job’s own primary container image where all steps will run.nameNStringname defines the hostname for the container (the default is localhost), which is used for reaching secondary (service) containers. By default, all services are exposed directly on localhost. This field is useful if you would rather have a different hostname instead of localhost, for example, if you are starting multiple versions of the same service.entrypointNString or ListThe command used as executable when launching the container. entrypoint overrides the image’s  ENTRYPOINT.commandNString or ListThe command used as PID 1 (or arguments for entrypoint) when launching the container. command overrides the image’s COMMAND. It will be used as arguments to the image ENTRYPOINT if it has one, or as the executable if the image has no ENTRYPOINT.userNStringWhich user to run commands as within the Docker containerenvironmentNMapA map of environment variable names and values. The environment settings apply to the entrypoint/command run by the Docker container, not the job steps.authNMapAuthentication for registries using standard docker login credentialsaws_authNMapAuthentication for AWS Elastic Container Registry (ECR)  For a  primary container, (the first container in the list) if neither command nor entrypoint is specified in the configuration, then any ENTRYPOINT and COMMAND in the image are ignored. The primary container is typically only used for running the steps and not for its ENTRYPOINT, and an ENTRYPOINT may consume significant resources or exit prematurely.   A  custom image may disable this behavior and force the ENTRYPOINT to run.   You can specify image versions using tags or digest. You can use any public images from any public Docker registry (defaults to Docker Hub). Learn more about specifying images on the  Using the Docker Execution Environment page.    Docker registry authentication  Some registries, Docker Hub, for example, may rate limit anonymous Docker pulls. We recommend that you authenticate to pull private and public images. The username and password can be specified in the auth field. See  Using Docker Authenticated Pulls for details.   Example:    jobs:
  build:
    docker:
      - image: buildpack-deps:trusty # primary container
        auth:
          username: mydockerhub-user
          password: $DOCKERHUB_PASSWORD  # context / project UI env-var reference
        environment:
          ENV: CI

      - image: mongo:2.6.8
        auth:
          username: mydockerhub-user
          password: $DOCKERHUB_PASSWORD  # context / project UI env-var reference
        command: [--smallfiles]

      - image: postgres:14.2
        auth:
          username: mydockerhub-user
          password: $DOCKERHUB_PASSWORD  # context / project UI env-var reference
        environment:
          POSTGRES_USER: user

      - image: redis@sha256:54057dd7e125ca41afe526a877e8bd35ec2cdd33b9217e022ed37bdcf7d09673
        auth:
          username: mydockerhub-user
          password: $DOCKERHUB_PASSWORD  # context / project UI env-var reference

      - image: acme-private/private-image:321
        auth:
          username: mydockerhub-user
          password: $DOCKERHUB_PASSWORD  # context / project UI env-var reference      AWS authentication  Using an image hosted on  AWS ECR requires authentication using AWS credentials.   Use OIDC  Authenticate using OpenID Connect (OIDC) using the oidc_role_arn field, as follows:    jobs:
  job_name:
    docker:
      - image: <your-image-arn>
        aws_auth:
          oidc_role_arn: <your-iam-role-arn>    For steps to get set up with OIDC to pull images from AWS ECR, see the  Pull and image from AWS ECR with OIDC page.    Use environment variables  By default, CircleCI uses the AWS credentials you provide by setting the AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY project environment variables. It is also possible to set the credentials by using the aws_auth field as in the following example:    jobs:
  build:
    docker:
      - image: account-id.dkr.ecr.us-east-1.amazonaws.com/org/repo:0.1
        aws_auth:
          aws_access_key_id: AKIAQWERVA  # can specify string literal values
          aws_secret_access_key: $ECR_AWS_SECRET_ACCESS_KEY  # or project UI envar reference        machine     CircleCI cloud The use of machine: true is deprecated. You must specify an image to use.        The machine executor is configured using the machine key, which takes a map:  KeyRequiredTypeDescriptionimageYStringThe virtual machine image to use. View  available images. Note: This key is not supported for Linux VMs on installations of CircleCI server. For information about customizing machine executor images on CircleCI installed on your servers, see our  Machine provisioner documentation.docker_layer_cachingNBooleanSet this to true to enable  Docker layer caching.  Example:  CloudServer    jobs:
  build: # name of your job
    machine: # executor type
      image: ubuntu-2004:current # recommended linux image

    steps:
      # Commands run in a Linux virtual machine environment        jobs:
  build: # name of your job
    machine: true # executor type
    steps:
      # Commands run in a Linux virtual machine environment        Available Linux machine images  Specifying an image in your configuration file is strongly recommended. CircleCI supports multiple Linux machine images that can be specified in the image field. For a full list of supported image tags, refer to the following pages in the Developer Hub:      Ubuntu-2004    Ubuntu-2204     More information on the software available in each image can be found in our  Discuss forum.   The machine executor supports  Docker Layer Caching, which is useful when you are building Docker images during your job or Workflow.     Available Linux machine images on server  If you are using CircleCI server, contact your system administrator for details of available Linux machine images.     Available Linux GPU machine images  When using the Linux  GPU executor, the available images are:     linux-cuda-11:default v11.4, v11.6, v11.8 (default), Docker v20.10.24   linux-cuda-12:default v12.0, v12.1 (default), Docker v20.10.24       Available Android machine images  CircleCI supports running jobs on Android for testing and deploying Android applications.   To use the  Android image directly with the machine executor, add the following to your job:    version: 2.1

jobs:
  build:
    machine:
      image: android:2024.11.1    The Android image can also be accessed using the  Android orb.   For examples, refer to the  Using Android Images with the Machine Executor page.     Available Windows machine images  Specifying an image in your configuration file is strongly recommended. CircleCI supports multiple Windows machine images that can be specified in the image field.   For a full list of supported images, refer to one of the following:      windows-server-2022-gui image    windows-server-2019 image     More information on what software is available in each image can be found in our  Discuss forum.   Alternatively, use the  Windows orb to manage your Windows execution environment. For examples, see the  Using the Windows Execution Environment page.     Available Windows machine images on server  If you are using CircleCI server, contact your system administrator for details of available Windows machine images.     Available Windows GPU machine image  When using the Windows  GPU executor, the available image is:      windows-server-2019-cuda     Example    version: 2.1

jobs:
  build:
    machine:
      image: windows-server-2019-cuda:current       macos  CircleCI supports running jobs on  macOS, to allow you to build, test, and deploy apps for macOS,  iOS,  tvOS and  watchOS. To run a job on a macOS virtual machine, add the macos key to the top-level configuration for your job and specify the version of Xcode to use.  KeyRequiredTypeDescriptionxcodeYStringThe version of Xcode that is installed on the virtual machine, see the  Supported Xcode Versions section of the Testing iOS document for the complete list.  Example: Use a macOS virtual machine with Xcode version 14.2.0:    jobs:
  build:
    macos:
      xcode: "14.2.0"      branches - DEPRECATED  This key is deprecated. Use  workflows filtering to control which jobs run for which branches.     resource_class  The resource_class feature allows you to configure CPU and RAM resources for each job. Resource classes are available for each execution environment, as described in the tables below.   We implement soft concurrency limits for each resource class to ensure our system remains stable for all customers. If you are on a Performance or Custom Plan and experience queuing for certain resource classes, it is possible you are hitting these limits.  Contact CircleCI support to request a raise on these limits for your account.   If you do not specify a resource class, CircleCI will use a default value that is subject to change. It is best practice to specify a resource class as opposed to relying on a default.      Java, Erlang and any other languages that introspect the /proc directory for information about CPU count may require additional configuration to prevent them from slowing down when using the CircleCI resource class feature. Programs with this issue may request 32 CPU cores and run slower than they would when requesting one core. Users of languages with this issue should pin their CPU count to their guaranteed CPU resources.           If you want to confirm how much memory you have been allocated, you can check the cgroup memory hierarchy limit with grep hierarchical_memory_limit /sys/fs/cgroup/memory/memory.stat.         Self-hosted runner  Use the resource_class key to configure a  self-hosted runner instance.   For example:    jobs:
  job_name:
    machine: true
    resource_class: <my-namespace>/<my-runner>      Docker execution environment  Example:    jobs:
  build:
    docker:
      - image: cimg/base:2024.12
    resource_class: xlarge
    steps:
      ... // other config    x86     For credit and access information, see the  Resource classes page. Resource class access is dependent on your  Plan.       ClassvCPUsRAMCloudServersmall12GBmedium24GBmedium+36GBlarge48GBxlarge816GB2xlarge1632GB2xlarge+2040GB   Arm  Arm on Docker For pricing information, and a list of CircleCI Docker convenience images that support Arm resource classes, see the  Resource classes page.       Arm on Docker For credit and access information see the  Resource classes page. Resource class access is dependent on your  Plan   To find out which CircleCI Docker convenience images support Arm resource classes, you can refer to  Docker hub:     Select the image (for example, cimg/python).   Select the tags tab.   View what is supported under OS/ARCH for the latest tags. For example, cimg/python has linux/amd64 and linux/arm64, which means Arm is supported.          ClassvCPUsRAMCloudServerarm.medium28 GBarm.large416 GBarm.xlarge832 GBarm.2xlarge1664 GB     LinuxVM execution environment ClassvCPUsRAMDisk SizeCloudServermedium27.5 GB150GBlarge415 GB150GBxlarge832 GB150GB2xlarge1664 GB150GB2xlarge+3264 GB150GB  Example:  CloudServer    jobs:
  build:
    machine:
      image: ubuntu-2004:2024.01.2 # recommended linux image
    resource_class: large
    steps:
      ... // other config        jobs:
  build:
    machine: true
    resource_class: large
    steps:
      ... // other config         macOS execution environment ClassvCPUsRAMCloudServermacos.m1.medium.gen14 @ 3.2 GHz6GBmacos.m1.large.gen18 @ 3.2 GHz12GBm2pro.medium4 @ 3.49 GHz8GBm2pro.large8 @ 3.49 GHz16GB      We have deprecated support for all Intel-based macOS resources.   The macos.x86.medium.gen2 resource class was deprecated on June 28, 2024.   See our  announcement for more details.         Example    jobs:
  build:
    macos:
      xcode: "15.4.0"
    resource_class: m2pro.medium
    steps:
      ... // other config      macOS execution environment on server  If you are working on CircleCI server v3.1 and up, you can access the macOS execution environment using  self-hosted runner.     Windows execution environment ClassvCPUsRAMDisk SizeCloudServerwindows.medium (default)415GB200 GBwindows.large830GB200 GBwindows.xlarge1660GB200 GBwindows.2xlarge32128GB200 GB     Using server? Check with your systems administrator whether you have access to the Windows execution environment.        Example:  CloudServer    version: 2.1

jobs:
  build: # name of your job
    resource_class: 'windows.medium'
    machine:
      image: 'windows-server-2022-gui:current'
      shell: 'powershell.exe -ExecutionPolicy Bypass'
    steps:
      # Commands are run in a Windows virtual machine environment
      - checkout
      - run: Write-Host 'Hello, Windows'        version: 2.1

jobs:
  build: # name of your job
    machine:
      image: windows-default
    steps:
      # Commands are run in a Windows virtual machine environment
      - checkout
      - run: Write-Host 'Hello, Windows'         GPU execution environment (Linux) ClassvCPUsRAMGPUsGPU modelGPU Memory (GiB)Disk Size (GiB)CloudServergpu.nvidia.small4161NVIDIA Tesla P416150gpu.nvidia.small.gen24161NVIDIA A10G24150gpu.nvidia.small.multi4152NVIDIA Tesla T416150gpu.nvidia.medium.multi8304NVIDIA Tesla T416150gpu.nvidia.medium8301NVIDIA Tesla T416150gpu.nvidia.large8301NVIDIA Tesla V10016150  Example:    version: 2.1

jobs:
  build:
    machine:
      image: linux-cuda-12:default
    resource_class: gpu.nvidia.medium
    steps:
      - run: nvidia-smi
      - run: docker run --gpus all nvidia/cuda:9.0-base nvidia-smi    See the  Available Linux GPU images section for the full list of available images.     GPU execution-environment (Windows) ClassvCPUsRAMGPUsGPU modelGPU Memory (GiB)Disk Size (GiB)CloudServerwindows.gpu.nvidia.medium16601NVIDIA Tesla T416200  Example:    version: 2.1
orbs:
  win: circleci/windows@5.0.0

jobs:
  build:
    executor: win/server-2019-cuda
    steps:
      - checkout
      - run: '&"C:\Program Files\NVIDIA Corporation\NVSMI\nvidia-smi.exe"'    (2) This resource requires review by our support team.  Open a support ticket if you would like to request access.     Arm VM execution-environment ClassvCPUsRAMDisk SizeCloudServerarm.medium (default)28GB100 GBarm.large416GB100 GBarm.xlarge832GB100 GBarm.2xlarge1664GB100 GB     Using server? Check with your systems administrator whether you have access to the Arm execution environment.        Example:  CloudServer    jobs:
  my-job:
    machine:
      image: ubuntu-2004:2024.01.2
    resource_class: arm.medium
    steps:
      - run: uname -a
      - run: echo "Hello, Arm!"        jobs:
  my-job:
    machine:
      image: arm-default
    resource_class: arm.medium
    steps:
      - run: uname -a
      - run: echo "Hello, Arm!"          steps  The steps setting in a job should be a list of single key/value pairs, the key of which indicates the step type. The value may be either a configuration map or a string (depending on what that type of step requires). For example, using a map:    jobs:
  build:
    working_directory: ~/canary-python
    environment:
      FOO: bar
    steps:
      - run:
          name: Running tests
          command: make test    Here run is a step type. The name attribute is used by the UI for display purposes. The command attribute is specific for run step and defines command to execute.   Some steps may implement a shorthand semantic. For example, run may be also be called like this:    jobs:
  build:
    steps:
      - run: make test    In its short form, the run step allows us to directly specify which command to execute as a string value. In this case step itself provides default suitable values for other attributes (name here will have the same value as command, for example).   Another shorthand, which is possible for some steps, is to use the step name as a string instead of a key/value pair:    jobs:
  build:
    steps:
      - checkout    In this case, the checkout step will check out project source code into the job’s  working_directory.   In general all steps can be described as:  KeyRequiredTypeDescription<step_type>YMap or StringA configuration map for the step or some string whose semantics are defined by the step.  Each built-in step is described in detail below.    run  The run step is used to invoke command-line programs. The run step takes either a map of configuration values, or, when called in its short-form, a string that will be used as both the command and name. Run commands are executed using non-login shells by default, so you must explicitly source any dotfiles as part of the command.      the run step replaces the deprecated deploy step. If your job has a parallelism of 1, the deprecated deploy step can be swapped out directly for the run step. If your job has parallelism > 1, see  Migrate from deploy to run.       KeyRequiredTypeDescriptioncommandYStringCommand to run via the shellnameNStringTitle of the step to be shown in the CircleCI UI (default: full command)shellNStringShell to use for execution command (default: See  Default Shell Options)environmentNMapAdditional environmental variables, locally scoped to commandbackgroundNBooleanWhether or not this step should run in the background (default: false)working_directoryNStringIn which directory to run this step. Will be interpreted relative to the  working_directory of the job). (default: .)no_output_timeoutNStringElapsed time the command can run without output. The string is a decimal with unit suffix, such as "20m", "1.25h", "5s". The default is 10 minutes and the maximum is governed by the  maximum time a job is allowed to run.whenNString Specify when to enable or disable the step. Takes the following values: always, on_success, on_fail (default: on_success)  Each run declaration represents a new shell. It is possible to specify a multi-line command, each line of which will be run in the same shell:    - run:
    command: |
      echo Running test
      mkdir -p /tmp/test-results
      make test    You can also configure commands to run  in the background if you do not want to wait for the step to complete before moving on to subsequent run steps.    Default shell options  For jobs that run on Linux, the default value of the shell option is /bin/bash -eo pipefail if /bin/bash is present in the build container. Otherwise it is /bin/sh -eo pipefail. The default shell is not a login shell (--login or -l are not specified). Hence, the shell will not source your ~/.bash_profile, ~/.bash_login, ~/.profile files.   For jobs that run on macOS, the default shell is /bin/bash --login -eo pipefail. The shell is a non-interactive login shell. The shell will execute /etc/profile/ followed by ~/.bash_profile before every step.   For more information about which files are executed when Bash is invocated,  see the INVOCATION section of the bash manpage.   Descriptions of the -eo pipefail options are provided below.    -e  Exit immediately if any of the following exits with a non-zero status:     A pipeline (which may consist of a single simple command).   A subshell command enclosed in parentheses.   One of the commands executed as part of a command list enclosed by braces.     In the previous example, mkdir failed to create a directory and returned a non-zero status, then command execution would be terminated, and the whole step would be marked as failed. If you desire the opposite behaviour, you need to add set +e in your command or override the default shell in your configuration map of run. For example:    - run:
    command: |
      echo Running test
      set +e
      mkdir -p /tmp/test-results
      make test

- run:
    shell: /bin/sh
    command: |
      echo Running test
      mkdir -p /tmp/test-results
      make test     -o pipefail  If pipefail is enabled, the pipeline’s return status is the value of the last (rightmost) command to exit with a non-zero status, or zero if all commands exit successfully. The shell waits for all commands in the pipeline to terminate before returning a value.   For example:    - run: make test | tee test-output.log    If make test fails, the -o pipefail option will cause the whole step to fail. Without -o pipefail, the step will always run successfully because the result of the whole pipeline is determined by the last command (tee test-output.log), which will always return a zero status.      If make test fails the rest of pipeline will be executed.        If you want to avoid this behaviour, you can specify set +o pipefail in the command or override the whole shell (see example above).   In general, we recommend using the default options (-eo pipefail) because they show errors in intermediate commands and simplify debugging job failures. For convenience, the UI displays the used shell and all active options for each run step.   For more information, see the  Using Shell Scripts document.     Background commands  The background attribute enables you to configure commands to run in the background. Job execution will immediately proceed to the next step rather than waiting for return of a command with the background attribute set to true. The following example shows the configuration for running the X virtual framebuffer in the background which is commonly required to run Selenium tests:    - run:
    name: Running X virtual framebuffer
    command: Xvfb :99 -screen 0 1280x1024x24
    background: true

- run: make test      Shorthand syntax  run has a very convenient shorthand syntax:    - run: make test

# shorthanded command can also have multiple lines
- run: |
    mkdir -p /tmp/test-results
    make test    In this case, command and name become the string value of run, and the rest of the config map for that run have their default values.     The when attribute  By default, CircleCI will execute job steps one at a time, in the order that they are defined in config.yml, until a step fails (returns a non-zero exit code). After a command fails, no further job steps will be executed.   Adding the when attribute to a job step allows you to override this default behaviour, and selectively run or skip steps depending on the status of the job.   The when attribute accepts the following values:    on_success  The step will run only if all of the previous steps have been successful (returned exit code 0). on_success is the default value.  always  The step will run regardless of the exit status of previous steps. always is useful if you have a task that you want to run regardless of whether the previous steps are successful or not. For example, you might have a job step that needs to upload logs or code-coverage data somewhere.  on_fail  The step will run only if one of the preceding steps has failed (returns a non-zero exit code). A common use of on_fail is to store some diagnostic data to help debug test failures, or to run custom notifications about the failure, such as sending emails or triggering alerts.        Some steps, such as store_artifacts and store_test_results will always run, even if a step has failed (returned a non-zero exit code) previously. The when attribute, store_artifacts and store_test_results are not run if the job has been killed by a cancel request or has reached the runtime timeout limit.         - run:
    name: Upload CodeCov.io Data
    command: bash <(curl -s https://codecov.io/bash) -F unittests
    when: always # Uploads code coverage results, pass or fail      Ending a job from within a step  A job can exit without failing by using run: circleci-agent step halt. However, if a step within the job is already failing then the job will continue to fail. This can be useful in situations where jobs need to conditionally execute.   Here is an example where halt is used to avoid running a job on the develop branch:    - run: |
    if [ "$CIRCLE_BRANCH" = "develop" ]; then
        circleci-agent step halt
    fi       The when step     The when and unless steps are supported in version: 2.1 configuration        A conditional step consists of a step with the key when or unless. Under the when key are the subkeys condition and steps. The purpose of the when step is customizing commands and job configuration to run on custom conditions (determined at config-compile time) that are checked before a workflow runs. See the  Conditional Steps section of the reusable configuration reference for more details.  KeyRequiredTypeDescriptionconditionYLogic A logic statementstepsYSequenceA list of steps to execute when the condition is true  Example:    version: 2.1

jobs: # conditional steps may also be defined in `commands:`
  job_with_optional_custom_checkout:
    parameters:
      custom_checkout:
        type: string
        default: ""
    machine:
      image: ubuntu-2004:2024.11.1
    steps:
      - when:
          condition: <<parameters.custom_checkout>>
          steps:
            - run: echo "my custom checkout"
      - unless:
          condition: <<parameters.custom_checkout>>
          steps:
            - checkout
workflows:
  build-test-deploy:
    jobs:
      - job_with_optional_custom_checkout:
          custom_checkout: "any non-empty string is truthy"
      - job_with_optional_custom_checkout      checkout      Blobless clones   A "blobless" strategy is being rolled out to help improve the performance of code checkouts from Git source code hosts.   Blobless clones reduce the amount of data fetched from the remote, by asking the remote to filter out objects that are not attached to the current commit.   While this improves performance in most cases, if a downstream step requires those objects to exist for scanning or comparisons, it can cause failures. To work around these potential problems, a fetch directly after a checkout will ensure the required data is available:    - checkout
- run: git fetch          A special step used to check out source code to the configured path (defaults to the working_directory). The reason this is a special step is because it is more of a helper function designed to simplify the process of checking out code. If you require doing git over HTTPS you should not use this step as it configures git to checkout over SSH.  KeyRequiredTypeDescriptionpathNStringCheckout directory. Will be interpreted relative to the  working_directory of the job). (default: .)  If path already exists and is:     A git repository - step will not clone whole repository, instead will fetch origin   NOT a git repository - step will fail.     In the case of checkout, the step type is just a string with no additional attributes:    - checkout    The checkout command automatically adds the required authenticity keys for interacting with GitHub and Bitbucket over SSH. These keys are detailed further in the  integration guide. This guide is also helpful if you wish to implement a custom checkout command.   CircleCI does not check out submodules. If your project requires submodules, add run steps with appropriate commands as shown in the following example:    - checkout
- run: git submodule sync
- run: git submodule update --init       The checkout step will configure Git to skip automatic garbage collection. If you are caching your .git directory with  restore_cache and would like to use garbage collection to reduce its size, you may wish to use a  run step with command git gc before doing so.          setup_remote_docker  Allows Docker commands to be run locally. See  Running Docker commands for details.    jobs:
  build:
    docker:
      - image: cimg/base:2024.06
    steps:
      # ... steps for building/testing app ...
      - setup_remote_docker:
          version: default   KeyRequiredTypeDescriptiondocker_layer_cachingNbooleanSet this to true to enable  Docker Layer Caching in the Remote Docker Environment (default: false)versionNStringVersion string of Docker you would like to use (default: 24.0.9). View the list of supported Docker versions  here.        setup_remote_docker is not compatible with the machine executor. See  Docker Layer Caching in Machine Executor for information on how to enable DLC with the machine executor.   The version key is not currently supported on CircleCI server. Contact your system administrator for information about the Docker version installed in your remote Docker environment. If you are on server 4.x, you can find the default AWS AMI  here.             save_cache  Generates and stores a cache of a file or directory of files such as dependencies or source code in our object storage. Later jobs can  restore this cache. Learn more on the  Caching Dependencies page.   Cache retention can be customized on the  CircleCI web app by navigating to Plan  Usage Controls.  KeyRequiredTypeDescriptionpathsYListList of directories which should be added to the cachekeyYStringUnique identifier for this cachenameNStringTitle of the step to be shown in the CircleCI UI (default: "Saving Cache")whenNString Specify when to enable or disable the step. Takes the following values: always, on_success, on_fail (default: on_success)  The cache for a specific key is immutable and cannot be changed once written.      If the cache for the given key already exists it will not be modified, and job execution will proceed to the next step.        When storing a new cache, the key value may contain special, templated, values for your convenience:  TemplateDescription{{ .Branch }}The VCS branch currently being built.{{ .BuildNum }}The CircleCI build number for this build.{{ .Revision }}The VCS revision currently being built.{{ .CheckoutKey }}The SSH key used to checkout the repository.{{ .Environment.variableName }}The environment variable variableName (supports any environment variable  exported by CircleCI or added to a specific  context--not any arbitrary environment variable).{{ checksum "filename" }}A base64 encoded SHA256 hash of the given filename’s contents. This should be a file committed in your repository and may also be referenced as a path that is absolute or relative from the current working directory. Good candidates are dependency manifests, such as package-lock.json, pom.xml or project.clj. It is important that this file does not change between restore_cache and save_cache, otherwise the cache will be saved under a cache key different than the one used at restore_cache time.{{ epoch }}The current time in seconds since the UNIX epoch.{{ arch }}The OS and CPU information. Useful when caching compiled binaries that depend on OS and CPU architecture, for example, darwin amd64 versus linux i386/32-bit.  During step execution, the templates above will be replaced by runtime values and use the resultant string as the key.   Template examples:     myapp-{{ checksum "package-lock.json" }} - cache will be regenerated every time something is changed in package-lock.json file, different branches of this project will generate the same cache key.   myapp-{{ .Branch }}-{{ checksum "package-lock.json" }} - same as the previous one, but each branch will generate separate cache   myapp-{{ epoch }} - every run of a job will generate a separate cache     While choosing suitable templates for your cache key, keep in mind that:     Cache saving is not a free operation. See the billing section on the  FAQ page.   It takes time to upload the cache.     Best practice is to have a key that generates a new cache only if something actually changed and avoid generating a new one every time a job is run.      Given the immutability of caches, it might be helpful to start all your cache keys with a version prefix v1-.... That way you will be able to regenerate all your caches just by incrementing the version in this prefix.        Example:    - save_cache:
    key: v1-myapp-{{ arch }}-{{ checksum "project.clj" }}
    paths:
      - /home/ubuntu/.m2     - save_cache:
    key: v1-{{ checksum "yarn.lock" }}
    paths:
      - node_modules/workspace-a
      - node_modules/workspace-c          Wildcards are not currently supported in save_cache paths. Visit the  Ideas board and vote for this feature if it would be useful for you or your organization.   In some instances, a workaround for this is to save a particular workspace to cache:             restore_cache  Restores a previously saved cache based on a key. Cache needs to have been saved first for this key using the  save_cache step. Learn more in  the caching documentation.  KeyRequiredTypeDescriptionkeyY (1)StringSingle cache key to restorekeysY (1)ListList of cache keys to lookup for a cache to restore. Only first existing key will be restored.nameNStringTitle of the step to be shown in the CircleCI UI (default: "Restoring Cache")  (1) at least one attribute has to be present. If key and keys are both given, key will be checked first, and then keys.   A key is searched against existing keys as a prefix.      When there are multiple matches, the most recent match will be used, even if there is a more precise match.        For example:    steps:
  - save_cache:
      key: v1-myapp-cache
      paths:
        - ~/d1

  - save_cache:
      key: v1-myapp-cache-new
      paths:
        - ~/d2

  - run: rm -f ~/d1 ~/d2

  - restore_cache:
      key: v1-myapp-cache    In this case cache v1-myapp-cache-new will be restored because it’s the most recent match with v1-myapp-cache prefix even if the first key (v1-myapp-cache) has exact match.   For more information on key formatting, see the key section of  save_cache step.   When CircleCI encounters a list of keys, the cache will be restored from the first key matching an existing cache. We recommend you use a more specific key first (for example, cache for exact version of package-lock.json) and more generic keys after (for example, any cache for this project). If no key has a cache that exists, the step will be skipped with a warning.   A path is not required here because the cache will be restored to the location from which it was originally saved.   Example:    - restore_cache:
    keys:
      - v1-myapp-{{ arch }}-{{ checksum "project.clj" }}
      # if cache for exact version of `project.clj` is not present then load any most recent one
      - v1-myapp-

# ... Steps building and testing your application ...

# cache will be saved only once for each version of `project.clj`
- save_cache:
    key: v1-myapp-{{ arch }}-{{ checksum "project.clj" }}
    paths:
      - /foo      deploy - DEPRECATED  See  run for current processes. If you have parallelism > 1 in your job, see the  Migrate from deploy to run guide.     store_artifacts  Step to store artifacts (for example logs, binaries, etc) to be available in the web app or through the API. See the  Uploading Artifacts page for more information.  KeyRequiredTypeDescriptionpathYStringDirectory in the primary container to save as job artifactsdestinationNStringPrefix added to the artifact paths in the artifacts API (default: the directory of the file specified in path)  There can be multiple store_artifacts steps in a job. Using a unique prefix for each step prevents them from overwriting files.   Artifact storage retention can be customized on the  CircleCI web app by navigating to Plan  Usage Controls.   Example:    - run:
    name: Build the Jekyll site
    command: bundle exec jekyll build --source jekyll --destination jekyll/_site/docs/
- store_artifacts:
    path: jekyll/_site/docs/
    destination: circleci-docs      store_test_results  Special step used to upload and store test results for a build. Test results are visible on the CircleCI web application under each build’s Test Summary section. Storing test results is useful for timing analysis of your test suites. For more information on storing test results, see the  Collecting Test Data page.   You can also store test results as build artifacts. For steps, refer to  the store_artifacts step section.  KeyRequiredTypeDescriptionpathYStringPath (absolute, or relative to your working_directory) to directory containing JUnit XML test metadata files, or to a single test file.  Example:   Directory structure:    test-results
├── jest
│   └── results.xml
├── mocha
│   └── results.xml
└── rspec
    └── results.xml    config.yml syntax:    - store_test_results:
    path: test-results      persist_to_workspace  Special step used to persist a temporary file to be used by another job in the workflow. For more information on using workspaces, see the  Using Workspaces to Share Data Between Jobs page.   persist_to_workspace adopts the storage settings from the storage customization controls on the CircleCI web app. If no custom setting is provided, persist_to_workspace defaults to 15 days.   Workspace storage retention can be customized on the  CircleCI web app by navigating to Plan  Usage Controls.  KeyRequiredTypeDescriptionrootYStringEither an absolute path or a path relative to working_directorypathsYListGlob identifying file(s), or a non-glob path to a directory to add to the shared workspace. Interpreted as relative to the workspace root. Must not be the workspace root itself.  The root key is a directory on the container which is taken to be the root directory of the workspace. The path values are all relative to the root.   Example for root Key   For example, the following step syntax persists the specified paths from /tmp/dir into the workspace, relative to the directory /tmp/dir.    - persist_to_workspace:
    root: /tmp/dir
    paths:
      - foo/bar
      - baz    After this step completes, the following directories are added to the workspace:    /tmp/dir/foo/bar
/tmp/dir/baz    Example for paths Key    - persist_to_workspace:
    root: /tmp/workspace
    paths:
      - target/application.jar
      - build/*    The paths list uses Glob from Go, and the pattern matches  filepath.Match.    pattern:
        { term }
term:
        '*' matches any sequence of non-Separator characters
        '?' matches any single non-Separator character
        '[' [ '^' ] { character-range }
        ']' character class (must be non-empty)
        c matches character c (c != '*', '?', '\\', '[')
        '\\' c matches character c
character-range:
        c matches character c (c != '\\', '-', ']')
        '\\' c matches character c
        lo '-' hi matches character c for lo <= c <= hi    The Go documentation states that the pattern may describe hierarchical names such as /usr/*/bin/ed (assuming the Separator is '/').      Everything must be relative to the work space root directory.          attach_workspace  Special step used to attach the workflow’s workspace to the current container. The full contents of the workspace are downloaded and copied into the directory the workspace is being attached at. For more information on using workspaces, see the  Using workspaces page.  KeyRequiredTypeDescriptionatYStringDirectory to attach the workspace to.  Workspace storage retention can be customized on the  CircleCI web app by navigating to Plan  Usage Controls.   Example:    - attach_workspace:
    at: /tmp/workspace       The lifetime of artifacts, workspaces, and caches can be customized on the  CircleCI web app by navigating to Plan  Usage Controls. Here you can control the storage retention periods for these objects. If no storage period is set, the default storage retention period of artifacts is 30 days, while the default storage retention period of workspaces and caches is 15 days.          add_ssh_keys  Special step that adds SSH keys from a project’s settings to a container. Also configures SSH to use these keys. For more information on SSH keys see the  Create additional GitHub SSH keys page.      Using server? only MD5 fingerprints are supported. In CircleCI in Project Settings  SSH keys  Additional SSH keys the MD5 fingerprint will be visible. SHA256 support is planned for an upcoming server release.       KeyRequiredTypeDescriptionfingerprintsNListList of fingerprints corresponding to the keys to be added (default: all keys added)   steps:
  - add_ssh_keys:
      fingerprints:
        - "b7:35:a6:4e:9b:0d:6d:d4:78:1e:9a:97:2a:66:6b:be"
        - "SHA256:NPj4IcXxqQEKGXOghi/QbG2sohoNfvZ30JwCcdSSNM0"       Even though CircleCI uses ssh-agent to sign all added SSH keys, you must use the add_ssh_keys key to actually add keys to a container.          Using pipeline values  Pipeline values are available to all pipeline configurations and can be used without previous declaration. For a list of pipeline values, see the  Pipeline values and parameters page.   Example:    version: 2.1
jobs:
  build:
    docker:
      - image: cimg/node:20.18.1
    environment:
      IMAGETAG: latest
    working_directory: ~/main
    steps:
      - run: echo "This is pipeline ID << pipeline.id >>"       circleci_ip_ranges     A paid account on a  Performance or Scale Plan is required to access IP ranges.        Enables jobs to go through a set of well-defined IP address ranges. See  IP ranges for details.   Example:    version: 2.1

jobs:
  build:
    circleci_ip_ranges: true # opts the job into the IP ranges feature
    docker:
      - image: curlimages/curl
    steps:
      - run: echo “Hello World”
workflows:
  build-workflow:
    jobs:
      - build         workflows   Used for orchestrating all jobs. Each workflow consists of the workflow name as a key and a map as a value. A name should be unique within the current config.yml. The top-level keys for the Workflows configuration are version and jobs. For more information, see the  Using Workflows to Orchestrate Jobs page.    version     The workflows version key is not required for version: 2.1 configuration        The Workflows version field is used to issue warnings for deprecation or breaking changes.  KeyRequiredTypeDescriptionversionY if config version is 2StringShould currently be 2    <workflow_name>  A unique name for your workflow.    triggers  Specifies which triggers will cause this workflow to be executed. Default behavior is to trigger the workflow when pushing to a branch.  KeyRequiredTypeDescriptiontriggersNArrayShould currently be schedule.   workflows:
   nightly:
     triggers:
       - schedule:
           cron: "0 0 * * *"
           filters:
             branches:
               only:
                 - main
                 - beta
     jobs:
       - test     schedule     Scheduled workflows are not available for projects integrated through the GitHub App, GitLab or Bitbucket Data Center.           The scheduled workflows feature is set to be deprecated. Using scheduled pipelines rather than scheduled workflows offers several benefits. Visit the scheduled pipelines  migration guide to find out how to migrate existing scheduled workflows to scheduled pipelines. If you would like to set up scheduled pipelines from scratch, visit the  Scheduled pipelines page.        A workflow may have a schedule indicating it runs at a certain time, for example a nightly build that runs every day at 12am UTC:    workflows:
   nightly:
     triggers:
       - schedule:
           cron: "0 0 * * *"
           filters:
             branches:
               only:
                 - main
                 - beta
     jobs:
       - test     cron  The cron key is defined using POSIX crontab syntax.  KeyRequiredTypeDescriptioncronYStringSee the  crontab man page.   workflows:
   nightly:
     triggers:
       - schedule:
           cron: "0 0 * * *"
           filters:
             branches:
               only:
                 - main
                 - beta
     jobs:
       - test      filters  Trigger filters can have the key branches.  KeyRequiredTypeDescriptionfiltersYMapA map defining rules for execution on specific branches   workflows:
   nightly:
     triggers:
       - schedule:
           cron: "0 0 * * *"
           filters:
             branches:
               only:
                 - main
                 - beta
     jobs:
       - test      branches  The branches key controls whether the current branch should have a schedule trigger created for it, where current branch is the branch containing the config.yml file with the trigger stanza. That is, a push on the main branch will only schedule a  workflow for the main branch.   Branches can have the keys only and ignore which each map to a single string naming a branch. You may also use regular expressions to match against branches by enclosing them with `/’s, or map to a list of such strings. Regular expressions must match the entire string.     Any branches that match only will run the job.   Any branches that match ignore will not run the job.   If neither only nor ignore are specified then all branches will run the job. If both only and ignore are specified, the only is used and ignore will have no effect.      workflows:
  commit:
    jobs:
      - test
      - deploy
  nightly:
    triggers:
      - schedule:
          cron: "0 0 * * *"
          filters:
            branches:
              only:
                - main
                - /^release\/.*/
    jobs:
      - coverage   KeyRequiredTypeDescriptionbranchesYMapA map defining rules for execution on specific branchesonly 1NString, or List of StringsEither a single branch specifier, or a list of branch specifiersignore 1NString, or List of StringsEither a single branch specifier, or a list of branch specifiers  1: One of either only or ignore branch filters must be specified. If both are present, only is used.       Using when in workflows     Using when or unless under workflows is supported in version: 2.1 configuration. Workflows are always run unless there is a when or unless filter that prevents the workflow from being run. If you want a workflow to run in every pipeline, do not add a when or unless filter.        You may use a when clause (the inverse clause unless is also supported) under a workflow declaration with a  logic statement to determine whether or not to run that workflow.   The example configuration below uses a pipeline parameter, run_integration_tests to drive the integration_tests workflow.    version: 2.1

workflows:
  integration_tests:
    when: pipeline.git.branch == "main"
    jobs:
      - mytestjob

jobs:
...    This example prevents the workflow integration_tests from running unless the pipeline is triggered on the main branch.   Refer to the  Workflows for more examples and conceptual information.     jobs  A job can have the keys requires, name, context, type, and filters.  KeyRequiredTypeDescriptionjobsYListA list of jobs to run with their dependencies   <job_name>  A job name that exists in your config.yml.    serial-group  The serial-group key is used to add a property to a job to allow a group of jobs to run in series, rather than concurrently, across an organization. Serial groups control the orchestration of jobs across an organization, not just within projects and pipelines.   The serial-group key is configurable per job. It is not possible to configure the key for a group of jobs at this time.   The value of the serial-group key is a string that is used to group jobs together to run one after another. The key must meet the following requirements:     Must be less than or equal to (≤) 512 characters, once compiled.   Must not be blank.   Must consist of alphanumeric characters plus, ., -, _, /.     Note the following features of serial groups:     You can use pipeline values and parameters in the serial-group key.   Serial groups will wait for five hours. After this jobs waiting in the group will be cancelled. This does not affect the standard limits that apply to a  job’s runtime.         Pipeline order protection in serial groups   Jobs in a serial group follow an order protection mechanism, as follows:     Jobs start in the order they join the queue, but are accepted based on pipeline number.   If a group is waiting/running and another job in the same project attempts to join the queue with a lower pipeline number, the job is skipped.   This immediate skip process exists to maintain order integrity, which is a safety process to avoid unexpected work in a build, for example, a deployment job running a previous version unexpectedly.     If there are no serial groups waiting/running, a pipeline with a lower number can start, such as restoring back to a previous pipeline via a rerun workflow.        KeyRequiredTypeDescriptionserial-groupNStringA string that is used across an org to group jobs together to run one after another. Can include pipeline values and parameters. Use this same serial group across multiple pipelines to control the orchestration of jobs across an organization.  Example:    # Creating multiple pipelines at the same time with the below config will results in
# all pipelines running test and build but only a single pipeline will run deploy at a time.

workflows:
  main-workflow:
    jobs:
      - test
      - build
      - deploy:
          serial-group: << pipeline.project.slug >>/deploy-group
          requires:
            - test
            - build    For more information, see the  Controlling serial execution across your organization page. '''    requires  Jobs are run concurrently by default, so you must explicitly require any dependencies by their job name if you need some jobs to run sequentially.  KeyRequiredTypeDescriptionrequiresNList A list of jobs that must succeed or attain a specified status for the job to start. Note: When jobs in the current workflow that are listed as dependencies are not executed (due to a filter function for example), their requirement as a dependency for other jobs will be ignored by the requires option. However, if all dependencies of a job are filtered, then that job will not be executed either.   Possible types of requires items:     Job name (a required job that must succeed for the job to start)   Map of job name to status (a required job that must attain the specified status for the job to start)   Map of job name to a list of statuses (a required job that must attain one of the specified status for the job to start)     The possible status values are: success, failed and canceled.    workflows:
  my-workflow:
    jobs:
      - build
      - test:
          requires:
            - build
      - deploy:
          requires:
            - build
            - test
      - notify-build-canceled:
          requires:
            - build: canceled
      - cleanup:
          requires:
            - deploy:
              - failed
              - canceled      name  The name key can be used to invoke reusable jobs across any number of workflows. Using the name key ensures numbers are not appended to your job name (for example, sayhello-1 , sayhello-2, etc.). The name you assign to the name key needs to be unique, otherwise the numbers will still be appended to the job name.  KeyRequiredTypeDescriptionnameNStringA replacement for the job name. Useful when calling a job multiple times. If you want to invoke the same job multiple times, and a job requires one of the duplicate jobs, this key is required. (2.1 only)    context  Jobs may be configured to use global environment variables set for an organization, see the  Contexts document for adding a context in the application settings.  KeyRequiredTypeDescriptioncontextNString/ListThe name of the context(s). The initial default name is org-global. Each context name must be unique. If using CircleCI server, only a single context per workflow is supported. Note: A maximum of 100 unique contexts across all workflows is allowed.    type  A job may have a type of approval indicating it must be manually approved before downstream jobs may proceed. For more information see the  Using workflows to orchestrate jobs page.   Jobs run in the dependency order until the workflow processes a job with the type: approval key followed by a job on which it depends, for example:    workflows:
  my-workflow:
    jobs:
      - build
      - test:
          requires:
            - build
      - hold:
          type: approval
          requires:
            - test
      - deploy:
          requires:
            - hold    An approval job can have any name. In the example above the approval job is named hold. The name you choose for an approval job should not be used to define a job in the main configuration. An approval job only exists as a workflow orchestration devise.     filters  Filter job execution within a workflow based on the following:     Branch   Tag   Expression-based condition     Job filters can have the keys branches or tags.      Workflows will ignore job-level branching. If you use job-level branching and later add workflows, you must remove the branching at the job level and instead declare it in the workflows section of your config.yml.       KeyRequiredTypeDescriptionfiltersNMapA map or string to define rules for job execution. Branch and tag filters require a map. Expression-based filters require a string.  The following is an example of how the CircleCI documentation project uses a regular expression to filter running a job in a workflow only on a specific branch:    # ...
workflows:
  build-deploy:
    jobs:
      - js_build
      - build_server_pdfs: # << the job to conditionally run based on the filter-by-branch-name.
          filters:
            branches:
              only: /server\/.*/ # the job build_server_pdfs will only run when the branch being built starts with server/    You can read more about using regular expressions in your config in the  Using workflows to schedule jobs page.     Expression-based job filters  Expression-based job filters allow you to conditionally run jobs based on the following:      Pipeline values    Pipeline parameters     An expression-based job filter is a rule that is evaluated against pipeline values and parameters to decide whether a job should run.   Using expression-based job filters is one way to optimize your pipelines. Optimizations include the following:     Lower costs.   Decrease time to feedback.   Run specific jobs based on the context of the source of change.      workflows:
  deploy:
    jobs:
      - init-service
      - test-service
      - build-service-image:
          requires:
            - init-service
      - dry-run-service:
          requires:
            - init-service
          filters: pipeline.git.branch != "main" and pipeline.git.branch != "canary"
      - publish-service:
          requires:
            - build-service-image
            - test-service
          filters: pipeline.git.branch == "main" or pipeline.git.tag starts-with "release"
      - deploy-service:
          context:
            - org-global
          requires:
            - publish-service
          filters: pipeline.git.branch == "main" and pipeline.parameters.my-custom-param starts-with "DEPLOY:"    Examples   Only run the job on the project’s main branch:    filters: pipeline.git.branch == "main"    Only run the job on the project’s main branch, or branches starting with integration-test:    filters: pipeline.git.branch == "main" or pipeline.git.branch starts-with "integration-test"    Only run the job on the main branch, and disallow use with pipelines  triggered with unversioned configuration:    filters: pipeline.git.branch == "main" and not (pipeline.trigger_source starts-with "api")    Use pipeline parameters and the pipeline value pipeline.git.branch to run a job only on specific branches or when triggered via the API with a pipeline parameter set to true:    version: 2.1

parameters:
  run-storybook-tests:
    type: boolean
    default: false

...
# jobs configuration ommitted for brevity

workflows:
  build:
    jobs:
      - setup
      - storybook-tests:
          requires:
            - setup
          filters: |
            pipeline.parameters.run-storybook-tests
            or pipeline.git.branch == "dry-run-deploy"
            or pipeline.git.branch starts-with "deploy"    You can use the API to trigger a pipeline with a pipeline parameter set to true:      Using server? If you are using CircleCI server, replace https://circleci.com with your server hostname when interacting with the CircleCI API.         curl -X POST https://circleci.com/api/v2/project/circleci/<org-id>/<project-id>/pipeline/run \
  --header "Circle-Token: $CIRCLE_TOKEN" \
  --header "content-type: application/json" \
  --data {
  "definition_id": "<pipeline-definition-id>",
  "config": {"branch": "<your-branch-name>"},
  "checkout": {"branch": "<your-branch-name>"},
  "parameters": {"run-storybook-tests": "true"}
  }    Operators   The operators you can use for expression-based job filters are described in the following table. You can also group sub-expressions with parentheses (, ). as in the examples above.  Operator typeOperatorsDescriptionLogicaland, orThese are short-circuiting boolean operators.Equality==, !=String, numeric, and boolean equality. If the operands are of different types then == will evaluate false, and != will evaluate true.Equalitystarts-withString prefix equality, "hello world" starts-with "hello" evaluates as true. It is an error to use a non-string type as an operand.Numeric comparison>=, >, ⇐, <Numeric comparisons. It is an error to use a non-numeric type as an operand.Negationnot Boolean negation.   Note that not has very high precedence and so binds very tightly. Use sub-expressions to apply not to more complex expressions. For example, with foo being true and bar being false:     not foo and bar evaluates to false   not (foo and bar) evaluates to true       branches  The branches filter can have the keys only and ignore, which map to a single string naming a branch. You may also use regular expressions to match against branches by enclosing them with slashes, or map to a list of such strings. Regular expressions must match the entire string.     Any branches that match only will run the job.   Any branches that match ignore will not run the job.   If neither only nor ignore are specified then all branches will run the job.   If both only and ignore are specified the only is considered before ignore.    KeyRequiredTypeDescriptionbranchesNMapA map defining rules for execution on specific branches.onlyNString, or list of stringsEither a single branch specifier, or a list of branch specifiers.ignoreNString, or list of stringsEither a single branch specifier, or a list of branch specifiers.   workflows:
  dev_stage_pre-prod:
    jobs:
      - test_dev:
          filters:  # using regex filters requires the entire branch to match
            branches:
              only:  # only branches matching the below regex filters will run
                - dev
                - /user-.*/
      - test_stage:
          filters:
            branches:
              only: stage
      - test_pre-prod:
          filters:
            branches:
              only: /pre-prod(?:-.+)?$/      tags  CircleCI does not run workflows for tags unless you explicitly specify tag filters. If a job requires any other jobs (directly or indirectly), you must specify tag filters for those jobs.   Tags can have the keys only and ignore. You may also use regular expressions to match against tags by enclosing them with slashes, or map to a list of such strings. Regular expressions must match the entire string. Both lightweight and annotated tags are supported.     Any tags that match only will run the job.   Any tags that match ignore will not run the job.   If neither only nor ignore are specified then the job is skipped for all tags.   If both only and ignore are specified the only is considered before ignore.    KeyRequiredTypeDescriptiontagsNMapA map defining rules for execution on specific tagsonlyNString, or List of StringsEither a single tag specifier, or a list of tag specifiersignoreNString, or List of StringsEither a single tag specifier, or a list of tag specifiers  For more information, see the  Executing workflows for a git tag section of the Workflows page.    workflows:
  untagged-build:
    jobs:
      - build
  tagged-build:
    jobs:
      - build:
          filters:
            tags:
              only: /^v.*/      matrix     The matrix key is supported in version: 2.1 configuration        The matrix stanza allows you to run a parameterized job multiple times with different arguments. For more information see the how-to guide on  Using Matrix Jobs. In order to use the matrix stanza, you must use parameterized jobs.  KeyRequiredTypeDescriptionparametersYMapA map of parameter names to every value the job should be called withexcludeNListA list of argument maps that should be excluded from the matrixaliasNStringAn alias for the matrix, usable from another job’s requires stanza. Defaults to the name of the job being executed  Example:   The following is a basic example of using matrix jobs.    workflows:
  workflow:
    jobs:
      - build:
          matrix:
            parameters:
              version: ["0.1", "0.2", "0.3"]
              platform: ["macos", "windows", "linux"]    This expands to 9 different build jobs, and could be equivalently written as:    workflows:
  workflow:
    jobs:
      - build:
          name: build-macos-0.1
          version: "0.1"
          platform: macos
      - build:
          name: build-macos-0.2
          version: "0.2"
          platform: macos
      - build:
          name: build-macos-0.3
          version: "0.3"
          platform: macos
      - build:
          name: build-windows-0.1
          version: "0.1"
          platform: windows
      - ...      Excluding sets of parameters from a matrix  Sometimes you may wish to run a job with every combination of arguments except some value or values. You can use an exclude stanza to achieve this:    workflows:
  workflow:
    jobs:
      - build:
          matrix:
            parameters:
              a: [1, 2, 3]
              b: [4, 5, 6]
            exclude:
              - a: 3
                b: 5    The matrix above would expand into 8 jobs: every combination of the parameters a and b, excluding {a: 3, b: 5}     Dependencies and matrix jobs  To require an entire matrix (every job within the matrix), use its alias. The alias defaults to the name of the job being invoked.    workflows:
  workflow:
    jobs:
      - deploy:
          matrix:
            parameters:
              version: ["0.1", "0.2"]
      - another-job:
          requires:
            - deploy    This means that another-job will require both deploy jobs in the matrix to finish before it runs.   Matrix jobs expose their parameter values via << matrix.* >> which can be used to generate more complex workflows. For example, here is a deploy matrix where each job waits for its respective build job in another matrix.    workflows:
  workflow:
    jobs:
      - build:
          name: build-v<< matrix.version >>
          matrix:
            parameters:
              version: ["0.1", "0.2"]
      - deploy:
          name: deploy-v<< matrix.version >>
          matrix:
            parameters:
              version: ["0.1", "0.2"]
          requires:
            - build-v<< matrix.version >>    This workflow will expand to:    workflows:
  workflow:
    jobs:
      - build:
          name: build-v0.1
          version: "0.1"
      - build:
          name: build-v0.2
          version: "0.2"
      - deploy:
          name: deploy-v0.1
          version: "0.1"
          requires:
            - build-v0.1
      - deploy:
          name: deploy-v0.2
          version: "0.2"
          requires:
            - build-v0.2      pre-steps and post-steps     Pre-steps and post-steps are supported in version: 2.1 configuration        Every job invocation in a workflow may optionally accept two special arguments: pre-steps and post-steps.   Steps under pre-steps are executed before any of the other steps in the job. The steps under post-steps are executed after all of the other steps.   Pre and post steps allow you to execute steps in a given job without modifying the job. Pre and post steps are useful, for example, to run custom setup steps before job execution.    version: 2.1

jobs:
  bar:
    machine:
      image: ubuntu-2004:2024.05.1
    steps:
      - checkout
      - run:
          command: echo "building"
      - run:
          command: echo "testing"

workflows:
  build:
    jobs:
      - bar:
          pre-steps: # steps to run before steps defined in the job bar
            - run:
                command: echo "install custom dependency"
          post-steps: # steps to run after steps defined in the job bar
            - run:
                command: echo "upload artifact to s3"           Logic statements   Certain dynamic configuration features accept logic statements as arguments. Logic statements are evaluated to boolean values at configuration compilation time, that is, before the workflow is run. The group of logic statements includes:  TypeArgumentstrue ifExampleYAML literalNoneis truthytrue/42/"a string"YAML aliasNoneresolves to a truthy value*my-alias Pipeline ValueNoneresolves to a truthy value<< pipeline.git.branch >> Pipeline ParameterNoneresolves to a truthy value<< pipeline.parameters.my-parameter >>andN logic statementsall arguments are truthyand: [ true, true, false ]orN logic statementsany argument is truthyor: [ false, true, false ]not1 logic statementthe argument is not truthynot: trueequalN valuesall arguments evaluate to equal valuesequal: [ 42, << pipeline.number >>]matchespattern and valuevalue matches the patternmatches: { pattern: "^feature-.$", value: << pipeline.git.branch >> }+  The following logic values are considered falsy:     false   null   0   NaN   empty strings ("")   statements with no arguments     All other values are truthy. Also note that using logic with an empty list will cause a validation error.   Logic statements always evaluate to a boolean value at the top level, and coerce as necessary. They can be nested in an arbitrary fashion, according to their argument specifications, and to a maximum depth of 100 levels.   matches uses  Java regular expressions for its pattern. A full match pattern must be provided, prefix matching is not an option. Though, it is recommended to enclose a pattern in ^ and $ to avoid accidental partial matches.      When using logic statements at the workflow level, do not include the condition: key (the condition key is only needed for job level logic statements).         workflows:
  my-workflow:
    when:
      or:
        - equal: [ main, << pipeline.git.branch >> ]
        - equal: [ staging, << pipeline.git.branch >> ]    Logic statement examples  You can find usage examples on the  "Orchestration cookbook" page.      Example full configuration      Using Docker? Authenticating Docker pulls from image registries is recommended when using the Docker execution environment. Authenticated pulls allow access to private Docker images, and may also grant higher rate limits, depending on your registry provider. For further information see  Using Docker authenticated pulls.         version: 2.1
jobs:
  build:
    docker:
      - image: ubuntu:23.04

      - image: mongo:6.0.14
        command: [mongod, --smallfiles]

      - image: postgres:14.12
        # some containers require setting environment variables
        environment:
          POSTGRES_USER: user

      - image: redis@sha256:54057dd7e125ca41afe526a877e8bd35ec2cdd33b9217e022ed37bdcf7d09673

      - image: rabbitmq:3.12.12

    environment:
      TEST_REPORTS: /tmp/test-reports

    working_directory: ~/my-project

    steps:
      - checkout

      - run:
          command: echo 127.0.0.1 devhost | sudo tee -a /etc/hosts

      # Create Postgres users and database
      # Note the YAML heredoc '|' for nicer formatting
      - run: |
          sudo -u root createuser -h localhost --superuser ubuntu &&
          sudo createdb -h localhost test_db

      - restore_cache:
          keys:
            - v1-my-project-{{ checksum "project.clj" }}
            - v1-my-project-

      - run:
          environment:
            SSH_TARGET: "localhost"
            TEST_ENV: "linux"
          command: |
            set -xu
            mkdir -p ${TEST_REPORTS}
            run-tests.sh
            cp out/tests/*.xml ${TEST_REPORTS}

      - run: |
          set -xu
          mkdir -p /tmp/artifacts
          create_jars.sh << pipeline.number >>
          cp *.jar /tmp/artifacts

      - save_cache:
          key: v1-my-project-{{ checksum "project.clj" }}
          paths:
            - ~/.m2

      # Save artifacts
      - store_artifacts:
          path: /tmp/artifacts
          destination: build

      # Upload test results
      - store_test_results:
          path: /tmp/test-reports

  deploy-stage:
    docker:
      - image: ubuntu:23.04
    working_directory: /tmp/my-project
    steps:
      - run:
          name: Deploy if tests pass and branch is Staging
          command: ansible-playbook site.yml -i staging

  deploy-prod:
    docker:
      - image: ubuntu:23.04
    working_directory: /tmp/my-project
    steps:
      - run:
          name: Deploy if tests pass and branch is Main
          command: ansible-playbook site.yml -i production

workflows:
  build-deploy:
    jobs:
      - build:
          filters:
            branches:
              ignore:
                - develop
                - /feature-.*/
      - deploy-stage:
          requires:
            - build
          filters:
            branches:
              only: staging
      - deploy-prod:
          requires:
            - build
          filters:
            branches:
              only: main    Suggest an edit to this pageMake a contribution Learn how to contributeStill need help? Ask the CircleCI community Join the research community Visit our Support site\n\nConfiguration reference1 week agoCloudServer v4+Helpful Resources6 config optimization tipsIntro to dynamic configUsing dynamic configValidate your config using local CLIHow to trigger a single jobOn This Pageversionsetuporbscommandsparametersexecutorsjobs<job_name>typeenvironmentparallelismparametersExecutor docker / machine / macosdockerDocker registry authenticationAWS authenticationUse OIDCUse environment variablesmachineAvailable Linux machine imagesAvailable Linux machine images on serverAvailable Linux GPU machine imagesAvailable Android machine imagesAvailable Windows machine imagesAvailable Windows machine images on serverAvailable Windows GPU machine imagemacosbranches - DEPRECATEDresource_classSelf-hosted runnerDocker execution environmentx86ArmLinuxVM execution environmentmacOS execution environmentmacOS execution environment on serverWindows execution environmentGPU execution environment (Linux)GPU execution-environment (Windows)Arm VM execution-environmentstepsrunDefault shell options-e-o pipefailBackground commandsShorthand syntaxThe when attributeEnding a job from within a stepThe when stepcheckoutsetup_remote_dockersave_cacherestore_cachedeploy - DEPRECATEDstore_artifactsstore_test_resultspersist_to_workspaceattach_workspaceadd_ssh_keysUsing pipeline valuescircleci_ip_rangesworkflowsversion<workflow_name>triggersschedulecronfiltersbranchesUsing when in workflowsjobs<job_name>serial-grouprequiresnamecontexttypefiltersExpression-based job filtersbranchestagsmatrixExcluding sets of parameters from a matrixDependencies and matrix jobspre-steps and post-stepsLogic statementsLogic statement examplesExample full configuration   This document is a reference for the CircleCI 2.x configuration keys that are used in the .circleci/config.yml file.   You can see a complete config.yml in our  full example.      version  KeyRequiredTypeDescriptionversionYString2, 2.0, or 2.1 See the  Reusable configuration page for an overview of 2.1 keys available to simplify your .circleci/config.yml file, reuse, and parameterized jobs.  The version field is intended to be used in order to issue warnings for deprecation or breaking changes.      setup  KeyRequiredTypeDescriptionsetupNBooleanDesignates the config.yaml for use of CircleCI’s  dynamic configuration feature.  The setup field enables you to conditionally trigger configurations from outside the primary .circleci parent directory, update pipeline parameters, or generate customized configurations.      orbs      The orbs key is supported in version: 2.1 configuration       KeyRequiredTypeDescriptionorbsNMapA map of user-selected names to either: orb references (strings) or orb definitions (maps). Orb definitions must be the orb-relevant subset of 2.1 config. See the  Creating Orbs documentation for details.executorsNMapA map of strings to executor definitions. See the  executors section below.commandsNMapA map of command names to command definitions. See the  commands section below.  The following example uses the node orb that exists in the certified circleci namespace. Refer to the Node orb page in the  Orb Registry for more examples and information.    version: 2.1

orbs:
  node: circleci/node@x.y

jobs:
  install-node-example:
    docker:
      - image: cimg/base:stable
    steps:
      - checkout
      - node/install:
          install-yarn: true
          node-version: '16.13'
      - run: node --version
workflows:
  test_my_app:
    jobs:
      - install-node-example    Documentation is available for orbs in the following sections:      Using Orbs    Authoring Orbs.     Public orbs are listed in the  Orb Registry.      commands      The commands key is supported in version: 2.1 configuration        A command defines a sequence of steps as a map to be executed in a job, enabling you to reuse a single command definition across multiple jobs. For more information see the  Reusable Config Reference Guide.  KeyRequiredTypeDescriptionstepsYSequenceA sequence of steps run inside the calling job of the command.parametersNMapA map of parameter keys. See the  Parameter Syntax section of the  Reusing Config document for details.descriptionNStringA string that describes the purpose of the command.  Example:    commands:
  sayhello:
    description: "A very simple command for demonstration purposes"
    parameters:
      to:
        type: string
        default: "Hello World"
    steps:
      - run: echo << parameters.to >>       parameters      The pipeline parameters key is supported in version: 2.1 configuration        Pipeline parameters declared for use in the configuration. See  Pipeline Values and Parameters for usage details.  KeyRequiredTypeDescriptionparametersNMapA map of parameter keys. Supports string, boolean, integer and enum types. See  Parameter Syntax for details.     executors      The executors key is supported in version: 2.1 configuration        Executors define the execution environment in which the steps of a job will be run, allowing you to reuse a single executor definition across multiple jobs.  KeyRequiredTypeDescriptiondockerY (1)ListOptions for  Docker executorresource_classNStringAmount of CPU and RAM allocated to each container in a job.machineY (1)MapOptions for  machine executormacosY (1)MapOptions for  macOS executorwindowsY (1)Map Windows executor currently working with orbs. Check out  the orb.shellNStringShell to use for execution command in all steps. Can be overridden by shell in each step (default: See  Default Shell Options)working_directoryNStringIn which directory to run the steps. Will be interpreted as an absolute path.environmentNMapA map of environment variable names and values.  (1) One executor type should be specified per job. If more than one is set you will receive an error.   Example:    version: 2.1
executors:
  my-executor:
    docker:
      - image: cimg/ruby:3.0.3-browsers

jobs:
  my-job:
    executor: my-executor
    steps:
      - run: echo "Hello executor!"    See the  Using Parameters in Executors section of the  Reusing config page for examples of parameterized executors.      jobs   A Workflow is comprised of one or more uniquely named jobs. Jobs are specified in the jobs map, see  Sample config.yml for two examples of a job map. The name of the job is the key in the map, and the value is a map describing the job.   Jobs have a maximum runtime based on pricing plan, as follows:     1 hour (Free)   3 hours (Performance)   5 hours (Scale)     If your jobs are timing out, consider the following:     A larger  resource_class.   Using  parallelism.   Run some of your jobs concurrently using  workflows.   You can upgrade your pricing plan.      <job_name>  Each job consists of the job’s name as a key and a map as a value. A name should be case insensitive unique within a current jobs list. The value map has the following attributes:  KeyRequiredTypeDescriptiontypeNStringJob type, can be build, release, no-op, or approval. If not specified, defaults to build.dockerY (1)ListOptions for the  Docker executormachineY (1)MapOptions for the  machine executormacosY (1)MapOptions for the  macOS executorshellNStringShell to use for execution command in all steps. Can be overridden by shell in each step (default: See  Default Shell Options)parametersNMap Parameters for making a job explicitly configurable in a workflow.stepsYListA list of  steps to be performedworking_directoryNStringIn which directory to run the steps. Will be interpreted as an absolute path. Default: ~/project (where project is a literal string, not the name of your specific project). Processes run during the job can use the $CIRCLE_WORKING_DIRECTORY environment variable to refer to this directory. Note: Paths written in your YAML configuration file will not be expanded; if your store_test_results.path is $CIRCLE_WORKING_DIRECTORY/tests, then CircleCI will attempt to store the test subdirectory of the directory literally named $CIRCLE_WORKING_DIRECTORY, dollar sign $ and all. working_directory will be created automatically if it doesn’t exist.parallelismNIntegerNumber of parallel instances of this job to run (default: 1)environmentNMapA map of environment variable names and values.branchesNMapThis key is deprecated. Use  workflows filtering to control which jobs run for which branches.resource_classNStringAmount of CPU and RAM allocated to each container in a job.  (1) One executor type should be specified per job. If more than one is set you will receive an error.    type  Configure a job type. Options are release, approval, no-op, build (default).   If a type is not specified, the job defaults to a build type.   Example of a job with a build type. build is the default type and does not need to be configured:    jobs:
  my-job:
    docker:
      - image: cimg/base:2024.12
    resource_class: xlarge
    steps:
      ... // other config    Jobs with the release type are used to  connect your pipeline configuration to a deployment in the CircleCI deploys UI. For full details, see the  Deploys overview page.   Example of a job with a release type:    jobs:
  release-my-service:
    type: release
    plan_name: <my-service-release>    The no-op type is used to configure a job that performs no actions and consumes no credits. no-op is commonly used to organise the order of operations within a workflow and make it easier to maintain. Only the type is required for a no-op type job, no further job configuration is required. For some examples of using no-op jobs, see the  Orchestration cookbook   Example of a job with a no-op type:    jobs:
  my-no-op-job:
    type: no-op    The approval type is used to configure a manual approval step. No job configuration is required or allowed for an approval type job. The approval type is most commonly configured within a workflow rather than under the top-level jobs key. Only approval type jobs can have their type configured under workflows. See  type under workflows section for full details.   Example of a job with an approval type, configured under workflows:    workflows:
  my-workflow:
    jobs:
      - build
      - test:
          requires:
            - build
      - hold:
          type: approval
          requires:
            - test
      - deploy:
          requires:
            - hold      environment  A map of environment variable names and values. For more information on defining and using environment variables, and the order of precedence governing the various ways they can be set, see the  Environment variables page.     parallelism  This feature is used to optimize test steps. If parallelism is set to N > 1, then N independent executors will be set up and each will run the steps of that job in parallel.   You can use the CircleCI CLI to split your test suite across parallel containers so the job completes in a shorter time.     Read more about splitting tests across parallel execution environments on the  Parallelism and test splitting page.   Refer to the  Use the CircleCI CLI to split tests how-to guide.   Follow the  Test splitting tutorial.     Example:    jobs:
  build:
    docker:
      - image: cimg/base:2024.12
    environment:
      FOO: bar
    parallelism: 3
    resource_class: large
    working_directory: ~/my-app
    steps:
      - run: go list ./... | circleci tests run --command "xargs gotestsum --junitfile junit.xml --format testname --" --split-by=timings --timings-type=name      parameters  Job-level parameters can be used when  calling a job in a workflow.   Reserved parameter-names:     name   requires   context   type   filters   matrix     See  Parameter Syntax for definition details.     Executor docker / machine / macos  CircleCI offers several execution environments in which to run your jobs. To specify an execution environment choose an executor, then specify and image and a resource class. An executor defines the underlying technology, environment, and operating system in which to run a job.   Set up your jobs to run using the docker (Linux), machine (LinuxVM, Windows, GPU, Arm), or macos executor, then specify an image with the tools and packages you need, and a resource class.   Learn more about execution environments and executors in the  Introduction to Execution Environments.     docker  Configured by docker key which takes a list of maps:  KeyRequiredTypeDescriptionimageYStringThe name of a custom Docker image to use. The first image listed under a job defines the job’s own primary container image where all steps will run.nameNStringname defines the hostname for the container (the default is localhost), which is used for reaching secondary (service) containers. By default, all services are exposed directly on localhost. This field is useful if you would rather have a different hostname instead of localhost, for example, if you are starting multiple versions of the same service.entrypointNString or ListThe command used as executable when launching the container. entrypoint overrides the image’s  ENTRYPOINT.commandNString or ListThe command used as PID 1 (or arguments for entrypoint) when launching the container. command overrides the image’s COMMAND. It will be used as arguments to the image ENTRYPOINT if it has one, or as the executable if the image has no ENTRYPOINT.userNStringWhich user to run commands as within the Docker containerenvironmentNMapA map of environment variable names and values. The environment settings apply to the entrypoint/command run by the Docker container, not the job steps.authNMapAuthentication for registries using standard docker login credentialsaws_authNMapAuthentication for AWS Elastic Container Registry (ECR)  For a  primary container, (the first container in the list) if neither command nor entrypoint is specified in the configuration, then any ENTRYPOINT and COMMAND in the image are ignored. The primary container is typically only used for running the steps and not for its ENTRYPOINT, and an ENTRYPOINT may consume significant resources or exit prematurely.   A  custom image may disable this behavior and force the ENTRYPOINT to run.   You can specify image versions using tags or digest. You can use any public images from any public Docker registry (defaults to Docker Hub). Learn more about specifying images on the  Using the Docker Execution Environment page.    Docker registry authentication  Some registries, Docker Hub, for example, may rate limit anonymous Docker pulls. We recommend that you authenticate to pull private and public images. The username and password can be specified in the auth field. See  Using Docker Authenticated Pulls for details.   Example:    jobs:
  build:
    docker:
      - image: buildpack-deps:trusty # primary container
        auth:
          username: mydockerhub-user
          password: $DOCKERHUB_PASSWORD  # context / project UI env-var reference
        environment:
          ENV: CI

      - image: mongo:2.6.8
        auth:
          username: mydockerhub-user
          password: $DOCKERHUB_PASSWORD  # context / project UI env-var reference
        command: [--smallfiles]

      - image: postgres:14.2
        auth:
          username: mydockerhub-user
          password: $DOCKERHUB_PASSWORD  # context / project UI env-var reference
        environment:
          POSTGRES_USER: user

      - image: redis@sha256:54057dd7e125ca41afe526a877e8bd35ec2cdd33b9217e022ed37bdcf7d09673
        auth:
          username: mydockerhub-user
          password: $DOCKERHUB_PASSWORD  # context / project UI env-var reference

      - image: acme-private/private-image:321
        auth:
          username: mydockerhub-user
          password: $DOCKERHUB_PASSWORD  # context / project UI env-var reference      AWS authentication  Using an image hosted on  AWS ECR requires authentication using AWS credentials.   Use OIDC  Authenticate using OpenID Connect (OIDC) using the oidc_role_arn field, as follows:    jobs:
  job_name:
    docker:
      - image: <your-image-arn>
        aws_auth:
          oidc_role_arn: <your-iam-role-arn>    For steps to get set up with OIDC to pull images from AWS ECR, see the  Pull and image from AWS ECR with OIDC page.    Use environment variables  By default, CircleCI uses the AWS credentials you provide by setting the AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY project environment variables. It is also possible to set the credentials by using the aws_auth field as in the following example:    jobs:
  build:
    docker:
      - image: account-id.dkr.ecr.us-east-1.amazonaws.com/org/repo:0.1
        aws_auth:
          aws_access_key_id: AKIAQWERVA  # can specify string literal values
          aws_secret_access_key: $ECR_AWS_SECRET_ACCESS_KEY  # or project UI envar reference        machine     CircleCI cloud The use of machine: true is deprecated. You must specify an image to use.        The machine executor is configured using the machine key, which takes a map:  KeyRequiredTypeDescriptionimageYStringThe virtual machine image to use. View  available images. Note: This key is not supported for Linux VMs on installations of CircleCI server. For information about customizing machine executor images on CircleCI installed on your servers, see our  Machine provisioner documentation.docker_layer_cachingNBooleanSet this to true to enable  Docker layer caching.  Example:  CloudServer    jobs:
  build: # name of your job
    machine: # executor type
      image: ubuntu-2004:current # recommended linux image

    steps:
      # Commands run in a Linux virtual machine environment        jobs:
  build: # name of your job
    machine: true # executor type
    steps:
      # Commands run in a Linux virtual machine environment        Available Linux machine images  Specifying an image in your configuration file is strongly recommended. CircleCI supports multiple Linux machine images that can be specified in the image field. For a full list of supported image tags, refer to the following pages in the Developer Hub:      Ubuntu-2004    Ubuntu-2204     More information on the software available in each image can be found in our  Discuss forum.   The machine executor supports  Docker Layer Caching, which is useful when you are building Docker images during your job or Workflow.     Available Linux machine images on server  If you are using CircleCI server, contact your system administrator for details of available Linux machine images.     Available Linux GPU machine images  When using the Linux  GPU executor, the available images are:     linux-cuda-11:default v11.4, v11.6, v11.8 (default), Docker v20.10.24   linux-cuda-12:default v12.0, v12.1 (default), Docker v20.10.24       Available Android machine images  CircleCI supports running jobs on Android for testing and deploying Android applications.   To use the  Android image directly with the machine executor, add the following to your job:    version: 2.1

jobs:
  build:
    machine:
      image: android:2024.11.1    The Android image can also be accessed using the  Android orb.   For examples, refer to the  Using Android Images with the Machine Executor page.     Available Windows machine images  Specifying an image in your configuration file is strongly recommended. CircleCI supports multiple Windows machine images that can be specified in the image field.   For a full list of supported images, refer to one of the following:      windows-server-2022-gui image    windows-server-2019 image     More information on what software is available in each image can be found in our  Discuss forum.   Alternatively, use the  Windows orb to manage your Windows execution environment. For examples, see the  Using the Windows Execution Environment page.     Available Windows machine images on server  If you are using CircleCI server, contact your system administrator for details of available Windows machine images.     Available Windows GPU machine image  When using the Windows  GPU executor, the available image is:      windows-server-2019-cuda     Example    version: 2.1

jobs:
  build:
    machine:
      image: windows-server-2019-cuda:current       macos  CircleCI supports running jobs on  macOS, to allow you to build, test, and deploy apps for macOS,  iOS,  tvOS and  watchOS. To run a job on a macOS virtual machine, add the macos key to the top-level configuration for your job and specify the version of Xcode to use.  KeyRequiredTypeDescriptionxcodeYStringThe version of Xcode that is installed on the virtual machine, see the  Supported Xcode Versions section of the Testing iOS document for the complete list.  Example: Use a macOS virtual machine with Xcode version 14.2.0:    jobs:
  build:
    macos:
      xcode: "14.2.0"      branches - DEPRECATED  This key is deprecated. Use  workflows filtering to control which jobs run for which branches.     resource_class  The resource_class feature allows you to configure CPU and RAM resources for each job. Resource classes are available for each execution environment, as described in the tables below.   We implement soft concurrency limits for each resource class to ensure our system remains stable for all customers. If you are on a Performance or Custom Plan and experience queuing for certain resource classes, it is possible you are hitting these limits.  Contact CircleCI support to request a raise on these limits for your account.   If you do not specify a resource class, CircleCI will use a default value that is subject to change. It is best practice to specify a resource class as opposed to relying on a default.      Java, Erlang and any other languages that introspect the /proc directory for information about CPU count may require additional configuration to prevent them from slowing down when using the CircleCI resource class feature. Programs with this issue may request 32 CPU cores and run slower than they would when requesting one core. Users of languages with this issue should pin their CPU count to their guaranteed CPU resources.           If you want to confirm how much memory you have been allocated, you can check the cgroup memory hierarchy limit with grep hierarchical_memory_limit /sys/fs/cgroup/memory/memory.stat.         Self-hosted runner  Use the resource_class key to configure a  self-hosted runner instance.   For example:    jobs:
  job_name:
    machine: true
    resource_class: <my-namespace>/<my-runner>      Docker execution environment  Example:    jobs:
  build:
    docker:
      - image: cimg/base:2024.12
    resource_class: xlarge
    steps:
      ... // other config    x86     For credit and access information, see the  Resource classes page. Resource class access is dependent on your  Plan.       ClassvCPUsRAMCloudServersmall12GBmedium24GBmedium+36GBlarge48GBxlarge816GB2xlarge1632GB2xlarge+2040GB   Arm  Arm on Docker For pricing information, and a list of CircleCI Docker convenience images that support Arm resource classes, see the  Resource classes page.       Arm on Docker For credit and access information see the  Resource classes page. Resource class access is dependent on your  Plan   To find out which CircleCI Docker convenience images support Arm resource classes, you can refer to  Docker hub:     Select the image (for example, cimg/python).   Select the tags tab.   View what is supported under OS/ARCH for the latest tags. For example, cimg/python has linux/amd64 and linux/arm64, which means Arm is supported.          ClassvCPUsRAMCloudServerarm.medium28 GBarm.large416 GBarm.xlarge832 GBarm.2xlarge1664 GB     LinuxVM execution environment ClassvCPUsRAMDisk SizeCloudServermedium27.5 GB150GBlarge415 GB150GBxlarge832 GB150GB2xlarge1664 GB150GB2xlarge+3264 GB150GB  Example:  CloudServer    jobs:
  build:
    machine:
      image: ubuntu-2004:2024.01.2 # recommended linux image
    resource_class: large
    steps:
      ... // other config        jobs:
  build:
    machine: true
    resource_class: large
    steps:
      ... // other config         macOS execution environment ClassvCPUsRAMCloudServermacos.m1.medium.gen14 @ 3.2 GHz6GBmacos.m1.large.gen18 @ 3.2 GHz12GBm2pro.medium4 @ 3.49 GHz8GBm2pro.large8 @ 3.49 GHz16GB      We have deprecated support for all Intel-based macOS resources.   The macos.x86.medium.gen2 resource class was deprecated on June 28, 2024.   See our  announcement for more details.         Example    jobs:
  build:
    macos:
      xcode: "15.4.0"
    resource_class: m2pro.medium
    steps:
      ... // other config      macOS execution environment on server  If you are working on CircleCI server v3.1 and up, you can access the macOS execution environment using  self-hosted runner.     Windows execution environment ClassvCPUsRAMDisk SizeCloudServerwindows.medium (default)415GB200 GBwindows.large830GB200 GBwindows.xlarge1660GB200 GBwindows.2xlarge32128GB200 GB     Using server? Check with your systems administrator whether you have access to the Windows execution environment.        Example:  CloudServer    version: 2.1

jobs:
  build: # name of your job
    resource_class: 'windows.medium'
    machine:
      image: 'windows-server-2022-gui:current'
      shell: 'powershell.exe -ExecutionPolicy Bypass'
    steps:
      # Commands are run in a Windows virtual machine environment
      - checkout
      - run: Write-Host 'Hello, Windows'        version: 2.1

jobs:
  build: # name of your job
    machine:
      image: windows-default
    steps:
      # Commands are run in a Windows virtual machine environment
      - checkout
      - run: Write-Host 'Hello, Windows'         GPU execution environment (Linux) ClassvCPUsRAMGPUsGPU modelGPU Memory (GiB)Disk Size (GiB)CloudServergpu.nvidia.small4161NVIDIA Tesla P416150gpu.nvidia.small.gen24161NVIDIA A10G24150gpu.nvidia.small.multi4152NVIDIA Tesla T416150gpu.nvidia.medium.multi8304NVIDIA Tesla T416150gpu.nvidia.medium8301NVIDIA Tesla T416150gpu.nvidia.large8301NVIDIA Tesla V10016150  Example:    version: 2.1

jobs:
  build:
    machine:
      image: linux-cuda-12:default
    resource_class: gpu.nvidia.medium
    steps:
      - run: nvidia-smi
      - run: docker run --gpus all nvidia/cuda:9.0-base nvidia-smi    See the  Available Linux GPU images section for the full list of available images.     GPU execution-environment (Windows) ClassvCPUsRAMGPUsGPU modelGPU Memory (GiB)Disk Size (GiB)CloudServerwindows.gpu.nvidia.medium16601NVIDIA Tesla T416200  Example:    version: 2.1
orbs:
  win: circleci/windows@5.0.0

jobs:
  build:
    executor: win/server-2019-cuda
    steps:
      - checkout
      - run: '&"C:\Program Files\NVIDIA Corporation\NVSMI\nvidia-smi.exe"'    (2) This resource requires review by our support team.  Open a support ticket if you would like to request access.     Arm VM execution-environment ClassvCPUsRAMDisk SizeCloudServerarm.medium (default)28GB100 GBarm.large416GB100 GBarm.xlarge832GB100 GBarm.2xlarge1664GB100 GB     Using server? Check with your systems administrator whether you have access to the Arm execution environment.        Example:  CloudServer    jobs:
  my-job:
    machine:
      image: ubuntu-2004:2024.01.2
    resource_class: arm.medium
    steps:
      - run: uname -a
      - run: echo "Hello, Arm!"        jobs:
  my-job:
    machine:
      image: arm-default
    resource_class: arm.medium
    steps:
      - run: uname -a
      - run: echo "Hello, Arm!"          steps  The steps setting in a job should be a list of single key/value pairs, the key of which indicates the step type. The value may be either a configuration map or a string (depending on what that type of step requires). For example, using a map:    jobs:
  build:
    working_directory: ~/canary-python
    environment:
      FOO: bar
    steps:
      - run:
          name: Running tests
          command: make test    Here run is a step type. The name attribute is used by the UI for display purposes. The command attribute is specific for run step and defines command to execute.   Some steps may implement a shorthand semantic. For example, run may be also be called like this:    jobs:
  build:
    steps:
      - run: make test    In its short form, the run step allows us to directly specify which command to execute as a string value. In this case step itself provides default suitable values for other attributes (name here will have the same value as command, for example).   Another shorthand, which is possible for some steps, is to use the step name as a string instead of a key/value pair:    jobs:
  build:
    steps:
      - checkout    In this case, the checkout step will check out project source code into the job’s  working_directory.   In general all steps can be described as:  KeyRequiredTypeDescription<step_type>YMap or StringA configuration map for the step or some string whose semantics are defined by the step.  Each built-in step is described in detail below.    run  The run step is used to invoke command-line programs. The run step takes either a map of configuration values, or, when called in its short-form, a string that will be used as both the command and name. Run commands are executed using non-login shells by default, so you must explicitly source any dotfiles as part of the command.      the run step replaces the deprecated deploy step. If your job has a parallelism of 1, the deprecated deploy step can be swapped out directly for the run step. If your job has parallelism > 1, see  Migrate from deploy to run.       KeyRequiredTypeDescriptioncommandYStringCommand to run via the shellnameNStringTitle of the step to be shown in the CircleCI UI (default: full command)shellNStringShell to use for execution command (default: See  Default Shell Options)environmentNMapAdditional environmental variables, locally scoped to commandbackgroundNBooleanWhether or not this step should run in the background (default: false)working_directoryNStringIn which directory to run this step. Will be interpreted relative to the  working_directory of the job). (default: .)no_output_timeoutNStringElapsed time the command can run without output. The string is a decimal with unit suffix, such as "20m", "1.25h", "5s". The default is 10 minutes and the maximum is governed by the  maximum time a job is allowed to run.whenNString Specify when to enable or disable the step. Takes the following values: always, on_success, on_fail (default: on_success)  Each run declaration represents a new shell. It is possible to specify a multi-line command, each line of which will be run in the same shell:    - run:
    command: |
      echo Running test
      mkdir -p /tmp/test-results
      make test    You can also configure commands to run  in the background if you do not want to wait for the step to complete before moving on to subsequent run steps.    Default shell options  For jobs that run on Linux, the default value of the shell option is /bin/bash -eo pipefail if /bin/bash is present in the build container. Otherwise it is /bin/sh -eo pipefail. The default shell is not a login shell (--login or -l are not specified). Hence, the shell will not source your ~/.bash_profile, ~/.bash_login, ~/.profile files.   For jobs that run on macOS, the default shell is /bin/bash --login -eo pipefail. The shell is a non-interactive login shell. The shell will execute /etc/profile/ followed by ~/.bash_profile before every step.   For more information about which files are executed when Bash is invocated,  see the INVOCATION section of the bash manpage.   Descriptions of the -eo pipefail options are provided below.    -e  Exit immediately if any of the following exits with a non-zero status:     A pipeline (which may consist of a single simple command).   A subshell command enclosed in parentheses.   One of the commands executed as part of a command list enclosed by braces.     In the previous example, mkdir failed to create a directory and returned a non-zero status, then command execution would be terminated, and the whole step would be marked as failed. If you desire the opposite behaviour, you need to add set +e in your command or override the default shell in your configuration map of run. For example:    - run:
    command: |
      echo Running test
      set +e
      mkdir -p /tmp/test-results
      make test

- run:
    shell: /bin/sh
    command: |
      echo Running test
      mkdir -p /tmp/test-results
      make test     -o pipefail  If pipefail is enabled, the pipeline’s return status is the value of the last (rightmost) command to exit with a non-zero status, or zero if all commands exit successfully. The shell waits for all commands in the pipeline to terminate before returning a value.   For example:    - run: make test | tee test-output.log    If make test fails, the -o pipefail option will cause the whole step to fail. Without -o pipefail, the step will always run successfully because the result of the whole pipeline is determined by the last command (tee test-output.log), which will always return a zero status.      If make test fails the rest of pipeline will be executed.        If you want to avoid this behaviour, you can specify set +o pipefail in the command or override the whole shell (see example above).   In general, we recommend using the default options (-eo pipefail) because they show errors in intermediate commands and simplify debugging job failures. For convenience, the UI displays the used shell and all active options for each run step.   For more information, see the  Using Shell Scripts document.     Background commands  The background attribute enables you to configure commands to run in the background. Job execution will immediately proceed to the next step rather than waiting for return of a command with the background attribute set to true. The following example shows the configuration for running the X virtual framebuffer in the background which is commonly required to run Selenium tests:    - run:
    name: Running X virtual framebuffer
    command: Xvfb :99 -screen 0 1280x1024x24
    background: true

- run: make test      Shorthand syntax  run has a very convenient shorthand syntax:    - run: make test

# shorthanded command can also have multiple lines
- run: |
    mkdir -p /tmp/test-results
    make test    In this case, command and name become the string value of run, and the rest of the config map for that run have their default values.     The when attribute  By default, CircleCI will execute job steps one at a time, in the order that they are defined in config.yml, until a step fails (returns a non-zero exit code). After a command fails, no further job steps will be executed.   Adding the when attribute to a job step allows you to override this default behaviour, and selectively run or skip steps depending on the status of the job.   The when attribute accepts the following values:    on_success  The step will run only if all of the previous steps have been successful (returned exit code 0). on_success is the default value.  always  The step will run regardless of the exit status of previous steps. always is useful if you have a task that you want to run regardless of whether the previous steps are successful or not. For example, you might have a job step that needs to upload logs or code-coverage data somewhere.  on_fail  The step will run only if one of the preceding steps has failed (returns a non-zero exit code). A common use of on_fail is to store some diagnostic data to help debug test failures, or to run custom notifications about the failure, such as sending emails or triggering alerts.        Some steps, such as store_artifacts and store_test_results will always run, even if a step has failed (returned a non-zero exit code) previously. The when attribute, store_artifacts and store_test_results are not run if the job has been killed by a cancel request or has reached the runtime timeout limit.         - run:
    name: Upload CodeCov.io Data
    command: bash <(curl -s https://codecov.io/bash) -F unittests
    when: always # Uploads code coverage results, pass or fail      Ending a job from within a step  A job can exit without failing by using run: circleci-agent step halt. However, if a step within the job is already failing then the job will continue to fail. This can be useful in situations where jobs need to conditionally execute.   Here is an example where halt is used to avoid running a job on the develop branch:    - run: |
    if [ "$CIRCLE_BRANCH" = "develop" ]; then
        circleci-agent step halt
    fi       The when step     The when and unless steps are supported in version: 2.1 configuration        A conditional step consists of a step with the key when or unless. Under the when key are the subkeys condition and steps. The purpose of the when step is customizing commands and job configuration to run on custom conditions (determined at config-compile time) that are checked before a workflow runs. See the  Conditional Steps section of the reusable configuration reference for more details.  KeyRequiredTypeDescriptionconditionYLogic A logic statementstepsYSequenceA list of steps to execute when the condition is true  Example:    version: 2.1

jobs: # conditional steps may also be defined in `commands:`
  job_with_optional_custom_checkout:
    parameters:
      custom_checkout:
        type: string
        default: ""
    machine:
      image: ubuntu-2004:2024.11.1
    steps:
      - when:
          condition: <<parameters.custom_checkout>>
          steps:
            - run: echo "my custom checkout"
      - unless:
          condition: <<parameters.custom_checkout>>
          steps:
            - checkout
workflows:
  build-test-deploy:
    jobs:
      - job_with_optional_custom_checkout:
          custom_checkout: "any non-empty string is truthy"
      - job_with_optional_custom_checkout      checkout      Blobless clones   A "blobless" strategy is being rolled out to help improve the performance of code checkouts from Git source code hosts.   Blobless clones reduce the amount of data fetched from the remote, by asking the remote to filter out objects that are not attached to the current commit.   While this improves performance in most cases, if a downstream step requires those objects to exist for scanning or comparisons, it can cause failures. To work around these potential problems, a fetch directly after a checkout will ensure the required data is available:    - checkout
- run: git fetch          A special step used to check out source code to the configured path (defaults to the working_directory). The reason this is a special step is because it is more of a helper function designed to simplify the process of checking out code. If you require doing git over HTTPS you should not use this step as it configures git to checkout over SSH.  KeyRequiredTypeDescriptionpathNStringCheckout directory. Will be interpreted relative to the  working_directory of the job). (default: .)  If path already exists and is:     A git repository - step will not clone whole repository, instead will fetch origin   NOT a git repository - step will fail.     In the case of checkout, the step type is just a string with no additional attributes:    - checkout    The checkout command automatically adds the required authenticity keys for interacting with GitHub and Bitbucket over SSH. These keys are detailed further in the  integration guide. This guide is also helpful if you wish to implement a custom checkout command.   CircleCI does not check out submodules. If your project requires submodules, add run steps with appropriate commands as shown in the following example:    - checkout
- run: git submodule sync
- run: git submodule update --init       The checkout step will configure Git to skip automatic garbage collection. If you are caching your .git directory with  restore_cache and would like to use garbage collection to reduce its size, you may wish to use a  run step with command git gc before doing so.          setup_remote_docker  Allows Docker commands to be run locally. See  Running Docker commands for details.    jobs:
  build:
    docker:
      - image: cimg/base:2024.06
    steps:
      # ... steps for building/testing app ...
      - setup_remote_docker:
          version: default   KeyRequiredTypeDescriptiondocker_layer_cachingNbooleanSet this to true to enable  Docker Layer Caching in the Remote Docker Environment (default: false)versionNStringVersion string of Docker you would like to use (default: 24.0.9). View the list of supported Docker versions  here.        setup_remote_docker is not compatible with the machine executor. See  Docker Layer Caching in Machine Executor for information on how to enable DLC with the machine executor.   The version key is not currently supported on CircleCI server. Contact your system administrator for information about the Docker version installed in your remote Docker environment. If you are on server 4.x, you can find the default AWS AMI  here.             save_cache  Generates and stores a cache of a file or directory of files such as dependencies or source code in our object storage. Later jobs can  restore this cache. Learn more on the  Caching Dependencies page.   Cache retention can be customized on the  CircleCI web app by navigating to Plan  Usage Controls.  KeyRequiredTypeDescriptionpathsYListList of directories which should be added to the cachekeyYStringUnique identifier for this cachenameNStringTitle of the step to be shown in the CircleCI UI (default: "Saving Cache")whenNString Specify when to enable or disable the step. Takes the following values: always, on_success, on_fail (default: on_success)  The cache for a specific key is immutable and cannot be changed once written.      If the cache for the given key already exists it will not be modified, and job execution will proceed to the next step.        When storing a new cache, the key value may contain special, templated, values for your convenience:  TemplateDescription{{ .Branch }}The VCS branch currently being built.{{ .BuildNum }}The CircleCI build number for this build.{{ .Revision }}The VCS revision currently being built.{{ .CheckoutKey }}The SSH key used to checkout the repository.{{ .Environment.variableName }}The environment variable variableName (supports any environment variable  exported by CircleCI or added to a specific  context--not any arbitrary environment variable).{{ checksum "filename" }}A base64 encoded SHA256 hash of the given filename’s contents. This should be a file committed in your repository and may also be referenced as a path that is absolute or relative from the current working directory. Good candidates are dependency manifests, such as package-lock.json, pom.xml or project.clj. It is important that this file does not change between restore_cache and save_cache, otherwise the cache will be saved under a cache key different than the one used at restore_cache time.{{ epoch }}The current time in seconds since the UNIX epoch.{{ arch }}The OS and CPU information. Useful when caching compiled binaries that depend on OS and CPU architecture, for example, darwin amd64 versus linux i386/32-bit.  During step execution, the templates above will be replaced by runtime values and use the resultant string as the key.   Template examples:     myapp-{{ checksum "package-lock.json" }} - cache will be regenerated every time something is changed in package-lock.json file, different branches of this project will generate the same cache key.   myapp-{{ .Branch }}-{{ checksum "package-lock.json" }} - same as the previous one, but each branch will generate separate cache   myapp-{{ epoch }} - every run of a job will generate a separate cache     While choosing suitable templates for your cache key, keep in mind that:     Cache saving is not a free operation. See the billing section on the  FAQ page.   It takes time to upload the cache.     Best practice is to have a key that generates a new cache only if something actually changed and avoid generating a new one every time a job is run.      Given the immutability of caches, it might be helpful to start all your cache keys with a version prefix v1-.... That way you will be able to regenerate all your caches just by incrementing the version in this prefix.        Example:    - save_cache:
    key: v1-myapp-{{ arch }}-{{ checksum "project.clj" }}
    paths:
      - /home/ubuntu/.m2     - save_cache:
    key: v1-{{ checksum "yarn.lock" }}
    paths:
      - node_modules/workspace-a
      - node_modules/workspace-c          Wildcards are not currently supported in save_cache paths. Visit the  Ideas board and vote for this feature if it would be useful for you or your organization.   In some instances, a workaround for this is to save a particular workspace to cache:             restore_cache  Restores a previously saved cache based on a key. Cache needs to have been saved first for this key using the  save_cache step. Learn more in  the caching documentation.  KeyRequiredTypeDescriptionkeyY (1)StringSingle cache key to restorekeysY (1)ListList of cache keys to lookup for a cache to restore. Only first existing key will be restored.nameNStringTitle of the step to be shown in the CircleCI UI (default: "Restoring Cache")  (1) at least one attribute has to be present. If key and keys are both given, key will be checked first, and then keys.   A key is searched against existing keys as a prefix.      When there are multiple matches, the most recent match will be used, even if there is a more precise match.        For example:    steps:
  - save_cache:
      key: v1-myapp-cache
      paths:
        - ~/d1

  - save_cache:
      key: v1-myapp-cache-new
      paths:
        - ~/d2

  - run: rm -f ~/d1 ~/d2

  - restore_cache:
      key: v1-myapp-cache    In this case cache v1-myapp-cache-new will be restored because it’s the most recent match with v1-myapp-cache prefix even if the first key (v1-myapp-cache) has exact match.   For more information on key formatting, see the key section of  save_cache step.   When CircleCI encounters a list of keys, the cache will be restored from the first key matching an existing cache. We recommend you use a more specific key first (for example, cache for exact version of package-lock.json) and more generic keys after (for example, any cache for this project). If no key has a cache that exists, the step will be skipped with a warning.   A path is not required here because the cache will be restored to the location from which it was originally saved.   Example:    - restore_cache:
    keys:
      - v1-myapp-{{ arch }}-{{ checksum "project.clj" }}
      # if cache for exact version of `project.clj` is not present then load any most recent one
      - v1-myapp-

# ... Steps building and testing your application ...

# cache will be saved only once for each version of `project.clj`
- save_cache:
    key: v1-myapp-{{ arch }}-{{ checksum "project.clj" }}
    paths:
      - /foo      deploy - DEPRECATED  See  run for current processes. If you have parallelism > 1 in your job, see the  Migrate from deploy to run guide.     store_artifacts  Step to store artifacts (for example logs, binaries, etc) to be available in the web app or through the API. See the  Uploading Artifacts page for more information.  KeyRequiredTypeDescriptionpathYStringDirectory in the primary container to save as job artifactsdestinationNStringPrefix added to the artifact paths in the artifacts API (default: the directory of the file specified in path)  There can be multiple store_artifacts steps in a job. Using a unique prefix for each step prevents them from overwriting files.   Artifact storage retention can be customized on the  CircleCI web app by navigating to Plan  Usage Controls.   Example:    - run:
    name: Build the Jekyll site
    command: bundle exec jekyll build --source jekyll --destination jekyll/_site/docs/
- store_artifacts:
    path: jekyll/_site/docs/
    destination: circleci-docs      store_test_results  Special step used to upload and store test results for a build. Test results are visible on the CircleCI web application under each build’s Test Summary section. Storing test results is useful for timing analysis of your test suites. For more information on storing test results, see the  Collecting Test Data page.   You can also store test results as build artifacts. For steps, refer to  the store_artifacts step section.  KeyRequiredTypeDescriptionpathYStringPath (absolute, or relative to your working_directory) to directory containing JUnit XML test metadata files, or to a single test file.  Example:   Directory structure:    test-results
├── jest
│   └── results.xml
├── mocha
│   └── results.xml
└── rspec
    └── results.xml    config.yml syntax:    - store_test_results:
    path: test-results      persist_to_workspace  Special step used to persist a temporary file to be used by another job in the workflow. For more information on using workspaces, see the  Using Workspaces to Share Data Between Jobs page.   persist_to_workspace adopts the storage settings from the storage customization controls on the CircleCI web app. If no custom setting is provided, persist_to_workspace defaults to 15 days.   Workspace storage retention can be customized on the  CircleCI web app by navigating to Plan  Usage Controls.  KeyRequiredTypeDescriptionrootYStringEither an absolute path or a path relative to working_directorypathsYListGlob identifying file(s), or a non-glob path to a directory to add to the shared workspace. Interpreted as relative to the workspace root. Must not be the workspace root itself.  The root key is a directory on the container which is taken to be the root directory of the workspace. The path values are all relative to the root.   Example for root Key   For example, the following step syntax persists the specified paths from /tmp/dir into the workspace, relative to the directory /tmp/dir.    - persist_to_workspace:
    root: /tmp/dir
    paths:
      - foo/bar
      - baz    After this step completes, the following directories are added to the workspace:    /tmp/dir/foo/bar
/tmp/dir/baz    Example for paths Key    - persist_to_workspace:
    root: /tmp/workspace
    paths:
      - target/application.jar
      - build/*    The paths list uses Glob from Go, and the pattern matches  filepath.Match.    pattern:
        { term }
term:
        '*' matches any sequence of non-Separator characters
        '?' matches any single non-Separator character
        '[' [ '^' ] { character-range }
        ']' character class (must be non-empty)
        c matches character c (c != '*', '?', '\\', '[')
        '\\' c matches character c
character-range:
        c matches character c (c != '\\', '-', ']')
        '\\' c matches character c
        lo '-' hi matches character c for lo <= c <= hi    The Go documentation states that the pattern may describe hierarchical names such as /usr/*/bin/ed (assuming the Separator is '/').      Everything must be relative to the work space root directory.          attach_workspace  Special step used to attach the workflow’s workspace to the current container. The full contents of the workspace are downloaded and copied into the directory the workspace is being attached at. For more information on using workspaces, see the  Using workspaces page.  KeyRequiredTypeDescriptionatYStringDirectory to attach the workspace to.  Workspace storage retention can be customized on the  CircleCI web app by navigating to Plan  Usage Controls.   Example:    - attach_workspace:
    at: /tmp/workspace       The lifetime of artifacts, workspaces, and caches can be customized on the  CircleCI web app by navigating to Plan  Usage Controls. Here you can control the storage retention periods for these objects. If no storage period is set, the default storage retention period of artifacts is 30 days, while the default storage retention period of workspaces and caches is 15 days.          add_ssh_keys  Special step that adds SSH keys from a project’s settings to a container. Also configures SSH to use these keys. For more information on SSH keys see the  Create additional GitHub SSH keys page.      Using server? only MD5 fingerprints are supported. In CircleCI in Project Settings  SSH keys  Additional SSH keys the MD5 fingerprint will be visible. SHA256 support is planned for an upcoming server release.       KeyRequiredTypeDescriptionfingerprintsNListList of fingerprints corresponding to the keys to be added (default: all keys added)   steps:
  - add_ssh_keys:
      fingerprints:
        - "b7:35:a6:4e:9b:0d:6d:d4:78:1e:9a:97:2a:66:6b:be"
        - "SHA256:NPj4IcXxqQEKGXOghi/QbG2sohoNfvZ30JwCcdSSNM0"       Even though CircleCI uses ssh-agent to sign all added SSH keys, you must use the add_ssh_keys key to actually add keys to a container.          Using pipeline values  Pipeline values are available to all pipeline configurations and can be used without previous declaration. For a list of pipeline values, see the  Pipeline values and parameters page.   Example:    version: 2.1
jobs:
  build:
    docker:
      - image: cimg/node:20.18.1
    environment:
      IMAGETAG: latest
    working_directory: ~/main
    steps:
      - run: echo "This is pipeline ID << pipeline.id >>"       circleci_ip_ranges     A paid account on a  Performance or Scale Plan is required to access IP ranges.        Enables jobs to go through a set of well-defined IP address ranges. See  IP ranges for details.   Example:    version: 2.1

jobs:
  build:
    circleci_ip_ranges: true # opts the job into the IP ranges feature
    docker:
      - image: curlimages/curl
    steps:
      - run: echo “Hello World”
workflows:
  build-workflow:
    jobs:
      - build         workflows   Used for orchestrating all jobs. Each workflow consists of the workflow name as a key and a map as a value. A name should be unique within the current config.yml. The top-level keys for the Workflows configuration are version and jobs. For more information, see the  Using Workflows to Orchestrate Jobs page.    version     The workflows version key is not required for version: 2.1 configuration        The Workflows version field is used to issue warnings for deprecation or breaking changes.  KeyRequiredTypeDescriptionversionY if config version is 2StringShould currently be 2    <workflow_name>  A unique name for your workflow.    triggers  Specifies which triggers will cause this workflow to be executed. Default behavior is to trigger the workflow when pushing to a branch.  KeyRequiredTypeDescriptiontriggersNArrayShould currently be schedule.   workflows:
   nightly:
     triggers:
       - schedule:
           cron: "0 0 * * *"
           filters:
             branches:
               only:
                 - main
                 - beta
     jobs:
       - test     schedule     Scheduled workflows are not available for projects integrated through the GitHub App, GitLab or Bitbucket Data Center.           The scheduled workflows feature is set to be deprecated. Using scheduled pipelines rather than scheduled workflows offers several benefits. Visit the scheduled pipelines  migration guide to find out how to migrate existing scheduled workflows to scheduled pipelines. If you would like to set up scheduled pipelines from scratch, visit the  Scheduled pipelines page.        A workflow may have a schedule indicating it runs at a certain time, for example a nightly build that runs every day at 12am UTC:    workflows:
   nightly:
     triggers:
       - schedule:
           cron: "0 0 * * *"
           filters:
             branches:
               only:
                 - main
                 - beta
     jobs:
       - test     cron  The cron key is defined using POSIX crontab syntax.  KeyRequiredTypeDescriptioncronYStringSee the  crontab man page.   workflows:
   nightly:
     triggers:
       - schedule:
           cron: "0 0 * * *"
           filters:
             branches:
               only:
                 - main
                 - beta
     jobs:
       - test      filters  Trigger filters can have the key branches.  KeyRequiredTypeDescriptionfiltersYMapA map defining rules for execution on specific branches   workflows:
   nightly:
     triggers:
       - schedule:
           cron: "0 0 * * *"
           filters:
             branches:
               only:
                 - main
                 - beta
     jobs:
       - test      branches  The branches key controls whether the current branch should have a schedule trigger created for it, where current branch is the branch containing the config.yml file with the trigger stanza. That is, a push on the main branch will only schedule a  workflow for the main branch.   Branches can have the keys only and ignore which each map to a single string naming a branch. You may also use regular expressions to match against branches by enclosing them with `/’s, or map to a list of such strings. Regular expressions must match the entire string.     Any branches that match only will run the job.   Any branches that match ignore will not run the job.   If neither only nor ignore are specified then all branches will run the job. If both only and ignore are specified, the only is used and ignore will have no effect.      workflows:
  commit:
    jobs:
      - test
      - deploy
  nightly:
    triggers:
      - schedule:
          cron: "0 0 * * *"
          filters:
            branches:
              only:
                - main
                - /^release\/.*/
    jobs:
      - coverage   KeyRequiredTypeDescriptionbranchesYMapA map defining rules for execution on specific branchesonly 1NString, or List of StringsEither a single branch specifier, or a list of branch specifiersignore 1NString, or List of StringsEither a single branch specifier, or a list of branch specifiers  1: One of either only or ignore branch filters must be specified. If both are present, only is used.       Using when in workflows     Using when or unless under workflows is supported in version: 2.1 configuration. Workflows are always run unless there is a when or unless filter that prevents the workflow from being run. If you want a workflow to run in every pipeline, do not add a when or unless filter.        You may use a when clause (the inverse clause unless is also supported) under a workflow declaration with a  logic statement to determine whether or not to run that workflow.   The example configuration below uses a pipeline parameter, run_integration_tests to drive the integration_tests workflow.    version: 2.1

workflows:
  integration_tests:
    when: pipeline.git.branch == "main"
    jobs:
      - mytestjob

jobs:
...    This example prevents the workflow integration_tests from running unless the pipeline is triggered on the main branch.   Refer to the  Workflows for more examples and conceptual information.     jobs  A job can have the keys requires, name, context, type, and filters.  KeyRequiredTypeDescriptionjobsYListA list of jobs to run with their dependencies   <job_name>  A job name that exists in your config.yml.    serial-group  The serial-group key is used to add a property to a job to allow a group of jobs to run in series, rather than concurrently, across an organization. Serial groups control the orchestration of jobs across an organization, not just within projects and pipelines.   The serial-group key is configurable per job. It is not possible to configure the key for a group of jobs at this time.   The value of the serial-group key is a string that is used to group jobs together to run one after another. The key must meet the following requirements:     Must be less than or equal to (≤) 512 characters, once compiled.   Must not be blank.   Must consist of alphanumeric characters plus, ., -, _, /.     Note the following features of serial groups:     You can use pipeline values and parameters in the serial-group key.   Serial groups will wait for five hours. After this jobs waiting in the group will be cancelled. This does not affect the standard limits that apply to a  job’s runtime.         Pipeline order protection in serial groups   Jobs in a serial group follow an order protection mechanism, as follows:     Jobs start in the order they join the queue, but are accepted based on pipeline number.   If a group is waiting/running and another job in the same project attempts to join the queue with a lower pipeline number, the job is skipped.   This immediate skip process exists to maintain order integrity, which is a safety process to avoid unexpected work in a build, for example, a deployment job running a previous version unexpectedly.     If there are no serial groups waiting/running, a pipeline with a lower number can start, such as restoring back to a previous pipeline via a rerun workflow.        KeyRequiredTypeDescriptionserial-groupNStringA string that is used across an org to group jobs together to run one after another. Can include pipeline values and parameters. Use this same serial group across multiple pipelines to control the orchestration of jobs across an organization.  Example:    # Creating multiple pipelines at the same time with the below config will results in
# all pipelines running test and build but only a single pipeline will run deploy at a time.

workflows:
  main-workflow:
    jobs:
      - test
      - build
      - deploy:
          serial-group: << pipeline.project.slug >>/deploy-group
          requires:
            - test
            - build    For more information, see the  Controlling serial execution across your organization page. '''    requires  Jobs are run concurrently by default, so you must explicitly require any dependencies by their job name if you need some jobs to run sequentially.  KeyRequiredTypeDescriptionrequiresNList A list of jobs that must succeed or attain a specified status for the job to start. Note: When jobs in the current workflow that are listed as dependencies are not executed (due to a filter function for example), their requirement as a dependency for other jobs will be ignored by the requires option. However, if all dependencies of a job are filtered, then that job will not be executed either.   Possible types of requires items:     Job name (a required job that must succeed for the job to start)   Map of job name to status (a required job that must attain the specified status for the job to start)   Map of job name to a list of statuses (a required job that must attain one of the specified status for the job to start)     The possible status values are: success, failed and canceled.    workflows:
  my-workflow:
    jobs:
      - build
      - test:
          requires:
            - build
      - deploy:
          requires:
            - build
            - test
      - notify-build-canceled:
          requires:
            - build: canceled
      - cleanup:
          requires:
            - deploy:
              - failed
              - canceled      name  The name key can be used to invoke reusable jobs across any number of workflows. Using the name key ensures numbers are not appended to your job name (for example, sayhello-1 , sayhello-2, etc.). The name you assign to the name key needs to be unique, otherwise the numbers will still be appended to the job name.  KeyRequiredTypeDescriptionnameNStringA replacement for the job name. Useful when calling a job multiple times. If you want to invoke the same job multiple times, and a job requires one of the duplicate jobs, this key is required. (2.1 only)    context  Jobs may be configured to use global environment variables set for an organization, see the  Contexts document for adding a context in the application settings.  KeyRequiredTypeDescriptioncontextNString/ListThe name of the context(s). The initial default name is org-global. Each context name must be unique. If using CircleCI server, only a single context per workflow is supported. Note: A maximum of 100 unique contexts across all workflows is allowed.    type  A job may have a type of approval indicating it must be manually approved before downstream jobs may proceed. For more information see the  Using workflows to orchestrate jobs page.   Jobs run in the dependency order until the workflow processes a job with the type: approval key followed by a job on which it depends, for example:    workflows:
  my-workflow:
    jobs:
      - build
      - test:
          requires:
            - build
      - hold:
          type: approval
          requires:
            - test
      - deploy:
          requires:
            - hold    An approval job can have any name. In the example above the approval job is named hold. The name you choose for an approval job should not be used to define a job in the main configuration. An approval job only exists as a workflow orchestration devise.     filters  Filter job execution within a workflow based on the following:     Branch   Tag   Expression-based condition     Job filters can have the keys branches or tags.      Workflows will ignore job-level branching. If you use job-level branching and later add workflows, you must remove the branching at the job level and instead declare it in the workflows section of your config.yml.       KeyRequiredTypeDescriptionfiltersNMapA map or string to define rules for job execution. Branch and tag filters require a map. Expression-based filters require a string.  The following is an example of how the CircleCI documentation project uses a regular expression to filter running a job in a workflow only on a specific branch:    # ...
workflows:
  build-deploy:
    jobs:
      - js_build
      - build_server_pdfs: # << the job to conditionally run based on the filter-by-branch-name.
          filters:
            branches:
              only: /server\/.*/ # the job build_server_pdfs will only run when the branch being built starts with server/    You can read more about using regular expressions in your config in the  Using workflows to schedule jobs page.     Expression-based job filters  Expression-based job filters allow you to conditionally run jobs based on the following:      Pipeline values    Pipeline parameters     An expression-based job filter is a rule that is evaluated against pipeline values and parameters to decide whether a job should run.   Using expression-based job filters is one way to optimize your pipelines. Optimizations include the following:     Lower costs.   Decrease time to feedback.   Run specific jobs based on the context of the source of change.      workflows:
  deploy:
    jobs:
      - init-service
      - test-service
      - build-service-image:
          requires:
            - init-service
      - dry-run-service:
          requires:
            - init-service
          filters: pipeline.git.branch != "main" and pipeline.git.branch != "canary"
      - publish-service:
          requires:
            - build-service-image
            - test-service
          filters: pipeline.git.branch == "main" or pipeline.git.tag starts-with "release"
      - deploy-service:
          context:
            - org-global
          requires:
            - publish-service
          filters: pipeline.git.branch == "main" and pipeline.parameters.my-custom-param starts-with "DEPLOY:"    Examples   Only run the job on the project’s main branch:    filters: pipeline.git.branch == "main"    Only run the job on the project’s main branch, or branches starting with integration-test:    filters: pipeline.git.branch == "main" or pipeline.git.branch starts-with "integration-test"    Only run the job on the main branch, and disallow use with pipelines  triggered with unversioned configuration:    filters: pipeline.git.branch == "main" and not (pipeline.trigger_source starts-with "api")    Use pipeline parameters and the pipeline value pipeline.git.branch to run a job only on specific branches or when triggered via the API with a pipeline parameter set to true:    version: 2.1

parameters:
  run-storybook-tests:
    type: boolean
    default: false

...
# jobs configuration ommitted for brevity

workflows:
  build:
    jobs:
      - setup
      - storybook-tests:
          requires:
            - setup
          filters: |
            pipeline.parameters.run-storybook-tests
            or pipeline.git.branch == "dry-run-deploy"
            or pipeline.git.branch starts-with "deploy"    You can use the API to trigger a pipeline with a pipeline parameter set to true:      Using server? If you are using CircleCI server, replace https://circleci.com with your server hostname when interacting with the CircleCI API.         curl -X POST https://circleci.com/api/v2/project/circleci/<org-id>/<project-id>/pipeline/run \
  --header "Circle-Token: $CIRCLE_TOKEN" \
  --header "content-type: application/json" \
  --data {
  "definition_id": "<pipeline-definition-id>",
  "config": {"branch": "<your-branch-name>"},
  "checkout": {"branch": "<your-branch-name>"},
  "parameters": {"run-storybook-tests": "true"}
  }    Operators   The operators you can use for expression-based job filters are described in the following table. You can also group sub-expressions with parentheses (, ). as in the examples above.  Operator typeOperatorsDescriptionLogicaland, orThese are short-circuiting boolean operators.Equality==, !=String, numeric, and boolean equality. If the operands are of different types then == will evaluate false, and != will evaluate true.Equalitystarts-withString prefix equality, "hello world" starts-with "hello" evaluates as true. It is an error to use a non-string type as an operand.Numeric comparison>=, >, ⇐, <Numeric comparisons. It is an error to use a non-numeric type as an operand.Negationnot Boolean negation.   Note that not has very high precedence and so binds very tightly. Use sub-expressions to apply not to more complex expressions. For example, with foo being true and bar being false:     not foo and bar evaluates to false   not (foo and bar) evaluates to true       branches  The branches filter can have the keys only and ignore, which map to a single string naming a branch. You may also use regular expressions to match against branches by enclosing them with slashes, or map to a list of such strings. Regular expressions must match the entire string.     Any branches that match only will run the job.   Any branches that match ignore will not run the job.   If neither only nor ignore are specified then all branches will run the job.   If both only and ignore are specified the only is considered before ignore.    KeyRequiredTypeDescriptionbranchesNMapA map defining rules for execution on specific branches.onlyNString, or list of stringsEither a single branch specifier, or a list of branch specifiers.ignoreNString, or list of stringsEither a single branch specifier, or a list of branch specifiers.   workflows:
  dev_stage_pre-prod:
    jobs:
      - test_dev:
          filters:  # using regex filters requires the entire branch to match
            branches:
              only:  # only branches matching the below regex filters will run
                - dev
                - /user-.*/
      - test_stage:
          filters:
            branches:
              only: stage
      - test_pre-prod:
          filters:
            branches:
              only: /pre-prod(?:-.+)?$/      tags  CircleCI does not run workflows for tags unless you explicitly specify tag filters. If a job requires any other jobs (directly or indirectly), you must specify tag filters for those jobs.   Tags can have the keys only and ignore. You may also use regular expressions to match against tags by enclosing them with slashes, or map to a list of such strings. Regular expressions must match the entire string. Both lightweight and annotated tags are supported.     Any tags that match only will run the job.   Any tags that match ignore will not run the job.   If neither only nor ignore are specified then the job is skipped for all tags.   If both only and ignore are specified the only is considered before ignore.    KeyRequiredTypeDescriptiontagsNMapA map defining rules for execution on specific tagsonlyNString, or List of StringsEither a single tag specifier, or a list of tag specifiersignoreNString, or List of StringsEither a single tag specifier, or a list of tag specifiers  For more information, see the  Executing workflows for a git tag section of the Workflows page.    workflows:
  untagged-build:
    jobs:
      - build
  tagged-build:
    jobs:
      - build:
          filters:
            tags:
              only: /^v.*/      matrix     The matrix key is supported in version: 2.1 configuration        The matrix stanza allows you to run a parameterized job multiple times with different arguments. For more information see the how-to guide on  Using Matrix Jobs. In order to use the matrix stanza, you must use parameterized jobs.  KeyRequiredTypeDescriptionparametersYMapA map of parameter names to every value the job should be called withexcludeNListA list of argument maps that should be excluded from the matrixaliasNStringAn alias for the matrix, usable from another job’s requires stanza. Defaults to the name of the job being executed  Example:   The following is a basic example of using matrix jobs.    workflows:
  workflow:
    jobs:
      - build:
          matrix:
            parameters:
              version: ["0.1", "0.2", "0.3"]
              platform: ["macos", "windows", "linux"]    This expands to 9 different build jobs, and could be equivalently written as:    workflows:
  workflow:
    jobs:
      - build:
          name: build-macos-0.1
          version: "0.1"
          platform: macos
      - build:
          name: build-macos-0.2
          version: "0.2"
          platform: macos
      - build:
          name: build-macos-0.3
          version: "0.3"
          platform: macos
      - build:
          name: build-windows-0.1
          version: "0.1"
          platform: windows
      - ...      Excluding sets of parameters from a matrix  Sometimes you may wish to run a job with every combination of arguments except some value or values. You can use an exclude stanza to achieve this:    workflows:
  workflow:
    jobs:
      - build:
          matrix:
            parameters:
              a: [1, 2, 3]
              b: [4, 5, 6]
            exclude:
              - a: 3
                b: 5    The matrix above would expand into 8 jobs: every combination of the parameters a and b, excluding {a: 3, b: 5}     Dependencies and matrix jobs  To require an entire matrix (every job within the matrix), use its alias. The alias defaults to the name of the job being invoked.    workflows:
  workflow:
    jobs:
      - deploy:
          matrix:
            parameters:
              version: ["0.1", "0.2"]
      - another-job:
          requires:
            - deploy    This means that another-job will require both deploy jobs in the matrix to finish before it runs.   Matrix jobs expose their parameter values via << matrix.* >> which can be used to generate more complex workflows. For example, here is a deploy matrix where each job waits for its respective build job in another matrix.    workflows:
  workflow:
    jobs:
      - build:
          name: build-v<< matrix.version >>
          matrix:
            parameters:
              version: ["0.1", "0.2"]
      - deploy:
          name: deploy-v<< matrix.version >>
          matrix:
            parameters:
              version: ["0.1", "0.2"]
          requires:
            - build-v<< matrix.version >>    This workflow will expand to:    workflows:
  workflow:
    jobs:
      - build:
          name: build-v0.1
          version: "0.1"
      - build:
          name: build-v0.2
          version: "0.2"
      - deploy:
          name: deploy-v0.1
          version: "0.1"
          requires:
            - build-v0.1
      - deploy:
          name: deploy-v0.2
          version: "0.2"
          requires:
            - build-v0.2      pre-steps and post-steps     Pre-steps and post-steps are supported in version: 2.1 configuration        Every job invocation in a workflow may optionally accept two special arguments: pre-steps and post-steps.   Steps under pre-steps are executed before any of the other steps in the job. The steps under post-steps are executed after all of the other steps.   Pre and post steps allow you to execute steps in a given job without modifying the job. Pre and post steps are useful, for example, to run custom setup steps before job execution.    version: 2.1

jobs:
  bar:
    machine:
      image: ubuntu-2004:2024.05.1
    steps:
      - checkout
      - run:
          command: echo "building"
      - run:
          command: echo "testing"

workflows:
  build:
    jobs:
      - bar:
          pre-steps: # steps to run before steps defined in the job bar
            - run:
                command: echo "install custom dependency"
          post-steps: # steps to run after steps defined in the job bar
            - run:
                command: echo "upload artifact to s3"           Logic statements   Certain dynamic configuration features accept logic statements as arguments. Logic statements are evaluated to boolean values at configuration compilation time, that is, before the workflow is run. The group of logic statements includes:  TypeArgumentstrue ifExampleYAML literalNoneis truthytrue/42/"a string"YAML aliasNoneresolves to a truthy value*my-alias Pipeline ValueNoneresolves to a truthy value<< pipeline.git.branch >> Pipeline ParameterNoneresolves to a truthy value<< pipeline.parameters.my-parameter >>andN logic statementsall arguments are truthyand: [ true, true, false ]orN logic statementsany argument is truthyor: [ false, true, false ]not1 logic statementthe argument is not truthynot: trueequalN valuesall arguments evaluate to equal valuesequal: [ 42, << pipeline.number >>]matchespattern and valuevalue matches the patternmatches: { pattern: "^feature-.$", value: << pipeline.git.branch >> }+  The following logic values are considered falsy:     false   null   0   NaN   empty strings ("")   statements with no arguments     All other values are truthy. Also note that using logic with an empty list will cause a validation error.   Logic statements always evaluate to a boolean value at the top level, and coerce as necessary. They can be nested in an arbitrary fashion, according to their argument specifications, and to a maximum depth of 100 levels.   matches uses  Java regular expressions for its pattern. A full match pattern must be provided, prefix matching is not an option. Though, it is recommended to enclose a pattern in ^ and $ to avoid accidental partial matches.      When using logic statements at the workflow level, do not include the condition: key (the condition key is only needed for job level logic statements).         workflows:
  my-workflow:
    when:
      or:
        - equal: [ main, << pipeline.git.branch >> ]
        - equal: [ staging, << pipeline.git.branch >> ]    Logic statement examples  You can find usage examples on the  "Orchestration cookbook" page.      Example full configuration      Using Docker? Authenticating Docker pulls from image registries is recommended when using the Docker execution environment. Authenticated pulls allow access to private Docker images, and may also grant higher rate limits, depending on your registry provider. For further information see  Using Docker authenticated pulls.         version: 2.1
jobs:
  build:
    docker:
      - image: ubuntu:23.04

      - image: mongo:6.0.14
        command: [mongod, --smallfiles]

      - image: postgres:14.12
        # some containers require setting environment variables
        environment:
          POSTGRES_USER: user

      - image: redis@sha256:54057dd7e125ca41afe526a877e8bd35ec2cdd33b9217e022ed37bdcf7d09673

      - image: rabbitmq:3.12.12

    environment:
      TEST_REPORTS: /tmp/test-reports

    working_directory: ~/my-project

    steps:
      - checkout

      - run:
          command: echo 127.0.0.1 devhost | sudo tee -a /etc/hosts

      # Create Postgres users and database
      # Note the YAML heredoc '|' for nicer formatting
      - run: |
          sudo -u root createuser -h localhost --superuser ubuntu &&
          sudo createdb -h localhost test_db

      - restore_cache:
          keys:
            - v1-my-project-{{ checksum "project.clj" }}
            - v1-my-project-

      - run:
          environment:
            SSH_TARGET: "localhost"
            TEST_ENV: "linux"
          command: |
            set -xu
            mkdir -p ${TEST_REPORTS}
            run-tests.sh
            cp out/tests/*.xml ${TEST_REPORTS}

      - run: |
          set -xu
          mkdir -p /tmp/artifacts
          create_jars.sh << pipeline.number >>
          cp *.jar /tmp/artifacts

      - save_cache:
          key: v1-my-project-{{ checksum "project.clj" }}
          paths:
            - ~/.m2

      # Save artifacts
      - store_artifacts:
          path: /tmp/artifacts
          destination: build

      # Upload test results
      - store_test_results:
          path: /tmp/test-reports

  deploy-stage:
    docker:
      - image: ubuntu:23.04
    working_directory: /tmp/my-project
    steps:
      - run:
          name: Deploy if tests pass and branch is Staging
          command: ansible-playbook site.yml -i staging

  deploy-prod:
    docker:
      - image: ubuntu:23.04
    working_directory: /tmp/my-project
    steps:
      - run:
          name: Deploy if tests pass and branch is Main
          command: ansible-playbook site.yml -i production

workflows:
  build-deploy:
    jobs:
      - build:
          filters:
            branches:
              ignore:
                - develop
                - /feature-.*/
      - deploy-stage:
          requires:
            - build
          filters:
            branches:
              only: staging
      - deploy-prod:
          requires:
            - build
          filters:
            branches:
              only: main    Suggest an edit to this pageMake a contribution Learn how to contributeStill need help? Ask the CircleCI community Join the research community Visit our Support site DocsTerms of UsePrivacy PolicyCookie PolicySecurity© 2025 Circle Internet Services, Inc., All Rights Reserved.\n\nThe orbs key is supported in version: 2.1 configuration  version: 2.1

orbs:
  node: circleci/node@x.y

jobs:
  install-node-example:
    docker:
      - image: cimg/base:stable
    steps:
      - checkout
      - node/install:
          install-yarn: true
          node-version: '16.13'
      - run: node --version
workflows:
  test_my_app:
    jobs:
      - install-node-example  The commands key is supported in version: 2.1 configuration  commands:
  sayhello:
    description: "A very simple command for demonstration purposes"
    parameters:
      to:
        type: string
        default: "Hello World"
    steps:
      - run: echo << parameters.to >>  The pipeline parameters key is supported in version: 2.1 configuration  The executors key is supported in version: 2.1 configuration  version: 2.1
executors:
  my-executor:
    docker:
      - image: cimg/ruby:3.0.3-browsers

jobs:
  my-job:
    executor: my-executor
    steps:
      - run: echo "Hello executor!"  jobs:
  my-job:
    docker:
      - image: cimg/base:2024.12
    resource_class: xlarge
    steps:
      ... // other config  jobs:
  release-my-service:
    type: release
    plan_name: <my-service-release>  jobs:
  my-no-op-job:
    type: no-op  workflows:
  my-workflow:
    jobs:
      - build
      - test:
          requires:
            - build
      - hold:
          type: approval
          requires:
            - test
      - deploy:
          requires:
            - hold  jobs:
  build:
    docker:
      - image: cimg/base:2024.12
    environment:
      FOO: bar
    parallelism: 3
    resource_class: large
    working_directory: ~/my-app
    steps:
      - run: go list ./... | circleci tests run --command "xargs gotestsum --junitfile junit.xml --format testname --" --split-by=timings --timings-type=name  jobs:
  build:
    docker:
      - image: buildpack-deps:trusty # primary container
        auth:
          username: mydockerhub-user
          password: $DOCKERHUB_PASSWORD  # context / project UI env-var reference
        environment:
          ENV: CI

      - image: mongo:2.6.8
        auth:
          username: mydockerhub-user
          password: $DOCKERHUB_PASSWORD  # context / project UI env-var reference
        command: [--smallfiles]

      - image: postgres:14.2
        auth:
          username: mydockerhub-user
          password: $DOCKERHUB_PASSWORD  # context / project UI env-var reference
        environment:
          POSTGRES_USER: user

      - image: redis@sha256:54057dd7e125ca41afe526a877e8bd35ec2cdd33b9217e022ed37bdcf7d09673
        auth:
          username: mydockerhub-user
          password: $DOCKERHUB_PASSWORD  # context / project UI env-var reference

      - image: acme-private/private-image:321
        auth:
          username: mydockerhub-user
          password: $DOCKERHUB_PASSWORD  # context / project UI env-var reference  jobs:
  job_name:
    docker:
      - image: <your-image-arn>
        aws_auth:
          oidc_role_arn: <your-iam-role-arn>  jobs:
  build:
    docker:
      - image: account-id.dkr.ecr.us-east-1.amazonaws.com/org/repo:0.1
        aws_auth:
          aws_access_key_id: AKIAQWERVA  # can specify string literal values
          aws_secret_access_key: $ECR_AWS_SECRET_ACCESS_KEY  # or project UI envar reference  CircleCI cloud The use of machine: true is deprecated. You must specify an image to use.    jobs:
  build: # name of your job
    machine: # executor type
      image: ubuntu-2004:current # recommended linux image

    steps:
      # Commands run in a Linux virtual machine environment    jobs:
  build: # name of your job
    machine: # executor type
      image: ubuntu-2004:current # recommended linux image

    steps:
      # Commands run in a Linux virtual machine environment    jobs:
  build: # name of your job
    machine: true # executor type
    steps:
      # Commands run in a Linux virtual machine environment    jobs:
  build: # name of your job
    machine: true # executor type
    steps:
      # Commands run in a Linux virtual machine environment  version: 2.1

jobs:
  build:
    machine:
      image: android:2024.11.1  version: 2.1

jobs:
  build:
    machine:
      image: windows-server-2019-cuda:current  jobs:
  build:
    macos:
      xcode: "14.2.0"  Java, Erlang and any other languages that introspect the /proc directory for information about CPU count may require additional configuration to prevent them from slowing down when using the CircleCI resource class feature. Programs with this issue may request 32 CPU cores and run slower than they would when requesting one core. Users of languages with this issue should pin their CPU count to their guaranteed CPU resources.  If you want to confirm how much memory you have been allocated, you can check the cgroup memory hierarchy limit with grep hierarchical_memory_limit /sys/fs/cgroup/memory/memory.stat.  jobs:
  job_name:
    machine: true
    resource_class: <my-namespace>/<my-runner>  jobs:
  build:
    docker:
      - image: cimg/base:2024.12
    resource_class: xlarge
    steps:
      ... // other config  For credit and access information, see the  Resource classes page. Resource class access is dependent on your  Plan.   Arm on Docker For credit and access information see the  Resource classes page. Resource class access is dependent on your  Plan   To find out which CircleCI Docker convenience images support Arm resource classes, you can refer to  Docker hub:     Select the image (for example, cimg/python).   Select the tags tab.   View what is supported under OS/ARCH for the latest tags. For example, cimg/python has linux/amd64 and linux/arm64, which means Arm is supported.       jobs:
  build:
    machine:
      image: ubuntu-2004:2024.01.2 # recommended linux image
    resource_class: large
    steps:
      ... // other config    jobs:
  build:
    machine:
      image: ubuntu-2004:2024.01.2 # recommended linux image
    resource_class: large
    steps:
      ... // other config    jobs:
  build:
    machine: true
    resource_class: large
    steps:
      ... // other config    jobs:
  build:
    machine: true
    resource_class: large
    steps:
      ... // other config   We have deprecated support for all Intel-based macOS resources.   The macos.x86.medium.gen2 resource class was deprecated on June 28, 2024.   See our  announcement for more details.   jobs:
  build:
    macos:
      xcode: "15.4.0"
    resource_class: m2pro.medium
    steps:
      ... // other config  Using server? Check with your systems administrator whether you have access to the Windows execution environment.    version: 2.1

jobs:
  build: # name of your job
    resource_class: 'windows.medium'
    machine:
      image: 'windows-server-2022-gui:current'
      shell: 'powershell.exe -ExecutionPolicy Bypass'
    steps:
      # Commands are run in a Windows virtual machine environment
      - checkout
      - run: Write-Host 'Hello, Windows'    version: 2.1

jobs:
  build: # name of your job
    resource_class: 'windows.medium'
    machine:
      image: 'windows-server-2022-gui:current'
      shell: 'powershell.exe -ExecutionPolicy Bypass'
    steps:
      # Commands are run in a Windows virtual machine environment
      - checkout
      - run: Write-Host 'Hello, Windows'    version: 2.1

jobs:
  build: # name of your job
    machine:
      image: windows-default
    steps:
      # Commands are run in a Windows virtual machine environment
      - checkout
      - run: Write-Host 'Hello, Windows'    version: 2.1

jobs:
  build: # name of your job
    machine:
      image: windows-default
    steps:
      # Commands are run in a Windows virtual machine environment
      - checkout
      - run: Write-Host 'Hello, Windows'  version: 2.1

jobs:
  build:
    machine:
      image: linux-cuda-12:default
    resource_class: gpu.nvidia.medium
    steps:
      - run: nvidia-smi
      - run: docker run --gpus all nvidia/cuda:9.0-base nvidia-smi  version: 2.1
orbs:
  win: circleci/windows@5.0.0

jobs:
  build:
    executor: win/server-2019-cuda
    steps:
      - checkout
      - run: '&"C:\Program Files\NVIDIA Corporation\NVSMI\nvidia-smi.exe"'  Using server? Check with your systems administrator whether you have access to the Arm execution environment.    jobs:
  my-job:
    machine:
      image: ubuntu-2004:2024.01.2
    resource_class: arm.medium
    steps:
      - run: uname -a
      - run: echo "Hello, Arm!"    jobs:
  my-job:
    machine:
      image: ubuntu-2004:2024.01.2
    resource_class: arm.medium
    steps:
      - run: uname -a
      - run: echo "Hello, Arm!"    jobs:
  my-job:
    machine:
      image: arm-default
    resource_class: arm.medium
    steps:
      - run: uname -a
      - run: echo "Hello, Arm!"    jobs:
  my-job:
    machine:
      image: arm-default
    resource_class: arm.medium
    steps:
      - run: uname -a
      - run: echo "Hello, Arm!"  jobs:
  build:
    working_directory: ~/canary-python
    environment:
      FOO: bar
    steps:
      - run:
          name: Running tests
          command: make test  jobs:
  build:
    steps:
      - run: make test  jobs:
  build:
    steps:
      - checkout  the run step replaces the deprecated deploy step. If your job has a parallelism of 1, the deprecated deploy step can be swapped out directly for the run step. If your job has parallelism > 1, see  Migrate from deploy to run.  - run:
    command: |
      echo Running test
      mkdir -p /tmp/test-results
      make test  - run:
    command: |
      echo Running test
      set +e
      mkdir -p /tmp/test-results
      make test

- run:
    shell: /bin/sh
    command: |
      echo Running test
      mkdir -p /tmp/test-results
      make test  - run: make test | tee test-output.log  If make test fails the rest of pipeline will be executed.  - run:
    name: Running X virtual framebuffer
    command: Xvfb :99 -screen 0 1280x1024x24
    background: true

- run: make test  - run: make test

# shorthanded command can also have multiple lines
- run: |
    mkdir -p /tmp/test-results
    make test  Some steps, such as store_artifacts and store_test_results will always run, even if a step has failed (returned a non-zero exit code) previously. The when attribute, store_artifacts and store_test_results are not run if the job has been killed by a cancel request or has reached the runtime timeout limit.  - run:
    name: Upload CodeCov.io Data
    command: bash <(curl -s https://codecov.io/bash) -F unittests
    when: always # Uploads code coverage results, pass or fail  - run: |
    if [ "$CIRCLE_BRANCH" = "develop" ]; then
        circleci-agent step halt
    fi  The when and unless steps are supported in version: 2.1 configuration  version: 2.1

jobs: # conditional steps may also be defined in `commands:`
  job_with_optional_custom_checkout:
    parameters:
      custom_checkout:
        type: string
        default: ""
    machine:
      image: ubuntu-2004:2024.11.1
    steps:
      - when:
          condition: <<parameters.custom_checkout>>
          steps:
            - run: echo "my custom checkout"
      - unless:
          condition: <<parameters.custom_checkout>>
          steps:
            - checkout
workflows:
  build-test-deploy:
    jobs:
      - job_with_optional_custom_checkout:
          custom_checkout: "any non-empty string is truthy"
      - job_with_optional_custom_checkout   Blobless clones   A "blobless" strategy is being rolled out to help improve the performance of code checkouts from Git source code hosts.   Blobless clones reduce the amount of data fetched from the remote, by asking the remote to filter out objects that are not attached to the current commit.   While this improves performance in most cases, if a downstream step requires those objects to exist for scanning or comparisons, it can cause failures. To work around these potential problems, a fetch directly after a checkout will ensure the required data is available:    - checkout
- run: git fetch    - checkout
- run: git fetch  - checkout  - checkout
- run: git submodule sync
- run: git submodule update --init  The checkout step will configure Git to skip automatic garbage collection. If you are caching your .git directory with  restore_cache and would like to use garbage collection to reduce its size, you may wish to use a  run step with command git gc before doing so.  jobs:
  build:
    docker:
      - image: cimg/base:2024.06
    steps:
      # ... steps for building/testing app ...
      - setup_remote_docker:
          version: default     setup_remote_docker is not compatible with the machine executor. See  Docker Layer Caching in Machine Executor for information on how to enable DLC with the machine executor.   The version key is not currently supported on CircleCI server. Contact your system administrator for information about the Docker version installed in your remote Docker environment. If you are on server 4.x, you can find the default AWS AMI  here.     If the cache for the given key already exists it will not be modified, and job execution will proceed to the next step.  Given the immutability of caches, it might be helpful to start all your cache keys with a version prefix v1-.... That way you will be able to regenerate all your caches just by incrementing the version in this prefix.  - save_cache:
    key: v1-myapp-{{ arch }}-{{ checksum "project.clj" }}
    paths:
      - /home/ubuntu/.m2  - save_cache:
    key: v1-{{ checksum "yarn.lock" }}
    paths:
      - node_modules/workspace-a
      - node_modules/workspace-c     Wildcards are not currently supported in save_cache paths. Visit the  Ideas board and vote for this feature if it would be useful for you or your organization.   In some instances, a workaround for this is to save a particular workspace to cache:     When there are multiple matches, the most recent match will be used, even if there is a more precise match.  steps:
  - save_cache:
      key: v1-myapp-cache
      paths:
        - ~/d1

  - save_cache:
      key: v1-myapp-cache-new
      paths:
        - ~/d2

  - run: rm -f ~/d1 ~/d2

  - restore_cache:
      key: v1-myapp-cache  - restore_cache:
    keys:
      - v1-myapp-{{ arch }}-{{ checksum "project.clj" }}
      # if cache for exact version of `project.clj` is not present then load any most recent one
      - v1-myapp-

# ... Steps building and testing your application ...

# cache will be saved only once for each version of `project.clj`
- save_cache:
    key: v1-myapp-{{ arch }}-{{ checksum "project.clj" }}
    paths:
      - /foo  - run:
    name: Build the Jekyll site
    command: bundle exec jekyll build --source jekyll --destination jekyll/_site/docs/
- store_artifacts:
    path: jekyll/_site/docs/
    destination: circleci-docs  test-results
├── jest
│   └── results.xml
├── mocha
│   └── results.xml
└── rspec
    └── results.xml  - store_test_results:
    path: test-results  - persist_to_workspace:
    root: /tmp/dir
    paths:
      - foo/bar
      - baz  /tmp/dir/foo/bar
/tmp/dir/baz  - persist_to_workspace:
    root: /tmp/workspace
    paths:
      - target/application.jar
      - build/*  pattern:
        { term }
term:
        '*' matches any sequence of non-Separator characters
        '?' matches any single non-Separator character
        '[' [ '^' ] { character-range }
        ']' character class (must be non-empty)
        c matches character c (c != '*', '?', '\\', '[')
        '\\' c matches character c
character-range:
        c matches character c (c != '\\', '-', ']')
        '\\' c matches character c
        lo '-' hi matches character c for lo <= c <= hi  Everything must be relative to the work space root directory.  - attach_workspace:
    at: /tmp/workspace  The lifetime of artifacts, workspaces, and caches can be customized on the  CircleCI web app by navigating to Plan  Usage Controls. Here you can control the storage retention periods for these objects. If no storage period is set, the default storage retention period of artifacts is 30 days, while the default storage retention period of workspaces and caches is 15 days.  Using server? only MD5 fingerprints are supported. In CircleCI in Project Settings  SSH keys  Additional SSH keys the MD5 fingerprint will be visible. SHA256 support is planned for an upcoming server release.  steps:
  - add_ssh_keys:
      fingerprints:
        - "b7:35:a6:4e:9b:0d:6d:d4:78:1e:9a:97:2a:66:6b:be"
        - "SHA256:NPj4IcXxqQEKGXOghi/QbG2sohoNfvZ30JwCcdSSNM0"  Even though CircleCI uses ssh-agent to sign all added SSH keys, you must use the add_ssh_keys key to actually add keys to a container.  version: 2.1
jobs:
  build:
    docker:
      - image: cimg/node:20.18.1
    environment:
      IMAGETAG: latest
    working_directory: ~/main
    steps:
      - run: echo "This is pipeline ID << pipeline.id >>"  A paid account on a  Performance or Scale Plan is required to access IP ranges.  version: 2.1

jobs:
  build:
    circleci_ip_ranges: true # opts the job into the IP ranges feature
    docker:
      - image: curlimages/curl
    steps:
      - run: echo “Hello World”
workflows:
  build-workflow:
    jobs:
      - build  The workflows version key is not required for version: 2.1 configuration  workflows:
   nightly:
     triggers:
       - schedule:
           cron: "0 0 * * *"
           filters:
             branches:
               only:
                 - main
                 - beta
     jobs:
       - test  Scheduled workflows are not available for projects integrated through the GitHub App, GitLab or Bitbucket Data Center.  The scheduled workflows feature is set to be deprecated. Using scheduled pipelines rather than scheduled workflows offers several benefits. Visit the scheduled pipelines  migration guide to find out how to migrate existing scheduled workflows to scheduled pipelines. If you would like to set up scheduled pipelines from scratch, visit the  Scheduled pipelines page.  workflows:
   nightly:
     triggers:
       - schedule:
           cron: "0 0 * * *"
           filters:
             branches:
               only:
                 - main
                 - beta
     jobs:
       - test  workflows:
   nightly:
     triggers:
       - schedule:
           cron: "0 0 * * *"
           filters:
             branches:
               only:
                 - main
                 - beta
     jobs:
       - test  workflows:
   nightly:
     triggers:
       - schedule:
           cron: "0 0 * * *"
           filters:
             branches:
               only:
                 - main
                 - beta
     jobs:
       - test  workflows:
  commit:
    jobs:
      - test
      - deploy
  nightly:
    triggers:
      - schedule:
          cron: "0 0 * * *"
          filters:
            branches:
              only:
                - main
                - /^release\/.*/
    jobs:
      - coverage  Using when or unless under workflows is supported in version: 2.1 configuration. Workflows are always run unless there is a when or unless filter that prevents the workflow from being run. If you want a workflow to run in every pipeline, do not add a when or unless filter.  version: 2.1

workflows:
  integration_tests:
    when: pipeline.git.branch == "main"
    jobs:
      - mytestjob

jobs:
...   Pipeline order protection in serial groups   Jobs in a serial group follow an order protection mechanism, as follows:     Jobs start in the order they join the queue, but are accepted based on pipeline number.   If a group is waiting/running and another job in the same project attempts to join the queue with a lower pipeline number, the job is skipped.   This immediate skip process exists to maintain order integrity, which is a safety process to avoid unexpected work in a build, for example, a deployment job running a previous version unexpectedly.     If there are no serial groups waiting/running, a pipeline with a lower number can start, such as restoring back to a previous pipeline via a rerun workflow.   # Creating multiple pipelines at the same time with the below config will results in
# all pipelines running test and build but only a single pipeline will run deploy at a time.

workflows:
  main-workflow:
    jobs:
      - test
      - build
      - deploy:
          serial-group: << pipeline.project.slug >>/deploy-group
          requires:
            - test
            - build  A list of jobs that must succeed or attain a specified status for the job to start. Note: When jobs in the current workflow that are listed as dependencies are not executed (due to a filter function for example), their requirement as a dependency for other jobs will be ignored by the requires option. However, if all dependencies of a job are filtered, then that job will not be executed either.   Possible types of requires items:     Job name (a required job that must succeed for the job to start)   Map of job name to status (a required job that must attain the specified status for the job to start)   Map of job name to a list of statuses (a required job that must attain one of the specified status for the job to start)     The possible status values are: success, failed and canceled.  workflows:
  my-workflow:
    jobs:
      - build
      - test:
          requires:
            - build
      - deploy:
          requires:
            - build
            - test
      - notify-build-canceled:
          requires:
            - build: canceled
      - cleanup:
          requires:
            - deploy:
              - failed
              - canceled  workflows:
  my-workflow:
    jobs:
      - build
      - test:
          requires:
            - build
      - hold:
          type: approval
          requires:
            - test
      - deploy:
          requires:
            - hold  Workflows will ignore job-level branching. If you use job-level branching and later add workflows, you must remove the branching at the job level and instead declare it in the workflows section of your config.yml.  # ...
workflows:
  build-deploy:
    jobs:
      - js_build
      - build_server_pdfs: # << the job to conditionally run based on the filter-by-branch-name.
          filters:
            branches:
              only: /server\/.*/ # the job build_server_pdfs will only run when the branch being built starts with server/  workflows:
  deploy:
    jobs:
      - init-service
      - test-service
      - build-service-image:
          requires:
            - init-service
      - dry-run-service:
          requires:
            - init-service
          filters: pipeline.git.branch != "main" and pipeline.git.branch != "canary"
      - publish-service:
          requires:
            - build-service-image
            - test-service
          filters: pipeline.git.branch == "main" or pipeline.git.tag starts-with "release"
      - deploy-service:
          context:
            - org-global
          requires:
            - publish-service
          filters: pipeline.git.branch == "main" and pipeline.parameters.my-custom-param starts-with "DEPLOY:"  filters: pipeline.git.branch == "main"  filters: pipeline.git.branch == "main" or pipeline.git.branch starts-with "integration-test"  filters: pipeline.git.branch == "main" and not (pipeline.trigger_source starts-with "api")  version: 2.1

parameters:
  run-storybook-tests:
    type: boolean
    default: false

...
# jobs configuration ommitted for brevity

workflows:
  build:
    jobs:
      - setup
      - storybook-tests:
          requires:
            - setup
          filters: |
            pipeline.parameters.run-storybook-tests
            or pipeline.git.branch == "dry-run-deploy"
            or pipeline.git.branch starts-with "deploy"  Using server? If you are using CircleCI server, replace https://circleci.com with your server hostname when interacting with the CircleCI API.  curl -X POST https://circleci.com/api/v2/project/circleci/<org-id>/<project-id>/pipeline/run \
  --header "Circle-Token: $CIRCLE_TOKEN" \
  --header "content-type: application/json" \
  --data {
  "definition_id": "<pipeline-definition-id>",
  "config": {"branch": "<your-branch-name>"},
  "checkout": {"branch": "<your-branch-name>"},
  "parameters": {"run-storybook-tests": "true"}
  }  Boolean negation.   Note that not has very high precedence and so binds very tightly. Use sub-expressions to apply not to more complex expressions. For example, with foo being true and bar being false:     not foo and bar evaluates to false   not (foo and bar) evaluates to true    workflows:
  dev_stage_pre-prod:
    jobs:
      - test_dev:
          filters:  # using regex filters requires the entire branch to match
            branches:
              only:  # only branches matching the below regex filters will run
                - dev
                - /user-.*/
      - test_stage:
          filters:
            branches:
              only: stage
      - test_pre-prod:
          filters:
            branches:
              only: /pre-prod(?:-.+)?$/  workflows:
  untagged-build:
    jobs:
      - build
  tagged-build:
    jobs:
      - build:
          filters:
            tags:
              only: /^v.*/  The matrix key is supported in version: 2.1 configuration  workflows:
  workflow:
    jobs:
      - build:
          matrix:
            parameters:
              version: ["0.1", "0.2", "0.3"]
              platform: ["macos", "windows", "linux"]  workflows:
  workflow:
    jobs:
      - build:
          name: build-macos-0.1
          version: "0.1"
          platform: macos
      - build:
          name: build-macos-0.2
          version: "0.2"
          platform: macos
      - build:
          name: build-macos-0.3
          version: "0.3"
          platform: macos
      - build:
          name: build-windows-0.1
          version: "0.1"
          platform: windows
      - ...  workflows:
  workflow:
    jobs:
      - build:
          matrix:
            parameters:
              a: [1, 2, 3]
              b: [4, 5, 6]
            exclude:
              - a: 3
                b: 5  workflows:
  workflow:
    jobs:
      - deploy:
          matrix:
            parameters:
              version: ["0.1", "0.2"]
      - another-job:
          requires:
            - deploy  workflows:
  workflow:
    jobs:
      - build:
          name: build-v<< matrix.version >>
          matrix:
            parameters:
              version: ["0.1", "0.2"]
      - deploy:
          name: deploy-v<< matrix.version >>
          matrix:
            parameters:
              version: ["0.1", "0.2"]
          requires:
            - build-v<< matrix.version >>  workflows:
  workflow:
    jobs:
      - build:
          name: build-v0.1
          version: "0.1"
      - build:
          name: build-v0.2
          version: "0.2"
      - deploy:
          name: deploy-v0.1
          version: "0.1"
          requires:
            - build-v0.1
      - deploy:
          name: deploy-v0.2
          version: "0.2"
          requires:
            - build-v0.2  Pre-steps and post-steps are supported in version: 2.1 configuration  version: 2.1

jobs:
  bar:
    machine:
      image: ubuntu-2004:2024.05.1
    steps:
      - checkout
      - run:
          command: echo "building"
      - run:
          command: echo "testing"

workflows:
  build:
    jobs:
      - bar:
          pre-steps: # steps to run before steps defined in the job bar
            - run:
                command: echo "install custom dependency"
          post-steps: # steps to run after steps defined in the job bar
            - run:
                command: echo "upload artifact to s3"  When using logic statements at the workflow level, do not include the condition: key (the condition key is only needed for job level logic statements).  workflows:
  my-workflow:
    when:
      or:
        - equal: [ main, << pipeline.git.branch >> ]
        - equal: [ staging, << pipeline.git.branch >> ]  Using Docker? Authenticating Docker pulls from image registries is recommended when using the Docker execution environment. Authenticated pulls allow access to private Docker images, and may also grant higher rate limits, depending on your registry provider. For further information see  Using Docker authenticated pulls.  version: 2.1
jobs:
  build:
    docker:
      - image: ubuntu:23.04

      - image: mongo:6.0.14
        command: [mongod, --smallfiles]

      - image: postgres:14.12
        # some containers require setting environment variables
        environment:
          POSTGRES_USER: user

      - image: redis@sha256:54057dd7e125ca41afe526a877e8bd35ec2cdd33b9217e022ed37bdcf7d09673

      - image: rabbitmq:3.12.12

    environment:
      TEST_REPORTS: /tmp/test-reports

    working_directory: ~/my-project

    steps:
      - checkout

      - run:
          command: echo 127.0.0.1 devhost | sudo tee -a /etc/hosts

      # Create Postgres users and database
      # Note the YAML heredoc '|' for nicer formatting
      - run: |
          sudo -u root createuser -h localhost --superuser ubuntu &&
          sudo createdb -h localhost test_db

      - restore_cache:
          keys:
            - v1-my-project-{{ checksum "project.clj" }}
            - v1-my-project-

      - run:
          environment:
            SSH_TARGET: "localhost"
            TEST_ENV: "linux"
          command: |
            set -xu
            mkdir -p ${TEST_REPORTS}
            run-tests.sh
            cp out/tests/*.xml ${TEST_REPORTS}

      - run: |
          set -xu
          mkdir -p /tmp/artifacts
          create_jars.sh << pipeline.number >>
          cp *.jar /tmp/artifacts

      - save_cache:
          key: v1-my-project-{{ checksum "project.clj" }}
          paths:
            - ~/.m2

      # Save artifacts
      - store_artifacts:
          path: /tmp/artifacts
          destination: build

      # Upload test results
      - store_test_results:
          path: /tmp/test-reports

  deploy-stage:
    docker:
      - image: ubuntu:23.04
    working_directory: /tmp/my-project
    steps:
      - run:
          name: Deploy if tests pass and branch is Staging
          command: ansible-playbook site.yml -i staging

  deploy-prod:
    docker:
      - image: ubuntu:23.04
    working_directory: /tmp/my-project
    steps:
      - run:
          name: Deploy if tests pass and branch is Main
          command: ansible-playbook site.yml -i production

workflows:
  build-deploy:
    jobs:
      - build:
          filters:
            branches:
              ignore:
                - develop
                - /feature-.*/
      - deploy-stage:
          requires:
            - build
          filters:
            branches:
              only: staging
      - deploy-prod:
          requires:
            - build
          filters:
            branches:
              only: main\n\n\n\nCircleCI config SDK1+ year ago1 min readCloudOn This PageOverviewInstall the SDKContribute Overview   The  CircleCI Config SDK is a JavaScript package library (also compatible with TypeScript) for generating a CircleCI YAML configuration file. Use the SDK to:     Replace writing YAML configuration files   Generate a static YAML configuration file   Modularize and manage your configuration as JavaScript packages   Enhance CircleCI’s  dynamic configuration   Build integrations with CLI tools or browser-based experiences     For example, generating a static configuration file can be useful for CLI tools where you want to create a CircleCI configuration, or browser-based tooling, such as a  visual config editor.   Components created with the CircleCI Config SDK can be packaged and distributed as Node packages.     Install the SDK   Install the CircleCI Config SDK with npm or Yarn, and include it in your project via Node.js or the browser.   npm installation:    $ npm i @circleci/circleci-config-sdk    Yarn installation:    yarn add @circleci/circleci-config-sdk    Use in Node.js    import CircleCI from '@circleci/circleci-config-sdk';    Use in the browser:    const CircleCI = require('@circleci/circleci-config-sdk');    Visit the SDK page to view a  full example of generating a CircleCI configuration.     Contribute   The CircleCI Config SDK is open source, and contributions are welcome. Visit the  contributing guide to view the guidelines and release process.   Suggest an edit to this pageMake a contribution Learn how to contributeStill need help? Ask the CircleCI community Join the research community Visit our Support site\n\nCircleCI config SDK1+ year ago1 min readCloudOn This PageOverviewInstall the SDKContribute Overview   The  CircleCI Config SDK is a JavaScript package library (also compatible with TypeScript) for generating a CircleCI YAML configuration file. Use the SDK to:     Replace writing YAML configuration files   Generate a static YAML configuration file   Modularize and manage your configuration as JavaScript packages   Enhance CircleCI’s  dynamic configuration   Build integrations with CLI tools or browser-based experiences     For example, generating a static configuration file can be useful for CLI tools where you want to create a CircleCI configuration, or browser-based tooling, such as a  visual config editor.   Components created with the CircleCI Config SDK can be packaged and distributed as Node packages.     Install the SDK   Install the CircleCI Config SDK with npm or Yarn, and include it in your project via Node.js or the browser.   npm installation:    $ npm i @circleci/circleci-config-sdk    Yarn installation:    yarn add @circleci/circleci-config-sdk    Use in Node.js    import CircleCI from '@circleci/circleci-config-sdk';    Use in the browser:    const CircleCI = require('@circleci/circleci-config-sdk');    Visit the SDK page to view a  full example of generating a CircleCI configuration.     Contribute   The CircleCI Config SDK is open source, and contributions are welcome. Visit the  contributing guide to view the guidelines and release process.   Suggest an edit to this pageMake a contribution Learn how to contributeStill need help? Ask the CircleCI community Join the research community Visit our Support site DocsTerms of UsePrivacy PolicyCookie PolicySecurity© 2025 Circle Internet Services, Inc., All Rights Reserved.\n\n$ npm i @circleci/circleci-config-sdk  yarn add @circleci/circleci-config-sdk  import CircleCI from '@circleci/circleci-config-sdk';  const CircleCI = require('@circleci/circleci-config-sdk');\n\n\n\nWebhook integration2 weeks ago8 min readCloudServer v4+On This PageCustom webhooksQuickstartExample: Trigger one pipeline from another1. Set up a custom webhook for Project B2. Configure Project A to trigger Project BExample: Extract custom webhook payload dataOutbound webhooksQuickstartCommunication protocol for outbound webhooksOutbound webhook headersValidate outbound webhooksOutbound webhook event specificationsNext steps   A webhook allows you to connect a platform (for example, CircleCI, an API you create yourself, or a third party service) to a stream of future events.   Setting up an outbound webhook on CircleCI enables your third party service to receive information (referred to as events) from CircleCI, as they happen. This can help you avoid polling the API or manually checking the CircleCI web application for desired information.   Setting up an inbound webhook (as a custom webhook trigger) on CircleCI enables a third party service to trigger a CircleCI pipeline. Any service that can send a webhook or make a curl request can trigger a CircleCI pipeline.     Custom webhooks      Custom webhooks are available for projects integrated via the GitHub App. Custom webhooks are not available on CircleCI server.        Use custom webhooks to trigger a pipeline from anywhere that can emit a webhook or run a curl command.      Custom webhooks are inbound to CircleCI and are used to trigger pipelines from other services. If you are looking for a way to have a CircleCI pipeline trigger a service, use an  outbound webhook.        This section presents some use cases for CircleCI custom webhooks.   Quickstart  Follow these steps to set up and test a custom webhook trigger. Trigger from anywhere that can emit a webhook or run a curl command:     In the  CircleCI web app select Projects in the sidebar.   Find your project in the list, select the ellipsis (), select Project Settings, and select Pipelines in the sidebar.   If there is already a GitHub App pipeline set up and it uses the desired YAML configuration file, proceed to the Triggers step below (step 5). If not, select Set up pipeline. If there is a Connect button, select it and follow the steps to install the CircleCI GitHub App into your GitHub organization (this step is compatible with orgs that integrate with  CircleCI’s GitHub OAuth app).   Name the new pipeline and select the repository where the CircleCI YAML configuration file is stored. Enter the file path (including the .circleci directory). The file path can be different than .circleci/config.yml (for example, .circleci/webhook.yml). Save the pipeline.   Select Triggers in the sidebar.   Select Add Trigger.   Select Custom Webhook from the dropdown menu.   Select Next.        Complete the form fields and options:    Enter a descriptive name for the trigger. For example, if you are setting up a custom webhook to run pipelines on events from Datadog, enter "Datadog" here.   (Optional) Add a description.   In the field "Pipeline to run", at the bottom of the page, select the pipeline that you created in the step above.   Enter the branch to use to fetch your config file when a Custom Webhook is received.   Enter the branch to use to check out your code when using the  checkout step in config. If your config is stored in the same repository as your code, then your Config branch and your Checkout branch should be the same.      Select Save.   You will see a webhook endpoint URL and secret. You can use these to set up your webhook trigger from your external source. Copy the Webhook URL and use it in your trigger source appended with the secret.     The secret will not be shown again so be sure to copy the URL before clicking Done.              You can now test your custom webhook trigger with curl. To trigger your pipeline, copy and paste the following sample request and replace <your-URL> and <your-secret> with the URL and secret that you generated in the previous step:     When triggering via curl, you must use a POST request with content-type: application/json.         curl -X POST -H "content-type: application/json" '<your-URL>?secret=<your-secret>'       See our  community forum for more details or how to use this functionality with a  3rd party service like DockerHub.      Custom webhooks will not work with  security group restrictions. Additionally, the configuration file that is used for pipelines triggered by a custom webhook will only be visible in the CircleCI web app if the configuration file path is .circleci/config.yml.         Example: Trigger one pipeline from another  Use a custom webhook to configure one pipeline to trigger a second pipeline. For example, you might need to run a set of integration tests on a repository after you have made a change to a separate repository.   For this example, assume you have two projects in separate repositories:      You can also use this method to trigger one pipeline from another within the same project.          Project A   Project B     When a change is made to Project A, we want the full Project A configuration to be run, and then the Project B pipeline should be triggered. To achieve this, follow these steps:   1. Set up a custom webhook for Project B  Navigate to Project B in the CircleCI web app and set up a custom webhook by following these steps:     In the  CircleCI web app select Projects in the sidebar.   Find your project in the list, select the ellipsis (), select Project Settings, and select Pipelines in the sidebar.   If there is already a GitHub App pipeline set up and it uses the desired YAML configuration file, proceed to the Triggers step below (step 5). If not, select Set up pipeline. If there is a Connect button, select it and follow the steps to install the CircleCI GitHub App into your GitHub organization (this step is compatible with orgs that integrate with  CircleCI’s GitHub OAuth app).   Name the new pipeline and select the repository where the CircleCI YAML configuration file is stored. Enter the file path (including the .circleci directory). The file path can be different than .circleci/config.yml (for example, .circleci/webhook.yml). Save the pipeline.   Select Triggers in the sidebar.   Select Add Trigger.   Select Custom Webhook from the dropdown menu.   Select Next.        Complete the form fields and options:    Enter a descriptive name for the trigger. For example, if you are setting up a custom webhook to run pipelines on events from Datadog, enter "Datadog" here.   (Optional) Add a description.   In the field "Pipeline to run", at the bottom of the page, select the pipeline that you created in the step above.   Enter the branch to use to fetch your config file when a Custom Webhook is received.   Enter the branch to use to check out your code when using the  checkout step in config. If your config is stored in the same repository as your code, then your Config branch and your Checkout branch should be the same.      Select Save.   You will see a webhook endpoint URL and secret. You can use these to set up your webhook trigger from your external source. Copy the Webhook URL and use it in your trigger source appended with the secret.     The secret will not be shown again so be sure to copy the URL before clicking Done.                 2. Configure Project A to trigger Project B  Navigate to Project A in the CircleCI web app and set up an environment variable. The value of the environment variable will be the secret from the custom webhook you just set up for Project B.      As an alternative, you can add an environment variable using a  context.          In the  CircleCI web app select your organization.   Select Projects in the sidebar.   Find your project in the list, select the ellipsis (), and select Project Settings.   Select Environment Variables from the sidebar.   Select Add Environment Variable.   Give your environment variable a name, for example, WEBHOOK_SECRET.   Update your Project A configuration file with a step that will trigger a pipeline for Project B, for example (lines 13-16):   version: 2.1

jobs:
  say-hello:
    docker:
      - image: cimg/base:stable
    steps:
      - checkout
      - run:
          name: example
          command: echo "one step"

      - run:
          name: Kick off new pipeline
          command: |
              curl -X POST -H "content-type: application/json" "https://internal.circleci.com/private/soc/e/6ccfca1c-5ed6-4dcf-96ca-374969d6edcb?secret=${WEBHOOK_SECRET}"

workflows:
  say-hello-workflow:
    jobs:
      - say-hello         Example: Extract custom webhook payload data  The custom webhook body is available by using the pipeline.trigger_parameters.webhook.body  pipeline value.   The following example shows how you can use jq to extract values from the webhook payload into environment variables when you want to use them in your configuration.   In this example the webhook body contains a property called branch. jq is installed and used to extract the branch value into an environment variable named WEBHOOK_BRANCH, which is then used in a GitHub clone command.      The  command configured in this example uses commands from the  jq and  GitHub CLI orbs.         commands:
  shallow_clone:
    description: Shallow Git Clone
    steps:
      - gh/setup:
          token: "GITHUB_TOKEN"
      - jq/install
      - run:
          name: Shallow Clone
          command: |
            WEBHOOK_BRANCH=$(echo '<< pipeline.trigger_parameters.webhook.body >>' | jq '.branch')
            gh repo clone << pipeline.trigger_parameters.github_app.repo_url >> . -- --depth 10 --branch "$WEBHOOK_BRANCH"       Outbound webhooks   Use outbound webhooks to integrate your CircleCI builds with external services.   For example, you could use  Outbound webhooks to:     Build a custom dashboard to visualize or analyze workflow/job events.   Send data to incident management tools (such as  PagerDuty).   Use tools like  Airtable to capture data and visualize it.   Alert when a workflow is cancelled, then use the API to rerun the workflow.   Trigger notification systems to alert people when workflows/jobs complete.   Build your own automation plugins and tools.     The following sections detail CircleCI outbound webhook structure and protocols.   Quickstart     Projects are limited to 5 outbound webhooks.        Webhooks are set up on a per-project basis, either within the CircleCI app or via API.   To configure webhooks via API see our documentation for  Webhooks Public API.   To configure webhooks within the CircleCI app:     In the  CircleCI web app select your organization.   Select Projects in the sidebar.   Find your project in the list, select the ellipsis (), and select Project Settings.   In the sidebar select Webhooks   Select Add Webhook   Fill out the webhook form (the table below describes the fields and their intent)   If your receiving API or third party service is set up, select Test Ping Event to send a test event.     The test ping event has an abbreviated payload for ease of testing. See full examples for  sample webhook payloads section of the webhooks reference.          FieldRequired?IntentWebhook nameYThe name of your webhookURLYThe URL the webhook will make POST requests toCertificate ValidationYEnsure the receiving host has a valid SSL certificate before sending an event. You should only leave this unchecked for testing purposes.Secret tokenNUsed by your API/platform to validate incoming data is from CircleCISelect an eventYYou must select at least one event that will trigger a webhook   Communication protocol for outbound webhooks  Once set up, a webhook is sent whenever an event occurs on the CircleCI platform.   A webhook is sent using an HTTP POST to the URL that was registered when the webhook was created, with a body encoded using JSON.   CircleCI expects the server that responds to a webhook will return a 2xx response code. If a non-2xx response is received, CircleCI will retry at a later time. If CircleCI does not receive a response to the webhook within a short period of time, CircleCI will assume that delivery has failed, and will retry at a later time. The timeout period is currently 10 seconds.   Webhook requests may be duplicated. To deduplicate (prevent requests from being duplicated for a specific event), use the  id property in the webhook payload for identification.   If you have feedback about timeouts and retries,  get in touch with our team.   Outbound webhook headers  A number of HTTP headers are set on webhooks, as detailed in the table below.  Header nameValuecontent-typeapplication/jsonuser-agentA string indicating that the sender was CircleCI (CircleCI-Webhook/1.0).circleci-event-typeThe type of event, (workflow-completed, job-completed, etc)circleci-signatureWhen present, this signature can be used to verify that the sender of the webhook has access to the secret token.    Validate outbound webhooks  You should validate webhooks as they come in to third party services to verify that they are coming from CircleCI. To support this, when creating a webhook, you can optionally provide a secret token. Each outgoing HTTP request to your service will contain a circleci-signature header. This header will consist of a comma-separated list of versioned signatures.    POST /uri HTTP/1.1
Host: your-webhook-host
circleci-signature: v1=4fcc06915b43d8a49aff193441e9e18654e6a27c2c428b02e8fcc41ccc2299f9,v2=...,v3=...    Currently, the latest (and only) signature version is v1. You should only check the latest signature type to prevent downgrade attacks.   The v1 signature is the HMAC-SHA256 digest of the request body, using the configured signing secret as the secret key.   Here are some example signatures for given request bodies:  BodySecret KeySignaturehello worldsecret734cc62f32841568f45715aeb9f4d7891324e6d948e4c6c60c0621cdac48623alalalaanother-secretdaa220016c8f29a8b214fbfc3671aeec2145cfb1e6790184ffb38b6d0425fa00an-important-request-payloadhunter1239be2242094a9a8c00c64306f382a7f9d691de910b4a266f67bd314ef18ac49fa  The following is an example of how you might validate signatures in Python:    import hmac

def verify_signature(secret, headers, body):
    # get the v1 signature from the `circleci-signature` header
    signature_from_header = {
        k: v for k, v in [
            pair.split('=') for pair in headers['circleci-signature'].split(',')
        ]
    }['v1']

    # Run HMAC-SHA256 on the request body using the configured signing secret
    valid_signature = hmac.new(bytes(secret, 'utf-8'), bytes(body, 'utf-8'), 'sha256').hexdigest()

    # use constant time string comparison to prevent timing attacks
    return hmac.compare_digest(valid_signature, signature_from_header)

# the following will return `True`
verify_signature(
    'secret',
    {
        'circleci-signature': 'v1=773ba44693c7553d6ee20f61ea5d2757a9a4f4a44d2841ae4e95b52e4cd62db4'
    },
    'foo',
)

# the following will return `False`
verify_signature(
    'secret',
    {
        'circleci-signature': 'v1=not-a-valid-signature'
    },
    'foo',
)     Outbound webhook event specifications  CircleCI currently offers outbound webhooks for the following events:  Event typeDescriptionPotential statusesIncluded sub-entitiesworkflow-completedA workflow has reached a terminal state"success", "failed", "error", "canceled", "unauthorized"project, organization, workflow, pipelinejob-completedA job has reached a terminal state"success", "failed", "canceled", "unauthorized"project, organization, workflow, pipeline, job     Next steps     See the  Webhooks reference page for key definitions and sample payloads.   Follow the  Using webhooks with third party tools tutorial.     Suggest an edit to this pageMake a contribution Learn how to contributeStill need help? Ask the CircleCI community Join the research community Visit our Support site\n\nWebhook integration2 weeks ago8 min readCloudServer v4+On This PageCustom webhooksQuickstartExample: Trigger one pipeline from another1. Set up a custom webhook for Project B2. Configure Project A to trigger Project BExample: Extract custom webhook payload dataOutbound webhooksQuickstartCommunication protocol for outbound webhooksOutbound webhook headersValidate outbound webhooksOutbound webhook event specificationsNext steps   A webhook allows you to connect a platform (for example, CircleCI, an API you create yourself, or a third party service) to a stream of future events.   Setting up an outbound webhook on CircleCI enables your third party service to receive information (referred to as events) from CircleCI, as they happen. This can help you avoid polling the API or manually checking the CircleCI web application for desired information.   Setting up an inbound webhook (as a custom webhook trigger) on CircleCI enables a third party service to trigger a CircleCI pipeline. Any service that can send a webhook or make a curl request can trigger a CircleCI pipeline.     Custom webhooks      Custom webhooks are available for projects integrated via the GitHub App. Custom webhooks are not available on CircleCI server.        Use custom webhooks to trigger a pipeline from anywhere that can emit a webhook or run a curl command.      Custom webhooks are inbound to CircleCI and are used to trigger pipelines from other services. If you are looking for a way to have a CircleCI pipeline trigger a service, use an  outbound webhook.        This section presents some use cases for CircleCI custom webhooks.   Quickstart  Follow these steps to set up and test a custom webhook trigger. Trigger from anywhere that can emit a webhook or run a curl command:     In the  CircleCI web app select Projects in the sidebar.   Find your project in the list, select the ellipsis (), select Project Settings, and select Pipelines in the sidebar.   If there is already a GitHub App pipeline set up and it uses the desired YAML configuration file, proceed to the Triggers step below (step 5). If not, select Set up pipeline. If there is a Connect button, select it and follow the steps to install the CircleCI GitHub App into your GitHub organization (this step is compatible with orgs that integrate with  CircleCI’s GitHub OAuth app).   Name the new pipeline and select the repository where the CircleCI YAML configuration file is stored. Enter the file path (including the .circleci directory). The file path can be different than .circleci/config.yml (for example, .circleci/webhook.yml). Save the pipeline.   Select Triggers in the sidebar.   Select Add Trigger.   Select Custom Webhook from the dropdown menu.   Select Next.        Complete the form fields and options:    Enter a descriptive name for the trigger. For example, if you are setting up a custom webhook to run pipelines on events from Datadog, enter "Datadog" here.   (Optional) Add a description.   In the field "Pipeline to run", at the bottom of the page, select the pipeline that you created in the step above.   Enter the branch to use to fetch your config file when a Custom Webhook is received.   Enter the branch to use to check out your code when using the  checkout step in config. If your config is stored in the same repository as your code, then your Config branch and your Checkout branch should be the same.      Select Save.   You will see a webhook endpoint URL and secret. You can use these to set up your webhook trigger from your external source. Copy the Webhook URL and use it in your trigger source appended with the secret.     The secret will not be shown again so be sure to copy the URL before clicking Done.              You can now test your custom webhook trigger with curl. To trigger your pipeline, copy and paste the following sample request and replace <your-URL> and <your-secret> with the URL and secret that you generated in the previous step:     When triggering via curl, you must use a POST request with content-type: application/json.         curl -X POST -H "content-type: application/json" '<your-URL>?secret=<your-secret>'       See our  community forum for more details or how to use this functionality with a  3rd party service like DockerHub.      Custom webhooks will not work with  security group restrictions. Additionally, the configuration file that is used for pipelines triggered by a custom webhook will only be visible in the CircleCI web app if the configuration file path is .circleci/config.yml.         Example: Trigger one pipeline from another  Use a custom webhook to configure one pipeline to trigger a second pipeline. For example, you might need to run a set of integration tests on a repository after you have made a change to a separate repository.   For this example, assume you have two projects in separate repositories:      You can also use this method to trigger one pipeline from another within the same project.          Project A   Project B     When a change is made to Project A, we want the full Project A configuration to be run, and then the Project B pipeline should be triggered. To achieve this, follow these steps:   1. Set up a custom webhook for Project B  Navigate to Project B in the CircleCI web app and set up a custom webhook by following these steps:     In the  CircleCI web app select Projects in the sidebar.   Find your project in the list, select the ellipsis (), select Project Settings, and select Pipelines in the sidebar.   If there is already a GitHub App pipeline set up and it uses the desired YAML configuration file, proceed to the Triggers step below (step 5). If not, select Set up pipeline. If there is a Connect button, select it and follow the steps to install the CircleCI GitHub App into your GitHub organization (this step is compatible with orgs that integrate with  CircleCI’s GitHub OAuth app).   Name the new pipeline and select the repository where the CircleCI YAML configuration file is stored. Enter the file path (including the .circleci directory). The file path can be different than .circleci/config.yml (for example, .circleci/webhook.yml). Save the pipeline.   Select Triggers in the sidebar.   Select Add Trigger.   Select Custom Webhook from the dropdown menu.   Select Next.        Complete the form fields and options:    Enter a descriptive name for the trigger. For example, if you are setting up a custom webhook to run pipelines on events from Datadog, enter "Datadog" here.   (Optional) Add a description.   In the field "Pipeline to run", at the bottom of the page, select the pipeline that you created in the step above.   Enter the branch to use to fetch your config file when a Custom Webhook is received.   Enter the branch to use to check out your code when using the  checkout step in config. If your config is stored in the same repository as your code, then your Config branch and your Checkout branch should be the same.      Select Save.   You will see a webhook endpoint URL and secret. You can use these to set up your webhook trigger from your external source. Copy the Webhook URL and use it in your trigger source appended with the secret.     The secret will not be shown again so be sure to copy the URL before clicking Done.                 2. Configure Project A to trigger Project B  Navigate to Project A in the CircleCI web app and set up an environment variable. The value of the environment variable will be the secret from the custom webhook you just set up for Project B.      As an alternative, you can add an environment variable using a  context.          In the  CircleCI web app select your organization.   Select Projects in the sidebar.   Find your project in the list, select the ellipsis (), and select Project Settings.   Select Environment Variables from the sidebar.   Select Add Environment Variable.   Give your environment variable a name, for example, WEBHOOK_SECRET.   Update your Project A configuration file with a step that will trigger a pipeline for Project B, for example (lines 13-16):   version: 2.1

jobs:
  say-hello:
    docker:
      - image: cimg/base:stable
    steps:
      - checkout
      - run:
          name: example
          command: echo "one step"

      - run:
          name: Kick off new pipeline
          command: |
              curl -X POST -H "content-type: application/json" "https://internal.circleci.com/private/soc/e/6ccfca1c-5ed6-4dcf-96ca-374969d6edcb?secret=${WEBHOOK_SECRET}"

workflows:
  say-hello-workflow:
    jobs:
      - say-hello         Example: Extract custom webhook payload data  The custom webhook body is available by using the pipeline.trigger_parameters.webhook.body  pipeline value.   The following example shows how you can use jq to extract values from the webhook payload into environment variables when you want to use them in your configuration.   In this example the webhook body contains a property called branch. jq is installed and used to extract the branch value into an environment variable named WEBHOOK_BRANCH, which is then used in a GitHub clone command.      The  command configured in this example uses commands from the  jq and  GitHub CLI orbs.         commands:
  shallow_clone:
    description: Shallow Git Clone
    steps:
      - gh/setup:
          token: "GITHUB_TOKEN"
      - jq/install
      - run:
          name: Shallow Clone
          command: |
            WEBHOOK_BRANCH=$(echo '<< pipeline.trigger_parameters.webhook.body >>' | jq '.branch')
            gh repo clone << pipeline.trigger_parameters.github_app.repo_url >> . -- --depth 10 --branch "$WEBHOOK_BRANCH"       Outbound webhooks   Use outbound webhooks to integrate your CircleCI builds with external services.   For example, you could use  Outbound webhooks to:     Build a custom dashboard to visualize or analyze workflow/job events.   Send data to incident management tools (such as  PagerDuty).   Use tools like  Airtable to capture data and visualize it.   Alert when a workflow is cancelled, then use the API to rerun the workflow.   Trigger notification systems to alert people when workflows/jobs complete.   Build your own automation plugins and tools.     The following sections detail CircleCI outbound webhook structure and protocols.   Quickstart     Projects are limited to 5 outbound webhooks.        Webhooks are set up on a per-project basis, either within the CircleCI app or via API.   To configure webhooks via API see our documentation for  Webhooks Public API.   To configure webhooks within the CircleCI app:     In the  CircleCI web app select your organization.   Select Projects in the sidebar.   Find your project in the list, select the ellipsis (), and select Project Settings.   In the sidebar select Webhooks   Select Add Webhook   Fill out the webhook form (the table below describes the fields and their intent)   If your receiving API or third party service is set up, select Test Ping Event to send a test event.     The test ping event has an abbreviated payload for ease of testing. See full examples for  sample webhook payloads section of the webhooks reference.          FieldRequired?IntentWebhook nameYThe name of your webhookURLYThe URL the webhook will make POST requests toCertificate ValidationYEnsure the receiving host has a valid SSL certificate before sending an event. You should only leave this unchecked for testing purposes.Secret tokenNUsed by your API/platform to validate incoming data is from CircleCISelect an eventYYou must select at least one event that will trigger a webhook   Communication protocol for outbound webhooks  Once set up, a webhook is sent whenever an event occurs on the CircleCI platform.   A webhook is sent using an HTTP POST to the URL that was registered when the webhook was created, with a body encoded using JSON.   CircleCI expects the server that responds to a webhook will return a 2xx response code. If a non-2xx response is received, CircleCI will retry at a later time. If CircleCI does not receive a response to the webhook within a short period of time, CircleCI will assume that delivery has failed, and will retry at a later time. The timeout period is currently 10 seconds.   Webhook requests may be duplicated. To deduplicate (prevent requests from being duplicated for a specific event), use the  id property in the webhook payload for identification.   If you have feedback about timeouts and retries,  get in touch with our team.   Outbound webhook headers  A number of HTTP headers are set on webhooks, as detailed in the table below.  Header nameValuecontent-typeapplication/jsonuser-agentA string indicating that the sender was CircleCI (CircleCI-Webhook/1.0).circleci-event-typeThe type of event, (workflow-completed, job-completed, etc)circleci-signatureWhen present, this signature can be used to verify that the sender of the webhook has access to the secret token.    Validate outbound webhooks  You should validate webhooks as they come in to third party services to verify that they are coming from CircleCI. To support this, when creating a webhook, you can optionally provide a secret token. Each outgoing HTTP request to your service will contain a circleci-signature header. This header will consist of a comma-separated list of versioned signatures.    POST /uri HTTP/1.1
Host: your-webhook-host
circleci-signature: v1=4fcc06915b43d8a49aff193441e9e18654e6a27c2c428b02e8fcc41ccc2299f9,v2=...,v3=...    Currently, the latest (and only) signature version is v1. You should only check the latest signature type to prevent downgrade attacks.   The v1 signature is the HMAC-SHA256 digest of the request body, using the configured signing secret as the secret key.   Here are some example signatures for given request bodies:  BodySecret KeySignaturehello worldsecret734cc62f32841568f45715aeb9f4d7891324e6d948e4c6c60c0621cdac48623alalalaanother-secretdaa220016c8f29a8b214fbfc3671aeec2145cfb1e6790184ffb38b6d0425fa00an-important-request-payloadhunter1239be2242094a9a8c00c64306f382a7f9d691de910b4a266f67bd314ef18ac49fa  The following is an example of how you might validate signatures in Python:    import hmac

def verify_signature(secret, headers, body):
    # get the v1 signature from the `circleci-signature` header
    signature_from_header = {
        k: v for k, v in [
            pair.split('=') for pair in headers['circleci-signature'].split(',')
        ]
    }['v1']

    # Run HMAC-SHA256 on the request body using the configured signing secret
    valid_signature = hmac.new(bytes(secret, 'utf-8'), bytes(body, 'utf-8'), 'sha256').hexdigest()

    # use constant time string comparison to prevent timing attacks
    return hmac.compare_digest(valid_signature, signature_from_header)

# the following will return `True`
verify_signature(
    'secret',
    {
        'circleci-signature': 'v1=773ba44693c7553d6ee20f61ea5d2757a9a4f4a44d2841ae4e95b52e4cd62db4'
    },
    'foo',
)

# the following will return `False`
verify_signature(
    'secret',
    {
        'circleci-signature': 'v1=not-a-valid-signature'
    },
    'foo',
)     Outbound webhook event specifications  CircleCI currently offers outbound webhooks for the following events:  Event typeDescriptionPotential statusesIncluded sub-entitiesworkflow-completedA workflow has reached a terminal state"success", "failed", "error", "canceled", "unauthorized"project, organization, workflow, pipelinejob-completedA job has reached a terminal state"success", "failed", "canceled", "unauthorized"project, organization, workflow, pipeline, job     Next steps     See the  Webhooks reference page for key definitions and sample payloads.   Follow the  Using webhooks with third party tools tutorial.     Suggest an edit to this pageMake a contribution Learn how to contributeStill need help? Ask the CircleCI community Join the research community Visit our Support site DocsTerms of UsePrivacy PolicyCookie PolicySecurity© 2025 Circle Internet Services, Inc., All Rights Reserved.\n\nCustom webhooks are available for projects integrated via the GitHub App. Custom webhooks are not available on CircleCI server.  Custom webhooks are inbound to CircleCI and are used to trigger pipelines from other services. If you are looking for a way to have a CircleCI pipeline trigger a service, use an  outbound webhook.    The secret will not be shown again so be sure to copy the URL before clicking Done.    When triggering via curl, you must use a POST request with content-type: application/json.  curl -X POST -H "content-type: application/json" '<your-URL>?secret=<your-secret>'  Custom webhooks will not work with  security group restrictions. Additionally, the configuration file that is used for pipelines triggered by a custom webhook will only be visible in the CircleCI web app if the configuration file path is .circleci/config.yml.  You can also use this method to trigger one pipeline from another within the same project.    The secret will not be shown again so be sure to copy the URL before clicking Done.    As an alternative, you can add an environment variable using a  context.  version: 2.1

jobs:
  say-hello:
    docker:
      - image: cimg/base:stable
    steps:
      - checkout
      - run:
          name: example
          command: echo "one step"

      - run:
          name: Kick off new pipeline
          command: |
              curl -X POST -H "content-type: application/json" "https://internal.circleci.com/private/soc/e/6ccfca1c-5ed6-4dcf-96ca-374969d6edcb?secret=${WEBHOOK_SECRET}"

workflows:
  say-hello-workflow:
    jobs:
      - say-hello  The  command configured in this example uses commands from the  jq and  GitHub CLI orbs.  commands:
  shallow_clone:
    description: Shallow Git Clone
    steps:
      - gh/setup:
          token: "GITHUB_TOKEN"
      - jq/install
      - run:
          name: Shallow Clone
          command: |
            WEBHOOK_BRANCH=$(echo '<< pipeline.trigger_parameters.webhook.body >>' | jq '.branch')
            gh repo clone << pipeline.trigger_parameters.github_app.repo_url >> . -- --depth 10 --branch "$WEBHOOK_BRANCH"  Projects are limited to 5 outbound webhooks.  The test ping event has an abbreviated payload for ease of testing. See full examples for  sample webhook payloads section of the webhooks reference.  POST /uri HTTP/1.1
Host: your-webhook-host
circleci-signature: v1=4fcc06915b43d8a49aff193441e9e18654e6a27c2c428b02e8fcc41ccc2299f9,v2=...,v3=...  import hmac

def verify_signature(secret, headers, body):
    # get the v1 signature from the `circleci-signature` header
    signature_from_header = {
        k: v for k, v in [
            pair.split('=') for pair in headers['circleci-signature'].split(',')
        ]
    }['v1']

    # Run HMAC-SHA256 on the request body using the configured signing secret
    valid_signature = hmac.new(bytes(secret, 'utf-8'), bytes(body, 'utf-8'), 'sha256').hexdigest()

    # use constant time string comparison to prevent timing attacks
    return hmac.compare_digest(valid_signature, signature_from_header)

# the following will return `True`
verify_signature(
    'secret',
    {
        'circleci-signature': 'v1=773ba44693c7553d6ee20f61ea5d2757a9a4f4a44d2841ae4e95b52e4cd62db4'
    },
    'foo',
)

# the following will return `False`
verify_signature(
    'secret',
    {
        'circleci-signature': 'v1=not-a-valid-signature'
    },
    'foo',
)\n\n\n\npostpostpostpostpostpostpostpostpostpostpostpostpostpostpostpostpostpostpostpostpostpostpostpostpostpostpostpostpostpostpostpostpostpostpostpostpostpostpostpost\n\n\n\nDocumentation
            
          
          
            circleci.com
            
          
        
        CircleCI V1 API Overview
The CircleCI API is a full-featured RESTful API that allows you to access all information and trigger all actions in CircleCI. RESTful APIs enable you to call individual API endpoints to perform the following actions:


GET - retrieve specific information, which may include arrays and sets of data and information.
POST - create/add a new API element.
PUT - update an existing API element in the API server.
DELETE - remove/delete an API element in the API server.



Although RESTful APIs include these 4 HTTP verbs, the CircleCI API does not currently use the PUT verb.



Access to billing functions is only available from the CircleCI application.

Authentication
The CircleCI API utilizes token-based authentication to manage access to the API server and validate that a user has permission to make API requests. Before you can make an API request, you must first add an API token and then verify that you are authenticated by the API server to make requests. The process to add an API token and have the API server authenticate you is described in the sections below.

Note You may use the API token as the username for HTTP Basic Authentication, by passing the -u flag to the curl command.
Add an API Token$ curl -H "Circle-Token: <circle-token>" https://circleci.com/api/v1.1/me
{
  "user_key_fingerprint" : null,
  "days_left_in_trial" : -238,
  "trial_end" : "2011-12-28T22:02:15Z",
  "basic_email_prefs" : "smart",
  "admin" : true,
  "login" : "pbiggar"
 }

To add an API token, perform the steps listed below.


 Add an API token from your account dashboard.
 To test it, View it in your browser or call the API using
 You should see a response similar to the example shown in the right pane.



All API calls are made in the same way, by making standard HTTP calls, using JSON, a content-type, and your API token.

Get Authenticatedcurl -H "Circle-Token: <circle-token>" "https://circleci.com/api/..."
curl -u <circle-token>: "https://circleci.com/api/..."
curl "https://circleci.com/api/v1.1/me?circle-token=<circle-token>"

You can add the API token using your account dashboard. We recommend using personal API tokens at this time because project API tokens are not supported for API v2. Project API tokens are supported for most API v1 endpoints. Notes are included below to indicate when a personal API token is required.

To be authenticated by the API server, use this as the value of the Circle-Token header:

Or you can use the API token as the username for HTTP Basic Authentication, by passing the -u flag to the curl command:


the colon ":" tells curl that there's no password.


DEPRECATED (this option will be removed in the future): The API token can be added to the circle-token query param:
Summary of API Endpoints
All CircleCI API endpoints begin with https://circleci.com/api/v1.1/
GET Requests


API
Description



/me
Provides information about the signed in user.


/projects
Lists all projects you are following on CircleCI, with job information organized by branch.


/project/:vcs-type/:username/:project
Returns a summary for each of the last 30 job runs for a single project.


/recent-builds
Returns a summary for each of the last 30 recent job runs, ordered by build_num.


/project/:vcs-type/:username/:project/:build_num
Returns full details for a single job run. The response includes all of the fields from the job summary. This is also the payload for the notification webhooks, in which case this object is the value to a key named ‘payload’.


/project/:vcs-type/:username/:project/:build_num/artifacts
Lists the artifacts produced by a given job run.


/project/:vcs-type/:username/:project/checkout-key/:fingerprint
Retrieves a checkout key.


POST Requests


API
Description



/project/:vcs-type/:username/:project/follow
Follow a new project on CircleCI.


/project/:vcs-type/:org_name/:project/:build_num/retry
Retries the job, returns a summary of the new job run.


/project/:vcs-type/:username/:project/:build_num/cancel
Cancels the job, returns a summary of the job run.


/project/:vcs-type/:username/:project/:build_num/ssh-users
Adds a user to the job's SSH permissions.


/project/:vcs-type/:username/:project/tree/:branch
Triggers a new job, returns a summary of the job run. Optional build parameters can be set.


/project/:vcs-type/:username/:project/ssh-key
Creates an SSH key used to access external systems that require SSH key-based authentication.


/project/:vcs-type/:username/:project/checkout-key
Creates a new checkout key.


DELETE Requests


API
Description



/project/:vcs-type/:username/:project/checkout-key/:fingerprint
Deletes a checkout key.


/project/:vcs-type/:username/:project/ssh-key
Delete the SSH key from a project.


Getting StartedAPI Syntax
When making an API request, make sure you follow standard REST API syntax and formatting. Adhering to proper REST API syntax ensures that the API server can properly process your request and return a JSON response. To make a request to the CircleCI API, use the format shown in the pane to the right:
"https://circleci.com/api/v1.1"

Where:


https://circleci.com - the resource URL for the API being called.
api - the class being called.
v1.1 - the API version.

Version Control Systemscurl https://circleci.com/api/v1.1/project/:vcs-type/:username/:project/tree/:branch

New with v1.1 of the API, for endpoints under /project` you will now need to tell CircleCI what version control system type your project uses. You may currently select either ‘github’ or ‘bitbucket’. The command for recent builds for a project would be formatted like the example shown in the right pane.
Rate Limiting
The CircleCI API is protected by a number of rate limiting measures to ensure the stability of the system. We reserve the right to throttle the requests made by an individual user, or the requests made to individual resources in order to ensure a fair level of service to all of our users.

As the author of an API integration with CircleCI, your integration should expect to be throttled, and should be able to gracefully handle failure.
There are different protections and limits in place for different parts of the API. In particular, we protect our API against sudden large bursts of traffic, and we protect against sustained high volumes of requests, for example, frequent polling.

For HTTP APIs, when a request is throttled, you will receive HTTP status code 429. If your integration requires that a throttled request is completed, then you should retry these requests after a delay, using an exponential backoff.
In most cases, the HTTP 429 response code will be accompanied by the Retry-After HTTP header. When this header is present, your integration should wait for the period of time specified by the header value before retrying a request.
List Ordering
There are two API endpoints where the list order is significant:


Recent jobs across all projects
Recent jobs for a single project


In both cases, jobs are returned in the order that they were created. For all other endpoints, the order has no special significance.
Accept Headercurl https://circleci.com/api/v1.1/me -H "Accept: application/json" -H "Circle-Token: <circle-token>"

If no accept header is specified (or it is empty), CircleCI will return the data in a Clojure EDN format. To receive the data as nicely formatted JSON, include any value for the Accept header (e.g text/plain). If you prefer to receive compact JSON with no whitespace or comments, use application/json as the Accept header.
Cache-Control Header
Some CircleCI APIs may emit a Cache-Control header to indicate that the response may be cached for a period of time. This feature can be used to avoid unnecessary re-fetching of data that will not change. If you plan to make a large volume of API requests you are strongly encouraged to make use of this header in order to improve your performance and lower your risk of being rate limited.
F/OSS
If you have a Free / Open Source Software (F/OSS) project, and have the setting turned on in Advanced Settings in your project dashboard, some read-only /project endpoints will return the requested data without the need for a token. People will also be able to view the job results dashboard for the project as well.
Usercurl https://circleci.com/api/v1.1/me -H "Circle-Token: <circle-token>"
{
  "basic_email_prefs" : "smart", // can be "smart", "none" or "all"
  "login" : "pbiggar" // your github username
}

GET Request: Provides information about the user that is currently signed in. The use of this endpoint requires a personal API token.
Projects
If you would like to retrieve detailed information about projects, CircleCI provides several different endpoints that you may call to return this information, including the ability to return detailed information for all projects. To ensure you do not encounter any performance-related lags or issues when making an API request, you may wish to limit your search for a single project instead of an array of projects.

The sections below describe the endpoints you may call to return Project information.
Get All Followed Projectscurl https://circleci.com/api/v1.1/projects -H "Circle-Token: <circle-token>"
[ {
  "vcs_url": "https://github.com/circleci/mongofinil",
  "followed": true, // true if you follow this project in CircleCI
  "username": "circleci",
  "reponame": "mongofinil",
  "branches" : {
    "master" : {
      "pusher_logins" : [ "pbiggar", "arohner" ], // users who have pushed
      "last_non_success" : { // last failed job on this branch
        "pushed_at" : "2013-02-12T21:33:14Z",
        "vcs_revision" : "1d231626ba1d2838e599c5c598d28e2306ad4e48",
        "build_num" : 22,
        "outcome" : "failed",
        },
      "last_success" : { // last successful job on this branch
        "pushed_at" : "2012-08-09T03:59:53Z",
        "vcs_revision" : "384211bbe72b2a22997116a78788117b3922d570",
        "build_num" : 15,
        "outcome" : "success",
        },
      "recent_builds" : [ { // last 5 jobs, ordered by pushed_at (decreasing)
        "pushed_at" : "2013-02-12T21:33:14Z",
        "vcs_revision" : "1d231626ba1d2838e599c5c598d28e2306ad4e48",
        "build_num" : 22,
        "outcome" : "failed",
        }, {
        "pushed_at" : "2013-02-11T03:09:54Z",
        "vcs_revision" : "0553ba86b35a97e22ead78b0d568f6a7c79b838d",
        "build_num" : 21,
        "outcome" : "failed",
        }, ... ],
      "running_builds" : [ ] // currently running jobs
    }
  }
}, ... ]

GET request.

Returns an array of all projects you are currently following on CircleCI, with job information organized by branch.
Follow a New Project on CircleCIcurl -X POST https://circleci.com/api/v1.1/project/:vcs-type/:username/:project/follow -H "Circle-Token: <circle-token>"
{
  "followed" : true,
  "first_build" : {
    "compare" : null,
    "previous_successful_build" : null,
    "build_parameters" : null,
    "oss" : true,
    "committer_date" : null,
    "body" : null,
    "usage_queued_at" : "2016-09-07T13:48:10.825Z",
    "fail_reason" : null,
    "retry_of" : null,
    "reponame" : "testing-circleci",
    "ssh_users" : [ ],
    "build_url" : "https://circleci.com/gh/circleci/mongofinil/1",
    "parallel" : 1,
    "failed" : null,
    "branch" : "master",
    "username" : "circleci",
    "author_date" : null,
    "why" : "first-build",
    "user" : {
      "is_user" : true,
      "login" : "circleci",
      "avatar_url" : "https://avatars.githubusercontent.com/u/6017470?v=3",
      "name" : "CircleCI",
      "vcs_type" : "github",
      "id" : 10101010
    },
    "vcs_revision" : "b2b5def65bf54091dde02ebb39ef3c54de3ff049",
    "vcs_tag" : null,
    "build_num" : 1,
    "infrastructure_fail" : false,
    "committer_email" : null,
    "previous" : null,
    "status" : "not_running",
    "committer_name" : null,
    "retries" : null,
    "subject" : null,
    "vcs_type" : "github",
    "timedout" : false,
    "dont_build" : null,
    "lifecycle" : "not_running",
    "no_dependency_cache" : false,
    "stop_time" : null,
    "ssh_disabled" : false,
    "build_time_millis" : null,
    "circle_yml" : null,
    "messages" : [ ],
    "is_first_green_build" : false,
    "job_name" : null,
    "start_time" : null,
    "canceler" : null,
    "outcome" : null,
    "vcs_url" : "https://github.com/circleci/mongofinil",
    "author_name" : null,
    "node" : null,
    "canceled" : false,
    "author_email" : null
  }
}

Request Type: POST

Follows a new project. CircleCI will then monitor the project for automatic building of commits.
Recent Jobs Across All Projectscurl https://circleci.com/api/v1.1/recent-builds?limit=1&shallow=true
[ {
  "vcs_url" : "https://github.com/circleci/mongofinil",
  "build_url" : "https://circleci.com/gh/circleci/mongofinil/22",
  "build_num" : 22,
  "branch" : "master",
  "vcs_revision" : "1d231626ba1d2838e599c5c598d28e2306ad4e48",
  "committer_name" : "Allen Rohner",
  "committer_email" : "arohner@gmail.com",
  "subject" : "Don't explode when the system clock shifts backwards",
  "body" : "", // commit message body
  "why" : "github", // short string explaining the reason we built
  "dont_build" : null, // reason why we didn't build, if we didn't build
  "queued_at" : "2013-02-12T21:33:30Z" // time the job was queued
  "start_time" : "2013-02-12T21:33:38Z", // time the job started
  "stop_time" : "2013-02-12T21:34:01Z", // time the job finished
  "build_time_millis" : 23505,
  "username" : "circleci",
  "reponame" : "mongofinil",
  "lifecycle" : "finished", // :queued, :not_run, :not_running, :running or :finished
  "outcome" : "failed", // :canceled, :infrastructure_fail, :timedout, :failed, :no_tests or :success
  "status" : "failed", // :retried, :canceled, :infrastructure_fail, :timedout, :not_run, :running, :failed, :queued, :not_running, :no_tests, :fixed, :success
  "retry_of" : null, // build_num of the job that this is a retry of
  "previous" : { // previous job
    "status" : "failed",
    "build_num" : 21
  }, ... ]

Request Type: GET

Returns a job summary for each of the last 30 recent job runs, ordered by build_num.



Parameter
Description



limit
The number of job runs to return. Maximum 100, defaults to 30.


offset
The API returns job runs starting from this offset, defaults to 0.


shallow
An optional boolean parameter that may be sent to improve performance if set to 'true'.



Note: When making an API request for Project information, you may experience performance lag and a decrease in overall performance while the request is being processed by the server. To improve performance, CircleCI recommends you pass the shallow parameter in your request.
Recent Jobs For A Single Projectcurl https://circleci.com/api/v1.1/project/:vcs-type/:username/:project?limit=20&offset=5&filter=completed -H "Circle-Token: <circle-token>"
[{
    "committer_date": "2019-04-12T10:44:51-07:00",
    "body": "",
    "usage_queued_at": "2019-04-12T17:46:11.229Z",
    "reponame": "circleci.com",
    "build_url": "https://circleci.com/gh/circleci/circleci.com/16315",
    "parallel": 1,
    "branch": "ja-homepage",
    "username": "circleci",
    "author_date": "2019-04-12T10:44:51-07:00",
    "why": "github",
    "user": {
        "is_user": true,
        "login": "trevor-circleci",
        "avatar_url": "https://avatars1.githubusercontent.com/u/22457684?v=4",
        "name": null,
        "vcs_type": "github",
        "id": 22457684
    },
    "vcs_revision": "8139060f4d1f6ff617ac49f8afb2273c4fee2343",
    "workflows": {
        "job_name": "build-preview",
        "job_id": "981f2bfa-3c50-4505-865d-5266670217eb",
        "workflow_id": "a063aeae-5b89-458b-8aa1-cca4c565b07d",
        "workspace_id": "a063aeae-5b89-458b-8aa1-cca4c565b07d",
        "upstream_job_ids": ["7e92fbf5-8111-430b-8e2a-54b169ba745d"],
        "upstream_concurrency_map": {},
        "workflow_name": "build-website"
    },
    "vcs_tag": null,
    "pull_requests": [{
        "head_sha": "8139060f4d1f6ff617ac49f8afb2273c4fee2343",
        "url": "https://github.com/circleci/circleci.com/pull/2347"
    }],
    "build_num": 16315,
    "committer_email": "trevor@circleci.com",
    "status": "success",
    "committer_name": "Trevor Sorel",
    "subject": "adding japanese translations for main nav",
    "dont_build": null,
    "lifecycle": "finished",
    "fleet": "picard",
    "stop_time": "2019-04-12T17:47:42.298Z",
    "build_time_millis": 89366,
    "start_time": "2019-04-12T17:46:12.932Z",
    "platform": "2.0",
    "outcome": "success",
    "vcs_url": "https://github.com/circleci/circleci.com",
    "author_name": "Trevor Sorel",
    "queued_at": "2019-04-12T17:46:11.289Z",
    "author_email": "trevor@circleci.com"
}]

GET Request: Returns a job summary for each of the last 30 job runs for a single project, ordered by build_num.



Parameter
Description



limit
The number of jobs to return. Maximum 100, defaults to 30.


offset
The API returns jobs starting from this offset, defaults to 0.


filter
Restricts which jobs are returned. Set to "completed", "successful", "failed", "running", or defaults to no filter.


shallow
An optional boolean value that may be sent to improve overall performance if set to 'true.'



Note: You can narrow the jobs to a single branch by appending /tree/:branch to the url. Note that the branch name should be url-encoded.
Improving Performance In Recent Job Requests Using the Shallow Parameter
When making API requests for information about recent job runs, you may experience performance lag and a decrease in overall performance while the request is being processed by the server. To improve performance, CircleCI recommends you pass the shallow parameter in your request.
curl https://circleci.com/api/v1.1/recent-builds?limit=1&shallow=true
[ {
  "vcs_url" : "https://github.com/circleci/mongofinil",
  "build_url" : "https://circleci.com/gh/circleci/mongofinil/22",
  "build_num" : 22,
  "branch" : "master",
  "vcs_revision" : "1d231626ba1d2838e599c5c598d28e2306ad4e48",
  "committer_name" : "Allen Rohner",
  "committer_email" : "arohner@gmail.com",
  "subject" : "Don't explode when the system clock shifts backwards",
  "body" : "", // commit message body
  "why" : "github", // short string explaining the reason we built
  "dont_build" : null, // reason why we didn't build, if we didn't build
  "queued_at" : "2013-02-12T21:33:30Z" // time the job was queued
  "start_time" : "2013-02-12T21:33:38Z", // time the job started running
  "stop_time" : "2013-02-12T21:34:01Z", // time the job finished running
  "build_time_millis" : 23505,
  "username" : "circleci",
  "reponame" : "mongofinil",
  "lifecycle" : "finished", // :queued, :not_run, :not_running, :running or :finished
  "outcome" : "failed", // :canceled, :infrastructure_fail, :timedout, :failed, :no_tests or :success
  "status" : "failed", // :retried, :canceled, :infrastructure_fail, :timedout, :not_run, :running, :failed, :queued, :not_running, :no_tests, :fixed, :success
  "retry_of" : null, // build_num of the job that this is a retry of
  "previous" : { // previous job
    "status" : "failed",
    "build_num" : 21
  }, ... ]
Sample Request Using the Shallow Parameter
The example to the right shows a user request for recent job information. Notice that when the user passes the shallow parameter, a limited set of information is returned, thereby improving response time and minimizing performance lag.
JobsSingle Jobcurl https://circleci.com/api/v1.1/project/:vcs-type/:username/:project/:build_num -H "Circle-Token: <circle-token>"
{
  "vcs_url" : "https://github.com/circleci/mongofinil",
  "build_url" : "https://circleci.com/gh/circleci/mongofinil/22",
  "build_num" : 22,
  "branch" : "master",
  "vcs_revision" : "1d231626ba1d2838e599c5c598d28e2306ad4e48",
  "committer_name" : "Allen Rohner",
  "committer_email" : "arohner@gmail.com",
  "subject" : "Don't explode when the system clock shifts backwards",
  "body" : "", // commit message body
  "why" : "github", // short string explaining the reason the job ran
  "dont_build" : null, // reason why we didn't build, if we didn't build
  "queued_at" : "2013-02-12T21:33:30Z", // time the job was queued
  "start_time" : "2013-02-12T21:33:38Z", // time the job started
  "stop_time" : "2013-02-12T21:34:01Z", // time the job finished
  "build_time_millis" : 23505,
  "username" : "circleci",
  "reponame" : "mongofinil",
  "lifecycle" : "finished", // :queued, :not_run, :not_running, :running or :finished
  "outcome" : "success", // :canceled, :infrastructure_fail, :timedout, :failed, :no_tests or :success
  "status" : "success", // :retried, :canceled, :infrastructure_fail, :timedout, :not_run, :running, :failed, :queued, :not_running, :no_tests, :fixed, :success
  "retry_of" : null, // build_num of the job that this is a retry of
  "steps" : [ {
    "name" : "configure the build",
    "actions" : [ {
      "bash_command" : null,
      "run_time_millis" : 1646,
      "start_time" : "2013-02-12T21:33:38Z",
      "end_time" : "2013-02-12T21:33:39Z",
      "name" : "configure the build",
      "exit_code" : null,
      "type" : "infrastructure",
      "index" : 0,
      "status" : "success",
    } ] },

    "name" : "lein2 deps",
    "actions" : [ {
      "bash_command" : "lein2 deps",
      "run_time_millis" : 7555,
      "start_time" : "2013-02-12T21:33:47Z",
      "messages" : [ ],
      "step" : 1,
      "exit_code" : 0,
      "end_time" : "2013-02-12T21:33:54Z",
      "index" : 0,
      "status" : "success",
      "type" : "dependencies",
      "source" : "inference",
      "failed" : null
    } ] },
    "name" : "lein2 trampoline midje",
    "actions" : [ {
      "bash_command" : "lein2 trampoline midje",
      "run_time_millis" : 2310,
      "continue" : null,
      "parallel" : true,
      "start_time" : "2013-02-12T21:33:59Z",
      "name" : "lein2 trampoline midje",
      "messages" : [ ],
      "step" : 6,
      "exit_code" : 1,
      "end_time" : "2013-02-12T21:34:01Z",
      "index" : 0,
      "status" : "failed",
      "timedout" : null,
      "infrastructure_fail" : null,
      "type" : "test",
      "source" : "inference",
      "failed" : true
    } ]
  } ],
  ...
}

GET Request: Returns the full details for a single job. The response includes all of the fields from the job summary.
Retry a Jobcurl -X POST https://circleci.com/api/v1.1/project/:vcs-type/:org_name/:project/:build_num/retry -H "Circle-Token: <circle-token>"



You can retry a job with SSH by swapping “retry” with “ssh”.

{
  "vcs_url" : "https://github.com/circleci/mongofinil",
  "build_url" : "https://circleci.com/gh/circleci/mongofinil/23",
  "build_num" : 23,
  "branch" : "master",
  "vcs_revision" : "1d231626ba1d2838e599c5c598d28e2306ad4e48",
  "committer_name" : "Allen Rohner",
  "committer_email" : "arohner@gmail.com",
  "subject" : "Don't explode when the system clock shifts backwards",
  "body" : "", // commit message body
  "why" : "retry", // short string explaining the reason we built
  "dont_build" : null, // reason why we didn't build, if we didn't build
  "queued_at" : "2013-04-12T21:33:30Z" // time the job was queued
  "start_time" : "2013-04-12T21:33:38Z", // time the job started running
  "stop_time" : "2013-04-12T21:34:01Z", // time the job finished running
  "build_time_millis" : 23505,
  "username" : "circleci",
  "reponame" : "mongofinil",
  "lifecycle" : "queued",
  "outcome" : null,
  "status" : "queued",
  "retry_of" : 22, // build_num of the job that this is a retry of
  "previous" : { // previous job
    "status" : "failed",
    "build_num" : 22
  }
}

POST Request: Retries the job and then returns a summary of the new job run.
Cancel a Jobcurl -X POST https://circleci.com/api/v1.1/project/:vcs-type/:username/:project/:build_num/cancel -H "Circle-Token: <circle-token>"
{
  "vcs_url" : "https://github.com/circleci/mongofinil",
  "build_url" : "https://circleci.com/gh/circleci/mongofinil/26",
  "build_num" : 26,
  "branch" : "master",
  "vcs_revision" : "59c9c5ea3e289f2f3b0c94e128267cc0ce2d65c6",
  "committer_name" : "Allen Rohner",
  "committer_email" : "arohner@gmail.com",
  "subject" : "Merge pull request #6 from dlowe/master"
  "body" : "le bump", // commit message body
  "why" : "retry", // short string explaining the reason we built
  "dont_build" : null, // reason why we didn't build, if we didn't build
  "queued_at" : "2013-05-24T19:37:59.095Z" // time the job was queued
  "start_time" : null, // time the job started running
  "stop_time" : null, // time the job finished running
  "build_time_millis" : null,
  "username" : "circleci",
  "reponame" : "mongofinil",
  "lifecycle" : "queued",
  "outcome" : "canceled",
  "status" : "canceled",
  "canceled" : true,
  "retry_of" : 25, // build_num of the job that this is a retry of
  "previous" : { // previous job
    "status" : "success",
    "build_num" : 25
  }
}

POST Request: Cancels the job and then returns a summary of the job run.
Trigger a new Jobcurl -X POST --header "Content-Type: application/json" -H "Circle-Token: <circle-token>" -d '{
  "job": "deploy-preview"
  "tag": "v0.1", // optional
  "parallel": 2, //optional, default null
  "build_parameters": { // optional
    "RUN_EXTRA_TESTS": "true"
  }
}'

https://circleci.com/api/v1.1/project/:vcs-type/:username/:project
{
  "author_name": "Allen Rohner",
  "build_url": "https://circleci.com/gh/circleci/mongofinil/54",
  "reponame": "mongofinil",
  "failed": null,
  "infrastructure_fail": false,
  "canceled": false,
  "all_commit_details": [{
      "author_name": "Allen Rohner",
      "commit": "f1baeb913288519dd9a942499cef2873f5b1c2bf",
      "author_login": "arohner",
      "committer_login": "arohner",
      "committer_name": "Allen Rohner",
      "body": "Minor version bump",
      "author_date": "2014-04-17T08:41:40Z",
      "committer_date": "2014-04-17T08:41:40Z",
      "commit_url": "https://github.com/circleci/mongofinil/commit/f1baeb913288519dd9a942499cef2873f5b1c2bf",
      "committer_email": "arohner@gmail.com",
      "author_email": "arohner@gmail.com",
      "subject": "Merge pull request #15 from circleci/minor-version-bump"
    }],
  "previous": {
    "build_num": 53,
    "status": "success",
    "build_time_millis": 55413
  },
  "ssh_enabled": null,
  "author_email": "arohner@gmail.com",
  "why": "edit",
  "build_time_millis": null,
  "committer_email": "arohner@gmail.com",
  "parallel": 2,
  "retries": null,
  "compare": null,
  "dont_build": null,
  "committer_name": "Allen Rohner",
  "usage_queued_at": "2014-04-29T12:56:55.338Z",
  "branch": "master",
  "body": "Minor version bump",
  "author_date": "2014-04-17T08:41:40Z",
  "node": null,
  "committer_date": "2014-04-17T08:41:40Z",
  "start_time": null,
  "stop_time": null,
  "lifecycle": "not_running",
  "user": {
    "email": "arohner@gmail.com",
    "name": "Allen Rohner",
    "login": "arohner",
    "is_user": true
  },
  "subject": "Merge pull request #15 from circleci/minor-version-bump",
  "messages": [],
  "job_name": "my-new-job",
  "retry_of": null,
  "previous_successful_build": {
    "build_num": 53,
    "status": "success",
    "build_time_millis": 55413
  },
  "outcome": null,
  "status": "not_running",
  "vcs_revision": "f1baeb913288519dd9a942499cef2873f5b1c2bf",
  "vcs_tag": "v0.1",
  "build_num": 54,
  "username": "circleci",
  "vcs_url": "https://github.com/circleci/mongofinil",
  "timedout": false
}


We recommend migrating from this endpoint to use API v2  trigger a pipeline.


POST Request: Triggers a new job and then returns a summary of the job run.



Parameter
Description



job
Name of job. If not provided, defaults to a job named "build".


revision
The specific revision to build. Default is null and the head of the branch is used. Cannot be used with tag parameter.


tag
The tag to build. Default is null. Cannot be used with revision parameter.


build_parameters
Additional environment variables to inject into the job environment. A map of names to values.


Trigger a new Job with a Branchcurl -X POST --header "Content-Type: application/json" -H "Circle-Token: <circle-token>" -d '{
  "parallel": 2, //optional, default null
  "revision": "f1baeb913288519dd9a942499cef2873f5b1c2bf" // optional
  "build_parameters": { // optional
    "RUN_EXTRA_TESTS": "true"
  }
}'

https://circleci.com/api/v1.1/project/:vcs-type/:username/:project/tree/:branch
{
  "author_name": "Allen Rohner",
  "build_url": "https://circleci.com/gh/circleci/mongofinil/54",
  "reponame": "mongofinil",
  "failed": null,
  "infrastructure_fail": false,
  "canceled": false,
  "all_commit_details": [
    {
      "author_name": "Allen Rohner",
      "commit": "f1baeb913288519dd9a942499cef2873f5b1c2bf",
      "author_login": "arohner",
      "committer_login": "arohner",
      "committer_name": "Allen Rohner",
      "body": "Minor version bump",
      "author_date": "2014-04-17T08:41:40Z",
      "committer_date": "2014-04-17T08:41:40Z",
      "commit_url": "https://github.com/circleci/mongofinil/commit/f1baeb913288519dd9a942499cef2873f5b1c2bf",
      "committer_email": "arohner@gmail.com",
      "author_email": "arohner@gmail.com",
      "subject": "Merge pull request #15 from circleci/minor-version-bump"
    }
  ],
  "previous": {
    "build_num": 53,
    "status": "success",
    "build_time_millis": 55413
  },
  "ssh_enabled": null,
  "author_email": "arohner@gmail.com",
  "why": "edit",
  "build_time_millis": null,
  "committer_email": "arohner@gmail.com",
  "parallel": 2,
  "retries": null,
  "compare": null,
  "dont_build": null,
  "committer_name": "Allen Rohner",
  "usage_queued_at": "2014-04-29T12:56:55.338Z",
  "branch": "master",
  "body": "Minor version bump",
  "author_date": "2014-04-17T08:41:40Z",
  "node": null,
  "committer_date": "2014-04-17T08:41:40Z",
  "start_time": null,
  "stop_time": null,
  "lifecycle": "not_running", // :queued, :not_run, :not_running, :running or :finished
  "user": {
    "email": "arohner@gmail.com",
    "name": "Allen Rohner",
    "login": "arohner",
    "is_user": true
  },
  "subject": "Merge pull request #15 from circleci/minor-version-bump",
  "messages": [],
  "job_name": null,
  "retry_of": null,
  "previous_successful_build": {
    "build_num": 53,
    "status": "success",
    "build_time_millis": 55413
  },
  "outcome": null,
  "status": "not_running",
  "vcs_revision": "f1baeb913288519dd9a942499cef2873f5b1c2bf",
  "build_num": 54,
  "username": "circleci",
  "vcs_url": "https://github.com/circleci/mongofinil",
  "timedout": false
}


We recommend migrating from this endpoint to use API v2  trigger a pipeline.


POST Request: Triggers a new job and then returns a summary of the job run.



Parameter
Description



revision
The specific revision to build. Default is null and the head of the branch is used. Cannot be used with tag parameter.


build_parameters
Additional environment variables to inject into the job environment. A map of names to values.



Note Triggering a new job with a branch is not currently supported with configurations that specify version: 2.1.
Trigger a new Pipeline by Project

We recommend migrating from this endpoint to use API v2  trigger a pipeline.

curl -X POST https://circleci.com/api/v1.1/project/:vcs-type/:username/:project/build -H "Circle-Token: <circle-token>"
{
  "status": 200,
  "body": "Build created"
  }

POST Request: Triggers a pipeline of the specified project, by branch, revision, or tag. Workflows will be run or scheduled in the same way as when a webhook from source control is received. The use of this endpoint requires a personal API token.


Note: This endpoint does not yet support the build_parameters options that the job-triggering endpoint supports.
This also means that this endpoint is not available for CircleCI server.




Parameter
Description



revision
The specific revision to build. If not specified, the HEAD of the branch is used. Cannot be used with tag parameter


branch
The branch to build. Cannot be used with tag parameter.


tag
The git tag to build. Cannot be used with branch and revision parameters.


Get Test Metadatacurl https://circleci.com/api/v1.1/project/:vcs-type/:username/:project/:build_num/tests -H "Circle-Token: <circle-token>"
{
  "tests" : [ {
    "message" : "",
    "file" : "features/desktop/invitations.feature",
    "source" : "cucumber",
    "run_time" : 2.957513661,
    "result" : "success",
    "name" : "Accepting an invitation",
    "classname" : "Invitations"
  }, {
    "message" : null,
    "file" : "spec/lib/webfinger_spec.rb",
    "source" : "rspec",
    "run_time" : 0.011366,
    "result" : "success",
    "name" : "Webfinger#intialize sets account ",
    "classname" : "spec.lib.webfinger_spec"
  } ]
}

GET Request Provides test metadata for a job.


Learn how to set up your jobs to collect test metadata.

KeysList Checkout Keyscurl https://circleci.com/api/v1.1/project/:vcs-type/:username/:project/checkout-key?digest=sha256 -H "Circle-Token: <circle-token>"
[{"public_key": "ssh-rsa...",
  "type": "deploy-key", // can be "deploy-key" or "github-user-key"
  "fingerprint": "AddwN379YO1pnTyrOqALUZmo6XU4zJ2RLuOZslrl7c4",
  "preferred": true,
  "time" : "2015-09-21T17:29:21.042Z" // when the key was issued
  }]

GET Request: Returns an array of checkout keys for :project.



Parameter
Description



digest
Fingerprint digest. Optional; 'md5' by default. Pass 'sha256' to return SHA-256 key fingerprint.


New Checkout Keycurl -X POST --header "Content-Type: application/json" -d '{"type":"github-user-key"}' https://circleci.com/api/v1.1/project/:vcs-type/:username/:project/checkout-key -H "Circle-Token: <circle-token>"
{"public_key": "ssh-rsa...",
  "type": "deploy-key", // can be "deploy-key" or "user-key"
  "fingerprint": "c9:0b:1c:4f:d5:65:56:b9:ad:88:f9:81:2b:37:74:2f",
  "preferred": true,
  "time" : "2015-09-21T17:29:21.042Z" // when the key was issued
  }

POST Request: Creates a new checkout key. This API request is only usable with a user API token. Organizations using GitHub OAuth with SAML SSO may require an additional authorization step to use the key.



Parameter
Description



type
The type of key to create. Can be 'deploy-key' or 'github-user-key'.


Get Checkout Keycurl https://circleci.com/api/v1.1/project/:vcs-type/:username/:project/checkout-key/:fingerprint -H "Circle-Token: <circle-token>"
{"public_key": "ssh-rsa...",
  "type": "deploy-key", // can be "deploy-key" or "user-key"
  "fingerprint": "c9:0b:1c:4f:d5:65:56:b9:ad:88:f9:81:2b:37:74:2f",
  "preferred": true,
  "time" : "2015-09-21T17:29:21.042Z" // when the key was issued
  }

GET Request: Returns an individual checkout key. Supply fingerprint as a path parameter. Fingerprint can be of type md5 or sha256. sha256 fingerprints should be URL-encoded.
Delete Checkout Key
DELETE Request: Deletes a checkout key by fingerprint. Supply fingerprint as a path parameter. Fingerprint can be of type md5 or sha256. sha256 fingerprints should be URL-encoded.
curl -X DELETE https://circleci.com/api/v1.1/project/:vcs-type/:username/:project/checkout-key/:fingerprint -H "Circle-Token: <circle-token>"
{"message":"ok"}
Create SSH Keys
POST Request: Creates an SSH key that will be used to access the external system identified by the hostname parameter for SSH key-based authentication.
curl -X POST --header "Content-Type: application/json" -d '{"hostname":"hostname","private_key":"RSA private key"}' https://circleci.com/api/v1.1/project/:vcs-type/:username/:project/ssh-key -H "Circle-Token: <circle-token>"
# no response expected
Delete SSH Keycurl -X DELETE --header "Content-Type: application/json" -d {"fingerprint":"Fingerprint", "hostname":"Hostname"} https://circleci.com/api/v1.1/project/:vcs-type/:username/:project/ssh-key -H "Circle-Token: <circle-token>"
# no response expected

DELETE Request: Deletes an SSH key from the system by fingerprint. Supply fingerprint in request body. Fingerprint can be of type md5 or sha256.
Heroku Keys
POST Request: Adds your Heroku API key to CircleCI and then takes apikey as form param name.
curl -X POST --header "Content-Type: application/json" -d '{"apikey":"Heroku key"}' https://circleci.com/user/heroku-key -H "Circle-Token: <circle-token>"
# no response expected
ArtifactsArtifacts Of A Jobcurl https://circleci.com/api/v1.1/project/:vcs-type/:username/:project/:build_num/artifacts -H "Circle-Token: <circle-token>"
[ {
  "path" : "raw-test-output/go-test-report.xml",
  "pretty_path" : "raw-test-output/go-test-report.xml",
  "node_index" : 0,
  "url" : "https://24-88881093-gh.circle-artifacts.com/0/raw-test-output/go-test-report.xml"
}, {
  "path" : "raw-test-output/go-test.out",
  "pretty_path" : "raw-test-output/go-test.out",
  "node_index" : 0,
  "url" : "https://24-88881093-gh.circle-artifacts.com/0/raw-test-output/go-test.out"
} ]

Returns an array of artifacts produced by a given job.
Request Type: GET
Notes

The value of path is relative to the project root (the working directory).
pretty_path returns the same value as path. It is included in the response for backwards compatibility.

Download an artifact file
You can download an individual artifact file via the API with an API-token authenticated HTTP request.
curl -L https://132-55688803-gh.circle-artifacts.com/0//tmp/circle-artifacts.7wgAaIU/file.txt -H "Circle-Token: <circle-token>"
Notes

Make sure your HTTP client is configured to follow redirects as the artifact URLs can respond with
an HTTP 3xx status code (the -L switch in curl will achieve this).
:token is an API token with 'view-builds' scope.

Artifacts of the latest Job runcurl https://circleci.com/api/v1.1/project/:vcs-type/:username/:project/latest/artifacts?branch=:branch&filter=:filter -H "Circle-Token: <circle-token>"
[ {
  "path" : "raw-test-output/go-test-report.xml",
  "pretty_path" : "raw-test-output/go-test-report.xml",
  "node_index" : 0,
  "url" : "https://24-88881093-gh.circle-artifacts.com/0/raw-test-output/go-test-report.xml"
}, {
  "path" : "raw-test-output/go-test.out",
  "pretty_path" : "raw-test-output/go-test.out",
  "node_index" : 0,
  "url" : "https://24-88881093-gh.circle-artifacts.com/0/raw-test-output/go-test.out"
} ]

Returns an array of artifacts produced by the latest job run on a given branch.

Request Type: GET



Parameter
Description



branch
The branch you would like to look in for the latest job run. Returns artifacts for latest job run in entire project if omitted.


filter
Restricts which jobs are returned. Set to "completed", "successful", "failed", "running", or defaults to no filter.


Notes

The value of path is relative to the project root (the working directory).
pretty_path returns the same value as path. It is included in the response for backwards compatibility.

Environment VariablesList Environment Variablescurl https://circleci.com/api/v1.1/project/:vcs-type/:username/:project/envvar -H "Circle-Token: <circle-token>"
[{"name":"foo","value":"xxxx1234"}]

GET Request: Returns four 'x' characters plus the last four ASCII characters of the value, consistent with the display of environment variable values in the CircleCI website.
Add Environment Variablescurl -X POST --header "Content-Type: application/json" -d '{"name":"foo", "value":"bar"}' https://circleci.com/api/v1.1/project/:vcs-type/:username/:project/envvar -H "Circle-Token: <circle-token>"
{"name":"foo","value":"xxxx"}

POST Request Creates a new environment variable.
Get Single Environment Variablecurl https://circleci.com/api/v1.1/project/:vcs-type/:username/:project/envvar/:name -H "Circle-Token: <circle-token>"
{"name":"foo","value":"xxxx"}

GET Request: Returns the hidden value of environment variable :name.
Delete Environment Variablescurl -X DELETE https://circleci.com/api/v1.1/project/:vcs-type/:username/:project/envvar/:name -H "Circle-Token: <circle-token>"
{"message":"ok"}

DELETE Request Deletes the environment variable named :name.\n\n\n\nSoftware as a Service Agreement
      
      
          Last Updated:
          
            December 20, 2023
          
      
      
        
Thank you for your interest in using our services!

This online Software as a Service Agreement (‘Agreement’), which incorporates our AUP, Copyright Infringement Notice and Takedown Policy, Privacy Policy and Supplemental Terms as applicable, is incorporated by reference into each Order that you may enter into with Circle Internet Services, Inc., dba, CircleCI, a Delaware corporation (‘we,’ ‘CircleCI,’ ‘our,’ ‘us’). ‘You’ means your employer or the entity you represent, its Affiliates and Users, or, if that does not apply, it means you as an individual. Each of you and us is a ‘Party,’ and collectively, you and we are the ‘Parties.’ Capitalized terms not defined herein shall have the meaning set forth in the applicable Order.

You must be at least eighteen (18) years old to use the Services.

When you click ‘I Agree/I Accept/Sign Up/Pay Now’ (or similar button or checkbox) when registering for the Services, you are accepting this Agreement on behalf of your employer, another entity, or yourself, as applicable, and represent and warrant that: (i) you have full legal authority to bind your employer, such other entity, or yourself, as applicable, to the terms of this Agreement; (ii) you have read and understand the terms of this Agreement; and (iii) you agree to the terms of this Agreement on behalf of your employer, an entity that you represent, or yourself, as applicable.

PLEASE NOTE THAT IF YOU REGISTER FOR THE SERVICES USING AN EMAIL ADDRESS FROM YOUR EMPLOYER OR ANOTHER ENTITY, THEN (A) YOU SHALL BE DEEMED TO REPRESENT SUCH PARTY, AND (B) YOUR CLICK TO ‘AGREE/ACCEPT/SIGN UP/PAY NOW’ (OR SIMILAR BUTTON OR CHECKBOX) WILL BIND YOUR EMPLOYER OR THE OTHER ENTITY TO THIS AGREEMENT.

This Agreement is effective as of the earliest of (i) the date you first complete registration for the Services by clicking ‘I Agree/I Accept/Sign Up/Pay Now’ (or similar button or checkbox), (ii) access the Services, or (iii) the effective date set forth on the initial Order (the ‘Effective Date’). For Evaluations, you also indicate your acceptance of the terms of this Agreement by your accessing or using the applicable Evaluation(s). This Agreement does not have to be signed in order to be binding.

Your right to access the Services, whether or not an Order has been signed between you and us, is expressly conditioned on your acceptance of this Agreement.

If you do not agree with the terms of this Agreement, or you don’t have the legal authority to bind your employer or another entity, do not click ‘I Agree/I Accept/Sign Up/Pay Now’ (or similar button or checkbox) when presented to you. In this case, you may not use the Services.

  
    Definitions Used in this Agreement
    
      ‘Affiliate’ means a company, corporation or other legal entity that directly or indirectly controls, is controlled by, or is under common control with a Party to this Agreement. For purposes of this definition, ‘control’ means direct or indirect ownership or control of more than fifty percent (50%) of the voting interests of the subject entity. When your Affiliate enters into an Order hereunder, it agrees to be bound by the terms of this Agreement as if it were you.
      ‘Agreement’ means collectively, this Software as a Service Agreement, along with our AUP, Copyright Infringement Notice and Takedown Policy, Privacy Policy and Supplemental Terms as applicable.
      ‘AUP’ means our standard Acceptable Use Policy, currently available at https://circleci.com/legal/acceptable-use/ or any successor URL.
      ‘California Privacy Law’ means the California Consumer Privacy Act of 2018 (CCPA) and any regulations promulgated thereunder, as amended by the California Privacy Rights Act of 2020 (CPRA).
      ‘California User Data’ means the personal information of consumers in California provided or made available by you to CircleCI.
      ‘CircleCI Content’ means source code, configurations, data, Documentation, reports, text, images, sounds, video, and content we make available to you under this Agreement.
      ‘Confidential Information’ means any technical, financial, business or other information provided by one Party to the other Party (including the terms of this Agreement), either designated as confidential or proprietary, or reasonably should be understood to be confidential given the nature of the information and the circumstances of disclosure.
      ‘Copyright Infringement Notice and Takedown Policy’ means our Copyright Infringement Notice and Takedown Policy located at https://circleci.com/legal/copyright-infringement-policy/ or any successor URL.
      ‘Disclosing Party’ means the party that provides Confidential Information to the other Party.
      ‘Documentation’ means any manuals, instructions or other documents or materials that we make available to you in any form or medium, that describe the functionality, components, features or requirements of the Services or CircleCI Content, including the Specifications and any aspect of the installation, configuration, integration, operation, use, support or maintenance thereof, excluding any marketing or other publicly available materials.
      ‘Equipment’ means any and all hardware, servers, software, operating systems, networking, web servers, internet and telecommunications service(s) and ancillary services needed to connect to, access or otherwise use the Services.
      ‘Fees’ means the amount we charge you for the Services and Support, the payment terms of which are outlined on an Order. Fees are payable in US Dollars via ACH or credit card.
      ‘Feedback’ means any suggestion, idea, improvement, enhancement request, recommendation, correction or other feedback voluntarily provided by you or any User to us relating to the operation of the Services. We may, without restriction and in our sole discretion, utilize Feedback to design, debug, display, perform, copy, make, have made, use, sell, and otherwise dispose of in any manner that we may choose without remuneration or accreditation to you. Feedback does not include your Confidential Information, software code or trade secrets.
      ‘Intellectual Property Rights’ means legal rights to intangible creations owned or licensed by a party under any copyright, patent, trademark, trade secret and other intellectual property laws worldwide.
      ‘Non-CircleCI Applications’ means any internet-based or offline software application, such as a version control system, that is provided by you or a third party and interoperates with the Services.
      ‘Order’ means an order form or other ordering document, including any exhibits and Supplemental Terms as applicable, provided by us and entered into between the Parties and/or their respective Affiliate(s). An Order may be provided electronically or on your account page on our website, specifying the chosen Services and Support, and associated Fees and payment terms. For avoidance of doubt, if you use a purchase order system, the terms of the Order and Agreement take precedence over any conflicting terms of your purchase order.
      ‘Personal Data’ means information that, alone or in combination with other information, could be used to identify a User.
      ‘Privacy Laws’ means all laws and regulations regarding data privacy and transmission of Personal Data that apply to our provision of the Services to you (e.g., storing and processing Your Data), including, without limitation, Articles 25(1) and 26(1) of EU Directive 95/46/EC of 24 October 1995, General Data Protection Regulation 2016/679 (GDPR) and California Consumers Privacy Act of 2018 (CCPA), as amended by the California Privacy Rights Act of 2020 (CPRA).
      ‘Privacy Policy’ means our Privacy Policy located at https://circleci.com/legal/privacy/ or any successor URL.
      ‘Receiving Party’ means the Party that receives Confidential Information from the other Party.
      ‘Resource Class Page’ means the publicly available web page where we publish Credit expenditure schedules for the Services, currently available at https://circleci.com/pricing/price-list/ or any successor URL.
      ‘Self-Hosted Applications’ means optional hybrid applications that provide additional functionality and are downloaded, installed and used on servers in your environment, but interact with our Services through an internet connection.
      ‘Services’ means our continuous integration/continuous deployment software-as-a-service offering, Self-Hosted Applications, and any other software, including downloadable software, and related technologies that may be made available by us to interoperate with the foregoing.
      ‘Specifications’ means the description of, minimum standards required, and the mode, means and mechanisms of action or functionality for the Services set forth in the Documentation.
      ‘Supplemental Terms’ means additional terms that apply to certain Services, including any product-specific terms that may be agreed by the Parties.
      ‘Support’ means free or paid ticket-based help with the Services.
      ‘Taxes’ means all applicable federal, state and local taxes, fees, charges, or other similar exactions, including, without limitation, sales and use taxes, excise taxes, VAT, GST, and other license or business and occupations taxes. Taxes do not include any Taxes that are imposed on or measured by our net income, property tax, or payroll taxes.
      ‘Term’ means the period during which you have agreed to subscribe to the Services.
      ‘Third-Party Content’ means information and data obtained by CircleCI from publicly available sources or our third-party content providers and made available to you and its Users through the Services, Evaluations or pursuant to an Order.
      ‘Updates’ means upgrades, new features, bug fixes, patches, and/or other error corrections to the software that CircleCI makes from time to time in its sole discretion. Updates are subject to the terms of this Agreement upon release.
      ‘Usage Data’ means metrics and data relating to a User’s access to the Services, which may include configuration files, build logs, error logs and other similar materials. Usage Data, when combined with other data, is an original CircleCI compilation pursuant to the copyright laws of the United States and other jurisdictions, of which we have dedicated substantial resources to collecting, managing, and compiling. Except as described herein, Usage Data does not include your Confidential Information, software code or trade secrets.
      ‘User’ means an individual who is authorized by you to use the Services. Users may include, for example, your and your Affiliate’s employees, consultants, contractors, representatives and/or agents.
      ‘Your Data’ means any data, software code, your Confidential Information, or other information received by the Services from you, your Users or third parties, in the course of access to the Services, excluding CircleCI Content, Usage Data, Third-Party Content and Non-CircleCI Applications.
    
  
  
    Your Acceptance of the Terms of this Agreement and any Changes to It
    By entering into an Order or otherwise downloading, accessing or using the Services, you unconditionally accept and agree to all of the terms of this Agreement. This Agreement shall apply to all usage by you and each of your User(s) of the Services. We may modify this Agreement at any time by posting a revised version at https://circleci.com/legal/terms-of-service/, and the revised version will become effective on the day it is published; provided, however, that if an Order specifies a fixed term of twelve (12) months or longer, the modifications will instead be effective immediately upon the start of the next renewal Term, if applicable. In either case, if any change to this Agreement is not acceptable to you, as your sole and exclusive remedy, you may choose not to renew, including canceling the auto-renewal of any Terms, in accordance with the terms set forth in Section 9. For the avoidance of doubt, any Order is subject to the version of the Agreement in effect at the time of the Order.
  
  
    Agreement Structure and Order of Precedence
    If there are any conflicts between this Agreement and any Order, the Order takes precedence and prevails over this Agreement, solely with respect to the subject matter of the applicable Order.
  
  
    Free Evaluations
    From time to time, we may invite you to try certain features or products at no charge for a limited evaluation period, which may be designated or identified as beta, pilot, evaluation, trial or the like (collectively, ‘Evaluation(s)’). Your agreement to participate in an Evaluation is completely voluntary, and if you initially opt into an Evaluation, you may opt out at any time in writing. If you opt out of an Evaluation that you had originally opted in, your access to such Evaluation will be terminated. Notwithstanding anything to the contrary contained in this Agreement, Evaluations are licensed for your internal evaluation purposes only, and not for production use. Unless otherwise stated in an Order, an Evaluation is limited to thirty (30) days. Notwithstanding the foregoing, we may discontinue any Evaluation program in whole or in part at any time in our sole discretion and we reserve the right to decide whether to make features provided in an Evaluation generally available. DUE TO THE NATURE OF EVALUATIONS AND THEIR VOLUNTARY PARTICIPATION, EVALUATIONS ARE EXCLUDED FROM OUR REMEDIES UNDER SECTIONS 10, 11 AND 12, UNLESS SUCH EXCLUSION IS NOT ENFORCEABLE UNDER APPLICABLE LAW. IF LIABILITY EXCLUSION IS NOT ENFORCABLE UNDER APPLICABLE LAW, OUR LIABILITY ARISING UNDER CLAIMS OF INTELLECTUAL PROPERTY INFRINGEMENT, BREACH OF WARRANTY, NEGLIGENCE, STRICT LIABILITY OR ANY OTHER THEORY OF LIABILITY WITH RESPECT TO THE EVALUATION SHALL NOT EXCEED ONE HUNDRED DOLLARS ($100.00).
  
  
    Ownership
    
      
        As to CircleCI
        We and our licensors own and retain all right, title and interest in and to the Services, CircleCI Content, Usage Data and Feedback and all associated Intellectual Property Rights therein. Except as provided in Section 6(a) below, we grant no further rights to you or your Users under this Agreement.
      
      
        As to Your Data
        You own and retain all right, title and interest in and to Your Data and all associated Intellectual Property Rights therein. Subject to the limited licenses granted herein, we acquire no right, title or interest from you or your licensors under this Agreement in or to Your Data.
      
    
  
  
    License Grants; Obligations; Restrictions; Consequences
    
      
        License Grants
        
          Subject to the terms of this Agreement, each Order and Your payment of all Fees, we grant you and your Users a worldwide, non-exclusive, non-sublicensable, non-transferable right to access (and where applicable, download and install) the Services during the applicable Term.
          You grant us, our Affiliates and licensors a worldwide, non-exclusive, royalty-free, fully paid, sublicensable, non-transferable [except as specified in Section 15(b)], license to receive, host, store, analyze, process, enhance, copy, transmit, create derivative works of, maintain and display Your Data that you, or your User(s) post(s) to the Services (either directly or via a Non-CircleCI Application) solely to administer and provide the Services in accordance with this Agreement.
          If you use a Non-CircleCI Application with the Services, you grant us a license to provide the Non-CircleCI Application and our provider with access to Your Data and information about your and your Users’ usage of the Services, as appropriate, for the interoperation of that Non-CircleCI Application with the Services.
        
      
      
        Obligations
        You shall use the Services only for lawful purposes in accordance with this Agreement as expressly licensed herein, including, without limitation, with your obligations set forth in this Section 6, the Documentation, and applicable laws and government regulations. You shall (i) be responsible for your Users’ compliance with this Agreement; (ii) be responsible for the quality and legality of Your Data and the means by which you acquired Your Data; (iii) use commercially reasonable efforts to prevent unauthorized access to the Services, and notify us promptly of any such unauthorized access to which you become aware; (iv) provide all necessary disclosures to your Users and obtain all necessary consents from such Users, in each case to the extent necessary to share such Users’ Personal Data with us and our Affiliates, licensors and service providers to use such Personal Data to provide the Services; (v) comply with the terms of service of the Non-CircleCI Applications that you use with the Services; and (vi) comply with the terms of our AUP. You shall promptly notify us of any suspected or alleged violation of this Agreement and shall cooperate with us with respect to: (1) our investigation of any suspected or alleged violation of this Agreement and (2) any action taken by CircleCI to enforce this Agreement. If we send you a notice that any Third-Party Content or a Non-CircleCI Application must be modified, disabled and/or removed from the Services to avoid violating applicable law, third-party rights, or the terms of this Agreement, you shall promptly do so. You shall confirm such modification, disablement or removal of such Third-Party Content or Non-CircleCI Application in writing upon our request, and you hereby authorize us to provide a copy of such confirmation to any such third-party claimant or governmental authority, as applicable. You and your Users are responsible for maintaining the security of your accounts, usernames and passwords and files, and for all uses of your and your User’s account. We shall not be liable for any loss or damage from your or any of your User’s failure to comply with this security obligation.
      
      
        Restrictions
        This Agreement does not grant you any right to reproduce, modify, distribute, or publicly display or perform the software included in the Services. You must not violate the Prohibited Uses section of our AUP.
      
      
        Consequences
        We may, in our sole discretion, suspend or terminate your or any of your User’s access to the Services this Agreement and any active Orders with or without advance written notice to you if we reasonably determine that you or your User has violated this Section 6. We may remove Your Data from the Services (or disable access to it) in accordance with our Copyright Infringement Notice and Takedown Policy. If you do not remove Third-Party Content or a Non-CircleCI Application upon notice from us, or if, in our judgment, continued violation is likely to reoccur, we may disable or remove the Third-Party Content and/or the Non-CircleCI Application from the Services. You will be liable for any violation of this Agreement by any of your Users. If we terminate this Agreement or an active Order in accordance with this Section, we shall do so in accordance with Section 9(b)(ii) below.
      
    
  
  
    Services and Support
    
      
        Creation of CircleCI Account
        As part of the registration process for the Services, you will create a CircleCI account by either providing your or your User’s email address and a password or by authorizing the CircleCI application through a Non-CircleCI Application (e.g., GitHub via Oauth). Account information must be accurate, current, and complete, and is governed by our Privacy Policy. You and your Users are each responsible for maintaining the confidentiality of, and activities that occur under, their respective account(s), and for any activities performed under such account(s). We reserve the right to access your and your Users’ accounts in order to respond to your or your Users’ requests for technical support. We retain the right, but not the obligation, to monitor the Services and Your Data.
      
      
        Provision of Services and Support
        We shall make the Services available to you and your Users pursuant to this Agreement and the applicable Order. We will provide Support in accordance with the level chosen on any Order. Support names and associated features are included on each Order. We will use commercially reasonable efforts to make the Services available 24 hours per day, 7 days per week, except for: (i) planned downtime, of which we will typically provide at least forty-eight (48) hours’ electronic notice and schedule, to the extent practicable, during the weekend hours between 6:00 p.m. Friday and 3:00 a.m. Monday, Pacific time, and (ii) any unavailability caused by unscheduled emergency maintenance either by us or our third-party vendors or hosting providers, or (iii) a Force Majeure event, the failure or delay of an internet service provider or Non-CircleCI Application, or any denial of service attack, for which we may or may not provide notice.
      
      
        Changes to Services and Support
        You may request Services and/or Support Plan upgrades at any time. Upon receipt of such request, we will promptly make the upgrade and bill you for such upgrade, prorated for the remaining Term of your current billing cycle. We do not provide mid-term Support Plan downgrades or refunds for Credits. You may downgrade your Support Plan upon the commencement of the first renewal Term after notice of such downgrade. You acknowledge that Support Plan upgrades provide additional features and decreased response times, while Support Plan downgrades remove features and increase response times. From time to time, we may introduce new Services, or update or sunset current Services, including but not limited to business model, plan level and/or features, Credit use executor type and resource class offerings and/or Support Plans. You will be migrated to the then-current business model, plan level and/or features, Support Plan and/or features upon release of the same, or when applicable, upon renewal.
      
      
        Non-CircleCI Applications
        You and your Users may enable or log in to our Services through a Non-CircleCI Application. You and your Users may download, authenticate, register for, and/or log into the Non-CircleCI Application on such application’s website. The Non-CircleCI Application provides us with certain information that you and your Users have provided to such Non-CircleCI Application, and we will use, store and disclose such information in accordance with our Privacy Policy. The way that Non-CircleCI Applications use, store and disclose your and your Users’ information is governed solely by the policies of the third parties that operate the Non-CircleCI Application, and we shall have no liability or responsibility for the privacy practices or other actions of any third-party site, application or service that may be enabled within the Services. In addition, we are not responsible for the accuracy, availability or reliability of any information, content, goods, data, opinions, advice or statements made available in connection with any Non-CircleCI Application, and as such, we shall not be liable for any damage or loss caused or alleged to be caused by or in connection with use or reliance thereon. We enable access to Non-CircleCI Applications merely as a convenience, and the integration or inclusion of such does not imply an endorsement or recommendation by CircleCI.
      
      
        Software Updates
        
          We continuously update our cloud-based software. You access the newest software version each time you log into the Services.
          We may develop and release Updates to Self-Hosted Applications (‘SHA Updates’). We will post notices of SHA Updates on the Self-Hosted Application change log, and, if you have not agreed to automatic updates, you agree to download and install such SHA Updates promptly. You acknowledge that, once a SHA Update has been provided, older versions of Self-Hosted Applications or portions thereof may no longer operate properly. We shall have no liability for inoperability due to your delay in installing SHA Updates.
        
      
      
        Equipment
        You are responsible for obtaining and maintaining any Equipment you need to use the Services and for ensuring that such Equipment is compatible with the Services  and complies with all configurations and Specifications set forth in the Documentation. We shall have no liability to you for any damage caused to your servers resulting from your access to the Services. You are responsible for maintaining the security of the Equipment and for all uses of the Equipment.
      
      
        Future Functionality
        You agree that your purchases are not contingent on the delivery of any future functionality or features, or dependent on any oral or written public comments made by us regarding any future functionality or features.
      
    
  
  
    Fees and Payment
    
      
        Fees
        You shall pay us the Fees set forth in each Order, under the terms set forth therein and this Agreement. Fees are charged in advance through the purchase of Credits and a Support Plan, except for Fees for overages, which are charged in arrears. Unless otherwise stated in an Order, (i) Fees for renewal Terms are subject to the then-current pricing, and (ii) you are responsible for, and will pay all Taxes imposed on or with respect to the Services that are the subject of this Agreement. If you are tax-exempt, you will supply official exemption documentation to us.
      
      
        Payments
        Payment terms are described in each Order. Notwithstanding, all amounts paid or payable are non-refundable, non-cancelable and non-creditable. If any amount owing by you under this Agreement for the Services is ten (10) or more days overdue, we may, in our sole discretion and without limiting any other rights and remedies, limit or suspend your access to the Services and Support until such amounts are paid in full, or we may, in our sole discretion, terminate the account in accordance with Section 9(b) below. If we suspend, limit, or terminate the Services under this Section 8(b), we will have no liability for any resulting damage, liabilities, losses (including any loss of data or profits) or any other consequences that you may experience. Additionally, any payments more than ten (10) days overdue shall bear a late payment fee of one and one-half percent (1.5%) per month, or if the maximum rate allowed by law is less, the maximum rate allowable by law.
      
    
  
  
    Term and Termination
    
      
        Term of Agreement and Orders
        This Agreement will begin on the Effective Date and continue in effect until terminated. Each Party may terminate this Agreement with thirty (30) days’ advance written notice if all Terms of Orders for the Service have expired or are terminated in accordance with Section 9(b). The Term of each Order will be set forth therein, starting on the Effective Date of the Order and continuing for the time period specified.
      
      
        Termination; Effect of Expiration or Termination; Survival
        
          Either Party may terminate any Order in accordance with its terms. Either Party may terminate any Order for cause upon written notice if the other Party fails to cure any material breach thereof within thirty (30) days after receiving a reasonably detailed written notice from the other Party alleging the breach. We may terminate any Order for cause upon written notice (1) within ten (10) days in the case of non-payment; and (2) immediately in the case of your or any of your User’s breach of Section 6(c). Upon any termination of this Agreement due to our uncured material breach of this Agreement, we will provide a refund to you for any prepaid and unused fees paid under this Agreement on a prorated basis. Termination is not an exclusive remedy, and all other remedies shall be available regardless of whether termination occurs.
          Regardless of the basis for expiration or termination of this Agreement, upon expiration or termination of an Order or this Agreement, we (1) will terminate your access to the Services, Support and CircleCI Content; and (2) shall not be obligated to retain any your Data for longer than thirty (30) days after any such expiration or termination. Thereafter, we may in our sole discretion, delete Your Data from the Services, which is unrecoverable. You shall destroy all copies of all CircleCI Content and all portions thereof in your possession and certify such destruction to us if we request such certification.
          All provisions of this Agreement which by their nature should survive expiration or termination, including without limitation, Sections 3 (Agreement Structure and Order of Precedence), 5 (Ownership), 9 (Term and Termination), 10 (Indemnification), 11 (Warranties and Disclaimer), 12 (Limitation of Liability), 13 (Confidentiality), 14 (Privacy, Security and Continuity), and 15 (Miscellaneous) shall survive any expiration or termination of this Agreement. The applicable Orders may identify additional terms that shall survive any expiration or termination of this Agreement.
        
      
    
  
  
    Indemnification
    
      You shall defend, indemnify and hold harmless us and our Affiliates, and each of their respective officers, directors, employees and agents (the ‘CircleCI Indemnitees’) from all damages, settlements, attorneys’ fees and expenses related to any third-party claim, suit or demand from (i) an allegation that the Your Data infringes or misappropriates such third party’s Intellectual Property Rights or violates applicable law or (ii) your or your employees’ or agents’ gross negligence, willful misconduct or fraud.
      The applicable CircleCI Indemnitee will promptly notify you upon becoming aware of any and all threats, claims and proceedings related thereto, and such CircleCI Indemnitee will reasonably cooperate with you to resolve the applicable claim (at your cost). Each applicable CircleCI Indemnitee reserves the right to assume the exclusive defense and control of any matter that is subject to indemnification under this Section 10. In such case, you agree to cooperate with any reasonable requests in assisting each applicable CircleCI Indemnitee’s defense of such matter. You shall not agree to, nor will we be responsible for, any settlement, judgment or other agreement which admits fault or incurs liability of us without our prior written approval, which approval will not be unreasonably withheld, conditioned, or delayed.
    
  
  
    Warranties and Disclaimer
    
      
        Warranties
        During the Term, we warrant, for your benefit only, that (i) we have the full right and legal authority to grant licenses provided herein and bind ourselves to the terms of this Agreement; and (ii) the Services shall be provided in a professional and workmanlike manner. You represent and warrant that you: (x) have the full legal authority to bind yourself to the terms of this Agreement; and (y) own or license rights to any Equipment on which Self-Hosted Applications is installed, and you are solely responsible for the configuration, security, and maintenance of such Equipment.
      
      
        Disclaimer
        EXCEPT AS PROVIDED HEREIN, THE SERVICES, EVALUATIONS, AND ALL SERVER AND NETWORK COMPONENTS ARE PROVIDED ON AN ‘AS IS’ AND ‘AS AVAILABLE’ BASIS WITHOUT ANY WARRANTIES OF ANY KIND, AND WE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, ALL IMPLIED WARRANTIES OF MERCHANTABILITY, TITLE, FITNESS FOR A PARTICULAR PURPOSE, AND NONINFRINGEMENT.
      
    
  
  
    Limitation of Liability
    UNDER NO CIRCUMSTANCES AND UNDER NO LEGAL THEORY (WHETHER IN CONTRACT, TORT OR OTHERWISE) SHALL WE OR OUR AFFILIATES, OFFICERS, DIRECTORS, EMPLOYEES, AGENTS, SERVICE PROVIDERS, SUPPLIERS OR LICENSORS BE LIABLE TO YOU, ANY USER OR ANY THIRD-PARTY FOR ANY (i) INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, CONSEQUENTIAL OR PUNITIVE DAMAGES, INCLUDING LOST PROFITS, LOST SALES OR BUSINESS, LOST DATA, GOODWILL, OR OTHER INTANGIBLE LOSSES; OR (ii) COST OF PROCUREMENT OF SUBSTITUTE PRODUCTS OR SERVICES IN CONNECTION WITH THIS AGREEMENT OR THE SERVICES, REGARDLESS OF WHETHER WE HAVE BEEN ADVISED OF THE POSSIBILITY OF OR COULD HAVE FORESEEN SUCH DAMAGES. NOTWITHSTANDING ANYTHING TO THE CONTRARY IN THIS AGREEMENT, OUR AGGREGATE LIABILITY TO YOU, YOUR AFFILIATES, OR ANY THIRD PARTY ARISING OUT OF OR RELATING TO THIS AGREEMENT OR THE SERVICES, SHALL IN NO EVENT EXCEED THE GREATER OF THE FEES ACTUALLY PAID BY YOU IN THE SIX (6) MONTHS PRECEDING THE EVENT GIVING RISE TO YOUR OR YOUR USER’S CLAIM OR ONE HUNDRED DOLLARS (US$100.00). YOU ACKNOWLEDGE AND AGREE THAT THE ESSENTIAL PURPOSE OF THIS SECTION 12 IS TO ALLOCATE THE RISK UNDER THIS AGREEMENT BETWEEN THE PARTIES, AND THE PARTIES HAVE RELIED ON THESE LIMITATIONS IN DETERMINING WHETHER TO ENTER INTO THIS AGREEMENT. SOME JURISDICTIONS DO NOT ALLOW THE EXCLUSION OF IMPLIED WARRANTEES OR LIMITATION OF LIABILITY FOR INCIDENTAL OR CONSEQUENTIAL DAMAGES, WHICH MEANS THAT SOME OF THE ABOVE LIMITATIONS MAY NOT APPLY TO YOU OR SOME USERS. IN SUCH JURISDICTIONS, OUR LIABILITY SHALL BE LIMITED TO THE GREATEST EXTENT PERMITTED BY LAW.
  
  
    Confidentiality
    All Confidential Information shall be held in confidence and will not be disclosed or used except to the extent necessary to carry out the Receiving Party’s obligations or express rights hereunder, except as otherwise authorized by the Disclosing Party in writing. The Receiving Party will use the same degree of care that it uses to protect the confidentiality of its own Confidential Information of like kind (but not less than reasonable care). These obligations shall not apply to information that (i) was previously known by the Receiving Party, as demonstrated by documents or files in existence at the time of disclosure; (ii) is generally and freely publicly available through no fault of the Receiving Party; (iii) the Receiving Party otherwise rightfully obtains from third parties without restriction; or (iv) is independently developed by the Receiving Party without reference to or reliance on the Disclosing Party’s Confidential Information, as demonstrated by documents or files in existence at the time of disclosure. The Receiving Party may disclose Confidential Information of the Disclosing Party to the extent compelled to do so by law, provided the Receiving Party gives the Disclosing Party prior notice of the compelled disclosure (to the extent legally permitted) and reasonable assistance, at the Disclosing Party’s cost, if the Disclosing Party wishes to contest the disclosure. If the Receiving Party is compelled by law to disclose the Disclosing Party’s Confidential Information as part of a civil proceeding to which the Disclosing Party is a party, and the Disclosing Party is not contesting the disclosure, the Disclosing Party will reimburse the Receiving Party for its reasonable cost of compiling and providing secure access to that Confidential Information. In the event that such protective order or other remedy is not obtained, the Receiving Party will furnish only that portion of the Confidential Information that is legally required and use commercially reasonable efforts to obtain assurance that confidential treatment will be accorded the Confidential Information.
  
  
    Privacy, Security and Continuity
    
      
        Privacy
        We will use Your Data only as permitted by Privacy Laws, our Privacy Policy and this Agreement. Our Privacy Policy states how it will collect, store, use and disclose Your Data including Personal Data. If you do not agree with our Privacy Policy, then you must stop using the Services immediately. We encourage you to periodically review our Privacy Policy, as it may change from time to time. Each Party shall comply with its own obligations under the applicable Privacy Laws. In this regard, you are solely responsible for providing any notices required by applicable Privacy Laws to, and receiving any consents and authorizations required by applicable Privacy Laws from, persons whose Personal Data may be included in Your Data. If you believe that the Your Data may include the Personal Data of natural persons located in the European Economic Area or United Kingdom and wish to execute a Data Processing Addendum (‘DPA’) pursuant to the GDPR, you may request, review and execute the DPA located at: https://circleci.com/legal/data-privacy/ or any successor URL.
      
      
        California Privacy Law
        For clarity under this Section 14(b), the terms ‘business’, ‘business purpose’, ‘commercial purpose’, ‘consumer’, ‘personal information’, ‘sensitive personal information’, ‘sell’, ‘share’ and ‘service provider’ have the meanings set forth in the California Privacy Law. The Parties agree that we are acting as a service provider in connection with this Agreement with respect to the California User Data, and that we receive the California User Data from you pursuant to a business purpose. You represent and warrant to us that you (i) are acting as a business in connection with this Agreement with respect to the California User Data, and (ii) are sharing and making available to us the California User Data pursuant to a business purpose and in accordance with the California Privacy Law. The Parties agree to comply with their own applicable obligations under, and provide the same level of privacy protection to, California User Data as required by the California Privacy Law.

        
          
            Our Obligations
            We agree not to (1) sell or share California User Data or (2) retain, use or disclose California User Data (x) for any purpose other than for the specific purpose of performing the Services or for a commercial purpose other than providing the Services, or (y) outside of the direct business relationship between us and you, including by not combining any California User Data with other personal information collected or received from another source except as otherwise permitted under the California Privacy Law.
          
          
            Your Obligations and Rights
            You agree that (1) you will only disclose California User Data to us for the limited purpose of using the Services in accordance with the Agreement, and (2) you represent that the California User Data does not contain sensitive personal information. If we engage in an unauthorized use of California User Data, you may, upon reasonable notice to us, take reasonable and appropriate steps to stop and remediate the unauthorized use of the California User Data.
          
        
      
      
        Security of the Services; Protection of Your Data
        We shall maintain reasonable administrative, physical, and technical safeguards for protection of the security, confidentiality and integrity of Your Data. Those safeguards will include, but will not be limited to, measures designed to prevent unauthorized access to or disclosure of Your Data (other than by you or your Users). We shall not be responsible or liable for any deletion, correction, damage, destruction or loss of Your Data that does not arise from a breach of its obligations under this Section 14(c).
      
      
        Data Transmission and Encryption
        Your Data is encrypted at rest and in transit as it traverses private networks and the internet. While we maintain a Data Backup Policy that requires restoration capabilities within common industry timelines, you bear sole responsibility for adequate backup of Your Data. Except for unauthorized access due to our negligence, we shall have no liability to you for any third-party unauthorized access to any of Your Data, or any corruption, deletion, destruction or loss of any Your Data.
      
      
        Business Continuity & Disaster Recovery
        Throughout the Term, we shall implement and maintain commercially reasonable business continuity and disaster recovery plans to help ensure availability of the Your Data following any significant interruption or failure of critical business processes or systems affecting the Services.
      
    
  
  
    Miscellaneous
    
      
        Governing Law; Venue; Attorney’s Fees
        This Agreement is governed by and construed pursuant to California law and controlling United States federal law, without regard to the conflicts of law provisions of any jurisdiction. The Parties (i) hereby generally, irrevocably and unconditionally submit to the exclusive jurisdiction of the federal and state courts in San Francisco County, California for the purpose of any suit, action or other proceeding arising out of or based upon this Agreement; (ii) agree not to commence any suit, action or other proceeding arising out of or based upon this Agreement except in such state and such courts; and (iii) hereby waive, and agree not to assert, by way of motion, as a defense, or otherwise, in any such suit, action or proceeding, any claim that it is not subject personally to the jurisdiction of the above-named courts, that its property is exempt or immune from attachment or execution, that the suit, action or proceeding is brought in an inconvenient forum, that the venue of the suit, action or proceeding is improper or that this Agreement or the subject matter hereof may not be enforced in or by such court. This choice of jurisdiction does not prevent either Party from seeking injunctive relief in any appropriate jurisdiction with respect to a violation of Intellectual Property Rights. The Services are a service, not goods, and are not subject to the Uniform Commercial Code, or the United Nations Convention on the International Sale of Goods. If any action is necessary to enforce the terms of this Agreement, the prevailing Party shall be entitled to reasonable attorneys’ fees, costs and expenses, in addition to any other relief that such prevailing Party may be entitled.
      
      
        Assignment
        Neither Party may assign or otherwise transfer (by operation of law or otherwise) this Agreement, or any of a Party’s rights or obligations under this Agreement, to any third party without the other Party’s prior written consent, which consent must not be unreasonably withheld, delayed or conditioned. Notwithstanding, either Party may assign or otherwise transfer this Agreement, including all associated Orders (and all its rights and obligations thereunder) to a successor-in-interest in connection with a merger, acquisition, reorganization, a sale of all or substantially all of its assets, or other change of control, or to any of its Affiliates. In the event of such a permitted transfer by you, the rights granted under this Agreement will continue to be subject to the same usage limitations that applied under any applicable Order prior to the transfer. Any purported assignment or other transfer in violation of this Section 15(b) is void. Subject to the terms of this Section 15(b), this Agreement will bind and inure to the benefit of the Parties and their respective permitted successors and transferees. There are no third-party beneficiaries under this Agreement.
      
      
        Force Majeure
        Except for the payment obligations hereunder, if either Party is prevented from performing, or is unable to perform, any of its obligations under this Agreement due to any cause beyond its reasonable control, including, but not limited to, war, riots, labor unrest, fire, earthquake, flood, hurricane, other natural disasters and acts of God, internet service failures or delays, and denial of service attacks (collectively, ‘Force Majeure’), the affected Party’s performance will be excused for the resulting period of delay or inability to perform. The affected Party must (i) give the other Party prompt written notice of the nature and expected duration of such Force Majeure, (ii) use commercially reasonable efforts to mitigate the period of delay or inability to perform, (c) periodically notify the other Party of significant changes in the status of the Force Majeure, and (d) notify the other Party promptly when the Force Majeure ends.
      
      
        Independent Contractors
        The Parties are independent contracting parties. Neither Party has, or shall hold itself out as having, any right or authority to incur any obligation on behalf of the other Party. The Parties’ relationship in connection with this Agreement is not construed a joint venture, partnership, franchise, employment, fiduciary, or agency relationship between the Parties, or as imposing any liability upon either Party that otherwise might result from such a relationship. Each Party will be solely responsible for payment of all compensation owed to its employees, as well as all employment and income-related taxes.
      
      
        Licensing the Services Through a Reseller or Marketplace
        Notwithstanding anything to the contrary in this Agreement, if you purchase a license to the Services through an authorized partner, reseller or marketplace (‘Third-Party Seller’):
        
          You agree to be bound by the terms of this Agreement.
          We will invoice Third-Party Seller, not you. You will pay the applicable amounts to the Third-Party Seller, as agreed between you and the Third-Party Seller, and Third-Party Seller will pay us. We may suspend or terminate your rights to use the Services if we do not receive the corresponding payment from the Third-Party Seller.
          Your Order details (e.g., the Services that Third-Party Seller is purchasing on behalf of You, the Term, etc.) will be as stated in the Order that the Third-Party Seller places with us on your behalf, and the Third-Party Seller is responsible for the accuracy of any such Order as communicated to us. We will only provision the Services for you after we receive and accept the Order from the Third-Party Seller.
          If you are entitled to a refund from a Third-Party Seller, the Third-Party Seller is solely responsible for providing such refund to you. We disclaim liability for any refunds owed to you from a Third-Party Seller.
          Third-Party Sellers are not authorized to modify this Agreement or make any promises or commitments on our behalf, and we are not bound by any obligations to you other than as set forth in this Agreement, unless agreed in writing by us and provided to you.
        
      
      
        Notices
        Billing-related notices to you will be emailed to your accounts payable contact designated by you and to us at this address. We will provide platform-related notices to you by email and/or the platform. Email notices shall be deemed to have been given on the day the email is sent. Notices for material breach or an indemnifiable claim must be in writing and shall be deemed to have been given upon personal delivery or delivery confirmation by nationally or internationally recognized overnight delivery service. We will provide written notice to you at the address you provide on your Order. You will send written notices to Circle Internet Services, Inc., dba, CircleCI at 2261 Market Street, #22561, San Francisco, CA, 94114 USA, Attn: Chief Legal Officer, with a courtesy copy emailed here. Either Party may provide a subsequent email or physical notice address in writing to the other Party in the manner provided herein.
      
      
        Anti-Corruption
        Each party shall comply with applicable laws concerning anti-bribery and anti-corruption, which includes the United States Foreign Corrupt Practices Act of 1977 as may be amended. As of the date of this Agreement and the date of each Order, you represent that you have not received or been offered any illegal or otherwise improper bribe, kickback, payment, gift or other thing of value from any employees, representatives or agents of us or our Affiliates in connection with this Agreement. You shall use reasonable efforts to promptly notify us if you become aware of any circumstances that are contrary to the foregoing representation.
      
      
        Government Users
        If you are a U.S. Government Agency, or this Agreement otherwise becomes subject to the Federal Acquisition Regulations (FAR) and any applicable Agency-specific FAR Supplements, you acknowledge that the Services constitute ‘commercial computer software’ and ‘commercial computer software documentation’ as such terms are used in FAR 12.212, DFARS 252.227-7014 and DFARS 227.7202. In accordance with FAR 12.211-12.212 and DFARS 227.7102-4 and 227.7202-4, as applicable, the rights of the U.S. Government to use, modify, reproduce, release, perform, display, or disclose commercial computer software, commercial computer software documentation, and technical data furnished in connection with the Services shall be as provided in this Agreement, except that, for U.S. Department of Defense Customer, technical data customarily provided to the public is being furnished in accordance with DFARS 252.227-7015. The commercial computer software and commercial computer software documentation are being licensed to U.S. Government end users (a) only as Commercial Items and (b) with only such rights as are granted to all other end-users pursuant to the terms herein. Any provisions of this Agreement inconsistent with federal procurement regulations or other federal law are not enforceable against the U.S. Government. If a U.S. Government Agency needs additional rights, it must negotiate a mutually acceptable written specially negotiated license to be incorporated as an addendum to this Agreement that will specifically grant those rights.
      
      
        Publicity
        Unless otherwise specified in the applicable Order, we may use your name, logo and marks to identify you as a customer of ours on our website and other marketing materials.
      
      
        Execution
        This Agreement and any Order may be signed electronically and in counterparts, in which case each signed copy will be deemed an original as though both signatures appeared on the same document.
      
      
        Severability
        If any provision of this Agreement or any Order is adjudged by any court of competent jurisdiction unenforceable or invalid, that provision will be limited or eliminated to the minimum extent necessary so that this Agreement and any applicable Order will otherwise remain in full force and effect and enforceable.
      
      
        Waiver
        A Party’s failure or delay in exercising any right hereunder does not operate as a waiver thereof, nor will any partial exercise of any right or power hereunder preclude further exercise.
      
      
        Entire Agreement
        This Agreement, together with all applicable Orders (including any other terms referenced in any of those documents), comprises the entire agreement between the Parties regarding the subject matter of this Agreement, and supersedes all prior or contemporaneous negotiations, discussions or agreements, whether written or oral, between the Parties regarding such subject matter. This Agreement may only be modified by written, mutual agreement of the Parties.
      
    
  


To view the prior version of these terms, please click here.\n\nLegal
  







  
    
      
        
        
        
          
          
            
              
                Software as a Service Agreement
              
            
            
              
              


  Definitions Used in this Agreement
  Your Acceptance of the Terms of this Agreement and any Changes to It
  Agreement Structure and Order of Precedence
  Free Evaluations
  Ownership
  License Grants; Obligations; Restrictions; Consequences
  Services and Support
  Fees and Payment
  Term and Termination
  Indemnification
  Warranties and Disclaimer
  Limitation of Liability
  Confidentiality
  Privacy, Security and Continuity
  Miscellaneous




            
          
        
          
          
            
              
                Software License Agreement
              
            
            
          
        
          
          
            
              
                AI Functionality Terms
              
            
            
          
        
          
          
            
              
                Code Sharing Terms of Service
              
            
            
          
        
          
          
            
              
                Self-Hosted Applications Terms
              
            
            
          
        
          
          
            
              
                Acceptable Use Policy
              
            
            
          
        
          
          
            
              
                Cookie Policy
              
            
            
          
        
          
          
            
              
                Privacy Policy
              
            
            
          
        
          
          
            
              
                CircleCI’s Commitment to Data Privacy
              
            
            
          
        
          
          
            
              
                 Trademark Usage Guidelines
              
            
            
          
        
          
          
            
              
                Copyright Infringement Notice and Takedown Policy
              
            
            
          
        
          
          
            
              
                Website Terms of Use
              
            
            
          
        
      
    
  
  
    
      
        Software as a Service Agreement
      
      
          Last Updated:
          
            December 20, 2023
          
      
      
        
Thank you for your interest in using our services!

This online Software as a Service Agreement (‘Agreement’), which incorporates our AUP, Copyright Infringement Notice and Takedown Policy, Privacy Policy and Supplemental Terms as applicable, is incorporated by reference into each Order that you may enter into with Circle Internet Services, Inc., dba, CircleCI, a Delaware corporation (‘we,’ ‘CircleCI,’ ‘our,’ ‘us’). ‘You’ means your employer or the entity you represent, its Affiliates and Users, or, if that does not apply, it means you as an individual. Each of you and us is a ‘Party,’ and collectively, you and we are the ‘Parties.’ Capitalized terms not defined herein shall have the meaning set forth in the applicable Order.

You must be at least eighteen (18) years old to use the Services.

When you click ‘I Agree/I Accept/Sign Up/Pay Now’ (or similar button or checkbox) when registering for the Services, you are accepting this Agreement on behalf of your employer, another entity, or yourself, as applicable, and represent and warrant that: (i) you have full legal authority to bind your employer, such other entity, or yourself, as applicable, to the terms of this Agreement; (ii) you have read and understand the terms of this Agreement; and (iii) you agree to the terms of this Agreement on behalf of your employer, an entity that you represent, or yourself, as applicable.

PLEASE NOTE THAT IF YOU REGISTER FOR THE SERVICES USING AN EMAIL ADDRESS FROM YOUR EMPLOYER OR ANOTHER ENTITY, THEN (A) YOU SHALL BE DEEMED TO REPRESENT SUCH PARTY, AND (B) YOUR CLICK TO ‘AGREE/ACCEPT/SIGN UP/PAY NOW’ (OR SIMILAR BUTTON OR CHECKBOX) WILL BIND YOUR EMPLOYER OR THE OTHER ENTITY TO THIS AGREEMENT.

This Agreement is effective as of the earliest of (i) the date you first complete registration for the Services by clicking ‘I Agree/I Accept/Sign Up/Pay Now’ (or similar button or checkbox), (ii) access the Services, or (iii) the effective date set forth on the initial Order (the ‘Effective Date’). For Evaluations, you also indicate your acceptance of the terms of this Agreement by your accessing or using the applicable Evaluation(s). This Agreement does not have to be signed in order to be binding.

Your right to access the Services, whether or not an Order has been signed between you and us, is expressly conditioned on your acceptance of this Agreement.

If you do not agree with the terms of this Agreement, or you don’t have the legal authority to bind your employer or another entity, do not click ‘I Agree/I Accept/Sign Up/Pay Now’ (or similar button or checkbox) when presented to you. In this case, you may not use the Services.

  
    Definitions Used in this Agreement
    
      ‘Affiliate’ means a company, corporation or other legal entity that directly or indirectly controls, is controlled by, or is under common control with a Party to this Agreement. For purposes of this definition, ‘control’ means direct or indirect ownership or control of more than fifty percent (50%) of the voting interests of the subject entity. When your Affiliate enters into an Order hereunder, it agrees to be bound by the terms of this Agreement as if it were you.
      ‘Agreement’ means collectively, this Software as a Service Agreement, along with our AUP, Copyright Infringement Notice and Takedown Policy, Privacy Policy and Supplemental Terms as applicable.
      ‘AUP’ means our standard Acceptable Use Policy, currently available at https://circleci.com/legal/acceptable-use/ or any successor URL.
      ‘California Privacy Law’ means the California Consumer Privacy Act of 2018 (CCPA) and any regulations promulgated thereunder, as amended by the California Privacy Rights Act of 2020 (CPRA).
      ‘California User Data’ means the personal information of consumers in California provided or made available by you to CircleCI.
      ‘CircleCI Content’ means source code, configurations, data, Documentation, reports, text, images, sounds, video, and content we make available to you under this Agreement.
      ‘Confidential Information’ means any technical, financial, business or other information provided by one Party to the other Party (including the terms of this Agreement), either designated as confidential or proprietary, or reasonably should be understood to be confidential given the nature of the information and the circumstances of disclosure.
      ‘Copyright Infringement Notice and Takedown Policy’ means our Copyright Infringement Notice and Takedown Policy located at https://circleci.com/legal/copyright-infringement-policy/ or any successor URL.
      ‘Disclosing Party’ means the party that provides Confidential Information to the other Party.
      ‘Documentation’ means any manuals, instructions or other documents or materials that we make available to you in any form or medium, that describe the functionality, components, features or requirements of the Services or CircleCI Content, including the Specifications and any aspect of the installation, configuration, integration, operation, use, support or maintenance thereof, excluding any marketing or other publicly available materials.
      ‘Equipment’ means any and all hardware, servers, software, operating systems, networking, web servers, internet and telecommunications service(s) and ancillary services needed to connect to, access or otherwise use the Services.
      ‘Fees’ means the amount we charge you for the Services and Support, the payment terms of which are outlined on an Order. Fees are payable in US Dollars via ACH or credit card.
      ‘Feedback’ means any suggestion, idea, improvement, enhancement request, recommendation, correction or other feedback voluntarily provided by you or any User to us relating to the operation of the Services. We may, without restriction and in our sole discretion, utilize Feedback to design, debug, display, perform, copy, make, have made, use, sell, and otherwise dispose of in any manner that we may choose without remuneration or accreditation to you. Feedback does not include your Confidential Information, software code or trade secrets.
      ‘Intellectual Property Rights’ means legal rights to intangible creations owned or licensed by a party under any copyright, patent, trademark, trade secret and other intellectual property laws worldwide.
      ‘Non-CircleCI Applications’ means any internet-based or offline software application, such as a version control system, that is provided by you or a third party and interoperates with the Services.
      ‘Order’ means an order form or other ordering document, including any exhibits and Supplemental Terms as applicable, provided by us and entered into between the Parties and/or their respective Affiliate(s). An Order may be provided electronically or on your account page on our website, specifying the chosen Services and Support, and associated Fees and payment terms. For avoidance of doubt, if you use a purchase order system, the terms of the Order and Agreement take precedence over any conflicting terms of your purchase order.
      ‘Personal Data’ means information that, alone or in combination with other information, could be used to identify a User.
      ‘Privacy Laws’ means all laws and regulations regarding data privacy and transmission of Personal Data that apply to our provision of the Services to you (e.g., storing and processing Your Data), including, without limitation, Articles 25(1) and 26(1) of EU Directive 95/46/EC of 24 October 1995, General Data Protection Regulation 2016/679 (GDPR) and California Consumers Privacy Act of 2018 (CCPA), as amended by the California Privacy Rights Act of 2020 (CPRA).
      ‘Privacy Policy’ means our Privacy Policy located at https://circleci.com/legal/privacy/ or any successor URL.
      ‘Receiving Party’ means the Party that receives Confidential Information from the other Party.
      ‘Resource Class Page’ means the publicly available web page where we publish Credit expenditure schedules for the Services, currently available at https://circleci.com/pricing/price-list/ or any successor URL.
      ‘Self-Hosted Applications’ means optional hybrid applications that provide additional functionality and are downloaded, installed and used on servers in your environment, but interact with our Services through an internet connection.
      ‘Services’ means our continuous integration/continuous deployment software-as-a-service offering, Self-Hosted Applications, and any other software, including downloadable software, and related technologies that may be made available by us to interoperate with the foregoing.
      ‘Specifications’ means the description of, minimum standards required, and the mode, means and mechanisms of action or functionality for the Services set forth in the Documentation.
      ‘Supplemental Terms’ means additional terms that apply to certain Services, including any product-specific terms that may be agreed by the Parties.
      ‘Support’ means free or paid ticket-based help with the Services.
      ‘Taxes’ means all applicable federal, state and local taxes, fees, charges, or other similar exactions, including, without limitation, sales and use taxes, excise taxes, VAT, GST, and other license or business and occupations taxes. Taxes do not include any Taxes that are imposed on or measured by our net income, property tax, or payroll taxes.
      ‘Term’ means the period during which you have agreed to subscribe to the Services.
      ‘Third-Party Content’ means information and data obtained by CircleCI from publicly available sources or our third-party content providers and made available to you and its Users through the Services, Evaluations or pursuant to an Order.
      ‘Updates’ means upgrades, new features, bug fixes, patches, and/or other error corrections to the software that CircleCI makes from time to time in its sole discretion. Updates are subject to the terms of this Agreement upon release.
      ‘Usage Data’ means metrics and data relating to a User’s access to the Services, which may include configuration files, build logs, error logs and other similar materials. Usage Data, when combined with other data, is an original CircleCI compilation pursuant to the copyright laws of the United States and other jurisdictions, of which we have dedicated substantial resources to collecting, managing, and compiling. Except as described herein, Usage Data does not include your Confidential Information, software code or trade secrets.
      ‘User’ means an individual who is authorized by you to use the Services. Users may include, for example, your and your Affiliate’s employees, consultants, contractors, representatives and/or agents.
      ‘Your Data’ means any data, software code, your Confidential Information, or other information received by the Services from you, your Users or third parties, in the course of access to the Services, excluding CircleCI Content, Usage Data, Third-Party Content and Non-CircleCI Applications.
    
  
  
    Your Acceptance of the Terms of this Agreement and any Changes to It
    By entering into an Order or otherwise downloading, accessing or using the Services, you unconditionally accept and agree to all of the terms of this Agreement. This Agreement shall apply to all usage by you and each of your User(s) of the Services. We may modify this Agreement at any time by posting a revised version at https://circleci.com/legal/terms-of-service/, and the revised version will become effective on the day it is published; provided, however, that if an Order specifies a fixed term of twelve (12) months or longer, the modifications will instead be effective immediately upon the start of the next renewal Term, if applicable. In either case, if any change to this Agreement is not acceptable to you, as your sole and exclusive remedy, you may choose not to renew, including canceling the auto-renewal of any Terms, in accordance with the terms set forth in Section 9. For the avoidance of doubt, any Order is subject to the version of the Agreement in effect at the time of the Order.
  
  
    Agreement Structure and Order of Precedence
    If there are any conflicts between this Agreement and any Order, the Order takes precedence and prevails over this Agreement, solely with respect to the subject matter of the applicable Order.
  
  
    Free Evaluations
    From time to time, we may invite you to try certain features or products at no charge for a limited evaluation period, which may be designated or identified as beta, pilot, evaluation, trial or the like (collectively, ‘Evaluation(s)’). Your agreement to participate in an Evaluation is completely voluntary, and if you initially opt into an Evaluation, you may opt out at any time in writing. If you opt out of an Evaluation that you had originally opted in, your access to such Evaluation will be terminated. Notwithstanding anything to the contrary contained in this Agreement, Evaluations are licensed for your internal evaluation purposes only, and not for production use. Unless otherwise stated in an Order, an Evaluation is limited to thirty (30) days. Notwithstanding the foregoing, we may discontinue any Evaluation program in whole or in part at any time in our sole discretion and we reserve the right to decide whether to make features provided in an Evaluation generally available. DUE TO THE NATURE OF EVALUATIONS AND THEIR VOLUNTARY PARTICIPATION, EVALUATIONS ARE EXCLUDED FROM OUR REMEDIES UNDER SECTIONS 10, 11 AND 12, UNLESS SUCH EXCLUSION IS NOT ENFORCEABLE UNDER APPLICABLE LAW. IF LIABILITY EXCLUSION IS NOT ENFORCABLE UNDER APPLICABLE LAW, OUR LIABILITY ARISING UNDER CLAIMS OF INTELLECTUAL PROPERTY INFRINGEMENT, BREACH OF WARRANTY, NEGLIGENCE, STRICT LIABILITY OR ANY OTHER THEORY OF LIABILITY WITH RESPECT TO THE EVALUATION SHALL NOT EXCEED ONE HUNDRED DOLLARS ($100.00).
  
  
    Ownership
    
      
        As to CircleCI
        We and our licensors own and retain all right, title and interest in and to the Services, CircleCI Content, Usage Data and Feedback and all associated Intellectual Property Rights therein. Except as provided in Section 6(a) below, we grant no further rights to you or your Users under this Agreement.
      
      
        As to Your Data
        You own and retain all right, title and interest in and to Your Data and all associated Intellectual Property Rights therein. Subject to the limited licenses granted herein, we acquire no right, title or interest from you or your licensors under this Agreement in or to Your Data.
      
    
  
  
    License Grants; Obligations; Restrictions; Consequences
    
      
        License Grants
        
          Subject to the terms of this Agreement, each Order and Your payment of all Fees, we grant you and your Users a worldwide, non-exclusive, non-sublicensable, non-transferable right to access (and where applicable, download and install) the Services during the applicable Term.
          You grant us, our Affiliates and licensors a worldwide, non-exclusive, royalty-free, fully paid, sublicensable, non-transferable [except as specified in Section 15(b)], license to receive, host, store, analyze, process, enhance, copy, transmit, create derivative works of, maintain and display Your Data that you, or your User(s) post(s) to the Services (either directly or via a Non-CircleCI Application) solely to administer and provide the Services in accordance with this Agreement.
          If you use a Non-CircleCI Application with the Services, you grant us a license to provide the Non-CircleCI Application and our provider with access to Your Data and information about your and your Users’ usage of the Services, as appropriate, for the interoperation of that Non-CircleCI Application with the Services.
        
      
      
        Obligations
        You shall use the Services only for lawful purposes in accordance with this Agreement as expressly licensed herein, including, without limitation, with your obligations set forth in this Section 6, the Documentation, and applicable laws and government regulations. You shall (i) be responsible for your Users’ compliance with this Agreement; (ii) be responsible for the quality and legality of Your Data and the means by which you acquired Your Data; (iii) use commercially reasonable efforts to prevent unauthorized access to the Services, and notify us promptly of any such unauthorized access to which you become aware; (iv) provide all necessary disclosures to your Users and obtain all necessary consents from such Users, in each case to the extent necessary to share such Users’ Personal Data with us and our Affiliates, licensors and service providers to use such Personal Data to provide the Services; (v) comply with the terms of service of the Non-CircleCI Applications that you use with the Services; and (vi) comply with the terms of our AUP. You shall promptly notify us of any suspected or alleged violation of this Agreement and shall cooperate with us with respect to: (1) our investigation of any suspected or alleged violation of this Agreement and (2) any action taken by CircleCI to enforce this Agreement. If we send you a notice that any Third-Party Content or a Non-CircleCI Application must be modified, disabled and/or removed from the Services to avoid violating applicable law, third-party rights, or the terms of this Agreement, you shall promptly do so. You shall confirm such modification, disablement or removal of such Third-Party Content or Non-CircleCI Application in writing upon our request, and you hereby authorize us to provide a copy of such confirmation to any such third-party claimant or governmental authority, as applicable. You and your Users are responsible for maintaining the security of your accounts, usernames and passwords and files, and for all uses of your and your User’s account. We shall not be liable for any loss or damage from your or any of your User’s failure to comply with this security obligation.
      
      
        Restrictions
        This Agreement does not grant you any right to reproduce, modify, distribute, or publicly display or perform the software included in the Services. You must not violate the Prohibited Uses section of our AUP.
      
      
        Consequences
        We may, in our sole discretion, suspend or terminate your or any of your User’s access to the Services this Agreement and any active Orders with or without advance written notice to you if we reasonably determine that you or your User has violated this Section 6. We may remove Your Data from the Services (or disable access to it) in accordance with our Copyright Infringement Notice and Takedown Policy. If you do not remove Third-Party Content or a Non-CircleCI Application upon notice from us, or if, in our judgment, continued violation is likely to reoccur, we may disable or remove the Third-Party Content and/or the Non-CircleCI Application from the Services. You will be liable for any violation of this Agreement by any of your Users. If we terminate this Agreement or an active Order in accordance with this Section, we shall do so in accordance with Section 9(b)(ii) below.
      
    
  
  
    Services and Support
    
      
        Creation of CircleCI Account
        As part of the registration process for the Services, you will create a CircleCI account by either providing your or your User’s email address and a password or by authorizing the CircleCI application through a Non-CircleCI Application (e.g., GitHub via Oauth). Account information must be accurate, current, and complete, and is governed by our Privacy Policy. You and your Users are each responsible for maintaining the confidentiality of, and activities that occur under, their respective account(s), and for any activities performed under such account(s). We reserve the right to access your and your Users’ accounts in order to respond to your or your Users’ requests for technical support. We retain the right, but not the obligation, to monitor the Services and Your Data.
      
      
        Provision of Services and Support
        We shall make the Services available to you and your Users pursuant to this Agreement and the applicable Order. We will provide Support in accordance with the level chosen on any Order. Support names and associated features are included on each Order. We will use commercially reasonable efforts to make the Services available 24 hours per day, 7 days per week, except for: (i) planned downtime, of which we will typically provide at least forty-eight (48) hours’ electronic notice and schedule, to the extent practicable, during the weekend hours between 6:00 p.m. Friday and 3:00 a.m. Monday, Pacific time, and (ii) any unavailability caused by unscheduled emergency maintenance either by us or our third-party vendors or hosting providers, or (iii) a Force Majeure event, the failure or delay of an internet service provider or Non-CircleCI Application, or any denial of service attack, for which we may or may not provide notice.
      
      
        Changes to Services and Support
        You may request Services and/or Support Plan upgrades at any time. Upon receipt of such request, we will promptly make the upgrade and bill you for such upgrade, prorated for the remaining Term of your current billing cycle. We do not provide mid-term Support Plan downgrades or refunds for Credits. You may downgrade your Support Plan upon the commencement of the first renewal Term after notice of such downgrade. You acknowledge that Support Plan upgrades provide additional features and decreased response times, while Support Plan downgrades remove features and increase response times. From time to time, we may introduce new Services, or update or sunset current Services, including but not limited to business model, plan level and/or features, Credit use executor type and resource class offerings and/or Support Plans. You will be migrated to the then-current business model, plan level and/or features, Support Plan and/or features upon release of the same, or when applicable, upon renewal.
      
      
        Non-CircleCI Applications
        You and your Users may enable or log in to our Services through a Non-CircleCI Application. You and your Users may download, authenticate, register for, and/or log into the Non-CircleCI Application on such application’s website. The Non-CircleCI Application provides us with certain information that you and your Users have provided to such Non-CircleCI Application, and we will use, store and disclose such information in accordance with our Privacy Policy. The way that Non-CircleCI Applications use, store and disclose your and your Users’ information is governed solely by the policies of the third parties that operate the Non-CircleCI Application, and we shall have no liability or responsibility for the privacy practices or other actions of any third-party site, application or service that may be enabled within the Services. In addition, we are not responsible for the accuracy, availability or reliability of any information, content, goods, data, opinions, advice or statements made available in connection with any Non-CircleCI Application, and as such, we shall not be liable for any damage or loss caused or alleged to be caused by or in connection with use or reliance thereon. We enable access to Non-CircleCI Applications merely as a convenience, and the integration or inclusion of such does not imply an endorsement or recommendation by CircleCI.
      
      
        Software Updates
        
          We continuously update our cloud-based software. You access the newest software version each time you log into the Services.
          We may develop and release Updates to Self-Hosted Applications (‘SHA Updates’). We will post notices of SHA Updates on the Self-Hosted Application change log, and, if you have not agreed to automatic updates, you agree to download and install such SHA Updates promptly. You acknowledge that, once a SHA Update has been provided, older versions of Self-Hosted Applications or portions thereof may no longer operate properly. We shall have no liability for inoperability due to your delay in installing SHA Updates.
        
      
      
        Equipment
        You are responsible for obtaining and maintaining any Equipment you need to use the Services and for ensuring that such Equipment is compatible with the Services  and complies with all configurations and Specifications set forth in the Documentation. We shall have no liability to you for any damage caused to your servers resulting from your access to the Services. You are responsible for maintaining the security of the Equipment and for all uses of the Equipment.
      
      
        Future Functionality
        You agree that your purchases are not contingent on the delivery of any future functionality or features, or dependent on any oral or written public comments made by us regarding any future functionality or features.
      
    
  
  
    Fees and Payment
    
      
        Fees
        You shall pay us the Fees set forth in each Order, under the terms set forth therein and this Agreement. Fees are charged in advance through the purchase of Credits and a Support Plan, except for Fees for overages, which are charged in arrears. Unless otherwise stated in an Order, (i) Fees for renewal Terms are subject to the then-current pricing, and (ii) you are responsible for, and will pay all Taxes imposed on or with respect to the Services that are the subject of this Agreement. If you are tax-exempt, you will supply official exemption documentation to us.
      
      
        Payments
        Payment terms are described in each Order. Notwithstanding, all amounts paid or payable are non-refundable, non-cancelable and non-creditable. If any amount owing by you under this Agreement for the Services is ten (10) or more days overdue, we may, in our sole discretion and without limiting any other rights and remedies, limit or suspend your access to the Services and Support until such amounts are paid in full, or we may, in our sole discretion, terminate the account in accordance with Section 9(b) below. If we suspend, limit, or terminate the Services under this Section 8(b), we will have no liability for any resulting damage, liabilities, losses (including any loss of data or profits) or any other consequences that you may experience. Additionally, any payments more than ten (10) days overdue shall bear a late payment fee of one and one-half percent (1.5%) per month, or if the maximum rate allowed by law is less, the maximum rate allowable by law.
      
    
  
  
    Term and Termination
    
      
        Term of Agreement and Orders
        This Agreement will begin on the Effective Date and continue in effect until terminated. Each Party may terminate this Agreement with thirty (30) days’ advance written notice if all Terms of Orders for the Service have expired or are terminated in accordance with Section 9(b). The Term of each Order will be set forth therein, starting on the Effective Date of the Order and continuing for the time period specified.
      
      
        Termination; Effect of Expiration or Termination; Survival
        
          Either Party may terminate any Order in accordance with its terms. Either Party may terminate any Order for cause upon written notice if the other Party fails to cure any material breach thereof within thirty (30) days after receiving a reasonably detailed written notice from the other Party alleging the breach. We may terminate any Order for cause upon written notice (1) within ten (10) days in the case of non-payment; and (2) immediately in the case of your or any of your User’s breach of Section 6(c). Upon any termination of this Agreement due to our uncured material breach of this Agreement, we will provide a refund to you for any prepaid and unused fees paid under this Agreement on a prorated basis. Termination is not an exclusive remedy, and all other remedies shall be available regardless of whether termination occurs.
          Regardless of the basis for expiration or termination of this Agreement, upon expiration or termination of an Order or this Agreement, we (1) will terminate your access to the Services, Support and CircleCI Content; and (2) shall not be obligated to retain any your Data for longer than thirty (30) days after any such expiration or termination. Thereafter, we may in our sole discretion, delete Your Data from the Services, which is unrecoverable. You shall destroy all copies of all CircleCI Content and all portions thereof in your possession and certify such destruction to us if we request such certification.
          All provisions of this Agreement which by their nature should survive expiration or termination, including without limitation, Sections 3 (Agreement Structure and Order of Precedence), 5 (Ownership), 9 (Term and Termination), 10 (Indemnification), 11 (Warranties and Disclaimer), 12 (Limitation of Liability), 13 (Confidentiality), 14 (Privacy, Security and Continuity), and 15 (Miscellaneous) shall survive any expiration or termination of this Agreement. The applicable Orders may identify additional terms that shall survive any expiration or termination of this Agreement.
        
      
    
  
  
    Indemnification
    
      You shall defend, indemnify and hold harmless us and our Affiliates, and each of their respective officers, directors, employees and agents (the ‘CircleCI Indemnitees’) from all damages, settlements, attorneys’ fees and expenses related to any third-party claim, suit or demand from (i) an allegation that the Your Data infringes or misappropriates such third party’s Intellectual Property Rights or violates applicable law or (ii) your or your employees’ or agents’ gross negligence, willful misconduct or fraud.
      The applicable CircleCI Indemnitee will promptly notify you upon becoming aware of any and all threats, claims and proceedings related thereto, and such CircleCI Indemnitee will reasonably cooperate with you to resolve the applicable claim (at your cost). Each applicable CircleCI Indemnitee reserves the right to assume the exclusive defense and control of any matter that is subject to indemnification under this Section 10. In such case, you agree to cooperate with any reasonable requests in assisting each applicable CircleCI Indemnitee’s defense of such matter. You shall not agree to, nor will we be responsible for, any settlement, judgment or other agreement which admits fault or incurs liability of us without our prior written approval, which approval will not be unreasonably withheld, conditioned, or delayed.
    
  
  
    Warranties and Disclaimer
    
      
        Warranties
        During the Term, we warrant, for your benefit only, that (i) we have the full right and legal authority to grant licenses provided herein and bind ourselves to the terms of this Agreement; and (ii) the Services shall be provided in a professional and workmanlike manner. You represent and warrant that you: (x) have the full legal authority to bind yourself to the terms of this Agreement; and (y) own or license rights to any Equipment on which Self-Hosted Applications is installed, and you are solely responsible for the configuration, security, and maintenance of such Equipment.
      
      
        Disclaimer
        EXCEPT AS PROVIDED HEREIN, THE SERVICES, EVALUATIONS, AND ALL SERVER AND NETWORK COMPONENTS ARE PROVIDED ON AN ‘AS IS’ AND ‘AS AVAILABLE’ BASIS WITHOUT ANY WARRANTIES OF ANY KIND, AND WE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, ALL IMPLIED WARRANTIES OF MERCHANTABILITY, TITLE, FITNESS FOR A PARTICULAR PURPOSE, AND NONINFRINGEMENT.
      
    
  
  
    Limitation of Liability
    UNDER NO CIRCUMSTANCES AND UNDER NO LEGAL THEORY (WHETHER IN CONTRACT, TORT OR OTHERWISE) SHALL WE OR OUR AFFILIATES, OFFICERS, DIRECTORS, EMPLOYEES, AGENTS, SERVICE PROVIDERS, SUPPLIERS OR LICENSORS BE LIABLE TO YOU, ANY USER OR ANY THIRD-PARTY FOR ANY (i) INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, CONSEQUENTIAL OR PUNITIVE DAMAGES, INCLUDING LOST PROFITS, LOST SALES OR BUSINESS, LOST DATA, GOODWILL, OR OTHER INTANGIBLE LOSSES; OR (ii) COST OF PROCUREMENT OF SUBSTITUTE PRODUCTS OR SERVICES IN CONNECTION WITH THIS AGREEMENT OR THE SERVICES, REGARDLESS OF WHETHER WE HAVE BEEN ADVISED OF THE POSSIBILITY OF OR COULD HAVE FORESEEN SUCH DAMAGES. NOTWITHSTANDING ANYTHING TO THE CONTRARY IN THIS AGREEMENT, OUR AGGREGATE LIABILITY TO YOU, YOUR AFFILIATES, OR ANY THIRD PARTY ARISING OUT OF OR RELATING TO THIS AGREEMENT OR THE SERVICES, SHALL IN NO EVENT EXCEED THE GREATER OF THE FEES ACTUALLY PAID BY YOU IN THE SIX (6) MONTHS PRECEDING THE EVENT GIVING RISE TO YOUR OR YOUR USER’S CLAIM OR ONE HUNDRED DOLLARS (US$100.00). YOU ACKNOWLEDGE AND AGREE THAT THE ESSENTIAL PURPOSE OF THIS SECTION 12 IS TO ALLOCATE THE RISK UNDER THIS AGREEMENT BETWEEN THE PARTIES, AND THE PARTIES HAVE RELIED ON THESE LIMITATIONS IN DETERMINING WHETHER TO ENTER INTO THIS AGREEMENT. SOME JURISDICTIONS DO NOT ALLOW THE EXCLUSION OF IMPLIED WARRANTEES OR LIMITATION OF LIABILITY FOR INCIDENTAL OR CONSEQUENTIAL DAMAGES, WHICH MEANS THAT SOME OF THE ABOVE LIMITATIONS MAY NOT APPLY TO YOU OR SOME USERS. IN SUCH JURISDICTIONS, OUR LIABILITY SHALL BE LIMITED TO THE GREATEST EXTENT PERMITTED BY LAW.
  
  
    Confidentiality
    All Confidential Information shall be held in confidence and will not be disclosed or used except to the extent necessary to carry out the Receiving Party’s obligations or express rights hereunder, except as otherwise authorized by the Disclosing Party in writing. The Receiving Party will use the same degree of care that it uses to protect the confidentiality of its own Confidential Information of like kind (but not less than reasonable care). These obligations shall not apply to information that (i) was previously known by the Receiving Party, as demonstrated by documents or files in existence at the time of disclosure; (ii) is generally and freely publicly available through no fault of the Receiving Party; (iii) the Receiving Party otherwise rightfully obtains from third parties without restriction; or (iv) is independently developed by the Receiving Party without reference to or reliance on the Disclosing Party’s Confidential Information, as demonstrated by documents or files in existence at the time of disclosure. The Receiving Party may disclose Confidential Information of the Disclosing Party to the extent compelled to do so by law, provided the Receiving Party gives the Disclosing Party prior notice of the compelled disclosure (to the extent legally permitted) and reasonable assistance, at the Disclosing Party’s cost, if the Disclosing Party wishes to contest the disclosure. If the Receiving Party is compelled by law to disclose the Disclosing Party’s Confidential Information as part of a civil proceeding to which the Disclosing Party is a party, and the Disclosing Party is not contesting the disclosure, the Disclosing Party will reimburse the Receiving Party for its reasonable cost of compiling and providing secure access to that Confidential Information. In the event that such protective order or other remedy is not obtained, the Receiving Party will furnish only that portion of the Confidential Information that is legally required and use commercially reasonable efforts to obtain assurance that confidential treatment will be accorded the Confidential Information.
  
  
    Privacy, Security and Continuity
    
      
        Privacy
        We will use Your Data only as permitted by Privacy Laws, our Privacy Policy and this Agreement. Our Privacy Policy states how it will collect, store, use and disclose Your Data including Personal Data. If you do not agree with our Privacy Policy, then you must stop using the Services immediately. We encourage you to periodically review our Privacy Policy, as it may change from time to time. Each Party shall comply with its own obligations under the applicable Privacy Laws. In this regard, you are solely responsible for providing any notices required by applicable Privacy Laws to, and receiving any consents and authorizations required by applicable Privacy Laws from, persons whose Personal Data may be included in Your Data. If you believe that the Your Data may include the Personal Data of natural persons located in the European Economic Area or United Kingdom and wish to execute a Data Processing Addendum (‘DPA’) pursuant to the GDPR, you may request, review and execute the DPA located at: https://circleci.com/legal/data-privacy/ or any successor URL.
      
      
        California Privacy Law
        For clarity under this Section 14(b), the terms ‘business’, ‘business purpose’, ‘commercial purpose’, ‘consumer’, ‘personal information’, ‘sensitive personal information’, ‘sell’, ‘share’ and ‘service provider’ have the meanings set forth in the California Privacy Law. The Parties agree that we are acting as a service provider in connection with this Agreement with respect to the California User Data, and that we receive the California User Data from you pursuant to a business purpose. You represent and warrant to us that you (i) are acting as a business in connection with this Agreement with respect to the California User Data, and (ii) are sharing and making available to us the California User Data pursuant to a business purpose and in accordance with the California Privacy Law. The Parties agree to comply with their own applicable obligations under, and provide the same level of privacy protection to, California User Data as required by the California Privacy Law.

        
          
            Our Obligations
            We agree not to (1) sell or share California User Data or (2) retain, use or disclose California User Data (x) for any purpose other than for the specific purpose of performing the Services or for a commercial purpose other than providing the Services, or (y) outside of the direct business relationship between us and you, including by not combining any California User Data with other personal information collected or received from another source except as otherwise permitted under the California Privacy Law.
          
          
            Your Obligations and Rights
            You agree that (1) you will only disclose California User Data to us for the limited purpose of using the Services in accordance with the Agreement, and (2) you represent that the California User Data does not contain sensitive personal information. If we engage in an unauthorized use of California User Data, you may, upon reasonable notice to us, take reasonable and appropriate steps to stop and remediate the unauthorized use of the California User Data.
          
        
      
      
        Security of the Services; Protection of Your Data
        We shall maintain reasonable administrative, physical, and technical safeguards for protection of the security, confidentiality and integrity of Your Data. Those safeguards will include, but will not be limited to, measures designed to prevent unauthorized access to or disclosure of Your Data (other than by you or your Users). We shall not be responsible or liable for any deletion, correction, damage, destruction or loss of Your Data that does not arise from a breach of its obligations under this Section 14(c).
      
      
        Data Transmission and Encryption
        Your Data is encrypted at rest and in transit as it traverses private networks and the internet. While we maintain a Data Backup Policy that requires restoration capabilities within common industry timelines, you bear sole responsibility for adequate backup of Your Data. Except for unauthorized access due to our negligence, we shall have no liability to you for any third-party unauthorized access to any of Your Data, or any corruption, deletion, destruction or loss of any Your Data.
      
      
        Business Continuity & Disaster Recovery
        Throughout the Term, we shall implement and maintain commercially reasonable business continuity and disaster recovery plans to help ensure availability of the Your Data following any significant interruption or failure of critical business processes or systems affecting the Services.
      
    
  
  
    Miscellaneous
    
      
        Governing Law; Venue; Attorney’s Fees
        This Agreement is governed by and construed pursuant to California law and controlling United States federal law, without regard to the conflicts of law provisions of any jurisdiction. The Parties (i) hereby generally, irrevocably and unconditionally submit to the exclusive jurisdiction of the federal and state courts in San Francisco County, California for the purpose of any suit, action or other proceeding arising out of or based upon this Agreement; (ii) agree not to commence any suit, action or other proceeding arising out of or based upon this Agreement except in such state and such courts; and (iii) hereby waive, and agree not to assert, by way of motion, as a defense, or otherwise, in any such suit, action or proceeding, any claim that it is not subject personally to the jurisdiction of the above-named courts, that its property is exempt or immune from attachment or execution, that the suit, action or proceeding is brought in an inconvenient forum, that the venue of the suit, action or proceeding is improper or that this Agreement or the subject matter hereof may not be enforced in or by such court. This choice of jurisdiction does not prevent either Party from seeking injunctive relief in any appropriate jurisdiction with respect to a violation of Intellectual Property Rights. The Services are a service, not goods, and are not subject to the Uniform Commercial Code, or the United Nations Convention on the International Sale of Goods. If any action is necessary to enforce the terms of this Agreement, the prevailing Party shall be entitled to reasonable attorneys’ fees, costs and expenses, in addition to any other relief that such prevailing Party may be entitled.
      
      
        Assignment
        Neither Party may assign or otherwise transfer (by operation of law or otherwise) this Agreement, or any of a Party’s rights or obligations under this Agreement, to any third party without the other Party’s prior written consent, which consent must not be unreasonably withheld, delayed or conditioned. Notwithstanding, either Party may assign or otherwise transfer this Agreement, including all associated Orders (and all its rights and obligations thereunder) to a successor-in-interest in connection with a merger, acquisition, reorganization, a sale of all or substantially all of its assets, or other change of control, or to any of its Affiliates. In the event of such a permitted transfer by you, the rights granted under this Agreement will continue to be subject to the same usage limitations that applied under any applicable Order prior to the transfer. Any purported assignment or other transfer in violation of this Section 15(b) is void. Subject to the terms of this Section 15(b), this Agreement will bind and inure to the benefit of the Parties and their respective permitted successors and transferees. There are no third-party beneficiaries under this Agreement.
      
      
        Force Majeure
        Except for the payment obligations hereunder, if either Party is prevented from performing, or is unable to perform, any of its obligations under this Agreement due to any cause beyond its reasonable control, including, but not limited to, war, riots, labor unrest, fire, earthquake, flood, hurricane, other natural disasters and acts of God, internet service failures or delays, and denial of service attacks (collectively, ‘Force Majeure’), the affected Party’s performance will be excused for the resulting period of delay or inability to perform. The affected Party must (i) give the other Party prompt written notice of the nature and expected duration of such Force Majeure, (ii) use commercially reasonable efforts to mitigate the period of delay or inability to perform, (c) periodically notify the other Party of significant changes in the status of the Force Majeure, and (d) notify the other Party promptly when the Force Majeure ends.
      
      
        Independent Contractors
        The Parties are independent contracting parties. Neither Party has, or shall hold itself out as having, any right or authority to incur any obligation on behalf of the other Party. The Parties’ relationship in connection with this Agreement is not construed a joint venture, partnership, franchise, employment, fiduciary, or agency relationship between the Parties, or as imposing any liability upon either Party that otherwise might result from such a relationship. Each Party will be solely responsible for payment of all compensation owed to its employees, as well as all employment and income-related taxes.
      
      
        Licensing the Services Through a Reseller or Marketplace
        Notwithstanding anything to the contrary in this Agreement, if you purchase a license to the Services through an authorized partner, reseller or marketplace (‘Third-Party Seller’):
        
          You agree to be bound by the terms of this Agreement.
          We will invoice Third-Party Seller, not you. You will pay the applicable amounts to the Third-Party Seller, as agreed between you and the Third-Party Seller, and Third-Party Seller will pay us. We may suspend or terminate your rights to use the Services if we do not receive the corresponding payment from the Third-Party Seller.
          Your Order details (e.g., the Services that Third-Party Seller is purchasing on behalf of You, the Term, etc.) will be as stated in the Order that the Third-Party Seller places with us on your behalf, and the Third-Party Seller is responsible for the accuracy of any such Order as communicated to us. We will only provision the Services for you after we receive and accept the Order from the Third-Party Seller.
          If you are entitled to a refund from a Third-Party Seller, the Third-Party Seller is solely responsible for providing such refund to you. We disclaim liability for any refunds owed to you from a Third-Party Seller.
          Third-Party Sellers are not authorized to modify this Agreement or make any promises or commitments on our behalf, and we are not bound by any obligations to you other than as set forth in this Agreement, unless agreed in writing by us and provided to you.
        
      
      
        Notices
        Billing-related notices to you will be emailed to your accounts payable contact designated by you and to us at this address. We will provide platform-related notices to you by email and/or the platform. Email notices shall be deemed to have been given on the day the email is sent. Notices for material breach or an indemnifiable claim must be in writing and shall be deemed to have been given upon personal delivery or delivery confirmation by nationally or internationally recognized overnight delivery service. We will provide written notice to you at the address you provide on your Order. You will send written notices to Circle Internet Services, Inc., dba, CircleCI at 2261 Market Street, #22561, San Francisco, CA, 94114 USA, Attn: Chief Legal Officer, with a courtesy copy emailed here. Either Party may provide a subsequent email or physical notice address in writing to the other Party in the manner provided herein.
      
      
        Anti-Corruption
        Each party shall comply with applicable laws concerning anti-bribery and anti-corruption, which includes the United States Foreign Corrupt Practices Act of 1977 as may be amended. As of the date of this Agreement and the date of each Order, you represent that you have not received or been offered any illegal or otherwise improper bribe, kickback, payment, gift or other thing of value from any employees, representatives or agents of us or our Affiliates in connection with this Agreement. You shall use reasonable efforts to promptly notify us if you become aware of any circumstances that are contrary to the foregoing representation.
      
      
        Government Users
        If you are a U.S. Government Agency, or this Agreement otherwise becomes subject to the Federal Acquisition Regulations (FAR) and any applicable Agency-specific FAR Supplements, you acknowledge that the Services constitute ‘commercial computer software’ and ‘commercial computer software documentation’ as such terms are used in FAR 12.212, DFARS 252.227-7014 and DFARS 227.7202. In accordance with FAR 12.211-12.212 and DFARS 227.7102-4 and 227.7202-4, as applicable, the rights of the U.S. Government to use, modify, reproduce, release, perform, display, or disclose commercial computer software, commercial computer software documentation, and technical data furnished in connection with the Services shall be as provided in this Agreement, except that, for U.S. Department of Defense Customer, technical data customarily provided to the public is being furnished in accordance with DFARS 252.227-7015. The commercial computer software and commercial computer software documentation are being licensed to U.S. Government end users (a) only as Commercial Items and (b) with only such rights as are granted to all other end-users pursuant to the terms herein. Any provisions of this Agreement inconsistent with federal procurement regulations or other federal law are not enforceable against the U.S. Government. If a U.S. Government Agency needs additional rights, it must negotiate a mutually acceptable written specially negotiated license to be incorporated as an addendum to this Agreement that will specifically grant those rights.
      
      
        Publicity
        Unless otherwise specified in the applicable Order, we may use your name, logo and marks to identify you as a customer of ours on our website and other marketing materials.
      
      
        Execution
        This Agreement and any Order may be signed electronically and in counterparts, in which case each signed copy will be deemed an original as though both signatures appeared on the same document.
      
      
        Severability
        If any provision of this Agreement or any Order is adjudged by any court of competent jurisdiction unenforceable or invalid, that provision will be limited or eliminated to the minimum extent necessary so that this Agreement and any applicable Order will otherwise remain in full force and effect and enforceable.
      
      
        Waiver
        A Party’s failure or delay in exercising any right hereunder does not operate as a waiver thereof, nor will any partial exercise of any right or power hereunder preclude further exercise.
      
      
        Entire Agreement
        This Agreement, together with all applicable Orders (including any other terms referenced in any of those documents), comprises the entire agreement between the Parties regarding the subject matter of this Agreement, and supersedes all prior or contemporaneous negotiations, discussions or agreements, whether written or oral, between the Parties regarding such subject matter. This Agreement may only be modified by written, mutual agreement of the Parties.
      
    
  


To view the prior version of these terms, please click here.\n\nLegal
  







  
    
      
        
        
        
          
          
            
              
                Software as a Service Agreement
              
            
            
              
              


  Definitions Used in this Agreement
  Your Acceptance of the Terms of this Agreement and any Changes to It
  Agreement Structure and Order of Precedence
  Free Evaluations
  Ownership
  License Grants; Obligations; Restrictions; Consequences
  Services and Support
  Fees and Payment
  Term and Termination
  Indemnification
  Warranties and Disclaimer
  Limitation of Liability
  Confidentiality
  Privacy, Security and Continuity
  Miscellaneous




            
          
        
          
          
            
              
                Software License Agreement
              
            
            
          
        
          
          
            
              
                AI Functionality Terms
              
            
            
          
        
          
          
            
              
                Code Sharing Terms of Service
              
            
            
          
        
          
          
            
              
                Self-Hosted Applications Terms
              
            
            
          
        
          
          
            
              
                Acceptable Use Policy
              
            
            
          
        
          
          
            
              
                Cookie Policy
              
            
            
          
        
          
          
            
              
                Privacy Policy
              
            
            
          
        
          
          
            
              
                CircleCI’s Commitment to Data Privacy
              
            
            
          
        
          
          
            
              
                 Trademark Usage Guidelines
              
            
            
          
        
          
          
            
              
                Copyright Infringement Notice and Takedown Policy
              
            
            
          
        
          
          
            
              
                Website Terms of Use
              
            
            
          
        
      
    
  
  
    
      
        Software as a Service Agreement
      
      
          Last Updated:
          
            December 20, 2023
          
      
      
        
Thank you for your interest in using our services!

This online Software as a Service Agreement (‘Agreement’), which incorporates our AUP, Copyright Infringement Notice and Takedown Policy, Privacy Policy and Supplemental Terms as applicable, is incorporated by reference into each Order that you may enter into with Circle Internet Services, Inc., dba, CircleCI, a Delaware corporation (‘we,’ ‘CircleCI,’ ‘our,’ ‘us’). ‘You’ means your employer or the entity you represent, its Affiliates and Users, or, if that does not apply, it means you as an individual. Each of you and us is a ‘Party,’ and collectively, you and we are the ‘Parties.’ Capitalized terms not defined herein shall have the meaning set forth in the applicable Order.

You must be at least eighteen (18) years old to use the Services.

When you click ‘I Agree/I Accept/Sign Up/Pay Now’ (or similar button or checkbox) when registering for the Services, you are accepting this Agreement on behalf of your employer, another entity, or yourself, as applicable, and represent and warrant that: (i) you have full legal authority to bind your employer, such other entity, or yourself, as applicable, to the terms of this Agreement; (ii) you have read and understand the terms of this Agreement; and (iii) you agree to the terms of this Agreement on behalf of your employer, an entity that you represent, or yourself, as applicable.

PLEASE NOTE THAT IF YOU REGISTER FOR THE SERVICES USING AN EMAIL ADDRESS FROM YOUR EMPLOYER OR ANOTHER ENTITY, THEN (A) YOU SHALL BE DEEMED TO REPRESENT SUCH PARTY, AND (B) YOUR CLICK TO ‘AGREE/ACCEPT/SIGN UP/PAY NOW’ (OR SIMILAR BUTTON OR CHECKBOX) WILL BIND YOUR EMPLOYER OR THE OTHER ENTITY TO THIS AGREEMENT.

This Agreement is effective as of the earliest of (i) the date you first complete registration for the Services by clicking ‘I Agree/I Accept/Sign Up/Pay Now’ (or similar button or checkbox), (ii) access the Services, or (iii) the effective date set forth on the initial Order (the ‘Effective Date’). For Evaluations, you also indicate your acceptance of the terms of this Agreement by your accessing or using the applicable Evaluation(s). This Agreement does not have to be signed in order to be binding.

Your right to access the Services, whether or not an Order has been signed between you and us, is expressly conditioned on your acceptance of this Agreement.

If you do not agree with the terms of this Agreement, or you don’t have the legal authority to bind your employer or another entity, do not click ‘I Agree/I Accept/Sign Up/Pay Now’ (or similar button or checkbox) when presented to you. In this case, you may not use the Services.

  
    Definitions Used in this Agreement
    
      ‘Affiliate’ means a company, corporation or other legal entity that directly or indirectly controls, is controlled by, or is under common control with a Party to this Agreement. For purposes of this definition, ‘control’ means direct or indirect ownership or control of more than fifty percent (50%) of the voting interests of the subject entity. When your Affiliate enters into an Order hereunder, it agrees to be bound by the terms of this Agreement as if it were you.
      ‘Agreement’ means collectively, this Software as a Service Agreement, along with our AUP, Copyright Infringement Notice and Takedown Policy, Privacy Policy and Supplemental Terms as applicable.
      ‘AUP’ means our standard Acceptable Use Policy, currently available at https://circleci.com/legal/acceptable-use/ or any successor URL.
      ‘California Privacy Law’ means the California Consumer Privacy Act of 2018 (CCPA) and any regulations promulgated thereunder, as amended by the California Privacy Rights Act of 2020 (CPRA).
      ‘California User Data’ means the personal information of consumers in California provided or made available by you to CircleCI.
      ‘CircleCI Content’ means source code, configurations, data, Documentation, reports, text, images, sounds, video, and content we make available to you under this Agreement.
      ‘Confidential Information’ means any technical, financial, business or other information provided by one Party to the other Party (including the terms of this Agreement), either designated as confidential or proprietary, or reasonably should be understood to be confidential given the nature of the information and the circumstances of disclosure.
      ‘Copyright Infringement Notice and Takedown Policy’ means our Copyright Infringement Notice and Takedown Policy located at https://circleci.com/legal/copyright-infringement-policy/ or any successor URL.
      ‘Disclosing Party’ means the party that provides Confidential Information to the other Party.
      ‘Documentation’ means any manuals, instructions or other documents or materials that we make available to you in any form or medium, that describe the functionality, components, features or requirements of the Services or CircleCI Content, including the Specifications and any aspect of the installation, configuration, integration, operation, use, support or maintenance thereof, excluding any marketing or other publicly available materials.
      ‘Equipment’ means any and all hardware, servers, software, operating systems, networking, web servers, internet and telecommunications service(s) and ancillary services needed to connect to, access or otherwise use the Services.
      ‘Fees’ means the amount we charge you for the Services and Support, the payment terms of which are outlined on an Order. Fees are payable in US Dollars via ACH or credit card.
      ‘Feedback’ means any suggestion, idea, improvement, enhancement request, recommendation, correction or other feedback voluntarily provided by you or any User to us relating to the operation of the Services. We may, without restriction and in our sole discretion, utilize Feedback to design, debug, display, perform, copy, make, have made, use, sell, and otherwise dispose of in any manner that we may choose without remuneration or accreditation to you. Feedback does not include your Confidential Information, software code or trade secrets.
      ‘Intellectual Property Rights’ means legal rights to intangible creations owned or licensed by a party under any copyright, patent, trademark, trade secret and other intellectual property laws worldwide.
      ‘Non-CircleCI Applications’ means any internet-based or offline software application, such as a version control system, that is provided by you or a third party and interoperates with the Services.
      ‘Order’ means an order form or other ordering document, including any exhibits and Supplemental Terms as applicable, provided by us and entered into between the Parties and/or their respective Affiliate(s). An Order may be provided electronically or on your account page on our website, specifying the chosen Services and Support, and associated Fees and payment terms. For avoidance of doubt, if you use a purchase order system, the terms of the Order and Agreement take precedence over any conflicting terms of your purchase order.
      ‘Personal Data’ means information that, alone or in combination with other information, could be used to identify a User.
      ‘Privacy Laws’ means all laws and regulations regarding data privacy and transmission of Personal Data that apply to our provision of the Services to you (e.g., storing and processing Your Data), including, without limitation, Articles 25(1) and 26(1) of EU Directive 95/46/EC of 24 October 1995, General Data Protection Regulation 2016/679 (GDPR) and California Consumers Privacy Act of 2018 (CCPA), as amended by the California Privacy Rights Act of 2020 (CPRA).
      ‘Privacy Policy’ means our Privacy Policy located at https://circleci.com/legal/privacy/ or any successor URL.
      ‘Receiving Party’ means the Party that receives Confidential Information from the other Party.
      ‘Resource Class Page’ means the publicly available web page where we publish Credit expenditure schedules for the Services, currently available at https://circleci.com/pricing/price-list/ or any successor URL.
      ‘Self-Hosted Applications’ means optional hybrid applications that provide additional functionality and are downloaded, installed and used on servers in your environment, but interact with our Services through an internet connection.
      ‘Services’ means our continuous integration/continuous deployment software-as-a-service offering, Self-Hosted Applications, and any other software, including downloadable software, and related technologies that may be made available by us to interoperate with the foregoing.
      ‘Specifications’ means the description of, minimum standards required, and the mode, means and mechanisms of action or functionality for the Services set forth in the Documentation.
      ‘Supplemental Terms’ means additional terms that apply to certain Services, including any product-specific terms that may be agreed by the Parties.
      ‘Support’ means free or paid ticket-based help with the Services.
      ‘Taxes’ means all applicable federal, state and local taxes, fees, charges, or other similar exactions, including, without limitation, sales and use taxes, excise taxes, VAT, GST, and other license or business and occupations taxes. Taxes do not include any Taxes that are imposed on or measured by our net income, property tax, or payroll taxes.
      ‘Term’ means the period during which you have agreed to subscribe to the Services.
      ‘Third-Party Content’ means information and data obtained by CircleCI from publicly available sources or our third-party content providers and made available to you and its Users through the Services, Evaluations or pursuant to an Order.
      ‘Updates’ means upgrades, new features, bug fixes, patches, and/or other error corrections to the software that CircleCI makes from time to time in its sole discretion. Updates are subject to the terms of this Agreement upon release.
      ‘Usage Data’ means metrics and data relating to a User’s access to the Services, which may include configuration files, build logs, error logs and other similar materials. Usage Data, when combined with other data, is an original CircleCI compilation pursuant to the copyright laws of the United States and other jurisdictions, of which we have dedicated substantial resources to collecting, managing, and compiling. Except as described herein, Usage Data does not include your Confidential Information, software code or trade secrets.
      ‘User’ means an individual who is authorized by you to use the Services. Users may include, for example, your and your Affiliate’s employees, consultants, contractors, representatives and/or agents.
      ‘Your Data’ means any data, software code, your Confidential Information, or other information received by the Services from you, your Users or third parties, in the course of access to the Services, excluding CircleCI Content, Usage Data, Third-Party Content and Non-CircleCI Applications.
    
  
  
    Your Acceptance of the Terms of this Agreement and any Changes to It
    By entering into an Order or otherwise downloading, accessing or using the Services, you unconditionally accept and agree to all of the terms of this Agreement. This Agreement shall apply to all usage by you and each of your User(s) of the Services. We may modify this Agreement at any time by posting a revised version at https://circleci.com/legal/terms-of-service/, and the revised version will become effective on the day it is published; provided, however, that if an Order specifies a fixed term of twelve (12) months or longer, the modifications will instead be effective immediately upon the start of the next renewal Term, if applicable. In either case, if any change to this Agreement is not acceptable to you, as your sole and exclusive remedy, you may choose not to renew, including canceling the auto-renewal of any Terms, in accordance with the terms set forth in Section 9. For the avoidance of doubt, any Order is subject to the version of the Agreement in effect at the time of the Order.
  
  
    Agreement Structure and Order of Precedence
    If there are any conflicts between this Agreement and any Order, the Order takes precedence and prevails over this Agreement, solely with respect to the subject matter of the applicable Order.
  
  
    Free Evaluations
    From time to time, we may invite you to try certain features or products at no charge for a limited evaluation period, which may be designated or identified as beta, pilot, evaluation, trial or the like (collectively, ‘Evaluation(s)’). Your agreement to participate in an Evaluation is completely voluntary, and if you initially opt into an Evaluation, you may opt out at any time in writing. If you opt out of an Evaluation that you had originally opted in, your access to such Evaluation will be terminated. Notwithstanding anything to the contrary contained in this Agreement, Evaluations are licensed for your internal evaluation purposes only, and not for production use. Unless otherwise stated in an Order, an Evaluation is limited to thirty (30) days. Notwithstanding the foregoing, we may discontinue any Evaluation program in whole or in part at any time in our sole discretion and we reserve the right to decide whether to make features provided in an Evaluation generally available. DUE TO THE NATURE OF EVALUATIONS AND THEIR VOLUNTARY PARTICIPATION, EVALUATIONS ARE EXCLUDED FROM OUR REMEDIES UNDER SECTIONS 10, 11 AND 12, UNLESS SUCH EXCLUSION IS NOT ENFORCEABLE UNDER APPLICABLE LAW. IF LIABILITY EXCLUSION IS NOT ENFORCABLE UNDER APPLICABLE LAW, OUR LIABILITY ARISING UNDER CLAIMS OF INTELLECTUAL PROPERTY INFRINGEMENT, BREACH OF WARRANTY, NEGLIGENCE, STRICT LIABILITY OR ANY OTHER THEORY OF LIABILITY WITH RESPECT TO THE EVALUATION SHALL NOT EXCEED ONE HUNDRED DOLLARS ($100.00).
  
  
    Ownership
    
      
        As to CircleCI
        We and our licensors own and retain all right, title and interest in and to the Services, CircleCI Content, Usage Data and Feedback and all associated Intellectual Property Rights therein. Except as provided in Section 6(a) below, we grant no further rights to you or your Users under this Agreement.
      
      
        As to Your Data
        You own and retain all right, title and interest in and to Your Data and all associated Intellectual Property Rights therein. Subject to the limited licenses granted herein, we acquire no right, title or interest from you or your licensors under this Agreement in or to Your Data.
      
    
  
  
    License Grants; Obligations; Restrictions; Consequences
    
      
        License Grants
        
          Subject to the terms of this Agreement, each Order and Your payment of all Fees, we grant you and your Users a worldwide, non-exclusive, non-sublicensable, non-transferable right to access (and where applicable, download and install) the Services during the applicable Term.
          You grant us, our Affiliates and licensors a worldwide, non-exclusive, royalty-free, fully paid, sublicensable, non-transferable [except as specified in Section 15(b)], license to receive, host, store, analyze, process, enhance, copy, transmit, create derivative works of, maintain and display Your Data that you, or your User(s) post(s) to the Services (either directly or via a Non-CircleCI Application) solely to administer and provide the Services in accordance with this Agreement.
          If you use a Non-CircleCI Application with the Services, you grant us a license to provide the Non-CircleCI Application and our provider with access to Your Data and information about your and your Users’ usage of the Services, as appropriate, for the interoperation of that Non-CircleCI Application with the Services.
        
      
      
        Obligations
        You shall use the Services only for lawful purposes in accordance with this Agreement as expressly licensed herein, including, without limitation, with your obligations set forth in this Section 6, the Documentation, and applicable laws and government regulations. You shall (i) be responsible for your Users’ compliance with this Agreement; (ii) be responsible for the quality and legality of Your Data and the means by which you acquired Your Data; (iii) use commercially reasonable efforts to prevent unauthorized access to the Services, and notify us promptly of any such unauthorized access to which you become aware; (iv) provide all necessary disclosures to your Users and obtain all necessary consents from such Users, in each case to the extent necessary to share such Users’ Personal Data with us and our Affiliates, licensors and service providers to use such Personal Data to provide the Services; (v) comply with the terms of service of the Non-CircleCI Applications that you use with the Services; and (vi) comply with the terms of our AUP. You shall promptly notify us of any suspected or alleged violation of this Agreement and shall cooperate with us with respect to: (1) our investigation of any suspected or alleged violation of this Agreement and (2) any action taken by CircleCI to enforce this Agreement. If we send you a notice that any Third-Party Content or a Non-CircleCI Application must be modified, disabled and/or removed from the Services to avoid violating applicable law, third-party rights, or the terms of this Agreement, you shall promptly do so. You shall confirm such modification, disablement or removal of such Third-Party Content or Non-CircleCI Application in writing upon our request, and you hereby authorize us to provide a copy of such confirmation to any such third-party claimant or governmental authority, as applicable. You and your Users are responsible for maintaining the security of your accounts, usernames and passwords and files, and for all uses of your and your User’s account. We shall not be liable for any loss or damage from your or any of your User’s failure to comply with this security obligation.
      
      
        Restrictions
        This Agreement does not grant you any right to reproduce, modify, distribute, or publicly display or perform the software included in the Services. You must not violate the Prohibited Uses section of our AUP.
      
      
        Consequences
        We may, in our sole discretion, suspend or terminate your or any of your User’s access to the Services this Agreement and any active Orders with or without advance written notice to you if we reasonably determine that you or your User has violated this Section 6. We may remove Your Data from the Services (or disable access to it) in accordance with our Copyright Infringement Notice and Takedown Policy. If you do not remove Third-Party Content or a Non-CircleCI Application upon notice from us, or if, in our judgment, continued violation is likely to reoccur, we may disable or remove the Third-Party Content and/or the Non-CircleCI Application from the Services. You will be liable for any violation of this Agreement by any of your Users. If we terminate this Agreement or an active Order in accordance with this Section, we shall do so in accordance with Section 9(b)(ii) below.
      
    
  
  
    Services and Support
    
      
        Creation of CircleCI Account
        As part of the registration process for the Services, you will create a CircleCI account by either providing your or your User’s email address and a password or by authorizing the CircleCI application through a Non-CircleCI Application (e.g., GitHub via Oauth). Account information must be accurate, current, and complete, and is governed by our Privacy Policy. You and your Users are each responsible for maintaining the confidentiality of, and activities that occur under, their respective account(s), and for any activities performed under such account(s). We reserve the right to access your and your Users’ accounts in order to respond to your or your Users’ requests for technical support. We retain the right, but not the obligation, to monitor the Services and Your Data.
      
      
        Provision of Services and Support
        We shall make the Services available to you and your Users pursuant to this Agreement and the applicable Order. We will provide Support in accordance with the level chosen on any Order. Support names and associated features are included on each Order. We will use commercially reasonable efforts to make the Services available 24 hours per day, 7 days per week, except for: (i) planned downtime, of which we will typically provide at least forty-eight (48) hours’ electronic notice and schedule, to the extent practicable, during the weekend hours between 6:00 p.m. Friday and 3:00 a.m. Monday, Pacific time, and (ii) any unavailability caused by unscheduled emergency maintenance either by us or our third-party vendors or hosting providers, or (iii) a Force Majeure event, the failure or delay of an internet service provider or Non-CircleCI Application, or any denial of service attack, for which we may or may not provide notice.
      
      
        Changes to Services and Support
        You may request Services and/or Support Plan upgrades at any time. Upon receipt of such request, we will promptly make the upgrade and bill you for such upgrade, prorated for the remaining Term of your current billing cycle. We do not provide mid-term Support Plan downgrades or refunds for Credits. You may downgrade your Support Plan upon the commencement of the first renewal Term after notice of such downgrade. You acknowledge that Support Plan upgrades provide additional features and decreased response times, while Support Plan downgrades remove features and increase response times. From time to time, we may introduce new Services, or update or sunset current Services, including but not limited to business model, plan level and/or features, Credit use executor type and resource class offerings and/or Support Plans. You will be migrated to the then-current business model, plan level and/or features, Support Plan and/or features upon release of the same, or when applicable, upon renewal.
      
      
        Non-CircleCI Applications
        You and your Users may enable or log in to our Services through a Non-CircleCI Application. You and your Users may download, authenticate, register for, and/or log into the Non-CircleCI Application on such application’s website. The Non-CircleCI Application provides us with certain information that you and your Users have provided to such Non-CircleCI Application, and we will use, store and disclose such information in accordance with our Privacy Policy. The way that Non-CircleCI Applications use, store and disclose your and your Users’ information is governed solely by the policies of the third parties that operate the Non-CircleCI Application, and we shall have no liability or responsibility for the privacy practices or other actions of any third-party site, application or service that may be enabled within the Services. In addition, we are not responsible for the accuracy, availability or reliability of any information, content, goods, data, opinions, advice or statements made available in connection with any Non-CircleCI Application, and as such, we shall not be liable for any damage or loss caused or alleged to be caused by or in connection with use or reliance thereon. We enable access to Non-CircleCI Applications merely as a convenience, and the integration or inclusion of such does not imply an endorsement or recommendation by CircleCI.
      
      
        Software Updates
        
          We continuously update our cloud-based software. You access the newest software version each time you log into the Services.
          We may develop and release Updates to Self-Hosted Applications (‘SHA Updates’). We will post notices of SHA Updates on the Self-Hosted Application change log, and, if you have not agreed to automatic updates, you agree to download and install such SHA Updates promptly. You acknowledge that, once a SHA Update has been provided, older versions of Self-Hosted Applications or portions thereof may no longer operate properly. We shall have no liability for inoperability due to your delay in installing SHA Updates.
        
      
      
        Equipment
        You are responsible for obtaining and maintaining any Equipment you need to use the Services and for ensuring that such Equipment is compatible with the Services  and complies with all configurations and Specifications set forth in the Documentation. We shall have no liability to you for any damage caused to your servers resulting from your access to the Services. You are responsible for maintaining the security of the Equipment and for all uses of the Equipment.
      
      
        Future Functionality
        You agree that your purchases are not contingent on the delivery of any future functionality or features, or dependent on any oral or written public comments made by us regarding any future functionality or features.
      
    
  
  
    Fees and Payment
    
      
        Fees
        You shall pay us the Fees set forth in each Order, under the terms set forth therein and this Agreement. Fees are charged in advance through the purchase of Credits and a Support Plan, except for Fees for overages, which are charged in arrears. Unless otherwise stated in an Order, (i) Fees for renewal Terms are subject to the then-current pricing, and (ii) you are responsible for, and will pay all Taxes imposed on or with respect to the Services that are the subject of this Agreement. If you are tax-exempt, you will supply official exemption documentation to us.
      
      
        Payments
        Payment terms are described in each Order. Notwithstanding, all amounts paid or payable are non-refundable, non-cancelable and non-creditable. If any amount owing by you under this Agreement for the Services is ten (10) or more days overdue, we may, in our sole discretion and without limiting any other rights and remedies, limit or suspend your access to the Services and Support until such amounts are paid in full, or we may, in our sole discretion, terminate the account in accordance with Section 9(b) below. If we suspend, limit, or terminate the Services under this Section 8(b), we will have no liability for any resulting damage, liabilities, losses (including any loss of data or profits) or any other consequences that you may experience. Additionally, any payments more than ten (10) days overdue shall bear a late payment fee of one and one-half percent (1.5%) per month, or if the maximum rate allowed by law is less, the maximum rate allowable by law.
      
    
  
  
    Term and Termination
    
      
        Term of Agreement and Orders
        This Agreement will begin on the Effective Date and continue in effect until terminated. Each Party may terminate this Agreement with thirty (30) days’ advance written notice if all Terms of Orders for the Service have expired or are terminated in accordance with Section 9(b). The Term of each Order will be set forth therein, starting on the Effective Date of the Order and continuing for the time period specified.
      
      
        Termination; Effect of Expiration or Termination; Survival
        
          Either Party may terminate any Order in accordance with its terms. Either Party may terminate any Order for cause upon written notice if the other Party fails to cure any material breach thereof within thirty (30) days after receiving a reasonably detailed written notice from the other Party alleging the breach. We may terminate any Order for cause upon written notice (1) within ten (10) days in the case of non-payment; and (2) immediately in the case of your or any of your User’s breach of Section 6(c). Upon any termination of this Agreement due to our uncured material breach of this Agreement, we will provide a refund to you for any prepaid and unused fees paid under this Agreement on a prorated basis. Termination is not an exclusive remedy, and all other remedies shall be available regardless of whether termination occurs.
          Regardless of the basis for expiration or termination of this Agreement, upon expiration or termination of an Order or this Agreement, we (1) will terminate your access to the Services, Support and CircleCI Content; and (2) shall not be obligated to retain any your Data for longer than thirty (30) days after any such expiration or termination. Thereafter, we may in our sole discretion, delete Your Data from the Services, which is unrecoverable. You shall destroy all copies of all CircleCI Content and all portions thereof in your possession and certify such destruction to us if we request such certification.
          All provisions of this Agreement which by their nature should survive expiration or termination, including without limitation, Sections 3 (Agreement Structure and Order of Precedence), 5 (Ownership), 9 (Term and Termination), 10 (Indemnification), 11 (Warranties and Disclaimer), 12 (Limitation of Liability), 13 (Confidentiality), 14 (Privacy, Security and Continuity), and 15 (Miscellaneous) shall survive any expiration or termination of this Agreement. The applicable Orders may identify additional terms that shall survive any expiration or termination of this Agreement.
        
      
    
  
  
    Indemnification
    
      You shall defend, indemnify and hold harmless us and our Affiliates, and each of their respective officers, directors, employees and agents (the ‘CircleCI Indemnitees’) from all damages, settlements, attorneys’ fees and expenses related to any third-party claim, suit or demand from (i) an allegation that the Your Data infringes or misappropriates such third party’s Intellectual Property Rights or violates applicable law or (ii) your or your employees’ or agents’ gross negligence, willful misconduct or fraud.
      The applicable CircleCI Indemnitee will promptly notify you upon becoming aware of any and all threats, claims and proceedings related thereto, and such CircleCI Indemnitee will reasonably cooperate with you to resolve the applicable claim (at your cost). Each applicable CircleCI Indemnitee reserves the right to assume the exclusive defense and control of any matter that is subject to indemnification under this Section 10. In such case, you agree to cooperate with any reasonable requests in assisting each applicable CircleCI Indemnitee’s defense of such matter. You shall not agree to, nor will we be responsible for, any settlement, judgment or other agreement which admits fault or incurs liability of us without our prior written approval, which approval will not be unreasonably withheld, conditioned, or delayed.
    
  
  
    Warranties and Disclaimer
    
      
        Warranties
        During the Term, we warrant, for your benefit only, that (i) we have the full right and legal authority to grant licenses provided herein and bind ourselves to the terms of this Agreement; and (ii) the Services shall be provided in a professional and workmanlike manner. You represent and warrant that you: (x) have the full legal authority to bind yourself to the terms of this Agreement; and (y) own or license rights to any Equipment on which Self-Hosted Applications is installed, and you are solely responsible for the configuration, security, and maintenance of such Equipment.
      
      
        Disclaimer
        EXCEPT AS PROVIDED HEREIN, THE SERVICES, EVALUATIONS, AND ALL SERVER AND NETWORK COMPONENTS ARE PROVIDED ON AN ‘AS IS’ AND ‘AS AVAILABLE’ BASIS WITHOUT ANY WARRANTIES OF ANY KIND, AND WE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, ALL IMPLIED WARRANTIES OF MERCHANTABILITY, TITLE, FITNESS FOR A PARTICULAR PURPOSE, AND NONINFRINGEMENT.
      
    
  
  
    Limitation of Liability
    UNDER NO CIRCUMSTANCES AND UNDER NO LEGAL THEORY (WHETHER IN CONTRACT, TORT OR OTHERWISE) SHALL WE OR OUR AFFILIATES, OFFICERS, DIRECTORS, EMPLOYEES, AGENTS, SERVICE PROVIDERS, SUPPLIERS OR LICENSORS BE LIABLE TO YOU, ANY USER OR ANY THIRD-PARTY FOR ANY (i) INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, CONSEQUENTIAL OR PUNITIVE DAMAGES, INCLUDING LOST PROFITS, LOST SALES OR BUSINESS, LOST DATA, GOODWILL, OR OTHER INTANGIBLE LOSSES; OR (ii) COST OF PROCUREMENT OF SUBSTITUTE PRODUCTS OR SERVICES IN CONNECTION WITH THIS AGREEMENT OR THE SERVICES, REGARDLESS OF WHETHER WE HAVE BEEN ADVISED OF THE POSSIBILITY OF OR COULD HAVE FORESEEN SUCH DAMAGES. NOTWITHSTANDING ANYTHING TO THE CONTRARY IN THIS AGREEMENT, OUR AGGREGATE LIABILITY TO YOU, YOUR AFFILIATES, OR ANY THIRD PARTY ARISING OUT OF OR RELATING TO THIS AGREEMENT OR THE SERVICES, SHALL IN NO EVENT EXCEED THE GREATER OF THE FEES ACTUALLY PAID BY YOU IN THE SIX (6) MONTHS PRECEDING THE EVENT GIVING RISE TO YOUR OR YOUR USER’S CLAIM OR ONE HUNDRED DOLLARS (US$100.00). YOU ACKNOWLEDGE AND AGREE THAT THE ESSENTIAL PURPOSE OF THIS SECTION 12 IS TO ALLOCATE THE RISK UNDER THIS AGREEMENT BETWEEN THE PARTIES, AND THE PARTIES HAVE RELIED ON THESE LIMITATIONS IN DETERMINING WHETHER TO ENTER INTO THIS AGREEMENT. SOME JURISDICTIONS DO NOT ALLOW THE EXCLUSION OF IMPLIED WARRANTEES OR LIMITATION OF LIABILITY FOR INCIDENTAL OR CONSEQUENTIAL DAMAGES, WHICH MEANS THAT SOME OF THE ABOVE LIMITATIONS MAY NOT APPLY TO YOU OR SOME USERS. IN SUCH JURISDICTIONS, OUR LIABILITY SHALL BE LIMITED TO THE GREATEST EXTENT PERMITTED BY LAW.
  
  
    Confidentiality
    All Confidential Information shall be held in confidence and will not be disclosed or used except to the extent necessary to carry out the Receiving Party’s obligations or express rights hereunder, except as otherwise authorized by the Disclosing Party in writing. The Receiving Party will use the same degree of care that it uses to protect the confidentiality of its own Confidential Information of like kind (but not less than reasonable care). These obligations shall not apply to information that (i) was previously known by the Receiving Party, as demonstrated by documents or files in existence at the time of disclosure; (ii) is generally and freely publicly available through no fault of the Receiving Party; (iii) the Receiving Party otherwise rightfully obtains from third parties without restriction; or (iv) is independently developed by the Receiving Party without reference to or reliance on the Disclosing Party’s Confidential Information, as demonstrated by documents or files in existence at the time of disclosure. The Receiving Party may disclose Confidential Information of the Disclosing Party to the extent compelled to do so by law, provided the Receiving Party gives the Disclosing Party prior notice of the compelled disclosure (to the extent legally permitted) and reasonable assistance, at the Disclosing Party’s cost, if the Disclosing Party wishes to contest the disclosure. If the Receiving Party is compelled by law to disclose the Disclosing Party’s Confidential Information as part of a civil proceeding to which the Disclosing Party is a party, and the Disclosing Party is not contesting the disclosure, the Disclosing Party will reimburse the Receiving Party for its reasonable cost of compiling and providing secure access to that Confidential Information. In the event that such protective order or other remedy is not obtained, the Receiving Party will furnish only that portion of the Confidential Information that is legally required and use commercially reasonable efforts to obtain assurance that confidential treatment will be accorded the Confidential Information.
  
  
    Privacy, Security and Continuity
    
      
        Privacy
        We will use Your Data only as permitted by Privacy Laws, our Privacy Policy and this Agreement. Our Privacy Policy states how it will collect, store, use and disclose Your Data including Personal Data. If you do not agree with our Privacy Policy, then you must stop using the Services immediately. We encourage you to periodically review our Privacy Policy, as it may change from time to time. Each Party shall comply with its own obligations under the applicable Privacy Laws. In this regard, you are solely responsible for providing any notices required by applicable Privacy Laws to, and receiving any consents and authorizations required by applicable Privacy Laws from, persons whose Personal Data may be included in Your Data. If you believe that the Your Data may include the Personal Data of natural persons located in the European Economic Area or United Kingdom and wish to execute a Data Processing Addendum (‘DPA’) pursuant to the GDPR, you may request, review and execute the DPA located at: https://circleci.com/legal/data-privacy/ or any successor URL.
      
      
        California Privacy Law
        For clarity under this Section 14(b), the terms ‘business’, ‘business purpose’, ‘commercial purpose’, ‘consumer’, ‘personal information’, ‘sensitive personal information’, ‘sell’, ‘share’ and ‘service provider’ have the meanings set forth in the California Privacy Law. The Parties agree that we are acting as a service provider in connection with this Agreement with respect to the California User Data, and that we receive the California User Data from you pursuant to a business purpose. You represent and warrant to us that you (i) are acting as a business in connection with this Agreement with respect to the California User Data, and (ii) are sharing and making available to us the California User Data pursuant to a business purpose and in accordance with the California Privacy Law. The Parties agree to comply with their own applicable obligations under, and provide the same level of privacy protection to, California User Data as required by the California Privacy Law.

        
          
            Our Obligations
            We agree not to (1) sell or share California User Data or (2) retain, use or disclose California User Data (x) for any purpose other than for the specific purpose of performing the Services or for a commercial purpose other than providing the Services, or (y) outside of the direct business relationship between us and you, including by not combining any California User Data with other personal information collected or received from another source except as otherwise permitted under the California Privacy Law.
          
          
            Your Obligations and Rights
            You agree that (1) you will only disclose California User Data to us for the limited purpose of using the Services in accordance with the Agreement, and (2) you represent that the California User Data does not contain sensitive personal information. If we engage in an unauthorized use of California User Data, you may, upon reasonable notice to us, take reasonable and appropriate steps to stop and remediate the unauthorized use of the California User Data.
          
        
      
      
        Security of the Services; Protection of Your Data
        We shall maintain reasonable administrative, physical, and technical safeguards for protection of the security, confidentiality and integrity of Your Data. Those safeguards will include, but will not be limited to, measures designed to prevent unauthorized access to or disclosure of Your Data (other than by you or your Users). We shall not be responsible or liable for any deletion, correction, damage, destruction or loss of Your Data that does not arise from a breach of its obligations under this Section 14(c).
      
      
        Data Transmission and Encryption
        Your Data is encrypted at rest and in transit as it traverses private networks and the internet. While we maintain a Data Backup Policy that requires restoration capabilities within common industry timelines, you bear sole responsibility for adequate backup of Your Data. Except for unauthorized access due to our negligence, we shall have no liability to you for any third-party unauthorized access to any of Your Data, or any corruption, deletion, destruction or loss of any Your Data.
      
      
        Business Continuity & Disaster Recovery
        Throughout the Term, we shall implement and maintain commercially reasonable business continuity and disaster recovery plans to help ensure availability of the Your Data following any significant interruption or failure of critical business processes or systems affecting the Services.
      
    
  
  
    Miscellaneous
    
      
        Governing Law; Venue; Attorney’s Fees
        This Agreement is governed by and construed pursuant to California law and controlling United States federal law, without regard to the conflicts of law provisions of any jurisdiction. The Parties (i) hereby generally, irrevocably and unconditionally submit to the exclusive jurisdiction of the federal and state courts in San Francisco County, California for the purpose of any suit, action or other proceeding arising out of or based upon this Agreement; (ii) agree not to commence any suit, action or other proceeding arising out of or based upon this Agreement except in such state and such courts; and (iii) hereby waive, and agree not to assert, by way of motion, as a defense, or otherwise, in any such suit, action or proceeding, any claim that it is not subject personally to the jurisdiction of the above-named courts, that its property is exempt or immune from attachment or execution, that the suit, action or proceeding is brought in an inconvenient forum, that the venue of the suit, action or proceeding is improper or that this Agreement or the subject matter hereof may not be enforced in or by such court. This choice of jurisdiction does not prevent either Party from seeking injunctive relief in any appropriate jurisdiction with respect to a violation of Intellectual Property Rights. The Services are a service, not goods, and are not subject to the Uniform Commercial Code, or the United Nations Convention on the International Sale of Goods. If any action is necessary to enforce the terms of this Agreement, the prevailing Party shall be entitled to reasonable attorneys’ fees, costs and expenses, in addition to any other relief that such prevailing Party may be entitled.
      
      
        Assignment
        Neither Party may assign or otherwise transfer (by operation of law or otherwise) this Agreement, or any of a Party’s rights or obligations under this Agreement, to any third party without the other Party’s prior written consent, which consent must not be unreasonably withheld, delayed or conditioned. Notwithstanding, either Party may assign or otherwise transfer this Agreement, including all associated Orders (and all its rights and obligations thereunder) to a successor-in-interest in connection with a merger, acquisition, reorganization, a sale of all or substantially all of its assets, or other change of control, or to any of its Affiliates. In the event of such a permitted transfer by you, the rights granted under this Agreement will continue to be subject to the same usage limitations that applied under any applicable Order prior to the transfer. Any purported assignment or other transfer in violation of this Section 15(b) is void. Subject to the terms of this Section 15(b), this Agreement will bind and inure to the benefit of the Parties and their respective permitted successors and transferees. There are no third-party beneficiaries under this Agreement.
      
      
        Force Majeure
        Except for the payment obligations hereunder, if either Party is prevented from performing, or is unable to perform, any of its obligations under this Agreement due to any cause beyond its reasonable control, including, but not limited to, war, riots, labor unrest, fire, earthquake, flood, hurricane, other natural disasters and acts of God, internet service failures or delays, and denial of service attacks (collectively, ‘Force Majeure’), the affected Party’s performance will be excused for the resulting period of delay or inability to perform. The affected Party must (i) give the other Party prompt written notice of the nature and expected duration of such Force Majeure, (ii) use commercially reasonable efforts to mitigate the period of delay or inability to perform, (c) periodically notify the other Party of significant changes in the status of the Force Majeure, and (d) notify the other Party promptly when the Force Majeure ends.
      
      
        Independent Contractors
        The Parties are independent contracting parties. Neither Party has, or shall hold itself out as having, any right or authority to incur any obligation on behalf of the other Party. The Parties’ relationship in connection with this Agreement is not construed a joint venture, partnership, franchise, employment, fiduciary, or agency relationship between the Parties, or as imposing any liability upon either Party that otherwise might result from such a relationship. Each Party will be solely responsible for payment of all compensation owed to its employees, as well as all employment and income-related taxes.
      
      
        Licensing the Services Through a Reseller or Marketplace
        Notwithstanding anything to the contrary in this Agreement, if you purchase a license to the Services through an authorized partner, reseller or marketplace (‘Third-Party Seller’):
        
          You agree to be bound by the terms of this Agreement.
          We will invoice Third-Party Seller, not you. You will pay the applicable amounts to the Third-Party Seller, as agreed between you and the Third-Party Seller, and Third-Party Seller will pay us. We may suspend or terminate your rights to use the Services if we do not receive the corresponding payment from the Third-Party Seller.
          Your Order details (e.g., the Services that Third-Party Seller is purchasing on behalf of You, the Term, etc.) will be as stated in the Order that the Third-Party Seller places with us on your behalf, and the Third-Party Seller is responsible for the accuracy of any such Order as communicated to us. We will only provision the Services for you after we receive and accept the Order from the Third-Party Seller.
          If you are entitled to a refund from a Third-Party Seller, the Third-Party Seller is solely responsible for providing such refund to you. We disclaim liability for any refunds owed to you from a Third-Party Seller.
          Third-Party Sellers are not authorized to modify this Agreement or make any promises or commitments on our behalf, and we are not bound by any obligations to you other than as set forth in this Agreement, unless agreed in writing by us and provided to you.
        
      
      
        Notices
        Billing-related notices to you will be emailed to your accounts payable contact designated by you and to us at this address. We will provide platform-related notices to you by email and/or the platform. Email notices shall be deemed to have been given on the day the email is sent. Notices for material breach or an indemnifiable claim must be in writing and shall be deemed to have been given upon personal delivery or delivery confirmation by nationally or internationally recognized overnight delivery service. We will provide written notice to you at the address you provide on your Order. You will send written notices to Circle Internet Services, Inc., dba, CircleCI at 2261 Market Street, #22561, San Francisco, CA, 94114 USA, Attn: Chief Legal Officer, with a courtesy copy emailed here. Either Party may provide a subsequent email or physical notice address in writing to the other Party in the manner provided herein.
      
      
        Anti-Corruption
        Each party shall comply with applicable laws concerning anti-bribery and anti-corruption, which includes the United States Foreign Corrupt Practices Act of 1977 as may be amended. As of the date of this Agreement and the date of each Order, you represent that you have not received or been offered any illegal or otherwise improper bribe, kickback, payment, gift or other thing of value from any employees, representatives or agents of us or our Affiliates in connection with this Agreement. You shall use reasonable efforts to promptly notify us if you become aware of any circumstances that are contrary to the foregoing representation.
      
      
        Government Users
        If you are a U.S. Government Agency, or this Agreement otherwise becomes subject to the Federal Acquisition Regulations (FAR) and any applicable Agency-specific FAR Supplements, you acknowledge that the Services constitute ‘commercial computer software’ and ‘commercial computer software documentation’ as such terms are used in FAR 12.212, DFARS 252.227-7014 and DFARS 227.7202. In accordance with FAR 12.211-12.212 and DFARS 227.7102-4 and 227.7202-4, as applicable, the rights of the U.S. Government to use, modify, reproduce, release, perform, display, or disclose commercial computer software, commercial computer software documentation, and technical data furnished in connection with the Services shall be as provided in this Agreement, except that, for U.S. Department of Defense Customer, technical data customarily provided to the public is being furnished in accordance with DFARS 252.227-7015. The commercial computer software and commercial computer software documentation are being licensed to U.S. Government end users (a) only as Commercial Items and (b) with only such rights as are granted to all other end-users pursuant to the terms herein. Any provisions of this Agreement inconsistent with federal procurement regulations or other federal law are not enforceable against the U.S. Government. If a U.S. Government Agency needs additional rights, it must negotiate a mutually acceptable written specially negotiated license to be incorporated as an addendum to this Agreement that will specifically grant those rights.
      
      
        Publicity
        Unless otherwise specified in the applicable Order, we may use your name, logo and marks to identify you as a customer of ours on our website and other marketing materials.
      
      
        Execution
        This Agreement and any Order may be signed electronically and in counterparts, in which case each signed copy will be deemed an original as though both signatures appeared on the same document.
      
      
        Severability
        If any provision of this Agreement or any Order is adjudged by any court of competent jurisdiction unenforceable or invalid, that provision will be limited or eliminated to the minimum extent necessary so that this Agreement and any applicable Order will otherwise remain in full force and effect and enforceable.
      
      
        Waiver
        A Party’s failure or delay in exercising any right hereunder does not operate as a waiver thereof, nor will any partial exercise of any right or power hereunder preclude further exercise.
      
      
        Entire Agreement
        This Agreement, together with all applicable Orders (including any other terms referenced in any of those documents), comprises the entire agreement between the Parties regarding the subject matter of this Agreement, and supersedes all prior or contemporaneous negotiations, discussions or agreements, whether written or oral, between the Parties regarding such subject matter. This Agreement may only be modified by written, mutual agreement of the Parties.
      
    
  


To view the prior version of these terms, please click here.\n\n\n\nPrivacy Policy
      
      
          Last Updated:
          
            March 27, 2025
          
      
      
        
Circle Internet Services, Inc. dba CircleCI, a Delaware corporation (“CircleCI”, “we” or “us”) provides this Privacy Policy to inform users of our Services (as that term is defined in our Software as a Service Agreement) of our policies and procedures regarding the collection, use and disclosure of Personal Data and other information. This Privacy Policy explains what data we collect when you use the Services, why we collect the data, how it is used and your rights and choices. Capitalized terms used but not defined in this Privacy Policy will have the meanings assigned to them by the Software as a Service Agreement.

While providing our Services, we may collect information about our customers’ Users on behalf of our customers. Our use of information on behalf of our customers is governed by our agreement with the applicable customer and the customer’s own privacy policies. We cannot control and are not responsible for the privacy policies or privacy practices of our customers or any other third parties.

By using or accessing the Services and providing us with your Personal Data, you are accepting the practices described in this Privacy Policy, and you are consenting to our processing of your data as set forth in this Privacy Policy now and as amended by us (for information on how we may change our Privacy Policy, please read the “Privacy Policy Changes” section below). If you have any questions or comments about this Privacy Policy or our use of your Personal Data, please contact us.

Information We Collect And How We Use It
Collection of Information
We have collected the following categories of information from our users within the last twelve (12) months:


  Identifiers, including name, email address, phone number, IP address and cookie identifiers,
  Certain financial-related information, including credit card number and billing and shipping address,
  Protected classification information, such as age and gender,
  Commercial information, including purchasing history of our business customer’s employees and representatives who use our Service,
  Internet or other similar network activity, such as browsing history, information on your interaction with our Site, browser type, and referring site,
  Location data, and
  Professional or employment related data with respect to our job applicants and our business customer’s employees and representatives who use our Services, such as professional title.


Categories of Sources

We obtain the personal information of our users from the following categories of sources:


  
    Personal Data That You Provide To Us
    When you interact with the Services, CircleCI may gather information that, alone or in combination with other information, could be used to identify you (“Personal Data”), as described below. If you are an EU or UK data subject, please see the “EU and UK Data Subject” section below for information on your rights in relation to the Personal Data we hold about you.

    
      
        Personal Data used to provide the Service and respond to requests
        When signing up for the Services, users are required to either provide their email address and a password while creating an account with us, or authenticate with their version control system identity (GitHub, GitLab, or Bitbucket).  When users log in to the Services using sign-in services such as OAuth (for example, login with a GitHub account), these services will authenticate a user’s identity and provide the user with the option to share certain Personal Data, such as name and email address(es), with us.  If you purchase one of our paid plans, we will also collect payment and billing information such as credit card details and billing address.  We use this data to provide you with access to the Services, contact you regarding your access and use of the Services or to notify you of important changes to the Services. For EU and UK data subjects, such use is necessary for the performance of the contract between you and us.

        On some sections of the Site, you may complete a web form to give your Personal Data to us directly, such as on our “Contact Us” page. We also collect Personal Data (e.g., your name, email, and phone number) when you request information, including a product demo, ask to download content (such as white papers), register for a webinar or other event, or subscribe to email lists. We will use your contact information to respond to your request. For EU and UK data subjects, such use is necessary to respond to or implement your request. If you send us a request or question regarding the use of the Services (for example via a support email or via one of our feedback mechanisms), we may publish it (in anonymous form only) in order to help us clarify or respond to your request or to help us support other users.

        CircleCI collects Personal Data that you provide through the Services only insofar as is necessary or appropriate to fulfill the purpose of your interaction with CircleCI, such as providing you with the Services and/or answering any requests regarding the Service as described above. You can always refuse to supply Personal Data, however doing so may prevent you from accessing the Services or engaging in certain activities on the Services.
      
      
        Personal Data we receive from third party applications
        CircleCI may receive Personal Data about you from third parties.  For example, if you access the Services through a third-party service or interact with the Services via a third-party service connected to the Services (e.g., by pushing code to a VCS repository configured to interact with the Services), that third party may pass certain Personal Data you provided to its service to CircleCI.  This information could include, but is not limited to, the user ID associated with your account, your name and email address, any information that you have permitted the third party to share with CircleCI, and any information you have made public in connection with that service.  You should always review, and if necessary, adjust your privacy settings on third-party websites and services before linking or connecting them to the Services. Ultimately, the terms governing your use of a third-party service will control what Personal Data, if any, that third party shares with CircleCI.  If you communicate with CircleCI via social media, and choose to share your user generated content with CircleCI, CircleCI may receive information such as posts or videos you’ve created, your photo, your account name and your comments about CircleCI.
      
      
        Personal Data we receive from other third parties
        CircleCI may obtain information about you from third-party sources, such as public sources, social media platforms (like LinkedIn, Twitter and other platforms) and third-party data providers and information services.  Examples of the information we may obtain from such third parties include your company, company size, job title and seniority, industry and other profile information. We do this to better understand your profile and interests so that we can deliver customized offers and other personalized services to you, such as to serve relevant offers to you via email, chatbots, phone or personalized advertising. We may also receive information about you and your engagement with our advertisements from our ad servers, ad networks, social media platforms, and other sources. This may include the websites you visited before coming to CircleCI so that we can determine advertising effectiveness and pay our referral partners. If you prefer not to have your information used for this purpose, you can opt out at any time by emailing us.
      
      
        Personal Data used to process applications for employment
        When you submit a job application through the Site, we will collect your resume and any additional information that you elect to provide to us, including but not limited to employment history and education. We will use your contact details and data about your employment history and education to conduct job interviews, evaluate your application, and as is otherwise needed for recruitment. For EU and UK data subjects, this use is necessary to respond to your request to process your application for employment.
      
      
        Personal Data used for marketing
        We will use your email to tell you about your usage of the Services, new features, solicit your feedback, or just keep you up to date with what’s going on with CircleCI and our products, upcoming events or other promotions. If you change your mind about receiving information from us or about the use of information volunteered by you, please send us a request specifying your new choice. Please contact us as specified under the “Contact Us” section. You may also choose to opt out of receiving such emails by following the unsubscribe instructions included in these emails, or by accessing the email preferences in your account settings page. If you download content from the Site, we may also use your phone number to contact you directly by phone, in connection with such new products and services, upcoming events or other promotions.

        Where required by applicable law (for example, if you are an EU or UK data subject), we will only send you marketing information by email or mail, or contact you by phone, if you consent to us doing so. When you provide us with your consent to be contacted for marketing purposes, you have the right to withdraw your consent at any time by following the instructions to “opt out” of receiving marketing communication in each marketing email we send you. In addition, if at any time you do not wish to receive future marketing communications or wish to have your name deleted from our mailing or calling lists, please make the appropriate request at https://privacy.circleci.com/. Please note that if you opt out from marketing communications, we may still contact you regarding issues related to our Services and to respond to your requests.
      
    
  
  
    Automatically Collected Information
    Like most hosted service operators, CircleCI collects information of the sort that web browsers and servers typically make available, such as the browser type, language preference, referring site and the date and time of each visitor request and store it in log files. CircleCI also collects Internet Protocol (“IP”) addresses, which can be used to identify the location from which your computer is connecting to the Site, for providing the Services and for support purposes.

    CircleCI also collects statistics about the behavior of visitors to the Services through cookies and similar technologies. We also allow some others to use cookies as described in the “Cookies” section below. CircleCI’s purpose in collecting such information is to better understand how CircleCI’s visitors use the Services and to improve your access to and use of the Services.

    Use of such automatically collected information is necessary for the performance of the contract between you and us, to the extent we process information that is needed for providing the Services and for support purposes, or is in our legitimate interest in understanding how the Services are being used by you and enhancing your experience when using our Services.
  
  
    Information We Process On Behalf Of Our Customers
    In providing the Services to our customers, we process on behalf of customers certain information that may include Personal Data, relating to customers’ employees, contractors or other users (“Users”) they transmit or otherwise submit to our Service. While our customers or Users decide what data to submit, this information typically includes email address and information relating to tests results.

    CircleCI collects and stores metrics and data relating to, generated by, provided in connection with, or derived from customers’ use of the Services (“Usage Data”) in order to provide, maintain, support, enhance, develop and improve the Services and CircleCI’s service offerings. CircleCI will not disclose individual metric or usage data other than in an aggregated and de-identified form. For EU and UK data subjects, this use of your Personal Data is necessary for our legitimate interests in understanding how the Services are being used by you and to improve your experience on it.
  


Data Retention
We will retain Personal Data that our customers provide to us through the Services for the period necessary to fulfill the purposes outlined in this Privacy Policy unless a longer retention period is required or permitted by law. We will retain Personal Data that we process on behalf of our customers for the duration set forth in the applicable customer contract or as otherwise instructed by the customer.

Bulletin Boards/Chat Rooms
If you submit a post or participate in a discussion on a bulletin board or chat room on the Services, you should be aware that any Personal Data you submit there can be read, collected, or used by other users of these forums, and could be used to send you unsolicited messages. We are not responsible for the Personal Data you choose to submit in these forums.

Disclosure Of Personal Data
In the preceding twelve (12) months, we have disclosed the following categories of personal information for a business purpose:


  Identifiers,
  Certain financial-related information,
  Protected classification information,
  Commercial information,
  Internet or other similar network activity,
  Location data, and
  Professional or employment related data.


We share personal information for a business purpose with various categories of third parties. CircleCI discloses Personal Data only to those of its employees, contractors, and service providers that (1) need to know that data in order to perform certain services and functions on CircleCI’s behalf and (2) have agreed to data protection and confidentiality obligations requiring them to protect that data. Third-party service providers include: (i) providers of payment processing, customer support services and hosting (which support us in the provision and maintenance of the Services), (ii) web analytics service providers (which help us collect statistics and other information, including through cookies, about the behavior of users of the Services - for more details, please see the “Cookies” section below); (iii) marketing and sales automation tools that allow us to manage marketing and sales processes; (iv) phone and chat communication tools that allow us to communicate with prospects and customers; (v) integration tools that allow us to capture data in one platform and send it to another; (vi) survey and poll tools that allows us to capture information about our Services; and (vii) event and meeting platforms that allow us to host and manage virtual and in-person events. Pursuant to our instructions, these parties may access, process or store Personal Data in the course of performing their duties to us and only as necessary to provide the services we request.

CircleCI may also disclose Personal Data when required to do so by law, such as to comply with a subpoena, bankruptcy proceedings, or similar legal process, or in response to lawful requests by public authorities, including to meet national security or law enforcement requirements, or when CircleCI believes in good faith that disclosure is reasonably necessary to protect the property or rights of CircleCI, third parties, or the public at large.

CircleCI may disclose Personal Data in connection with a merger, acquisition, or sale of all or a portion of its assets (a “Corporate Transaction”). If CircleCI is involved in a Corporate Transaction, you will be notified either via email and/or a prominent notice through the Service of any change in ownership or uses of your Personal Data, as well as any choices you may have regarding your Personal Data, or we will require any such buyer to agree to treat your Personal Data in accordance with this Privacy Policy.

In the preceding twelve (12) months, we have not sold our users’ personal information.

Access and Deletion Requests
You may visit https://privacy.circleci.com/ to request that we provide you with a copy of your Personal Data or that we delete your Personal Data that we maintain on our systems. We will respond to your request within a reasonable timeframe. If you are an EU or UK data subject or California resident, see your additional rights below.

Rights of Certain California Residents
The California Consumer Privacy Act (CCPA) and California Privacy Rights Act (CPRA) provide certain California residents with the additional rights listed below.

Right to Access. You have the right to request that we disclose certain information to you about our collection and use of your personal information over the past 12 months. Once we receive and confirm your verifiable consumer request, we will disclose to you:


  The categories of personal information we collected about you,
  The categories of sources for the personal information we collected about you,
  Our business or commercial purpose for collecting that personal information,
  The categories of third parties with whom we share that personal information, and
  The specific pieces of personal information we collected about you (which will also allow you to exercise your data portability right).


Data Portability Right. You have the right to request that we provide you with access to the information above (under Right to Access) in a readily useable format that allows you to transmit (i.e., port) the information to another entity without hindrance. If you make a request under your right to request access, you will receive access to your information in a readily useable format.

Right to Delete. You have the right to request that we delete any of your personal information that we collected from you and retained, subject to certain exceptions. Once we receive and confirm your verifiable consumer request, we will delete (and direct our service providers to delete) your personal information from our records, unless an exception applies.  You must contact the applicable business customers directly to delete your information that they have in their systems.

We may deny your deletion request or not delete some of your personal information, if retaining the information is necessary for us or our service provider(s) to:


  Complete the transaction for which we collected the personal information, provide a good or service that you requested, take actions reasonably anticipated within the context of our ongoing business relationship with you, or otherwise perform our contract with you.
  Detect security incidents, protect against malicious, deceptive, fraudulent, or illegal activity, or prosecute those responsible for such activities.
  Debug products to identify and repair errors that impair existing intended functionality.
  Exercise free speech, ensure the right of another consumer to exercise their free speech rights, or exercise another right provided for by law.
  Comply with the California Electronic Communications Privacy Act (Cal. Penal Code § 1546 et. seq.).
  Engage in public or peer-reviewed scientific, historical, or statistical research in the public interest that adheres to all other applicable ethics and privacy laws, when the information’s deletion may likely render impossible or seriously impair the research’s achievement, if you previously provided informed consent.
  Enable solely internal uses that are reasonably aligned with consumer expectations based on your relationship with us.
  Comply with a legal obligation.
  Make other internal and lawful uses of that information that are compatible with the context in which you provided it.


We may also limit our deletion to the extent permitted by applicable law.

Right to Update. You have the right to request that inaccurate personal information that we hold about you be corrected.

Right to restrict the use and disclosure of your sensitive information. You have the right to request that we limit our use and disclosure of your sensitive personal information.  We currently do not request or retain any sensitive personal information from our customers.

Categories of Personal Data collected by CircleCI. For more details on how we use the Personal Data, who we disclose it to for a business purpose, and how long we keep it for, please see the sections “Categories of Sources”, “Disclosure of Personal Data”, and “Data Retention” set forth above.

Categories of Personal Data disclosed for a business purpose. You have the right to request that we limit our use and disclosure of your sensitive personal information.  We currently do not request or retain any sensitive personal information from our customers.

Exercising Your Rights. To exercise your rights, please contact us as follows:


  Submit your request by visiting our Privacy Center at https://privacy.circleci.com/ and selecting your specific request (e.g., right to access, right to correct, or right to delete); or
  Email us at privacy@circleci.com and provide the following information:
    
      Full name and email address associated with your use of our Services, and
      Your specific request (e.g., right to access, right to portability, right to update or right to delete).
    
  


We will attempt to respond to a consumer request for access or deletion within 45 days of receiving that request. If we require more time, we will inform you of the reason and extension period in writing.

Only you, or someone legally authorized to act on your behalf, may make a verifiable consumer request related to your personal information.

You may only make a verifiable consumer request for access or data portability twice within a 12-month period.

Non-Discrimination. We will not discriminate against you for exercising any of your rights under the CCPA or CPRA. Unless permitted by the CCPA or CPRA, we will not:


  Deny you goods or services,
  Charge you different prices or rates for goods or services, including through granting discounts or other benefits, or imposing penalties,
  Provide you a different level or quality of goods or services, or
  Suggest that you may receive a different price or rate for goods or services or a different level or quality of goods or services.


However, we may offer you certain financial incentives permitted by the CCPA and CPRA that can result in different prices, rates, or quality levels. Any CCPA or CPRA-permitted financial incentive we offer will reasonably relate to your personal information’s value to CircleCI and contain written terms that describe the program’s material aspects. Participation in a financial incentive program requires your prior opt in consent, which you may revoke at any time. We currently do not provide any financial incentives.

No Sale or Sharing of Personal Information. We do not sell or share (for the purpose of cross-context behavioral advertising) your personal information, as those terms are defined under the CCPA/CPRA.

EU and UK Data Subjects
Scope: This section applies if you are an EU or UK data subject (for these purposes, reference to the EU also includes the European Economic Area countries of Iceland, Liechtenstein, Norway and, where applicable, Switzerland).

Data Controller: CircleCI is the data controller of Personal Data provided to, or collected by or for, our Services, but we may act as data processor on behalf of our customers for Personal Data that we process on their behalf when providing the Services.

Your Rights: Subject to applicable law, you have the following rights in relation to your Personal Data:


  Right of access: If you ask us, we will confirm whether we are processing your Personal Data and, if so, provide you with a copy of that Personal Data along with certain other details. If you require additional copies of the data, we may need to charge a reasonable fee.
  Right to rectification: If your Personal Data is inaccurate or incomplete, you are entitled to ask that we correct or complete it. If we shared your Personal Data with others, we will tell them about the correction where possible. If you ask us, and where possible and lawful to do so, we will also tell you with whom we shared your Personal Data so you can contact them directly.
  Right to erasure: You may ask us to delete or remove your Personal Data, such as where you withdraw your consent. If we shared your data with others, we will tell them about the erasure where possible. If you ask us, and where possible and lawful to do so, we will also tell you with whom we shared your Personal Data so you can contact them directly.
  Right to restrict processing: You may ask us to restrict or ‘block’ the processing of your Personal Data in certain circumstances, such as where you contest the accuracy of the data or object to us processing it. We will tell you before we lift any restriction on processing. If we shared your Personal Data with others, we will tell them about the restriction where possible. If you ask us, and where possible and lawful to do so, we will also tell you with whom we shared your Personal Data so you can contact them directly.
  Right to data portability: Effective 25 May 2018, you have the right to obtain your Personal Data from us that you consented to give us or that was provided to us as necessary in connection with our contract with you.  We will give you your Personal Data in a structured, commonly used and machine-readable format.  You may reuse it elsewhere.
  Right to object: You may ask us at any time to stop processing your Personal Data, and we will do so if we are processing your Personal Data for direct marketing and otherwise.  However, if we are relying on a legitimate interest to process your Personal Data and we demonstrate compelling legitimate grounds for the processing we may continue.
  Rights in relation to automated decision-making and profiling: You have the right to be free from decisions based solely on automated processing of your Personal Data, including profiling, that produce a significant legal effect on you, unless such profiling in necessary for entering into, or the performance of, a contract between you and us or you provide your explicit consent.
  Right to withdraw consent: If we rely on your consent to process your Personal Data, you have the right to withdraw that consent at any time. Withdrawal of consent will not affect any processing of your data before we received notice that you wished to unsubscribe.
  Right to lodge a complaint with the data protection authority: If you have a concern about our privacy practices, including the way we handled your Personal Data, you can report it to the data protection authority that is authorized to hear those concerns.


You may exercise your rights by visiting our Privacy Center at https://privacy.circleci.com/ and selecting your specific request (e.g., right of access, right to erasure, etc.).

Legitimate Interest. “Legitimate interests” means the interests of CircleCI in conducting and managing our organization. For example, we have a legitimate interest in processing your Personal Data to analyze how the Services are being used by you, and to ensure network and information security, as described in this Privacy Policy. When we process your Personal Data for our legitimate interests, we make sure to consider and balance any potential impact on you, and your rights under data protection laws. Our legitimate interests do not automatically override your interests. We will not use your Personal Data for activities where our interests are overridden by the impact on you, unless we have your consent or those activities are otherwise required or permitted to by law. You have the right to object to processing that is based on our legitimate interests. For more information on your rights, please see the “Your Rights” section above.

International Data Transfers from Europe
Your personal information may be transferred to CircleCI and its service providers in countries other than the country in which you are resident, including in the United States, and other locations where we have offices or employees. These countries may have data protection laws that are different from the laws of your country and may not provide the same level of protection as your country.

Model Clauses
If you are located in the European Economic Area, the UK or Switzerland, we will protect your personal information when it is transferred outside of your jurisdiction by (a) processing it in a territory that provides an adequate level of protection based on its data protection laws; (b) implementing appropriate safeguards to protect your personal information, such as relying on the European standard contractual clauses (“Model Clauses”); (c) by seeking your consent for transfers of your personal information for specific purposes; and/or (d) by relying on other transfer mechanisms approved by authorities in the country from which data are transferred. CircleCI relies on the Model Clauses for data transfers.

EU-U.S. Data Privacy Framework with UK Extension, and Swiss-U.S. Data Privacy Framework
CircleCI complies with the EU-U.S. Data Privacy Framework (“EU-U.S. DPF”), the UK Extension to the EU-U.S. DPF, and the Swiss-U.S. Data Privacy Framework (“Swiss-U.S. DPF”) as set forth by the U.S. Department of Commerce.  CircleCI has certified to the U.S. Department of Commerce that it adheres to the EU-U.S. Data Privacy Framework Principles (“EU-U.S. DPF Principles”) with regard to the processing of personal data received from the European Union in reliance on the EU-U.S. DPF and from the United Kingdom (and Gibraltar) under the UK Extension to the EU-U.S. DPF.  CircleCI has certified to the U.S. Department of Commerce that it adheres to the Swiss-U.S. Data Privacy Framework Principles (“Swiss-U.S. DPF Principles”) with regard to the processing of personal data received from Switzerland in reliance on the Swiss-U.S. DPF.  If there is any conflict between the terms in this privacy policy and the EU-U.S. DPF Principles and/or the Swiss-U.S. DPF Principles, the Principles shall govern.  To learn more about the Data Privacy Framework (“DPF”) program, and to view our certification, please visit https://www.dataprivacyframework.gov/.

CircleCI is responsible for the processing of personal data it receives, under the EU-U.S. DPF, the UK Extension to the EU-U.S. DPF, and Swiss-U.S. DPF and subsequently transfers to a third party acting as an agent on its behalf.  CircleCI complies with the EU-U.S. DPF Principles and the Swiss-U.S. DPF Principles for all onward transfers of personal data from the EU, UK, and Switzerland, including the onward transfer liability provisions.

The Federal Trade Commission has jurisdiction over CircleCI’s compliance with the EU-U.S. DPF, the UK Extension to the EU-U.S. DPF, and the Swiss-U.S. DPF. In certain situations, CircleCI may be required to disclose personal data in response to lawful requests by public authorities, including to meet national security or law enforcement requirements.

Recourse, Enforcement, Liability: In compliance with the EU-US DPF, the UK Extension to the EU-US DPF, and the Swiss-US DPF, CircleCI commits to resolve complaints about your privacy and our collection or use of your Personal Data. European Union, UK (and Gibraltar) or Swiss individuals with inquiries or complaints regarding this Privacy Policy should first contact CircleCI as follows:


  Email: privacy@circleci.com
  Phone: +1-800-585-7075
  Postal Mail:
Circle Internet Services, Inc.
Attention: Privacy
2261 Market Street, #22561
San Francisco, CA, 94114


In compliance with the EU-U.S. DPF, the UK Extension to the EU-U.S. DPF, and the Swiss-U.S. DPF, CircleCI commits to refer unresolved complaints concerning its handling of non-HR related personal data received in reliance on the EU-U.S. DPF, the UK Extension to the EU-U.S. DPF, and the Swiss-U.S. DPF to TRUSTe, an alternative dispute resolution provider based in the United States. For clarity, Non-HR related data includes all personal data processed by CircleCI on behalf of its customers.  If you do not receive timely acknowledgment of your DPF Principles-related complaint from us, or if we have not addressed your DPF Principles-related complaint to your satisfaction, please visit https://feedback-form.truste.com/watchdog/request for more information or to file a complaint.  The services of TRUSTe are provided to you at no cost.

Further, CircleCI commits to cooperate and comply with the advice of the panel established by the EU data protection authorities (DPAs), the UK Information Commissioner’s Office (ICO) and the Gibraltar Regulatory Authority (GRA) with regard to unresolved complaints concerning our handling of human resources personal data received in reliance on the EU-U.S. DPF and the UK Extension to the EU-U.S. DPF in the context of the employment relationship.

For complaints regarding EU-U.S. DPF, the UK Extension to the EU-U.S DPF, and Swiss-U.S. DPF compliance not resolved by any of the other DPF mechanisms, you have the possibility, under certain conditions, to invoke binding arbitration. Further information can be found on the official DPF website: https://www.dataprivacyframework.gov/s/article/ANNEX-I-introduction-dpf?tabset-35584=2.

Cookies
We and our partners use cookies or similar technologies to optimize the functionality of the Site, help us understand how the Site is used and provide you with interest-based advertising based upon a user’s browsing activities and interests. For more information about the cookies and similar technologies used on our Site, please refer to our Cookie Policy and Security page.

Links to Other Websites
This Privacy Policy applies only to the Services and not to any third-party sites or hosted services you may find or access through our Site. If you submit Personal Data to any of those sites or services, your information will be governed by their privacy policies. We encourage you to carefully read the privacy policy of any site you visit or hosted service you use.

Social Media Widgets
The Services may include social media features, such as the Twitter button, and widgets, such as the “share this” button or interactive mini-programs. These features may collect your IP address, which page you are visiting on the Site, and may set a cookie to enable the feature to function properly. Social media features and widgets are either hosted by a third party or hosted directly on the Services. Your interactions with these features are governed by the privacy policy of the company providing it.

Do Not Track
Currently, various browsers - including Microsoft Edge, Firefox, and Safari - offer a “do not track” or “DNT” option that relies on technology known as a DNT header, which sends a signal to the websites visited by the user about the user’s browsers DNT preference setting. CircleCI does not currently commit to responding to browser’s DNT preference across its Services, because no common industry standard for DNT has been adopted by industry groups, technology companies or regulators, including no consistent standard of interpreting user intent. CircleCI takes privacy and choices regarding privacy seriously and will make efforts to continue to monitor the development around DNT browser technology and the implementation of a standard for DNT.

Security
We take precautions to ensure the security of your Personal Data. We follow generally accepted standards to protect the Personal Data submitted to us, both during transmission and once we receive it. When you enter your login information on the Service, all information to and from the service is encrypted using Transport Layer Security (TLS). For more information on our data security policies, please check here.

That said, like any hosted service provider, we cannot guarantee that unauthorized third parties or unauthorized personnel will not gain access to your Personal Data despite our efforts. You should note that in using the Services, your information will travel through third-party infrastructures which are not under our control.

We cannot protect, nor does this Privacy Policy apply to, any information that you transmit to other users of the Services. You should never transmit personal or identifying information to other users.

If you have any questions about the security of the Services, you can contact us.

Privacy Policy Changes
Although most changes are likely to be minor, CircleCI may change its Privacy Policy from time to time, and in CircleCI’s sole discretion. If we make any material changes to this Privacy Policy, we will either notify you by email (sent to the email address specified in your account) or by means of a notice on or within the Services prior to the change becoming effective, or as otherwise required by the applicable law. We encourage you to periodically review the Site for the latest information on our privacy practices. Your continued use of the Services after any change in this Privacy Policy takes effect will constitute your acceptance of such change.

Contact Us
If you wish to make a request regarding your personal information, please visit our Privacy Center at https://privacy.circleci.com/ and select your specific request.

If you have questions or concerns about this Privacy Policy, please contact us at:

Circle Internet Services, Inc.
2261 Market Street, #22561
San Francisco, CA, 94114
Phone: +1-800-585-7075
Email: privacy@circleci.com\n\nLegal
  







  
    
      
        
        
        
          
          
            
              
                Software as a Service Agreement
              
            
            
          
        
          
          
            
              
                Software License Agreement
              
            
            
          
        
          
          
            
              
                AI Functionality Terms
              
            
            
          
        
          
          
            
              
                Code Sharing Terms of Service
              
            
            
          
        
          
          
            
              
                Self-Hosted Applications Terms
              
            
            
          
        
          
          
            
              
                Acceptable Use Policy
              
            
            
          
        
          
          
            
              
                Cookie Policy
              
            
            
          
        
          
          
            
              
                Privacy Policy
              
            
            
              
              


  Information We Collect And How We Use It
  Data Retention
  Bulletin Boards/Chat Rooms
  Disclosure Of Personal Data
  Access and Deletion Requests
  Rights of Certain California Residents
  EU and UK Data Subjects
  International Data Transfers from Europe
  Cookies
  Links to Other Websites
  Social Media Widgets
  Do Not Track
  Security
  Privacy Policy Changes
  Contact Us




            
          
        
          
          
            
              
                CircleCI’s Commitment to Data Privacy
              
            
            
          
        
          
          
            
              
                 Trademark Usage Guidelines
              
            
            
          
        
          
          
            
              
                Copyright Infringement Notice and Takedown Policy
              
            
            
          
        
          
          
            
              
                Website Terms of Use
              
            
            
          
        
      
    
  
  
    
      
        Privacy Policy
      
      
          Last Updated:
          
            March 27, 2025
          
      
      
        
Circle Internet Services, Inc. dba CircleCI, a Delaware corporation (“CircleCI”, “we” or “us”) provides this Privacy Policy to inform users of our Services (as that term is defined in our Software as a Service Agreement) of our policies and procedures regarding the collection, use and disclosure of Personal Data and other information. This Privacy Policy explains what data we collect when you use the Services, why we collect the data, how it is used and your rights and choices. Capitalized terms used but not defined in this Privacy Policy will have the meanings assigned to them by the Software as a Service Agreement.

While providing our Services, we may collect information about our customers’ Users on behalf of our customers. Our use of information on behalf of our customers is governed by our agreement with the applicable customer and the customer’s own privacy policies. We cannot control and are not responsible for the privacy policies or privacy practices of our customers or any other third parties.

By using or accessing the Services and providing us with your Personal Data, you are accepting the practices described in this Privacy Policy, and you are consenting to our processing of your data as set forth in this Privacy Policy now and as amended by us (for information on how we may change our Privacy Policy, please read the “Privacy Policy Changes” section below). If you have any questions or comments about this Privacy Policy or our use of your Personal Data, please contact us.

Information We Collect And How We Use It
Collection of Information
We have collected the following categories of information from our users within the last twelve (12) months:


  Identifiers, including name, email address, phone number, IP address and cookie identifiers,
  Certain financial-related information, including credit card number and billing and shipping address,
  Protected classification information, such as age and gender,
  Commercial information, including purchasing history of our business customer’s employees and representatives who use our Service,
  Internet or other similar network activity, such as browsing history, information on your interaction with our Site, browser type, and referring site,
  Location data, and
  Professional or employment related data with respect to our job applicants and our business customer’s employees and representatives who use our Services, such as professional title.


Categories of Sources

We obtain the personal information of our users from the following categories of sources:


  
    Personal Data That You Provide To Us
    When you interact with the Services, CircleCI may gather information that, alone or in combination with other information, could be used to identify you (“Personal Data”), as described below. If you are an EU or UK data subject, please see the “EU and UK Data Subject” section below for information on your rights in relation to the Personal Data we hold about you.

    
      
        Personal Data used to provide the Service and respond to requests
        When signing up for the Services, users are required to either provide their email address and a password while creating an account with us, or authenticate with their version control system identity (GitHub, GitLab, or Bitbucket).  When users log in to the Services using sign-in services such as OAuth (for example, login with a GitHub account), these services will authenticate a user’s identity and provide the user with the option to share certain Personal Data, such as name and email address(es), with us.  If you purchase one of our paid plans, we will also collect payment and billing information such as credit card details and billing address.  We use this data to provide you with access to the Services, contact you regarding your access and use of the Services or to notify you of important changes to the Services. For EU and UK data subjects, such use is necessary for the performance of the contract between you and us.

        On some sections of the Site, you may complete a web form to give your Personal Data to us directly, such as on our “Contact Us” page. We also collect Personal Data (e.g., your name, email, and phone number) when you request information, including a product demo, ask to download content (such as white papers), register for a webinar or other event, or subscribe to email lists. We will use your contact information to respond to your request. For EU and UK data subjects, such use is necessary to respond to or implement your request. If you send us a request or question regarding the use of the Services (for example via a support email or via one of our feedback mechanisms), we may publish it (in anonymous form only) in order to help us clarify or respond to your request or to help us support other users.

        CircleCI collects Personal Data that you provide through the Services only insofar as is necessary or appropriate to fulfill the purpose of your interaction with CircleCI, such as providing you with the Services and/or answering any requests regarding the Service as described above. You can always refuse to supply Personal Data, however doing so may prevent you from accessing the Services or engaging in certain activities on the Services.
      
      
        Personal Data we receive from third party applications
        CircleCI may receive Personal Data about you from third parties.  For example, if you access the Services through a third-party service or interact with the Services via a third-party service connected to the Services (e.g., by pushing code to a VCS repository configured to interact with the Services), that third party may pass certain Personal Data you provided to its service to CircleCI.  This information could include, but is not limited to, the user ID associated with your account, your name and email address, any information that you have permitted the third party to share with CircleCI, and any information you have made public in connection with that service.  You should always review, and if necessary, adjust your privacy settings on third-party websites and services before linking or connecting them to the Services. Ultimately, the terms governing your use of a third-party service will control what Personal Data, if any, that third party shares with CircleCI.  If you communicate with CircleCI via social media, and choose to share your user generated content with CircleCI, CircleCI may receive information such as posts or videos you’ve created, your photo, your account name and your comments about CircleCI.
      
      
        Personal Data we receive from other third parties
        CircleCI may obtain information about you from third-party sources, such as public sources, social media platforms (like LinkedIn, Twitter and other platforms) and third-party data providers and information services.  Examples of the information we may obtain from such third parties include your company, company size, job title and seniority, industry and other profile information. We do this to better understand your profile and interests so that we can deliver customized offers and other personalized services to you, such as to serve relevant offers to you via email, chatbots, phone or personalized advertising. We may also receive information about you and your engagement with our advertisements from our ad servers, ad networks, social media platforms, and other sources. This may include the websites you visited before coming to CircleCI so that we can determine advertising effectiveness and pay our referral partners. If you prefer not to have your information used for this purpose, you can opt out at any time by emailing us.
      
      
        Personal Data used to process applications for employment
        When you submit a job application through the Site, we will collect your resume and any additional information that you elect to provide to us, including but not limited to employment history and education. We will use your contact details and data about your employment history and education to conduct job interviews, evaluate your application, and as is otherwise needed for recruitment. For EU and UK data subjects, this use is necessary to respond to your request to process your application for employment.
      
      
        Personal Data used for marketing
        We will use your email to tell you about your usage of the Services, new features, solicit your feedback, or just keep you up to date with what’s going on with CircleCI and our products, upcoming events or other promotions. If you change your mind about receiving information from us or about the use of information volunteered by you, please send us a request specifying your new choice. Please contact us as specified under the “Contact Us” section. You may also choose to opt out of receiving such emails by following the unsubscribe instructions included in these emails, or by accessing the email preferences in your account settings page. If you download content from the Site, we may also use your phone number to contact you directly by phone, in connection with such new products and services, upcoming events or other promotions.

        Where required by applicable law (for example, if you are an EU or UK data subject), we will only send you marketing information by email or mail, or contact you by phone, if you consent to us doing so. When you provide us with your consent to be contacted for marketing purposes, you have the right to withdraw your consent at any time by following the instructions to “opt out” of receiving marketing communication in each marketing email we send you. In addition, if at any time you do not wish to receive future marketing communications or wish to have your name deleted from our mailing or calling lists, please make the appropriate request at https://privacy.circleci.com/. Please note that if you opt out from marketing communications, we may still contact you regarding issues related to our Services and to respond to your requests.
      
    
  
  
    Automatically Collected Information
    Like most hosted service operators, CircleCI collects information of the sort that web browsers and servers typically make available, such as the browser type, language preference, referring site and the date and time of each visitor request and store it in log files. CircleCI also collects Internet Protocol (“IP”) addresses, which can be used to identify the location from which your computer is connecting to the Site, for providing the Services and for support purposes.

    CircleCI also collects statistics about the behavior of visitors to the Services through cookies and similar technologies. We also allow some others to use cookies as described in the “Cookies” section below. CircleCI’s purpose in collecting such information is to better understand how CircleCI’s visitors use the Services and to improve your access to and use of the Services.

    Use of such automatically collected information is necessary for the performance of the contract between you and us, to the extent we process information that is needed for providing the Services and for support purposes, or is in our legitimate interest in understanding how the Services are being used by you and enhancing your experience when using our Services.
  
  
    Information We Process On Behalf Of Our Customers
    In providing the Services to our customers, we process on behalf of customers certain information that may include Personal Data, relating to customers’ employees, contractors or other users (“Users”) they transmit or otherwise submit to our Service. While our customers or Users decide what data to submit, this information typically includes email address and information relating to tests results.

    CircleCI collects and stores metrics and data relating to, generated by, provided in connection with, or derived from customers’ use of the Services (“Usage Data”) in order to provide, maintain, support, enhance, develop and improve the Services and CircleCI’s service offerings. CircleCI will not disclose individual metric or usage data other than in an aggregated and de-identified form. For EU and UK data subjects, this use of your Personal Data is necessary for our legitimate interests in understanding how the Services are being used by you and to improve your experience on it.
  


Data Retention
We will retain Personal Data that our customers provide to us through the Services for the period necessary to fulfill the purposes outlined in this Privacy Policy unless a longer retention period is required or permitted by law. We will retain Personal Data that we process on behalf of our customers for the duration set forth in the applicable customer contract or as otherwise instructed by the customer.

Bulletin Boards/Chat Rooms
If you submit a post or participate in a discussion on a bulletin board or chat room on the Services, you should be aware that any Personal Data you submit there can be read, collected, or used by other users of these forums, and could be used to send you unsolicited messages. We are not responsible for the Personal Data you choose to submit in these forums.

Disclosure Of Personal Data
In the preceding twelve (12) months, we have disclosed the following categories of personal information for a business purpose:


  Identifiers,
  Certain financial-related information,
  Protected classification information,
  Commercial information,
  Internet or other similar network activity,
  Location data, and
  Professional or employment related data.


We share personal information for a business purpose with various categories of third parties. CircleCI discloses Personal Data only to those of its employees, contractors, and service providers that (1) need to know that data in order to perform certain services and functions on CircleCI’s behalf and (2) have agreed to data protection and confidentiality obligations requiring them to protect that data. Third-party service providers include: (i) providers of payment processing, customer support services and hosting (which support us in the provision and maintenance of the Services), (ii) web analytics service providers (which help us collect statistics and other information, including through cookies, about the behavior of users of the Services - for more details, please see the “Cookies” section below); (iii) marketing and sales automation tools that allow us to manage marketing and sales processes; (iv) phone and chat communication tools that allow us to communicate with prospects and customers; (v) integration tools that allow us to capture data in one platform and send it to another; (vi) survey and poll tools that allows us to capture information about our Services; and (vii) event and meeting platforms that allow us to host and manage virtual and in-person events. Pursuant to our instructions, these parties may access, process or store Personal Data in the course of performing their duties to us and only as necessary to provide the services we request.

CircleCI may also disclose Personal Data when required to do so by law, such as to comply with a subpoena, bankruptcy proceedings, or similar legal process, or in response to lawful requests by public authorities, including to meet national security or law enforcement requirements, or when CircleCI believes in good faith that disclosure is reasonably necessary to protect the property or rights of CircleCI, third parties, or the public at large.

CircleCI may disclose Personal Data in connection with a merger, acquisition, or sale of all or a portion of its assets (a “Corporate Transaction”). If CircleCI is involved in a Corporate Transaction, you will be notified either via email and/or a prominent notice through the Service of any change in ownership or uses of your Personal Data, as well as any choices you may have regarding your Personal Data, or we will require any such buyer to agree to treat your Personal Data in accordance with this Privacy Policy.

In the preceding twelve (12) months, we have not sold our users’ personal information.

Access and Deletion Requests
You may visit https://privacy.circleci.com/ to request that we provide you with a copy of your Personal Data or that we delete your Personal Data that we maintain on our systems. We will respond to your request within a reasonable timeframe. If you are an EU or UK data subject or California resident, see your additional rights below.

Rights of Certain California Residents
The California Consumer Privacy Act (CCPA) and California Privacy Rights Act (CPRA) provide certain California residents with the additional rights listed below.

Right to Access. You have the right to request that we disclose certain information to you about our collection and use of your personal information over the past 12 months. Once we receive and confirm your verifiable consumer request, we will disclose to you:


  The categories of personal information we collected about you,
  The categories of sources for the personal information we collected about you,
  Our business or commercial purpose for collecting that personal information,
  The categories of third parties with whom we share that personal information, and
  The specific pieces of personal information we collected about you (which will also allow you to exercise your data portability right).


Data Portability Right. You have the right to request that we provide you with access to the information above (under Right to Access) in a readily useable format that allows you to transmit (i.e., port) the information to another entity without hindrance. If you make a request under your right to request access, you will receive access to your information in a readily useable format.

Right to Delete. You have the right to request that we delete any of your personal information that we collected from you and retained, subject to certain exceptions. Once we receive and confirm your verifiable consumer request, we will delete (and direct our service providers to delete) your personal information from our records, unless an exception applies.  You must contact the applicable business customers directly to delete your information that they have in their systems.

We may deny your deletion request or not delete some of your personal information, if retaining the information is necessary for us or our service provider(s) to:


  Complete the transaction for which we collected the personal information, provide a good or service that you requested, take actions reasonably anticipated within the context of our ongoing business relationship with you, or otherwise perform our contract with you.
  Detect security incidents, protect against malicious, deceptive, fraudulent, or illegal activity, or prosecute those responsible for such activities.
  Debug products to identify and repair errors that impair existing intended functionality.
  Exercise free speech, ensure the right of another consumer to exercise their free speech rights, or exercise another right provided for by law.
  Comply with the California Electronic Communications Privacy Act (Cal. Penal Code § 1546 et. seq.).
  Engage in public or peer-reviewed scientific, historical, or statistical research in the public interest that adheres to all other applicable ethics and privacy laws, when the information’s deletion may likely render impossible or seriously impair the research’s achievement, if you previously provided informed consent.
  Enable solely internal uses that are reasonably aligned with consumer expectations based on your relationship with us.
  Comply with a legal obligation.
  Make other internal and lawful uses of that information that are compatible with the context in which you provided it.


We may also limit our deletion to the extent permitted by applicable law.

Right to Update. You have the right to request that inaccurate personal information that we hold about you be corrected.

Right to restrict the use and disclosure of your sensitive information. You have the right to request that we limit our use and disclosure of your sensitive personal information.  We currently do not request or retain any sensitive personal information from our customers.

Categories of Personal Data collected by CircleCI. For more details on how we use the Personal Data, who we disclose it to for a business purpose, and how long we keep it for, please see the sections “Categories of Sources”, “Disclosure of Personal Data”, and “Data Retention” set forth above.

Categories of Personal Data disclosed for a business purpose. You have the right to request that we limit our use and disclosure of your sensitive personal information.  We currently do not request or retain any sensitive personal information from our customers.

Exercising Your Rights. To exercise your rights, please contact us as follows:


  Submit your request by visiting our Privacy Center at https://privacy.circleci.com/ and selecting your specific request (e.g., right to access, right to correct, or right to delete); or
  Email us at privacy@circleci.com and provide the following information:
    
      Full name and email address associated with your use of our Services, and
      Your specific request (e.g., right to access, right to portability, right to update or right to delete).
    
  


We will attempt to respond to a consumer request for access or deletion within 45 days of receiving that request. If we require more time, we will inform you of the reason and extension period in writing.

Only you, or someone legally authorized to act on your behalf, may make a verifiable consumer request related to your personal information.

You may only make a verifiable consumer request for access or data portability twice within a 12-month period.

Non-Discrimination. We will not discriminate against you for exercising any of your rights under the CCPA or CPRA. Unless permitted by the CCPA or CPRA, we will not:


  Deny you goods or services,
  Charge you different prices or rates for goods or services, including through granting discounts or other benefits, or imposing penalties,
  Provide you a different level or quality of goods or services, or
  Suggest that you may receive a different price or rate for goods or services or a different level or quality of goods or services.


However, we may offer you certain financial incentives permitted by the CCPA and CPRA that can result in different prices, rates, or quality levels. Any CCPA or CPRA-permitted financial incentive we offer will reasonably relate to your personal information’s value to CircleCI and contain written terms that describe the program’s material aspects. Participation in a financial incentive program requires your prior opt in consent, which you may revoke at any time. We currently do not provide any financial incentives.

No Sale or Sharing of Personal Information. We do not sell or share (for the purpose of cross-context behavioral advertising) your personal information, as those terms are defined under the CCPA/CPRA.

EU and UK Data Subjects
Scope: This section applies if you are an EU or UK data subject (for these purposes, reference to the EU also includes the European Economic Area countries of Iceland, Liechtenstein, Norway and, where applicable, Switzerland).

Data Controller: CircleCI is the data controller of Personal Data provided to, or collected by or for, our Services, but we may act as data processor on behalf of our customers for Personal Data that we process on their behalf when providing the Services.

Your Rights: Subject to applicable law, you have the following rights in relation to your Personal Data:


  Right of access: If you ask us, we will confirm whether we are processing your Personal Data and, if so, provide you with a copy of that Personal Data along with certain other details. If you require additional copies of the data, we may need to charge a reasonable fee.
  Right to rectification: If your Personal Data is inaccurate or incomplete, you are entitled to ask that we correct or complete it. If we shared your Personal Data with others, we will tell them about the correction where possible. If you ask us, and where possible and lawful to do so, we will also tell you with whom we shared your Personal Data so you can contact them directly.
  Right to erasure: You may ask us to delete or remove your Personal Data, such as where you withdraw your consent. If we shared your data with others, we will tell them about the erasure where possible. If you ask us, and where possible and lawful to do so, we will also tell you with whom we shared your Personal Data so you can contact them directly.
  Right to restrict processing: You may ask us to restrict or ‘block’ the processing of your Personal Data in certain circumstances, such as where you contest the accuracy of the data or object to us processing it. We will tell you before we lift any restriction on processing. If we shared your Personal Data with others, we will tell them about the restriction where possible. If you ask us, and where possible and lawful to do so, we will also tell you with whom we shared your Personal Data so you can contact them directly.
  Right to data portability: Effective 25 May 2018, you have the right to obtain your Personal Data from us that you consented to give us or that was provided to us as necessary in connection with our contract with you.  We will give you your Personal Data in a structured, commonly used and machine-readable format.  You may reuse it elsewhere.
  Right to object: You may ask us at any time to stop processing your Personal Data, and we will do so if we are processing your Personal Data for direct marketing and otherwise.  However, if we are relying on a legitimate interest to process your Personal Data and we demonstrate compelling legitimate grounds for the processing we may continue.
  Rights in relation to automated decision-making and profiling: You have the right to be free from decisions based solely on automated processing of your Personal Data, including profiling, that produce a significant legal effect on you, unless such profiling in necessary for entering into, or the performance of, a contract between you and us or you provide your explicit consent.
  Right to withdraw consent: If we rely on your consent to process your Personal Data, you have the right to withdraw that consent at any time. Withdrawal of consent will not affect any processing of your data before we received notice that you wished to unsubscribe.
  Right to lodge a complaint with the data protection authority: If you have a concern about our privacy practices, including the way we handled your Personal Data, you can report it to the data protection authority that is authorized to hear those concerns.


You may exercise your rights by visiting our Privacy Center at https://privacy.circleci.com/ and selecting your specific request (e.g., right of access, right to erasure, etc.).

Legitimate Interest. “Legitimate interests” means the interests of CircleCI in conducting and managing our organization. For example, we have a legitimate interest in processing your Personal Data to analyze how the Services are being used by you, and to ensure network and information security, as described in this Privacy Policy. When we process your Personal Data for our legitimate interests, we make sure to consider and balance any potential impact on you, and your rights under data protection laws. Our legitimate interests do not automatically override your interests. We will not use your Personal Data for activities where our interests are overridden by the impact on you, unless we have your consent or those activities are otherwise required or permitted to by law. You have the right to object to processing that is based on our legitimate interests. For more information on your rights, please see the “Your Rights” section above.

International Data Transfers from Europe
Your personal information may be transferred to CircleCI and its service providers in countries other than the country in which you are resident, including in the United States, and other locations where we have offices or employees. These countries may have data protection laws that are different from the laws of your country and may not provide the same level of protection as your country.

Model Clauses
If you are located in the European Economic Area, the UK or Switzerland, we will protect your personal information when it is transferred outside of your jurisdiction by (a) processing it in a territory that provides an adequate level of protection based on its data protection laws; (b) implementing appropriate safeguards to protect your personal information, such as relying on the European standard contractual clauses (“Model Clauses”); (c) by seeking your consent for transfers of your personal information for specific purposes; and/or (d) by relying on other transfer mechanisms approved by authorities in the country from which data are transferred. CircleCI relies on the Model Clauses for data transfers.

EU-U.S. Data Privacy Framework with UK Extension, and Swiss-U.S. Data Privacy Framework
CircleCI complies with the EU-U.S. Data Privacy Framework (“EU-U.S. DPF”), the UK Extension to the EU-U.S. DPF, and the Swiss-U.S. Data Privacy Framework (“Swiss-U.S. DPF”) as set forth by the U.S. Department of Commerce.  CircleCI has certified to the U.S. Department of Commerce that it adheres to the EU-U.S. Data Privacy Framework Principles (“EU-U.S. DPF Principles”) with regard to the processing of personal data received from the European Union in reliance on the EU-U.S. DPF and from the United Kingdom (and Gibraltar) under the UK Extension to the EU-U.S. DPF.  CircleCI has certified to the U.S. Department of Commerce that it adheres to the Swiss-U.S. Data Privacy Framework Principles (“Swiss-U.S. DPF Principles”) with regard to the processing of personal data received from Switzerland in reliance on the Swiss-U.S. DPF.  If there is any conflict between the terms in this privacy policy and the EU-U.S. DPF Principles and/or the Swiss-U.S. DPF Principles, the Principles shall govern.  To learn more about the Data Privacy Framework (“DPF”) program, and to view our certification, please visit https://www.dataprivacyframework.gov/.

CircleCI is responsible for the processing of personal data it receives, under the EU-U.S. DPF, the UK Extension to the EU-U.S. DPF, and Swiss-U.S. DPF and subsequently transfers to a third party acting as an agent on its behalf.  CircleCI complies with the EU-U.S. DPF Principles and the Swiss-U.S. DPF Principles for all onward transfers of personal data from the EU, UK, and Switzerland, including the onward transfer liability provisions.

The Federal Trade Commission has jurisdiction over CircleCI’s compliance with the EU-U.S. DPF, the UK Extension to the EU-U.S. DPF, and the Swiss-U.S. DPF. In certain situations, CircleCI may be required to disclose personal data in response to lawful requests by public authorities, including to meet national security or law enforcement requirements.

Recourse, Enforcement, Liability: In compliance with the EU-US DPF, the UK Extension to the EU-US DPF, and the Swiss-US DPF, CircleCI commits to resolve complaints about your privacy and our collection or use of your Personal Data. European Union, UK (and Gibraltar) or Swiss individuals with inquiries or complaints regarding this Privacy Policy should first contact CircleCI as follows:


  Email: privacy@circleci.com
  Phone: +1-800-585-7075
  Postal Mail:
Circle Internet Services, Inc.
Attention: Privacy
2261 Market Street, #22561
San Francisco, CA, 94114


In compliance with the EU-U.S. DPF, the UK Extension to the EU-U.S. DPF, and the Swiss-U.S. DPF, CircleCI commits to refer unresolved complaints concerning its handling of non-HR related personal data received in reliance on the EU-U.S. DPF, the UK Extension to the EU-U.S. DPF, and the Swiss-U.S. DPF to TRUSTe, an alternative dispute resolution provider based in the United States. For clarity, Non-HR related data includes all personal data processed by CircleCI on behalf of its customers.  If you do not receive timely acknowledgment of your DPF Principles-related complaint from us, or if we have not addressed your DPF Principles-related complaint to your satisfaction, please visit https://feedback-form.truste.com/watchdog/request for more information or to file a complaint.  The services of TRUSTe are provided to you at no cost.

Further, CircleCI commits to cooperate and comply with the advice of the panel established by the EU data protection authorities (DPAs), the UK Information Commissioner’s Office (ICO) and the Gibraltar Regulatory Authority (GRA) with regard to unresolved complaints concerning our handling of human resources personal data received in reliance on the EU-U.S. DPF and the UK Extension to the EU-U.S. DPF in the context of the employment relationship.

For complaints regarding EU-U.S. DPF, the UK Extension to the EU-U.S DPF, and Swiss-U.S. DPF compliance not resolved by any of the other DPF mechanisms, you have the possibility, under certain conditions, to invoke binding arbitration. Further information can be found on the official DPF website: https://www.dataprivacyframework.gov/s/article/ANNEX-I-introduction-dpf?tabset-35584=2.

Cookies
We and our partners use cookies or similar technologies to optimize the functionality of the Site, help us understand how the Site is used and provide you with interest-based advertising based upon a user’s browsing activities and interests. For more information about the cookies and similar technologies used on our Site, please refer to our Cookie Policy and Security page.

Links to Other Websites
This Privacy Policy applies only to the Services and not to any third-party sites or hosted services you may find or access through our Site. If you submit Personal Data to any of those sites or services, your information will be governed by their privacy policies. We encourage you to carefully read the privacy policy of any site you visit or hosted service you use.

Social Media Widgets
The Services may include social media features, such as the Twitter button, and widgets, such as the “share this” button or interactive mini-programs. These features may collect your IP address, which page you are visiting on the Site, and may set a cookie to enable the feature to function properly. Social media features and widgets are either hosted by a third party or hosted directly on the Services. Your interactions with these features are governed by the privacy policy of the company providing it.

Do Not Track
Currently, various browsers - including Microsoft Edge, Firefox, and Safari - offer a “do not track” or “DNT” option that relies on technology known as a DNT header, which sends a signal to the websites visited by the user about the user’s browsers DNT preference setting. CircleCI does not currently commit to responding to browser’s DNT preference across its Services, because no common industry standard for DNT has been adopted by industry groups, technology companies or regulators, including no consistent standard of interpreting user intent. CircleCI takes privacy and choices regarding privacy seriously and will make efforts to continue to monitor the development around DNT browser technology and the implementation of a standard for DNT.

Security
We take precautions to ensure the security of your Personal Data. We follow generally accepted standards to protect the Personal Data submitted to us, both during transmission and once we receive it. When you enter your login information on the Service, all information to and from the service is encrypted using Transport Layer Security (TLS). For more information on our data security policies, please check here.

That said, like any hosted service provider, we cannot guarantee that unauthorized third parties or unauthorized personnel will not gain access to your Personal Data despite our efforts. You should note that in using the Services, your information will travel through third-party infrastructures which are not under our control.

We cannot protect, nor does this Privacy Policy apply to, any information that you transmit to other users of the Services. You should never transmit personal or identifying information to other users.

If you have any questions about the security of the Services, you can contact us.

Privacy Policy Changes
Although most changes are likely to be minor, CircleCI may change its Privacy Policy from time to time, and in CircleCI’s sole discretion. If we make any material changes to this Privacy Policy, we will either notify you by email (sent to the email address specified in your account) or by means of a notice on or within the Services prior to the change becoming effective, or as otherwise required by the applicable law. We encourage you to periodically review the Site for the latest information on our privacy practices. Your continued use of the Services after any change in this Privacy Policy takes effect will constitute your acceptance of such change.

Contact Us
If you wish to make a request regarding your personal information, please visit our Privacy Center at https://privacy.circleci.com/ and select your specific request.

If you have questions or concerns about this Privacy Policy, please contact us at:

Circle Internet Services, Inc.
2261 Market Street, #22561
San Francisco, CA, 94114
Phone: +1-800-585-7075
Email: privacy@circleci.com\n\nLegal
  







  
    
      
        
        
        
          
          
            
              
                Software as a Service Agreement
              
            
            
          
        
          
          
            
              
                Software License Agreement
              
            
            
          
        
          
          
            
              
                AI Functionality Terms
              
            
            
          
        
          
          
            
              
                Code Sharing Terms of Service
              
            
            
          
        
          
          
            
              
                Self-Hosted Applications Terms
              
            
            
          
        
          
          
            
              
                Acceptable Use Policy
              
            
            
          
        
          
          
            
              
                Cookie Policy
              
            
            
          
        
          
          
            
              
                Privacy Policy
              
            
            
              
              


  Information We Collect And How We Use It
  Data Retention
  Bulletin Boards/Chat Rooms
  Disclosure Of Personal Data
  Access and Deletion Requests
  Rights of Certain California Residents
  EU and UK Data Subjects
  International Data Transfers from Europe
  Cookies
  Links to Other Websites
  Social Media Widgets
  Do Not Track
  Security
  Privacy Policy Changes
  Contact Us




            
          
        
          
          
            
              
                CircleCI’s Commitment to Data Privacy
              
            
            
          
        
          
          
            
              
                 Trademark Usage Guidelines
              
            
            
          
        
          
          
            
              
                Copyright Infringement Notice and Takedown Policy
              
            
            
          
        
          
          
            
              
                Website Terms of Use
              
            
            
          
        
      
    
  
  
    
      
        Privacy Policy
      
      
          Last Updated:
          
            March 27, 2025
          
      
      
        
Circle Internet Services, Inc. dba CircleCI, a Delaware corporation (“CircleCI”, “we” or “us”) provides this Privacy Policy to inform users of our Services (as that term is defined in our Software as a Service Agreement) of our policies and procedures regarding the collection, use and disclosure of Personal Data and other information. This Privacy Policy explains what data we collect when you use the Services, why we collect the data, how it is used and your rights and choices. Capitalized terms used but not defined in this Privacy Policy will have the meanings assigned to them by the Software as a Service Agreement.

While providing our Services, we may collect information about our customers’ Users on behalf of our customers. Our use of information on behalf of our customers is governed by our agreement with the applicable customer and the customer’s own privacy policies. We cannot control and are not responsible for the privacy policies or privacy practices of our customers or any other third parties.

By using or accessing the Services and providing us with your Personal Data, you are accepting the practices described in this Privacy Policy, and you are consenting to our processing of your data as set forth in this Privacy Policy now and as amended by us (for information on how we may change our Privacy Policy, please read the “Privacy Policy Changes” section below). If you have any questions or comments about this Privacy Policy or our use of your Personal Data, please contact us.

Information We Collect And How We Use It
Collection of Information
We have collected the following categories of information from our users within the last twelve (12) months:


  Identifiers, including name, email address, phone number, IP address and cookie identifiers,
  Certain financial-related information, including credit card number and billing and shipping address,
  Protected classification information, such as age and gender,
  Commercial information, including purchasing history of our business customer’s employees and representatives who use our Service,
  Internet or other similar network activity, such as browsing history, information on your interaction with our Site, browser type, and referring site,
  Location data, and
  Professional or employment related data with respect to our job applicants and our business customer’s employees and representatives who use our Services, such as professional title.


Categories of Sources

We obtain the personal information of our users from the following categories of sources:


  
    Personal Data That You Provide To Us
    When you interact with the Services, CircleCI may gather information that, alone or in combination with other information, could be used to identify you (“Personal Data”), as described below. If you are an EU or UK data subject, please see the “EU and UK Data Subject” section below for information on your rights in relation to the Personal Data we hold about you.

    
      
        Personal Data used to provide the Service and respond to requests
        When signing up for the Services, users are required to either provide their email address and a password while creating an account with us, or authenticate with their version control system identity (GitHub, GitLab, or Bitbucket).  When users log in to the Services using sign-in services such as OAuth (for example, login with a GitHub account), these services will authenticate a user’s identity and provide the user with the option to share certain Personal Data, such as name and email address(es), with us.  If you purchase one of our paid plans, we will also collect payment and billing information such as credit card details and billing address.  We use this data to provide you with access to the Services, contact you regarding your access and use of the Services or to notify you of important changes to the Services. For EU and UK data subjects, such use is necessary for the performance of the contract between you and us.

        On some sections of the Site, you may complete a web form to give your Personal Data to us directly, such as on our “Contact Us” page. We also collect Personal Data (e.g., your name, email, and phone number) when you request information, including a product demo, ask to download content (such as white papers), register for a webinar or other event, or subscribe to email lists. We will use your contact information to respond to your request. For EU and UK data subjects, such use is necessary to respond to or implement your request. If you send us a request or question regarding the use of the Services (for example via a support email or via one of our feedback mechanisms), we may publish it (in anonymous form only) in order to help us clarify or respond to your request or to help us support other users.

        CircleCI collects Personal Data that you provide through the Services only insofar as is necessary or appropriate to fulfill the purpose of your interaction with CircleCI, such as providing you with the Services and/or answering any requests regarding the Service as described above. You can always refuse to supply Personal Data, however doing so may prevent you from accessing the Services or engaging in certain activities on the Services.
      
      
        Personal Data we receive from third party applications
        CircleCI may receive Personal Data about you from third parties.  For example, if you access the Services through a third-party service or interact with the Services via a third-party service connected to the Services (e.g., by pushing code to a VCS repository configured to interact with the Services), that third party may pass certain Personal Data you provided to its service to CircleCI.  This information could include, but is not limited to, the user ID associated with your account, your name and email address, any information that you have permitted the third party to share with CircleCI, and any information you have made public in connection with that service.  You should always review, and if necessary, adjust your privacy settings on third-party websites and services before linking or connecting them to the Services. Ultimately, the terms governing your use of a third-party service will control what Personal Data, if any, that third party shares with CircleCI.  If you communicate with CircleCI via social media, and choose to share your user generated content with CircleCI, CircleCI may receive information such as posts or videos you’ve created, your photo, your account name and your comments about CircleCI.
      
      
        Personal Data we receive from other third parties
        CircleCI may obtain information about you from third-party sources, such as public sources, social media platforms (like LinkedIn, Twitter and other platforms) and third-party data providers and information services.  Examples of the information we may obtain from such third parties include your company, company size, job title and seniority, industry and other profile information. We do this to better understand your profile and interests so that we can deliver customized offers and other personalized services to you, such as to serve relevant offers to you via email, chatbots, phone or personalized advertising. We may also receive information about you and your engagement with our advertisements from our ad servers, ad networks, social media platforms, and other sources. This may include the websites you visited before coming to CircleCI so that we can determine advertising effectiveness and pay our referral partners. If you prefer not to have your information used for this purpose, you can opt out at any time by emailing us.
      
      
        Personal Data used to process applications for employment
        When you submit a job application through the Site, we will collect your resume and any additional information that you elect to provide to us, including but not limited to employment history and education. We will use your contact details and data about your employment history and education to conduct job interviews, evaluate your application, and as is otherwise needed for recruitment. For EU and UK data subjects, this use is necessary to respond to your request to process your application for employment.
      
      
        Personal Data used for marketing
        We will use your email to tell you about your usage of the Services, new features, solicit your feedback, or just keep you up to date with what’s going on with CircleCI and our products, upcoming events or other promotions. If you change your mind about receiving information from us or about the use of information volunteered by you, please send us a request specifying your new choice. Please contact us as specified under the “Contact Us” section. You may also choose to opt out of receiving such emails by following the unsubscribe instructions included in these emails, or by accessing the email preferences in your account settings page. If you download content from the Site, we may also use your phone number to contact you directly by phone, in connection with such new products and services, upcoming events or other promotions.

        Where required by applicable law (for example, if you are an EU or UK data subject), we will only send you marketing information by email or mail, or contact you by phone, if you consent to us doing so. When you provide us with your consent to be contacted for marketing purposes, you have the right to withdraw your consent at any time by following the instructions to “opt out” of receiving marketing communication in each marketing email we send you. In addition, if at any time you do not wish to receive future marketing communications or wish to have your name deleted from our mailing or calling lists, please make the appropriate request at https://privacy.circleci.com/. Please note that if you opt out from marketing communications, we may still contact you regarding issues related to our Services and to respond to your requests.
      
    
  
  
    Automatically Collected Information
    Like most hosted service operators, CircleCI collects information of the sort that web browsers and servers typically make available, such as the browser type, language preference, referring site and the date and time of each visitor request and store it in log files. CircleCI also collects Internet Protocol (“IP”) addresses, which can be used to identify the location from which your computer is connecting to the Site, for providing the Services and for support purposes.

    CircleCI also collects statistics about the behavior of visitors to the Services through cookies and similar technologies. We also allow some others to use cookies as described in the “Cookies” section below. CircleCI’s purpose in collecting such information is to better understand how CircleCI’s visitors use the Services and to improve your access to and use of the Services.

    Use of such automatically collected information is necessary for the performance of the contract between you and us, to the extent we process information that is needed for providing the Services and for support purposes, or is in our legitimate interest in understanding how the Services are being used by you and enhancing your experience when using our Services.
  
  
    Information We Process On Behalf Of Our Customers
    In providing the Services to our customers, we process on behalf of customers certain information that may include Personal Data, relating to customers’ employees, contractors or other users (“Users”) they transmit or otherwise submit to our Service. While our customers or Users decide what data to submit, this information typically includes email address and information relating to tests results.

    CircleCI collects and stores metrics and data relating to, generated by, provided in connection with, or derived from customers’ use of the Services (“Usage Data”) in order to provide, maintain, support, enhance, develop and improve the Services and CircleCI’s service offerings. CircleCI will not disclose individual metric or usage data other than in an aggregated and de-identified form. For EU and UK data subjects, this use of your Personal Data is necessary for our legitimate interests in understanding how the Services are being used by you and to improve your experience on it.
  


Data Retention
We will retain Personal Data that our customers provide to us through the Services for the period necessary to fulfill the purposes outlined in this Privacy Policy unless a longer retention period is required or permitted by law. We will retain Personal Data that we process on behalf of our customers for the duration set forth in the applicable customer contract or as otherwise instructed by the customer.

Bulletin Boards/Chat Rooms
If you submit a post or participate in a discussion on a bulletin board or chat room on the Services, you should be aware that any Personal Data you submit there can be read, collected, or used by other users of these forums, and could be used to send you unsolicited messages. We are not responsible for the Personal Data you choose to submit in these forums.

Disclosure Of Personal Data
In the preceding twelve (12) months, we have disclosed the following categories of personal information for a business purpose:


  Identifiers,
  Certain financial-related information,
  Protected classification information,
  Commercial information,
  Internet or other similar network activity,
  Location data, and
  Professional or employment related data.


We share personal information for a business purpose with various categories of third parties. CircleCI discloses Personal Data only to those of its employees, contractors, and service providers that (1) need to know that data in order to perform certain services and functions on CircleCI’s behalf and (2) have agreed to data protection and confidentiality obligations requiring them to protect that data. Third-party service providers include: (i) providers of payment processing, customer support services and hosting (which support us in the provision and maintenance of the Services), (ii) web analytics service providers (which help us collect statistics and other information, including through cookies, about the behavior of users of the Services - for more details, please see the “Cookies” section below); (iii) marketing and sales automation tools that allow us to manage marketing and sales processes; (iv) phone and chat communication tools that allow us to communicate with prospects and customers; (v) integration tools that allow us to capture data in one platform and send it to another; (vi) survey and poll tools that allows us to capture information about our Services; and (vii) event and meeting platforms that allow us to host and manage virtual and in-person events. Pursuant to our instructions, these parties may access, process or store Personal Data in the course of performing their duties to us and only as necessary to provide the services we request.

CircleCI may also disclose Personal Data when required to do so by law, such as to comply with a subpoena, bankruptcy proceedings, or similar legal process, or in response to lawful requests by public authorities, including to meet national security or law enforcement requirements, or when CircleCI believes in good faith that disclosure is reasonably necessary to protect the property or rights of CircleCI, third parties, or the public at large.

CircleCI may disclose Personal Data in connection with a merger, acquisition, or sale of all or a portion of its assets (a “Corporate Transaction”). If CircleCI is involved in a Corporate Transaction, you will be notified either via email and/or a prominent notice through the Service of any change in ownership or uses of your Personal Data, as well as any choices you may have regarding your Personal Data, or we will require any such buyer to agree to treat your Personal Data in accordance with this Privacy Policy.

In the preceding twelve (12) months, we have not sold our users’ personal information.

Access and Deletion Requests
You may visit https://privacy.circleci.com/ to request that we provide you with a copy of your Personal Data or that we delete your Personal Data that we maintain on our systems. We will respond to your request within a reasonable timeframe. If you are an EU or UK data subject or California resident, see your additional rights below.

Rights of Certain California Residents
The California Consumer Privacy Act (CCPA) and California Privacy Rights Act (CPRA) provide certain California residents with the additional rights listed below.

Right to Access. You have the right to request that we disclose certain information to you about our collection and use of your personal information over the past 12 months. Once we receive and confirm your verifiable consumer request, we will disclose to you:


  The categories of personal information we collected about you,
  The categories of sources for the personal information we collected about you,
  Our business or commercial purpose for collecting that personal information,
  The categories of third parties with whom we share that personal information, and
  The specific pieces of personal information we collected about you (which will also allow you to exercise your data portability right).


Data Portability Right. You have the right to request that we provide you with access to the information above (under Right to Access) in a readily useable format that allows you to transmit (i.e., port) the information to another entity without hindrance. If you make a request under your right to request access, you will receive access to your information in a readily useable format.

Right to Delete. You have the right to request that we delete any of your personal information that we collected from you and retained, subject to certain exceptions. Once we receive and confirm your verifiable consumer request, we will delete (and direct our service providers to delete) your personal information from our records, unless an exception applies.  You must contact the applicable business customers directly to delete your information that they have in their systems.

We may deny your deletion request or not delete some of your personal information, if retaining the information is necessary for us or our service provider(s) to:


  Complete the transaction for which we collected the personal information, provide a good or service that you requested, take actions reasonably anticipated within the context of our ongoing business relationship with you, or otherwise perform our contract with you.
  Detect security incidents, protect against malicious, deceptive, fraudulent, or illegal activity, or prosecute those responsible for such activities.
  Debug products to identify and repair errors that impair existing intended functionality.
  Exercise free speech, ensure the right of another consumer to exercise their free speech rights, or exercise another right provided for by law.
  Comply with the California Electronic Communications Privacy Act (Cal. Penal Code § 1546 et. seq.).
  Engage in public or peer-reviewed scientific, historical, or statistical research in the public interest that adheres to all other applicable ethics and privacy laws, when the information’s deletion may likely render impossible or seriously impair the research’s achievement, if you previously provided informed consent.
  Enable solely internal uses that are reasonably aligned with consumer expectations based on your relationship with us.
  Comply with a legal obligation.
  Make other internal and lawful uses of that information that are compatible with the context in which you provided it.


We may also limit our deletion to the extent permitted by applicable law.

Right to Update. You have the right to request that inaccurate personal information that we hold about you be corrected.

Right to restrict the use and disclosure of your sensitive information. You have the right to request that we limit our use and disclosure of your sensitive personal information.  We currently do not request or retain any sensitive personal information from our customers.

Categories of Personal Data collected by CircleCI. For more details on how we use the Personal Data, who we disclose it to for a business purpose, and how long we keep it for, please see the sections “Categories of Sources”, “Disclosure of Personal Data”, and “Data Retention” set forth above.

Categories of Personal Data disclosed for a business purpose. You have the right to request that we limit our use and disclosure of your sensitive personal information.  We currently do not request or retain any sensitive personal information from our customers.

Exercising Your Rights. To exercise your rights, please contact us as follows:


  Submit your request by visiting our Privacy Center at https://privacy.circleci.com/ and selecting your specific request (e.g., right to access, right to correct, or right to delete); or
  Email us at privacy@circleci.com and provide the following information:
    
      Full name and email address associated with your use of our Services, and
      Your specific request (e.g., right to access, right to portability, right to update or right to delete).
    
  


We will attempt to respond to a consumer request for access or deletion within 45 days of receiving that request. If we require more time, we will inform you of the reason and extension period in writing.

Only you, or someone legally authorized to act on your behalf, may make a verifiable consumer request related to your personal information.

You may only make a verifiable consumer request for access or data portability twice within a 12-month period.

Non-Discrimination. We will not discriminate against you for exercising any of your rights under the CCPA or CPRA. Unless permitted by the CCPA or CPRA, we will not:


  Deny you goods or services,
  Charge you different prices or rates for goods or services, including through granting discounts or other benefits, or imposing penalties,
  Provide you a different level or quality of goods or services, or
  Suggest that you may receive a different price or rate for goods or services or a different level or quality of goods or services.


However, we may offer you certain financial incentives permitted by the CCPA and CPRA that can result in different prices, rates, or quality levels. Any CCPA or CPRA-permitted financial incentive we offer will reasonably relate to your personal information’s value to CircleCI and contain written terms that describe the program’s material aspects. Participation in a financial incentive program requires your prior opt in consent, which you may revoke at any time. We currently do not provide any financial incentives.

No Sale or Sharing of Personal Information. We do not sell or share (for the purpose of cross-context behavioral advertising) your personal information, as those terms are defined under the CCPA/CPRA.

EU and UK Data Subjects
Scope: This section applies if you are an EU or UK data subject (for these purposes, reference to the EU also includes the European Economic Area countries of Iceland, Liechtenstein, Norway and, where applicable, Switzerland).

Data Controller: CircleCI is the data controller of Personal Data provided to, or collected by or for, our Services, but we may act as data processor on behalf of our customers for Personal Data that we process on their behalf when providing the Services.

Your Rights: Subject to applicable law, you have the following rights in relation to your Personal Data:


  Right of access: If you ask us, we will confirm whether we are processing your Personal Data and, if so, provide you with a copy of that Personal Data along with certain other details. If you require additional copies of the data, we may need to charge a reasonable fee.
  Right to rectification: If your Personal Data is inaccurate or incomplete, you are entitled to ask that we correct or complete it. If we shared your Personal Data with others, we will tell them about the correction where possible. If you ask us, and where possible and lawful to do so, we will also tell you with whom we shared your Personal Data so you can contact them directly.
  Right to erasure: You may ask us to delete or remove your Personal Data, such as where you withdraw your consent. If we shared your data with others, we will tell them about the erasure where possible. If you ask us, and where possible and lawful to do so, we will also tell you with whom we shared your Personal Data so you can contact them directly.
  Right to restrict processing: You may ask us to restrict or ‘block’ the processing of your Personal Data in certain circumstances, such as where you contest the accuracy of the data or object to us processing it. We will tell you before we lift any restriction on processing. If we shared your Personal Data with others, we will tell them about the restriction where possible. If you ask us, and where possible and lawful to do so, we will also tell you with whom we shared your Personal Data so you can contact them directly.
  Right to data portability: Effective 25 May 2018, you have the right to obtain your Personal Data from us that you consented to give us or that was provided to us as necessary in connection with our contract with you.  We will give you your Personal Data in a structured, commonly used and machine-readable format.  You may reuse it elsewhere.
  Right to object: You may ask us at any time to stop processing your Personal Data, and we will do so if we are processing your Personal Data for direct marketing and otherwise.  However, if we are relying on a legitimate interest to process your Personal Data and we demonstrate compelling legitimate grounds for the processing we may continue.
  Rights in relation to automated decision-making and profiling: You have the right to be free from decisions based solely on automated processing of your Personal Data, including profiling, that produce a significant legal effect on you, unless such profiling in necessary for entering into, or the performance of, a contract between you and us or you provide your explicit consent.
  Right to withdraw consent: If we rely on your consent to process your Personal Data, you have the right to withdraw that consent at any time. Withdrawal of consent will not affect any processing of your data before we received notice that you wished to unsubscribe.
  Right to lodge a complaint with the data protection authority: If you have a concern about our privacy practices, including the way we handled your Personal Data, you can report it to the data protection authority that is authorized to hear those concerns.


You may exercise your rights by visiting our Privacy Center at https://privacy.circleci.com/ and selecting your specific request (e.g., right of access, right to erasure, etc.).

Legitimate Interest. “Legitimate interests” means the interests of CircleCI in conducting and managing our organization. For example, we have a legitimate interest in processing your Personal Data to analyze how the Services are being used by you, and to ensure network and information security, as described in this Privacy Policy. When we process your Personal Data for our legitimate interests, we make sure to consider and balance any potential impact on you, and your rights under data protection laws. Our legitimate interests do not automatically override your interests. We will not use your Personal Data for activities where our interests are overridden by the impact on you, unless we have your consent or those activities are otherwise required or permitted to by law. You have the right to object to processing that is based on our legitimate interests. For more information on your rights, please see the “Your Rights” section above.

International Data Transfers from Europe
Your personal information may be transferred to CircleCI and its service providers in countries other than the country in which you are resident, including in the United States, and other locations where we have offices or employees. These countries may have data protection laws that are different from the laws of your country and may not provide the same level of protection as your country.

Model Clauses
If you are located in the European Economic Area, the UK or Switzerland, we will protect your personal information when it is transferred outside of your jurisdiction by (a) processing it in a territory that provides an adequate level of protection based on its data protection laws; (b) implementing appropriate safeguards to protect your personal information, such as relying on the European standard contractual clauses (“Model Clauses”); (c) by seeking your consent for transfers of your personal information for specific purposes; and/or (d) by relying on other transfer mechanisms approved by authorities in the country from which data are transferred. CircleCI relies on the Model Clauses for data transfers.

EU-U.S. Data Privacy Framework with UK Extension, and Swiss-U.S. Data Privacy Framework
CircleCI complies with the EU-U.S. Data Privacy Framework (“EU-U.S. DPF”), the UK Extension to the EU-U.S. DPF, and the Swiss-U.S. Data Privacy Framework (“Swiss-U.S. DPF”) as set forth by the U.S. Department of Commerce.  CircleCI has certified to the U.S. Department of Commerce that it adheres to the EU-U.S. Data Privacy Framework Principles (“EU-U.S. DPF Principles”) with regard to the processing of personal data received from the European Union in reliance on the EU-U.S. DPF and from the United Kingdom (and Gibraltar) under the UK Extension to the EU-U.S. DPF.  CircleCI has certified to the U.S. Department of Commerce that it adheres to the Swiss-U.S. Data Privacy Framework Principles (“Swiss-U.S. DPF Principles”) with regard to the processing of personal data received from Switzerland in reliance on the Swiss-U.S. DPF.  If there is any conflict between the terms in this privacy policy and the EU-U.S. DPF Principles and/or the Swiss-U.S. DPF Principles, the Principles shall govern.  To learn more about the Data Privacy Framework (“DPF”) program, and to view our certification, please visit https://www.dataprivacyframework.gov/.

CircleCI is responsible for the processing of personal data it receives, under the EU-U.S. DPF, the UK Extension to the EU-U.S. DPF, and Swiss-U.S. DPF and subsequently transfers to a third party acting as an agent on its behalf.  CircleCI complies with the EU-U.S. DPF Principles and the Swiss-U.S. DPF Principles for all onward transfers of personal data from the EU, UK, and Switzerland, including the onward transfer liability provisions.

The Federal Trade Commission has jurisdiction over CircleCI’s compliance with the EU-U.S. DPF, the UK Extension to the EU-U.S. DPF, and the Swiss-U.S. DPF. In certain situations, CircleCI may be required to disclose personal data in response to lawful requests by public authorities, including to meet national security or law enforcement requirements.

Recourse, Enforcement, Liability: In compliance with the EU-US DPF, the UK Extension to the EU-US DPF, and the Swiss-US DPF, CircleCI commits to resolve complaints about your privacy and our collection or use of your Personal Data. European Union, UK (and Gibraltar) or Swiss individuals with inquiries or complaints regarding this Privacy Policy should first contact CircleCI as follows:


  Email: privacy@circleci.com
  Phone: +1-800-585-7075
  Postal Mail:
Circle Internet Services, Inc.
Attention: Privacy
2261 Market Street, #22561
San Francisco, CA, 94114


In compliance with the EU-U.S. DPF, the UK Extension to the EU-U.S. DPF, and the Swiss-U.S. DPF, CircleCI commits to refer unresolved complaints concerning its handling of non-HR related personal data received in reliance on the EU-U.S. DPF, the UK Extension to the EU-U.S. DPF, and the Swiss-U.S. DPF to TRUSTe, an alternative dispute resolution provider based in the United States. For clarity, Non-HR related data includes all personal data processed by CircleCI on behalf of its customers.  If you do not receive timely acknowledgment of your DPF Principles-related complaint from us, or if we have not addressed your DPF Principles-related complaint to your satisfaction, please visit https://feedback-form.truste.com/watchdog/request for more information or to file a complaint.  The services of TRUSTe are provided to you at no cost.

Further, CircleCI commits to cooperate and comply with the advice of the panel established by the EU data protection authorities (DPAs), the UK Information Commissioner’s Office (ICO) and the Gibraltar Regulatory Authority (GRA) with regard to unresolved complaints concerning our handling of human resources personal data received in reliance on the EU-U.S. DPF and the UK Extension to the EU-U.S. DPF in the context of the employment relationship.

For complaints regarding EU-U.S. DPF, the UK Extension to the EU-U.S DPF, and Swiss-U.S. DPF compliance not resolved by any of the other DPF mechanisms, you have the possibility, under certain conditions, to invoke binding arbitration. Further information can be found on the official DPF website: https://www.dataprivacyframework.gov/s/article/ANNEX-I-introduction-dpf?tabset-35584=2.

Cookies
We and our partners use cookies or similar technologies to optimize the functionality of the Site, help us understand how the Site is used and provide you with interest-based advertising based upon a user’s browsing activities and interests. For more information about the cookies and similar technologies used on our Site, please refer to our Cookie Policy and Security page.

Links to Other Websites
This Privacy Policy applies only to the Services and not to any third-party sites or hosted services you may find or access through our Site. If you submit Personal Data to any of those sites or services, your information will be governed by their privacy policies. We encourage you to carefully read the privacy policy of any site you visit or hosted service you use.

Social Media Widgets
The Services may include social media features, such as the Twitter button, and widgets, such as the “share this” button or interactive mini-programs. These features may collect your IP address, which page you are visiting on the Site, and may set a cookie to enable the feature to function properly. Social media features and widgets are either hosted by a third party or hosted directly on the Services. Your interactions with these features are governed by the privacy policy of the company providing it.

Do Not Track
Currently, various browsers - including Microsoft Edge, Firefox, and Safari - offer a “do not track” or “DNT” option that relies on technology known as a DNT header, which sends a signal to the websites visited by the user about the user’s browsers DNT preference setting. CircleCI does not currently commit to responding to browser’s DNT preference across its Services, because no common industry standard for DNT has been adopted by industry groups, technology companies or regulators, including no consistent standard of interpreting user intent. CircleCI takes privacy and choices regarding privacy seriously and will make efforts to continue to monitor the development around DNT browser technology and the implementation of a standard for DNT.

Security
We take precautions to ensure the security of your Personal Data. We follow generally accepted standards to protect the Personal Data submitted to us, both during transmission and once we receive it. When you enter your login information on the Service, all information to and from the service is encrypted using Transport Layer Security (TLS). For more information on our data security policies, please check here.

That said, like any hosted service provider, we cannot guarantee that unauthorized third parties or unauthorized personnel will not gain access to your Personal Data despite our efforts. You should note that in using the Services, your information will travel through third-party infrastructures which are not under our control.

We cannot protect, nor does this Privacy Policy apply to, any information that you transmit to other users of the Services. You should never transmit personal or identifying information to other users.

If you have any questions about the security of the Services, you can contact us.

Privacy Policy Changes
Although most changes are likely to be minor, CircleCI may change its Privacy Policy from time to time, and in CircleCI’s sole discretion. If we make any material changes to this Privacy Policy, we will either notify you by email (sent to the email address specified in your account) or by means of a notice on or within the Services prior to the change becoming effective, or as otherwise required by the applicable law. We encourage you to periodically review the Site for the latest information on our privacy practices. Your continued use of the Services after any change in this Privacy Policy takes effect will constitute your acceptance of such change.

Contact Us
If you wish to make a request regarding your personal information, please visit our Privacy Center at https://privacy.circleci.com/ and select your specific request.

If you have questions or concerns about this Privacy Policy, please contact us at:

Circle Internet Services, Inc.
2261 Market Street, #22561
San Francisco, CA, 94114
Phone: +1-800-585-7075
Email: privacy@circleci.com\n\n\n\nCookie Policy
      
      
          Last Updated:
          
            March 19, 2025
          
      
      
        
This Cookie Policy (“Policy”) explains the different types of cookies and similar technologies that may be applied on the browsers and devices of consumers who visit https://circleci.com and https://discuss.circleci.com/, and any other websites (together the “Site”) owned by Circle Internet Services, Inc. dba CircleCI, a Delaware corporation (“CircleCI”, “we” or “us”) or who use our services, such as our continuous integration software and related technologies (the “Services”).

This Policy does not apply to the privacy practices of third-party websites which may be linked to this Site.

For more information about our data practices generally, see our Privacy Policy.

We may update this Policy from time to time in order to reflect, for example, changes to the cookies we use or for other operational, legal or regulatory reasons.  Please re-visit this Policy regularly to stay informed about our use of cookies and similar technologies. The date at the top of this Policy indicates when it was last updated.

If you have questions or concerns about this Policy, please contact us at:

Circle Internet Services, Inc.
2261 Market Street, #22561
San Francisco, CA, 94114
Phone: +1-800-585-7075
Email: privacy@circleci.com

Consent
By continuing to visit our Site or use our Services, you are agreeing to the use of cookies and other similar technologies for the purposes we describe in this Policy.

What are Cookies?
Cookies are small text files which are downloaded to your browser or device when you visit a website. Most web pages contain elements from multiple web domains so when you visit our Site and Services, your browser or device may receive cookies from several sources. This includes third parties that provide services on our behalf, such as site analytics or ad targeting.  In relation to the use of cookies by third parties, we do not have access or control over these cookies. We may also use local shared objects on our Site and Services to store your user preferences and settings. You can manage local shared objects by following the instructions here.

Our emails may contain a single, campaign-unique “web beacon pixel” to tell us whether our emails are opened and verify any clicks through to links within the email. We may use this information for purposes including determining which of our emails are more interesting to you and to query whether users who do not open our emails wish to continue receiving them. The pixel will be deleted when you delete the email.

Why do we use Cookies?
Our Site uses both 1st party cookies (which are set directly by us) and 3rd party cookies (which are set by third parties). We use 1st party and 3rd party cookies for several reasons. Some cookies are required for technical reasons in order for the Site and the Services to operate, and we refer to these as “Strictly Necessary” cookies. Some cookies allow us to measure and improve the performance of our Site and Services, such as by counting visits and traffic sources, and we refer to these as “Performance” cookies. Some cookies enable us to provide enhanced functionality and personalization on the Sites and Services, and we refer to these as “Functional” cookies. Finally, some cookies enable us and our partners to serve targeted advertisements, and we refer to these as “Targeting” cookies.  The specific types of 1st and 3rd party cookies served through the Site and the Services and the purposes they perform are described below.

Cookie Preferences and Disabling Cookies
Depending on where you are located, you may see a cookie notice pop up on our Site. You can set your cookie preferences for our Site by either clicking on Customize Settings or the Cookie Consent Manager. If you are not happy with the preferences that you previously set, follow these steps: (1) delete your cookies (see below for information on deleting cookies), (2) refresh the web page, and (3) open the cookie manager when the cookie preference notice pops up and reset your preferences.

If you do not agree to the use of these cookies, please disable or delete them by following the instructions for your browser(s) set out at http://www.allaboutcookies.org/manage-cookies/index.html. Please note that the Site and Services will not function well if cookies are disabled.  It may also stop you from saving customized settings, like login information.

If you delete your cookies, you will need to opt out again from targeted advertising (see below). You may download a browser extension that will help preserve the opt-out preferences you set by visiting www.aboutads.info/PMC.

Opting out of Targeted Advertising by Third Parties
For cookies that track activity in connection with targeting advertising, you can opt-out of third party targeting cookies on the Digital Advertising Alliance’s consumer choice page (http://optout.aboutads.info) or the Network Advertising Initiative’s consumer choice page (http://optout.networkadvertising.org) or the European Interactive Digital Advertising Alliance consumer choice page (http://youronlinechoices.eu).

Some of our third party targeting providers have their own opt-out mechanisms that are linked from their sites or their online-posted privacy policies. You should review the privacy policies of those companies for these opt-out links if you no longer wish to receive targeted advertising from a particular company, or multiple companies.

Please note that opting out from targeted advertising will not opt you out of being served advertising. You will continue to receive generic ads.

Other tools offered by third parties can help you see and manage the types of cookies and trackers that you encounter. More information about cookies and cookie management, including links to browser manufacturers’ cookie management pages, can be found on www.allaboutcookies.org and www.aboutcookies.org. For other browsers not included on www.aboutcookies.org, please consult the documentation that your browser manufacturer provides. If you access the Site on your mobile device, you may not be able to control tracking technologies through these settings.

After your initial visit to the Site and Services we may change the cookies and other technologies we use.

Current Cookies

Strictly Necessary Cookies
These cookies enable you to navigate the Sites and to use their services and features. These cookies are necessary for the website to function and cannot be switched off in our systems. They are usually only set in response to actions made by you which amount to a request for services, such as setting your privacy preferences, authenticating users, or logging in or filling in forms. You can set your browser to block or alert you about these cookies, but some parts of the site will not work.


  
    Cookie Name
    Provider
    Description of Purpose
    Expiration
  
  
    
      algoliasearch-client-js-#.#.#-01234VWXYZ
      assets-developer.circleci.com
      Necessary in order to optimize the website's search-bar function. The cookie ensures accurate and fast search results.
      Persistent
    
  
    
      object(#-#-##:#:#.#)
      cdn.amplitude.com
      Holds the users timezone.
      Persistent
    
  
    
      CookieConsent
      circleci.com
      Stores the user's cookie consent state for the current domain
      1 year
    
  
    
      dd_cookie_test_#
      circleci.com
      Registers data on visitors' website-behaviour. This is used for internal analysis and website optimization. 
      1 day
    
  
    
      optimizelyDomainTestCookie
      circleci.com
      Tracks the conversion rate between the user and the advertisement banners on the website - This serves to optimise the relevance of the advertisements on the website. 
      180 days
    
  
    
      optimizelyEndUserId
      circleci.com
      Used to measure how selected users react to targeted changes to the website's content and functionality, in order to determine what variation is most efficacious in terms of converting users to customers.
      180 days
    
  
    
      session_id
      d2qm0z2kzhiwa.cloudfront.net
      Preserves users states across page requests.
      Session
    
  
    
      uc_session
      dropboxusercontent.com
      Determines whether the user has accepted the cookie consent box. 
      Session
    
  
    
      rc::a
      gstatic.com
      This cookie is used to distinguish between humans and bots. This is beneficial for the website, in order to make valid reports on the use of their website.
      Persistent
    
  
    
      rc::b
      gstatic.com
      This cookie is used to distinguish between humans and bots. 
      Session
    
  
    
      rc::c
      gstatic.com
      This cookie is used to distinguish between humans and bots. 
      Session
    
  
    
      rc::f
      gstatic.com
      This cookie is used to distinguish between humans and bots. 
      Persistent
    
  
    
      __cf_bm
      hsadspixel.net
      This cookie is used to distinguish between humans and bots. This is beneficial for the website, in order to make valid reports on the use of their website.
      1 day
    
  
    
      __cf_bm
      hs-analytics.net
      This cookie is used to distinguish between humans and bots. This is beneficial for the website, in order to make valid reports on the use of their website.
      1 day
    
  
    
      __cf_bm
      hs-banner.com
      This cookie is used to distinguish between humans and bots. This is beneficial for the website, in order to make valid reports on the use of their website.
      1 day
    
  
    
      __cf_bm
      hscollectedforms.net
      This cookie is used to distinguish between humans and bots. This is beneficial for the website, in order to make valid reports on the use of their website.
      1 day
    
  
    
      __cf_bm
      hsforms.com
      This cookie is used to distinguish between humans and bots. This is beneficial for the website, in order to make valid reports on the use of their website.
      1 day
    
  
    
      _cfuvid
      hsforms.com
      This cookie is a part of the services provided by Cloudflare - Including load-balancing, deliverance of website content and serving DNS connection for website operators. 
      Session
    
  
    
      __cf_bm
      hsforms.net
      This cookie is used to distinguish between humans and bots. This is beneficial for the website, in order to make valid reports on the use of their website.
      1 day
    
  
    
      __cf_bm
      hs-scripts.com
      This cookie is used to distinguish between humans and bots. This is beneficial for the website, in order to make valid reports on the use of their website.
      1 day
    
  
    
      __cf_bm
      hubapi.com
      This cookie is used to distinguish between humans and bots. This is beneficial for the website, in order to make valid reports on the use of their website.
      1 day
    
  
    
      __cf_bm
      hubspot.com
      This cookie is used to distinguish between humans and bots. This is beneficial for the website, in order to make valid reports on the use of their website.
      1 day
    
  
    
      _cfuvid
      hubspot.com
      This cookie is a part of the services provided by Cloudflare - Including load-balancing, deliverance of website content and serving DNS connection for website operators. 
      Session
    
  
    
      li_gc
      linkedin.com
      Stores the user's cookie consent state for the current domain
      6 months
    
  
    
      _cfuvid
      medium.com
      This cookie is a part of the services provided by Cloudflare - Including load-balancing, deliverance of website content and serving DNS connection for website operators. 
      Session
    
  
    
      https://#_oeu#.#$$event_queue
      optimizely.com
      Stores event instances that are waiting to be added to the previous ...$$events key. https://support.optimizely.com/hc/en-us/articles/4410284260365-Cookies-and-localStorage-in-the-Optimizely-snippet
      Persistent
    
  
    
      https://#_oeu#.#$$layer_states
      optimizely.com
      Stores bucketing decision (variation and holdback assignment) for each layer in Optimizely Web & Optimizely Personalization.  https://support.optimizely.com/hc/en-us/articles/4410284260365-Cookies-and-localStorage-in-the-Optimizely-snippet
      Persistent
    
  
    
      https://#_oeu#.#$$session_state
      optimizely.com
      Tracks the session identifier and timestamp, which helps Optimizely identify sessions for analytics purposes.  https://support.optimizely.com/hc/en-us/articles/4410284260365-Cookies-and-localStorage-in-the-Optimizely-snippet
      Persistent
    
  
    
      https://#_oeu#.#$$tracker_optimizely
      optimizely.com
      Temporary storage for the batched sending of events to the Optimizely Event API. https://support.optimizely.com/hc/en-us/articles/4410284260365-Cookies-and-localStorage-in-the-Optimizely-snippet
      Persistent
    
  
    
      https://#_oeu#.#$$variation_map
      optimizely.com
      Records the variation that the visitor has seen for each experiment. This allows us to deliver a consistent experience on successive page loads. https://support.optimizely.com/hc/en-us/articles/4410284260365-Cookies-and-localStorage-in-the-Optimizely-snippet 
      Persistent
    
  
    
      https://#_oeu#.#$$visitor_profile
      optimizely.com
      Stores the visitor's values for various audience conditions.  This is particularly important for "sticky" conditions like Ad Campaign, Source Type, and Referrer for which we need to rely on the first observed value.  https://support.optimizely.com/hc/en-us/articles/4410284260365-Cookies-and-localStorage-in-the-Optimizely-snippet
      Persistent
    
  
    
      https://circleci.com_pending_events
      optimizely.com
      Temporary storage of XMLHttpRequest information, enabling the snippet to reliably send requests (e.g., to the Event API) even if the visitor navigates to a new page while a request is in progress.
      Persistent
    
  


Performance Cookies - Site features and services
These cookies and other technologies improve your experience by enabling personalization (like remembering if you’ve logged into our service before), as well as enabling certain features like chat support.  They can help you fill out forms on our Site more easily.


  
    Cookie Name
    Provider
    Description of Purpose
    Expiration
  
  
    
      storedOpenClose:primaryNavigation
      assets-authentication.circleci.com
      
      Persistent
    
  
    
      cci-customer
      circleci.com
      This cookie is used to determine if the visitor has signed into the CircleCI application. It allows to personalize the experience of the visitor. 
      2 years
    
  
    
      locale
      dropbox.com
      The cookie determines the preferred language and country-setting of the visitor - This allows the website to show content most relevant to that region and language.
      5 years
    
  
    
      gvc
      www.dropbox.com
      Used to implement or transfer content through Dropbox. 
      400 days
    
  


Functional Cookies - Analytics and Website Optimization
These cookies and other technologies help us learn how well our Site and Services are performing. We use these cookies to understand, improve, and research our Site and Services.


  
    Cookie Name
    Provider
    Description of Purpose
    Expiration
  
  
    
      fingerprint
      assets-developer.circleci.com
      Used to detect and log potential tracking errors.
      Persistent
    
  
    
      amplitude_unsent_#
      cdn.amplitude.com
      Registers data on visitors' website-behaviour. This is used for internal analysis and website optimization. 
      Persistent
    
  
    
      amplitude_unsent_identify_#
      cdn.amplitude.com
      Registers data on visitors' website-behaviour. This is used for internal analysis and website optimization. 
      Persistent
    
  
    
      ajs_anonymous_id
      cdn.segment.com
      This cookie is used to count how many times a website has been visited by different visitors - this is done by assigning the visitor an ID, so the visitor does not get registered twice.
      Persistent
    
  
    
      __hssc
      circleci.com
      Identifies if the cookie data needs to be updated in the visitor's browser.
      1 day
    
  
    
      __hssrc
      circleci.com
      Used to recognise the visitor's browser upon reentry on the website.
      Session
    
  
    
      __hstc
      circleci.com
      Sets a unique ID for the session. This allows the website to obtain data on visitor behaviour for statistical purposes.
      180 days
    
  
    
      __q_domainTest
      circleci.com
      Used in context with Account-Based-Marketing (ABM). The cookie registers data such as IP-addresses, time spent on the website and page requests for the visit. This is used for retargeting of multiple users rooting from the same IP-addresses. ABM usually facilitates B2B marketing purposes.
      Session
    
  
    
      _dd_s
      circleci.com
      Registers the website's speed and performance. This function can be used in context with statistics and load-balancing.
      1 day
    
  
    
      _ga
      circleci.com
      Registers a unique ID that is used to generate statistical data on how the visitor uses the website.
      2 years
    
  
    
      _ga_#
      circleci.com
      Used by Google Analytics to collect data on the number of times a user has visited the website as well as dates for the first and most recent visit. 
      2 years
    
  
    
      _gat
      circleci.com
      Used by Google Analytics to throttle request rate
      1 day
    
  
    
      _gid
      circleci.com
      Registers a unique ID that is used to generate statistical data on how the visitor uses the website.
      1 day
    
  
    
      _hjSession_#
      circleci.com
      Collects statistics on the visitor's visits to the website, such as the number of visits, average time spent on the website and what pages have been read.
      1 day
    
  
    
      _hjSessionUser_#
      circleci.com
      Collects statistics on the visitor's visits to the website, such as the number of visits, average time spent on the website and what pages have been read.
      1 year
    
  
    
      ajs_anonymous_id
      circleci.com
      This cookie is used to identify a specific visitor - this information is used to identify the number of specific visitors on a website.
      1 year
    
  
    
      amplitude_#
      circleci.com
      Registers statistical data on users' behaviour on the website. Used for internal analytics by the website operator. 
      10 years
    
  
    
      amplitude_id_#
      circleci.com
      Registers data on visitors' website-behaviour. This is used for internal analysis and website optimization. 
      10 years
    
  
    
      amplitude-session-id
      circleci.com
      These cookies are set by Amplitude analytics, which helps to better understand how the CircleCI website is used. 
      Session
    
  
    
      analytics-client-id
      circleci.com
      Client ID is a cookie that's stored in the client's browser and sent with each request to Google Analytics.
      Session
    
  
    
      closed-customer-banner
      circleci.com
      
      Session
    
  
    
      current_referrer
      circleci.com
      
      Session
    
  
    
      enterprise_customer
      circleci.com
      
      Session
    
  
    
      gitlab-onboarding
      circleci.com
      
      Session
    
  
    
      hubspotutk
      circleci.com
      Sets a unique ID for the session. This allows the website to obtain data on visitor behaviour for statistical purposes.
      180 days
    
  
    
      initial_referrer
      circleci.com
      
      Session
    
  
    
      t
      dropbox.com
      Stores data on which websites the user has visited.
      1 year
    
  
    
      __Host-#
      dropboxusercontent.com
      
      1 year
    
  
    
      collect
      google-analytics.com
      Used to send data to Google Analytics about the visitor's device and behavior. Tracks the visitor across devices and marketing channels.
      Session
    
  
    
      hjActiveViewportIds
      hotjar.com
      This cookie contains an ID string on the current session. This contains non-personal information on what subpages the visitor enters – this information is used to optimize the visitor's experience.
      Persistent
    
  
    
      hjViewportId
      hotjar.com
      Saves the user's screen size in order to adjust the size of images on the website.
      Session
    
  
    
      optimizely_data$$pending_events
      optimizely.com
      This cookie is set to make split-tests on the website, which optimizes the website's relevance towards the visitor – the cookie can also be set to improve the visitor's experience on a website.
      Persistent
    
  
    
      __Host-#
      www.dropbox.com
      
      1 year
    
  


Targeting Cookies
These cookies and other technologies collect information about the browsing habits associated with your device and are used to make advertising more relevant to you and your interests. Third parties provide these services in return for recognizing that you (or more accurately your device) have visited a certain Site. These third parties put down advertising cookies both when you visit our Site and Services and when you use their services and navigate away from our Site and Services.


  
    Cookie Name
    Provider
    Description of Purpose
    Expiration
  
  
    
      tuid
      a.usbrowserspeed.com
      Allows us to personalize and improve a visitor's experience on the site.
      1 year
    
  
    
      receive-cookie-deprecation
      adnxs.com
      Collects information on user behaviour on multiple websites. This information is used in order to optimize the relevance of advertisement on the website.
      3 months
    
  
    
      uuid
      alocdn.com
      This cookie is used to optimize ad relevance by collecting visitor data from multiple websites – this exchange of visitor data is normally provided by a third-party data-center or ad-exchange.
      1 year
    
  
    
      v1/beacon/img.gif
      b.6sc.co
      Used in context with Account-Based-Marketing (ABM). The cookie registers data such as IP-addresses, time spent on the website and page requests for the visit. This is used for retargeting of multiple users rooting from the same IP-addresses. ABM usually facilitates B2B marketing purposes.
      Session
    
  
    
      ajs_user_id
      cdn.segment.com
      Collects data on visitors' preferences and behaviour on the website - This information is used make content and advertisement more relevant to the specific visitor. 
      Persistent
    
  
    
      __q_state_Q2nN3hknkeUxhVKm
      circleci.com
      Qualified Chat. Needed for the functionality of the website’s chat-box function.
      10 years
    
  
    
      __tld__
      circleci.com
      Used to track visitors on multiple websites, in order to present relevant advertisement based on the visitor's preferences. 
      Session
    
  
    
      _an_uid
      circleci.com
      Presents the user with relevant content and advertisement. The service is provided by third-party advertisement hubs, which facilitate real-time bidding for advertisers.
      7 days
    
  
    
      _gcl_au
      circleci.com
      Used by Google AdSense for experimenting with advertisement efficiency across websites using their services.  
      3 months
    
  
    
      _gd_session
      circleci.com
      Collects visitor data related to the user's visits to the website, such as the number of visits, average time spent on the website and what pages have been loaded, with the purpose of displaying targeted ads.
      1 day
    
  
    
      _gd_visitor
      circleci.com
      Collects visitor data related to the user's visits to the website, such as the number of visits, average time spent on the website and what pages have been loaded, with the purpose of displaying targeted ads.
      2 years
    
  
    
      _jeevageo
      circleci.com
      Tracks the visitor's geographical location.
      Session
    
  
    
      _jeevaloaded
      circleci.com
      Whether or not the script loaded for the visitor.
      Session
    
  
    
      _jeevaresolve
      circleci.com
      An infotap.com cookie that helps improve visitors' experience on the website.
      Session
    
  
    
      _jeevasessionID
      circleci.com
      The visitor's session ID.
      Session
    
  
    
      _jeevatd
      circleci.com
      An infotap.com cookie that helps improve visitors' experience on the website.
      Session
    
  
    
      _jeevauid
      circleci.com
      The visitor's Jeeva user ID.
      Session
    
  
    
      _lc2_fpi
      circleci.com
      Registers user behaviour and navigation on the website, and any interaction with active campaigns. This is used for optimizing advertisement and for efficient retargeting.  
      2 years
    
  
    
      _lc2_fpi_js
      circleci.com
      This cookie is set by LiveIntent. A random, unique, device identifier, stored as a 1st party cookie, to enable targeted advertising
      Session
    
  
    
      _li_dcdm_c
      circleci.com
      Registers user behaviour and navigation on the website, and any interaction with active campaigns. This is used for optimizing advertisement and for efficient retargeting.  
      Session
    
  
    
      _mkto_trk
      circleci.com
      Contains data on visitor behaviour and website interaction. This is used in context with the email marketing service Marketo.com, which allows the website to target visitors via email. 
      Session
    
  
    
      ajs_user_id
      circleci.com
      This cookie is used to collect data on the visitor's behavior on the website - this information can be used to assign the visitor to a visitor segment, based on common preferences.
      Session
    
  
    
      amplitude_cookie_test
      circleci.com
      Detects whether partner data synchronization is functioning and currently running - This function sends user data between third-party advertisement companies for the purpose of targeted advertisements.  
      Session
    
  
    
      fbclid
      circleci.com
      Facebook click identifier
      Session
    
  
    
      gclid
      circleci.com
      Used to send data to Google Analytics about the visitor's device and behavior. Tracks the visitor across devices and marketing channels.
      Session
    
  
    
      msclkid
      circleci.com
      Microsoft Click ID (MSCLKID)
      Session
    
  
    
      optimizelyOptOut
      circleci.com
      Collects visitor data related to the user's visits to the website, such as the number of visits, average time spent on the website and what pages have been loaded, with the purpose of displaying targeted ads.
      Session
    
  
    
      sa-user-id
      circleci.com
      Used to track visitors on multiple websites, in order to present relevant advertisement based on the visitor's preferences. 
      1 year
    
  
    
      sa-user-id-v2
      circleci.com
      Used to track visitors on multiple websites, in order to present relevant advertisement based on the visitor's preferences. 
      1 year
    
  
    
      sa-user-id-v3
      circleci.com
      Collects data on the user across websites - This data is used to make advertisement more relevant.
      1 year
    
  
    
      utm_content
      circleci.com
      Used to send data to Google Analytics about the visitor's device and behavior. Tracks the visitor across devices and marketing channels.
      Session
    
  
    
      utm_medium
      circleci.com
      Collects information on user preferences and/or interaction with web-campaign content - This is used on CRM-campaign-platform used by website owners for promoting events or products.
      Session
    
  
    
      utm_source
      circleci.com
      Determines how the user accessed the website. This information is used by the website operator in order to measure the efficiency of their marketing.    
      Session
    
  
    
      utm_term
      circleci.com
      Determines how the user accessed the website. This information is used by the website operator in order to measure the efficiency of their marketing.    
      Session
    
  
    
      circleciAnonymousId
      d2qm0z2kzhiwa.cloudfront.net
      Content caching.
      Persistent
    
  
    
      meApiDone
      d2qm0z2kzhiwa.cloudfront.net
      Content caching.
      Session
    
  
    
      IDE
      doubleclick.net
      Used by Google DoubleClick to register and report the website user's actions after viewing or clicking one of the advertiser's ads with the purpose of measuring the efficacy of an ad and to present targeted ads to the user.
      400 days
    
  
    
      test_cookie
      doubleclick.net
      Used to check if the user's browser supports cookies.
      1 day
    
  
    
      gvc
      dropboxusercontent.com
      
      5 years
    
  
    
      _GRECAPTCHA
      google.com
      This cookie is used to distinguish between humans and bots. This is beneficial for the website, in order to make valid reports on the use of their website.
      180 days
    
  
    
      NID
      google.com
      
      6 months
    
  
    
      pagead/1p-conversion/#/
      google.com
      
      Session
    
  
    
      pagead/1p-user-list/#
      google.com
      Tracks if the user has shown interest in specific products or events across multiple websites and detects how the user navigates between sites. This is used for measurement of advertisement efforts and facilitates payment of referral-fees between websites.
      Session
    
  
    
      csi
      gstatic.com
      Collects data on visitors' preferences and behaviour on the website - This information is used make content and advertisement more relevant to the specific visitor. 
      Session
    
  
    
      __ptq.gif
      hubspot.com
      Sends data to the marketing platform Hubspot about the visitor's device and behaviour. Tracks the visitor across devices and marketing channels.
      Session
    
  
    
      __q_local_form_debug
      js.qualified.com
      Tracks website visitor interaction with the Qualified Chat Messenger. Stored in the website visitor’s browser as well as the Qualified Service.
      Persistent
    
  
    
      _li_duid
      liadm.com
      Collects information on user behaviour on multiple websites. This information is used in order to optimize the relevance of advertisement on the website.
      Persistent
    
  
    
      lidid
      liadm.com
      Collects data on visitors' behaviour and interaction - This is used to make advertisement on the website more relevant. The cookie also allows the website to detect any referrals from other websites.  
      400 days
    
  
    
      p
      liadm.com
      Used to track visitors on multiple websites, in order to present relevant advertisement based on the visitor's preferences. 
      Session
    
  
    
      bcookie
      linkedin.com
      Used by the social networking service, LinkedIn, for tracking the use of embedded services.
      1 year
    
  
    
      lidc
      linkedin.com
      Used by the social networking service, LinkedIn, for tracking the use of embedded services.
      2 days
    
  
    
      A/N{39}
      opps-api.getwarmly.com
      Engages with the warmly.ai API to set up tools to optimize website visitor data.
      1 year
    
  
    
      ClientSessionStore
      opps-widget.getwarmly.com
      Optimizes data from 3rd party tools to track website visitors who are ready to learn more or engage further.
      Persistent
    
  
    
      MediaStore-client
      opps-widget.getwarmly.com
      Optimizes data from 3rd party tools to track website visitors who are ready to learn more or engage further.
      Persistent
    
  
    
      warmly_fingerprint
      opps-widget.getwarmly.com
      Personalization for users to engage with website using chat.
      Persistent
    
  
    
      WidgetStore
      opps-widget.getwarmly.com
      Optimizes data from 3rd party tools to track website visitors who are ready to learn more or engage further.
      Persistent
    
  
    
      optimizely_data$$#$$event_queue
      optimizely.com
      
      Persistent
    
  
    
      optimizely_data$$#$$layer_states
      optimizely.com
      
      Persistent
    
  
    
      optimizely_data$$#$$session_state
      optimizely.com
      
      Persistent
    
  
    
      optimizely_data$$#$$tracker_optimizely
      optimizely.com
      
      Persistent
    
  
    
      optimizely_data$$#$$variation_map
      optimizely.com
      
      Persistent
    
  
    
      optimizely_data$$#$$visitor_profile
      optimizely.com
      
      Persistent
    
  
    
      _jeevauid
      r2d2-inbound-js-store-production.s3.us-east-1.amazonaws.com
      Sales enablement and personalization.
      Persistent
    
  
    
      sa-user-id
      stackadapt.com
      Used to track visitors on multiple websites, in order to present relevant advertisement based on the visitor's preferences. 
      Persistent
    
  
    
      sa-user-id
      stackadapt.com
      Used to track visitors on multiple websites, in order to present relevant advertisement based on the visitor's preferences. 
      1 year
    
  
    
      sa-user-id-v2
      stackadapt.com
      Used to track visitors on multiple websites, in order to present relevant advertisement based on the visitor's preferences. 
      1 year
    
  
    
      sa-user-id-v2
      stackadapt.com
      Used to track visitors on multiple websites, in order to present relevant advertisement based on the visitor's preferences. 
      Persistent
    
  
    
      sa-user-id-v3
      stackadapt.com
      Collects data on the user across websites - This data is used to make advertisement more relevant.
      Persistent
    
  
    
      sa-user-id-v3
      stackadapt.com
      Collects data on the user across websites - This data is used to make advertisement more relevant.
      1 year
    
  
    
      _gcl_ls
      www.googletagmanager.com
      Conversion Linker tags store ad click information in browser local storage.
      Persistent
    
  
    
      #-#
      youtube.com
      Used to track user’s interaction with embedded content.
      Session
    
  
    
      __Secure-ROLLOUT_TOKEN
      youtube.com
      
      180 days
    
  
    
      iU5q-!O9@$
      youtube.com
      Registers a unique ID to keep statistics of what videos from YouTube the user has seen.
      Session
    
  
    
      LAST_RESULT_ENTRY_KEY
      youtube.com
      Used to track user’s interaction with embedded content.
      Session
    
  
    
      LogsDatabaseV2:V#||LogsRequestsStore
      youtube.com
      Used to track user’s interaction with embedded content.
      Persistent
    
  
    
      nextId
      youtube.com
      Used to track user’s interaction with embedded content.
      Session
    
  
    
      remote_sid
      youtube.com
      Necessary for the implementation and functionality of YouTube video-content on the website.  
      Session
    
  
    
      requests
      youtube.com
      Used to track user’s interaction with embedded content.
      Session
    
  
    
      ServiceWorkerLogsDatabase#SWHealthLog
      youtube.com
      Necessary for the implementation and functionality of YouTube video-content on the website.  
      Persistent
    
  
    
      TESTCOOKIESENABLED
      youtube.com
      Used to track user’s interaction with embedded content.
      1 day
    
  
    
      VISITOR_INFO1_LIVE
      youtube.com
      Tries to estimate the users' bandwidth on pages with integrated YouTube videos.
      180 days
    
  
    
      YSC
      youtube.com
      Registers a unique ID to keep statistics of what videos from YouTube the user has seen.
      Session
    
  
    
      yt.innertube::nextId
      youtube.com
      Registers a unique ID to keep statistics of what videos from YouTube the user has seen.
      Persistent
    
  
    
      ytidb::LAST_RESULT_ENTRY_KEY
      youtube.com
      Stores the user's video player preferences using embedded YouTube video
      Persistent
    
  
    
      YtIdbMeta#databases
      youtube.com
      Used to track user’s interaction with embedded content.
      Persistent
    
  
    
      yt-remote-cast-available
      youtube.com
      Stores the user's video player preferences using embedded YouTube video
      Session
    
  
    
      yt-remote-cast-installed
      youtube.com
      Stores the user's video player preferences using embedded YouTube video
      Session
    
  
    
      yt-remote-connected-devices
      youtube.com
      Stores the user's video player preferences using embedded YouTube video
      Persistent
    
  
    
      yt-remote-device-id
      youtube.com
      Stores the user's video player preferences using embedded YouTube video
      Persistent
    
  
    
      yt-remote-fast-check-period
      youtube.com
      Stores the user's video player preferences using embedded YouTube video
      Session
    
  
    
      yt-remote-session-app
      youtube.com
      Stores the user's video player preferences using embedded YouTube video
      Session
    
  
    
      yt-remote-session-name
      youtube.com
      Stores the user's video player preferences using embedded YouTube video
      Session
    
  


Unclassified
Unclassified cookies are cookies that we are in the process of classifying, together with the providers of individual cookies.


  
    Cookie Name
    Provider
    Description of Purpose
    Expiration\n\nLegal
  







  
    
      
        
        
        
          
          
            
              
                Software as a Service Agreement
              
            
            
          
        
          
          
            
              
                Software License Agreement
              
            
            
          
        
          
          
            
              
                AI Functionality Terms
              
            
            
          
        
          
          
            
              
                Code Sharing Terms of Service
              
            
            
          
        
          
          
            
              
                Self-Hosted Applications Terms
              
            
            
          
        
          
          
            
              
                Acceptable Use Policy
              
            
            
          
        
          
          
            
              
                Cookie Policy
              
            
            
              
              


  Consent
  What are Cookies?
  Why do we use Cookies?
  Cookie Preferences and Disabling Cookies
  Opting out of Targeted Advertising by Third Parties
  Current Cookies    
      Strictly Necessary Cookies
      Performance Cookies - Site features and services
      Functional Cookies - Analytics and Website Optimization
      Targeting Cookies
      Unclassified
    
  




            
          
        
          
          
            
              
                Privacy Policy
              
            
            
          
        
          
          
            
              
                CircleCI’s Commitment to Data Privacy
              
            
            
          
        
          
          
            
              
                 Trademark Usage Guidelines
              
            
            
          
        
          
          
            
              
                Copyright Infringement Notice and Takedown Policy
              
            
            
          
        
          
          
            
              
                Website Terms of Use
              
            
            
          
        
      
    
  
  
    
      
        Cookie Policy
      
      
          Last Updated:
          
            March 19, 2025
          
      
      
        
This Cookie Policy (“Policy”) explains the different types of cookies and similar technologies that may be applied on the browsers and devices of consumers who visit https://circleci.com and https://discuss.circleci.com/, and any other websites (together the “Site”) owned by Circle Internet Services, Inc. dba CircleCI, a Delaware corporation (“CircleCI”, “we” or “us”) or who use our services, such as our continuous integration software and related technologies (the “Services”).

This Policy does not apply to the privacy practices of third-party websites which may be linked to this Site.

For more information about our data practices generally, see our Privacy Policy.

We may update this Policy from time to time in order to reflect, for example, changes to the cookies we use or for other operational, legal or regulatory reasons.  Please re-visit this Policy regularly to stay informed about our use of cookies and similar technologies. The date at the top of this Policy indicates when it was last updated.

If you have questions or concerns about this Policy, please contact us at:

Circle Internet Services, Inc.
2261 Market Street, #22561
San Francisco, CA, 94114
Phone: +1-800-585-7075
Email: privacy@circleci.com

Consent
By continuing to visit our Site or use our Services, you are agreeing to the use of cookies and other similar technologies for the purposes we describe in this Policy.

What are Cookies?
Cookies are small text files which are downloaded to your browser or device when you visit a website. Most web pages contain elements from multiple web domains so when you visit our Site and Services, your browser or device may receive cookies from several sources. This includes third parties that provide services on our behalf, such as site analytics or ad targeting.  In relation to the use of cookies by third parties, we do not have access or control over these cookies. We may also use local shared objects on our Site and Services to store your user preferences and settings. You can manage local shared objects by following the instructions here.

Our emails may contain a single, campaign-unique “web beacon pixel” to tell us whether our emails are opened and verify any clicks through to links within the email. We may use this information for purposes including determining which of our emails are more interesting to you and to query whether users who do not open our emails wish to continue receiving them. The pixel will be deleted when you delete the email.

Why do we use Cookies?
Our Site uses both 1st party cookies (which are set directly by us) and 3rd party cookies (which are set by third parties). We use 1st party and 3rd party cookies for several reasons. Some cookies are required for technical reasons in order for the Site and the Services to operate, and we refer to these as “Strictly Necessary” cookies. Some cookies allow us to measure and improve the performance of our Site and Services, such as by counting visits and traffic sources, and we refer to these as “Performance” cookies. Some cookies enable us to provide enhanced functionality and personalization on the Sites and Services, and we refer to these as “Functional” cookies. Finally, some cookies enable us and our partners to serve targeted advertisements, and we refer to these as “Targeting” cookies.  The specific types of 1st and 3rd party cookies served through the Site and the Services and the purposes they perform are described below.

Cookie Preferences and Disabling Cookies
Depending on where you are located, you may see a cookie notice pop up on our Site. You can set your cookie preferences for our Site by either clicking on Customize Settings or the Cookie Consent Manager. If you are not happy with the preferences that you previously set, follow these steps: (1) delete your cookies (see below for information on deleting cookies), (2) refresh the web page, and (3) open the cookie manager when the cookie preference notice pops up and reset your preferences.

If you do not agree to the use of these cookies, please disable or delete them by following the instructions for your browser(s) set out at http://www.allaboutcookies.org/manage-cookies/index.html. Please note that the Site and Services will not function well if cookies are disabled.  It may also stop you from saving customized settings, like login information.

If you delete your cookies, you will need to opt out again from targeted advertising (see below). You may download a browser extension that will help preserve the opt-out preferences you set by visiting www.aboutads.info/PMC.

Opting out of Targeted Advertising by Third Parties
For cookies that track activity in connection with targeting advertising, you can opt-out of third party targeting cookies on the Digital Advertising Alliance’s consumer choice page (http://optout.aboutads.info) or the Network Advertising Initiative’s consumer choice page (http://optout.networkadvertising.org) or the European Interactive Digital Advertising Alliance consumer choice page (http://youronlinechoices.eu).

Some of our third party targeting providers have their own opt-out mechanisms that are linked from their sites or their online-posted privacy policies. You should review the privacy policies of those companies for these opt-out links if you no longer wish to receive targeted advertising from a particular company, or multiple companies.

Please note that opting out from targeted advertising will not opt you out of being served advertising. You will continue to receive generic ads.

Other tools offered by third parties can help you see and manage the types of cookies and trackers that you encounter. More information about cookies and cookie management, including links to browser manufacturers’ cookie management pages, can be found on www.allaboutcookies.org and www.aboutcookies.org. For other browsers not included on www.aboutcookies.org, please consult the documentation that your browser manufacturer provides. If you access the Site on your mobile device, you may not be able to control tracking technologies through these settings.

After your initial visit to the Site and Services we may change the cookies and other technologies we use.

Current Cookies

Strictly Necessary Cookies
These cookies enable you to navigate the Sites and to use their services and features. These cookies are necessary for the website to function and cannot be switched off in our systems. They are usually only set in response to actions made by you which amount to a request for services, such as setting your privacy preferences, authenticating users, or logging in or filling in forms. You can set your browser to block or alert you about these cookies, but some parts of the site will not work.


  
    Cookie Name
    Provider
    Description of Purpose
    Expiration
  
  
    
      algoliasearch-client-js-#.#.#-01234VWXYZ
      assets-developer.circleci.com
      Necessary in order to optimize the website's search-bar function. The cookie ensures accurate and fast search results.
      Persistent
    
  
    
      object(#-#-##:#:#.#)
      cdn.amplitude.com
      Holds the users timezone.
      Persistent
    
  
    
      CookieConsent
      circleci.com
      Stores the user's cookie consent state for the current domain
      1 year
    
  
    
      dd_cookie_test_#
      circleci.com
      Registers data on visitors' website-behaviour. This is used for internal analysis and website optimization. 
      1 day
    
  
    
      optimizelyDomainTestCookie
      circleci.com
      Tracks the conversion rate between the user and the advertisement banners on the website - This serves to optimise the relevance of the advertisements on the website. 
      180 days
    
  
    
      optimizelyEndUserId
      circleci.com
      Used to measure how selected users react to targeted changes to the website's content and functionality, in order to determine what variation is most efficacious in terms of converting users to customers.
      180 days
    
  
    
      session_id
      d2qm0z2kzhiwa.cloudfront.net
      Preserves users states across page requests.
      Session
    
  
    
      uc_session
      dropboxusercontent.com
      Determines whether the user has accepted the cookie consent box. 
      Session
    
  
    
      rc::a
      gstatic.com
      This cookie is used to distinguish between humans and bots. This is beneficial for the website, in order to make valid reports on the use of their website.
      Persistent
    
  
    
      rc::b
      gstatic.com
      This cookie is used to distinguish between humans and bots. 
      Session
    
  
    
      rc::c
      gstatic.com
      This cookie is used to distinguish between humans and bots. 
      Session
    
  
    
      rc::f
      gstatic.com
      This cookie is used to distinguish between humans and bots. 
      Persistent
    
  
    
      __cf_bm
      hsadspixel.net
      This cookie is used to distinguish between humans and bots. This is beneficial for the website, in order to make valid reports on the use of their website.
      1 day
    
  
    
      __cf_bm
      hs-analytics.net
      This cookie is used to distinguish between humans and bots. This is beneficial for the website, in order to make valid reports on the use of their website.
      1 day
    
  
    
      __cf_bm
      hs-banner.com
      This cookie is used to distinguish between humans and bots. This is beneficial for the website, in order to make valid reports on the use of their website.
      1 day
    
  
    
      __cf_bm
      hscollectedforms.net
      This cookie is used to distinguish between humans and bots. This is beneficial for the website, in order to make valid reports on the use of their website.
      1 day
    
  
    
      __cf_bm
      hsforms.com
      This cookie is used to distinguish between humans and bots. This is beneficial for the website, in order to make valid reports on the use of their website.
      1 day
    
  
    
      _cfuvid
      hsforms.com
      This cookie is a part of the services provided by Cloudflare - Including load-balancing, deliverance of website content and serving DNS connection for website operators. 
      Session
    
  
    
      __cf_bm
      hsforms.net
      This cookie is used to distinguish between humans and bots. This is beneficial for the website, in order to make valid reports on the use of their website.
      1 day
    
  
    
      __cf_bm
      hs-scripts.com
      This cookie is used to distinguish between humans and bots. This is beneficial for the website, in order to make valid reports on the use of their website.
      1 day
    
  
    
      __cf_bm
      hubapi.com
      This cookie is used to distinguish between humans and bots. This is beneficial for the website, in order to make valid reports on the use of their website.
      1 day
    
  
    
      __cf_bm
      hubspot.com
      This cookie is used to distinguish between humans and bots. This is beneficial for the website, in order to make valid reports on the use of their website.
      1 day
    
  
    
      _cfuvid
      hubspot.com
      This cookie is a part of the services provided by Cloudflare - Including load-balancing, deliverance of website content and serving DNS connection for website operators. 
      Session
    
  
    
      li_gc
      linkedin.com
      Stores the user's cookie consent state for the current domain
      6 months
    
  
    
      _cfuvid
      medium.com
      This cookie is a part of the services provided by Cloudflare - Including load-balancing, deliverance of website content and serving DNS connection for website operators. 
      Session
    
  
    
      https://#_oeu#.#$$event_queue
      optimizely.com
      Stores event instances that are waiting to be added to the previous ...$$events key. https://support.optimizely.com/hc/en-us/articles/4410284260365-Cookies-and-localStorage-in-the-Optimizely-snippet
      Persistent
    
  
    
      https://#_oeu#.#$$layer_states
      optimizely.com
      Stores bucketing decision (variation and holdback assignment) for each layer in Optimizely Web & Optimizely Personalization.  https://support.optimizely.com/hc/en-us/articles/4410284260365-Cookies-and-localStorage-in-the-Optimizely-snippet
      Persistent
    
  
    
      https://#_oeu#.#$$session_state
      optimizely.com
      Tracks the session identifier and timestamp, which helps Optimizely identify sessions for analytics purposes.  https://support.optimizely.com/hc/en-us/articles/4410284260365-Cookies-and-localStorage-in-the-Optimizely-snippet
      Persistent
    
  
    
      https://#_oeu#.#$$tracker_optimizely
      optimizely.com
      Temporary storage for the batched sending of events to the Optimizely Event API. https://support.optimizely.com/hc/en-us/articles/4410284260365-Cookies-and-localStorage-in-the-Optimizely-snippet
      Persistent
    
  
    
      https://#_oeu#.#$$variation_map
      optimizely.com
      Records the variation that the visitor has seen for each experiment. This allows us to deliver a consistent experience on successive page loads. https://support.optimizely.com/hc/en-us/articles/4410284260365-Cookies-and-localStorage-in-the-Optimizely-snippet 
      Persistent
    
  
    
      https://#_oeu#.#$$visitor_profile
      optimizely.com
      Stores the visitor's values for various audience conditions.  This is particularly important for "sticky" conditions like Ad Campaign, Source Type, and Referrer for which we need to rely on the first observed value.  https://support.optimizely.com/hc/en-us/articles/4410284260365-Cookies-and-localStorage-in-the-Optimizely-snippet
      Persistent
    
  
    
      https://circleci.com_pending_events
      optimizely.com
      Temporary storage of XMLHttpRequest information, enabling the snippet to reliably send requests (e.g., to the Event API) even if the visitor navigates to a new page while a request is in progress.
      Persistent
    
  


Performance Cookies - Site features and services
These cookies and other technologies improve your experience by enabling personalization (like remembering if you’ve logged into our service before), as well as enabling certain features like chat support.  They can help you fill out forms on our Site more easily.


  
    Cookie Name
    Provider
    Description of Purpose
    Expiration
  
  
    
      storedOpenClose:primaryNavigation
      assets-authentication.circleci.com
      
      Persistent
    
  
    
      cci-customer
      circleci.com
      This cookie is used to determine if the visitor has signed into the CircleCI application. It allows to personalize the experience of the visitor. 
      2 years
    
  
    
      locale
      dropbox.com
      The cookie determines the preferred language and country-setting of the visitor - This allows the website to show content most relevant to that region and language.
      5 years
    
  
    
      gvc
      www.dropbox.com
      Used to implement or transfer content through Dropbox. 
      400 days
    
  


Functional Cookies - Analytics and Website Optimization
These cookies and other technologies help us learn how well our Site and Services are performing. We use these cookies to understand, improve, and research our Site and Services.


  
    Cookie Name
    Provider
    Description of Purpose
    Expiration
  
  
    
      fingerprint
      assets-developer.circleci.com
      Used to detect and log potential tracking errors.
      Persistent
    
  
    
      amplitude_unsent_#
      cdn.amplitude.com
      Registers data on visitors' website-behaviour. This is used for internal analysis and website optimization. 
      Persistent
    
  
    
      amplitude_unsent_identify_#
      cdn.amplitude.com
      Registers data on visitors' website-behaviour. This is used for internal analysis and website optimization. 
      Persistent
    
  
    
      ajs_anonymous_id
      cdn.segment.com
      This cookie is used to count how many times a website has been visited by different visitors - this is done by assigning the visitor an ID, so the visitor does not get registered twice.
      Persistent
    
  
    
      __hssc
      circleci.com
      Identifies if the cookie data needs to be updated in the visitor's browser.
      1 day
    
  
    
      __hssrc
      circleci.com
      Used to recognise the visitor's browser upon reentry on the website.
      Session
    
  
    
      __hstc
      circleci.com
      Sets a unique ID for the session. This allows the website to obtain data on visitor behaviour for statistical purposes.
      180 days
    
  
    
      __q_domainTest
      circleci.com
      Used in context with Account-Based-Marketing (ABM). The cookie registers data such as IP-addresses, time spent on the website and page requests for the visit. This is used for retargeting of multiple users rooting from the same IP-addresses. ABM usually facilitates B2B marketing purposes.
      Session
    
  
    
      _dd_s
      circleci.com
      Registers the website's speed and performance. This function can be used in context with statistics and load-balancing.
      1 day
    
  
    
      _ga
      circleci.com
      Registers a unique ID that is used to generate statistical data on how the visitor uses the website.
      2 years
    
  
    
      _ga_#
      circleci.com
      Used by Google Analytics to collect data on the number of times a user has visited the website as well as dates for the first and most recent visit. 
      2 years
    
  
    
      _gat
      circleci.com
      Used by Google Analytics to throttle request rate
      1 day
    
  
    
      _gid
      circleci.com
      Registers a unique ID that is used to generate statistical data on how the visitor uses the website.
      1 day
    
  
    
      _hjSession_#
      circleci.com
      Collects statistics on the visitor's visits to the website, such as the number of visits, average time spent on the website and what pages have been read.
      1 day
    
  
    
      _hjSessionUser_#
      circleci.com
      Collects statistics on the visitor's visits to the website, such as the number of visits, average time spent on the website and what pages have been read.
      1 year
    
  
    
      ajs_anonymous_id
      circleci.com
      This cookie is used to identify a specific visitor - this information is used to identify the number of specific visitors on a website.
      1 year
    
  
    
      amplitude_#
      circleci.com
      Registers statistical data on users' behaviour on the website. Used for internal analytics by the website operator. 
      10 years
    
  
    
      amplitude_id_#
      circleci.com
      Registers data on visitors' website-behaviour. This is used for internal analysis and website optimization. 
      10 years
    
  
    
      amplitude-session-id
      circleci.com
      These cookies are set by Amplitude analytics, which helps to better understand how the CircleCI website is used. 
      Session
    
  
    
      analytics-client-id
      circleci.com
      Client ID is a cookie that's stored in the client's browser and sent with each request to Google Analytics.
      Session
    
  
    
      closed-customer-banner
      circleci.com
      
      Session
    
  
    
      current_referrer
      circleci.com
      
      Session
    
  
    
      enterprise_customer
      circleci.com
      
      Session
    
  
    
      gitlab-onboarding
      circleci.com
      
      Session
    
  
    
      hubspotutk
      circleci.com
      Sets a unique ID for the session. This allows the website to obtain data on visitor behaviour for statistical purposes.
      180 days
    
  
    
      initial_referrer
      circleci.com
      
      Session
    
  
    
      t
      dropbox.com
      Stores data on which websites the user has visited.
      1 year
    
  
    
      __Host-#
      dropboxusercontent.com
      
      1 year
    
  
    
      collect
      google-analytics.com
      Used to send data to Google Analytics about the visitor's device and behavior. Tracks the visitor across devices and marketing channels.
      Session
    
  
    
      hjActiveViewportIds
      hotjar.com
      This cookie contains an ID string on the current session. This contains non-personal information on what subpages the visitor enters – this information is used to optimize the visitor's experience.
      Persistent
    
  
    
      hjViewportId
      hotjar.com
      Saves the user's screen size in order to adjust the size of images on the website.
      Session
    
  
    
      optimizely_data$$pending_events
      optimizely.com
      This cookie is set to make split-tests on the website, which optimizes the website's relevance towards the visitor – the cookie can also be set to improve the visitor's experience on a website.
      Persistent
    
  
    
      __Host-#
      www.dropbox.com
      
      1 year
    
  


Targeting Cookies
These cookies and other technologies collect information about the browsing habits associated with your device and are used to make advertising more relevant to you and your interests. Third parties provide these services in return for recognizing that you (or more accurately your device) have visited a certain Site. These third parties put down advertising cookies both when you visit our Site and Services and when you use their services and navigate away from our Site and Services.


  
    Cookie Name
    Provider
    Description of Purpose
    Expiration
  
  
    
      tuid
      a.usbrowserspeed.com
      Allows us to personalize and improve a visitor's experience on the site.
      1 year
    
  
    
      receive-cookie-deprecation
      adnxs.com
      Collects information on user behaviour on multiple websites. This information is used in order to optimize the relevance of advertisement on the website.
      3 months
    
  
    
      uuid
      alocdn.com
      This cookie is used to optimize ad relevance by collecting visitor data from multiple websites – this exchange of visitor data is normally provided by a third-party data-center or ad-exchange.
      1 year
    
  
    
      v1/beacon/img.gif
      b.6sc.co
      Used in context with Account-Based-Marketing (ABM). The cookie registers data such as IP-addresses, time spent on the website and page requests for the visit. This is used for retargeting of multiple users rooting from the same IP-addresses. ABM usually facilitates B2B marketing purposes.
      Session
    
  
    
      ajs_user_id
      cdn.segment.com
      Collects data on visitors' preferences and behaviour on the website - This information is used make content and advertisement more relevant to the specific visitor. 
      Persistent
    
  
    
      __q_state_Q2nN3hknkeUxhVKm
      circleci.com
      Qualified Chat. Needed for the functionality of the website’s chat-box function.
      10 years
    
  
    
      __tld__
      circleci.com
      Used to track visitors on multiple websites, in order to present relevant advertisement based on the visitor's preferences. 
      Session
    
  
    
      _an_uid
      circleci.com
      Presents the user with relevant content and advertisement. The service is provided by third-party advertisement hubs, which facilitate real-time bidding for advertisers.
      7 days
    
  
    
      _gcl_au
      circleci.com
      Used by Google AdSense for experimenting with advertisement efficiency across websites using their services.  
      3 months
    
  
    
      _gd_session
      circleci.com
      Collects visitor data related to the user's visits to the website, such as the number of visits, average time spent on the website and what pages have been loaded, with the purpose of displaying targeted ads.
      1 day
    
  
    
      _gd_visitor
      circleci.com
      Collects visitor data related to the user's visits to the website, such as the number of visits, average time spent on the website and what pages have been loaded, with the purpose of displaying targeted ads.
      2 years
    
  
    
      _jeevageo
      circleci.com
      Tracks the visitor's geographical location.
      Session
    
  
    
      _jeevaloaded
      circleci.com
      Whether or not the script loaded for the visitor.
      Session
    
  
    
      _jeevaresolve
      circleci.com
      An infotap.com cookie that helps improve visitors' experience on the website.
      Session
    
  
    
      _jeevasessionID
      circleci.com
      The visitor's session ID.
      Session
    
  
    
      _jeevatd
      circleci.com
      An infotap.com cookie that helps improve visitors' experience on the website.
      Session
    
  
    
      _jeevauid
      circleci.com
      The visitor's Jeeva user ID.
      Session
    
  
    
      _lc2_fpi
      circleci.com
      Registers user behaviour and navigation on the website, and any interaction with active campaigns. This is used for optimizing advertisement and for efficient retargeting.  
      2 years
    
  
    
      _lc2_fpi_js
      circleci.com
      This cookie is set by LiveIntent. A random, unique, device identifier, stored as a 1st party cookie, to enable targeted advertising
      Session
    
  
    
      _li_dcdm_c
      circleci.com
      Registers user behaviour and navigation on the website, and any interaction with active campaigns. This is used for optimizing advertisement and for efficient retargeting.  
      Session
    
  
    
      _mkto_trk
      circleci.com
      Contains data on visitor behaviour and website interaction. This is used in context with the email marketing service Marketo.com, which allows the website to target visitors via email. 
      Session
    
  
    
      ajs_user_id
      circleci.com
      This cookie is used to collect data on the visitor's behavior on the website - this information can be used to assign the visitor to a visitor segment, based on common preferences.
      Session
    
  
    
      amplitude_cookie_test
      circleci.com
      Detects whether partner data synchronization is functioning and currently running - This function sends user data between third-party advertisement companies for the purpose of targeted advertisements.  
      Session
    
  
    
      fbclid
      circleci.com
      Facebook click identifier
      Session
    
  
    
      gclid
      circleci.com
      Used to send data to Google Analytics about the visitor's device and behavior. Tracks the visitor across devices and marketing channels.
      Session
    
  
    
      msclkid
      circleci.com
      Microsoft Click ID (MSCLKID)
      Session
    
  
    
      optimizelyOptOut
      circleci.com
      Collects visitor data related to the user's visits to the website, such as the number of visits, average time spent on the website and what pages have been loaded, with the purpose of displaying targeted ads.
      Session
    
  
    
      sa-user-id
      circleci.com
      Used to track visitors on multiple websites, in order to present relevant advertisement based on the visitor's preferences. 
      1 year
    
  
    
      sa-user-id-v2
      circleci.com
      Used to track visitors on multiple websites, in order to present relevant advertisement based on the visitor's preferences. 
      1 year
    
  
    
      sa-user-id-v3
      circleci.com
      Collects data on the user across websites - This data is used to make advertisement more relevant.
      1 year
    
  
    
      utm_content
      circleci.com
      Used to send data to Google Analytics about the visitor's device and behavior. Tracks the visitor across devices and marketing channels.
      Session
    
  
    
      utm_medium
      circleci.com
      Collects information on user preferences and/or interaction with web-campaign content - This is used on CRM-campaign-platform used by website owners for promoting events or products.
      Session
    
  
    
      utm_source
      circleci.com
      Determines how the user accessed the website. This information is used by the website operator in order to measure the efficiency of their marketing.    
      Session
    
  
    
      utm_term
      circleci.com
      Determines how the user accessed the website. This information is used by the website operator in order to measure the efficiency of their marketing.    
      Session
    
  
    
      circleciAnonymousId
      d2qm0z2kzhiwa.cloudfront.net
      Content caching.
      Persistent
    
  
    
      meApiDone
      d2qm0z2kzhiwa.cloudfront.net
      Content caching.
      Session
    
  
    
      IDE
      doubleclick.net
      Used by Google DoubleClick to register and report the website user's actions after viewing or clicking one of the advertiser's ads with the purpose of measuring the efficacy of an ad and to present targeted ads to the user.
      400 days
    
  
    
      test_cookie
      doubleclick.net
      Used to check if the user's browser supports cookies.
      1 day
    
  
    
      gvc
      dropboxusercontent.com
      
      5 years
    
  
    
      _GRECAPTCHA
      google.com
      This cookie is used to distinguish between humans and bots. This is beneficial for the website, in order to make valid reports on the use of their website.
      180 days
    
  
    
      NID
      google.com
      
      6 months
    
  
    
      pagead/1p-conversion/#/
      google.com
      
      Session
    
  
    
      pagead/1p-user-list/#
      google.com
      Tracks if the user has shown interest in specific products or events across multiple websites and detects how the user navigates between sites. This is used for measurement of advertisement efforts and facilitates payment of referral-fees between websites.
      Session
    
  
    
      csi
      gstatic.com
      Collects data on visitors' preferences and behaviour on the website - This information is used make content and advertisement more relevant to the specific visitor. 
      Session
    
  
    
      __ptq.gif
      hubspot.com
      Sends data to the marketing platform Hubspot about the visitor's device and behaviour. Tracks the visitor across devices and marketing channels.
      Session
    
  
    
      __q_local_form_debug
      js.qualified.com
      Tracks website visitor interaction with the Qualified Chat Messenger. Stored in the website visitor’s browser as well as the Qualified Service.
      Persistent
    
  
    
      _li_duid
      liadm.com
      Collects information on user behaviour on multiple websites. This information is used in order to optimize the relevance of advertisement on the website.
      Persistent
    
  
    
      lidid
      liadm.com
      Collects data on visitors' behaviour and interaction - This is used to make advertisement on the website more relevant. The cookie also allows the website to detect any referrals from other websites.  
      400 days
    
  
    
      p
      liadm.com
      Used to track visitors on multiple websites, in order to present relevant advertisement based on the visitor's preferences. 
      Session
    
  
    
      bcookie
      linkedin.com
      Used by the social networking service, LinkedIn, for tracking the use of embedded services.
      1 year
    
  
    
      lidc
      linkedin.com
      Used by the social networking service, LinkedIn, for tracking the use of embedded services.
      2 days
    
  
    
      A/N{39}
      opps-api.getwarmly.com
      Engages with the warmly.ai API to set up tools to optimize website visitor data.
      1 year
    
  
    
      ClientSessionStore
      opps-widget.getwarmly.com
      Optimizes data from 3rd party tools to track website visitors who are ready to learn more or engage further.
      Persistent
    
  
    
      MediaStore-client
      opps-widget.getwarmly.com
      Optimizes data from 3rd party tools to track website visitors who are ready to learn more or engage further.
      Persistent
    
  
    
      warmly_fingerprint
      opps-widget.getwarmly.com
      Personalization for users to engage with website using chat.
      Persistent
    
  
    
      WidgetStore
      opps-widget.getwarmly.com
      Optimizes data from 3rd party tools to track website visitors who are ready to learn more or engage further.
      Persistent
    
  
    
      optimizely_data$$#$$event_queue
      optimizely.com
      
      Persistent
    
  
    
      optimizely_data$$#$$layer_states
      optimizely.com
      
      Persistent
    
  
    
      optimizely_data$$#$$session_state
      optimizely.com
      
      Persistent
    
  
    
      optimizely_data$$#$$tracker_optimizely
      optimizely.com
      
      Persistent
    
  
    
      optimizely_data$$#$$variation_map
      optimizely.com
      
      Persistent
    
  
    
      optimizely_data$$#$$visitor_profile
      optimizely.com
      
      Persistent
    
  
    
      _jeevauid
      r2d2-inbound-js-store-production.s3.us-east-1.amazonaws.com
      Sales enablement and personalization.
      Persistent
    
  
    
      sa-user-id
      stackadapt.com
      Used to track visitors on multiple websites, in order to present relevant advertisement based on the visitor's preferences. 
      Persistent
    
  
    
      sa-user-id
      stackadapt.com
      Used to track visitors on multiple websites, in order to present relevant advertisement based on the visitor's preferences. 
      1 year
    
  
    
      sa-user-id-v2
      stackadapt.com
      Used to track visitors on multiple websites, in order to present relevant advertisement based on the visitor's preferences. 
      1 year
    
  
    
      sa-user-id-v2
      stackadapt.com
      Used to track visitors on multiple websites, in order to present relevant advertisement based on the visitor's preferences. 
      Persistent
    
  
    
      sa-user-id-v3
      stackadapt.com
      Collects data on the user across websites - This data is used to make advertisement more relevant.
      Persistent
    
  
    
      sa-user-id-v3
      stackadapt.com
      Collects data on the user across websites - This data is used to make advertisement more relevant.
      1 year
    
  
    
      _gcl_ls
      www.googletagmanager.com
      Conversion Linker tags store ad click information in browser local storage.
      Persistent
    
  
    
      #-#
      youtube.com
      Used to track user’s interaction with embedded content.
      Session
    
  
    
      __Secure-ROLLOUT_TOKEN
      youtube.com
      
      180 days
    
  
    
      iU5q-!O9@$
      youtube.com
      Registers a unique ID to keep statistics of what videos from YouTube the user has seen.
      Session
    
  
    
      LAST_RESULT_ENTRY_KEY
      youtube.com
      Used to track user’s interaction with embedded content.
      Session
    
  
    
      LogsDatabaseV2:V#||LogsRequestsStore
      youtube.com
      Used to track user’s interaction with embedded content.
      Persistent
    
  
    
      nextId
      youtube.com
      Used to track user’s interaction with embedded content.
      Session
    
  
    
      remote_sid
      youtube.com
      Necessary for the implementation and functionality of YouTube video-content on the website.  
      Session
    
  
    
      requests
      youtube.com
      Used to track user’s interaction with embedded content.
      Session
    
  
    
      ServiceWorkerLogsDatabase#SWHealthLog
      youtube.com
      Necessary for the implementation and functionality of YouTube video-content on the website.  
      Persistent
    
  
    
      TESTCOOKIESENABLED
      youtube.com
      Used to track user’s interaction with embedded content.
      1 day
    
  
    
      VISITOR_INFO1_LIVE
      youtube.com
      Tries to estimate the users' bandwidth on pages with integrated YouTube videos.
      180 days
    
  
    
      YSC
      youtube.com
      Registers a unique ID to keep statistics of what videos from YouTube the user has seen.
      Session
    
  
    
      yt.innertube::nextId
      youtube.com
      Registers a unique ID to keep statistics of what videos from YouTube the user has seen.
      Persistent
    
  
    
      ytidb::LAST_RESULT_ENTRY_KEY
      youtube.com
      Stores the user's video player preferences using embedded YouTube video
      Persistent
    
  
    
      YtIdbMeta#databases
      youtube.com
      Used to track user’s interaction with embedded content.
      Persistent
    
  
    
      yt-remote-cast-available
      youtube.com
      Stores the user's video player preferences using embedded YouTube video
      Session
    
  
    
      yt-remote-cast-installed
      youtube.com
      Stores the user's video player preferences using embedded YouTube video
      Session
    
  
    
      yt-remote-connected-devices
      youtube.com
      Stores the user's video player preferences using embedded YouTube video
      Persistent
    
  
    
      yt-remote-device-id
      youtube.com
      Stores the user's video player preferences using embedded YouTube video
      Persistent
    
  
    
      yt-remote-fast-check-period
      youtube.com
      Stores the user's video player preferences using embedded YouTube video
      Session
    
  
    
      yt-remote-session-app
      youtube.com
      Stores the user's video player preferences using embedded YouTube video
      Session
    
  
    
      yt-remote-session-name
      youtube.com
      Stores the user's video player preferences using embedded YouTube video
      Session
    
  


Unclassified
Unclassified cookies are cookies that we are in the process of classifying, together with the providers of individual cookies.


  
    Cookie Name
    Provider
    Description of Purpose
    Expiration\n\nLegal
  







  
    
      
        
        
        
          
          
            
              
                Software as a Service Agreement
              
            
            
          
        
          
          
            
              
                Software License Agreement
              
            
            
          
        
          
          
            
              
                AI Functionality Terms
              
            
            
          
        
          
          
            
              
                Code Sharing Terms of Service
              
            
            
          
        
          
          
            
              
                Self-Hosted Applications Terms
              
            
            
          
        
          
          
            
              
                Acceptable Use Policy
              
            
            
          
        
          
          
            
              
                Cookie Policy
              
            
            
              
              


  Consent
  What are Cookies?
  Why do we use Cookies?
  Cookie Preferences and Disabling Cookies
  Opting out of Targeted Advertising by Third Parties
  Current Cookies    
      Strictly Necessary Cookies
      Performance Cookies - Site features and services
      Functional Cookies - Analytics and Website Optimization
      Targeting Cookies
      Unclassified
    
  




            
          
        
          
          
            
              
                Privacy Policy
              
            
            
          
        
          
          
            
              
                CircleCI’s Commitment to Data Privacy
              
            
            
          
        
          
          
            
              
                 Trademark Usage Guidelines
              
            
            
          
        
          
          
            
              
                Copyright Infringement Notice and Takedown Policy
              
            
            
          
        
          
          
            
              
                Website Terms of Use
              
            
            
          
        
      
    
  
  
    
      
        Cookie Policy
      
      
          Last Updated:
          
            March 19, 2025
          
      
      
        
This Cookie Policy (“Policy”) explains the different types of cookies and similar technologies that may be applied on the browsers and devices of consumers who visit https://circleci.com and https://discuss.circleci.com/, and any other websites (together the “Site”) owned by Circle Internet Services, Inc. dba CircleCI, a Delaware corporation (“CircleCI”, “we” or “us”) or who use our services, such as our continuous integration software and related technologies (the “Services”).

This Policy does not apply to the privacy practices of third-party websites which may be linked to this Site.

For more information about our data practices generally, see our Privacy Policy.

We may update this Policy from time to time in order to reflect, for example, changes to the cookies we use or for other operational, legal or regulatory reasons.  Please re-visit this Policy regularly to stay informed about our use of cookies and similar technologies. The date at the top of this Policy indicates when it was last updated.

If you have questions or concerns about this Policy, please contact us at:

Circle Internet Services, Inc.
2261 Market Street, #22561
San Francisco, CA, 94114
Phone: +1-800-585-7075
Email: privacy@circleci.com

Consent
By continuing to visit our Site or use our Services, you are agreeing to the use of cookies and other similar technologies for the purposes we describe in this Policy.

What are Cookies?
Cookies are small text files which are downloaded to your browser or device when you visit a website. Most web pages contain elements from multiple web domains so when you visit our Site and Services, your browser or device may receive cookies from several sources. This includes third parties that provide services on our behalf, such as site analytics or ad targeting.  In relation to the use of cookies by third parties, we do not have access or control over these cookies. We may also use local shared objects on our Site and Services to store your user preferences and settings. You can manage local shared objects by following the instructions here.

Our emails may contain a single, campaign-unique “web beacon pixel” to tell us whether our emails are opened and verify any clicks through to links within the email. We may use this information for purposes including determining which of our emails are more interesting to you and to query whether users who do not open our emails wish to continue receiving them. The pixel will be deleted when you delete the email.

Why do we use Cookies?
Our Site uses both 1st party cookies (which are set directly by us) and 3rd party cookies (which are set by third parties). We use 1st party and 3rd party cookies for several reasons. Some cookies are required for technical reasons in order for the Site and the Services to operate, and we refer to these as “Strictly Necessary” cookies. Some cookies allow us to measure and improve the performance of our Site and Services, such as by counting visits and traffic sources, and we refer to these as “Performance” cookies. Some cookies enable us to provide enhanced functionality and personalization on the Sites and Services, and we refer to these as “Functional” cookies. Finally, some cookies enable us and our partners to serve targeted advertisements, and we refer to these as “Targeting” cookies.  The specific types of 1st and 3rd party cookies served through the Site and the Services and the purposes they perform are described below.

Cookie Preferences and Disabling Cookies
Depending on where you are located, you may see a cookie notice pop up on our Site. You can set your cookie preferences for our Site by either clicking on Customize Settings or the Cookie Consent Manager. If you are not happy with the preferences that you previously set, follow these steps: (1) delete your cookies (see below for information on deleting cookies), (2) refresh the web page, and (3) open the cookie manager when the cookie preference notice pops up and reset your preferences.

If you do not agree to the use of these cookies, please disable or delete them by following the instructions for your browser(s) set out at http://www.allaboutcookies.org/manage-cookies/index.html. Please note that the Site and Services will not function well if cookies are disabled.  It may also stop you from saving customized settings, like login information.

If you delete your cookies, you will need to opt out again from targeted advertising (see below). You may download a browser extension that will help preserve the opt-out preferences you set by visiting www.aboutads.info/PMC.

Opting out of Targeted Advertising by Third Parties
For cookies that track activity in connection with targeting advertising, you can opt-out of third party targeting cookies on the Digital Advertising Alliance’s consumer choice page (http://optout.aboutads.info) or the Network Advertising Initiative’s consumer choice page (http://optout.networkadvertising.org) or the European Interactive Digital Advertising Alliance consumer choice page (http://youronlinechoices.eu).

Some of our third party targeting providers have their own opt-out mechanisms that are linked from their sites or their online-posted privacy policies. You should review the privacy policies of those companies for these opt-out links if you no longer wish to receive targeted advertising from a particular company, or multiple companies.

Please note that opting out from targeted advertising will not opt you out of being served advertising. You will continue to receive generic ads.

Other tools offered by third parties can help you see and manage the types of cookies and trackers that you encounter. More information about cookies and cookie management, including links to browser manufacturers’ cookie management pages, can be found on www.allaboutcookies.org and www.aboutcookies.org. For other browsers not included on www.aboutcookies.org, please consult the documentation that your browser manufacturer provides. If you access the Site on your mobile device, you may not be able to control tracking technologies through these settings.

After your initial visit to the Site and Services we may change the cookies and other technologies we use.

Current Cookies

Strictly Necessary Cookies
These cookies enable you to navigate the Sites and to use their services and features. These cookies are necessary for the website to function and cannot be switched off in our systems. They are usually only set in response to actions made by you which amount to a request for services, such as setting your privacy preferences, authenticating users, or logging in or filling in forms. You can set your browser to block or alert you about these cookies, but some parts of the site will not work.


  
    Cookie Name
    Provider
    Description of Purpose
    Expiration
  
  
    
      algoliasearch-client-js-#.#.#-01234VWXYZ
      assets-developer.circleci.com
      Necessary in order to optimize the website's search-bar function. The cookie ensures accurate and fast search results.
      Persistent
    
  
    
      object(#-#-##:#:#.#)
      cdn.amplitude.com
      Holds the users timezone.
      Persistent
    
  
    
      CookieConsent
      circleci.com
      Stores the user's cookie consent state for the current domain
      1 year
    
  
    
      dd_cookie_test_#
      circleci.com
      Registers data on visitors' website-behaviour. This is used for internal analysis and website optimization. 
      1 day
    
  
    
      optimizelyDomainTestCookie
      circleci.com
      Tracks the conversion rate between the user and the advertisement banners on the website - This serves to optimise the relevance of the advertisements on the website. 
      180 days
    
  
    
      optimizelyEndUserId
      circleci.com
      Used to measure how selected users react to targeted changes to the website's content and functionality, in order to determine what variation is most efficacious in terms of converting users to customers.
      180 days
    
  
    
      session_id
      d2qm0z2kzhiwa.cloudfront.net
      Preserves users states across page requests.
      Session
    
  
    
      uc_session
      dropboxusercontent.com
      Determines whether the user has accepted the cookie consent box. 
      Session
    
  
    
      rc::a
      gstatic.com
      This cookie is used to distinguish between humans and bots. This is beneficial for the website, in order to make valid reports on the use of their website.
      Persistent
    
  
    
      rc::b
      gstatic.com
      This cookie is used to distinguish between humans and bots. 
      Session
    
  
    
      rc::c
      gstatic.com
      This cookie is used to distinguish between humans and bots. 
      Session
    
  
    
      rc::f
      gstatic.com
      This cookie is used to distinguish between humans and bots. 
      Persistent
    
  
    
      __cf_bm
      hsadspixel.net
      This cookie is used to distinguish between humans and bots. This is beneficial for the website, in order to make valid reports on the use of their website.
      1 day
    
  
    
      __cf_bm
      hs-analytics.net
      This cookie is used to distinguish between humans and bots. This is beneficial for the website, in order to make valid reports on the use of their website.
      1 day
    
  
    
      __cf_bm
      hs-banner.com
      This cookie is used to distinguish between humans and bots. This is beneficial for the website, in order to make valid reports on the use of their website.
      1 day
    
  
    
      __cf_bm
      hscollectedforms.net
      This cookie is used to distinguish between humans and bots. This is beneficial for the website, in order to make valid reports on the use of their website.
      1 day
    
  
    
      __cf_bm
      hsforms.com
      This cookie is used to distinguish between humans and bots. This is beneficial for the website, in order to make valid reports on the use of their website.
      1 day
    
  
    
      _cfuvid
      hsforms.com
      This cookie is a part of the services provided by Cloudflare - Including load-balancing, deliverance of website content and serving DNS connection for website operators. 
      Session
    
  
    
      __cf_bm
      hsforms.net
      This cookie is used to distinguish between humans and bots. This is beneficial for the website, in order to make valid reports on the use of their website.
      1 day
    
  
    
      __cf_bm
      hs-scripts.com
      This cookie is used to distinguish between humans and bots. This is beneficial for the website, in order to make valid reports on the use of their website.
      1 day
    
  
    
      __cf_bm
      hubapi.com
      This cookie is used to distinguish between humans and bots. This is beneficial for the website, in order to make valid reports on the use of their website.
      1 day
    
  
    
      __cf_bm
      hubspot.com
      This cookie is used to distinguish between humans and bots. This is beneficial for the website, in order to make valid reports on the use of their website.
      1 day
    
  
    
      _cfuvid
      hubspot.com
      This cookie is a part of the services provided by Cloudflare - Including load-balancing, deliverance of website content and serving DNS connection for website operators. 
      Session
    
  
    
      li_gc
      linkedin.com
      Stores the user's cookie consent state for the current domain
      6 months
    
  
    
      _cfuvid
      medium.com
      This cookie is a part of the services provided by Cloudflare - Including load-balancing, deliverance of website content and serving DNS connection for website operators. 
      Session
    
  
    
      https://#_oeu#.#$$event_queue
      optimizely.com
      Stores event instances that are waiting to be added to the previous ...$$events key. https://support.optimizely.com/hc/en-us/articles/4410284260365-Cookies-and-localStorage-in-the-Optimizely-snippet
      Persistent
    
  
    
      https://#_oeu#.#$$layer_states
      optimizely.com
      Stores bucketing decision (variation and holdback assignment) for each layer in Optimizely Web & Optimizely Personalization.  https://support.optimizely.com/hc/en-us/articles/4410284260365-Cookies-and-localStorage-in-the-Optimizely-snippet
      Persistent
    
  
    
      https://#_oeu#.#$$session_state
      optimizely.com
      Tracks the session identifier and timestamp, which helps Optimizely identify sessions for analytics purposes.  https://support.optimizely.com/hc/en-us/articles/4410284260365-Cookies-and-localStorage-in-the-Optimizely-snippet
      Persistent
    
  
    
      https://#_oeu#.#$$tracker_optimizely
      optimizely.com
      Temporary storage for the batched sending of events to the Optimizely Event API. https://support.optimizely.com/hc/en-us/articles/4410284260365-Cookies-and-localStorage-in-the-Optimizely-snippet
      Persistent
    
  
    
      https://#_oeu#.#$$variation_map
      optimizely.com
      Records the variation that the visitor has seen for each experiment. This allows us to deliver a consistent experience on successive page loads. https://support.optimizely.com/hc/en-us/articles/4410284260365-Cookies-and-localStorage-in-the-Optimizely-snippet 
      Persistent
    
  
    
      https://#_oeu#.#$$visitor_profile
      optimizely.com
      Stores the visitor's values for various audience conditions.  This is particularly important for "sticky" conditions like Ad Campaign, Source Type, and Referrer for which we need to rely on the first observed value.  https://support.optimizely.com/hc/en-us/articles/4410284260365-Cookies-and-localStorage-in-the-Optimizely-snippet
      Persistent
    
  
    
      https://circleci.com_pending_events
      optimizely.com
      Temporary storage of XMLHttpRequest information, enabling the snippet to reliably send requests (e.g., to the Event API) even if the visitor navigates to a new page while a request is in progress.
      Persistent
    
  


Performance Cookies - Site features and services
These cookies and other technologies improve your experience by enabling personalization (like remembering if you’ve logged into our service before), as well as enabling certain features like chat support.  They can help you fill out forms on our Site more easily.


  
    Cookie Name
    Provider
    Description of Purpose
    Expiration
  
  
    
      storedOpenClose:primaryNavigation
      assets-authentication.circleci.com
      
      Persistent
    
  
    
      cci-customer
      circleci.com
      This cookie is used to determine if the visitor has signed into the CircleCI application. It allows to personalize the experience of the visitor. 
      2 years
    
  
    
      locale
      dropbox.com
      The cookie determines the preferred language and country-setting of the visitor - This allows the website to show content most relevant to that region and language.
      5 years
    
  
    
      gvc
      www.dropbox.com
      Used to implement or transfer content through Dropbox. 
      400 days
    
  


Functional Cookies - Analytics and Website Optimization
These cookies and other technologies help us learn how well our Site and Services are performing. We use these cookies to understand, improve, and research our Site and Services.


  
    Cookie Name
    Provider
    Description of Purpose
    Expiration
  
  
    
      fingerprint
      assets-developer.circleci.com
      Used to detect and log potential tracking errors.
      Persistent
    
  
    
      amplitude_unsent_#
      cdn.amplitude.com
      Registers data on visitors' website-behaviour. This is used for internal analysis and website optimization. 
      Persistent
    
  
    
      amplitude_unsent_identify_#
      cdn.amplitude.com
      Registers data on visitors' website-behaviour. This is used for internal analysis and website optimization. 
      Persistent
    
  
    
      ajs_anonymous_id
      cdn.segment.com
      This cookie is used to count how many times a website has been visited by different visitors - this is done by assigning the visitor an ID, so the visitor does not get registered twice.
      Persistent
    
  
    
      __hssc
      circleci.com
      Identifies if the cookie data needs to be updated in the visitor's browser.
      1 day
    
  
    
      __hssrc
      circleci.com
      Used to recognise the visitor's browser upon reentry on the website.
      Session
    
  
    
      __hstc
      circleci.com
      Sets a unique ID for the session. This allows the website to obtain data on visitor behaviour for statistical purposes.
      180 days
    
  
    
      __q_domainTest
      circleci.com
      Used in context with Account-Based-Marketing (ABM). The cookie registers data such as IP-addresses, time spent on the website and page requests for the visit. This is used for retargeting of multiple users rooting from the same IP-addresses. ABM usually facilitates B2B marketing purposes.
      Session
    
  
    
      _dd_s
      circleci.com
      Registers the website's speed and performance. This function can be used in context with statistics and load-balancing.
      1 day
    
  
    
      _ga
      circleci.com
      Registers a unique ID that is used to generate statistical data on how the visitor uses the website.
      2 years
    
  
    
      _ga_#
      circleci.com
      Used by Google Analytics to collect data on the number of times a user has visited the website as well as dates for the first and most recent visit. 
      2 years
    
  
    
      _gat
      circleci.com
      Used by Google Analytics to throttle request rate
      1 day
    
  
    
      _gid
      circleci.com
      Registers a unique ID that is used to generate statistical data on how the visitor uses the website.
      1 day
    
  
    
      _hjSession_#
      circleci.com
      Collects statistics on the visitor's visits to the website, such as the number of visits, average time spent on the website and what pages have been read.
      1 day
    
  
    
      _hjSessionUser_#
      circleci.com
      Collects statistics on the visitor's visits to the website, such as the number of visits, average time spent on the website and what pages have been read.
      1 year
    
  
    
      ajs_anonymous_id
      circleci.com
      This cookie is used to identify a specific visitor - this information is used to identify the number of specific visitors on a website.
      1 year
    
  
    
      amplitude_#
      circleci.com
      Registers statistical data on users' behaviour on the website. Used for internal analytics by the website operator. 
      10 years
    
  
    
      amplitude_id_#
      circleci.com
      Registers data on visitors' website-behaviour. This is used for internal analysis and website optimization. 
      10 years
    
  
    
      amplitude-session-id
      circleci.com
      These cookies are set by Amplitude analytics, which helps to better understand how the CircleCI website is used. 
      Session
    
  
    
      analytics-client-id
      circleci.com
      Client ID is a cookie that's stored in the client's browser and sent with each request to Google Analytics.
      Session
    
  
    
      closed-customer-banner
      circleci.com
      
      Session
    
  
    
      current_referrer
      circleci.com
      
      Session
    
  
    
      enterprise_customer
      circleci.com
      
      Session
    
  
    
      gitlab-onboarding
      circleci.com
      
      Session
    
  
    
      hubspotutk
      circleci.com
      Sets a unique ID for the session. This allows the website to obtain data on visitor behaviour for statistical purposes.
      180 days
    
  
    
      initial_referrer
      circleci.com
      
      Session
    
  
    
      t
      dropbox.com
      Stores data on which websites the user has visited.
      1 year
    
  
    
      __Host-#
      dropboxusercontent.com
      
      1 year
    
  
    
      collect
      google-analytics.com
      Used to send data to Google Analytics about the visitor's device and behavior. Tracks the visitor across devices and marketing channels.
      Session
    
  
    
      hjActiveViewportIds
      hotjar.com
      This cookie contains an ID string on the current session. This contains non-personal information on what subpages the visitor enters – this information is used to optimize the visitor's experience.
      Persistent
    
  
    
      hjViewportId
      hotjar.com
      Saves the user's screen size in order to adjust the size of images on the website.
      Session
    
  
    
      optimizely_data$$pending_events
      optimizely.com
      This cookie is set to make split-tests on the website, which optimizes the website's relevance towards the visitor – the cookie can also be set to improve the visitor's experience on a website.
      Persistent
    
  
    
      __Host-#
      www.dropbox.com
      
      1 year
    
  


Targeting Cookies
These cookies and other technologies collect information about the browsing habits associated with your device and are used to make advertising more relevant to you and your interests. Third parties provide these services in return for recognizing that you (or more accurately your device) have visited a certain Site. These third parties put down advertising cookies both when you visit our Site and Services and when you use their services and navigate away from our Site and Services.


  
    Cookie Name
    Provider
    Description of Purpose
    Expiration
  
  
    
      tuid
      a.usbrowserspeed.com
      Allows us to personalize and improve a visitor's experience on the site.
      1 year
    
  
    
      receive-cookie-deprecation
      adnxs.com
      Collects information on user behaviour on multiple websites. This information is used in order to optimize the relevance of advertisement on the website.
      3 months
    
  
    
      uuid
      alocdn.com
      This cookie is used to optimize ad relevance by collecting visitor data from multiple websites – this exchange of visitor data is normally provided by a third-party data-center or ad-exchange.
      1 year
    
  
    
      v1/beacon/img.gif
      b.6sc.co
      Used in context with Account-Based-Marketing (ABM). The cookie registers data such as IP-addresses, time spent on the website and page requests for the visit. This is used for retargeting of multiple users rooting from the same IP-addresses. ABM usually facilitates B2B marketing purposes.
      Session
    
  
    
      ajs_user_id
      cdn.segment.com
      Collects data on visitors' preferences and behaviour on the website - This information is used make content and advertisement more relevant to the specific visitor. 
      Persistent
    
  
    
      __q_state_Q2nN3hknkeUxhVKm
      circleci.com
      Qualified Chat. Needed for the functionality of the website’s chat-box function.
      10 years
    
  
    
      __tld__
      circleci.com
      Used to track visitors on multiple websites, in order to present relevant advertisement based on the visitor's preferences. 
      Session
    
  
    
      _an_uid
      circleci.com
      Presents the user with relevant content and advertisement. The service is provided by third-party advertisement hubs, which facilitate real-time bidding for advertisers.
      7 days
    
  
    
      _gcl_au
      circleci.com
      Used by Google AdSense for experimenting with advertisement efficiency across websites using their services.  
      3 months
    
  
    
      _gd_session
      circleci.com
      Collects visitor data related to the user's visits to the website, such as the number of visits, average time spent on the website and what pages have been loaded, with the purpose of displaying targeted ads.
      1 day
    
  
    
      _gd_visitor
      circleci.com
      Collects visitor data related to the user's visits to the website, such as the number of visits, average time spent on the website and what pages have been loaded, with the purpose of displaying targeted ads.
      2 years
    
  
    
      _jeevageo
      circleci.com
      Tracks the visitor's geographical location.
      Session
    
  
    
      _jeevaloaded
      circleci.com
      Whether or not the script loaded for the visitor.
      Session
    
  
    
      _jeevaresolve
      circleci.com
      An infotap.com cookie that helps improve visitors' experience on the website.
      Session
    
  
    
      _jeevasessionID
      circleci.com
      The visitor's session ID.
      Session
    
  
    
      _jeevatd
      circleci.com
      An infotap.com cookie that helps improve visitors' experience on the website.
      Session
    
  
    
      _jeevauid
      circleci.com
      The visitor's Jeeva user ID.
      Session
    
  
    
      _lc2_fpi
      circleci.com
      Registers user behaviour and navigation on the website, and any interaction with active campaigns. This is used for optimizing advertisement and for efficient retargeting.  
      2 years
    
  
    
      _lc2_fpi_js
      circleci.com
      This cookie is set by LiveIntent. A random, unique, device identifier, stored as a 1st party cookie, to enable targeted advertising
      Session
    
  
    
      _li_dcdm_c
      circleci.com
      Registers user behaviour and navigation on the website, and any interaction with active campaigns. This is used for optimizing advertisement and for efficient retargeting.  
      Session
    
  
    
      _mkto_trk
      circleci.com
      Contains data on visitor behaviour and website interaction. This is used in context with the email marketing service Marketo.com, which allows the website to target visitors via email. 
      Session
    
  
    
      ajs_user_id
      circleci.com
      This cookie is used to collect data on the visitor's behavior on the website - this information can be used to assign the visitor to a visitor segment, based on common preferences.
      Session
    
  
    
      amplitude_cookie_test
      circleci.com
      Detects whether partner data synchronization is functioning and currently running - This function sends user data between third-party advertisement companies for the purpose of targeted advertisements.  
      Session
    
  
    
      fbclid
      circleci.com
      Facebook click identifier
      Session
    
  
    
      gclid
      circleci.com
      Used to send data to Google Analytics about the visitor's device and behavior. Tracks the visitor across devices and marketing channels.
      Session
    
  
    
      msclkid
      circleci.com
      Microsoft Click ID (MSCLKID)
      Session
    
  
    
      optimizelyOptOut
      circleci.com
      Collects visitor data related to the user's visits to the website, such as the number of visits, average time spent on the website and what pages have been loaded, with the purpose of displaying targeted ads.
      Session
    
  
    
      sa-user-id
      circleci.com
      Used to track visitors on multiple websites, in order to present relevant advertisement based on the visitor's preferences. 
      1 year
    
  
    
      sa-user-id-v2
      circleci.com
      Used to track visitors on multiple websites, in order to present relevant advertisement based on the visitor's preferences. 
      1 year
    
  
    
      sa-user-id-v3
      circleci.com
      Collects data on the user across websites - This data is used to make advertisement more relevant.
      1 year
    
  
    
      utm_content
      circleci.com
      Used to send data to Google Analytics about the visitor's device and behavior. Tracks the visitor across devices and marketing channels.
      Session
    
  
    
      utm_medium
      circleci.com
      Collects information on user preferences and/or interaction with web-campaign content - This is used on CRM-campaign-platform used by website owners for promoting events or products.
      Session
    
  
    
      utm_source
      circleci.com
      Determines how the user accessed the website. This information is used by the website operator in order to measure the efficiency of their marketing.    
      Session
    
  
    
      utm_term
      circleci.com
      Determines how the user accessed the website. This information is used by the website operator in order to measure the efficiency of their marketing.    
      Session
    
  
    
      circleciAnonymousId
      d2qm0z2kzhiwa.cloudfront.net
      Content caching.
      Persistent
    
  
    
      meApiDone
      d2qm0z2kzhiwa.cloudfront.net
      Content caching.
      Session
    
  
    
      IDE
      doubleclick.net
      Used by Google DoubleClick to register and report the website user's actions after viewing or clicking one of the advertiser's ads with the purpose of measuring the efficacy of an ad and to present targeted ads to the user.
      400 days
    
  
    
      test_cookie
      doubleclick.net
      Used to check if the user's browser supports cookies.
      1 day
    
  
    
      gvc
      dropboxusercontent.com
      
      5 years
    
  
    
      _GRECAPTCHA
      google.com
      This cookie is used to distinguish between humans and bots. This is beneficial for the website, in order to make valid reports on the use of their website.
      180 days
    
  
    
      NID
      google.com
      
      6 months
    
  
    
      pagead/1p-conversion/#/
      google.com
      
      Session
    
  
    
      pagead/1p-user-list/#
      google.com
      Tracks if the user has shown interest in specific products or events across multiple websites and detects how the user navigates between sites. This is used for measurement of advertisement efforts and facilitates payment of referral-fees between websites.
      Session
    
  
    
      csi
      gstatic.com
      Collects data on visitors' preferences and behaviour on the website - This information is used make content and advertisement more relevant to the specific visitor. 
      Session
    
  
    
      __ptq.gif
      hubspot.com
      Sends data to the marketing platform Hubspot about the visitor's device and behaviour. Tracks the visitor across devices and marketing channels.
      Session
    
  
    
      __q_local_form_debug
      js.qualified.com
      Tracks website visitor interaction with the Qualified Chat Messenger. Stored in the website visitor’s browser as well as the Qualified Service.
      Persistent
    
  
    
      _li_duid
      liadm.com
      Collects information on user behaviour on multiple websites. This information is used in order to optimize the relevance of advertisement on the website.
      Persistent
    
  
    
      lidid
      liadm.com
      Collects data on visitors' behaviour and interaction - This is used to make advertisement on the website more relevant. The cookie also allows the website to detect any referrals from other websites.  
      400 days
    
  
    
      p
      liadm.com
      Used to track visitors on multiple websites, in order to present relevant advertisement based on the visitor's preferences. 
      Session
    
  
    
      bcookie
      linkedin.com
      Used by the social networking service, LinkedIn, for tracking the use of embedded services.
      1 year
    
  
    
      lidc
      linkedin.com
      Used by the social networking service, LinkedIn, for tracking the use of embedded services.
      2 days
    
  
    
      A/N{39}
      opps-api.getwarmly.com
      Engages with the warmly.ai API to set up tools to optimize website visitor data.
      1 year
    
  
    
      ClientSessionStore
      opps-widget.getwarmly.com
      Optimizes data from 3rd party tools to track website visitors who are ready to learn more or engage further.
      Persistent
    
  
    
      MediaStore-client
      opps-widget.getwarmly.com
      Optimizes data from 3rd party tools to track website visitors who are ready to learn more or engage further.
      Persistent
    
  
    
      warmly_fingerprint
      opps-widget.getwarmly.com
      Personalization for users to engage with website using chat.
      Persistent
    
  
    
      WidgetStore
      opps-widget.getwarmly.com
      Optimizes data from 3rd party tools to track website visitors who are ready to learn more or engage further.
      Persistent
    
  
    
      optimizely_data$$#$$event_queue
      optimizely.com
      
      Persistent
    
  
    
      optimizely_data$$#$$layer_states
      optimizely.com
      
      Persistent
    
  
    
      optimizely_data$$#$$session_state
      optimizely.com
      
      Persistent
    
  
    
      optimizely_data$$#$$tracker_optimizely
      optimizely.com
      
      Persistent
    
  
    
      optimizely_data$$#$$variation_map
      optimizely.com
      
      Persistent
    
  
    
      optimizely_data$$#$$visitor_profile
      optimizely.com
      
      Persistent
    
  
    
      _jeevauid
      r2d2-inbound-js-store-production.s3.us-east-1.amazonaws.com
      Sales enablement and personalization.
      Persistent
    
  
    
      sa-user-id
      stackadapt.com
      Used to track visitors on multiple websites, in order to present relevant advertisement based on the visitor's preferences. 
      Persistent
    
  
    
      sa-user-id
      stackadapt.com
      Used to track visitors on multiple websites, in order to present relevant advertisement based on the visitor's preferences. 
      1 year
    
  
    
      sa-user-id-v2
      stackadapt.com
      Used to track visitors on multiple websites, in order to present relevant advertisement based on the visitor's preferences. 
      1 year
    
  
    
      sa-user-id-v2
      stackadapt.com
      Used to track visitors on multiple websites, in order to present relevant advertisement based on the visitor's preferences. 
      Persistent
    
  
    
      sa-user-id-v3
      stackadapt.com
      Collects data on the user across websites - This data is used to make advertisement more relevant.
      Persistent
    
  
    
      sa-user-id-v3
      stackadapt.com
      Collects data on the user across websites - This data is used to make advertisement more relevant.
      1 year
    
  
    
      _gcl_ls
      www.googletagmanager.com
      Conversion Linker tags store ad click information in browser local storage.
      Persistent
    
  
    
      #-#
      youtube.com
      Used to track user’s interaction with embedded content.
      Session
    
  
    
      __Secure-ROLLOUT_TOKEN
      youtube.com
      
      180 days
    
  
    
      iU5q-!O9@$
      youtube.com
      Registers a unique ID to keep statistics of what videos from YouTube the user has seen.
      Session
    
  
    
      LAST_RESULT_ENTRY_KEY
      youtube.com
      Used to track user’s interaction with embedded content.
      Session
    
  
    
      LogsDatabaseV2:V#||LogsRequestsStore
      youtube.com
      Used to track user’s interaction with embedded content.
      Persistent
    
  
    
      nextId
      youtube.com
      Used to track user’s interaction with embedded content.
      Session
    
  
    
      remote_sid
      youtube.com
      Necessary for the implementation and functionality of YouTube video-content on the website.  
      Session
    
  
    
      requests
      youtube.com
      Used to track user’s interaction with embedded content.
      Session
    
  
    
      ServiceWorkerLogsDatabase#SWHealthLog
      youtube.com
      Necessary for the implementation and functionality of YouTube video-content on the website.  
      Persistent
    
  
    
      TESTCOOKIESENABLED
      youtube.com
      Used to track user’s interaction with embedded content.
      1 day
    
  
    
      VISITOR_INFO1_LIVE
      youtube.com
      Tries to estimate the users' bandwidth on pages with integrated YouTube videos.
      180 days
    
  
    
      YSC
      youtube.com
      Registers a unique ID to keep statistics of what videos from YouTube the user has seen.
      Session
    
  
    
      yt.innertube::nextId
      youtube.com
      Registers a unique ID to keep statistics of what videos from YouTube the user has seen.
      Persistent
    
  
    
      ytidb::LAST_RESULT_ENTRY_KEY
      youtube.com
      Stores the user's video player preferences using embedded YouTube video
      Persistent
    
  
    
      YtIdbMeta#databases
      youtube.com
      Used to track user’s interaction with embedded content.
      Persistent
    
  
    
      yt-remote-cast-available
      youtube.com
      Stores the user's video player preferences using embedded YouTube video
      Session
    
  
    
      yt-remote-cast-installed
      youtube.com
      Stores the user's video player preferences using embedded YouTube video
      Session
    
  
    
      yt-remote-connected-devices
      youtube.com
      Stores the user's video player preferences using embedded YouTube video
      Persistent
    
  
    
      yt-remote-device-id
      youtube.com
      Stores the user's video player preferences using embedded YouTube video
      Persistent
    
  
    
      yt-remote-fast-check-period
      youtube.com
      Stores the user's video player preferences using embedded YouTube video
      Session
    
  
    
      yt-remote-session-app
      youtube.com
      Stores the user's video player preferences using embedded YouTube video
      Session
    
  
    
      yt-remote-session-name
      youtube.com
      Stores the user's video player preferences using embedded YouTube video
      Session
    
  


Unclassified
Unclassified cookies are cookies that we are in the process of classifying, together with the providers of individual cookies.


  
    Cookie Name
    Provider
    Description of Purpose
    Expiration\n\n\n\nYour security is our priority
      
        
          At CircleCI, our top concern is protecting our users’ intellectual property and sensitive secrets such as keys, tokens, and credentials.

        
      
      
        

  
    
    
      
        
        Request a security report
      
    
  
    
    
      
        
        Report a security issue
      
    
  

      
    
    
  







  
  
    
        
          Compliance and authorizations
          CircleCI takes the security of your applications seriously. We partner with the top security organizations to ensure that your projects are built, deployed, and maintained securely.

        
      
        
          
          
            
              
  
  
    
    FedRAMP tailored
    First CI/CD tool to meet the rigorous security and privacy NIST-standards of FedRAMP

  
  

            
              
  
  
    
    SOC 2 Type II compliant
    SOC 2 Type II compliance is a component of the American Institute of CPAs (AICPA)’s Service Organization Control reporting platform

  
  

            
          
        
        
          
            
              

            
          
        
      
    
  





  
    
      Product security features
      Get the compliance, security, and audit logging features that you need. Choose our cloud-hosted service with the option to use CircleCI compute and self-hosted runners, or run your own instance of CircleCI entirely on your own infrastructure.

    
    
      
        
        
        
        
        
        
          Source code security
          Communication with your VCS to access source code is always encrypted over the wire using SSH and/or HTTPS.

        
      
        
        
        
        
        
        
          Config policies
          Enforce organizational compliance and standardization across projects.

        
      
        
        
        
        
        
        
          Environment variables (secrets)
          Protect secrets and other sensitive data in CircleCI using environment variables.

        
      
        
        
        
        
        
        
          OpenID Connect
          CircleCI supports authentication via OpenID Connect at the job level. Using OIDC, pipelines can authenticate to systems like Vault, AWS and GCP without distributing secrets.

        
      
        
        
        
        
        
        
          Restricted contexts
          Restricted contexts allow encrypted storage and sharing of environment variables across multiple projects while limiting access to certain user groups or at the project level.

        
      
        
        
        
        
        
        
          Audit logging
          Use audit logs to monitor anomalies, assist in forensics, and demonstrate compliance.

        
      
        
        
        
        
        
        
          Runtime isolation
          CircleCI runs all builds in isolated sandboxes that are destroyed after each use.

        
      
        
        
        
        
        
        
          Console output and artifacts
          Encryption is employed over the wire using SSH and/or HTTPS for both console output and artifacts. Both are only available to those with read access to your repository.

        
      
        
        
        
        
        
        
          Two-factor authentication
          CircleCI inherits 2FA authentication established in your third-party VCS provider.

        
      
    
  

























  
  
    
      

    
  



  
    
      
      Compliance & certifications
      
        
          
            Current compliance & certifications
          
          
            
              
                
                  SOC 2 Type II compliant
                
                
                  SOC 2 Type II provides CircleCI with an opportunity to meet (and exceed) industry standards and gives our customer organization’s access to industry-recognized, standardized reports that they can compare across services in our space. Achieving SOC 2 Type II compliance means that CircleCI has put in place and follows the procedures and security policies necessary to reduce risks, and that their processes can be requested and audited.

Learn more about SOC 2 Type II at https://www.aicpa.org/.

                
              
            
              
                
                  FedRAMP tailored
                
                
                  Our FedRAMP Tailored designation demonstrates that CircleCI meets US government data security standards and is authorized for use within US government agencies.

Learn more about the FedRAMP certification at https://www.fedramp.gov/.

                
              
            
              
                
                  Data privacy frameworks
                
                
                  The certification ensures that CircleCI meets all data transfer security standards for the United States, the EU, the UK (and Gibraltar) and Switzerland under the EU-U.S. Data Privacy Framework, the UK Extension to the EU-U.S. Data Privacy Framework, and the Swiss-U.S. Data Privacy Framework as set forth by the U.S. Department of Commerce.

Learn more about the Data Privacy Framework at https://www.dataprivacyframework.gov/.

                
              
            
              
                
                  PCI compliance
                
                
                  CircleCI leverages the PCI compliance of Stripe.

                
              
            
          
        
      
    
      
      Business practices
      
        
          
            Personnel & Processors
          
          
            
              
                
                  Background checks
                
                
                  All CircleCI employees and contractors must pass a background check and sign confidentiality agreements.

                
              
            
              
                
                  Employee security awareness
                
                
                  CircleCI mandates that new employees attend classes covering security best practices.

                
              
            
              
                
                  Engineer security education
                
                
                  Engineers are required to attend an additional technical security workshop.

                
              
            
              
                
                  Policies
                
                
                  CircleCI maintains various security policies which are maintained and communicated by our security management team.

                
              
            
              
                
                  Partner management
                
                
                  CircleCI requires all partners and third-party vendors to fill out a security questionnaire. Those which handle PII are also required to sign a Data Processing Addendum.

                
              
            
          
        
      
        
          
            Security incident response
          
          
            
              
                
                  Response team
                
                
                  CircleCI maintains a dedicated Incident Response Team.

                
              
            
              
                
                  Response policy + plan
                
                
                  CircleCI maintains an Incident Response Policy and Runbook to facilitate decision making during critical situations.

                
              
            
              
                
                  Communication
                
                
                  Network and security incidents are published at https://status.circleci.com/.
At our discretion, based on the nature of a security incident, we
may contact customers directly and/or publish security alert
information to https://circleci.com/blog/
in addition to (or in lieu of) posting to our general status page.

                
              
            
          
        
      
    
      
      Physical security
      
        
          
            Offices security
          
          
            
              
                
                  Headquarters security
                
                
                  CircleCI headquarters employs 24-hour door personnel and badge access is required at all hours. Visitors are required to sign in and be escorted at all times.

                
              
            
              
                
                  Remote offices security
                
                
                  CircleCI’s remote offices in Denver, Japan, and London implement similar physical security controls to the San Francisco headquarters.

                
              
            
          
        
      
        
          
            Fleet security
          
          
            
              
                
                  Linux fleet security
                
                
                  CircleCI uses Amazon and Google Cloud Platform for its computing. Both vendors are industry leaders in security and privacy.

                
              
            
              
                
                  macOS fleet security
                
                
                  CircleCI operates macOS fleets housed at three data centers, located in Milwaukee, Las Vegas, and Atlanta. No CircleCI employee has physical access to the machines and all administration is done remotely. Data center engineers are the only people with access to provisioning machines, updating or deprovisioning machines. Federal regulators completed a full-day onsite audit in 2022 to assess the security, availability and integrity of the facility. Additionally, a penetration test was performed in late 2022 to identify and resolve any potential threats to the platform. Extensive badging, access logging, and other security controls are in place, all of which have been audited and approved under SOC 2 Type II compliance programs at CircleCI or the data center provider.

                
              
            
          
        
      
    
      
      Network & data security
      
        
          
            Network security
          
          
            
              
                
                  Vulnerability scanning
                
                
                  CircleCI implements a Docker-centric vulnerability scanning tool in its software development CI/CD process. Patching timelines for CircleCI’s cloud service are:

  Critical – 14 days
  High – 14 days
  Medium – 30 days
  Low – 30 days


Monthly scans are submitted to federal authorities as part of ongoing FedRAMP compliance.

                
              
            
              
                
                  Internal systems auditing
                
                
                  CircleCI maintains a formal Audit Policy governing application events, system events, hardware events, and physical access. This includes the what, when, and where of the event, its source, its object, its outcome, and the person associated with it.

                
              
            
              
                
                  Architecture
                
                
                  CircleCI’s architecture consists of multiple layers of data security including a DMZ, bastion hosts, and firewalls.

                
              
            
              
                
                  Global distribution
                
                
                  CircleCI’s Site Reliability, Support and Engineering teams are globally distributed for 24/7/365 coverage.

                
              
            
              
                
                  Build isolation
                
                
                  CircleCI runs all builds in isolated sandboxes that are destroyed after each use.

                
              
            
          
        
      
        
          
            Data security
          
          
            
              
                
                  Traffic encryption
                
                
                  All data in transit is encrypted via TLS and SSH.

                
              
            
              
                
                  Environment variable encryption
                
                
                  Environment variables are encrypted at rest and in transit, and injected into the runtime environment at the start of a job. All sensitive secrets such as keys, tokens, and other credentials should be stored as environment variables within CircleCI.

                
              
            
              
                
                  Source code encryption
                
                
                  Source code is always encrypted via TLS and SSH in transit, but is not encrypted at rest. Source code at rest is secured behind multiple layers of architecture security such as DMZ, bastion hosts, and firewalls.

                
              
            
              
                
                  Data backup
                
                
                  CircleCI maintains a Data Backup and Snapshot Policy that requires restoration capabilities within common industry timelines.

                
              
            
          
        
      
    
      
      Application security
      
        
          
            Secure development
          
          
            
              
                
                  Secure coding
                
                
                  The Software Development Lifecycle Policy dictates delivery, review and merge processes to minimize rollbacks, downtime, design flaws and security incidents.

                
              
            
              
                
                  Site reliability
                
                
                  CircleCI employs a team of Site Reliability Engineers ensuring that the CircleCI application security layers are consistently maintained.

                
              
            
          
        
      
        
          
            Application-level security
          
          
            
              
                
                  OWASP Top 10
                
                
                  CircleCI’s web application is designed to withstand OWASP Top 10 matters such as injections, broken authentication and session management, cross-site scripting (XSS), insecure direct object references, missing function level access control, cross-site request forgery (CSRF), unvalidated redirects and forwards.

                
              
            
              
                
                  Application penetration testing
                
                
                  Third-party penetration testers are hired annually to test the CircleCI application, network, infrastructure, and new products for vulnerabilities. Coverage ranges from OWASP Top 10 to threat modeling of new product features.

                
              
            
          
        
      
    
  






  
    
      Have a security concern about CircleCI?
      
        
          
          
            
            





          
        
      
    
    
      
      
        
          Finding serious security issues
          If you find any of the following issues, please contact us with relevant details including steps to reproduce or a proof-of-concept.

  Injection vulnerabilities
  Authentication or session problems
  Improper access to sensitive data
  Broken access controls
  Cross-site scripting
  Anything from the OWASP Top 10 Project
  Email spoofing, SPF, DKIM, and DMARC errors


Reports we do not act on

  Credentials in a 3rd party’s .circleci/config.yml


CircleCI does not have a bounty program We do not offer bug bounties for discovered vulnerabilities. We hope that if you discover vulnerabilities in the course of your work that you share them with us so we can improve the health of the internet ecosystem.

          

        
      
        
          Protect our users’ data
          Upon discovering a vulnerability, we ask that you:

  Inform us as soon as possible, contact our security team by email at security@circleci.com
    
      If you are reporting a sensitive issue, please encrypt your message using our security team’s GPG key (ID: 0x4013DDA7, fingerprint: 3CD2 A48F 2071 61C0 B9B7 1AE2 6170 15B8 4013 DDA7)
    
  
  Test against fake data and accounts, not our users’ private data (please ask if you’d like a free account to work on this)
  Work with us to close the vulnerability before disclosing it to others


          


Email security@circleci.com 

        
      
    
  





  
    
      Learn more
      

  Previous
  
  Next

    
  
  
    
      
        
        
          
            
            
          
          
            
              Blog post
              Integrate CircleCI with HashiCorp Vault using OIDC
            
            Learn more
          
        
      
        
        
          
            
            
          
          
            
              Blog post
              Security best practices for CI/CD
            
            Learn more
          
        
      
        
        
          
            
            
          
          
            
              Ebook
              Vulnerability management and DevSecOps with CI/CD
            
            Learn more\n\nYour security is our priority
      
        
          At CircleCI, our top concern is protecting our users’ intellectual property and sensitive secrets such as keys, tokens, and credentials.

        
      
      
        

  
    
    
      
        
        Request a security report
      
    
  
    
    
      
        
        Report a security issue
      
    
  

      
    
    
  







  
  
    
        
          Compliance and authorizations
          CircleCI takes the security of your applications seriously. We partner with the top security organizations to ensure that your projects are built, deployed, and maintained securely.

        
      
        
          
          
            
              
  
  
    
    FedRAMP tailored
    First CI/CD tool to meet the rigorous security and privacy NIST-standards of FedRAMP

  
  

            
              
  
  
    
    SOC 2 Type II compliant
    SOC 2 Type II compliance is a component of the American Institute of CPAs (AICPA)’s Service Organization Control reporting platform

  
  

            
          
        
        
          
            
              

            
          
        
      
    
  





  
    
      Product security features
      Get the compliance, security, and audit logging features that you need. Choose our cloud-hosted service with the option to use CircleCI compute and self-hosted runners, or run your own instance of CircleCI entirely on your own infrastructure.

    
    
      
        
        
        
        
        
        
          Source code security
          Communication with your VCS to access source code is always encrypted over the wire using SSH and/or HTTPS.

        
      
        
        
        
        
        
        
          Config policies
          Enforce organizational compliance and standardization across projects.

        
      
        
        
        
        
        
        
          Environment variables (secrets)
          Protect secrets and other sensitive data in CircleCI using environment variables.

        
      
        
        
        
        
        
        
          OpenID Connect
          CircleCI supports authentication via OpenID Connect at the job level. Using OIDC, pipelines can authenticate to systems like Vault, AWS and GCP without distributing secrets.

        
      
        
        
        
        
        
        
          Restricted contexts
          Restricted contexts allow encrypted storage and sharing of environment variables across multiple projects while limiting access to certain user groups or at the project level.

        
      
        
        
        
        
        
        
          Audit logging
          Use audit logs to monitor anomalies, assist in forensics, and demonstrate compliance.

        
      
        
        
        
        
        
        
          Runtime isolation
          CircleCI runs all builds in isolated sandboxes that are destroyed after each use.

        
      
        
        
        
        
        
        
          Console output and artifacts
          Encryption is employed over the wire using SSH and/or HTTPS for both console output and artifacts. Both are only available to those with read access to your repository.

        
      
        
        
        
        
        
        
          Two-factor authentication
          CircleCI inherits 2FA authentication established in your third-party VCS provider.

        
      
    
  

























  
  
    
      

    
  



  
    
      
      Compliance & certifications
      
        
          
            Current compliance & certifications
          
          
            
              
                
                  SOC 2 Type II compliant
                
                
                  SOC 2 Type II provides CircleCI with an opportunity to meet (and exceed) industry standards and gives our customer organization’s access to industry-recognized, standardized reports that they can compare across services in our space. Achieving SOC 2 Type II compliance means that CircleCI has put in place and follows the procedures and security policies necessary to reduce risks, and that their processes can be requested and audited.

Learn more about SOC 2 Type II at https://www.aicpa.org/.

                
              
            
              
                
                  FedRAMP tailored
                
                
                  Our FedRAMP Tailored designation demonstrates that CircleCI meets US government data security standards and is authorized for use within US government agencies.

Learn more about the FedRAMP certification at https://www.fedramp.gov/.

                
              
            
              
                
                  Data privacy frameworks
                
                
                  The certification ensures that CircleCI meets all data transfer security standards for the United States, the EU, the UK (and Gibraltar) and Switzerland under the EU-U.S. Data Privacy Framework, the UK Extension to the EU-U.S. Data Privacy Framework, and the Swiss-U.S. Data Privacy Framework as set forth by the U.S. Department of Commerce.

Learn more about the Data Privacy Framework at https://www.dataprivacyframework.gov/.

                
              
            
              
                
                  PCI compliance
                
                
                  CircleCI leverages the PCI compliance of Stripe.

                
              
            
          
        
      
    
      
      Business practices
      
        
          
            Personnel & Processors
          
          
            
              
                
                  Background checks
                
                
                  All CircleCI employees and contractors must pass a background check and sign confidentiality agreements.

                
              
            
              
                
                  Employee security awareness
                
                
                  CircleCI mandates that new employees attend classes covering security best practices.

                
              
            
              
                
                  Engineer security education
                
                
                  Engineers are required to attend an additional technical security workshop.

                
              
            
              
                
                  Policies
                
                
                  CircleCI maintains various security policies which are maintained and communicated by our security management team.

                
              
            
              
                
                  Partner management
                
                
                  CircleCI requires all partners and third-party vendors to fill out a security questionnaire. Those which handle PII are also required to sign a Data Processing Addendum.

                
              
            
          
        
      
        
          
            Security incident response
          
          
            
              
                
                  Response team
                
                
                  CircleCI maintains a dedicated Incident Response Team.

                
              
            
              
                
                  Response policy + plan
                
                
                  CircleCI maintains an Incident Response Policy and Runbook to facilitate decision making during critical situations.

                
              
            
              
                
                  Communication
                
                
                  Network and security incidents are published at https://status.circleci.com/.
At our discretion, based on the nature of a security incident, we
may contact customers directly and/or publish security alert
information to https://circleci.com/blog/
in addition to (or in lieu of) posting to our general status page.

                
              
            
          
        
      
    
      
      Physical security
      
        
          
            Offices security
          
          
            
              
                
                  Headquarters security
                
                
                  CircleCI headquarters employs 24-hour door personnel and badge access is required at all hours. Visitors are required to sign in and be escorted at all times.

                
              
            
              
                
                  Remote offices security
                
                
                  CircleCI’s remote offices in Denver, Japan, and London implement similar physical security controls to the San Francisco headquarters.

                
              
            
          
        
      
        
          
            Fleet security
          
          
            
              
                
                  Linux fleet security
                
                
                  CircleCI uses Amazon and Google Cloud Platform for its computing. Both vendors are industry leaders in security and privacy.

                
              
            
              
                
                  macOS fleet security
                
                
                  CircleCI operates macOS fleets housed at three data centers, located in Milwaukee, Las Vegas, and Atlanta. No CircleCI employee has physical access to the machines and all administration is done remotely. Data center engineers are the only people with access to provisioning machines, updating or deprovisioning machines. Federal regulators completed a full-day onsite audit in 2022 to assess the security, availability and integrity of the facility. Additionally, a penetration test was performed in late 2022 to identify and resolve any potential threats to the platform. Extensive badging, access logging, and other security controls are in place, all of which have been audited and approved under SOC 2 Type II compliance programs at CircleCI or the data center provider.

                
              
            
          
        
      
    
      
      Network & data security
      
        
          
            Network security
          
          
            
              
                
                  Vulnerability scanning
                
                
                  CircleCI implements a Docker-centric vulnerability scanning tool in its software development CI/CD process. Patching timelines for CircleCI’s cloud service are:

  Critical – 14 days
  High – 14 days
  Medium – 30 days
  Low – 30 days


Monthly scans are submitted to federal authorities as part of ongoing FedRAMP compliance.

                
              
            
              
                
                  Internal systems auditing
                
                
                  CircleCI maintains a formal Audit Policy governing application events, system events, hardware events, and physical access. This includes the what, when, and where of the event, its source, its object, its outcome, and the person associated with it.

                
              
            
              
                
                  Architecture
                
                
                  CircleCI’s architecture consists of multiple layers of data security including a DMZ, bastion hosts, and firewalls.

                
              
            
              
                
                  Global distribution
                
                
                  CircleCI’s Site Reliability, Support and Engineering teams are globally distributed for 24/7/365 coverage.

                
              
            
              
                
                  Build isolation
                
                
                  CircleCI runs all builds in isolated sandboxes that are destroyed after each use.

                
              
            
          
        
      
        
          
            Data security
          
          
            
              
                
                  Traffic encryption
                
                
                  All data in transit is encrypted via TLS and SSH.

                
              
            
              
                
                  Environment variable encryption
                
                
                  Environment variables are encrypted at rest and in transit, and injected into the runtime environment at the start of a job. All sensitive secrets such as keys, tokens, and other credentials should be stored as environment variables within CircleCI.

                
              
            
              
                
                  Source code encryption
                
                
                  Source code is always encrypted via TLS and SSH in transit, but is not encrypted at rest. Source code at rest is secured behind multiple layers of architecture security such as DMZ, bastion hosts, and firewalls.

                
              
            
              
                
                  Data backup
                
                
                  CircleCI maintains a Data Backup and Snapshot Policy that requires restoration capabilities within common industry timelines.

                
              
            
          
        
      
    
      
      Application security
      
        
          
            Secure development
          
          
            
              
                
                  Secure coding
                
                
                  The Software Development Lifecycle Policy dictates delivery, review and merge processes to minimize rollbacks, downtime, design flaws and security incidents.

                
              
            
              
                
                  Site reliability
                
                
                  CircleCI employs a team of Site Reliability Engineers ensuring that the CircleCI application security layers are consistently maintained.

                
              
            
          
        
      
        
          
            Application-level security
          
          
            
              
                
                  OWASP Top 10
                
                
                  CircleCI’s web application is designed to withstand OWASP Top 10 matters such as injections, broken authentication and session management, cross-site scripting (XSS), insecure direct object references, missing function level access control, cross-site request forgery (CSRF), unvalidated redirects and forwards.

                
              
            
              
                
                  Application penetration testing
                
                
                  Third-party penetration testers are hired annually to test the CircleCI application, network, infrastructure, and new products for vulnerabilities. Coverage ranges from OWASP Top 10 to threat modeling of new product features.

                
              
            
          
        
      
    
  






  
    
      Have a security concern about CircleCI?
      
        
          
          
            
            





          
        
      
    
    
      
      
        
          Finding serious security issues
          If you find any of the following issues, please contact us with relevant details including steps to reproduce or a proof-of-concept.

  Injection vulnerabilities
  Authentication or session problems
  Improper access to sensitive data
  Broken access controls
  Cross-site scripting
  Anything from the OWASP Top 10 Project
  Email spoofing, SPF, DKIM, and DMARC errors


Reports we do not act on

  Credentials in a 3rd party’s .circleci/config.yml


CircleCI does not have a bounty program We do not offer bug bounties for discovered vulnerabilities. We hope that if you discover vulnerabilities in the course of your work that you share them with us so we can improve the health of the internet ecosystem.

          

        
      
        
          Protect our users’ data
          Upon discovering a vulnerability, we ask that you:

  Inform us as soon as possible, contact our security team by email at security@circleci.com
    
      If you are reporting a sensitive issue, please encrypt your message using our security team’s GPG key (ID: 0x4013DDA7, fingerprint: 3CD2 A48F 2071 61C0 B9B7 1AE2 6170 15B8 4013 DDA7)
    
  
  Test against fake data and accounts, not our users’ private data (please ask if you’d like a free account to work on this)
  Work with us to close the vulnerability before disclosing it to others


          


Email security@circleci.com 

        
      
    
  





  
    
      Learn more
      

  Previous
  
  Next

    
  
  
    
      
        
        
          
            
            
          
          
            
              Blog post
              Integrate CircleCI with HashiCorp Vault using OIDC
            
            Learn more
          
        
      
        
        
          
            
            
          
          
            
              Blog post
              Security best practices for CI/CD
            
            Learn more
          
        
      
        
        
          
            
            
          
          
            
              Ebook
              Vulnerability management and DevSecOps with CI/CD
            
            Learn more\n\n\n\nQuickstart guide1 month ago3 min readCloudOn This PagePrerequisites1. Connect your code2. Dig into your first pipeline3. Debug and iterateNext steps   This quickstart provides a guided tour through setting up a project, collaborating, and tools to iterate on and debug your build configuration. The following sections cover the following:     Create a project, connecting some existing code to CircleCI.   Inviting team members to collaborate on your new project.   Use the VS Code extension to debug and extend your config.   SSH into a build to debug your project.     If you would rather jump to a full list of CircleCI config.yml options, see the  Configuration reference.     Prerequisites     A CircleCI account. You can  sign up for free.   A code repository you want to build on CircleCI.        1. Connect your code    Create a project, connect your new code repository, and commit a CircleCI configuration file. View your project build in the CircleCI app.            This guide assumes you have signed up and   connected to GitHub, Bitbucket or GitLab          Check your project slug to discover which GitHub integration you have set up:     Head to the  CircleCI web app and select your org from the cards on your user homepage.   Select Projects from the sidebar and locate your project from the list. You can use the search to help.   Select the ellipsis menu () next to your project and select Project Settings. The project slug is listed on the project settings homepage.    GitHub App: Project slug starts with circleci followed by UUIDs. For example, circleci/34R3kN5RtfEE7v4sa4nWAU/4nYdoKGkb6RXn7JGt8SQtg).   GitHub OAuth app: Project slug is human readable. For example, github/circleci/circleci-demo-workflows.        For more information about the differences, see the  VCS integration overview.        GitHub AppGitLab & Bitbucket Data CenterGitHub OAuth app & Bitbucket Cloud    1. Create a project In the  CircleCI web app select your org, then select Create Project, then follow the instructions in the app. Don’t see these options? Select the CircleCI logo in the top bar to get back to your user homepage and check you have the correct org selected.        2. Set up a pipeline Follow the in-app instructions to set up your pipelinem including connecting your code, preparing a config file and reviewing triggers. For a more detailed look at this process see the  Create a project guide.        3. Commit and run Once you have gone through the pipeline setup process in the app you have everything you need to commit your config (unless you have a config in your repo already) and build. Review your project details and select Commit config and run.        4. Congratulations 🎉 You should soon have a passing pipeline. In the next sections we will cover ways to modify and debug your config.           1. Create a project In the CircleCI web app, select  Projects from the sidebar. Click Create Project, then select the repository you would like to connect from the dropdown. Don’t see these options? Use the org selector in the top left corner to find the correct organization.        2. Select a config.yml In the “Select your  config.yml file” modal, select Fast, then give your project a name, and click Create Project. If you are authenticated through the GitHub App, you also need to set up SSH access for your project at this point.        3. CircleCI config editor You are now in the  CircleCI config editor, pre-populated with a sample config.yml file. You can swap out this config for an alternative by clicking Change: Hello World.        4. Commit your config Click Commit and Run. This will create a .circleci/config.yml file at the root of your repository on a new branch called update-circleci-config.        5. Congratulations 🎉 You should soon have a passing pipeline. If you are happy with this configuration, merge it into your main branch, or continue to make changes.           1. Set up a project In the  CircleCI web app select your org, then select Set up a Project, then select Set up Project next to your project in the list. Don’t see these options? Select the CircleCI logo in the top bar to get back to your user homepage and check you have the correct org selected.        2. Select a config.yml In the “Select your config.yml file” modal, select Faster, then click Set Up Project.        3. Congratulations 🎉 You should soon have a passing pipeline. In the next sections we will cover ways to modify and debug your config.           2. Dig into your first pipeline    Explore your passing pipeline and invite your teammates to join you, for free. By collaborating, you can troubleshoot, get pull requests approved, and build and test faster.       1. So, what just happened? Expand your workflow and select a job to view the steps that ran. Use the tabs along the top to access test results, timing data, artifacts, and resource usage metrics.        2. View step output Exand any step to view the build output. You can search, share or download the output for collaboration and debugging. If a step fails, use the  Explain this error button for help.        3. Invite teammates Invite teammates to collaborate on your projects. Navigate to Organization Settings > People to generate invites and get further instructions. Collaborators can view and follow your projects. Teammates can make a free CircleCI account at any time to view your pipelines, even if they are not committing any code.       3. Debug and iterate    Discover CircleCI features to help debug and configure your builds.       1. Rerun with SSH To access a job's build environment for troubleshooting, rerun the job with SSH access. The VM remains active for 10 minutes after the pipeline finishes. For full details, see the  Debug with SSH page.        2. VS Code extention Using the  CircleCI VS Code extention, validate your CircleCI config file. Get help with troubleshooting config updates and help keeping dependencies up to date.            Next steps      CircleCI foundation videos    Introduction to configuration    CircleCI concepts    Benefits of CircleCI Free Plan     Suggest an edit to this pageMake a contribution Learn how to contributeStill need help? Ask the CircleCI community Join the research community Visit our Support site\n\nQuickstart guide1 month ago3 min readCloudOn This PagePrerequisites1. Connect your code2. Dig into your first pipeline3. Debug and iterateNext steps   This quickstart provides a guided tour through setting up a project, collaborating, and tools to iterate on and debug your build configuration. The following sections cover the following:     Create a project, connecting some existing code to CircleCI.   Inviting team members to collaborate on your new project.   Use the VS Code extension to debug and extend your config.   SSH into a build to debug your project.     If you would rather jump to a full list of CircleCI config.yml options, see the  Configuration reference.     Prerequisites     A CircleCI account. You can  sign up for free.   A code repository you want to build on CircleCI.        1. Connect your code    Create a project, connect your new code repository, and commit a CircleCI configuration file. View your project build in the CircleCI app.            This guide assumes you have signed up and   connected to GitHub, Bitbucket or GitLab          Check your project slug to discover which GitHub integration you have set up:     Head to the  CircleCI web app and select your org from the cards on your user homepage.   Select Projects from the sidebar and locate your project from the list. You can use the search to help.   Select the ellipsis menu () next to your project and select Project Settings. The project slug is listed on the project settings homepage.    GitHub App: Project slug starts with circleci followed by UUIDs. For example, circleci/34R3kN5RtfEE7v4sa4nWAU/4nYdoKGkb6RXn7JGt8SQtg).   GitHub OAuth app: Project slug is human readable. For example, github/circleci/circleci-demo-workflows.        For more information about the differences, see the  VCS integration overview.        GitHub AppGitLab & Bitbucket Data CenterGitHub OAuth app & Bitbucket Cloud    1. Create a project In the  CircleCI web app select your org, then select Create Project, then follow the instructions in the app. Don’t see these options? Select the CircleCI logo in the top bar to get back to your user homepage and check you have the correct org selected.        2. Set up a pipeline Follow the in-app instructions to set up your pipelinem including connecting your code, preparing a config file and reviewing triggers. For a more detailed look at this process see the  Create a project guide.        3. Commit and run Once you have gone through the pipeline setup process in the app you have everything you need to commit your config (unless you have a config in your repo already) and build. Review your project details and select Commit config and run.        4. Congratulations 🎉 You should soon have a passing pipeline. In the next sections we will cover ways to modify and debug your config.           1. Create a project In the CircleCI web app, select  Projects from the sidebar. Click Create Project, then select the repository you would like to connect from the dropdown. Don’t see these options? Use the org selector in the top left corner to find the correct organization.        2. Select a config.yml In the “Select your  config.yml file” modal, select Fast, then give your project a name, and click Create Project. If you are authenticated through the GitHub App, you also need to set up SSH access for your project at this point.        3. CircleCI config editor You are now in the  CircleCI config editor, pre-populated with a sample config.yml file. You can swap out this config for an alternative by clicking Change: Hello World.        4. Commit your config Click Commit and Run. This will create a .circleci/config.yml file at the root of your repository on a new branch called update-circleci-config.        5. Congratulations 🎉 You should soon have a passing pipeline. If you are happy with this configuration, merge it into your main branch, or continue to make changes.           1. Set up a project In the  CircleCI web app select your org, then select Set up a Project, then select Set up Project next to your project in the list. Don’t see these options? Select the CircleCI logo in the top bar to get back to your user homepage and check you have the correct org selected.        2. Select a config.yml In the “Select your config.yml file” modal, select Faster, then click Set Up Project.        3. Congratulations 🎉 You should soon have a passing pipeline. In the next sections we will cover ways to modify and debug your config.           2. Dig into your first pipeline    Explore your passing pipeline and invite your teammates to join you, for free. By collaborating, you can troubleshoot, get pull requests approved, and build and test faster.       1. So, what just happened? Expand your workflow and select a job to view the steps that ran. Use the tabs along the top to access test results, timing data, artifacts, and resource usage metrics.        2. View step output Exand any step to view the build output. You can search, share or download the output for collaboration and debugging. If a step fails, use the  Explain this error button for help.        3. Invite teammates Invite teammates to collaborate on your projects. Navigate to Organization Settings > People to generate invites and get further instructions. Collaborators can view and follow your projects. Teammates can make a free CircleCI account at any time to view your pipelines, even if they are not committing any code.       3. Debug and iterate    Discover CircleCI features to help debug and configure your builds.       1. Rerun with SSH To access a job's build environment for troubleshooting, rerun the job with SSH access. The VM remains active for 10 minutes after the pipeline finishes. For full details, see the  Debug with SSH page.        2. VS Code extention Using the  CircleCI VS Code extention, validate your CircleCI config file. Get help with troubleshooting config updates and help keeping dependencies up to date.            Next steps      CircleCI foundation videos    Introduction to configuration    CircleCI concepts    Benefits of CircleCI Free Plan     Suggest an edit to this pageMake a contribution Learn how to contributeStill need help? Ask the CircleCI community Join the research community Visit our Support site DocsTerms of UsePrivacy PolicyCookie PolicySecurity© 2025 Circle Internet Services, Inc., All Rights Reserved.\n\nCheck your project slug to discover which GitHub integration you have set up:     Head to the  CircleCI web app and select your org from the cards on your user homepage.   Select Projects from the sidebar and locate your project from the list. You can use the search to help.   Select the ellipsis menu () next to your project and select Project Settings. The project slug is listed on the project settings homepage.    GitHub App: Project slug starts with circleci followed by UUIDs. For example, circleci/34R3kN5RtfEE7v4sa4nWAU/4nYdoKGkb6RXn7JGt8SQtg).   GitHub OAuth app: Project slug is human readable. For example, github/circleci/circleci-demo-workflows.        For more information about the differences, see the  VCS integration overview.     1. Create a project In the  CircleCI web app select your org, then select Create Project, then follow the instructions in the app. Don’t see these options? Select the CircleCI logo in the top bar to get back to your user homepage and check you have the correct org selected.        2. Set up a pipeline Follow the in-app instructions to set up your pipelinem including connecting your code, preparing a config file and reviewing triggers. For a more detailed look at this process see the  Create a project guide.        3. Commit and run Once you have gone through the pipeline setup process in the app you have everything you need to commit your config (unless you have a config in your repo already) and build. Review your project details and select Commit config and run.        4. Congratulations 🎉 You should soon have a passing pipeline. In the next sections we will cover ways to modify and debug your config.         1. Create a project In the CircleCI web app, select  Projects from the sidebar. Click Create Project, then select the repository you would like to connect from the dropdown. Don’t see these options? Use the org selector in the top left corner to find the correct organization.        2. Select a config.yml In the “Select your  config.yml file” modal, select Fast, then give your project a name, and click Create Project. If you are authenticated through the GitHub App, you also need to set up SSH access for your project at this point.        3. CircleCI config editor You are now in the  CircleCI config editor, pre-populated with a sample config.yml file. You can swap out this config for an alternative by clicking Change: Hello World.        4. Commit your config Click Commit and Run. This will create a .circleci/config.yml file at the root of your repository on a new branch called update-circleci-config.        5. Congratulations 🎉 You should soon have a passing pipeline. If you are happy with this configuration, merge it into your main branch, or continue to make changes.         1. Set up a project In the  CircleCI web app select your org, then select Set up a Project, then select Set up Project next to your project in the list. Don’t see these options? Select the CircleCI logo in the top bar to get back to your user homepage and check you have the correct org selected.        2. Select a config.yml In the “Select your config.yml file” modal, select Faster, then click Set Up Project.        3. Congratulations 🎉 You should soon have a passing pipeline. In the next sections we will cover ways to modify and debug your config.\n\n\n\nExamples and guides overview2 weeks ago1 min readCloudServer v4+On This PageLanguage guidesPlatform guidesNext steps   This page provides a collection of examples to help you learn how to build, test, and deploy applications written in the most common programming languages, frameworks, and platforms on CircleCI.   If you are new to CircleCI, we recommend going through our  Quickstart Guide for getting your first successful pipeline.   For basic examples of adding pipeline jobs in a specific execution environment such as a Docker container or Linux VM, review our  Hello World document.     Language guides   To get a project up and running on CircleCI, see the following quickstart guides:      Configure a Node.js application on CircleCI    Configure a Python application on CircleCI    Configure a Go application on CircleCI     We have created demo applications in various languages so you can learn by example. Each language listed below has an associated guide and public repository on GitHub.  Language GuideFrameworkGitHub Repo Name Configuring a Node.js Application on CircleCI^Vue.js sample-javascript-cfd Configuring a Python Application on CircleCI^Flask sample-python-cfd JavaSpring Boot sample-java-cfd C#/.NETASP.NET Core sample-dotnet-cfd Mono repo - Python backend and Node.js frontendFlask, Vue.js sample-monorepo-cfd    Platform guides   Use the tutorial associated with your platform to learn about the customization that is possible in a  .circleci/config.yml.  Platform guideDescription macOS Project TutorialSet up a macOS project in CircleCI. Testing iOSSet up and test iOS projects in CircleCI. Windows Project TutorialFull example of setting up a .NET project in CircleCI.    Next steps     Read the  Sample config.yml Files document for examples of using concurrent workflows, sequential workflows, fan-in/fan-out workflows, and building Linux and iOS in one configuration file.   Refer to the  Configuration reference page for detailed syntax.     Suggest an edit to this pageMake a contribution Learn how to contributeStill need help? Ask the CircleCI community Join the research community Visit our Support site\n\nExamples and guides overview2 weeks ago1 min readCloudServer v4+On This PageLanguage guidesPlatform guidesNext steps   This page provides a collection of examples to help you learn how to build, test, and deploy applications written in the most common programming languages, frameworks, and platforms on CircleCI.   If you are new to CircleCI, we recommend going through our  Quickstart Guide for getting your first successful pipeline.   For basic examples of adding pipeline jobs in a specific execution environment such as a Docker container or Linux VM, review our  Hello World document.     Language guides   To get a project up and running on CircleCI, see the following quickstart guides:      Configure a Node.js application on CircleCI    Configure a Python application on CircleCI    Configure a Go application on CircleCI     We have created demo applications in various languages so you can learn by example. Each language listed below has an associated guide and public repository on GitHub.  Language GuideFrameworkGitHub Repo Name Configuring a Node.js Application on CircleCI^Vue.js sample-javascript-cfd Configuring a Python Application on CircleCI^Flask sample-python-cfd JavaSpring Boot sample-java-cfd C#/.NETASP.NET Core sample-dotnet-cfd Mono repo - Python backend and Node.js frontendFlask, Vue.js sample-monorepo-cfd    Platform guides   Use the tutorial associated with your platform to learn about the customization that is possible in a  .circleci/config.yml.  Platform guideDescription macOS Project TutorialSet up a macOS project in CircleCI. Testing iOSSet up and test iOS projects in CircleCI. Windows Project TutorialFull example of setting up a .NET project in CircleCI.    Next steps     Read the  Sample config.yml Files document for examples of using concurrent workflows, sequential workflows, fan-in/fan-out workflows, and building Linux and iOS in one configuration file.   Refer to the  Configuration reference page for detailed syntax.     Suggest an edit to this pageMake a contribution Learn how to contributeStill need help? Ask the CircleCI community Join the research community Visit our Support site DocsTerms of UsePrivacy PolicyCookie PolicySecurity© 2025 Circle Internet Services, Inc., All Rights Reserved.\n\n\n\nConfiguration introduction2 weeks ago7 min readCloudServer v4+On This PageGetting started with CircleCI configPart 1: Using the shellPart 2: Using code from your repositoryPart 3: Using different environments and creating workflowsPart 4: Adding a manual approvalVS Code extensionSee also   This guide gets you started with the CircleCI config.yml file.     Getting started with CircleCI config   This guide covers the following topics:     How CircleCI finds and runs config.yml.   How you can use shell commands to perform actions.   How config.yml interacts with your code.   How to trigger a build.   How to use Docker containers to run your jobs in a specific environment.   How to use workflows to orchestrate your build.   How to add approval steps to your workflow.     CircleCI believes in configuration as code. Consequently, the entire delivery process from build to deploy is orchestrated through a single file called config.yml. The config.yml file is located in a folder called .circleci at the top of your repository project. CircleCI uses the YAML syntax for config. See the  Introduction to YAML configurations page for guidance on the basics.     Part 1: Using the shell   CircleCI provides an on-demand shell to run commands. In this first example, you will set up a build and execute a shell command.     If you have not done so already,  sign up with CircleCI and then either create or set up a new project. You can follow the steps to connect a code repository in our  Quickstart guide.   Once you have created or set up your project in CircleCI, go to the .circleci/config.yml file and replace its contents with the following code:     Using Docker? Authenticating Docker pulls from image registries is recommended when using the Docker execution environment. Authenticated pulls allow access to private Docker images, and may also grant higher rate limits, depending on your registry provider. For further information see  Using Docker authenticated pulls.         version: 2.1
jobs:
  build:
    docker:
      - image: alpine:3.15
    steps:
      - run:
          name: The First Step
          command: |
            echo 'Hello World!'
            echo 'This is the delivery pipeline'    The following commentary describes what occurs in each line of the sample code:     Line 1: This indicates the version of the CircleCI platform you are using. 2.1 is the most recent version.   Line 2: The jobs level contains a collection of children, representing your jobs. You specify the names for these jobs, for example, build, test, deploy.   Line 3: build is the first child in the jobs collection. In this example, build is also the only job.   Line 4: This specifies that you are using a Docker image for the container where your job’s commands are run.   Line 5: This is the Docker image. The example shows alpine:3.15, a minimal image based on Alpine Linux.  As mentioned in the note above the sample code, you may optionally supply your Docker credentials when using a Docker executor.    Line 6: The steps collection is a list of run directives.   Line 7: Each run directive is executed in the order in which it is declared.   Line 8: The name attribute provides useful information when returning warnings, errors, and output. The name should be meaningful to you as an action within your build process.   Line 9: The command attribute is a list of shell commands that you want to execute. The initial pipe, |, indicates there will be multiple lines of shell commands.   Line 10: Prints Hello World! in your build shell.   Line 11: Prints This is the delivery pipeline.      Commit your config.yml file (and push, if you are working remotely).   A new pipeline is triggered in CircleCI. You can see the output in the  CircleCI dashboard. A green tick denotes a successful pipeline. A red exclamation mark alerts you to a failure. Click on the job for more details.       You should see your step - The First Step - with the output of the commands:            Although the config.yml syntax itself is straightforward, the indentation is more complicated. Incorrect indentation is the most common error. If you are experiencing problems with this example, check your indentation carefully, or copy and paste the sample code.          Part 2: Using code from your repository   CircleCI provides several commands to simplify complex actions. In this example, you will use the checkout command. This command fetches the code from your git repository. Once you have retrieved that code, you can work with it in subsequent steps.   If you have not done so already, create a .circleci directory in your project, add a config.yml file, and type or paste the code from the example below.   If you already have a config.yml file from the example above, here are the changes you need to make:     On Line 5, change the image to cimg/base:2021.04.   On Line 7, add a checkout command.   Add another run step (lines 13-17) at the end.     Make sure you observe the indentation.    version: 2.1
jobs:
  build:
    docker:
      - image: cimg/base:2021.04
    steps:
      - checkout
      - run:
          name: The First Step
          command: |
            echo 'Hello World!'
            echo 'This is the delivery pipeline'
      - run:
          name: The Second Step
          command: |
            ls -al
            echo '^^^The files in your repo^^^'    These two small changes have significantly increased the functionality of your config file:     Line 5: This line now specifies a Docker image that supports git. cimg/base:2021.04 is a small Ubuntu-based image for running basic jobs.   Line 7: The checkout command fetches the code from your git repository.   Lines 13-17: This second step in the build job is listing (using ls -al) the contents of the repository that has been checked out. You can now perform further actions on this repository.     As before, commit and push your updated config.yml file.   You should now see some additional steps on the CircleCI dashboard:     Checkout code has cloned the code from your git repository.   The Second Step has listed the files found in your git repository.            Part 3: Using different environments and creating workflows   In Parts 1 and 2, you ran your job in basic Linux-based Docker containers.   With CircleCI, you can run different jobs in different execution environments, such as virtual machines or Docker containers. By changing the Docker image, you can quickly upgrade your environment version or change languages.   In this part, you will create additional jobs and run them using different Docker images.   If you have not done so already, create a .circleci directory in your project, add a config.yml file, and type or paste the code from the example below.    version: 2.1
jobs:
  # running commands on a basic image
  Hello-World:
    docker:
      - image: cimg/base:2021.04
    steps:
      - run:
          name: Saying Hello
          command: |
            echo 'Hello World!'
            echo 'This is the delivery pipeline'
  # fetching code from the repo
  Fetch-Code:
    docker:
      - image: cimg/base:2021.04
    steps:
      - checkout
      - run:
          name: Getting the Code
          command: |
            ls -al
            echo '^^^Your repo files^^^'
  # running a node container
  Using-Node:
    docker:
      - image: cimg/node:17.2
    steps:
      - run:
          name: Running the Node Container
          command: |
            node -v
workflows:
  Example-Workflow:
    jobs:
      - Hello-World
      - Fetch-Code:
          requires:
            - Hello-World
      - Using-Node:
          requires:
            - Fetch-Code    This example is more complicated than the others, but it introduces several important concepts. Parts 1 and 2 included just one job called build, which contained several steps. This example includes three jobs. By separating those steps into jobs, you can run each of them in a different environment.   The following commentary describes what occurs in each line of the sample code:     Line 3: You can add comments to your config.yml file by preceding them with the # (hash) sign.   Lines 4-12: The first job is Hello-World. As in Part 1, it runs two commands in a basic image.   Line 14: The second job is Fetch-Code. It is indented to align with the Hello-World job.   Lines 15-16: The Fetch-Code job uses a basic git-compatible image.   Lines 17-23: This code is repeated from Part 2, but now it is a separate job.   Line 25: The third job is Using-Node.   Lines 26-27: This Using-Node job uses a Docker image called cimg/node:17.2. This image contains version 17.2 of Node, along with a browser and other useful tools.   Lines 28-32: As in the previous jobs, there is a run step. This time, the command node -v prints the version of Node running in the container.   Lines 33-34: This line creates a workflow called Example-Workflow. Workflows define a list of jobs and their run order.   Lines 35-36: These lines specify the first job, Hello-World.   Lines 37-39: The syntax for the Fetch-Code job is slightly different. The job name is followed by a requires:, then a requires statement. This line specifies that the Hello-World job must run successfully before the Fetch-Code job is executed.   Lines 40-42: The final job is Using-Node. As before, this job requires the successful completion of the previous job, Fetch-Code.     As before, commit and push your updated config.yml file.   In CircleCI, your pipeline will look different. Your workflow is now called Example-Workflow and you have three jobs, rather than just one.        If you click on the Using-Node job and then the Running the Node Container step, you should see that the command node -v has printed the version of Node.        In this example, you have:     Added comments to document your jobs.   Created multiple jobs to run in different Docker containers.   Created a workflow to define the order in which your jobs run.   Introduced some logic to ensure that the previous job must complete successfully before the next job is executed.        To increase your understanding, experiment with other  CircleCI images, or add some more jobs to your workflow.          Part 4: Adding a manual approval   The CircleCI workflow model is based on the orchestration of preceding jobs. As you saw in Part 3, the requires statement specifies that a job should run only if the previous job has been successfully executed.   In Part 3, an event triggering the pipeline caused the Hello-World job to run immediately. The remaining jobs ran automatically, once Hello-World had completely successfully.   In this part, you will create a manual approval stage. This means subsequent jobs are executed only after you have approved the next step in the CircleCI app.   If you have not done so already, create a .circleci directory in your project, add a config.yml file, and type or paste the code from the example below:    version: 2.1
jobs:
  # running commands on a basic image
  Hello-World:
    docker:
      - image: alpine:3.15
    steps:
      - run:
          name: Saying Hello
          command: |
            echo 'Hello World!'
            echo 'This is the delivery pipeline'
  # fetching code from the repo
  Fetch-Code:
    docker:
      - image: cimg/base:2021.04
    steps:
      - checkout
      - run:
          name: Getting the Code
          command: |
            ls -al
            echo '^^^Your repo files^^^'
  # running a node container
  Using-Node:
    docker:
      - image: cimg/node:17.2
    steps:
      - run:
          name: Running the Node Container
          command: |
            node -v
  Now-Complete:
    docker:
      - image: alpine:3.15
    steps:
      - run:
          name: Approval Complete
          command: |
            echo 'The work is now complete.'

workflows:
  Example-Workflow:
    jobs:
      - Hello-World
      - Fetch-Code:
          requires:
            - Hello-World
      - Using-Node:
          requires:
            - Fetch-Code
      - Hold-for-Approval:
          type: approval
          requires:
            - Using-Node
            - Fetch-Code
      - Now-Complete:
          requires:
            - Hold-for-Approval    Most of this code will look familiar to you. There are a couple of important additions:     Lines 52-56: This creates a new job called Hold-for-Approval. The type specifies this is an approval, so you are required to manually approve this job in CircleCI. This is useful if you want to see whether the previous jobs have been executed as expected. For example, you can check that a website looks correct on a test server before making it live. Or you might want a human to perform checks before you execute any expensive jobs.   Lines 57-59: This final job - Now-Complete - requires the successful completion of Hold-for-Approval, so will execute only once you have approved that previous job in CircleCI.     As before, commit and push your updated config.yml file.   If you look at your pipeline in CircleCI, you will see the a purple status badge of Needs Approval.        To approve the job, click the thumbs up icon to the right of the Hold-for-Approval job in the Actions column. In the pop-up message, click the blue Approve button.   Now you will see a tick in the Actions column and your jobs should complete.   Select the Now-Complete job, then the Approval Complete step. You should see the output of your command: The work is now complete.           If you encounter errors, the problem is likely to be caused by incorrect indentation. The  CircleCI Configuration Editor validates your syntax, provides autocomplete suggestions, and offers tips.        In this example, you have:     Introduced some additional logic to control your workflow.   Implemented the approval job type to require a manual approval within your workflow.     Using what you have learned above, you are ready to create some powerful pipelines.     VS Code extension   If you use VS Code, you might find the official  CircleCI extension useful when writing, editing, navigating and troubleshooting your YAML Config files.   The extension provides real-time syntax highlighting and validation, assisted navigation through go-to-definition and go-to-reference commands, usage hints, and autocomplete suggestions.        The CircleCI VS Code extension is available to download on the  VS Code marketplace.     See also      Configuring CircleCI    Executors and Images    Using Workflows to Orchestrate Jobs     Suggest an edit to this pageMake a contribution Learn how to contributeStill need help? Ask the CircleCI community Join the research community Visit our Support site\n\nConfiguration introduction2 weeks ago7 min readCloudServer v4+On This PageGetting started with CircleCI configPart 1: Using the shellPart 2: Using code from your repositoryPart 3: Using different environments and creating workflowsPart 4: Adding a manual approvalVS Code extensionSee also   This guide gets you started with the CircleCI config.yml file.     Getting started with CircleCI config   This guide covers the following topics:     How CircleCI finds and runs config.yml.   How you can use shell commands to perform actions.   How config.yml interacts with your code.   How to trigger a build.   How to use Docker containers to run your jobs in a specific environment.   How to use workflows to orchestrate your build.   How to add approval steps to your workflow.     CircleCI believes in configuration as code. Consequently, the entire delivery process from build to deploy is orchestrated through a single file called config.yml. The config.yml file is located in a folder called .circleci at the top of your repository project. CircleCI uses the YAML syntax for config. See the  Introduction to YAML configurations page for guidance on the basics.     Part 1: Using the shell   CircleCI provides an on-demand shell to run commands. In this first example, you will set up a build and execute a shell command.     If you have not done so already,  sign up with CircleCI and then either create or set up a new project. You can follow the steps to connect a code repository in our  Quickstart guide.   Once you have created or set up your project in CircleCI, go to the .circleci/config.yml file and replace its contents with the following code:     Using Docker? Authenticating Docker pulls from image registries is recommended when using the Docker execution environment. Authenticated pulls allow access to private Docker images, and may also grant higher rate limits, depending on your registry provider. For further information see  Using Docker authenticated pulls.         version: 2.1
jobs:
  build:
    docker:
      - image: alpine:3.15
    steps:
      - run:
          name: The First Step
          command: |
            echo 'Hello World!'
            echo 'This is the delivery pipeline'    The following commentary describes what occurs in each line of the sample code:     Line 1: This indicates the version of the CircleCI platform you are using. 2.1 is the most recent version.   Line 2: The jobs level contains a collection of children, representing your jobs. You specify the names for these jobs, for example, build, test, deploy.   Line 3: build is the first child in the jobs collection. In this example, build is also the only job.   Line 4: This specifies that you are using a Docker image for the container where your job’s commands are run.   Line 5: This is the Docker image. The example shows alpine:3.15, a minimal image based on Alpine Linux.  As mentioned in the note above the sample code, you may optionally supply your Docker credentials when using a Docker executor.    Line 6: The steps collection is a list of run directives.   Line 7: Each run directive is executed in the order in which it is declared.   Line 8: The name attribute provides useful information when returning warnings, errors, and output. The name should be meaningful to you as an action within your build process.   Line 9: The command attribute is a list of shell commands that you want to execute. The initial pipe, |, indicates there will be multiple lines of shell commands.   Line 10: Prints Hello World! in your build shell.   Line 11: Prints This is the delivery pipeline.      Commit your config.yml file (and push, if you are working remotely).   A new pipeline is triggered in CircleCI. You can see the output in the  CircleCI dashboard. A green tick denotes a successful pipeline. A red exclamation mark alerts you to a failure. Click on the job for more details.       You should see your step - The First Step - with the output of the commands:            Although the config.yml syntax itself is straightforward, the indentation is more complicated. Incorrect indentation is the most common error. If you are experiencing problems with this example, check your indentation carefully, or copy and paste the sample code.          Part 2: Using code from your repository   CircleCI provides several commands to simplify complex actions. In this example, you will use the checkout command. This command fetches the code from your git repository. Once you have retrieved that code, you can work with it in subsequent steps.   If you have not done so already, create a .circleci directory in your project, add a config.yml file, and type or paste the code from the example below.   If you already have a config.yml file from the example above, here are the changes you need to make:     On Line 5, change the image to cimg/base:2021.04.   On Line 7, add a checkout command.   Add another run step (lines 13-17) at the end.     Make sure you observe the indentation.    version: 2.1
jobs:
  build:
    docker:
      - image: cimg/base:2021.04
    steps:
      - checkout
      - run:
          name: The First Step
          command: |
            echo 'Hello World!'
            echo 'This is the delivery pipeline'
      - run:
          name: The Second Step
          command: |
            ls -al
            echo '^^^The files in your repo^^^'    These two small changes have significantly increased the functionality of your config file:     Line 5: This line now specifies a Docker image that supports git. cimg/base:2021.04 is a small Ubuntu-based image for running basic jobs.   Line 7: The checkout command fetches the code from your git repository.   Lines 13-17: This second step in the build job is listing (using ls -al) the contents of the repository that has been checked out. You can now perform further actions on this repository.     As before, commit and push your updated config.yml file.   You should now see some additional steps on the CircleCI dashboard:     Checkout code has cloned the code from your git repository.   The Second Step has listed the files found in your git repository.            Part 3: Using different environments and creating workflows   In Parts 1 and 2, you ran your job in basic Linux-based Docker containers.   With CircleCI, you can run different jobs in different execution environments, such as virtual machines or Docker containers. By changing the Docker image, you can quickly upgrade your environment version or change languages.   In this part, you will create additional jobs and run them using different Docker images.   If you have not done so already, create a .circleci directory in your project, add a config.yml file, and type or paste the code from the example below.    version: 2.1
jobs:
  # running commands on a basic image
  Hello-World:
    docker:
      - image: cimg/base:2021.04
    steps:
      - run:
          name: Saying Hello
          command: |
            echo 'Hello World!'
            echo 'This is the delivery pipeline'
  # fetching code from the repo
  Fetch-Code:
    docker:
      - image: cimg/base:2021.04
    steps:
      - checkout
      - run:
          name: Getting the Code
          command: |
            ls -al
            echo '^^^Your repo files^^^'
  # running a node container
  Using-Node:
    docker:
      - image: cimg/node:17.2
    steps:
      - run:
          name: Running the Node Container
          command: |
            node -v
workflows:
  Example-Workflow:
    jobs:
      - Hello-World
      - Fetch-Code:
          requires:
            - Hello-World
      - Using-Node:
          requires:
            - Fetch-Code    This example is more complicated than the others, but it introduces several important concepts. Parts 1 and 2 included just one job called build, which contained several steps. This example includes three jobs. By separating those steps into jobs, you can run each of them in a different environment.   The following commentary describes what occurs in each line of the sample code:     Line 3: You can add comments to your config.yml file by preceding them with the # (hash) sign.   Lines 4-12: The first job is Hello-World. As in Part 1, it runs two commands in a basic image.   Line 14: The second job is Fetch-Code. It is indented to align with the Hello-World job.   Lines 15-16: The Fetch-Code job uses a basic git-compatible image.   Lines 17-23: This code is repeated from Part 2, but now it is a separate job.   Line 25: The third job is Using-Node.   Lines 26-27: This Using-Node job uses a Docker image called cimg/node:17.2. This image contains version 17.2 of Node, along with a browser and other useful tools.   Lines 28-32: As in the previous jobs, there is a run step. This time, the command node -v prints the version of Node running in the container.   Lines 33-34: This line creates a workflow called Example-Workflow. Workflows define a list of jobs and their run order.   Lines 35-36: These lines specify the first job, Hello-World.   Lines 37-39: The syntax for the Fetch-Code job is slightly different. The job name is followed by a requires:, then a requires statement. This line specifies that the Hello-World job must run successfully before the Fetch-Code job is executed.   Lines 40-42: The final job is Using-Node. As before, this job requires the successful completion of the previous job, Fetch-Code.     As before, commit and push your updated config.yml file.   In CircleCI, your pipeline will look different. Your workflow is now called Example-Workflow and you have three jobs, rather than just one.        If you click on the Using-Node job and then the Running the Node Container step, you should see that the command node -v has printed the version of Node.        In this example, you have:     Added comments to document your jobs.   Created multiple jobs to run in different Docker containers.   Created a workflow to define the order in which your jobs run.   Introduced some logic to ensure that the previous job must complete successfully before the next job is executed.        To increase your understanding, experiment with other  CircleCI images, or add some more jobs to your workflow.          Part 4: Adding a manual approval   The CircleCI workflow model is based on the orchestration of preceding jobs. As you saw in Part 3, the requires statement specifies that a job should run only if the previous job has been successfully executed.   In Part 3, an event triggering the pipeline caused the Hello-World job to run immediately. The remaining jobs ran automatically, once Hello-World had completely successfully.   In this part, you will create a manual approval stage. This means subsequent jobs are executed only after you have approved the next step in the CircleCI app.   If you have not done so already, create a .circleci directory in your project, add a config.yml file, and type or paste the code from the example below:    version: 2.1
jobs:
  # running commands on a basic image
  Hello-World:
    docker:
      - image: alpine:3.15
    steps:
      - run:
          name: Saying Hello
          command: |
            echo 'Hello World!'
            echo 'This is the delivery pipeline'
  # fetching code from the repo
  Fetch-Code:
    docker:
      - image: cimg/base:2021.04
    steps:
      - checkout
      - run:
          name: Getting the Code
          command: |
            ls -al
            echo '^^^Your repo files^^^'
  # running a node container
  Using-Node:
    docker:
      - image: cimg/node:17.2
    steps:
      - run:
          name: Running the Node Container
          command: |
            node -v
  Now-Complete:
    docker:
      - image: alpine:3.15
    steps:
      - run:
          name: Approval Complete
          command: |
            echo 'The work is now complete.'

workflows:
  Example-Workflow:
    jobs:
      - Hello-World
      - Fetch-Code:
          requires:
            - Hello-World
      - Using-Node:
          requires:
            - Fetch-Code
      - Hold-for-Approval:
          type: approval
          requires:
            - Using-Node
            - Fetch-Code
      - Now-Complete:
          requires:
            - Hold-for-Approval    Most of this code will look familiar to you. There are a couple of important additions:     Lines 52-56: This creates a new job called Hold-for-Approval. The type specifies this is an approval, so you are required to manually approve this job in CircleCI. This is useful if you want to see whether the previous jobs have been executed as expected. For example, you can check that a website looks correct on a test server before making it live. Or you might want a human to perform checks before you execute any expensive jobs.   Lines 57-59: This final job - Now-Complete - requires the successful completion of Hold-for-Approval, so will execute only once you have approved that previous job in CircleCI.     As before, commit and push your updated config.yml file.   If you look at your pipeline in CircleCI, you will see the a purple status badge of Needs Approval.        To approve the job, click the thumbs up icon to the right of the Hold-for-Approval job in the Actions column. In the pop-up message, click the blue Approve button.   Now you will see a tick in the Actions column and your jobs should complete.   Select the Now-Complete job, then the Approval Complete step. You should see the output of your command: The work is now complete.           If you encounter errors, the problem is likely to be caused by incorrect indentation. The  CircleCI Configuration Editor validates your syntax, provides autocomplete suggestions, and offers tips.        In this example, you have:     Introduced some additional logic to control your workflow.   Implemented the approval job type to require a manual approval within your workflow.     Using what you have learned above, you are ready to create some powerful pipelines.     VS Code extension   If you use VS Code, you might find the official  CircleCI extension useful when writing, editing, navigating and troubleshooting your YAML Config files.   The extension provides real-time syntax highlighting and validation, assisted navigation through go-to-definition and go-to-reference commands, usage hints, and autocomplete suggestions.        The CircleCI VS Code extension is available to download on the  VS Code marketplace.     See also      Configuring CircleCI    Executors and Images    Using Workflows to Orchestrate Jobs     Suggest an edit to this pageMake a contribution Learn how to contributeStill need help? Ask the CircleCI community Join the research community Visit our Support site DocsTerms of UsePrivacy PolicyCookie PolicySecurity© 2025 Circle Internet Services, Inc., All Rights Reserved.\n\nUsing Docker? Authenticating Docker pulls from image registries is recommended when using the Docker execution environment. Authenticated pulls allow access to private Docker images, and may also grant higher rate limits, depending on your registry provider. For further information see  Using Docker authenticated pulls.  version: 2.1
jobs:
  build:
    docker:
      - image: alpine:3.15
    steps:
      - run:
          name: The First Step
          command: |
            echo 'Hello World!'
            echo 'This is the delivery pipeline'    Although the config.yml syntax itself is straightforward, the indentation is more complicated. Incorrect indentation is the most common error. If you are experiencing problems with this example, check your indentation carefully, or copy and paste the sample code.  version: 2.1
jobs:
  build:
    docker:
      - image: cimg/base:2021.04
    steps:
      - checkout
      - run:
          name: The First Step
          command: |
            echo 'Hello World!'
            echo 'This is the delivery pipeline'
      - run:
          name: The Second Step
          command: |
            ls -al
            echo '^^^The files in your repo^^^'    version: 2.1
jobs:
  # running commands on a basic image
  Hello-World:
    docker:
      - image: cimg/base:2021.04
    steps:
      - run:
          name: Saying Hello
          command: |
            echo 'Hello World!'
            echo 'This is the delivery pipeline'
  # fetching code from the repo
  Fetch-Code:
    docker:
      - image: cimg/base:2021.04
    steps:
      - checkout
      - run:
          name: Getting the Code
          command: |
            ls -al
            echo '^^^Your repo files^^^'
  # running a node container
  Using-Node:
    docker:
      - image: cimg/node:17.2
    steps:
      - run:
          name: Running the Node Container
          command: |
            node -v
workflows:
  Example-Workflow:
    jobs:
      - Hello-World
      - Fetch-Code:
          requires:
            - Hello-World
      - Using-Node:
          requires:
            - Fetch-Code      To increase your understanding, experiment with other  CircleCI images, or add some more jobs to your workflow.  version: 2.1
jobs:
  # running commands on a basic image
  Hello-World:
    docker:
      - image: alpine:3.15
    steps:
      - run:
          name: Saying Hello
          command: |
            echo 'Hello World!'
            echo 'This is the delivery pipeline'
  # fetching code from the repo
  Fetch-Code:
    docker:
      - image: cimg/base:2021.04
    steps:
      - checkout
      - run:
          name: Getting the Code
          command: |
            ls -al
            echo '^^^Your repo files^^^'
  # running a node container
  Using-Node:
    docker:
      - image: cimg/node:17.2
    steps:
      - run:
          name: Running the Node Container
          command: |
            node -v
  Now-Complete:
    docker:
      - image: alpine:3.15
    steps:
      - run:
          name: Approval Complete
          command: |
            echo 'The work is now complete.'

workflows:
  Example-Workflow:
    jobs:
      - Hello-World
      - Fetch-Code:
          requires:
            - Hello-World
      - Using-Node:
          requires:
            - Fetch-Code
      - Hold-for-Approval:
          type: approval
          requires:
            - Using-Node
            - Fetch-Code
      - Now-Complete:
          requires:
            - Hold-for-Approval      If you encounter errors, the problem is likely to be caused by incorrect indentation. The  CircleCI Configuration Editor validates your syntax, provides autocomplete suggestions, and offers tips.\n\n\n\nSample config.yml Files2 weeks ago6 min readCloudServer v4+On This PageTools for editing configuration filesSimple configuration examplesConcurrent workflowSequential workflowApproval jobHello worldSample configuration with sequential workflow and secondary Docker containerSample configuration with fan-in/fan-out workflowSample configuration with multiple executor typesSee also   This document provides sample .circleci/config.yml files that you can use as a starting point when setting up projects, or to better understand different ways to orchestrate jobs using workflows and filters. For information on all configuration elements available to you, see the  Configuration reference page.   If you would like to get set up quickly, see our language-specific quickstart guides:      Node    Python    Go       Tools for editing configuration files   CircleCI has created an  extension for Visual Studio Code that reduces context switching between the web app and VS Code through a set of helpful features.   The VS Code extension reduces the time to create, modify, and troubleshoot configuration files through real-time syntax validation, highlighting, and autocomplete suggestions. Authenticating the extension with your CircleCI account will also allow you to visualize and manage your CircleCI pipelines directly from your code editor, and be notified of workflow status changes.   The CircleCI VS Code extension is available to download on the  VS Code marketplace.     Simple configuration examples      Using Docker? Authenticating Docker pulls from image registries is recommended when using the Docker execution environment. Authenticated pulls allow access to private Docker images, and may also grant higher rate limits, depending on your registry provider. For further information see  Using Docker authenticated pulls.        Concurrent workflow  The configuration example below shows a concurrent workflow in which the build and test jobs run at the same time. Both jobs are run in Docker containers using the base image provided by CircleCI.     Refer to the  Workflows document for complete details about orchestrating job runs with concurrent, sequential, and manual approval workflows.   Refer to the  Developer Hub convenience images page to find out about available Docker images for running your jobs.     This image shows the workflow view for the following configuration example:         version: 2.1

# Define the jobs we want to run for this project
jobs:
  build:
    docker:
      - image: cimg/base:2023.03
    steps:
      - checkout
      - run: echo "this is the build job"
  test:
    docker:
      - image: cimg/base:2023.03
    steps:
      - checkout
      - run: echo "this is the test job"

# Orchestrate our job run sequence
workflows:
  build_and_test:
    jobs:
      - build
      - test     Sequential workflow  The configuration example below shows a sequential workflow where the build job runs, and then the test job runs once build has completed. Configure sequential workflows using the  requires key, and specifying the test job "requires" the build job in order to run. Both jobs are run in Docker containers using the base image provided by CircleCI.     Refer to the  Workflows document for complete details about orchestrating job runs with concurrent, sequential, and manual approval workflows.   Refer to the  developer hub convenience images page to find out about available Docker images for running your jobs.     This image shows the workflow view for the following configuration example, in which jobs run sequentially (one after the other):         version: 2.1

# Define the jobs we want to run for this project
jobs:
  build:
    docker:
      - image: cimg/base:2023.03
    steps:
      - checkout
      - run: echo "this is the build job"
  test:
    docker:
      - image: cimg/base:2023.03
    steps:
      - checkout
      - run: echo "this is the test job"

# Orchestrate our job run sequence
workflows:
  build_and_test:
    jobs:
      - build
      - test:
          requires:
            - build     Approval job  The example below shows a sequential workflow with an  approval job. Use an approval job to require manual approval before downstream jobs may proceed.    version: 2.1

executors: # Define an executor
  my-executor:
    docker:
      - image: cimg/base:2024.01
# Define the jobs we want to run for this project
jobs:
  build:
    executor: my-executor
    steps:
      - checkout
      - run: echo "build"
  test:
    executor: my-executor
    steps:
      - checkout
      - run: echo "test"
  deploy:
    executor: my-executor
    steps:
      - checkout
      - run: echo "deploy"

# Orchestrate our job run sequence
workflows:
  build_and_test:
    jobs:
      - build
      - test:
          requires:
            - build
      - hold:
          type: approval
          requires:
            - build
      - deploy:
          requires:
            - hold    The workflow runs as follows:     build job runs   test job runs   hold job, with type: approval ensures the workflow waits for manual approval in the CircleCI web app   Once hold job is approved the deploy job runs     An approval job can have any name. In the example above the approval job is named hold. The name you choose for an approval job should not be used to define a job in the main configuration. An approval job only exists as a workflow orchestration devise.   The image below shows the workflow view for the following configuration example. This image has three parts to show:     The workflow graph with the hold job paused   The "Needs Approval" popup that appears when you click on a hold job   The workflow view again once the hold job has been approved and the deploy job has run            Refer to the  Workflows document for complete details about orchestrating job runs with concurrent, sequential, and manual approval workflows.   Refer to the  developer hub convenience images page to find out about available Docker images for running your jobs.      Hello world   # Use the latest 2.1 version of CircleCI pipeline process engine.
# See: https://circleci.com/docs/configuration-reference
version: 2.1

# Define a job to be invoked later in a workflow.
# See: https://circleci.com/docs/jobs-steps/#jobs-overview & https://circleci.com/docs/configuration-reference/#jobs
jobs:
  say-hello:
    # Specify the execution environment. You can specify an image from Docker Hub or use one of our convenience images from CircleCI's Developer Hub.
    # See: https://circleci.com/docs/executor-intro/ & https://circleci.com/docs/configuration-reference/#executor-job
    docker:
      # Specify the version you desire here
      # See: https://circleci.com/developer/images/image/cimg/base
      - image: cimg/base:current

    # Add steps to the job
    # See: https://circleci.com/docs/jobs-steps/#steps-overview & https://circleci.com/docs/configuration-reference/#steps
    steps:
      # Checkout the code as the first step.
      - checkout
      - run:
          name: "Say hello"
          command: "echo Hello, World!"

# Orchestrate jobs using workflows
# See: https://circleci.com/docs/workflows/ & https://circleci.com/docs/configuration-reference/#workflows
workflows:
  say-hello-workflow: # This is the name of the workflow, feel free to change it to better match your workflow.
    # Inside the workflow, you define the jobs you want to run.
    jobs:
      - say-hello       Sample configuration with sequential workflow and secondary Docker container   Following is a sample .circleci/config.yml file using the following configuration features:     A sequential workflow   An orb   A secondary services container   Workspaces   Storing artifacts      version: 2.1

orbs:
  node: circleci/node@3.0.0

jobs:
  build:
    working_directory: ~/mern-starter
    # Reuse Docker container specification given by the node Orb
    executor: node/default
    steps:
      - checkout
      # Install the latest npm - the node Orb takes care of it
      - node/install-npm
      # Install dependencies - the node Orb take care of installation and dependency caching
      - node/install-packages:
          app-dir: ~/mern-starter
          cache-path: node_modules
          override-ci-command: npm i
      # Save workspace for subsequent jobs (i.e. test)
      - persist_to_workspace:
          root: .
          paths:
            - .

  test:
    docker:
      # The primary container is an instance of the first image listed. The job's commands run in this container.
      - image: cimg/node:current
      # The secondary container is an instance of the second listed image which is run in a common network where ports exposed on the primary container are available on localhost.
      - image: mongo:4.2
    steps:
      # Reuse the workspace from the build job
      - attach_workspace:
          at: .
      - run:
          name: Demonstrate that Mongo DB is available as localhost
          command: |
            curl -sSJL https://www.mongodb.org/static/pgp/server-4.2.asc | sudo apt-key add -
            echo "deb [ arch=amd64,arm64 ] https://repo.mongodb.org/apt/ubuntu bionic/mongodb-org/4.2 multiverse" | sudo tee /etc/apt/sources.list.d/mongodb-org-4.2.list
            sudo apt update
            sudo apt install mongodb-org
            mongo localhost --eval "db.serverStatus()"
      - run:
          name: Test
          command: npm test
      - run:
          name: Generate code coverage
          command: './node_modules/.bin/nyc report --reporter=text-lcov'
      # You can specify either a single file or a directory to store as artifacts
      - store_artifacts:
          path: test-results.xml
          destination: deliverable.xml
      - store_artifacts:
          path: coverage
          destination: coverage

workflows:
  build_and_test:
    jobs:
      - build
      - test:
          requires:
            - build    This example shows a sequential workflow with the test job configured to run only on the main branch. Refer to the  Workflows document for complete details about orchestrating job runs with concurrent, sequential, and manual approval workflows.     Sample configuration with fan-in/fan-out workflow   Below are two sample configurations for a Fan-in/Fan-out workflow.         version: 2.1

orbs:
    docker: circleci/docker@1.0.1

jobs:
    prepare-dependencies:
        docker:
            - image: node:current-alpine
        steps:
            - checkout
            - run:
                  name: Compute version number
                  command: echo "0.0.${CIRCLE_BUILD_NUM}-${CIRCLE_SHA1:0:7}" | tee version.txt
            - restore_cache:
                  keys:
                      - yarn-deps-{{ checksum "yarn.lock" }}
                      - yarn-deps
            - run:
                  name: yarn install
                  command: yarn install
            - save_cache:
                  paths:
                      - node_modules
                  key: yarn-deps-{{ checksum "yarn.lock" }}-{{ epoch }}
            - store_artifacts:
                  path: yarn.lock
            - persist_to_workspace:
                  root: .
                  paths:
                      - .

    build-production:
        docker:
            - image: node:current-alpine
        steps:
            - attach_workspace:
                  at: .
            - run:
                  name: Production build
                  command: |
                      export __BUILD_VERSION="$(cat version.txt)"
                      yarn build
            - store_artifacts:
                  path: dist/server.js
            - persist_to_workspace:
                  root: .
                  paths:
                      - .

    build-docker-image:
        machine:
            # The image uses the current tag, which always points to the most recent
            # supported release. If stability and determinism are crucial for your CI
            # pipeline, use a release date tag with your image, e.g. ubuntu-2004:202201-02
            image: ubuntu-2004:current
        steps:
            - attach_workspace:
                  at: .
            - run:
                  name: Setup __BUILD_VERSION envvar
                  command: |
                      echo 'export __BUILD_VERSION="$(cat version.txt)"' >> "$BASH_ENV"
            - docker/check:
                  registry: $DOCKER_REGISTRY
            - docker/build:
                  image: $DOCKER_IMAGE_NAME
                  tag: $__BUILD_VERSION
                  registry: $DOCKER_REGISTRY
            - docker/push:
                  image: $DOCKER_IMAGE_NAME
                  tag: $__BUILD_VERSION
                  registry: $DOCKER_REGISTRY

    test:
        docker:
            - image: node:current-alpine
        parallelism: 2
        steps:
            - attach_workspace:
                  at: .
            - run:
                  name: Run tests
                  command: |
                      circleci tests glob '**/*.test.ts' | circleci tests split --split-by timings | xargs yarn test:ci
            - store_artifacts:
                  path: test-results
            - store_test_results:
                  path: test-results

    deploy-docker-image:
        machine:
            image: ubuntu-2004:current
        steps:
            - attach_workspace:
                  at: .
            - run:
                  name: Setup __BUILD_VERSION envvar
                  command: |
                      echo 'export __BUILD_VERSION="$(cat version.txt)"' >> "$BASH_ENV"
            - docker/check:
                  registry: $DOCKER_REGISTRY
            - docker/pull:
                  images: $DOCKER_REGISTRY/$DOCKER_IMAGE_NAME:$__BUILD_VERSION
            - run:
                  name: Tag the image as latest
                  command: docker tag $DOCKER_REGISTRY/$DOCKER_IMAGE_NAME:$__BUILD_VERSION $DOCKER_REGISTRY/$DOCKER_IMAGE_NAME:latest
            - docker/push:
                  image: $DOCKER_IMAGE_NAME
                  tag: latest
                  registry: $DOCKER_REGISTRY

workflows:
    build-test-deploy:
        jobs:
            - prepare-dependencies
            - build-production:
                  requires:
                      - prepare-dependencies
            - build-docker-image:
                  context: docker-hub
                  requires:
                      - build-production
            - test:
                  requires:
                      - prepare-dependencies
            - deploy-docker-image:
                  context: docker-hub
                  requires:
                      - build-docker-image
                      - test       A job can only run when its dependencies are satisfied therefore it requires the dependencies of all upstream jobs. This means only the immediate upstream dependencies need to be specified in the requires: blocks.          Sample configuration with multiple executor types   It is possible to use multiple  executor types in the same workflow.   In Example-1 each push will build and test the project on Linux, Windows and macOS.   In Example-2 each push of an iOS project will be built on macOS, and additional iOS tools ( SwiftLint and  Danger) will be run in Docker.  Example 1Example 2    version: 2.1

orbs:
  github-release: haskell-works/github-release@1.3.3

parameters:
  src-repo-url:
    type: string
    default: https://github.com/esnet/iperf.git
  branch-name:
    type: string
    default: "3.8.1"
  common-build-params:
    type: string
    default: "--disable-shared --disable-static"

jobs:
  build-linux:
    docker:
      - image: archlinux/base
    parameters:
      label:
        type: string
        default: iperf3-linux
    steps:
      - run:
          name: Install dependencies
          command: pacman -Syu --noconfirm openssl git gcc make awk tar
      - run:
          name: Clone iperf3
          command: git clone << pipeline.parameters.src-repo-url >> -b << pipeline.parameters.branch-name >>
      - run:
          name: Build iperf3
          working_directory: iperf
          command: |
            CIRCLE_WORKING_DIRECTORY=$(eval "echo $CIRCLE_WORKING_DIRECTORY")
            IPERF3_MAKE_PREFIX=$CIRCLE_WORKING_DIRECTORY/<< parameters.label >>
            ./configure --prefix=$IPERF3_MAKE_PREFIX << pipeline.parameters.common-build-params >>
            make
            mkdir -p $IPERF3_MAKE_PREFIX
            make install
      - run:
          name: Create a tarball
          command: tar -cJf << parameters.label >>.tar.xz << parameters.label >>
      - persist_to_workspace:
          root: .
          paths:
            - << parameters.label >>.tar.xz
      - store_artifacts:
          path: << parameters.label >>.tar.xz

  build-windows:
    machine:
      image: windows-server-2019-vs2019:stable
      shell: powershell.exe
    resource_class: windows.medium
    parameters:
      label:
        type: string
        default: iperf3-cygwin64
    steps:
      - run:
          name: Download Cygwin installer
          shell: bash.exe
          command: |
            curl -sSJOL https://cygwin.com/setup-x86_64.exe
      - run:
          name: Install Cygwin and required packages
          command: . etup-x86_64.exe -q -s https://mirrors.kernel.org/sourceware/cygwin/ -P libssl-devel,git,gcc-core,make
      - run:
          name: Build iperf3 with Cygwin
          shell: C:\\cygwin64\\bin\\bash.exe --login -eo pipefail
          command: |
            CIRCLE_WORKING_DIRECTORY=$(eval "echo $CIRCLE_WORKING_DIRECTORY")
            IPERF3_MAKE_PREFIX=$CIRCLE_WORKING_DIRECTORY/<< parameters.label >>
            cd $CIRCLE_WORKING_DIRECTORY
            git clone << pipeline.parameters.src-repo-url >> -b << pipeline.parameters.branch-name >>
            cd iperf
            ./configure --prefix=$IPERF3_MAKE_PREFIX << pipeline.parameters.common-build-params >>
            make
            mkdir -p $IPERF3_MAKE_PREFIX
            make install
            cp /usr/bin/cygwin1.dll /usr/bin/cygcrypto-1.1.dll /usr/bin/cygz.dll -t $IPERF3_MAKE_PREFIX/bin
      - run:
          name: Create a Zip file
          command: |
            $ProgressPreference = "SilentlyContinue"
            Compress-Archive .\\<< parameters.label >> .\\<< parameters.label >>.zip
      - persist_to_workspace:
          root: .
          paths:
            - << parameters.label >>.zip
      - store_artifacts:
          path: << parameters.label >>.zip

  build-macos:
    macos:
      xcode: 14.2.0
    parameters:
      label:
        type: string
        default: iperf3-macos
    steps:
      - run:
          name: Clone iperf3
          command: git clone << pipeline.parameters.src-repo-url >> -b << pipeline.parameters.branch-name >>
      - run:
          name: Build iperf3
          working_directory: iperf
          command: |
            CIRCLE_WORKING_DIRECTORY=$(eval "echo $CIRCLE_WORKING_DIRECTORY")
            IPERF3_MAKE_PREFIX=$CIRCLE_WORKING_DIRECTORY/<< parameters.label >>
            ./configure --prefix=$IPERF3_MAKE_PREFIX --with-openssl=$(brew --prefix openssl) << pipeline.parameters.common-build-params >>
            make
            mkdir -p $IPERF3_MAKE_PREFIX
            make install
            # Postruns
            cd $IPERF3_MAKE_PREFIX/bin
            # Copy linked OpenSSL libraris to the current directory
            # and tell the linker to refer to them
            otool -L iperf3 | grep openssl | awk '{ print $1 }' | while read dylib
            do
              name=$(basename $dylib)
              cp $dylib ./
              chmod u+w $name
              install_name_tool -change $dylib @executable_path/$name iperf3
            done
            # Modify libssl as well
            otool -L libssl.1.1.dylib | grep openssl | awk '{ print $1 }' | while read dylib
            do
              install_name_tool -change $dylib @executable_path/$(basename $dylib) libssl.1.1.dylib
            done
      - run:
          name: Create a Zip file
          command: zip -r << parameters.label >>.zip << parameters.label >>
      - persist_to_workspace:
          root: .
          paths:
            - << parameters.label >>.zip
      - store_artifacts:
          path: << parameters.label >>.zip

  test-linux:
    docker:
      - image: cimg/base:stable
    parameters:
      label:
        type: string
        default: iperf3-linux
    steps:
      - attach_workspace:
          at: ./
      - run:
          name: Extract << parameters.label >>.tar.xz
          command: tar -xf << parameters.label >>.tar.xz
      - run:
          name: Test executable
          command: << parameters.label >>/bin/iperf3 -v
      - run:
          name: Run as a server
          command: << parameters.label >>/bin/iperf3 -s
          background: true
      - run:
          name: Run as a client
          command: << parameters.label >>/bin/iperf3 -c localhost -R

  test-windows:
    machine:
      image: windows-server-2019-vs2019:stable
      shell: powershell.exe
    resource_class: windows.medium
    parameters:
      label:
        type: string
        default: iperf3-cygwin64
    steps:
      - attach_workspace:
          at: .
      - run:
          name: Extract iperf3-cygwin64.zip
          command: |
            $ProgressPreference = "SilentlyContinue"
            Expand-Archive .\\<< parameters.label >>.zip .
      - run:
          name: Test executable
          command: .\\<< parameters.label >>\bin\iperf3.exe -v
      - run:
          name: Run as a server
          command: .\\<< parameters.label >>\bin\iperf3.exe -s
          background: true
      - run:
          name: Run as a client
          command: .\\<< parameters.label >>\bin\iperf3.exe -c localhost -R

  test-macos:
    macos:
      xcode: 14.2.0
    parameters:
      label:
        type: string
        default: iperf3-macos
    steps:
      - attach_workspace:
          at: .
      - run:
          name: Uninstall pre-installed OpenSSL
          command: brew uninstall --ignore-dependencies openssl
      - run:
          name: Extract << parameters.label >>
          command: unzip << parameters.label >>
      - run:
          name: Test executable
          command: << parameters.label >>/bin/iperf3 -v
      - run:
          name: Run as a server
          command: << parameters.label >>/bin/iperf3 -s
          background: true
      - run:
          name: Run as a client
          command: << parameters.label >>/bin/iperf3 -c localhost -R

  release:
    executor: github-release/default
    steps:
      - attach_workspace:
          at: .
      - run:
          name: Compute version number
          command: |
            echo 'export IPERF3_BUILD_VERSION="<< pipeline.parameters.branch-name>>-${CIRCLE_BUILD_NUM}-${CIRCLE_SHA1:0:7}"' | tee -a "$BASH_ENV"
      - github-release/release:
          tag: v$IPERF3_BUILD_VERSION
          title: $IPERF3_BUILD_VERSION
          artefacts-folder: .

workflows:
  build-test-release:
    jobs:
      - build-linux
      - build-windows
      - build-macos
      - test-linux:
          requires:
            - build-linux
      - test-windows:
          requires:
            - build-windows
      - test-macos:
          requires:
            - build-macos
      - release:
          requires:
            - test-linux
            - test-windows
            - test-macos
          context: github
          filters:
            branches:
              only: main        version: 2.1

jobs:
  build-and-test:
    macos:
      xcode: 14.2.0
    steps:
      - checkout
      - run:
          name: Install CocoaPods
          command: pod install --verbose
      - run:
          name: Build and run tests
          command: fastlane scan
          environment:
            SCAN_DEVICE: iPhone 8
            SCAN_SCHEME: WebTests
      - store_test_results:
          path: test_output/report.xml
      - store_artifacts:
          path: /tmp/test-results
          destination: scan-test-results
      - store_artifacts:
          path: ~/Library/Logs/scan
          destination: scan-logs

  swiftlint:
    docker:
      - image: dantoml/swiftlint:latest
    steps:
      - checkout
      - run: swiftlint lint --reporter junit | tee result.xml
      - store_artifacts:
          path: result.xml
      - store_test_results:
          path: result.xml

  danger:
    docker:
      - image: dantoml/danger:latest
    steps:
      - checkout
      - run: danger

workflows:
  build-test-lint:
    jobs:
      - swiftlint
      - danger
      - build-and-test         See also     See the  Concepts document and  Workflows for more details of the concepts covered in this example.   See the  Configuration Reference document for full details of each individual configuration key.   See the  Example Public Repos document for a list of public projects that use CircleCI.     Suggest an edit to this pageMake a contribution Learn how to contributeStill need help? Ask the CircleCI community Join the research community Visit our Support site\n\nSample config.yml Files2 weeks ago6 min readCloudServer v4+On This PageTools for editing configuration filesSimple configuration examplesConcurrent workflowSequential workflowApproval jobHello worldSample configuration with sequential workflow and secondary Docker containerSample configuration with fan-in/fan-out workflowSample configuration with multiple executor typesSee also   This document provides sample .circleci/config.yml files that you can use as a starting point when setting up projects, or to better understand different ways to orchestrate jobs using workflows and filters. For information on all configuration elements available to you, see the  Configuration reference page.   If you would like to get set up quickly, see our language-specific quickstart guides:      Node    Python    Go       Tools for editing configuration files   CircleCI has created an  extension for Visual Studio Code that reduces context switching between the web app and VS Code through a set of helpful features.   The VS Code extension reduces the time to create, modify, and troubleshoot configuration files through real-time syntax validation, highlighting, and autocomplete suggestions. Authenticating the extension with your CircleCI account will also allow you to visualize and manage your CircleCI pipelines directly from your code editor, and be notified of workflow status changes.   The CircleCI VS Code extension is available to download on the  VS Code marketplace.     Simple configuration examples      Using Docker? Authenticating Docker pulls from image registries is recommended when using the Docker execution environment. Authenticated pulls allow access to private Docker images, and may also grant higher rate limits, depending on your registry provider. For further information see  Using Docker authenticated pulls.        Concurrent workflow  The configuration example below shows a concurrent workflow in which the build and test jobs run at the same time. Both jobs are run in Docker containers using the base image provided by CircleCI.     Refer to the  Workflows document for complete details about orchestrating job runs with concurrent, sequential, and manual approval workflows.   Refer to the  Developer Hub convenience images page to find out about available Docker images for running your jobs.     This image shows the workflow view for the following configuration example:         version: 2.1

# Define the jobs we want to run for this project
jobs:
  build:
    docker:
      - image: cimg/base:2023.03
    steps:
      - checkout
      - run: echo "this is the build job"
  test:
    docker:
      - image: cimg/base:2023.03
    steps:
      - checkout
      - run: echo "this is the test job"

# Orchestrate our job run sequence
workflows:
  build_and_test:
    jobs:
      - build
      - test     Sequential workflow  The configuration example below shows a sequential workflow where the build job runs, and then the test job runs once build has completed. Configure sequential workflows using the  requires key, and specifying the test job "requires" the build job in order to run. Both jobs are run in Docker containers using the base image provided by CircleCI.     Refer to the  Workflows document for complete details about orchestrating job runs with concurrent, sequential, and manual approval workflows.   Refer to the  developer hub convenience images page to find out about available Docker images for running your jobs.     This image shows the workflow view for the following configuration example, in which jobs run sequentially (one after the other):         version: 2.1

# Define the jobs we want to run for this project
jobs:
  build:
    docker:
      - image: cimg/base:2023.03
    steps:
      - checkout
      - run: echo "this is the build job"
  test:
    docker:
      - image: cimg/base:2023.03
    steps:
      - checkout
      - run: echo "this is the test job"

# Orchestrate our job run sequence
workflows:
  build_and_test:
    jobs:
      - build
      - test:
          requires:
            - build     Approval job  The example below shows a sequential workflow with an  approval job. Use an approval job to require manual approval before downstream jobs may proceed.    version: 2.1

executors: # Define an executor
  my-executor:
    docker:
      - image: cimg/base:2024.01
# Define the jobs we want to run for this project
jobs:
  build:
    executor: my-executor
    steps:
      - checkout
      - run: echo "build"
  test:
    executor: my-executor
    steps:
      - checkout
      - run: echo "test"
  deploy:
    executor: my-executor
    steps:
      - checkout
      - run: echo "deploy"

# Orchestrate our job run sequence
workflows:
  build_and_test:
    jobs:
      - build
      - test:
          requires:
            - build
      - hold:
          type: approval
          requires:
            - build
      - deploy:
          requires:
            - hold    The workflow runs as follows:     build job runs   test job runs   hold job, with type: approval ensures the workflow waits for manual approval in the CircleCI web app   Once hold job is approved the deploy job runs     An approval job can have any name. In the example above the approval job is named hold. The name you choose for an approval job should not be used to define a job in the main configuration. An approval job only exists as a workflow orchestration devise.   The image below shows the workflow view for the following configuration example. This image has three parts to show:     The workflow graph with the hold job paused   The "Needs Approval" popup that appears when you click on a hold job   The workflow view again once the hold job has been approved and the deploy job has run            Refer to the  Workflows document for complete details about orchestrating job runs with concurrent, sequential, and manual approval workflows.   Refer to the  developer hub convenience images page to find out about available Docker images for running your jobs.      Hello world   # Use the latest 2.1 version of CircleCI pipeline process engine.
# See: https://circleci.com/docs/configuration-reference
version: 2.1

# Define a job to be invoked later in a workflow.
# See: https://circleci.com/docs/jobs-steps/#jobs-overview & https://circleci.com/docs/configuration-reference/#jobs
jobs:
  say-hello:
    # Specify the execution environment. You can specify an image from Docker Hub or use one of our convenience images from CircleCI's Developer Hub.
    # See: https://circleci.com/docs/executor-intro/ & https://circleci.com/docs/configuration-reference/#executor-job
    docker:
      # Specify the version you desire here
      # See: https://circleci.com/developer/images/image/cimg/base
      - image: cimg/base:current

    # Add steps to the job
    # See: https://circleci.com/docs/jobs-steps/#steps-overview & https://circleci.com/docs/configuration-reference/#steps
    steps:
      # Checkout the code as the first step.
      - checkout
      - run:
          name: "Say hello"
          command: "echo Hello, World!"

# Orchestrate jobs using workflows
# See: https://circleci.com/docs/workflows/ & https://circleci.com/docs/configuration-reference/#workflows
workflows:
  say-hello-workflow: # This is the name of the workflow, feel free to change it to better match your workflow.
    # Inside the workflow, you define the jobs you want to run.
    jobs:
      - say-hello       Sample configuration with sequential workflow and secondary Docker container   Following is a sample .circleci/config.yml file using the following configuration features:     A sequential workflow   An orb   A secondary services container   Workspaces   Storing artifacts      version: 2.1

orbs:
  node: circleci/node@3.0.0

jobs:
  build:
    working_directory: ~/mern-starter
    # Reuse Docker container specification given by the node Orb
    executor: node/default
    steps:
      - checkout
      # Install the latest npm - the node Orb takes care of it
      - node/install-npm
      # Install dependencies - the node Orb take care of installation and dependency caching
      - node/install-packages:
          app-dir: ~/mern-starter
          cache-path: node_modules
          override-ci-command: npm i
      # Save workspace for subsequent jobs (i.e. test)
      - persist_to_workspace:
          root: .
          paths:
            - .

  test:
    docker:
      # The primary container is an instance of the first image listed. The job's commands run in this container.
      - image: cimg/node:current
      # The secondary container is an instance of the second listed image which is run in a common network where ports exposed on the primary container are available on localhost.
      - image: mongo:4.2
    steps:
      # Reuse the workspace from the build job
      - attach_workspace:
          at: .
      - run:
          name: Demonstrate that Mongo DB is available as localhost
          command: |
            curl -sSJL https://www.mongodb.org/static/pgp/server-4.2.asc | sudo apt-key add -
            echo "deb [ arch=amd64,arm64 ] https://repo.mongodb.org/apt/ubuntu bionic/mongodb-org/4.2 multiverse" | sudo tee /etc/apt/sources.list.d/mongodb-org-4.2.list
            sudo apt update
            sudo apt install mongodb-org
            mongo localhost --eval "db.serverStatus()"
      - run:
          name: Test
          command: npm test
      - run:
          name: Generate code coverage
          command: './node_modules/.bin/nyc report --reporter=text-lcov'
      # You can specify either a single file or a directory to store as artifacts
      - store_artifacts:
          path: test-results.xml
          destination: deliverable.xml
      - store_artifacts:
          path: coverage
          destination: coverage

workflows:
  build_and_test:
    jobs:
      - build
      - test:
          requires:
            - build    This example shows a sequential workflow with the test job configured to run only on the main branch. Refer to the  Workflows document for complete details about orchestrating job runs with concurrent, sequential, and manual approval workflows.     Sample configuration with fan-in/fan-out workflow   Below are two sample configurations for a Fan-in/Fan-out workflow.         version: 2.1

orbs:
    docker: circleci/docker@1.0.1

jobs:
    prepare-dependencies:
        docker:
            - image: node:current-alpine
        steps:
            - checkout
            - run:
                  name: Compute version number
                  command: echo "0.0.${CIRCLE_BUILD_NUM}-${CIRCLE_SHA1:0:7}" | tee version.txt
            - restore_cache:
                  keys:
                      - yarn-deps-{{ checksum "yarn.lock" }}
                      - yarn-deps
            - run:
                  name: yarn install
                  command: yarn install
            - save_cache:
                  paths:
                      - node_modules
                  key: yarn-deps-{{ checksum "yarn.lock" }}-{{ epoch }}
            - store_artifacts:
                  path: yarn.lock
            - persist_to_workspace:
                  root: .
                  paths:
                      - .

    build-production:
        docker:
            - image: node:current-alpine
        steps:
            - attach_workspace:
                  at: .
            - run:
                  name: Production build
                  command: |
                      export __BUILD_VERSION="$(cat version.txt)"
                      yarn build
            - store_artifacts:
                  path: dist/server.js
            - persist_to_workspace:
                  root: .
                  paths:
                      - .

    build-docker-image:
        machine:
            # The image uses the current tag, which always points to the most recent
            # supported release. If stability and determinism are crucial for your CI
            # pipeline, use a release date tag with your image, e.g. ubuntu-2004:202201-02
            image: ubuntu-2004:current
        steps:
            - attach_workspace:
                  at: .
            - run:
                  name: Setup __BUILD_VERSION envvar
                  command: |
                      echo 'export __BUILD_VERSION="$(cat version.txt)"' >> "$BASH_ENV"
            - docker/check:
                  registry: $DOCKER_REGISTRY
            - docker/build:
                  image: $DOCKER_IMAGE_NAME
                  tag: $__BUILD_VERSION
                  registry: $DOCKER_REGISTRY
            - docker/push:
                  image: $DOCKER_IMAGE_NAME
                  tag: $__BUILD_VERSION
                  registry: $DOCKER_REGISTRY

    test:
        docker:
            - image: node:current-alpine
        parallelism: 2
        steps:
            - attach_workspace:
                  at: .
            - run:
                  name: Run tests
                  command: |
                      circleci tests glob '**/*.test.ts' | circleci tests split --split-by timings | xargs yarn test:ci
            - store_artifacts:
                  path: test-results
            - store_test_results:
                  path: test-results

    deploy-docker-image:
        machine:
            image: ubuntu-2004:current
        steps:
            - attach_workspace:
                  at: .
            - run:
                  name: Setup __BUILD_VERSION envvar
                  command: |
                      echo 'export __BUILD_VERSION="$(cat version.txt)"' >> "$BASH_ENV"
            - docker/check:
                  registry: $DOCKER_REGISTRY
            - docker/pull:
                  images: $DOCKER_REGISTRY/$DOCKER_IMAGE_NAME:$__BUILD_VERSION
            - run:
                  name: Tag the image as latest
                  command: docker tag $DOCKER_REGISTRY/$DOCKER_IMAGE_NAME:$__BUILD_VERSION $DOCKER_REGISTRY/$DOCKER_IMAGE_NAME:latest
            - docker/push:
                  image: $DOCKER_IMAGE_NAME
                  tag: latest
                  registry: $DOCKER_REGISTRY

workflows:
    build-test-deploy:
        jobs:
            - prepare-dependencies
            - build-production:
                  requires:
                      - prepare-dependencies
            - build-docker-image:
                  context: docker-hub
                  requires:
                      - build-production
            - test:
                  requires:
                      - prepare-dependencies
            - deploy-docker-image:
                  context: docker-hub
                  requires:
                      - build-docker-image
                      - test       A job can only run when its dependencies are satisfied therefore it requires the dependencies of all upstream jobs. This means only the immediate upstream dependencies need to be specified in the requires: blocks.          Sample configuration with multiple executor types   It is possible to use multiple  executor types in the same workflow.   In Example-1 each push will build and test the project on Linux, Windows and macOS.   In Example-2 each push of an iOS project will be built on macOS, and additional iOS tools ( SwiftLint and  Danger) will be run in Docker.  Example 1Example 2    version: 2.1

orbs:
  github-release: haskell-works/github-release@1.3.3

parameters:
  src-repo-url:
    type: string
    default: https://github.com/esnet/iperf.git
  branch-name:
    type: string
    default: "3.8.1"
  common-build-params:
    type: string
    default: "--disable-shared --disable-static"

jobs:
  build-linux:
    docker:
      - image: archlinux/base
    parameters:
      label:
        type: string
        default: iperf3-linux
    steps:
      - run:
          name: Install dependencies
          command: pacman -Syu --noconfirm openssl git gcc make awk tar
      - run:
          name: Clone iperf3
          command: git clone << pipeline.parameters.src-repo-url >> -b << pipeline.parameters.branch-name >>
      - run:
          name: Build iperf3
          working_directory: iperf
          command: |
            CIRCLE_WORKING_DIRECTORY=$(eval "echo $CIRCLE_WORKING_DIRECTORY")
            IPERF3_MAKE_PREFIX=$CIRCLE_WORKING_DIRECTORY/<< parameters.label >>
            ./configure --prefix=$IPERF3_MAKE_PREFIX << pipeline.parameters.common-build-params >>
            make
            mkdir -p $IPERF3_MAKE_PREFIX
            make install
      - run:
          name: Create a tarball
          command: tar -cJf << parameters.label >>.tar.xz << parameters.label >>
      - persist_to_workspace:
          root: .
          paths:
            - << parameters.label >>.tar.xz
      - store_artifacts:
          path: << parameters.label >>.tar.xz

  build-windows:
    machine:
      image: windows-server-2019-vs2019:stable
      shell: powershell.exe
    resource_class: windows.medium
    parameters:
      label:
        type: string
        default: iperf3-cygwin64
    steps:
      - run:
          name: Download Cygwin installer
          shell: bash.exe
          command: |
            curl -sSJOL https://cygwin.com/setup-x86_64.exe
      - run:
          name: Install Cygwin and required packages
          command: . etup-x86_64.exe -q -s https://mirrors.kernel.org/sourceware/cygwin/ -P libssl-devel,git,gcc-core,make
      - run:
          name: Build iperf3 with Cygwin
          shell: C:\\cygwin64\\bin\\bash.exe --login -eo pipefail
          command: |
            CIRCLE_WORKING_DIRECTORY=$(eval "echo $CIRCLE_WORKING_DIRECTORY")
            IPERF3_MAKE_PREFIX=$CIRCLE_WORKING_DIRECTORY/<< parameters.label >>
            cd $CIRCLE_WORKING_DIRECTORY
            git clone << pipeline.parameters.src-repo-url >> -b << pipeline.parameters.branch-name >>
            cd iperf
            ./configure --prefix=$IPERF3_MAKE_PREFIX << pipeline.parameters.common-build-params >>
            make
            mkdir -p $IPERF3_MAKE_PREFIX
            make install
            cp /usr/bin/cygwin1.dll /usr/bin/cygcrypto-1.1.dll /usr/bin/cygz.dll -t $IPERF3_MAKE_PREFIX/bin
      - run:
          name: Create a Zip file
          command: |
            $ProgressPreference = "SilentlyContinue"
            Compress-Archive .\\<< parameters.label >> .\\<< parameters.label >>.zip
      - persist_to_workspace:
          root: .
          paths:
            - << parameters.label >>.zip
      - store_artifacts:
          path: << parameters.label >>.zip

  build-macos:
    macos:
      xcode: 14.2.0
    parameters:
      label:
        type: string
        default: iperf3-macos
    steps:
      - run:
          name: Clone iperf3
          command: git clone << pipeline.parameters.src-repo-url >> -b << pipeline.parameters.branch-name >>
      - run:
          name: Build iperf3
          working_directory: iperf
          command: |
            CIRCLE_WORKING_DIRECTORY=$(eval "echo $CIRCLE_WORKING_DIRECTORY")
            IPERF3_MAKE_PREFIX=$CIRCLE_WORKING_DIRECTORY/<< parameters.label >>
            ./configure --prefix=$IPERF3_MAKE_PREFIX --with-openssl=$(brew --prefix openssl) << pipeline.parameters.common-build-params >>
            make
            mkdir -p $IPERF3_MAKE_PREFIX
            make install
            # Postruns
            cd $IPERF3_MAKE_PREFIX/bin
            # Copy linked OpenSSL libraris to the current directory
            # and tell the linker to refer to them
            otool -L iperf3 | grep openssl | awk '{ print $1 }' | while read dylib
            do
              name=$(basename $dylib)
              cp $dylib ./
              chmod u+w $name
              install_name_tool -change $dylib @executable_path/$name iperf3
            done
            # Modify libssl as well
            otool -L libssl.1.1.dylib | grep openssl | awk '{ print $1 }' | while read dylib
            do
              install_name_tool -change $dylib @executable_path/$(basename $dylib) libssl.1.1.dylib
            done
      - run:
          name: Create a Zip file
          command: zip -r << parameters.label >>.zip << parameters.label >>
      - persist_to_workspace:
          root: .
          paths:
            - << parameters.label >>.zip
      - store_artifacts:
          path: << parameters.label >>.zip

  test-linux:
    docker:
      - image: cimg/base:stable
    parameters:
      label:
        type: string
        default: iperf3-linux
    steps:
      - attach_workspace:
          at: ./
      - run:
          name: Extract << parameters.label >>.tar.xz
          command: tar -xf << parameters.label >>.tar.xz
      - run:
          name: Test executable
          command: << parameters.label >>/bin/iperf3 -v
      - run:
          name: Run as a server
          command: << parameters.label >>/bin/iperf3 -s
          background: true
      - run:
          name: Run as a client
          command: << parameters.label >>/bin/iperf3 -c localhost -R

  test-windows:
    machine:
      image: windows-server-2019-vs2019:stable
      shell: powershell.exe
    resource_class: windows.medium
    parameters:
      label:
        type: string
        default: iperf3-cygwin64
    steps:
      - attach_workspace:
          at: .
      - run:
          name: Extract iperf3-cygwin64.zip
          command: |
            $ProgressPreference = "SilentlyContinue"
            Expand-Archive .\\<< parameters.label >>.zip .
      - run:
          name: Test executable
          command: .\\<< parameters.label >>\bin\iperf3.exe -v
      - run:
          name: Run as a server
          command: .\\<< parameters.label >>\bin\iperf3.exe -s
          background: true
      - run:
          name: Run as a client
          command: .\\<< parameters.label >>\bin\iperf3.exe -c localhost -R

  test-macos:
    macos:
      xcode: 14.2.0
    parameters:
      label:
        type: string
        default: iperf3-macos
    steps:
      - attach_workspace:
          at: .
      - run:
          name: Uninstall pre-installed OpenSSL
          command: brew uninstall --ignore-dependencies openssl
      - run:
          name: Extract << parameters.label >>
          command: unzip << parameters.label >>
      - run:
          name: Test executable
          command: << parameters.label >>/bin/iperf3 -v
      - run:
          name: Run as a server
          command: << parameters.label >>/bin/iperf3 -s
          background: true
      - run:
          name: Run as a client
          command: << parameters.label >>/bin/iperf3 -c localhost -R

  release:
    executor: github-release/default
    steps:
      - attach_workspace:
          at: .
      - run:
          name: Compute version number
          command: |
            echo 'export IPERF3_BUILD_VERSION="<< pipeline.parameters.branch-name>>-${CIRCLE_BUILD_NUM}-${CIRCLE_SHA1:0:7}"' | tee -a "$BASH_ENV"
      - github-release/release:
          tag: v$IPERF3_BUILD_VERSION
          title: $IPERF3_BUILD_VERSION
          artefacts-folder: .

workflows:
  build-test-release:
    jobs:
      - build-linux
      - build-windows
      - build-macos
      - test-linux:
          requires:
            - build-linux
      - test-windows:
          requires:
            - build-windows
      - test-macos:
          requires:
            - build-macos
      - release:
          requires:
            - test-linux
            - test-windows
            - test-macos
          context: github
          filters:
            branches:
              only: main        version: 2.1

jobs:
  build-and-test:
    macos:
      xcode: 14.2.0
    steps:
      - checkout
      - run:
          name: Install CocoaPods
          command: pod install --verbose
      - run:
          name: Build and run tests
          command: fastlane scan
          environment:
            SCAN_DEVICE: iPhone 8
            SCAN_SCHEME: WebTests
      - store_test_results:
          path: test_output/report.xml
      - store_artifacts:
          path: /tmp/test-results
          destination: scan-test-results
      - store_artifacts:
          path: ~/Library/Logs/scan
          destination: scan-logs

  swiftlint:
    docker:
      - image: dantoml/swiftlint:latest
    steps:
      - checkout
      - run: swiftlint lint --reporter junit | tee result.xml
      - store_artifacts:
          path: result.xml
      - store_test_results:
          path: result.xml

  danger:
    docker:
      - image: dantoml/danger:latest
    steps:
      - checkout
      - run: danger

workflows:
  build-test-lint:
    jobs:
      - swiftlint
      - danger
      - build-and-test         See also     See the  Concepts document and  Workflows for more details of the concepts covered in this example.   See the  Configuration Reference document for full details of each individual configuration key.   See the  Example Public Repos document for a list of public projects that use CircleCI.     Suggest an edit to this pageMake a contribution Learn how to contributeStill need help? Ask the CircleCI community Join the research community Visit our Support site DocsTerms of UsePrivacy PolicyCookie PolicySecurity© 2025 Circle Internet Services, Inc., All Rights Reserved.\n\nUsing Docker? Authenticating Docker pulls from image registries is recommended when using the Docker execution environment. Authenticated pulls allow access to private Docker images, and may also grant higher rate limits, depending on your registry provider. For further information see  Using Docker authenticated pulls.    version: 2.1

# Define the jobs we want to run for this project
jobs:
  build:
    docker:
      - image: cimg/base:2023.03
    steps:
      - checkout
      - run: echo "this is the build job"
  test:
    docker:
      - image: cimg/base:2023.03
    steps:
      - checkout
      - run: echo "this is the test job"

# Orchestrate our job run sequence
workflows:
  build_and_test:
    jobs:
      - build
      - test    version: 2.1

# Define the jobs we want to run for this project
jobs:
  build:
    docker:
      - image: cimg/base:2023.03
    steps:
      - checkout
      - run: echo "this is the build job"
  test:
    docker:
      - image: cimg/base:2023.03
    steps:
      - checkout
      - run: echo "this is the test job"

# Orchestrate our job run sequence
workflows:
  build_and_test:
    jobs:
      - build
      - test:
          requires:
            - build  version: 2.1

executors: # Define an executor
  my-executor:
    docker:
      - image: cimg/base:2024.01
# Define the jobs we want to run for this project
jobs:
  build:
    executor: my-executor
    steps:
      - checkout
      - run: echo "build"
  test:
    executor: my-executor
    steps:
      - checkout
      - run: echo "test"
  deploy:
    executor: my-executor
    steps:
      - checkout
      - run: echo "deploy"

# Orchestrate our job run sequence
workflows:
  build_and_test:
    jobs:
      - build
      - test:
          requires:
            - build
      - hold:
          type: approval
          requires:
            - build
      - deploy:
          requires:
            - hold    # Use the latest 2.1 version of CircleCI pipeline process engine.
# See: https://circleci.com/docs/configuration-reference
version: 2.1

# Define a job to be invoked later in a workflow.
# See: https://circleci.com/docs/jobs-steps/#jobs-overview & https://circleci.com/docs/configuration-reference/#jobs
jobs:
  say-hello:
    # Specify the execution environment. You can specify an image from Docker Hub or use one of our convenience images from CircleCI's Developer Hub.
    # See: https://circleci.com/docs/executor-intro/ & https://circleci.com/docs/configuration-reference/#executor-job
    docker:
      # Specify the version you desire here
      # See: https://circleci.com/developer/images/image/cimg/base
      - image: cimg/base:current

    # Add steps to the job
    # See: https://circleci.com/docs/jobs-steps/#steps-overview & https://circleci.com/docs/configuration-reference/#steps
    steps:
      # Checkout the code as the first step.
      - checkout
      - run:
          name: "Say hello"
          command: "echo Hello, World!"

# Orchestrate jobs using workflows
# See: https://circleci.com/docs/workflows/ & https://circleci.com/docs/configuration-reference/#workflows
workflows:
  say-hello-workflow: # This is the name of the workflow, feel free to change it to better match your workflow.
    # Inside the workflow, you define the jobs you want to run.
    jobs:
      - say-hello  version: 2.1

orbs:
  node: circleci/node@3.0.0

jobs:
  build:
    working_directory: ~/mern-starter
    # Reuse Docker container specification given by the node Orb
    executor: node/default
    steps:
      - checkout
      # Install the latest npm - the node Orb takes care of it
      - node/install-npm
      # Install dependencies - the node Orb take care of installation and dependency caching
      - node/install-packages:
          app-dir: ~/mern-starter
          cache-path: node_modules
          override-ci-command: npm i
      # Save workspace for subsequent jobs (i.e. test)
      - persist_to_workspace:
          root: .
          paths:
            - .

  test:
    docker:
      # The primary container is an instance of the first image listed. The job's commands run in this container.
      - image: cimg/node:current
      # The secondary container is an instance of the second listed image which is run in a common network where ports exposed on the primary container are available on localhost.
      - image: mongo:4.2
    steps:
      # Reuse the workspace from the build job
      - attach_workspace:
          at: .
      - run:
          name: Demonstrate that Mongo DB is available as localhost
          command: |
            curl -sSJL https://www.mongodb.org/static/pgp/server-4.2.asc | sudo apt-key add -
            echo "deb [ arch=amd64,arm64 ] https://repo.mongodb.org/apt/ubuntu bionic/mongodb-org/4.2 multiverse" | sudo tee /etc/apt/sources.list.d/mongodb-org-4.2.list
            sudo apt update
            sudo apt install mongodb-org
            mongo localhost --eval "db.serverStatus()"
      - run:
          name: Test
          command: npm test
      - run:
          name: Generate code coverage
          command: './node_modules/.bin/nyc report --reporter=text-lcov'
      # You can specify either a single file or a directory to store as artifacts
      - store_artifacts:
          path: test-results.xml
          destination: deliverable.xml
      - store_artifacts:
          path: coverage
          destination: coverage

workflows:
  build_and_test:
    jobs:
      - build
      - test:
          requires:
            - build    version: 2.1

orbs:
    docker: circleci/docker@1.0.1

jobs:
    prepare-dependencies:
        docker:
            - image: node:current-alpine
        steps:
            - checkout
            - run:
                  name: Compute version number
                  command: echo "0.0.${CIRCLE_BUILD_NUM}-${CIRCLE_SHA1:0:7}" | tee version.txt
            - restore_cache:
                  keys:
                      - yarn-deps-{{ checksum "yarn.lock" }}
                      - yarn-deps
            - run:
                  name: yarn install
                  command: yarn install
            - save_cache:
                  paths:
                      - node_modules
                  key: yarn-deps-{{ checksum "yarn.lock" }}-{{ epoch }}
            - store_artifacts:
                  path: yarn.lock
            - persist_to_workspace:
                  root: .
                  paths:
                      - .

    build-production:
        docker:
            - image: node:current-alpine
        steps:
            - attach_workspace:
                  at: .
            - run:
                  name: Production build
                  command: |
                      export __BUILD_VERSION="$(cat version.txt)"
                      yarn build
            - store_artifacts:
                  path: dist/server.js
            - persist_to_workspace:
                  root: .
                  paths:
                      - .

    build-docker-image:
        machine:
            # The image uses the current tag, which always points to the most recent
            # supported release. If stability and determinism are crucial for your CI
            # pipeline, use a release date tag with your image, e.g. ubuntu-2004:202201-02
            image: ubuntu-2004:current
        steps:
            - attach_workspace:
                  at: .
            - run:
                  name: Setup __BUILD_VERSION envvar
                  command: |
                      echo 'export __BUILD_VERSION="$(cat version.txt)"' >> "$BASH_ENV"
            - docker/check:
                  registry: $DOCKER_REGISTRY
            - docker/build:
                  image: $DOCKER_IMAGE_NAME
                  tag: $__BUILD_VERSION
                  registry: $DOCKER_REGISTRY
            - docker/push:
                  image: $DOCKER_IMAGE_NAME
                  tag: $__BUILD_VERSION
                  registry: $DOCKER_REGISTRY

    test:
        docker:
            - image: node:current-alpine
        parallelism: 2
        steps:
            - attach_workspace:
                  at: .
            - run:
                  name: Run tests
                  command: |
                      circleci tests glob '**/*.test.ts' | circleci tests split --split-by timings | xargs yarn test:ci
            - store_artifacts:
                  path: test-results
            - store_test_results:
                  path: test-results

    deploy-docker-image:
        machine:
            image: ubuntu-2004:current
        steps:
            - attach_workspace:
                  at: .
            - run:
                  name: Setup __BUILD_VERSION envvar
                  command: |
                      echo 'export __BUILD_VERSION="$(cat version.txt)"' >> "$BASH_ENV"
            - docker/check:
                  registry: $DOCKER_REGISTRY
            - docker/pull:
                  images: $DOCKER_REGISTRY/$DOCKER_IMAGE_NAME:$__BUILD_VERSION
            - run:
                  name: Tag the image as latest
                  command: docker tag $DOCKER_REGISTRY/$DOCKER_IMAGE_NAME:$__BUILD_VERSION $DOCKER_REGISTRY/$DOCKER_IMAGE_NAME:latest
            - docker/push:
                  image: $DOCKER_IMAGE_NAME
                  tag: latest
                  registry: $DOCKER_REGISTRY

workflows:
    build-test-deploy:
        jobs:
            - prepare-dependencies
            - build-production:
                  requires:
                      - prepare-dependencies
            - build-docker-image:
                  context: docker-hub
                  requires:
                      - build-production
            - test:
                  requires:
                      - prepare-dependencies
            - deploy-docker-image:
                  context: docker-hub
                  requires:
                      - build-docker-image
                      - test  A job can only run when its dependencies are satisfied therefore it requires the dependencies of all upstream jobs. This means only the immediate upstream dependencies need to be specified in the requires: blocks.    version: 2.1

orbs:
  github-release: haskell-works/github-release@1.3.3

parameters:
  src-repo-url:
    type: string
    default: https://github.com/esnet/iperf.git
  branch-name:
    type: string
    default: "3.8.1"
  common-build-params:
    type: string
    default: "--disable-shared --disable-static"

jobs:
  build-linux:
    docker:
      - image: archlinux/base
    parameters:
      label:
        type: string
        default: iperf3-linux
    steps:
      - run:
          name: Install dependencies
          command: pacman -Syu --noconfirm openssl git gcc make awk tar
      - run:
          name: Clone iperf3
          command: git clone << pipeline.parameters.src-repo-url >> -b << pipeline.parameters.branch-name >>
      - run:
          name: Build iperf3
          working_directory: iperf
          command: |
            CIRCLE_WORKING_DIRECTORY=$(eval "echo $CIRCLE_WORKING_DIRECTORY")
            IPERF3_MAKE_PREFIX=$CIRCLE_WORKING_DIRECTORY/<< parameters.label >>
            ./configure --prefix=$IPERF3_MAKE_PREFIX << pipeline.parameters.common-build-params >>
            make
            mkdir -p $IPERF3_MAKE_PREFIX
            make install
      - run:
          name: Create a tarball
          command: tar -cJf << parameters.label >>.tar.xz << parameters.label >>
      - persist_to_workspace:
          root: .
          paths:
            - << parameters.label >>.tar.xz
      - store_artifacts:
          path: << parameters.label >>.tar.xz

  build-windows:
    machine:
      image: windows-server-2019-vs2019:stable
      shell: powershell.exe
    resource_class: windows.medium
    parameters:
      label:
        type: string
        default: iperf3-cygwin64
    steps:
      - run:
          name: Download Cygwin installer
          shell: bash.exe
          command: |
            curl -sSJOL https://cygwin.com/setup-x86_64.exe
      - run:
          name: Install Cygwin and required packages
          command: . etup-x86_64.exe -q -s https://mirrors.kernel.org/sourceware/cygwin/ -P libssl-devel,git,gcc-core,make
      - run:
          name: Build iperf3 with Cygwin
          shell: C:\\cygwin64\\bin\\bash.exe --login -eo pipefail
          command: |
            CIRCLE_WORKING_DIRECTORY=$(eval "echo $CIRCLE_WORKING_DIRECTORY")
            IPERF3_MAKE_PREFIX=$CIRCLE_WORKING_DIRECTORY/<< parameters.label >>
            cd $CIRCLE_WORKING_DIRECTORY
            git clone << pipeline.parameters.src-repo-url >> -b << pipeline.parameters.branch-name >>
            cd iperf
            ./configure --prefix=$IPERF3_MAKE_PREFIX << pipeline.parameters.common-build-params >>
            make
            mkdir -p $IPERF3_MAKE_PREFIX
            make install
            cp /usr/bin/cygwin1.dll /usr/bin/cygcrypto-1.1.dll /usr/bin/cygz.dll -t $IPERF3_MAKE_PREFIX/bin
      - run:
          name: Create a Zip file
          command: |
            $ProgressPreference = "SilentlyContinue"
            Compress-Archive .\\<< parameters.label >> .\\<< parameters.label >>.zip
      - persist_to_workspace:
          root: .
          paths:
            - << parameters.label >>.zip
      - store_artifacts:
          path: << parameters.label >>.zip

  build-macos:
    macos:
      xcode: 14.2.0
    parameters:
      label:
        type: string
        default: iperf3-macos
    steps:
      - run:
          name: Clone iperf3
          command: git clone << pipeline.parameters.src-repo-url >> -b << pipeline.parameters.branch-name >>
      - run:
          name: Build iperf3
          working_directory: iperf
          command: |
            CIRCLE_WORKING_DIRECTORY=$(eval "echo $CIRCLE_WORKING_DIRECTORY")
            IPERF3_MAKE_PREFIX=$CIRCLE_WORKING_DIRECTORY/<< parameters.label >>
            ./configure --prefix=$IPERF3_MAKE_PREFIX --with-openssl=$(brew --prefix openssl) << pipeline.parameters.common-build-params >>
            make
            mkdir -p $IPERF3_MAKE_PREFIX
            make install
            # Postruns
            cd $IPERF3_MAKE_PREFIX/bin
            # Copy linked OpenSSL libraris to the current directory
            # and tell the linker to refer to them
            otool -L iperf3 | grep openssl | awk '{ print $1 }' | while read dylib
            do
              name=$(basename $dylib)
              cp $dylib ./
              chmod u+w $name
              install_name_tool -change $dylib @executable_path/$name iperf3
            done
            # Modify libssl as well
            otool -L libssl.1.1.dylib | grep openssl | awk '{ print $1 }' | while read dylib
            do
              install_name_tool -change $dylib @executable_path/$(basename $dylib) libssl.1.1.dylib
            done
      - run:
          name: Create a Zip file
          command: zip -r << parameters.label >>.zip << parameters.label >>
      - persist_to_workspace:
          root: .
          paths:
            - << parameters.label >>.zip
      - store_artifacts:
          path: << parameters.label >>.zip

  test-linux:
    docker:
      - image: cimg/base:stable
    parameters:
      label:
        type: string
        default: iperf3-linux
    steps:
      - attach_workspace:
          at: ./
      - run:
          name: Extract << parameters.label >>.tar.xz
          command: tar -xf << parameters.label >>.tar.xz
      - run:
          name: Test executable
          command: << parameters.label >>/bin/iperf3 -v
      - run:
          name: Run as a server
          command: << parameters.label >>/bin/iperf3 -s
          background: true
      - run:
          name: Run as a client
          command: << parameters.label >>/bin/iperf3 -c localhost -R

  test-windows:
    machine:
      image: windows-server-2019-vs2019:stable
      shell: powershell.exe
    resource_class: windows.medium
    parameters:
      label:
        type: string
        default: iperf3-cygwin64
    steps:
      - attach_workspace:
          at: .
      - run:
          name: Extract iperf3-cygwin64.zip
          command: |
            $ProgressPreference = "SilentlyContinue"
            Expand-Archive .\\<< parameters.label >>.zip .
      - run:
          name: Test executable
          command: .\\<< parameters.label >>\bin\iperf3.exe -v
      - run:
          name: Run as a server
          command: .\\<< parameters.label >>\bin\iperf3.exe -s
          background: true
      - run:
          name: Run as a client
          command: .\\<< parameters.label >>\bin\iperf3.exe -c localhost -R

  test-macos:
    macos:
      xcode: 14.2.0
    parameters:
      label:
        type: string
        default: iperf3-macos
    steps:
      - attach_workspace:
          at: .
      - run:
          name: Uninstall pre-installed OpenSSL
          command: brew uninstall --ignore-dependencies openssl
      - run:
          name: Extract << parameters.label >>
          command: unzip << parameters.label >>
      - run:
          name: Test executable
          command: << parameters.label >>/bin/iperf3 -v
      - run:
          name: Run as a server
          command: << parameters.label >>/bin/iperf3 -s
          background: true
      - run:
          name: Run as a client
          command: << parameters.label >>/bin/iperf3 -c localhost -R

  release:
    executor: github-release/default
    steps:
      - attach_workspace:
          at: .
      - run:
          name: Compute version number
          command: |
            echo 'export IPERF3_BUILD_VERSION="<< pipeline.parameters.branch-name>>-${CIRCLE_BUILD_NUM}-${CIRCLE_SHA1:0:7}"' | tee -a "$BASH_ENV"
      - github-release/release:
          tag: v$IPERF3_BUILD_VERSION
          title: $IPERF3_BUILD_VERSION
          artefacts-folder: .

workflows:
  build-test-release:
    jobs:
      - build-linux
      - build-windows
      - build-macos
      - test-linux:
          requires:
            - build-linux
      - test-windows:
          requires:
            - build-windows
      - test-macos:
          requires:
            - build-macos
      - release:
          requires:
            - test-linux
            - test-windows
            - test-macos
          context: github
          filters:
            branches:
              only: main    version: 2.1

orbs:
  github-release: haskell-works/github-release@1.3.3

parameters:
  src-repo-url:
    type: string
    default: https://github.com/esnet/iperf.git
  branch-name:
    type: string
    default: "3.8.1"
  common-build-params:
    type: string
    default: "--disable-shared --disable-static"

jobs:
  build-linux:
    docker:
      - image: archlinux/base
    parameters:
      label:
        type: string
        default: iperf3-linux
    steps:
      - run:
          name: Install dependencies
          command: pacman -Syu --noconfirm openssl git gcc make awk tar
      - run:
          name: Clone iperf3
          command: git clone << pipeline.parameters.src-repo-url >> -b << pipeline.parameters.branch-name >>
      - run:
          name: Build iperf3
          working_directory: iperf
          command: |
            CIRCLE_WORKING_DIRECTORY=$(eval "echo $CIRCLE_WORKING_DIRECTORY")
            IPERF3_MAKE_PREFIX=$CIRCLE_WORKING_DIRECTORY/<< parameters.label >>
            ./configure --prefix=$IPERF3_MAKE_PREFIX << pipeline.parameters.common-build-params >>
            make
            mkdir -p $IPERF3_MAKE_PREFIX
            make install
      - run:
          name: Create a tarball
          command: tar -cJf << parameters.label >>.tar.xz << parameters.label >>
      - persist_to_workspace:
          root: .
          paths:
            - << parameters.label >>.tar.xz
      - store_artifacts:
          path: << parameters.label >>.tar.xz

  build-windows:
    machine:
      image: windows-server-2019-vs2019:stable
      shell: powershell.exe
    resource_class: windows.medium
    parameters:
      label:
        type: string
        default: iperf3-cygwin64
    steps:
      - run:
          name: Download Cygwin installer
          shell: bash.exe
          command: |
            curl -sSJOL https://cygwin.com/setup-x86_64.exe
      - run:
          name: Install Cygwin and required packages
          command: . etup-x86_64.exe -q -s https://mirrors.kernel.org/sourceware/cygwin/ -P libssl-devel,git,gcc-core,make
      - run:
          name: Build iperf3 with Cygwin
          shell: C:\\cygwin64\\bin\\bash.exe --login -eo pipefail
          command: |
            CIRCLE_WORKING_DIRECTORY=$(eval "echo $CIRCLE_WORKING_DIRECTORY")
            IPERF3_MAKE_PREFIX=$CIRCLE_WORKING_DIRECTORY/<< parameters.label >>
            cd $CIRCLE_WORKING_DIRECTORY
            git clone << pipeline.parameters.src-repo-url >> -b << pipeline.parameters.branch-name >>
            cd iperf
            ./configure --prefix=$IPERF3_MAKE_PREFIX << pipeline.parameters.common-build-params >>
            make
            mkdir -p $IPERF3_MAKE_PREFIX
            make install
            cp /usr/bin/cygwin1.dll /usr/bin/cygcrypto-1.1.dll /usr/bin/cygz.dll -t $IPERF3_MAKE_PREFIX/bin
      - run:
          name: Create a Zip file
          command: |
            $ProgressPreference = "SilentlyContinue"
            Compress-Archive .\\<< parameters.label >> .\\<< parameters.label >>.zip
      - persist_to_workspace:
          root: .
          paths:
            - << parameters.label >>.zip
      - store_artifacts:
          path: << parameters.label >>.zip

  build-macos:
    macos:
      xcode: 14.2.0
    parameters:
      label:
        type: string
        default: iperf3-macos
    steps:
      - run:
          name: Clone iperf3
          command: git clone << pipeline.parameters.src-repo-url >> -b << pipeline.parameters.branch-name >>
      - run:
          name: Build iperf3
          working_directory: iperf
          command: |
            CIRCLE_WORKING_DIRECTORY=$(eval "echo $CIRCLE_WORKING_DIRECTORY")
            IPERF3_MAKE_PREFIX=$CIRCLE_WORKING_DIRECTORY/<< parameters.label >>
            ./configure --prefix=$IPERF3_MAKE_PREFIX --with-openssl=$(brew --prefix openssl) << pipeline.parameters.common-build-params >>
            make
            mkdir -p $IPERF3_MAKE_PREFIX
            make install
            # Postruns
            cd $IPERF3_MAKE_PREFIX/bin
            # Copy linked OpenSSL libraris to the current directory
            # and tell the linker to refer to them
            otool -L iperf3 | grep openssl | awk '{ print $1 }' | while read dylib
            do
              name=$(basename $dylib)
              cp $dylib ./
              chmod u+w $name
              install_name_tool -change $dylib @executable_path/$name iperf3
            done
            # Modify libssl as well
            otool -L libssl.1.1.dylib | grep openssl | awk '{ print $1 }' | while read dylib
            do
              install_name_tool -change $dylib @executable_path/$(basename $dylib) libssl.1.1.dylib
            done
      - run:
          name: Create a Zip file
          command: zip -r << parameters.label >>.zip << parameters.label >>
      - persist_to_workspace:
          root: .
          paths:
            - << parameters.label >>.zip
      - store_artifacts:
          path: << parameters.label >>.zip

  test-linux:
    docker:
      - image: cimg/base:stable
    parameters:
      label:
        type: string
        default: iperf3-linux
    steps:
      - attach_workspace:
          at: ./
      - run:
          name: Extract << parameters.label >>.tar.xz
          command: tar -xf << parameters.label >>.tar.xz
      - run:
          name: Test executable
          command: << parameters.label >>/bin/iperf3 -v
      - run:
          name: Run as a server
          command: << parameters.label >>/bin/iperf3 -s
          background: true
      - run:
          name: Run as a client
          command: << parameters.label >>/bin/iperf3 -c localhost -R

  test-windows:
    machine:
      image: windows-server-2019-vs2019:stable
      shell: powershell.exe
    resource_class: windows.medium
    parameters:
      label:
        type: string
        default: iperf3-cygwin64
    steps:
      - attach_workspace:
          at: .
      - run:
          name: Extract iperf3-cygwin64.zip
          command: |
            $ProgressPreference = "SilentlyContinue"
            Expand-Archive .\\<< parameters.label >>.zip .
      - run:
          name: Test executable
          command: .\\<< parameters.label >>\bin\iperf3.exe -v
      - run:
          name: Run as a server
          command: .\\<< parameters.label >>\bin\iperf3.exe -s
          background: true
      - run:
          name: Run as a client
          command: .\\<< parameters.label >>\bin\iperf3.exe -c localhost -R

  test-macos:
    macos:
      xcode: 14.2.0
    parameters:
      label:
        type: string
        default: iperf3-macos
    steps:
      - attach_workspace:
          at: .
      - run:
          name: Uninstall pre-installed OpenSSL
          command: brew uninstall --ignore-dependencies openssl
      - run:
          name: Extract << parameters.label >>
          command: unzip << parameters.label >>
      - run:
          name: Test executable
          command: << parameters.label >>/bin/iperf3 -v
      - run:
          name: Run as a server
          command: << parameters.label >>/bin/iperf3 -s
          background: true
      - run:
          name: Run as a client
          command: << parameters.label >>/bin/iperf3 -c localhost -R

  release:
    executor: github-release/default
    steps:
      - attach_workspace:
          at: .
      - run:
          name: Compute version number
          command: |
            echo 'export IPERF3_BUILD_VERSION="<< pipeline.parameters.branch-name>>-${CIRCLE_BUILD_NUM}-${CIRCLE_SHA1:0:7}"' | tee -a "$BASH_ENV"
      - github-release/release:
          tag: v$IPERF3_BUILD_VERSION
          title: $IPERF3_BUILD_VERSION
          artefacts-folder: .

workflows:
  build-test-release:
    jobs:
      - build-linux
      - build-windows
      - build-macos
      - test-linux:
          requires:
            - build-linux
      - test-windows:
          requires:
            - build-windows
      - test-macos:
          requires:
            - build-macos
      - release:
          requires:
            - test-linux
            - test-windows
            - test-macos
          context: github
          filters:
            branches:
              only: main    version: 2.1

jobs:
  build-and-test:
    macos:
      xcode: 14.2.0
    steps:
      - checkout
      - run:
          name: Install CocoaPods
          command: pod install --verbose
      - run:
          name: Build and run tests
          command: fastlane scan
          environment:
            SCAN_DEVICE: iPhone 8
            SCAN_SCHEME: WebTests
      - store_test_results:
          path: test_output/report.xml
      - store_artifacts:
          path: /tmp/test-results
          destination: scan-test-results
      - store_artifacts:
          path: ~/Library/Logs/scan
          destination: scan-logs

  swiftlint:
    docker:
      - image: dantoml/swiftlint:latest
    steps:
      - checkout
      - run: swiftlint lint --reporter junit | tee result.xml
      - store_artifacts:
          path: result.xml
      - store_test_results:
          path: result.xml

  danger:
    docker:
      - image: dantoml/danger:latest
    steps:
      - checkout
      - run: danger

workflows:
  build-test-lint:
    jobs:
      - swiftlint
      - danger
      - build-and-test    version: 2.1

jobs:
  build-and-test:
    macos:
      xcode: 14.2.0
    steps:
      - checkout
      - run:
          name: Install CocoaPods
          command: pod install --verbose
      - run:
          name: Build and run tests
          command: fastlane scan
          environment:
            SCAN_DEVICE: iPhone 8
            SCAN_SCHEME: WebTests
      - store_test_results:
          path: test_output/report.xml
      - store_artifacts:
          path: /tmp/test-results
          destination: scan-test-results
      - store_artifacts:
          path: ~/Library/Logs/scan
          destination: scan-logs

  swiftlint:
    docker:
      - image: dantoml/swiftlint:latest
    steps:
      - checkout
      - run: swiftlint lint --reporter junit | tee result.xml
      - store_artifacts:
          path: result.xml
      - store_test_results:
          path: result.xml

  danger:
    docker:
      - image: dantoml/danger:latest
    steps:
      - checkout
      - run: danger

workflows:
  build-test-lint:
    jobs:
      - swiftlint
      - danger
      - build-and-test\n\n\n\nConfiguration reference1 week agoCloudServer v4+Helpful Resources6 config optimization tipsIntro to dynamic configUsing dynamic configValidate your config using local CLIHow to trigger a single jobOn This Pageversionsetuporbscommandsparametersexecutorsjobs<job_name>typeenvironmentparallelismparametersExecutor docker / machine / macosdockerDocker registry authenticationAWS authenticationUse OIDCUse environment variablesmachineAvailable Linux machine imagesAvailable Linux machine images on serverAvailable Linux GPU machine imagesAvailable Android machine imagesAvailable Windows machine imagesAvailable Windows machine images on serverAvailable Windows GPU machine imagemacosbranches - DEPRECATEDresource_classSelf-hosted runnerDocker execution environmentx86ArmLinuxVM execution environmentmacOS execution environmentmacOS execution environment on serverWindows execution environmentGPU execution environment (Linux)GPU execution-environment (Windows)Arm VM execution-environmentstepsrunDefault shell options-e-o pipefailBackground commandsShorthand syntaxThe when attributeEnding a job from within a stepThe when stepcheckoutsetup_remote_dockersave_cacherestore_cachedeploy - DEPRECATEDstore_artifactsstore_test_resultspersist_to_workspaceattach_workspaceadd_ssh_keysUsing pipeline valuescircleci_ip_rangesworkflowsversion<workflow_name>triggersschedulecronfiltersbranchesUsing when in workflowsjobs<job_name>serial-grouprequiresnamecontexttypefiltersExpression-based job filtersbranchestagsmatrixExcluding sets of parameters from a matrixDependencies and matrix jobspre-steps and post-stepsLogic statementsLogic statement examplesExample full configuration   This document is a reference for the CircleCI 2.x configuration keys that are used in the .circleci/config.yml file.   You can see a complete config.yml in our  full example.      version  KeyRequiredTypeDescriptionversionYString2, 2.0, or 2.1 See the  Reusable configuration page for an overview of 2.1 keys available to simplify your .circleci/config.yml file, reuse, and parameterized jobs.  The version field is intended to be used in order to issue warnings for deprecation or breaking changes.      setup  KeyRequiredTypeDescriptionsetupNBooleanDesignates the config.yaml for use of CircleCI’s  dynamic configuration feature.  The setup field enables you to conditionally trigger configurations from outside the primary .circleci parent directory, update pipeline parameters, or generate customized configurations.      orbs      The orbs key is supported in version: 2.1 configuration       KeyRequiredTypeDescriptionorbsNMapA map of user-selected names to either: orb references (strings) or orb definitions (maps). Orb definitions must be the orb-relevant subset of 2.1 config. See the  Creating Orbs documentation for details.executorsNMapA map of strings to executor definitions. See the  executors section below.commandsNMapA map of command names to command definitions. See the  commands section below.  The following example uses the node orb that exists in the certified circleci namespace. Refer to the Node orb page in the  Orb Registry for more examples and information.    version: 2.1

orbs:
  node: circleci/node@x.y

jobs:
  install-node-example:
    docker:
      - image: cimg/base:stable
    steps:
      - checkout
      - node/install:
          install-yarn: true
          node-version: '16.13'
      - run: node --version
workflows:
  test_my_app:
    jobs:
      - install-node-example    Documentation is available for orbs in the following sections:      Using Orbs    Authoring Orbs.     Public orbs are listed in the  Orb Registry.      commands      The commands key is supported in version: 2.1 configuration        A command defines a sequence of steps as a map to be executed in a job, enabling you to reuse a single command definition across multiple jobs. For more information see the  Reusable Config Reference Guide.  KeyRequiredTypeDescriptionstepsYSequenceA sequence of steps run inside the calling job of the command.parametersNMapA map of parameter keys. See the  Parameter Syntax section of the  Reusing Config document for details.descriptionNStringA string that describes the purpose of the command.  Example:    commands:
  sayhello:
    description: "A very simple command for demonstration purposes"
    parameters:
      to:
        type: string
        default: "Hello World"
    steps:
      - run: echo << parameters.to >>       parameters      The pipeline parameters key is supported in version: 2.1 configuration        Pipeline parameters declared for use in the configuration. See  Pipeline Values and Parameters for usage details.  KeyRequiredTypeDescriptionparametersNMapA map of parameter keys. Supports string, boolean, integer and enum types. See  Parameter Syntax for details.     executors      The executors key is supported in version: 2.1 configuration        Executors define the execution environment in which the steps of a job will be run, allowing you to reuse a single executor definition across multiple jobs.  KeyRequiredTypeDescriptiondockerY (1)ListOptions for  Docker executorresource_classNStringAmount of CPU and RAM allocated to each container in a job.machineY (1)MapOptions for  machine executormacosY (1)MapOptions for  macOS executorwindowsY (1)Map Windows executor currently working with orbs. Check out  the orb.shellNStringShell to use for execution command in all steps. Can be overridden by shell in each step (default: See  Default Shell Options)working_directoryNStringIn which directory to run the steps. Will be interpreted as an absolute path.environmentNMapA map of environment variable names and values.  (1) One executor type should be specified per job. If more than one is set you will receive an error.   Example:    version: 2.1
executors:
  my-executor:
    docker:
      - image: cimg/ruby:3.0.3-browsers

jobs:
  my-job:
    executor: my-executor
    steps:
      - run: echo "Hello executor!"    See the  Using Parameters in Executors section of the  Reusing config page for examples of parameterized executors.      jobs   A Workflow is comprised of one or more uniquely named jobs. Jobs are specified in the jobs map, see  Sample config.yml for two examples of a job map. The name of the job is the key in the map, and the value is a map describing the job.   Jobs have a maximum runtime based on pricing plan, as follows:     1 hour (Free)   3 hours (Performance)   5 hours (Scale)     If your jobs are timing out, consider the following:     A larger  resource_class.   Using  parallelism.   Run some of your jobs concurrently using  workflows.   You can upgrade your pricing plan.      <job_name>  Each job consists of the job’s name as a key and a map as a value. A name should be case insensitive unique within a current jobs list. The value map has the following attributes:  KeyRequiredTypeDescriptiontypeNStringJob type, can be build, release, no-op, or approval. If not specified, defaults to build.dockerY (1)ListOptions for the  Docker executormachineY (1)MapOptions for the  machine executormacosY (1)MapOptions for the  macOS executorshellNStringShell to use for execution command in all steps. Can be overridden by shell in each step (default: See  Default Shell Options)parametersNMap Parameters for making a job explicitly configurable in a workflow.stepsYListA list of  steps to be performedworking_directoryNStringIn which directory to run the steps. Will be interpreted as an absolute path. Default: ~/project (where project is a literal string, not the name of your specific project). Processes run during the job can use the $CIRCLE_WORKING_DIRECTORY environment variable to refer to this directory. Note: Paths written in your YAML configuration file will not be expanded; if your store_test_results.path is $CIRCLE_WORKING_DIRECTORY/tests, then CircleCI will attempt to store the test subdirectory of the directory literally named $CIRCLE_WORKING_DIRECTORY, dollar sign $ and all. working_directory will be created automatically if it doesn’t exist.parallelismNIntegerNumber of parallel instances of this job to run (default: 1)environmentNMapA map of environment variable names and values.branchesNMapThis key is deprecated. Use  workflows filtering to control which jobs run for which branches.resource_classNStringAmount of CPU and RAM allocated to each container in a job.  (1) One executor type should be specified per job. If more than one is set you will receive an error.    type  Configure a job type. Options are release, approval, no-op, build (default).   If a type is not specified, the job defaults to a build type.   Example of a job with a build type. build is the default type and does not need to be configured:    jobs:
  my-job:
    docker:
      - image: cimg/base:2024.12
    resource_class: xlarge
    steps:
      ... // other config    Jobs with the release type are used to  connect your pipeline configuration to a deployment in the CircleCI deploys UI. For full details, see the  Deploys overview page.   Example of a job with a release type:    jobs:
  release-my-service:
    type: release
    plan_name: <my-service-release>    The no-op type is used to configure a job that performs no actions and consumes no credits. no-op is commonly used to organise the order of operations within a workflow and make it easier to maintain. Only the type is required for a no-op type job, no further job configuration is required. For some examples of using no-op jobs, see the  Orchestration cookbook   Example of a job with a no-op type:    jobs:
  my-no-op-job:
    type: no-op    The approval type is used to configure a manual approval step. No job configuration is required or allowed for an approval type job. The approval type is most commonly configured within a workflow rather than under the top-level jobs key. Only approval type jobs can have their type configured under workflows. See  type under workflows section for full details.   Example of a job with an approval type, configured under workflows:    workflows:
  my-workflow:
    jobs:
      - build
      - test:
          requires:
            - build
      - hold:
          type: approval
          requires:
            - test
      - deploy:
          requires:
            - hold      environment  A map of environment variable names and values. For more information on defining and using environment variables, and the order of precedence governing the various ways they can be set, see the  Environment variables page.     parallelism  This feature is used to optimize test steps. If parallelism is set to N > 1, then N independent executors will be set up and each will run the steps of that job in parallel.   You can use the CircleCI CLI to split your test suite across parallel containers so the job completes in a shorter time.     Read more about splitting tests across parallel execution environments on the  Parallelism and test splitting page.   Refer to the  Use the CircleCI CLI to split tests how-to guide.   Follow the  Test splitting tutorial.     Example:    jobs:
  build:
    docker:
      - image: cimg/base:2024.12
    environment:
      FOO: bar
    parallelism: 3
    resource_class: large
    working_directory: ~/my-app
    steps:
      - run: go list ./... | circleci tests run --command "xargs gotestsum --junitfile junit.xml --format testname --" --split-by=timings --timings-type=name      parameters  Job-level parameters can be used when  calling a job in a workflow.   Reserved parameter-names:     name   requires   context   type   filters   matrix     See  Parameter Syntax for definition details.     Executor docker / machine / macos  CircleCI offers several execution environments in which to run your jobs. To specify an execution environment choose an executor, then specify and image and a resource class. An executor defines the underlying technology, environment, and operating system in which to run a job.   Set up your jobs to run using the docker (Linux), machine (LinuxVM, Windows, GPU, Arm), or macos executor, then specify an image with the tools and packages you need, and a resource class.   Learn more about execution environments and executors in the  Introduction to Execution Environments.     docker  Configured by docker key which takes a list of maps:  KeyRequiredTypeDescriptionimageYStringThe name of a custom Docker image to use. The first image listed under a job defines the job’s own primary container image where all steps will run.nameNStringname defines the hostname for the container (the default is localhost), which is used for reaching secondary (service) containers. By default, all services are exposed directly on localhost. This field is useful if you would rather have a different hostname instead of localhost, for example, if you are starting multiple versions of the same service.entrypointNString or ListThe command used as executable when launching the container. entrypoint overrides the image’s  ENTRYPOINT.commandNString or ListThe command used as PID 1 (or arguments for entrypoint) when launching the container. command overrides the image’s COMMAND. It will be used as arguments to the image ENTRYPOINT if it has one, or as the executable if the image has no ENTRYPOINT.userNStringWhich user to run commands as within the Docker containerenvironmentNMapA map of environment variable names and values. The environment settings apply to the entrypoint/command run by the Docker container, not the job steps.authNMapAuthentication for registries using standard docker login credentialsaws_authNMapAuthentication for AWS Elastic Container Registry (ECR)  For a  primary container, (the first container in the list) if neither command nor entrypoint is specified in the configuration, then any ENTRYPOINT and COMMAND in the image are ignored. The primary container is typically only used for running the steps and not for its ENTRYPOINT, and an ENTRYPOINT may consume significant resources or exit prematurely.   A  custom image may disable this behavior and force the ENTRYPOINT to run.   You can specify image versions using tags or digest. You can use any public images from any public Docker registry (defaults to Docker Hub). Learn more about specifying images on the  Using the Docker Execution Environment page.    Docker registry authentication  Some registries, Docker Hub, for example, may rate limit anonymous Docker pulls. We recommend that you authenticate to pull private and public images. The username and password can be specified in the auth field. See  Using Docker Authenticated Pulls for details.   Example:    jobs:
  build:
    docker:
      - image: buildpack-deps:trusty # primary container
        auth:
          username: mydockerhub-user
          password: $DOCKERHUB_PASSWORD  # context / project UI env-var reference
        environment:
          ENV: CI

      - image: mongo:2.6.8
        auth:
          username: mydockerhub-user
          password: $DOCKERHUB_PASSWORD  # context / project UI env-var reference
        command: [--smallfiles]

      - image: postgres:14.2
        auth:
          username: mydockerhub-user
          password: $DOCKERHUB_PASSWORD  # context / project UI env-var reference
        environment:
          POSTGRES_USER: user

      - image: redis@sha256:54057dd7e125ca41afe526a877e8bd35ec2cdd33b9217e022ed37bdcf7d09673
        auth:
          username: mydockerhub-user
          password: $DOCKERHUB_PASSWORD  # context / project UI env-var reference

      - image: acme-private/private-image:321
        auth:
          username: mydockerhub-user
          password: $DOCKERHUB_PASSWORD  # context / project UI env-var reference      AWS authentication  Using an image hosted on  AWS ECR requires authentication using AWS credentials.   Use OIDC  Authenticate using OpenID Connect (OIDC) using the oidc_role_arn field, as follows:    jobs:
  job_name:
    docker:
      - image: <your-image-arn>
        aws_auth:
          oidc_role_arn: <your-iam-role-arn>    For steps to get set up with OIDC to pull images from AWS ECR, see the  Pull and image from AWS ECR with OIDC page.    Use environment variables  By default, CircleCI uses the AWS credentials you provide by setting the AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY project environment variables. It is also possible to set the credentials by using the aws_auth field as in the following example:    jobs:
  build:
    docker:
      - image: account-id.dkr.ecr.us-east-1.amazonaws.com/org/repo:0.1
        aws_auth:
          aws_access_key_id: AKIAQWERVA  # can specify string literal values
          aws_secret_access_key: $ECR_AWS_SECRET_ACCESS_KEY  # or project UI envar reference        machine     CircleCI cloud The use of machine: true is deprecated. You must specify an image to use.        The machine executor is configured using the machine key, which takes a map:  KeyRequiredTypeDescriptionimageYStringThe virtual machine image to use. View  available images. Note: This key is not supported for Linux VMs on installations of CircleCI server. For information about customizing machine executor images on CircleCI installed on your servers, see our  Machine provisioner documentation.docker_layer_cachingNBooleanSet this to true to enable  Docker layer caching.  Example:  CloudServer    jobs:
  build: # name of your job
    machine: # executor type
      image: ubuntu-2004:current # recommended linux image

    steps:
      # Commands run in a Linux virtual machine environment        jobs:
  build: # name of your job
    machine: true # executor type
    steps:
      # Commands run in a Linux virtual machine environment        Available Linux machine images  Specifying an image in your configuration file is strongly recommended. CircleCI supports multiple Linux machine images that can be specified in the image field. For a full list of supported image tags, refer to the following pages in the Developer Hub:      Ubuntu-2004    Ubuntu-2204     More information on the software available in each image can be found in our  Discuss forum.   The machine executor supports  Docker Layer Caching, which is useful when you are building Docker images during your job or Workflow.     Available Linux machine images on server  If you are using CircleCI server, contact your system administrator for details of available Linux machine images.     Available Linux GPU machine images  When using the Linux  GPU executor, the available images are:     linux-cuda-11:default v11.4, v11.6, v11.8 (default), Docker v20.10.24   linux-cuda-12:default v12.0, v12.1 (default), Docker v20.10.24       Available Android machine images  CircleCI supports running jobs on Android for testing and deploying Android applications.   To use the  Android image directly with the machine executor, add the following to your job:    version: 2.1

jobs:
  build:
    machine:
      image: android:2024.11.1    The Android image can also be accessed using the  Android orb.   For examples, refer to the  Using Android Images with the Machine Executor page.     Available Windows machine images  Specifying an image in your configuration file is strongly recommended. CircleCI supports multiple Windows machine images that can be specified in the image field.   For a full list of supported images, refer to one of the following:      windows-server-2022-gui image    windows-server-2019 image     More information on what software is available in each image can be found in our  Discuss forum.   Alternatively, use the  Windows orb to manage your Windows execution environment. For examples, see the  Using the Windows Execution Environment page.     Available Windows machine images on server  If you are using CircleCI server, contact your system administrator for details of available Windows machine images.     Available Windows GPU machine image  When using the Windows  GPU executor, the available image is:      windows-server-2019-cuda     Example    version: 2.1

jobs:
  build:
    machine:
      image: windows-server-2019-cuda:current       macos  CircleCI supports running jobs on  macOS, to allow you to build, test, and deploy apps for macOS,  iOS,  tvOS and  watchOS. To run a job on a macOS virtual machine, add the macos key to the top-level configuration for your job and specify the version of Xcode to use.  KeyRequiredTypeDescriptionxcodeYStringThe version of Xcode that is installed on the virtual machine, see the  Supported Xcode Versions section of the Testing iOS document for the complete list.  Example: Use a macOS virtual machine with Xcode version 14.2.0:    jobs:
  build:
    macos:
      xcode: "14.2.0"      branches - DEPRECATED  This key is deprecated. Use  workflows filtering to control which jobs run for which branches.     resource_class  The resource_class feature allows you to configure CPU and RAM resources for each job. Resource classes are available for each execution environment, as described in the tables below.   We implement soft concurrency limits for each resource class to ensure our system remains stable for all customers. If you are on a Performance or Custom Plan and experience queuing for certain resource classes, it is possible you are hitting these limits.  Contact CircleCI support to request a raise on these limits for your account.   If you do not specify a resource class, CircleCI will use a default value that is subject to change. It is best practice to specify a resource class as opposed to relying on a default.      Java, Erlang and any other languages that introspect the /proc directory for information about CPU count may require additional configuration to prevent them from slowing down when using the CircleCI resource class feature. Programs with this issue may request 32 CPU cores and run slower than they would when requesting one core. Users of languages with this issue should pin their CPU count to their guaranteed CPU resources.           If you want to confirm how much memory you have been allocated, you can check the cgroup memory hierarchy limit with grep hierarchical_memory_limit /sys/fs/cgroup/memory/memory.stat.         Self-hosted runner  Use the resource_class key to configure a  self-hosted runner instance.   For example:    jobs:
  job_name:
    machine: true
    resource_class: <my-namespace>/<my-runner>      Docker execution environment  Example:    jobs:
  build:
    docker:
      - image: cimg/base:2024.12
    resource_class: xlarge
    steps:
      ... // other config    x86     For credit and access information, see the  Resource classes page. Resource class access is dependent on your  Plan.       ClassvCPUsRAMCloudServersmall12GBmedium24GBmedium+36GBlarge48GBxlarge816GB2xlarge1632GB2xlarge+2040GB   Arm  Arm on Docker For pricing information, and a list of CircleCI Docker convenience images that support Arm resource classes, see the  Resource classes page.       Arm on Docker For credit and access information see the  Resource classes page. Resource class access is dependent on your  Plan   To find out which CircleCI Docker convenience images support Arm resource classes, you can refer to  Docker hub:     Select the image (for example, cimg/python).   Select the tags tab.   View what is supported under OS/ARCH for the latest tags. For example, cimg/python has linux/amd64 and linux/arm64, which means Arm is supported.          ClassvCPUsRAMCloudServerarm.medium28 GBarm.large416 GBarm.xlarge832 GBarm.2xlarge1664 GB     LinuxVM execution environment ClassvCPUsRAMDisk SizeCloudServermedium27.5 GB150GBlarge415 GB150GBxlarge832 GB150GB2xlarge1664 GB150GB2xlarge+3264 GB150GB  Example:  CloudServer    jobs:
  build:
    machine:
      image: ubuntu-2004:2024.01.2 # recommended linux image
    resource_class: large
    steps:
      ... // other config        jobs:
  build:
    machine: true
    resource_class: large
    steps:
      ... // other config         macOS execution environment ClassvCPUsRAMCloudServermacos.m1.medium.gen14 @ 3.2 GHz6GBmacos.m1.large.gen18 @ 3.2 GHz12GBm2pro.medium4 @ 3.49 GHz8GBm2pro.large8 @ 3.49 GHz16GB      We have deprecated support for all Intel-based macOS resources.   The macos.x86.medium.gen2 resource class was deprecated on June 28, 2024.   See our  announcement for more details.         Example    jobs:
  build:
    macos:
      xcode: "15.4.0"
    resource_class: m2pro.medium
    steps:
      ... // other config      macOS execution environment on server  If you are working on CircleCI server v3.1 and up, you can access the macOS execution environment using  self-hosted runner.     Windows execution environment ClassvCPUsRAMDisk SizeCloudServerwindows.medium (default)415GB200 GBwindows.large830GB200 GBwindows.xlarge1660GB200 GBwindows.2xlarge32128GB200 GB     Using server? Check with your systems administrator whether you have access to the Windows execution environment.        Example:  CloudServer    version: 2.1

jobs:
  build: # name of your job
    resource_class: 'windows.medium'
    machine:
      image: 'windows-server-2022-gui:current'
      shell: 'powershell.exe -ExecutionPolicy Bypass'
    steps:
      # Commands are run in a Windows virtual machine environment
      - checkout
      - run: Write-Host 'Hello, Windows'        version: 2.1

jobs:
  build: # name of your job
    machine:
      image: windows-default
    steps:
      # Commands are run in a Windows virtual machine environment
      - checkout
      - run: Write-Host 'Hello, Windows'         GPU execution environment (Linux) ClassvCPUsRAMGPUsGPU modelGPU Memory (GiB)Disk Size (GiB)CloudServergpu.nvidia.small4161NVIDIA Tesla P416150gpu.nvidia.small.gen24161NVIDIA A10G24150gpu.nvidia.small.multi4152NVIDIA Tesla T416150gpu.nvidia.medium.multi8304NVIDIA Tesla T416150gpu.nvidia.medium8301NVIDIA Tesla T416150gpu.nvidia.large8301NVIDIA Tesla V10016150  Example:    version: 2.1

jobs:
  build:
    machine:
      image: linux-cuda-12:default
    resource_class: gpu.nvidia.medium
    steps:
      - run: nvidia-smi
      - run: docker run --gpus all nvidia/cuda:9.0-base nvidia-smi    See the  Available Linux GPU images section for the full list of available images.     GPU execution-environment (Windows) ClassvCPUsRAMGPUsGPU modelGPU Memory (GiB)Disk Size (GiB)CloudServerwindows.gpu.nvidia.medium16601NVIDIA Tesla T416200  Example:    version: 2.1
orbs:
  win: circleci/windows@5.0.0

jobs:
  build:
    executor: win/server-2019-cuda
    steps:
      - checkout
      - run: '&"C:\Program Files\NVIDIA Corporation\NVSMI\nvidia-smi.exe"'    (2) This resource requires review by our support team.  Open a support ticket if you would like to request access.     Arm VM execution-environment ClassvCPUsRAMDisk SizeCloudServerarm.medium (default)28GB100 GBarm.large416GB100 GBarm.xlarge832GB100 GBarm.2xlarge1664GB100 GB     Using server? Check with your systems administrator whether you have access to the Arm execution environment.        Example:  CloudServer    jobs:
  my-job:
    machine:
      image: ubuntu-2004:2024.01.2
    resource_class: arm.medium
    steps:
      - run: uname -a
      - run: echo "Hello, Arm!"        jobs:
  my-job:
    machine:
      image: arm-default
    resource_class: arm.medium
    steps:
      - run: uname -a
      - run: echo "Hello, Arm!"          steps  The steps setting in a job should be a list of single key/value pairs, the key of which indicates the step type. The value may be either a configuration map or a string (depending on what that type of step requires). For example, using a map:    jobs:
  build:
    working_directory: ~/canary-python
    environment:
      FOO: bar
    steps:
      - run:
          name: Running tests
          command: make test    Here run is a step type. The name attribute is used by the UI for display purposes. The command attribute is specific for run step and defines command to execute.   Some steps may implement a shorthand semantic. For example, run may be also be called like this:    jobs:
  build:
    steps:
      - run: make test    In its short form, the run step allows us to directly specify which command to execute as a string value. In this case step itself provides default suitable values for other attributes (name here will have the same value as command, for example).   Another shorthand, which is possible for some steps, is to use the step name as a string instead of a key/value pair:    jobs:
  build:
    steps:
      - checkout    In this case, the checkout step will check out project source code into the job’s  working_directory.   In general all steps can be described as:  KeyRequiredTypeDescription<step_type>YMap or StringA configuration map for the step or some string whose semantics are defined by the step.  Each built-in step is described in detail below.    run  The run step is used to invoke command-line programs. The run step takes either a map of configuration values, or, when called in its short-form, a string that will be used as both the command and name. Run commands are executed using non-login shells by default, so you must explicitly source any dotfiles as part of the command.      the run step replaces the deprecated deploy step. If your job has a parallelism of 1, the deprecated deploy step can be swapped out directly for the run step. If your job has parallelism > 1, see  Migrate from deploy to run.       KeyRequiredTypeDescriptioncommandYStringCommand to run via the shellnameNStringTitle of the step to be shown in the CircleCI UI (default: full command)shellNStringShell to use for execution command (default: See  Default Shell Options)environmentNMapAdditional environmental variables, locally scoped to commandbackgroundNBooleanWhether or not this step should run in the background (default: false)working_directoryNStringIn which directory to run this step. Will be interpreted relative to the  working_directory of the job). (default: .)no_output_timeoutNStringElapsed time the command can run without output. The string is a decimal with unit suffix, such as "20m", "1.25h", "5s". The default is 10 minutes and the maximum is governed by the  maximum time a job is allowed to run.whenNString Specify when to enable or disable the step. Takes the following values: always, on_success, on_fail (default: on_success)  Each run declaration represents a new shell. It is possible to specify a multi-line command, each line of which will be run in the same shell:    - run:
    command: |
      echo Running test
      mkdir -p /tmp/test-results
      make test    You can also configure commands to run  in the background if you do not want to wait for the step to complete before moving on to subsequent run steps.    Default shell options  For jobs that run on Linux, the default value of the shell option is /bin/bash -eo pipefail if /bin/bash is present in the build container. Otherwise it is /bin/sh -eo pipefail. The default shell is not a login shell (--login or -l are not specified). Hence, the shell will not source your ~/.bash_profile, ~/.bash_login, ~/.profile files.   For jobs that run on macOS, the default shell is /bin/bash --login -eo pipefail. The shell is a non-interactive login shell. The shell will execute /etc/profile/ followed by ~/.bash_profile before every step.   For more information about which files are executed when Bash is invocated,  see the INVOCATION section of the bash manpage.   Descriptions of the -eo pipefail options are provided below.    -e  Exit immediately if any of the following exits with a non-zero status:     A pipeline (which may consist of a single simple command).   A subshell command enclosed in parentheses.   One of the commands executed as part of a command list enclosed by braces.     In the previous example, mkdir failed to create a directory and returned a non-zero status, then command execution would be terminated, and the whole step would be marked as failed. If you desire the opposite behaviour, you need to add set +e in your command or override the default shell in your configuration map of run. For example:    - run:
    command: |
      echo Running test
      set +e
      mkdir -p /tmp/test-results
      make test

- run:
    shell: /bin/sh
    command: |
      echo Running test
      mkdir -p /tmp/test-results
      make test     -o pipefail  If pipefail is enabled, the pipeline’s return status is the value of the last (rightmost) command to exit with a non-zero status, or zero if all commands exit successfully. The shell waits for all commands in the pipeline to terminate before returning a value.   For example:    - run: make test | tee test-output.log    If make test fails, the -o pipefail option will cause the whole step to fail. Without -o pipefail, the step will always run successfully because the result of the whole pipeline is determined by the last command (tee test-output.log), which will always return a zero status.      If make test fails the rest of pipeline will be executed.        If you want to avoid this behaviour, you can specify set +o pipefail in the command or override the whole shell (see example above).   In general, we recommend using the default options (-eo pipefail) because they show errors in intermediate commands and simplify debugging job failures. For convenience, the UI displays the used shell and all active options for each run step.   For more information, see the  Using Shell Scripts document.     Background commands  The background attribute enables you to configure commands to run in the background. Job execution will immediately proceed to the next step rather than waiting for return of a command with the background attribute set to true. The following example shows the configuration for running the X virtual framebuffer in the background which is commonly required to run Selenium tests:    - run:
    name: Running X virtual framebuffer
    command: Xvfb :99 -screen 0 1280x1024x24
    background: true

- run: make test      Shorthand syntax  run has a very convenient shorthand syntax:    - run: make test

# shorthanded command can also have multiple lines
- run: |
    mkdir -p /tmp/test-results
    make test    In this case, command and name become the string value of run, and the rest of the config map for that run have their default values.     The when attribute  By default, CircleCI will execute job steps one at a time, in the order that they are defined in config.yml, until a step fails (returns a non-zero exit code). After a command fails, no further job steps will be executed.   Adding the when attribute to a job step allows you to override this default behaviour, and selectively run or skip steps depending on the status of the job.   The when attribute accepts the following values:    on_success  The step will run only if all of the previous steps have been successful (returned exit code 0). on_success is the default value.  always  The step will run regardless of the exit status of previous steps. always is useful if you have a task that you want to run regardless of whether the previous steps are successful or not. For example, you might have a job step that needs to upload logs or code-coverage data somewhere.  on_fail  The step will run only if one of the preceding steps has failed (returns a non-zero exit code). A common use of on_fail is to store some diagnostic data to help debug test failures, or to run custom notifications about the failure, such as sending emails or triggering alerts.        Some steps, such as store_artifacts and store_test_results will always run, even if a step has failed (returned a non-zero exit code) previously. The when attribute, store_artifacts and store_test_results are not run if the job has been killed by a cancel request or has reached the runtime timeout limit.         - run:
    name: Upload CodeCov.io Data
    command: bash <(curl -s https://codecov.io/bash) -F unittests
    when: always # Uploads code coverage results, pass or fail      Ending a job from within a step  A job can exit without failing by using run: circleci-agent step halt. However, if a step within the job is already failing then the job will continue to fail. This can be useful in situations where jobs need to conditionally execute.   Here is an example where halt is used to avoid running a job on the develop branch:    - run: |
    if [ "$CIRCLE_BRANCH" = "develop" ]; then
        circleci-agent step halt
    fi       The when step     The when and unless steps are supported in version: 2.1 configuration        A conditional step consists of a step with the key when or unless. Under the when key are the subkeys condition and steps. The purpose of the when step is customizing commands and job configuration to run on custom conditions (determined at config-compile time) that are checked before a workflow runs. See the  Conditional Steps section of the reusable configuration reference for more details.  KeyRequiredTypeDescriptionconditionYLogic A logic statementstepsYSequenceA list of steps to execute when the condition is true  Example:    version: 2.1

jobs: # conditional steps may also be defined in `commands:`
  job_with_optional_custom_checkout:
    parameters:
      custom_checkout:
        type: string
        default: ""
    machine:
      image: ubuntu-2004:2024.11.1
    steps:
      - when:
          condition: <<parameters.custom_checkout>>
          steps:
            - run: echo "my custom checkout"
      - unless:
          condition: <<parameters.custom_checkout>>
          steps:
            - checkout
workflows:
  build-test-deploy:
    jobs:
      - job_with_optional_custom_checkout:
          custom_checkout: "any non-empty string is truthy"
      - job_with_optional_custom_checkout      checkout      Blobless clones   A "blobless" strategy is being rolled out to help improve the performance of code checkouts from Git source code hosts.   Blobless clones reduce the amount of data fetched from the remote, by asking the remote to filter out objects that are not attached to the current commit.   While this improves performance in most cases, if a downstream step requires those objects to exist for scanning or comparisons, it can cause failures. To work around these potential problems, a fetch directly after a checkout will ensure the required data is available:    - checkout
- run: git fetch          A special step used to check out source code to the configured path (defaults to the working_directory). The reason this is a special step is because it is more of a helper function designed to simplify the process of checking out code. If you require doing git over HTTPS you should not use this step as it configures git to checkout over SSH.  KeyRequiredTypeDescriptionpathNStringCheckout directory. Will be interpreted relative to the  working_directory of the job). (default: .)  If path already exists and is:     A git repository - step will not clone whole repository, instead will fetch origin   NOT a git repository - step will fail.     In the case of checkout, the step type is just a string with no additional attributes:    - checkout    The checkout command automatically adds the required authenticity keys for interacting with GitHub and Bitbucket over SSH. These keys are detailed further in the  integration guide. This guide is also helpful if you wish to implement a custom checkout command.   CircleCI does not check out submodules. If your project requires submodules, add run steps with appropriate commands as shown in the following example:    - checkout
- run: git submodule sync
- run: git submodule update --init       The checkout step will configure Git to skip automatic garbage collection. If you are caching your .git directory with  restore_cache and would like to use garbage collection to reduce its size, you may wish to use a  run step with command git gc before doing so.          setup_remote_docker  Allows Docker commands to be run locally. See  Running Docker commands for details.    jobs:
  build:
    docker:
      - image: cimg/base:2024.06
    steps:
      # ... steps for building/testing app ...
      - setup_remote_docker:
          version: default   KeyRequiredTypeDescriptiondocker_layer_cachingNbooleanSet this to true to enable  Docker Layer Caching in the Remote Docker Environment (default: false)versionNStringVersion string of Docker you would like to use (default: 24.0.9). View the list of supported Docker versions  here.        setup_remote_docker is not compatible with the machine executor. See  Docker Layer Caching in Machine Executor for information on how to enable DLC with the machine executor.   The version key is not currently supported on CircleCI server. Contact your system administrator for information about the Docker version installed in your remote Docker environment. If you are on server 4.x, you can find the default AWS AMI  here.             save_cache  Generates and stores a cache of a file or directory of files such as dependencies or source code in our object storage. Later jobs can  restore this cache. Learn more on the  Caching Dependencies page.   Cache retention can be customized on the  CircleCI web app by navigating to Plan  Usage Controls.  KeyRequiredTypeDescriptionpathsYListList of directories which should be added to the cachekeyYStringUnique identifier for this cachenameNStringTitle of the step to be shown in the CircleCI UI (default: "Saving Cache")whenNString Specify when to enable or disable the step. Takes the following values: always, on_success, on_fail (default: on_success)  The cache for a specific key is immutable and cannot be changed once written.      If the cache for the given key already exists it will not be modified, and job execution will proceed to the next step.        When storing a new cache, the key value may contain special, templated, values for your convenience:  TemplateDescription{{ .Branch }}The VCS branch currently being built.{{ .BuildNum }}The CircleCI build number for this build.{{ .Revision }}The VCS revision currently being built.{{ .CheckoutKey }}The SSH key used to checkout the repository.{{ .Environment.variableName }}The environment variable variableName (supports any environment variable  exported by CircleCI or added to a specific  context--not any arbitrary environment variable).{{ checksum "filename" }}A base64 encoded SHA256 hash of the given filename’s contents. This should be a file committed in your repository and may also be referenced as a path that is absolute or relative from the current working directory. Good candidates are dependency manifests, such as package-lock.json, pom.xml or project.clj. It is important that this file does not change between restore_cache and save_cache, otherwise the cache will be saved under a cache key different than the one used at restore_cache time.{{ epoch }}The current time in seconds since the UNIX epoch.{{ arch }}The OS and CPU information. Useful when caching compiled binaries that depend on OS and CPU architecture, for example, darwin amd64 versus linux i386/32-bit.  During step execution, the templates above will be replaced by runtime values and use the resultant string as the key.   Template examples:     myapp-{{ checksum "package-lock.json" }} - cache will be regenerated every time something is changed in package-lock.json file, different branches of this project will generate the same cache key.   myapp-{{ .Branch }}-{{ checksum "package-lock.json" }} - same as the previous one, but each branch will generate separate cache   myapp-{{ epoch }} - every run of a job will generate a separate cache     While choosing suitable templates for your cache key, keep in mind that:     Cache saving is not a free operation. See the billing section on the  FAQ page.   It takes time to upload the cache.     Best practice is to have a key that generates a new cache only if something actually changed and avoid generating a new one every time a job is run.      Given the immutability of caches, it might be helpful to start all your cache keys with a version prefix v1-.... That way you will be able to regenerate all your caches just by incrementing the version in this prefix.        Example:    - save_cache:
    key: v1-myapp-{{ arch }}-{{ checksum "project.clj" }}
    paths:
      - /home/ubuntu/.m2     - save_cache:
    key: v1-{{ checksum "yarn.lock" }}
    paths:
      - node_modules/workspace-a
      - node_modules/workspace-c          Wildcards are not currently supported in save_cache paths. Visit the  Ideas board and vote for this feature if it would be useful for you or your organization.   In some instances, a workaround for this is to save a particular workspace to cache:             restore_cache  Restores a previously saved cache based on a key. Cache needs to have been saved first for this key using the  save_cache step. Learn more in  the caching documentation.  KeyRequiredTypeDescriptionkeyY (1)StringSingle cache key to restorekeysY (1)ListList of cache keys to lookup for a cache to restore. Only first existing key will be restored.nameNStringTitle of the step to be shown in the CircleCI UI (default: "Restoring Cache")  (1) at least one attribute has to be present. If key and keys are both given, key will be checked first, and then keys.   A key is searched against existing keys as a prefix.      When there are multiple matches, the most recent match will be used, even if there is a more precise match.        For example:    steps:
  - save_cache:
      key: v1-myapp-cache
      paths:
        - ~/d1

  - save_cache:
      key: v1-myapp-cache-new
      paths:
        - ~/d2

  - run: rm -f ~/d1 ~/d2

  - restore_cache:
      key: v1-myapp-cache    In this case cache v1-myapp-cache-new will be restored because it’s the most recent match with v1-myapp-cache prefix even if the first key (v1-myapp-cache) has exact match.   For more information on key formatting, see the key section of  save_cache step.   When CircleCI encounters a list of keys, the cache will be restored from the first key matching an existing cache. We recommend you use a more specific key first (for example, cache for exact version of package-lock.json) and more generic keys after (for example, any cache for this project). If no key has a cache that exists, the step will be skipped with a warning.   A path is not required here because the cache will be restored to the location from which it was originally saved.   Example:    - restore_cache:
    keys:
      - v1-myapp-{{ arch }}-{{ checksum "project.clj" }}
      # if cache for exact version of `project.clj` is not present then load any most recent one
      - v1-myapp-

# ... Steps building and testing your application ...

# cache will be saved only once for each version of `project.clj`
- save_cache:
    key: v1-myapp-{{ arch }}-{{ checksum "project.clj" }}
    paths:
      - /foo      deploy - DEPRECATED  See  run for current processes. If you have parallelism > 1 in your job, see the  Migrate from deploy to run guide.     store_artifacts  Step to store artifacts (for example logs, binaries, etc) to be available in the web app or through the API. See the  Uploading Artifacts page for more information.  KeyRequiredTypeDescriptionpathYStringDirectory in the primary container to save as job artifactsdestinationNStringPrefix added to the artifact paths in the artifacts API (default: the directory of the file specified in path)  There can be multiple store_artifacts steps in a job. Using a unique prefix for each step prevents them from overwriting files.   Artifact storage retention can be customized on the  CircleCI web app by navigating to Plan  Usage Controls.   Example:    - run:
    name: Build the Jekyll site
    command: bundle exec jekyll build --source jekyll --destination jekyll/_site/docs/
- store_artifacts:
    path: jekyll/_site/docs/
    destination: circleci-docs      store_test_results  Special step used to upload and store test results for a build. Test results are visible on the CircleCI web application under each build’s Test Summary section. Storing test results is useful for timing analysis of your test suites. For more information on storing test results, see the  Collecting Test Data page.   You can also store test results as build artifacts. For steps, refer to  the store_artifacts step section.  KeyRequiredTypeDescriptionpathYStringPath (absolute, or relative to your working_directory) to directory containing JUnit XML test metadata files, or to a single test file.  Example:   Directory structure:    test-results
├── jest
│   └── results.xml
├── mocha
│   └── results.xml
└── rspec
    └── results.xml    config.yml syntax:    - store_test_results:
    path: test-results      persist_to_workspace  Special step used to persist a temporary file to be used by another job in the workflow. For more information on using workspaces, see the  Using Workspaces to Share Data Between Jobs page.   persist_to_workspace adopts the storage settings from the storage customization controls on the CircleCI web app. If no custom setting is provided, persist_to_workspace defaults to 15 days.   Workspace storage retention can be customized on the  CircleCI web app by navigating to Plan  Usage Controls.  KeyRequiredTypeDescriptionrootYStringEither an absolute path or a path relative to working_directorypathsYListGlob identifying file(s), or a non-glob path to a directory to add to the shared workspace. Interpreted as relative to the workspace root. Must not be the workspace root itself.  The root key is a directory on the container which is taken to be the root directory of the workspace. The path values are all relative to the root.   Example for root Key   For example, the following step syntax persists the specified paths from /tmp/dir into the workspace, relative to the directory /tmp/dir.    - persist_to_workspace:
    root: /tmp/dir
    paths:
      - foo/bar
      - baz    After this step completes, the following directories are added to the workspace:    /tmp/dir/foo/bar
/tmp/dir/baz    Example for paths Key    - persist_to_workspace:
    root: /tmp/workspace
    paths:
      - target/application.jar
      - build/*    The paths list uses Glob from Go, and the pattern matches  filepath.Match.    pattern:
        { term }
term:
        '*' matches any sequence of non-Separator characters
        '?' matches any single non-Separator character
        '[' [ '^' ] { character-range }
        ']' character class (must be non-empty)
        c matches character c (c != '*', '?', '\\', '[')
        '\\' c matches character c
character-range:
        c matches character c (c != '\\', '-', ']')
        '\\' c matches character c
        lo '-' hi matches character c for lo <= c <= hi    The Go documentation states that the pattern may describe hierarchical names such as /usr/*/bin/ed (assuming the Separator is '/').      Everything must be relative to the work space root directory.          attach_workspace  Special step used to attach the workflow’s workspace to the current container. The full contents of the workspace are downloaded and copied into the directory the workspace is being attached at. For more information on using workspaces, see the  Using workspaces page.  KeyRequiredTypeDescriptionatYStringDirectory to attach the workspace to.  Workspace storage retention can be customized on the  CircleCI web app by navigating to Plan  Usage Controls.   Example:    - attach_workspace:
    at: /tmp/workspace       The lifetime of artifacts, workspaces, and caches can be customized on the  CircleCI web app by navigating to Plan  Usage Controls. Here you can control the storage retention periods for these objects. If no storage period is set, the default storage retention period of artifacts is 30 days, while the default storage retention period of workspaces and caches is 15 days.          add_ssh_keys  Special step that adds SSH keys from a project’s settings to a container. Also configures SSH to use these keys. For more information on SSH keys see the  Create additional GitHub SSH keys page.      Using server? only MD5 fingerprints are supported. In CircleCI in Project Settings  SSH keys  Additional SSH keys the MD5 fingerprint will be visible. SHA256 support is planned for an upcoming server release.       KeyRequiredTypeDescriptionfingerprintsNListList of fingerprints corresponding to the keys to be added (default: all keys added)   steps:
  - add_ssh_keys:
      fingerprints:
        - "b7:35:a6:4e:9b:0d:6d:d4:78:1e:9a:97:2a:66:6b:be"
        - "SHA256:NPj4IcXxqQEKGXOghi/QbG2sohoNfvZ30JwCcdSSNM0"       Even though CircleCI uses ssh-agent to sign all added SSH keys, you must use the add_ssh_keys key to actually add keys to a container.          Using pipeline values  Pipeline values are available to all pipeline configurations and can be used without previous declaration. For a list of pipeline values, see the  Pipeline values and parameters page.   Example:    version: 2.1
jobs:
  build:
    docker:
      - image: cimg/node:20.18.1
    environment:
      IMAGETAG: latest
    working_directory: ~/main
    steps:
      - run: echo "This is pipeline ID << pipeline.id >>"       circleci_ip_ranges     A paid account on a  Performance or Scale Plan is required to access IP ranges.        Enables jobs to go through a set of well-defined IP address ranges. See  IP ranges for details.   Example:    version: 2.1

jobs:
  build:
    circleci_ip_ranges: true # opts the job into the IP ranges feature
    docker:
      - image: curlimages/curl
    steps:
      - run: echo “Hello World”
workflows:
  build-workflow:
    jobs:
      - build         workflows   Used for orchestrating all jobs. Each workflow consists of the workflow name as a key and a map as a value. A name should be unique within the current config.yml. The top-level keys for the Workflows configuration are version and jobs. For more information, see the  Using Workflows to Orchestrate Jobs page.    version     The workflows version key is not required for version: 2.1 configuration        The Workflows version field is used to issue warnings for deprecation or breaking changes.  KeyRequiredTypeDescriptionversionY if config version is 2StringShould currently be 2    <workflow_name>  A unique name for your workflow.    triggers  Specifies which triggers will cause this workflow to be executed. Default behavior is to trigger the workflow when pushing to a branch.  KeyRequiredTypeDescriptiontriggersNArrayShould currently be schedule.   workflows:
   nightly:
     triggers:
       - schedule:
           cron: "0 0 * * *"
           filters:
             branches:
               only:
                 - main
                 - beta
     jobs:
       - test     schedule     Scheduled workflows are not available for projects integrated through the GitHub App, GitLab or Bitbucket Data Center.           The scheduled workflows feature is set to be deprecated. Using scheduled pipelines rather than scheduled workflows offers several benefits. Visit the scheduled pipelines  migration guide to find out how to migrate existing scheduled workflows to scheduled pipelines. If you would like to set up scheduled pipelines from scratch, visit the  Scheduled pipelines page.        A workflow may have a schedule indicating it runs at a certain time, for example a nightly build that runs every day at 12am UTC:    workflows:
   nightly:
     triggers:
       - schedule:
           cron: "0 0 * * *"
           filters:
             branches:
               only:
                 - main
                 - beta
     jobs:
       - test     cron  The cron key is defined using POSIX crontab syntax.  KeyRequiredTypeDescriptioncronYStringSee the  crontab man page.   workflows:
   nightly:
     triggers:
       - schedule:
           cron: "0 0 * * *"
           filters:
             branches:
               only:
                 - main
                 - beta
     jobs:
       - test      filters  Trigger filters can have the key branches.  KeyRequiredTypeDescriptionfiltersYMapA map defining rules for execution on specific branches   workflows:
   nightly:
     triggers:
       - schedule:
           cron: "0 0 * * *"
           filters:
             branches:
               only:
                 - main
                 - beta
     jobs:
       - test      branches  The branches key controls whether the current branch should have a schedule trigger created for it, where current branch is the branch containing the config.yml file with the trigger stanza. That is, a push on the main branch will only schedule a  workflow for the main branch.   Branches can have the keys only and ignore which each map to a single string naming a branch. You may also use regular expressions to match against branches by enclosing them with `/’s, or map to a list of such strings. Regular expressions must match the entire string.     Any branches that match only will run the job.   Any branches that match ignore will not run the job.   If neither only nor ignore are specified then all branches will run the job. If both only and ignore are specified, the only is used and ignore will have no effect.      workflows:
  commit:
    jobs:
      - test
      - deploy
  nightly:
    triggers:
      - schedule:
          cron: "0 0 * * *"
          filters:
            branches:
              only:
                - main
                - /^release\/.*/
    jobs:
      - coverage   KeyRequiredTypeDescriptionbranchesYMapA map defining rules for execution on specific branchesonly 1NString, or List of StringsEither a single branch specifier, or a list of branch specifiersignore 1NString, or List of StringsEither a single branch specifier, or a list of branch specifiers  1: One of either only or ignore branch filters must be specified. If both are present, only is used.       Using when in workflows     Using when or unless under workflows is supported in version: 2.1 configuration. Workflows are always run unless there is a when or unless filter that prevents the workflow from being run. If you want a workflow to run in every pipeline, do not add a when or unless filter.        You may use a when clause (the inverse clause unless is also supported) under a workflow declaration with a  logic statement to determine whether or not to run that workflow.   The example configuration below uses a pipeline parameter, run_integration_tests to drive the integration_tests workflow.    version: 2.1

workflows:
  integration_tests:
    when: pipeline.git.branch == "main"
    jobs:
      - mytestjob

jobs:
...    This example prevents the workflow integration_tests from running unless the pipeline is triggered on the main branch.   Refer to the  Workflows for more examples and conceptual information.     jobs  A job can have the keys requires, name, context, type, and filters.  KeyRequiredTypeDescriptionjobsYListA list of jobs to run with their dependencies   <job_name>  A job name that exists in your config.yml.    serial-group  The serial-group key is used to add a property to a job to allow a group of jobs to run in series, rather than concurrently, across an organization. Serial groups control the orchestration of jobs across an organization, not just within projects and pipelines.   The serial-group key is configurable per job. It is not possible to configure the key for a group of jobs at this time.   The value of the serial-group key is a string that is used to group jobs together to run one after another. The key must meet the following requirements:     Must be less than or equal to (≤) 512 characters, once compiled.   Must not be blank.   Must consist of alphanumeric characters plus, ., -, _, /.     Note the following features of serial groups:     You can use pipeline values and parameters in the serial-group key.   Serial groups will wait for five hours. After this jobs waiting in the group will be cancelled. This does not affect the standard limits that apply to a  job’s runtime.         Pipeline order protection in serial groups   Jobs in a serial group follow an order protection mechanism, as follows:     Jobs start in the order they join the queue, but are accepted based on pipeline number.   If a group is waiting/running and another job in the same project attempts to join the queue with a lower pipeline number, the job is skipped.   This immediate skip process exists to maintain order integrity, which is a safety process to avoid unexpected work in a build, for example, a deployment job running a previous version unexpectedly.     If there are no serial groups waiting/running, a pipeline with a lower number can start, such as restoring back to a previous pipeline via a rerun workflow.        KeyRequiredTypeDescriptionserial-groupNStringA string that is used across an org to group jobs together to run one after another. Can include pipeline values and parameters. Use this same serial group across multiple pipelines to control the orchestration of jobs across an organization.  Example:    # Creating multiple pipelines at the same time with the below config will results in
# all pipelines running test and build but only a single pipeline will run deploy at a time.

workflows:
  main-workflow:
    jobs:
      - test
      - build
      - deploy:
          serial-group: << pipeline.project.slug >>/deploy-group
          requires:
            - test
            - build    For more information, see the  Controlling serial execution across your organization page. '''    requires  Jobs are run concurrently by default, so you must explicitly require any dependencies by their job name if you need some jobs to run sequentially.  KeyRequiredTypeDescriptionrequiresNList A list of jobs that must succeed or attain a specified status for the job to start. Note: When jobs in the current workflow that are listed as dependencies are not executed (due to a filter function for example), their requirement as a dependency for other jobs will be ignored by the requires option. However, if all dependencies of a job are filtered, then that job will not be executed either.   Possible types of requires items:     Job name (a required job that must succeed for the job to start)   Map of job name to status (a required job that must attain the specified status for the job to start)   Map of job name to a list of statuses (a required job that must attain one of the specified status for the job to start)     The possible status values are: success, failed and canceled.    workflows:
  my-workflow:
    jobs:
      - build
      - test:
          requires:
            - build
      - deploy:
          requires:
            - build
            - test
      - notify-build-canceled:
          requires:
            - build: canceled
      - cleanup:
          requires:
            - deploy:
              - failed
              - canceled      name  The name key can be used to invoke reusable jobs across any number of workflows. Using the name key ensures numbers are not appended to your job name (for example, sayhello-1 , sayhello-2, etc.). The name you assign to the name key needs to be unique, otherwise the numbers will still be appended to the job name.  KeyRequiredTypeDescriptionnameNStringA replacement for the job name. Useful when calling a job multiple times. If you want to invoke the same job multiple times, and a job requires one of the duplicate jobs, this key is required. (2.1 only)    context  Jobs may be configured to use global environment variables set for an organization, see the  Contexts document for adding a context in the application settings.  KeyRequiredTypeDescriptioncontextNString/ListThe name of the context(s). The initial default name is org-global. Each context name must be unique. If using CircleCI server, only a single context per workflow is supported. Note: A maximum of 100 unique contexts across all workflows is allowed.    type  A job may have a type of approval indicating it must be manually approved before downstream jobs may proceed. For more information see the  Using workflows to orchestrate jobs page.   Jobs run in the dependency order until the workflow processes a job with the type: approval key followed by a job on which it depends, for example:    workflows:
  my-workflow:
    jobs:
      - build
      - test:
          requires:
            - build
      - hold:
          type: approval
          requires:
            - test
      - deploy:
          requires:
            - hold    An approval job can have any name. In the example above the approval job is named hold. The name you choose for an approval job should not be used to define a job in the main configuration. An approval job only exists as a workflow orchestration devise.     filters  Filter job execution within a workflow based on the following:     Branch   Tag   Expression-based condition     Job filters can have the keys branches or tags.      Workflows will ignore job-level branching. If you use job-level branching and later add workflows, you must remove the branching at the job level and instead declare it in the workflows section of your config.yml.       KeyRequiredTypeDescriptionfiltersNMapA map or string to define rules for job execution. Branch and tag filters require a map. Expression-based filters require a string.  The following is an example of how the CircleCI documentation project uses a regular expression to filter running a job in a workflow only on a specific branch:    # ...
workflows:
  build-deploy:
    jobs:
      - js_build
      - build_server_pdfs: # << the job to conditionally run based on the filter-by-branch-name.
          filters:
            branches:
              only: /server\/.*/ # the job build_server_pdfs will only run when the branch being built starts with server/    You can read more about using regular expressions in your config in the  Using workflows to schedule jobs page.     Expression-based job filters  Expression-based job filters allow you to conditionally run jobs based on the following:      Pipeline values    Pipeline parameters     An expression-based job filter is a rule that is evaluated against pipeline values and parameters to decide whether a job should run.   Using expression-based job filters is one way to optimize your pipelines. Optimizations include the following:     Lower costs.   Decrease time to feedback.   Run specific jobs based on the context of the source of change.      workflows:
  deploy:
    jobs:
      - init-service
      - test-service
      - build-service-image:
          requires:
            - init-service
      - dry-run-service:
          requires:
            - init-service
          filters: pipeline.git.branch != "main" and pipeline.git.branch != "canary"
      - publish-service:
          requires:
            - build-service-image
            - test-service
          filters: pipeline.git.branch == "main" or pipeline.git.tag starts-with "release"
      - deploy-service:
          context:
            - org-global
          requires:
            - publish-service
          filters: pipeline.git.branch == "main" and pipeline.parameters.my-custom-param starts-with "DEPLOY:"    Examples   Only run the job on the project’s main branch:    filters: pipeline.git.branch == "main"    Only run the job on the project’s main branch, or branches starting with integration-test:    filters: pipeline.git.branch == "main" or pipeline.git.branch starts-with "integration-test"    Only run the job on the main branch, and disallow use with pipelines  triggered with unversioned configuration:    filters: pipeline.git.branch == "main" and not (pipeline.trigger_source starts-with "api")    Use pipeline parameters and the pipeline value pipeline.git.branch to run a job only on specific branches or when triggered via the API with a pipeline parameter set to true:    version: 2.1

parameters:
  run-storybook-tests:
    type: boolean
    default: false

...
# jobs configuration ommitted for brevity

workflows:
  build:
    jobs:
      - setup
      - storybook-tests:
          requires:
            - setup
          filters: |
            pipeline.parameters.run-storybook-tests
            or pipeline.git.branch == "dry-run-deploy"
            or pipeline.git.branch starts-with "deploy"    You can use the API to trigger a pipeline with a pipeline parameter set to true:      Using server? If you are using CircleCI server, replace https://circleci.com with your server hostname when interacting with the CircleCI API.         curl -X POST https://circleci.com/api/v2/project/circleci/<org-id>/<project-id>/pipeline/run \
  --header "Circle-Token: $CIRCLE_TOKEN" \
  --header "content-type: application/json" \
  --data {
  "definition_id": "<pipeline-definition-id>",
  "config": {"branch": "<your-branch-name>"},
  "checkout": {"branch": "<your-branch-name>"},
  "parameters": {"run-storybook-tests": "true"}
  }    Operators   The operators you can use for expression-based job filters are described in the following table. You can also group sub-expressions with parentheses (, ). as in the examples above.  Operator typeOperatorsDescriptionLogicaland, orThese are short-circuiting boolean operators.Equality==, !=String, numeric, and boolean equality. If the operands are of different types then == will evaluate false, and != will evaluate true.Equalitystarts-withString prefix equality, "hello world" starts-with "hello" evaluates as true. It is an error to use a non-string type as an operand.Numeric comparison>=, >, ⇐, <Numeric comparisons. It is an error to use a non-numeric type as an operand.Negationnot Boolean negation.   Note that not has very high precedence and so binds very tightly. Use sub-expressions to apply not to more complex expressions. For example, with foo being true and bar being false:     not foo and bar evaluates to false   not (foo and bar) evaluates to true       branches  The branches filter can have the keys only and ignore, which map to a single string naming a branch. You may also use regular expressions to match against branches by enclosing them with slashes, or map to a list of such strings. Regular expressions must match the entire string.     Any branches that match only will run the job.   Any branches that match ignore will not run the job.   If neither only nor ignore are specified then all branches will run the job.   If both only and ignore are specified the only is considered before ignore.    KeyRequiredTypeDescriptionbranchesNMapA map defining rules for execution on specific branches.onlyNString, or list of stringsEither a single branch specifier, or a list of branch specifiers.ignoreNString, or list of stringsEither a single branch specifier, or a list of branch specifiers.   workflows:
  dev_stage_pre-prod:
    jobs:
      - test_dev:
          filters:  # using regex filters requires the entire branch to match
            branches:
              only:  # only branches matching the below regex filters will run
                - dev
                - /user-.*/
      - test_stage:
          filters:
            branches:
              only: stage
      - test_pre-prod:
          filters:
            branches:
              only: /pre-prod(?:-.+)?$/      tags  CircleCI does not run workflows for tags unless you explicitly specify tag filters. If a job requires any other jobs (directly or indirectly), you must specify tag filters for those jobs.   Tags can have the keys only and ignore. You may also use regular expressions to match against tags by enclosing them with slashes, or map to a list of such strings. Regular expressions must match the entire string. Both lightweight and annotated tags are supported.     Any tags that match only will run the job.   Any tags that match ignore will not run the job.   If neither only nor ignore are specified then the job is skipped for all tags.   If both only and ignore are specified the only is considered before ignore.    KeyRequiredTypeDescriptiontagsNMapA map defining rules for execution on specific tagsonlyNString, or List of StringsEither a single tag specifier, or a list of tag specifiersignoreNString, or List of StringsEither a single tag specifier, or a list of tag specifiers  For more information, see the  Executing workflows for a git tag section of the Workflows page.    workflows:
  untagged-build:
    jobs:
      - build
  tagged-build:
    jobs:
      - build:
          filters:
            tags:
              only: /^v.*/      matrix     The matrix key is supported in version: 2.1 configuration        The matrix stanza allows you to run a parameterized job multiple times with different arguments. For more information see the how-to guide on  Using Matrix Jobs. In order to use the matrix stanza, you must use parameterized jobs.  KeyRequiredTypeDescriptionparametersYMapA map of parameter names to every value the job should be called withexcludeNListA list of argument maps that should be excluded from the matrixaliasNStringAn alias for the matrix, usable from another job’s requires stanza. Defaults to the name of the job being executed  Example:   The following is a basic example of using matrix jobs.    workflows:
  workflow:
    jobs:
      - build:
          matrix:
            parameters:
              version: ["0.1", "0.2", "0.3"]
              platform: ["macos", "windows", "linux"]    This expands to 9 different build jobs, and could be equivalently written as:    workflows:
  workflow:
    jobs:
      - build:
          name: build-macos-0.1
          version: "0.1"
          platform: macos
      - build:
          name: build-macos-0.2
          version: "0.2"
          platform: macos
      - build:
          name: build-macos-0.3
          version: "0.3"
          platform: macos
      - build:
          name: build-windows-0.1
          version: "0.1"
          platform: windows
      - ...      Excluding sets of parameters from a matrix  Sometimes you may wish to run a job with every combination of arguments except some value or values. You can use an exclude stanza to achieve this:    workflows:
  workflow:
    jobs:
      - build:
          matrix:
            parameters:
              a: [1, 2, 3]
              b: [4, 5, 6]
            exclude:
              - a: 3
                b: 5    The matrix above would expand into 8 jobs: every combination of the parameters a and b, excluding {a: 3, b: 5}     Dependencies and matrix jobs  To require an entire matrix (every job within the matrix), use its alias. The alias defaults to the name of the job being invoked.    workflows:
  workflow:
    jobs:
      - deploy:
          matrix:
            parameters:
              version: ["0.1", "0.2"]
      - another-job:
          requires:
            - deploy    This means that another-job will require both deploy jobs in the matrix to finish before it runs.   Matrix jobs expose their parameter values via << matrix.* >> which can be used to generate more complex workflows. For example, here is a deploy matrix where each job waits for its respective build job in another matrix.    workflows:
  workflow:
    jobs:
      - build:
          name: build-v<< matrix.version >>
          matrix:
            parameters:
              version: ["0.1", "0.2"]
      - deploy:
          name: deploy-v<< matrix.version >>
          matrix:
            parameters:
              version: ["0.1", "0.2"]
          requires:
            - build-v<< matrix.version >>    This workflow will expand to:    workflows:
  workflow:
    jobs:
      - build:
          name: build-v0.1
          version: "0.1"
      - build:
          name: build-v0.2
          version: "0.2"
      - deploy:
          name: deploy-v0.1
          version: "0.1"
          requires:
            - build-v0.1
      - deploy:
          name: deploy-v0.2
          version: "0.2"
          requires:
            - build-v0.2      pre-steps and post-steps     Pre-steps and post-steps are supported in version: 2.1 configuration        Every job invocation in a workflow may optionally accept two special arguments: pre-steps and post-steps.   Steps under pre-steps are executed before any of the other steps in the job. The steps under post-steps are executed after all of the other steps.   Pre and post steps allow you to execute steps in a given job without modifying the job. Pre and post steps are useful, for example, to run custom setup steps before job execution.    version: 2.1

jobs:
  bar:
    machine:
      image: ubuntu-2004:2024.05.1
    steps:
      - checkout
      - run:
          command: echo "building"
      - run:
          command: echo "testing"

workflows:
  build:
    jobs:
      - bar:
          pre-steps: # steps to run before steps defined in the job bar
            - run:
                command: echo "install custom dependency"
          post-steps: # steps to run after steps defined in the job bar
            - run:
                command: echo "upload artifact to s3"           Logic statements   Certain dynamic configuration features accept logic statements as arguments. Logic statements are evaluated to boolean values at configuration compilation time, that is, before the workflow is run. The group of logic statements includes:  TypeArgumentstrue ifExampleYAML literalNoneis truthytrue/42/"a string"YAML aliasNoneresolves to a truthy value*my-alias Pipeline ValueNoneresolves to a truthy value<< pipeline.git.branch >> Pipeline ParameterNoneresolves to a truthy value<< pipeline.parameters.my-parameter >>andN logic statementsall arguments are truthyand: [ true, true, false ]orN logic statementsany argument is truthyor: [ false, true, false ]not1 logic statementthe argument is not truthynot: trueequalN valuesall arguments evaluate to equal valuesequal: [ 42, << pipeline.number >>]matchespattern and valuevalue matches the patternmatches: { pattern: "^feature-.$", value: << pipeline.git.branch >> }+  The following logic values are considered falsy:     false   null   0   NaN   empty strings ("")   statements with no arguments     All other values are truthy. Also note that using logic with an empty list will cause a validation error.   Logic statements always evaluate to a boolean value at the top level, and coerce as necessary. They can be nested in an arbitrary fashion, according to their argument specifications, and to a maximum depth of 100 levels.   matches uses  Java regular expressions for its pattern. A full match pattern must be provided, prefix matching is not an option. Though, it is recommended to enclose a pattern in ^ and $ to avoid accidental partial matches.      When using logic statements at the workflow level, do not include the condition: key (the condition key is only needed for job level logic statements).         workflows:
  my-workflow:
    when:
      or:
        - equal: [ main, << pipeline.git.branch >> ]
        - equal: [ staging, << pipeline.git.branch >> ]    Logic statement examples  You can find usage examples on the  "Orchestration cookbook" page.      Example full configuration      Using Docker? Authenticating Docker pulls from image registries is recommended when using the Docker execution environment. Authenticated pulls allow access to private Docker images, and may also grant higher rate limits, depending on your registry provider. For further information see  Using Docker authenticated pulls.         version: 2.1
jobs:
  build:
    docker:
      - image: ubuntu:23.04

      - image: mongo:6.0.14
        command: [mongod, --smallfiles]

      - image: postgres:14.12
        # some containers require setting environment variables
        environment:
          POSTGRES_USER: user

      - image: redis@sha256:54057dd7e125ca41afe526a877e8bd35ec2cdd33b9217e022ed37bdcf7d09673

      - image: rabbitmq:3.12.12

    environment:
      TEST_REPORTS: /tmp/test-reports

    working_directory: ~/my-project

    steps:
      - checkout

      - run:
          command: echo 127.0.0.1 devhost | sudo tee -a /etc/hosts

      # Create Postgres users and database
      # Note the YAML heredoc '|' for nicer formatting
      - run: |
          sudo -u root createuser -h localhost --superuser ubuntu &&
          sudo createdb -h localhost test_db

      - restore_cache:
          keys:
            - v1-my-project-{{ checksum "project.clj" }}
            - v1-my-project-

      - run:
          environment:
            SSH_TARGET: "localhost"
            TEST_ENV: "linux"
          command: |
            set -xu
            mkdir -p ${TEST_REPORTS}
            run-tests.sh
            cp out/tests/*.xml ${TEST_REPORTS}

      - run: |
          set -xu
          mkdir -p /tmp/artifacts
          create_jars.sh << pipeline.number >>
          cp *.jar /tmp/artifacts

      - save_cache:
          key: v1-my-project-{{ checksum "project.clj" }}
          paths:
            - ~/.m2

      # Save artifacts
      - store_artifacts:
          path: /tmp/artifacts
          destination: build

      # Upload test results
      - store_test_results:
          path: /tmp/test-reports

  deploy-stage:
    docker:
      - image: ubuntu:23.04
    working_directory: /tmp/my-project
    steps:
      - run:
          name: Deploy if tests pass and branch is Staging
          command: ansible-playbook site.yml -i staging

  deploy-prod:
    docker:
      - image: ubuntu:23.04
    working_directory: /tmp/my-project
    steps:
      - run:
          name: Deploy if tests pass and branch is Main
          command: ansible-playbook site.yml -i production

workflows:
  build-deploy:
    jobs:
      - build:
          filters:
            branches:
              ignore:
                - develop
                - /feature-.*/
      - deploy-stage:
          requires:
            - build
          filters:
            branches:
              only: staging
      - deploy-prod:
          requires:
            - build
          filters:
            branches:
              only: main    Suggest an edit to this pageMake a contribution Learn how to contributeStill need help? Ask the CircleCI community Join the research community Visit our Support site\n\nConfiguration reference1 week agoCloudServer v4+Helpful Resources6 config optimization tipsIntro to dynamic configUsing dynamic configValidate your config using local CLIHow to trigger a single jobOn This Pageversionsetuporbscommandsparametersexecutorsjobs<job_name>typeenvironmentparallelismparametersExecutor docker / machine / macosdockerDocker registry authenticationAWS authenticationUse OIDCUse environment variablesmachineAvailable Linux machine imagesAvailable Linux machine images on serverAvailable Linux GPU machine imagesAvailable Android machine imagesAvailable Windows machine imagesAvailable Windows machine images on serverAvailable Windows GPU machine imagemacosbranches - DEPRECATEDresource_classSelf-hosted runnerDocker execution environmentx86ArmLinuxVM execution environmentmacOS execution environmentmacOS execution environment on serverWindows execution environmentGPU execution environment (Linux)GPU execution-environment (Windows)Arm VM execution-environmentstepsrunDefault shell options-e-o pipefailBackground commandsShorthand syntaxThe when attributeEnding a job from within a stepThe when stepcheckoutsetup_remote_dockersave_cacherestore_cachedeploy - DEPRECATEDstore_artifactsstore_test_resultspersist_to_workspaceattach_workspaceadd_ssh_keysUsing pipeline valuescircleci_ip_rangesworkflowsversion<workflow_name>triggersschedulecronfiltersbranchesUsing when in workflowsjobs<job_name>serial-grouprequiresnamecontexttypefiltersExpression-based job filtersbranchestagsmatrixExcluding sets of parameters from a matrixDependencies and matrix jobspre-steps and post-stepsLogic statementsLogic statement examplesExample full configuration   This document is a reference for the CircleCI 2.x configuration keys that are used in the .circleci/config.yml file.   You can see a complete config.yml in our  full example.      version  KeyRequiredTypeDescriptionversionYString2, 2.0, or 2.1 See the  Reusable configuration page for an overview of 2.1 keys available to simplify your .circleci/config.yml file, reuse, and parameterized jobs.  The version field is intended to be used in order to issue warnings for deprecation or breaking changes.      setup  KeyRequiredTypeDescriptionsetupNBooleanDesignates the config.yaml for use of CircleCI’s  dynamic configuration feature.  The setup field enables you to conditionally trigger configurations from outside the primary .circleci parent directory, update pipeline parameters, or generate customized configurations.      orbs      The orbs key is supported in version: 2.1 configuration       KeyRequiredTypeDescriptionorbsNMapA map of user-selected names to either: orb references (strings) or orb definitions (maps). Orb definitions must be the orb-relevant subset of 2.1 config. See the  Creating Orbs documentation for details.executorsNMapA map of strings to executor definitions. See the  executors section below.commandsNMapA map of command names to command definitions. See the  commands section below.  The following example uses the node orb that exists in the certified circleci namespace. Refer to the Node orb page in the  Orb Registry for more examples and information.    version: 2.1

orbs:
  node: circleci/node@x.y

jobs:
  install-node-example:
    docker:
      - image: cimg/base:stable
    steps:
      - checkout
      - node/install:
          install-yarn: true
          node-version: '16.13'
      - run: node --version
workflows:
  test_my_app:
    jobs:
      - install-node-example    Documentation is available for orbs in the following sections:      Using Orbs    Authoring Orbs.     Public orbs are listed in the  Orb Registry.      commands      The commands key is supported in version: 2.1 configuration        A command defines a sequence of steps as a map to be executed in a job, enabling you to reuse a single command definition across multiple jobs. For more information see the  Reusable Config Reference Guide.  KeyRequiredTypeDescriptionstepsYSequenceA sequence of steps run inside the calling job of the command.parametersNMapA map of parameter keys. See the  Parameter Syntax section of the  Reusing Config document for details.descriptionNStringA string that describes the purpose of the command.  Example:    commands:
  sayhello:
    description: "A very simple command for demonstration purposes"
    parameters:
      to:
        type: string
        default: "Hello World"
    steps:
      - run: echo << parameters.to >>       parameters      The pipeline parameters key is supported in version: 2.1 configuration        Pipeline parameters declared for use in the configuration. See  Pipeline Values and Parameters for usage details.  KeyRequiredTypeDescriptionparametersNMapA map of parameter keys. Supports string, boolean, integer and enum types. See  Parameter Syntax for details.     executors      The executors key is supported in version: 2.1 configuration        Executors define the execution environment in which the steps of a job will be run, allowing you to reuse a single executor definition across multiple jobs.  KeyRequiredTypeDescriptiondockerY (1)ListOptions for  Docker executorresource_classNStringAmount of CPU and RAM allocated to each container in a job.machineY (1)MapOptions for  machine executormacosY (1)MapOptions for  macOS executorwindowsY (1)Map Windows executor currently working with orbs. Check out  the orb.shellNStringShell to use for execution command in all steps. Can be overridden by shell in each step (default: See  Default Shell Options)working_directoryNStringIn which directory to run the steps. Will be interpreted as an absolute path.environmentNMapA map of environment variable names and values.  (1) One executor type should be specified per job. If more than one is set you will receive an error.   Example:    version: 2.1
executors:
  my-executor:
    docker:
      - image: cimg/ruby:3.0.3-browsers

jobs:
  my-job:
    executor: my-executor
    steps:
      - run: echo "Hello executor!"    See the  Using Parameters in Executors section of the  Reusing config page for examples of parameterized executors.      jobs   A Workflow is comprised of one or more uniquely named jobs. Jobs are specified in the jobs map, see  Sample config.yml for two examples of a job map. The name of the job is the key in the map, and the value is a map describing the job.   Jobs have a maximum runtime based on pricing plan, as follows:     1 hour (Free)   3 hours (Performance)   5 hours (Scale)     If your jobs are timing out, consider the following:     A larger  resource_class.   Using  parallelism.   Run some of your jobs concurrently using  workflows.   You can upgrade your pricing plan.      <job_name>  Each job consists of the job’s name as a key and a map as a value. A name should be case insensitive unique within a current jobs list. The value map has the following attributes:  KeyRequiredTypeDescriptiontypeNStringJob type, can be build, release, no-op, or approval. If not specified, defaults to build.dockerY (1)ListOptions for the  Docker executormachineY (1)MapOptions for the  machine executormacosY (1)MapOptions for the  macOS executorshellNStringShell to use for execution command in all steps. Can be overridden by shell in each step (default: See  Default Shell Options)parametersNMap Parameters for making a job explicitly configurable in a workflow.stepsYListA list of  steps to be performedworking_directoryNStringIn which directory to run the steps. Will be interpreted as an absolute path. Default: ~/project (where project is a literal string, not the name of your specific project). Processes run during the job can use the $CIRCLE_WORKING_DIRECTORY environment variable to refer to this directory. Note: Paths written in your YAML configuration file will not be expanded; if your store_test_results.path is $CIRCLE_WORKING_DIRECTORY/tests, then CircleCI will attempt to store the test subdirectory of the directory literally named $CIRCLE_WORKING_DIRECTORY, dollar sign $ and all. working_directory will be created automatically if it doesn’t exist.parallelismNIntegerNumber of parallel instances of this job to run (default: 1)environmentNMapA map of environment variable names and values.branchesNMapThis key is deprecated. Use  workflows filtering to control which jobs run for which branches.resource_classNStringAmount of CPU and RAM allocated to each container in a job.  (1) One executor type should be specified per job. If more than one is set you will receive an error.    type  Configure a job type. Options are release, approval, no-op, build (default).   If a type is not specified, the job defaults to a build type.   Example of a job with a build type. build is the default type and does not need to be configured:    jobs:
  my-job:
    docker:
      - image: cimg/base:2024.12
    resource_class: xlarge
    steps:
      ... // other config    Jobs with the release type are used to  connect your pipeline configuration to a deployment in the CircleCI deploys UI. For full details, see the  Deploys overview page.   Example of a job with a release type:    jobs:
  release-my-service:
    type: release
    plan_name: <my-service-release>    The no-op type is used to configure a job that performs no actions and consumes no credits. no-op is commonly used to organise the order of operations within a workflow and make it easier to maintain. Only the type is required for a no-op type job, no further job configuration is required. For some examples of using no-op jobs, see the  Orchestration cookbook   Example of a job with a no-op type:    jobs:
  my-no-op-job:
    type: no-op    The approval type is used to configure a manual approval step. No job configuration is required or allowed for an approval type job. The approval type is most commonly configured within a workflow rather than under the top-level jobs key. Only approval type jobs can have their type configured under workflows. See  type under workflows section for full details.   Example of a job with an approval type, configured under workflows:    workflows:
  my-workflow:
    jobs:
      - build
      - test:
          requires:
            - build
      - hold:
          type: approval
          requires:
            - test
      - deploy:
          requires:
            - hold      environment  A map of environment variable names and values. For more information on defining and using environment variables, and the order of precedence governing the various ways they can be set, see the  Environment variables page.     parallelism  This feature is used to optimize test steps. If parallelism is set to N > 1, then N independent executors will be set up and each will run the steps of that job in parallel.   You can use the CircleCI CLI to split your test suite across parallel containers so the job completes in a shorter time.     Read more about splitting tests across parallel execution environments on the  Parallelism and test splitting page.   Refer to the  Use the CircleCI CLI to split tests how-to guide.   Follow the  Test splitting tutorial.     Example:    jobs:
  build:
    docker:
      - image: cimg/base:2024.12
    environment:
      FOO: bar
    parallelism: 3
    resource_class: large
    working_directory: ~/my-app
    steps:
      - run: go list ./... | circleci tests run --command "xargs gotestsum --junitfile junit.xml --format testname --" --split-by=timings --timings-type=name      parameters  Job-level parameters can be used when  calling a job in a workflow.   Reserved parameter-names:     name   requires   context   type   filters   matrix     See  Parameter Syntax for definition details.     Executor docker / machine / macos  CircleCI offers several execution environments in which to run your jobs. To specify an execution environment choose an executor, then specify and image and a resource class. An executor defines the underlying technology, environment, and operating system in which to run a job.   Set up your jobs to run using the docker (Linux), machine (LinuxVM, Windows, GPU, Arm), or macos executor, then specify an image with the tools and packages you need, and a resource class.   Learn more about execution environments and executors in the  Introduction to Execution Environments.     docker  Configured by docker key which takes a list of maps:  KeyRequiredTypeDescriptionimageYStringThe name of a custom Docker image to use. The first image listed under a job defines the job’s own primary container image where all steps will run.nameNStringname defines the hostname for the container (the default is localhost), which is used for reaching secondary (service) containers. By default, all services are exposed directly on localhost. This field is useful if you would rather have a different hostname instead of localhost, for example, if you are starting multiple versions of the same service.entrypointNString or ListThe command used as executable when launching the container. entrypoint overrides the image’s  ENTRYPOINT.commandNString or ListThe command used as PID 1 (or arguments for entrypoint) when launching the container. command overrides the image’s COMMAND. It will be used as arguments to the image ENTRYPOINT if it has one, or as the executable if the image has no ENTRYPOINT.userNStringWhich user to run commands as within the Docker containerenvironmentNMapA map of environment variable names and values. The environment settings apply to the entrypoint/command run by the Docker container, not the job steps.authNMapAuthentication for registries using standard docker login credentialsaws_authNMapAuthentication for AWS Elastic Container Registry (ECR)  For a  primary container, (the first container in the list) if neither command nor entrypoint is specified in the configuration, then any ENTRYPOINT and COMMAND in the image are ignored. The primary container is typically only used for running the steps and not for its ENTRYPOINT, and an ENTRYPOINT may consume significant resources or exit prematurely.   A  custom image may disable this behavior and force the ENTRYPOINT to run.   You can specify image versions using tags or digest. You can use any public images from any public Docker registry (defaults to Docker Hub). Learn more about specifying images on the  Using the Docker Execution Environment page.    Docker registry authentication  Some registries, Docker Hub, for example, may rate limit anonymous Docker pulls. We recommend that you authenticate to pull private and public images. The username and password can be specified in the auth field. See  Using Docker Authenticated Pulls for details.   Example:    jobs:
  build:
    docker:
      - image: buildpack-deps:trusty # primary container
        auth:
          username: mydockerhub-user
          password: $DOCKERHUB_PASSWORD  # context / project UI env-var reference
        environment:
          ENV: CI

      - image: mongo:2.6.8
        auth:
          username: mydockerhub-user
          password: $DOCKERHUB_PASSWORD  # context / project UI env-var reference
        command: [--smallfiles]

      - image: postgres:14.2
        auth:
          username: mydockerhub-user
          password: $DOCKERHUB_PASSWORD  # context / project UI env-var reference
        environment:
          POSTGRES_USER: user

      - image: redis@sha256:54057dd7e125ca41afe526a877e8bd35ec2cdd33b9217e022ed37bdcf7d09673
        auth:
          username: mydockerhub-user
          password: $DOCKERHUB_PASSWORD  # context / project UI env-var reference

      - image: acme-private/private-image:321
        auth:
          username: mydockerhub-user
          password: $DOCKERHUB_PASSWORD  # context / project UI env-var reference      AWS authentication  Using an image hosted on  AWS ECR requires authentication using AWS credentials.   Use OIDC  Authenticate using OpenID Connect (OIDC) using the oidc_role_arn field, as follows:    jobs:
  job_name:
    docker:
      - image: <your-image-arn>
        aws_auth:
          oidc_role_arn: <your-iam-role-arn>    For steps to get set up with OIDC to pull images from AWS ECR, see the  Pull and image from AWS ECR with OIDC page.    Use environment variables  By default, CircleCI uses the AWS credentials you provide by setting the AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY project environment variables. It is also possible to set the credentials by using the aws_auth field as in the following example:    jobs:
  build:
    docker:
      - image: account-id.dkr.ecr.us-east-1.amazonaws.com/org/repo:0.1
        aws_auth:
          aws_access_key_id: AKIAQWERVA  # can specify string literal values
          aws_secret_access_key: $ECR_AWS_SECRET_ACCESS_KEY  # or project UI envar reference        machine     CircleCI cloud The use of machine: true is deprecated. You must specify an image to use.        The machine executor is configured using the machine key, which takes a map:  KeyRequiredTypeDescriptionimageYStringThe virtual machine image to use. View  available images. Note: This key is not supported for Linux VMs on installations of CircleCI server. For information about customizing machine executor images on CircleCI installed on your servers, see our  Machine provisioner documentation.docker_layer_cachingNBooleanSet this to true to enable  Docker layer caching.  Example:  CloudServer    jobs:
  build: # name of your job
    machine: # executor type
      image: ubuntu-2004:current # recommended linux image

    steps:
      # Commands run in a Linux virtual machine environment        jobs:
  build: # name of your job
    machine: true # executor type
    steps:
      # Commands run in a Linux virtual machine environment        Available Linux machine images  Specifying an image in your configuration file is strongly recommended. CircleCI supports multiple Linux machine images that can be specified in the image field. For a full list of supported image tags, refer to the following pages in the Developer Hub:      Ubuntu-2004    Ubuntu-2204     More information on the software available in each image can be found in our  Discuss forum.   The machine executor supports  Docker Layer Caching, which is useful when you are building Docker images during your job or Workflow.     Available Linux machine images on server  If you are using CircleCI server, contact your system administrator for details of available Linux machine images.     Available Linux GPU machine images  When using the Linux  GPU executor, the available images are:     linux-cuda-11:default v11.4, v11.6, v11.8 (default), Docker v20.10.24   linux-cuda-12:default v12.0, v12.1 (default), Docker v20.10.24       Available Android machine images  CircleCI supports running jobs on Android for testing and deploying Android applications.   To use the  Android image directly with the machine executor, add the following to your job:    version: 2.1

jobs:
  build:
    machine:
      image: android:2024.11.1    The Android image can also be accessed using the  Android orb.   For examples, refer to the  Using Android Images with the Machine Executor page.     Available Windows machine images  Specifying an image in your configuration file is strongly recommended. CircleCI supports multiple Windows machine images that can be specified in the image field.   For a full list of supported images, refer to one of the following:      windows-server-2022-gui image    windows-server-2019 image     More information on what software is available in each image can be found in our  Discuss forum.   Alternatively, use the  Windows orb to manage your Windows execution environment. For examples, see the  Using the Windows Execution Environment page.     Available Windows machine images on server  If you are using CircleCI server, contact your system administrator for details of available Windows machine images.     Available Windows GPU machine image  When using the Windows  GPU executor, the available image is:      windows-server-2019-cuda     Example    version: 2.1

jobs:
  build:
    machine:
      image: windows-server-2019-cuda:current       macos  CircleCI supports running jobs on  macOS, to allow you to build, test, and deploy apps for macOS,  iOS,  tvOS and  watchOS. To run a job on a macOS virtual machine, add the macos key to the top-level configuration for your job and specify the version of Xcode to use.  KeyRequiredTypeDescriptionxcodeYStringThe version of Xcode that is installed on the virtual machine, see the  Supported Xcode Versions section of the Testing iOS document for the complete list.  Example: Use a macOS virtual machine with Xcode version 14.2.0:    jobs:
  build:
    macos:
      xcode: "14.2.0"      branches - DEPRECATED  This key is deprecated. Use  workflows filtering to control which jobs run for which branches.     resource_class  The resource_class feature allows you to configure CPU and RAM resources for each job. Resource classes are available for each execution environment, as described in the tables below.   We implement soft concurrency limits for each resource class to ensure our system remains stable for all customers. If you are on a Performance or Custom Plan and experience queuing for certain resource classes, it is possible you are hitting these limits.  Contact CircleCI support to request a raise on these limits for your account.   If you do not specify a resource class, CircleCI will use a default value that is subject to change. It is best practice to specify a resource class as opposed to relying on a default.      Java, Erlang and any other languages that introspect the /proc directory for information about CPU count may require additional configuration to prevent them from slowing down when using the CircleCI resource class feature. Programs with this issue may request 32 CPU cores and run slower than they would when requesting one core. Users of languages with this issue should pin their CPU count to their guaranteed CPU resources.           If you want to confirm how much memory you have been allocated, you can check the cgroup memory hierarchy limit with grep hierarchical_memory_limit /sys/fs/cgroup/memory/memory.stat.         Self-hosted runner  Use the resource_class key to configure a  self-hosted runner instance.   For example:    jobs:
  job_name:
    machine: true
    resource_class: <my-namespace>/<my-runner>      Docker execution environment  Example:    jobs:
  build:
    docker:
      - image: cimg/base:2024.12
    resource_class: xlarge
    steps:
      ... // other config    x86     For credit and access information, see the  Resource classes page. Resource class access is dependent on your  Plan.       ClassvCPUsRAMCloudServersmall12GBmedium24GBmedium+36GBlarge48GBxlarge816GB2xlarge1632GB2xlarge+2040GB   Arm  Arm on Docker For pricing information, and a list of CircleCI Docker convenience images that support Arm resource classes, see the  Resource classes page.       Arm on Docker For credit and access information see the  Resource classes page. Resource class access is dependent on your  Plan   To find out which CircleCI Docker convenience images support Arm resource classes, you can refer to  Docker hub:     Select the image (for example, cimg/python).   Select the tags tab.   View what is supported under OS/ARCH for the latest tags. For example, cimg/python has linux/amd64 and linux/arm64, which means Arm is supported.          ClassvCPUsRAMCloudServerarm.medium28 GBarm.large416 GBarm.xlarge832 GBarm.2xlarge1664 GB     LinuxVM execution environment ClassvCPUsRAMDisk SizeCloudServermedium27.5 GB150GBlarge415 GB150GBxlarge832 GB150GB2xlarge1664 GB150GB2xlarge+3264 GB150GB  Example:  CloudServer    jobs:
  build:
    machine:
      image: ubuntu-2004:2024.01.2 # recommended linux image
    resource_class: large
    steps:
      ... // other config        jobs:
  build:
    machine: true
    resource_class: large
    steps:
      ... // other config         macOS execution environment ClassvCPUsRAMCloudServermacos.m1.medium.gen14 @ 3.2 GHz6GBmacos.m1.large.gen18 @ 3.2 GHz12GBm2pro.medium4 @ 3.49 GHz8GBm2pro.large8 @ 3.49 GHz16GB      We have deprecated support for all Intel-based macOS resources.   The macos.x86.medium.gen2 resource class was deprecated on June 28, 2024.   See our  announcement for more details.         Example    jobs:
  build:
    macos:
      xcode: "15.4.0"
    resource_class: m2pro.medium
    steps:
      ... // other config      macOS execution environment on server  If you are working on CircleCI server v3.1 and up, you can access the macOS execution environment using  self-hosted runner.     Windows execution environment ClassvCPUsRAMDisk SizeCloudServerwindows.medium (default)415GB200 GBwindows.large830GB200 GBwindows.xlarge1660GB200 GBwindows.2xlarge32128GB200 GB     Using server? Check with your systems administrator whether you have access to the Windows execution environment.        Example:  CloudServer    version: 2.1

jobs:
  build: # name of your job
    resource_class: 'windows.medium'
    machine:
      image: 'windows-server-2022-gui:current'
      shell: 'powershell.exe -ExecutionPolicy Bypass'
    steps:
      # Commands are run in a Windows virtual machine environment
      - checkout
      - run: Write-Host 'Hello, Windows'        version: 2.1

jobs:
  build: # name of your job
    machine:
      image: windows-default
    steps:
      # Commands are run in a Windows virtual machine environment
      - checkout
      - run: Write-Host 'Hello, Windows'         GPU execution environment (Linux) ClassvCPUsRAMGPUsGPU modelGPU Memory (GiB)Disk Size (GiB)CloudServergpu.nvidia.small4161NVIDIA Tesla P416150gpu.nvidia.small.gen24161NVIDIA A10G24150gpu.nvidia.small.multi4152NVIDIA Tesla T416150gpu.nvidia.medium.multi8304NVIDIA Tesla T416150gpu.nvidia.medium8301NVIDIA Tesla T416150gpu.nvidia.large8301NVIDIA Tesla V10016150  Example:    version: 2.1

jobs:
  build:
    machine:
      image: linux-cuda-12:default
    resource_class: gpu.nvidia.medium
    steps:
      - run: nvidia-smi
      - run: docker run --gpus all nvidia/cuda:9.0-base nvidia-smi    See the  Available Linux GPU images section for the full list of available images.     GPU execution-environment (Windows) ClassvCPUsRAMGPUsGPU modelGPU Memory (GiB)Disk Size (GiB)CloudServerwindows.gpu.nvidia.medium16601NVIDIA Tesla T416200  Example:    version: 2.1
orbs:
  win: circleci/windows@5.0.0

jobs:
  build:
    executor: win/server-2019-cuda
    steps:
      - checkout
      - run: '&"C:\Program Files\NVIDIA Corporation\NVSMI\nvidia-smi.exe"'    (2) This resource requires review by our support team.  Open a support ticket if you would like to request access.     Arm VM execution-environment ClassvCPUsRAMDisk SizeCloudServerarm.medium (default)28GB100 GBarm.large416GB100 GBarm.xlarge832GB100 GBarm.2xlarge1664GB100 GB     Using server? Check with your systems administrator whether you have access to the Arm execution environment.        Example:  CloudServer    jobs:
  my-job:
    machine:
      image: ubuntu-2004:2024.01.2
    resource_class: arm.medium
    steps:
      - run: uname -a
      - run: echo "Hello, Arm!"        jobs:
  my-job:
    machine:
      image: arm-default
    resource_class: arm.medium
    steps:
      - run: uname -a
      - run: echo "Hello, Arm!"          steps  The steps setting in a job should be a list of single key/value pairs, the key of which indicates the step type. The value may be either a configuration map or a string (depending on what that type of step requires). For example, using a map:    jobs:
  build:
    working_directory: ~/canary-python
    environment:
      FOO: bar
    steps:
      - run:
          name: Running tests
          command: make test    Here run is a step type. The name attribute is used by the UI for display purposes. The command attribute is specific for run step and defines command to execute.   Some steps may implement a shorthand semantic. For example, run may be also be called like this:    jobs:
  build:
    steps:
      - run: make test    In its short form, the run step allows us to directly specify which command to execute as a string value. In this case step itself provides default suitable values for other attributes (name here will have the same value as command, for example).   Another shorthand, which is possible for some steps, is to use the step name as a string instead of a key/value pair:    jobs:
  build:
    steps:
      - checkout    In this case, the checkout step will check out project source code into the job’s  working_directory.   In general all steps can be described as:  KeyRequiredTypeDescription<step_type>YMap or StringA configuration map for the step or some string whose semantics are defined by the step.  Each built-in step is described in detail below.    run  The run step is used to invoke command-line programs. The run step takes either a map of configuration values, or, when called in its short-form, a string that will be used as both the command and name. Run commands are executed using non-login shells by default, so you must explicitly source any dotfiles as part of the command.      the run step replaces the deprecated deploy step. If your job has a parallelism of 1, the deprecated deploy step can be swapped out directly for the run step. If your job has parallelism > 1, see  Migrate from deploy to run.       KeyRequiredTypeDescriptioncommandYStringCommand to run via the shellnameNStringTitle of the step to be shown in the CircleCI UI (default: full command)shellNStringShell to use for execution command (default: See  Default Shell Options)environmentNMapAdditional environmental variables, locally scoped to commandbackgroundNBooleanWhether or not this step should run in the background (default: false)working_directoryNStringIn which directory to run this step. Will be interpreted relative to the  working_directory of the job). (default: .)no_output_timeoutNStringElapsed time the command can run without output. The string is a decimal with unit suffix, such as "20m", "1.25h", "5s". The default is 10 minutes and the maximum is governed by the  maximum time a job is allowed to run.whenNString Specify when to enable or disable the step. Takes the following values: always, on_success, on_fail (default: on_success)  Each run declaration represents a new shell. It is possible to specify a multi-line command, each line of which will be run in the same shell:    - run:
    command: |
      echo Running test
      mkdir -p /tmp/test-results
      make test    You can also configure commands to run  in the background if you do not want to wait for the step to complete before moving on to subsequent run steps.    Default shell options  For jobs that run on Linux, the default value of the shell option is /bin/bash -eo pipefail if /bin/bash is present in the build container. Otherwise it is /bin/sh -eo pipefail. The default shell is not a login shell (--login or -l are not specified). Hence, the shell will not source your ~/.bash_profile, ~/.bash_login, ~/.profile files.   For jobs that run on macOS, the default shell is /bin/bash --login -eo pipefail. The shell is a non-interactive login shell. The shell will execute /etc/profile/ followed by ~/.bash_profile before every step.   For more information about which files are executed when Bash is invocated,  see the INVOCATION section of the bash manpage.   Descriptions of the -eo pipefail options are provided below.    -e  Exit immediately if any of the following exits with a non-zero status:     A pipeline (which may consist of a single simple command).   A subshell command enclosed in parentheses.   One of the commands executed as part of a command list enclosed by braces.     In the previous example, mkdir failed to create a directory and returned a non-zero status, then command execution would be terminated, and the whole step would be marked as failed. If you desire the opposite behaviour, you need to add set +e in your command or override the default shell in your configuration map of run. For example:    - run:
    command: |
      echo Running test
      set +e
      mkdir -p /tmp/test-results
      make test

- run:
    shell: /bin/sh
    command: |
      echo Running test
      mkdir -p /tmp/test-results
      make test     -o pipefail  If pipefail is enabled, the pipeline’s return status is the value of the last (rightmost) command to exit with a non-zero status, or zero if all commands exit successfully. The shell waits for all commands in the pipeline to terminate before returning a value.   For example:    - run: make test | tee test-output.log    If make test fails, the -o pipefail option will cause the whole step to fail. Without -o pipefail, the step will always run successfully because the result of the whole pipeline is determined by the last command (tee test-output.log), which will always return a zero status.      If make test fails the rest of pipeline will be executed.        If you want to avoid this behaviour, you can specify set +o pipefail in the command or override the whole shell (see example above).   In general, we recommend using the default options (-eo pipefail) because they show errors in intermediate commands and simplify debugging job failures. For convenience, the UI displays the used shell and all active options for each run step.   For more information, see the  Using Shell Scripts document.     Background commands  The background attribute enables you to configure commands to run in the background. Job execution will immediately proceed to the next step rather than waiting for return of a command with the background attribute set to true. The following example shows the configuration for running the X virtual framebuffer in the background which is commonly required to run Selenium tests:    - run:
    name: Running X virtual framebuffer
    command: Xvfb :99 -screen 0 1280x1024x24
    background: true

- run: make test      Shorthand syntax  run has a very convenient shorthand syntax:    - run: make test

# shorthanded command can also have multiple lines
- run: |
    mkdir -p /tmp/test-results
    make test    In this case, command and name become the string value of run, and the rest of the config map for that run have their default values.     The when attribute  By default, CircleCI will execute job steps one at a time, in the order that they are defined in config.yml, until a step fails (returns a non-zero exit code). After a command fails, no further job steps will be executed.   Adding the when attribute to a job step allows you to override this default behaviour, and selectively run or skip steps depending on the status of the job.   The when attribute accepts the following values:    on_success  The step will run only if all of the previous steps have been successful (returned exit code 0). on_success is the default value.  always  The step will run regardless of the exit status of previous steps. always is useful if you have a task that you want to run regardless of whether the previous steps are successful or not. For example, you might have a job step that needs to upload logs or code-coverage data somewhere.  on_fail  The step will run only if one of the preceding steps has failed (returns a non-zero exit code). A common use of on_fail is to store some diagnostic data to help debug test failures, or to run custom notifications about the failure, such as sending emails or triggering alerts.        Some steps, such as store_artifacts and store_test_results will always run, even if a step has failed (returned a non-zero exit code) previously. The when attribute, store_artifacts and store_test_results are not run if the job has been killed by a cancel request or has reached the runtime timeout limit.         - run:
    name: Upload CodeCov.io Data
    command: bash <(curl -s https://codecov.io/bash) -F unittests
    when: always # Uploads code coverage results, pass or fail      Ending a job from within a step  A job can exit without failing by using run: circleci-agent step halt. However, if a step within the job is already failing then the job will continue to fail. This can be useful in situations where jobs need to conditionally execute.   Here is an example where halt is used to avoid running a job on the develop branch:    - run: |
    if [ "$CIRCLE_BRANCH" = "develop" ]; then
        circleci-agent step halt
    fi       The when step     The when and unless steps are supported in version: 2.1 configuration        A conditional step consists of a step with the key when or unless. Under the when key are the subkeys condition and steps. The purpose of the when step is customizing commands and job configuration to run on custom conditions (determined at config-compile time) that are checked before a workflow runs. See the  Conditional Steps section of the reusable configuration reference for more details.  KeyRequiredTypeDescriptionconditionYLogic A logic statementstepsYSequenceA list of steps to execute when the condition is true  Example:    version: 2.1

jobs: # conditional steps may also be defined in `commands:`
  job_with_optional_custom_checkout:
    parameters:
      custom_checkout:
        type: string
        default: ""
    machine:
      image: ubuntu-2004:2024.11.1
    steps:
      - when:
          condition: <<parameters.custom_checkout>>
          steps:
            - run: echo "my custom checkout"
      - unless:
          condition: <<parameters.custom_checkout>>
          steps:
            - checkout
workflows:
  build-test-deploy:
    jobs:
      - job_with_optional_custom_checkout:
          custom_checkout: "any non-empty string is truthy"
      - job_with_optional_custom_checkout      checkout      Blobless clones   A "blobless" strategy is being rolled out to help improve the performance of code checkouts from Git source code hosts.   Blobless clones reduce the amount of data fetched from the remote, by asking the remote to filter out objects that are not attached to the current commit.   While this improves performance in most cases, if a downstream step requires those objects to exist for scanning or comparisons, it can cause failures. To work around these potential problems, a fetch directly after a checkout will ensure the required data is available:    - checkout
- run: git fetch          A special step used to check out source code to the configured path (defaults to the working_directory). The reason this is a special step is because it is more of a helper function designed to simplify the process of checking out code. If you require doing git over HTTPS you should not use this step as it configures git to checkout over SSH.  KeyRequiredTypeDescriptionpathNStringCheckout directory. Will be interpreted relative to the  working_directory of the job). (default: .)  If path already exists and is:     A git repository - step will not clone whole repository, instead will fetch origin   NOT a git repository - step will fail.     In the case of checkout, the step type is just a string with no additional attributes:    - checkout    The checkout command automatically adds the required authenticity keys for interacting with GitHub and Bitbucket over SSH. These keys are detailed further in the  integration guide. This guide is also helpful if you wish to implement a custom checkout command.   CircleCI does not check out submodules. If your project requires submodules, add run steps with appropriate commands as shown in the following example:    - checkout
- run: git submodule sync
- run: git submodule update --init       The checkout step will configure Git to skip automatic garbage collection. If you are caching your .git directory with  restore_cache and would like to use garbage collection to reduce its size, you may wish to use a  run step with command git gc before doing so.          setup_remote_docker  Allows Docker commands to be run locally. See  Running Docker commands for details.    jobs:
  build:
    docker:
      - image: cimg/base:2024.06
    steps:
      # ... steps for building/testing app ...
      - setup_remote_docker:
          version: default   KeyRequiredTypeDescriptiondocker_layer_cachingNbooleanSet this to true to enable  Docker Layer Caching in the Remote Docker Environment (default: false)versionNStringVersion string of Docker you would like to use (default: 24.0.9). View the list of supported Docker versions  here.        setup_remote_docker is not compatible with the machine executor. See  Docker Layer Caching in Machine Executor for information on how to enable DLC with the machine executor.   The version key is not currently supported on CircleCI server. Contact your system administrator for information about the Docker version installed in your remote Docker environment. If you are on server 4.x, you can find the default AWS AMI  here.             save_cache  Generates and stores a cache of a file or directory of files such as dependencies or source code in our object storage. Later jobs can  restore this cache. Learn more on the  Caching Dependencies page.   Cache retention can be customized on the  CircleCI web app by navigating to Plan  Usage Controls.  KeyRequiredTypeDescriptionpathsYListList of directories which should be added to the cachekeyYStringUnique identifier for this cachenameNStringTitle of the step to be shown in the CircleCI UI (default: "Saving Cache")whenNString Specify when to enable or disable the step. Takes the following values: always, on_success, on_fail (default: on_success)  The cache for a specific key is immutable and cannot be changed once written.      If the cache for the given key already exists it will not be modified, and job execution will proceed to the next step.        When storing a new cache, the key value may contain special, templated, values for your convenience:  TemplateDescription{{ .Branch }}The VCS branch currently being built.{{ .BuildNum }}The CircleCI build number for this build.{{ .Revision }}The VCS revision currently being built.{{ .CheckoutKey }}The SSH key used to checkout the repository.{{ .Environment.variableName }}The environment variable variableName (supports any environment variable  exported by CircleCI or added to a specific  context--not any arbitrary environment variable).{{ checksum "filename" }}A base64 encoded SHA256 hash of the given filename’s contents. This should be a file committed in your repository and may also be referenced as a path that is absolute or relative from the current working directory. Good candidates are dependency manifests, such as package-lock.json, pom.xml or project.clj. It is important that this file does not change between restore_cache and save_cache, otherwise the cache will be saved under a cache key different than the one used at restore_cache time.{{ epoch }}The current time in seconds since the UNIX epoch.{{ arch }}The OS and CPU information. Useful when caching compiled binaries that depend on OS and CPU architecture, for example, darwin amd64 versus linux i386/32-bit.  During step execution, the templates above will be replaced by runtime values and use the resultant string as the key.   Template examples:     myapp-{{ checksum "package-lock.json" }} - cache will be regenerated every time something is changed in package-lock.json file, different branches of this project will generate the same cache key.   myapp-{{ .Branch }}-{{ checksum "package-lock.json" }} - same as the previous one, but each branch will generate separate cache   myapp-{{ epoch }} - every run of a job will generate a separate cache     While choosing suitable templates for your cache key, keep in mind that:     Cache saving is not a free operation. See the billing section on the  FAQ page.   It takes time to upload the cache.     Best practice is to have a key that generates a new cache only if something actually changed and avoid generating a new one every time a job is run.      Given the immutability of caches, it might be helpful to start all your cache keys with a version prefix v1-.... That way you will be able to regenerate all your caches just by incrementing the version in this prefix.        Example:    - save_cache:
    key: v1-myapp-{{ arch }}-{{ checksum "project.clj" }}
    paths:
      - /home/ubuntu/.m2     - save_cache:
    key: v1-{{ checksum "yarn.lock" }}
    paths:
      - node_modules/workspace-a
      - node_modules/workspace-c          Wildcards are not currently supported in save_cache paths. Visit the  Ideas board and vote for this feature if it would be useful for you or your organization.   In some instances, a workaround for this is to save a particular workspace to cache:             restore_cache  Restores a previously saved cache based on a key. Cache needs to have been saved first for this key using the  save_cache step. Learn more in  the caching documentation.  KeyRequiredTypeDescriptionkeyY (1)StringSingle cache key to restorekeysY (1)ListList of cache keys to lookup for a cache to restore. Only first existing key will be restored.nameNStringTitle of the step to be shown in the CircleCI UI (default: "Restoring Cache")  (1) at least one attribute has to be present. If key and keys are both given, key will be checked first, and then keys.   A key is searched against existing keys as a prefix.      When there are multiple matches, the most recent match will be used, even if there is a more precise match.        For example:    steps:
  - save_cache:
      key: v1-myapp-cache
      paths:
        - ~/d1

  - save_cache:
      key: v1-myapp-cache-new
      paths:
        - ~/d2

  - run: rm -f ~/d1 ~/d2

  - restore_cache:
      key: v1-myapp-cache    In this case cache v1-myapp-cache-new will be restored because it’s the most recent match with v1-myapp-cache prefix even if the first key (v1-myapp-cache) has exact match.   For more information on key formatting, see the key section of  save_cache step.   When CircleCI encounters a list of keys, the cache will be restored from the first key matching an existing cache. We recommend you use a more specific key first (for example, cache for exact version of package-lock.json) and more generic keys after (for example, any cache for this project). If no key has a cache that exists, the step will be skipped with a warning.   A path is not required here because the cache will be restored to the location from which it was originally saved.   Example:    - restore_cache:
    keys:
      - v1-myapp-{{ arch }}-{{ checksum "project.clj" }}
      # if cache for exact version of `project.clj` is not present then load any most recent one
      - v1-myapp-

# ... Steps building and testing your application ...

# cache will be saved only once for each version of `project.clj`
- save_cache:
    key: v1-myapp-{{ arch }}-{{ checksum "project.clj" }}
    paths:
      - /foo      deploy - DEPRECATED  See  run for current processes. If you have parallelism > 1 in your job, see the  Migrate from deploy to run guide.     store_artifacts  Step to store artifacts (for example logs, binaries, etc) to be available in the web app or through the API. See the  Uploading Artifacts page for more information.  KeyRequiredTypeDescriptionpathYStringDirectory in the primary container to save as job artifactsdestinationNStringPrefix added to the artifact paths in the artifacts API (default: the directory of the file specified in path)  There can be multiple store_artifacts steps in a job. Using a unique prefix for each step prevents them from overwriting files.   Artifact storage retention can be customized on the  CircleCI web app by navigating to Plan  Usage Controls.   Example:    - run:
    name: Build the Jekyll site
    command: bundle exec jekyll build --source jekyll --destination jekyll/_site/docs/
- store_artifacts:
    path: jekyll/_site/docs/
    destination: circleci-docs      store_test_results  Special step used to upload and store test results for a build. Test results are visible on the CircleCI web application under each build’s Test Summary section. Storing test results is useful for timing analysis of your test suites. For more information on storing test results, see the  Collecting Test Data page.   You can also store test results as build artifacts. For steps, refer to  the store_artifacts step section.  KeyRequiredTypeDescriptionpathYStringPath (absolute, or relative to your working_directory) to directory containing JUnit XML test metadata files, or to a single test file.  Example:   Directory structure:    test-results
├── jest
│   └── results.xml
├── mocha
│   └── results.xml
└── rspec
    └── results.xml    config.yml syntax:    - store_test_results:
    path: test-results      persist_to_workspace  Special step used to persist a temporary file to be used by another job in the workflow. For more information on using workspaces, see the  Using Workspaces to Share Data Between Jobs page.   persist_to_workspace adopts the storage settings from the storage customization controls on the CircleCI web app. If no custom setting is provided, persist_to_workspace defaults to 15 days.   Workspace storage retention can be customized on the  CircleCI web app by navigating to Plan  Usage Controls.  KeyRequiredTypeDescriptionrootYStringEither an absolute path or a path relative to working_directorypathsYListGlob identifying file(s), or a non-glob path to a directory to add to the shared workspace. Interpreted as relative to the workspace root. Must not be the workspace root itself.  The root key is a directory on the container which is taken to be the root directory of the workspace. The path values are all relative to the root.   Example for root Key   For example, the following step syntax persists the specified paths from /tmp/dir into the workspace, relative to the directory /tmp/dir.    - persist_to_workspace:
    root: /tmp/dir
    paths:
      - foo/bar
      - baz    After this step completes, the following directories are added to the workspace:    /tmp/dir/foo/bar
/tmp/dir/baz    Example for paths Key    - persist_to_workspace:
    root: /tmp/workspace
    paths:
      - target/application.jar
      - build/*    The paths list uses Glob from Go, and the pattern matches  filepath.Match.    pattern:
        { term }
term:
        '*' matches any sequence of non-Separator characters
        '?' matches any single non-Separator character
        '[' [ '^' ] { character-range }
        ']' character class (must be non-empty)
        c matches character c (c != '*', '?', '\\', '[')
        '\\' c matches character c
character-range:
        c matches character c (c != '\\', '-', ']')
        '\\' c matches character c
        lo '-' hi matches character c for lo <= c <= hi    The Go documentation states that the pattern may describe hierarchical names such as /usr/*/bin/ed (assuming the Separator is '/').      Everything must be relative to the work space root directory.          attach_workspace  Special step used to attach the workflow’s workspace to the current container. The full contents of the workspace are downloaded and copied into the directory the workspace is being attached at. For more information on using workspaces, see the  Using workspaces page.  KeyRequiredTypeDescriptionatYStringDirectory to attach the workspace to.  Workspace storage retention can be customized on the  CircleCI web app by navigating to Plan  Usage Controls.   Example:    - attach_workspace:
    at: /tmp/workspace       The lifetime of artifacts, workspaces, and caches can be customized on the  CircleCI web app by navigating to Plan  Usage Controls. Here you can control the storage retention periods for these objects. If no storage period is set, the default storage retention period of artifacts is 30 days, while the default storage retention period of workspaces and caches is 15 days.          add_ssh_keys  Special step that adds SSH keys from a project’s settings to a container. Also configures SSH to use these keys. For more information on SSH keys see the  Create additional GitHub SSH keys page.      Using server? only MD5 fingerprints are supported. In CircleCI in Project Settings  SSH keys  Additional SSH keys the MD5 fingerprint will be visible. SHA256 support is planned for an upcoming server release.       KeyRequiredTypeDescriptionfingerprintsNListList of fingerprints corresponding to the keys to be added (default: all keys added)   steps:
  - add_ssh_keys:
      fingerprints:
        - "b7:35:a6:4e:9b:0d:6d:d4:78:1e:9a:97:2a:66:6b:be"
        - "SHA256:NPj4IcXxqQEKGXOghi/QbG2sohoNfvZ30JwCcdSSNM0"       Even though CircleCI uses ssh-agent to sign all added SSH keys, you must use the add_ssh_keys key to actually add keys to a container.          Using pipeline values  Pipeline values are available to all pipeline configurations and can be used without previous declaration. For a list of pipeline values, see the  Pipeline values and parameters page.   Example:    version: 2.1
jobs:
  build:
    docker:
      - image: cimg/node:20.18.1
    environment:
      IMAGETAG: latest
    working_directory: ~/main
    steps:
      - run: echo "This is pipeline ID << pipeline.id >>"       circleci_ip_ranges     A paid account on a  Performance or Scale Plan is required to access IP ranges.        Enables jobs to go through a set of well-defined IP address ranges. See  IP ranges for details.   Example:    version: 2.1

jobs:
  build:
    circleci_ip_ranges: true # opts the job into the IP ranges feature
    docker:
      - image: curlimages/curl
    steps:
      - run: echo “Hello World”
workflows:
  build-workflow:
    jobs:
      - build         workflows   Used for orchestrating all jobs. Each workflow consists of the workflow name as a key and a map as a value. A name should be unique within the current config.yml. The top-level keys for the Workflows configuration are version and jobs. For more information, see the  Using Workflows to Orchestrate Jobs page.    version     The workflows version key is not required for version: 2.1 configuration        The Workflows version field is used to issue warnings for deprecation or breaking changes.  KeyRequiredTypeDescriptionversionY if config version is 2StringShould currently be 2    <workflow_name>  A unique name for your workflow.    triggers  Specifies which triggers will cause this workflow to be executed. Default behavior is to trigger the workflow when pushing to a branch.  KeyRequiredTypeDescriptiontriggersNArrayShould currently be schedule.   workflows:
   nightly:
     triggers:
       - schedule:
           cron: "0 0 * * *"
           filters:
             branches:
               only:
                 - main
                 - beta
     jobs:
       - test     schedule     Scheduled workflows are not available for projects integrated through the GitHub App, GitLab or Bitbucket Data Center.           The scheduled workflows feature is set to be deprecated. Using scheduled pipelines rather than scheduled workflows offers several benefits. Visit the scheduled pipelines  migration guide to find out how to migrate existing scheduled workflows to scheduled pipelines. If you would like to set up scheduled pipelines from scratch, visit the  Scheduled pipelines page.        A workflow may have a schedule indicating it runs at a certain time, for example a nightly build that runs every day at 12am UTC:    workflows:
   nightly:
     triggers:
       - schedule:
           cron: "0 0 * * *"
           filters:
             branches:
               only:
                 - main
                 - beta
     jobs:
       - test     cron  The cron key is defined using POSIX crontab syntax.  KeyRequiredTypeDescriptioncronYStringSee the  crontab man page.   workflows:
   nightly:
     triggers:
       - schedule:
           cron: "0 0 * * *"
           filters:
             branches:
               only:
                 - main
                 - beta
     jobs:
       - test      filters  Trigger filters can have the key branches.  KeyRequiredTypeDescriptionfiltersYMapA map defining rules for execution on specific branches   workflows:
   nightly:
     triggers:
       - schedule:
           cron: "0 0 * * *"
           filters:
             branches:
               only:
                 - main
                 - beta
     jobs:
       - test      branches  The branches key controls whether the current branch should have a schedule trigger created for it, where current branch is the branch containing the config.yml file with the trigger stanza. That is, a push on the main branch will only schedule a  workflow for the main branch.   Branches can have the keys only and ignore which each map to a single string naming a branch. You may also use regular expressions to match against branches by enclosing them with `/’s, or map to a list of such strings. Regular expressions must match the entire string.     Any branches that match only will run the job.   Any branches that match ignore will not run the job.   If neither only nor ignore are specified then all branches will run the job. If both only and ignore are specified, the only is used and ignore will have no effect.      workflows:
  commit:
    jobs:
      - test
      - deploy
  nightly:
    triggers:
      - schedule:
          cron: "0 0 * * *"
          filters:
            branches:
              only:
                - main
                - /^release\/.*/
    jobs:
      - coverage   KeyRequiredTypeDescriptionbranchesYMapA map defining rules for execution on specific branchesonly 1NString, or List of StringsEither a single branch specifier, or a list of branch specifiersignore 1NString, or List of StringsEither a single branch specifier, or a list of branch specifiers  1: One of either only or ignore branch filters must be specified. If both are present, only is used.       Using when in workflows     Using when or unless under workflows is supported in version: 2.1 configuration. Workflows are always run unless there is a when or unless filter that prevents the workflow from being run. If you want a workflow to run in every pipeline, do not add a when or unless filter.        You may use a when clause (the inverse clause unless is also supported) under a workflow declaration with a  logic statement to determine whether or not to run that workflow.   The example configuration below uses a pipeline parameter, run_integration_tests to drive the integration_tests workflow.    version: 2.1

workflows:
  integration_tests:
    when: pipeline.git.branch == "main"
    jobs:
      - mytestjob

jobs:
...    This example prevents the workflow integration_tests from running unless the pipeline is triggered on the main branch.   Refer to the  Workflows for more examples and conceptual information.     jobs  A job can have the keys requires, name, context, type, and filters.  KeyRequiredTypeDescriptionjobsYListA list of jobs to run with their dependencies   <job_name>  A job name that exists in your config.yml.    serial-group  The serial-group key is used to add a property to a job to allow a group of jobs to run in series, rather than concurrently, across an organization. Serial groups control the orchestration of jobs across an organization, not just within projects and pipelines.   The serial-group key is configurable per job. It is not possible to configure the key for a group of jobs at this time.   The value of the serial-group key is a string that is used to group jobs together to run one after another. The key must meet the following requirements:     Must be less than or equal to (≤) 512 characters, once compiled.   Must not be blank.   Must consist of alphanumeric characters plus, ., -, _, /.     Note the following features of serial groups:     You can use pipeline values and parameters in the serial-group key.   Serial groups will wait for five hours. After this jobs waiting in the group will be cancelled. This does not affect the standard limits that apply to a  job’s runtime.         Pipeline order protection in serial groups   Jobs in a serial group follow an order protection mechanism, as follows:     Jobs start in the order they join the queue, but are accepted based on pipeline number.   If a group is waiting/running and another job in the same project attempts to join the queue with a lower pipeline number, the job is skipped.   This immediate skip process exists to maintain order integrity, which is a safety process to avoid unexpected work in a build, for example, a deployment job running a previous version unexpectedly.     If there are no serial groups waiting/running, a pipeline with a lower number can start, such as restoring back to a previous pipeline via a rerun workflow.        KeyRequiredTypeDescriptionserial-groupNStringA string that is used across an org to group jobs together to run one after another. Can include pipeline values and parameters. Use this same serial group across multiple pipelines to control the orchestration of jobs across an organization.  Example:    # Creating multiple pipelines at the same time with the below config will results in
# all pipelines running test and build but only a single pipeline will run deploy at a time.

workflows:
  main-workflow:
    jobs:
      - test
      - build
      - deploy:
          serial-group: << pipeline.project.slug >>/deploy-group
          requires:
            - test
            - build    For more information, see the  Controlling serial execution across your organization page. '''    requires  Jobs are run concurrently by default, so you must explicitly require any dependencies by their job name if you need some jobs to run sequentially.  KeyRequiredTypeDescriptionrequiresNList A list of jobs that must succeed or attain a specified status for the job to start. Note: When jobs in the current workflow that are listed as dependencies are not executed (due to a filter function for example), their requirement as a dependency for other jobs will be ignored by the requires option. However, if all dependencies of a job are filtered, then that job will not be executed either.   Possible types of requires items:     Job name (a required job that must succeed for the job to start)   Map of job name to status (a required job that must attain the specified status for the job to start)   Map of job name to a list of statuses (a required job that must attain one of the specified status for the job to start)     The possible status values are: success, failed and canceled.    workflows:
  my-workflow:
    jobs:
      - build
      - test:
          requires:
            - build
      - deploy:
          requires:
            - build
            - test
      - notify-build-canceled:
          requires:
            - build: canceled
      - cleanup:
          requires:
            - deploy:
              - failed
              - canceled      name  The name key can be used to invoke reusable jobs across any number of workflows. Using the name key ensures numbers are not appended to your job name (for example, sayhello-1 , sayhello-2, etc.). The name you assign to the name key needs to be unique, otherwise the numbers will still be appended to the job name.  KeyRequiredTypeDescriptionnameNStringA replacement for the job name. Useful when calling a job multiple times. If you want to invoke the same job multiple times, and a job requires one of the duplicate jobs, this key is required. (2.1 only)    context  Jobs may be configured to use global environment variables set for an organization, see the  Contexts document for adding a context in the application settings.  KeyRequiredTypeDescriptioncontextNString/ListThe name of the context(s). The initial default name is org-global. Each context name must be unique. If using CircleCI server, only a single context per workflow is supported. Note: A maximum of 100 unique contexts across all workflows is allowed.    type  A job may have a type of approval indicating it must be manually approved before downstream jobs may proceed. For more information see the  Using workflows to orchestrate jobs page.   Jobs run in the dependency order until the workflow processes a job with the type: approval key followed by a job on which it depends, for example:    workflows:
  my-workflow:
    jobs:
      - build
      - test:
          requires:
            - build
      - hold:
          type: approval
          requires:
            - test
      - deploy:
          requires:
            - hold    An approval job can have any name. In the example above the approval job is named hold. The name you choose for an approval job should not be used to define a job in the main configuration. An approval job only exists as a workflow orchestration devise.     filters  Filter job execution within a workflow based on the following:     Branch   Tag   Expression-based condition     Job filters can have the keys branches or tags.      Workflows will ignore job-level branching. If you use job-level branching and later add workflows, you must remove the branching at the job level and instead declare it in the workflows section of your config.yml.       KeyRequiredTypeDescriptionfiltersNMapA map or string to define rules for job execution. Branch and tag filters require a map. Expression-based filters require a string.  The following is an example of how the CircleCI documentation project uses a regular expression to filter running a job in a workflow only on a specific branch:    # ...
workflows:
  build-deploy:
    jobs:
      - js_build
      - build_server_pdfs: # << the job to conditionally run based on the filter-by-branch-name.
          filters:
            branches:
              only: /server\/.*/ # the job build_server_pdfs will only run when the branch being built starts with server/    You can read more about using regular expressions in your config in the  Using workflows to schedule jobs page.     Expression-based job filters  Expression-based job filters allow you to conditionally run jobs based on the following:      Pipeline values    Pipeline parameters     An expression-based job filter is a rule that is evaluated against pipeline values and parameters to decide whether a job should run.   Using expression-based job filters is one way to optimize your pipelines. Optimizations include the following:     Lower costs.   Decrease time to feedback.   Run specific jobs based on the context of the source of change.      workflows:
  deploy:
    jobs:
      - init-service
      - test-service
      - build-service-image:
          requires:
            - init-service
      - dry-run-service:
          requires:
            - init-service
          filters: pipeline.git.branch != "main" and pipeline.git.branch != "canary"
      - publish-service:
          requires:
            - build-service-image
            - test-service
          filters: pipeline.git.branch == "main" or pipeline.git.tag starts-with "release"
      - deploy-service:
          context:
            - org-global
          requires:
            - publish-service
          filters: pipeline.git.branch == "main" and pipeline.parameters.my-custom-param starts-with "DEPLOY:"    Examples   Only run the job on the project’s main branch:    filters: pipeline.git.branch == "main"    Only run the job on the project’s main branch, or branches starting with integration-test:    filters: pipeline.git.branch == "main" or pipeline.git.branch starts-with "integration-test"    Only run the job on the main branch, and disallow use with pipelines  triggered with unversioned configuration:    filters: pipeline.git.branch == "main" and not (pipeline.trigger_source starts-with "api")    Use pipeline parameters and the pipeline value pipeline.git.branch to run a job only on specific branches or when triggered via the API with a pipeline parameter set to true:    version: 2.1

parameters:
  run-storybook-tests:
    type: boolean
    default: false

...
# jobs configuration ommitted for brevity

workflows:
  build:
    jobs:
      - setup
      - storybook-tests:
          requires:
            - setup
          filters: |
            pipeline.parameters.run-storybook-tests
            or pipeline.git.branch == "dry-run-deploy"
            or pipeline.git.branch starts-with "deploy"    You can use the API to trigger a pipeline with a pipeline parameter set to true:      Using server? If you are using CircleCI server, replace https://circleci.com with your server hostname when interacting with the CircleCI API.         curl -X POST https://circleci.com/api/v2/project/circleci/<org-id>/<project-id>/pipeline/run \
  --header "Circle-Token: $CIRCLE_TOKEN" \
  --header "content-type: application/json" \
  --data {
  "definition_id": "<pipeline-definition-id>",
  "config": {"branch": "<your-branch-name>"},
  "checkout": {"branch": "<your-branch-name>"},
  "parameters": {"run-storybook-tests": "true"}
  }    Operators   The operators you can use for expression-based job filters are described in the following table. You can also group sub-expressions with parentheses (, ). as in the examples above.  Operator typeOperatorsDescriptionLogicaland, orThese are short-circuiting boolean operators.Equality==, !=String, numeric, and boolean equality. If the operands are of different types then == will evaluate false, and != will evaluate true.Equalitystarts-withString prefix equality, "hello world" starts-with "hello" evaluates as true. It is an error to use a non-string type as an operand.Numeric comparison>=, >, ⇐, <Numeric comparisons. It is an error to use a non-numeric type as an operand.Negationnot Boolean negation.   Note that not has very high precedence and so binds very tightly. Use sub-expressions to apply not to more complex expressions. For example, with foo being true and bar being false:     not foo and bar evaluates to false   not (foo and bar) evaluates to true       branches  The branches filter can have the keys only and ignore, which map to a single string naming a branch. You may also use regular expressions to match against branches by enclosing them with slashes, or map to a list of such strings. Regular expressions must match the entire string.     Any branches that match only will run the job.   Any branches that match ignore will not run the job.   If neither only nor ignore are specified then all branches will run the job.   If both only and ignore are specified the only is considered before ignore.    KeyRequiredTypeDescriptionbranchesNMapA map defining rules for execution on specific branches.onlyNString, or list of stringsEither a single branch specifier, or a list of branch specifiers.ignoreNString, or list of stringsEither a single branch specifier, or a list of branch specifiers.   workflows:
  dev_stage_pre-prod:
    jobs:
      - test_dev:
          filters:  # using regex filters requires the entire branch to match
            branches:
              only:  # only branches matching the below regex filters will run
                - dev
                - /user-.*/
      - test_stage:
          filters:
            branches:
              only: stage
      - test_pre-prod:
          filters:
            branches:
              only: /pre-prod(?:-.+)?$/      tags  CircleCI does not run workflows for tags unless you explicitly specify tag filters. If a job requires any other jobs (directly or indirectly), you must specify tag filters for those jobs.   Tags can have the keys only and ignore. You may also use regular expressions to match against tags by enclosing them with slashes, or map to a list of such strings. Regular expressions must match the entire string. Both lightweight and annotated tags are supported.     Any tags that match only will run the job.   Any tags that match ignore will not run the job.   If neither only nor ignore are specified then the job is skipped for all tags.   If both only and ignore are specified the only is considered before ignore.    KeyRequiredTypeDescriptiontagsNMapA map defining rules for execution on specific tagsonlyNString, or List of StringsEither a single tag specifier, or a list of tag specifiersignoreNString, or List of StringsEither a single tag specifier, or a list of tag specifiers  For more information, see the  Executing workflows for a git tag section of the Workflows page.    workflows:
  untagged-build:
    jobs:
      - build
  tagged-build:
    jobs:
      - build:
          filters:
            tags:
              only: /^v.*/      matrix     The matrix key is supported in version: 2.1 configuration        The matrix stanza allows you to run a parameterized job multiple times with different arguments. For more information see the how-to guide on  Using Matrix Jobs. In order to use the matrix stanza, you must use parameterized jobs.  KeyRequiredTypeDescriptionparametersYMapA map of parameter names to every value the job should be called withexcludeNListA list of argument maps that should be excluded from the matrixaliasNStringAn alias for the matrix, usable from another job’s requires stanza. Defaults to the name of the job being executed  Example:   The following is a basic example of using matrix jobs.    workflows:
  workflow:
    jobs:
      - build:
          matrix:
            parameters:
              version: ["0.1", "0.2", "0.3"]
              platform: ["macos", "windows", "linux"]    This expands to 9 different build jobs, and could be equivalently written as:    workflows:
  workflow:
    jobs:
      - build:
          name: build-macos-0.1
          version: "0.1"
          platform: macos
      - build:
          name: build-macos-0.2
          version: "0.2"
          platform: macos
      - build:
          name: build-macos-0.3
          version: "0.3"
          platform: macos
      - build:
          name: build-windows-0.1
          version: "0.1"
          platform: windows
      - ...      Excluding sets of parameters from a matrix  Sometimes you may wish to run a job with every combination of arguments except some value or values. You can use an exclude stanza to achieve this:    workflows:
  workflow:
    jobs:
      - build:
          matrix:
            parameters:
              a: [1, 2, 3]
              b: [4, 5, 6]
            exclude:
              - a: 3
                b: 5    The matrix above would expand into 8 jobs: every combination of the parameters a and b, excluding {a: 3, b: 5}     Dependencies and matrix jobs  To require an entire matrix (every job within the matrix), use its alias. The alias defaults to the name of the job being invoked.    workflows:
  workflow:
    jobs:
      - deploy:
          matrix:
            parameters:
              version: ["0.1", "0.2"]
      - another-job:
          requires:
            - deploy    This means that another-job will require both deploy jobs in the matrix to finish before it runs.   Matrix jobs expose their parameter values via << matrix.* >> which can be used to generate more complex workflows. For example, here is a deploy matrix where each job waits for its respective build job in another matrix.    workflows:
  workflow:
    jobs:
      - build:
          name: build-v<< matrix.version >>
          matrix:
            parameters:
              version: ["0.1", "0.2"]
      - deploy:
          name: deploy-v<< matrix.version >>
          matrix:
            parameters:
              version: ["0.1", "0.2"]
          requires:
            - build-v<< matrix.version >>    This workflow will expand to:    workflows:
  workflow:
    jobs:
      - build:
          name: build-v0.1
          version: "0.1"
      - build:
          name: build-v0.2
          version: "0.2"
      - deploy:
          name: deploy-v0.1
          version: "0.1"
          requires:
            - build-v0.1
      - deploy:
          name: deploy-v0.2
          version: "0.2"
          requires:
            - build-v0.2      pre-steps and post-steps     Pre-steps and post-steps are supported in version: 2.1 configuration        Every job invocation in a workflow may optionally accept two special arguments: pre-steps and post-steps.   Steps under pre-steps are executed before any of the other steps in the job. The steps under post-steps are executed after all of the other steps.   Pre and post steps allow you to execute steps in a given job without modifying the job. Pre and post steps are useful, for example, to run custom setup steps before job execution.    version: 2.1

jobs:
  bar:
    machine:
      image: ubuntu-2004:2024.05.1
    steps:
      - checkout
      - run:
          command: echo "building"
      - run:
          command: echo "testing"

workflows:
  build:
    jobs:
      - bar:
          pre-steps: # steps to run before steps defined in the job bar
            - run:
                command: echo "install custom dependency"
          post-steps: # steps to run after steps defined in the job bar
            - run:
                command: echo "upload artifact to s3"           Logic statements   Certain dynamic configuration features accept logic statements as arguments. Logic statements are evaluated to boolean values at configuration compilation time, that is, before the workflow is run. The group of logic statements includes:  TypeArgumentstrue ifExampleYAML literalNoneis truthytrue/42/"a string"YAML aliasNoneresolves to a truthy value*my-alias Pipeline ValueNoneresolves to a truthy value<< pipeline.git.branch >> Pipeline ParameterNoneresolves to a truthy value<< pipeline.parameters.my-parameter >>andN logic statementsall arguments are truthyand: [ true, true, false ]orN logic statementsany argument is truthyor: [ false, true, false ]not1 logic statementthe argument is not truthynot: trueequalN valuesall arguments evaluate to equal valuesequal: [ 42, << pipeline.number >>]matchespattern and valuevalue matches the patternmatches: { pattern: "^feature-.$", value: << pipeline.git.branch >> }+  The following logic values are considered falsy:     false   null   0   NaN   empty strings ("")   statements with no arguments     All other values are truthy. Also note that using logic with an empty list will cause a validation error.   Logic statements always evaluate to a boolean value at the top level, and coerce as necessary. They can be nested in an arbitrary fashion, according to their argument specifications, and to a maximum depth of 100 levels.   matches uses  Java regular expressions for its pattern. A full match pattern must be provided, prefix matching is not an option. Though, it is recommended to enclose a pattern in ^ and $ to avoid accidental partial matches.      When using logic statements at the workflow level, do not include the condition: key (the condition key is only needed for job level logic statements).         workflows:
  my-workflow:
    when:
      or:
        - equal: [ main, << pipeline.git.branch >> ]
        - equal: [ staging, << pipeline.git.branch >> ]    Logic statement examples  You can find usage examples on the  "Orchestration cookbook" page.      Example full configuration      Using Docker? Authenticating Docker pulls from image registries is recommended when using the Docker execution environment. Authenticated pulls allow access to private Docker images, and may also grant higher rate limits, depending on your registry provider. For further information see  Using Docker authenticated pulls.         version: 2.1
jobs:
  build:
    docker:
      - image: ubuntu:23.04

      - image: mongo:6.0.14
        command: [mongod, --smallfiles]

      - image: postgres:14.12
        # some containers require setting environment variables
        environment:
          POSTGRES_USER: user

      - image: redis@sha256:54057dd7e125ca41afe526a877e8bd35ec2cdd33b9217e022ed37bdcf7d09673

      - image: rabbitmq:3.12.12

    environment:
      TEST_REPORTS: /tmp/test-reports

    working_directory: ~/my-project

    steps:
      - checkout

      - run:
          command: echo 127.0.0.1 devhost | sudo tee -a /etc/hosts

      # Create Postgres users and database
      # Note the YAML heredoc '|' for nicer formatting
      - run: |
          sudo -u root createuser -h localhost --superuser ubuntu &&
          sudo createdb -h localhost test_db

      - restore_cache:
          keys:
            - v1-my-project-{{ checksum "project.clj" }}
            - v1-my-project-

      - run:
          environment:
            SSH_TARGET: "localhost"
            TEST_ENV: "linux"
          command: |
            set -xu
            mkdir -p ${TEST_REPORTS}
            run-tests.sh
            cp out/tests/*.xml ${TEST_REPORTS}

      - run: |
          set -xu
          mkdir -p /tmp/artifacts
          create_jars.sh << pipeline.number >>
          cp *.jar /tmp/artifacts

      - save_cache:
          key: v1-my-project-{{ checksum "project.clj" }}
          paths:
            - ~/.m2

      # Save artifacts
      - store_artifacts:
          path: /tmp/artifacts
          destination: build

      # Upload test results
      - store_test_results:
          path: /tmp/test-reports

  deploy-stage:
    docker:
      - image: ubuntu:23.04
    working_directory: /tmp/my-project
    steps:
      - run:
          name: Deploy if tests pass and branch is Staging
          command: ansible-playbook site.yml -i staging

  deploy-prod:
    docker:
      - image: ubuntu:23.04
    working_directory: /tmp/my-project
    steps:
      - run:
          name: Deploy if tests pass and branch is Main
          command: ansible-playbook site.yml -i production

workflows:
  build-deploy:
    jobs:
      - build:
          filters:
            branches:
              ignore:
                - develop
                - /feature-.*/
      - deploy-stage:
          requires:
            - build
          filters:
            branches:
              only: staging
      - deploy-prod:
          requires:
            - build
          filters:
            branches:
              only: main    Suggest an edit to this pageMake a contribution Learn how to contributeStill need help? Ask the CircleCI community Join the research community Visit our Support site DocsTerms of UsePrivacy PolicyCookie PolicySecurity© 2025 Circle Internet Services, Inc., All Rights Reserved.\n\nThe orbs key is supported in version: 2.1 configuration  version: 2.1

orbs:
  node: circleci/node@x.y

jobs:
  install-node-example:
    docker:
      - image: cimg/base:stable
    steps:
      - checkout
      - node/install:
          install-yarn: true
          node-version: '16.13'
      - run: node --version
workflows:
  test_my_app:
    jobs:
      - install-node-example  The commands key is supported in version: 2.1 configuration  commands:
  sayhello:
    description: "A very simple command for demonstration purposes"
    parameters:
      to:
        type: string
        default: "Hello World"
    steps:
      - run: echo << parameters.to >>  The pipeline parameters key is supported in version: 2.1 configuration  The executors key is supported in version: 2.1 configuration  version: 2.1
executors:
  my-executor:
    docker:
      - image: cimg/ruby:3.0.3-browsers

jobs:
  my-job:
    executor: my-executor
    steps:
      - run: echo "Hello executor!"  jobs:
  my-job:
    docker:
      - image: cimg/base:2024.12
    resource_class: xlarge
    steps:
      ... // other config  jobs:
  release-my-service:
    type: release
    plan_name: <my-service-release>  jobs:
  my-no-op-job:
    type: no-op  workflows:
  my-workflow:
    jobs:
      - build
      - test:
          requires:
            - build
      - hold:
          type: approval
          requires:
            - test
      - deploy:
          requires:
            - hold  jobs:
  build:
    docker:
      - image: cimg/base:2024.12
    environment:
      FOO: bar
    parallelism: 3
    resource_class: large
    working_directory: ~/my-app
    steps:
      - run: go list ./... | circleci tests run --command "xargs gotestsum --junitfile junit.xml --format testname --" --split-by=timings --timings-type=name  jobs:
  build:
    docker:
      - image: buildpack-deps:trusty # primary container
        auth:
          username: mydockerhub-user
          password: $DOCKERHUB_PASSWORD  # context / project UI env-var reference
        environment:
          ENV: CI

      - image: mongo:2.6.8
        auth:
          username: mydockerhub-user
          password: $DOCKERHUB_PASSWORD  # context / project UI env-var reference
        command: [--smallfiles]

      - image: postgres:14.2
        auth:
          username: mydockerhub-user
          password: $DOCKERHUB_PASSWORD  # context / project UI env-var reference
        environment:
          POSTGRES_USER: user

      - image: redis@sha256:54057dd7e125ca41afe526a877e8bd35ec2cdd33b9217e022ed37bdcf7d09673
        auth:
          username: mydockerhub-user
          password: $DOCKERHUB_PASSWORD  # context / project UI env-var reference

      - image: acme-private/private-image:321
        auth:
          username: mydockerhub-user
          password: $DOCKERHUB_PASSWORD  # context / project UI env-var reference  jobs:
  job_name:
    docker:
      - image: <your-image-arn>
        aws_auth:
          oidc_role_arn: <your-iam-role-arn>  jobs:
  build:
    docker:
      - image: account-id.dkr.ecr.us-east-1.amazonaws.com/org/repo:0.1
        aws_auth:
          aws_access_key_id: AKIAQWERVA  # can specify string literal values
          aws_secret_access_key: $ECR_AWS_SECRET_ACCESS_KEY  # or project UI envar reference  CircleCI cloud The use of machine: true is deprecated. You must specify an image to use.    jobs:
  build: # name of your job
    machine: # executor type
      image: ubuntu-2004:current # recommended linux image

    steps:
      # Commands run in a Linux virtual machine environment    jobs:
  build: # name of your job
    machine: # executor type
      image: ubuntu-2004:current # recommended linux image

    steps:
      # Commands run in a Linux virtual machine environment    jobs:
  build: # name of your job
    machine: true # executor type
    steps:
      # Commands run in a Linux virtual machine environment    jobs:
  build: # name of your job
    machine: true # executor type
    steps:
      # Commands run in a Linux virtual machine environment  version: 2.1

jobs:
  build:
    machine:
      image: android:2024.11.1  version: 2.1

jobs:
  build:
    machine:
      image: windows-server-2019-cuda:current  jobs:
  build:
    macos:
      xcode: "14.2.0"  Java, Erlang and any other languages that introspect the /proc directory for information about CPU count may require additional configuration to prevent them from slowing down when using the CircleCI resource class feature. Programs with this issue may request 32 CPU cores and run slower than they would when requesting one core. Users of languages with this issue should pin their CPU count to their guaranteed CPU resources.  If you want to confirm how much memory you have been allocated, you can check the cgroup memory hierarchy limit with grep hierarchical_memory_limit /sys/fs/cgroup/memory/memory.stat.  jobs:
  job_name:
    machine: true
    resource_class: <my-namespace>/<my-runner>  jobs:
  build:
    docker:
      - image: cimg/base:2024.12
    resource_class: xlarge
    steps:
      ... // other config  For credit and access information, see the  Resource classes page. Resource class access is dependent on your  Plan.   Arm on Docker For credit and access information see the  Resource classes page. Resource class access is dependent on your  Plan   To find out which CircleCI Docker convenience images support Arm resource classes, you can refer to  Docker hub:     Select the image (for example, cimg/python).   Select the tags tab.   View what is supported under OS/ARCH for the latest tags. For example, cimg/python has linux/amd64 and linux/arm64, which means Arm is supported.       jobs:
  build:
    machine:
      image: ubuntu-2004:2024.01.2 # recommended linux image
    resource_class: large
    steps:
      ... // other config    jobs:
  build:
    machine:
      image: ubuntu-2004:2024.01.2 # recommended linux image
    resource_class: large
    steps:
      ... // other config    jobs:
  build:
    machine: true
    resource_class: large
    steps:
      ... // other config    jobs:
  build:
    machine: true
    resource_class: large
    steps:
      ... // other config   We have deprecated support for all Intel-based macOS resources.   The macos.x86.medium.gen2 resource class was deprecated on June 28, 2024.   See our  announcement for more details.   jobs:
  build:
    macos:
      xcode: "15.4.0"
    resource_class: m2pro.medium
    steps:
      ... // other config  Using server? Check with your systems administrator whether you have access to the Windows execution environment.    version: 2.1

jobs:
  build: # name of your job
    resource_class: 'windows.medium'
    machine:
      image: 'windows-server-2022-gui:current'
      shell: 'powershell.exe -ExecutionPolicy Bypass'
    steps:
      # Commands are run in a Windows virtual machine environment
      - checkout
      - run: Write-Host 'Hello, Windows'    version: 2.1

jobs:
  build: # name of your job
    resource_class: 'windows.medium'
    machine:
      image: 'windows-server-2022-gui:current'
      shell: 'powershell.exe -ExecutionPolicy Bypass'
    steps:
      # Commands are run in a Windows virtual machine environment
      - checkout
      - run: Write-Host 'Hello, Windows'    version: 2.1

jobs:
  build: # name of your job
    machine:
      image: windows-default
    steps:
      # Commands are run in a Windows virtual machine environment
      - checkout
      - run: Write-Host 'Hello, Windows'    version: 2.1

jobs:
  build: # name of your job
    machine:
      image: windows-default
    steps:
      # Commands are run in a Windows virtual machine environment
      - checkout
      - run: Write-Host 'Hello, Windows'  version: 2.1

jobs:
  build:
    machine:
      image: linux-cuda-12:default
    resource_class: gpu.nvidia.medium
    steps:
      - run: nvidia-smi
      - run: docker run --gpus all nvidia/cuda:9.0-base nvidia-smi  version: 2.1
orbs:
  win: circleci/windows@5.0.0

jobs:
  build:
    executor: win/server-2019-cuda
    steps:
      - checkout
      - run: '&"C:\Program Files\NVIDIA Corporation\NVSMI\nvidia-smi.exe"'  Using server? Check with your systems administrator whether you have access to the Arm execution environment.    jobs:
  my-job:
    machine:
      image: ubuntu-2004:2024.01.2
    resource_class: arm.medium
    steps:
      - run: uname -a
      - run: echo "Hello, Arm!"    jobs:
  my-job:
    machine:
      image: ubuntu-2004:2024.01.2
    resource_class: arm.medium
    steps:
      - run: uname -a
      - run: echo "Hello, Arm!"    jobs:
  my-job:
    machine:
      image: arm-default
    resource_class: arm.medium
    steps:
      - run: uname -a
      - run: echo "Hello, Arm!"    jobs:
  my-job:
    machine:
      image: arm-default
    resource_class: arm.medium
    steps:
      - run: uname -a
      - run: echo "Hello, Arm!"  jobs:
  build:
    working_directory: ~/canary-python
    environment:
      FOO: bar
    steps:
      - run:
          name: Running tests
          command: make test  jobs:
  build:
    steps:
      - run: make test  jobs:
  build:
    steps:
      - checkout  the run step replaces the deprecated deploy step. If your job has a parallelism of 1, the deprecated deploy step can be swapped out directly for the run step. If your job has parallelism > 1, see  Migrate from deploy to run.  - run:
    command: |
      echo Running test
      mkdir -p /tmp/test-results
      make test  - run:
    command: |
      echo Running test
      set +e
      mkdir -p /tmp/test-results
      make test

- run:
    shell: /bin/sh
    command: |
      echo Running test
      mkdir -p /tmp/test-results
      make test  - run: make test | tee test-output.log  If make test fails the rest of pipeline will be executed.  - run:
    name: Running X virtual framebuffer
    command: Xvfb :99 -screen 0 1280x1024x24
    background: true

- run: make test  - run: make test

# shorthanded command can also have multiple lines
- run: |
    mkdir -p /tmp/test-results
    make test  Some steps, such as store_artifacts and store_test_results will always run, even if a step has failed (returned a non-zero exit code) previously. The when attribute, store_artifacts and store_test_results are not run if the job has been killed by a cancel request or has reached the runtime timeout limit.  - run:
    name: Upload CodeCov.io Data
    command: bash <(curl -s https://codecov.io/bash) -F unittests
    when: always # Uploads code coverage results, pass or fail  - run: |
    if [ "$CIRCLE_BRANCH" = "develop" ]; then
        circleci-agent step halt
    fi  The when and unless steps are supported in version: 2.1 configuration  version: 2.1

jobs: # conditional steps may also be defined in `commands:`
  job_with_optional_custom_checkout:
    parameters:
      custom_checkout:
        type: string
        default: ""
    machine:
      image: ubuntu-2004:2024.11.1
    steps:
      - when:
          condition: <<parameters.custom_checkout>>
          steps:
            - run: echo "my custom checkout"
      - unless:
          condition: <<parameters.custom_checkout>>
          steps:
            - checkout
workflows:
  build-test-deploy:
    jobs:
      - job_with_optional_custom_checkout:
          custom_checkout: "any non-empty string is truthy"
      - job_with_optional_custom_checkout   Blobless clones   A "blobless" strategy is being rolled out to help improve the performance of code checkouts from Git source code hosts.   Blobless clones reduce the amount of data fetched from the remote, by asking the remote to filter out objects that are not attached to the current commit.   While this improves performance in most cases, if a downstream step requires those objects to exist for scanning or comparisons, it can cause failures. To work around these potential problems, a fetch directly after a checkout will ensure the required data is available:    - checkout
- run: git fetch    - checkout
- run: git fetch  - checkout  - checkout
- run: git submodule sync
- run: git submodule update --init  The checkout step will configure Git to skip automatic garbage collection. If you are caching your .git directory with  restore_cache and would like to use garbage collection to reduce its size, you may wish to use a  run step with command git gc before doing so.  jobs:
  build:
    docker:
      - image: cimg/base:2024.06
    steps:
      # ... steps for building/testing app ...
      - setup_remote_docker:
          version: default     setup_remote_docker is not compatible with the machine executor. See  Docker Layer Caching in Machine Executor for information on how to enable DLC with the machine executor.   The version key is not currently supported on CircleCI server. Contact your system administrator for information about the Docker version installed in your remote Docker environment. If you are on server 4.x, you can find the default AWS AMI  here.     If the cache for the given key already exists it will not be modified, and job execution will proceed to the next step.  Given the immutability of caches, it might be helpful to start all your cache keys with a version prefix v1-.... That way you will be able to regenerate all your caches just by incrementing the version in this prefix.  - save_cache:
    key: v1-myapp-{{ arch }}-{{ checksum "project.clj" }}
    paths:
      - /home/ubuntu/.m2  - save_cache:
    key: v1-{{ checksum "yarn.lock" }}
    paths:
      - node_modules/workspace-a
      - node_modules/workspace-c     Wildcards are not currently supported in save_cache paths. Visit the  Ideas board and vote for this feature if it would be useful for you or your organization.   In some instances, a workaround for this is to save a particular workspace to cache:     When there are multiple matches, the most recent match will be used, even if there is a more precise match.  steps:
  - save_cache:
      key: v1-myapp-cache
      paths:
        - ~/d1

  - save_cache:
      key: v1-myapp-cache-new
      paths:
        - ~/d2

  - run: rm -f ~/d1 ~/d2

  - restore_cache:
      key: v1-myapp-cache  - restore_cache:
    keys:
      - v1-myapp-{{ arch }}-{{ checksum "project.clj" }}
      # if cache for exact version of `project.clj` is not present then load any most recent one
      - v1-myapp-

# ... Steps building and testing your application ...

# cache will be saved only once for each version of `project.clj`
- save_cache:
    key: v1-myapp-{{ arch }}-{{ checksum "project.clj" }}
    paths:
      - /foo  - run:
    name: Build the Jekyll site
    command: bundle exec jekyll build --source jekyll --destination jekyll/_site/docs/
- store_artifacts:
    path: jekyll/_site/docs/
    destination: circleci-docs  test-results
├── jest
│   └── results.xml
├── mocha
│   └── results.xml
└── rspec
    └── results.xml  - store_test_results:
    path: test-results  - persist_to_workspace:
    root: /tmp/dir
    paths:
      - foo/bar
      - baz  /tmp/dir/foo/bar
/tmp/dir/baz  - persist_to_workspace:
    root: /tmp/workspace
    paths:
      - target/application.jar
      - build/*  pattern:
        { term }
term:
        '*' matches any sequence of non-Separator characters
        '?' matches any single non-Separator character
        '[' [ '^' ] { character-range }
        ']' character class (must be non-empty)
        c matches character c (c != '*', '?', '\\', '[')
        '\\' c matches character c
character-range:
        c matches character c (c != '\\', '-', ']')
        '\\' c matches character c
        lo '-' hi matches character c for lo <= c <= hi  Everything must be relative to the work space root directory.  - attach_workspace:
    at: /tmp/workspace  The lifetime of artifacts, workspaces, and caches can be customized on the  CircleCI web app by navigating to Plan  Usage Controls. Here you can control the storage retention periods for these objects. If no storage period is set, the default storage retention period of artifacts is 30 days, while the default storage retention period of workspaces and caches is 15 days.  Using server? only MD5 fingerprints are supported. In CircleCI in Project Settings  SSH keys  Additional SSH keys the MD5 fingerprint will be visible. SHA256 support is planned for an upcoming server release.  steps:
  - add_ssh_keys:
      fingerprints:
        - "b7:35:a6:4e:9b:0d:6d:d4:78:1e:9a:97:2a:66:6b:be"
        - "SHA256:NPj4IcXxqQEKGXOghi/QbG2sohoNfvZ30JwCcdSSNM0"  Even though CircleCI uses ssh-agent to sign all added SSH keys, you must use the add_ssh_keys key to actually add keys to a container.  version: 2.1
jobs:
  build:
    docker:
      - image: cimg/node:20.18.1
    environment:
      IMAGETAG: latest
    working_directory: ~/main
    steps:
      - run: echo "This is pipeline ID << pipeline.id >>"  A paid account on a  Performance or Scale Plan is required to access IP ranges.  version: 2.1

jobs:
  build:
    circleci_ip_ranges: true # opts the job into the IP ranges feature
    docker:
      - image: curlimages/curl
    steps:
      - run: echo “Hello World”
workflows:
  build-workflow:
    jobs:
      - build  The workflows version key is not required for version: 2.1 configuration  workflows:
   nightly:
     triggers:
       - schedule:
           cron: "0 0 * * *"
           filters:
             branches:
               only:
                 - main
                 - beta
     jobs:
       - test  Scheduled workflows are not available for projects integrated through the GitHub App, GitLab or Bitbucket Data Center.  The scheduled workflows feature is set to be deprecated. Using scheduled pipelines rather than scheduled workflows offers several benefits. Visit the scheduled pipelines  migration guide to find out how to migrate existing scheduled workflows to scheduled pipelines. If you would like to set up scheduled pipelines from scratch, visit the  Scheduled pipelines page.  workflows:
   nightly:
     triggers:
       - schedule:
           cron: "0 0 * * *"
           filters:
             branches:
               only:
                 - main
                 - beta
     jobs:
       - test  workflows:
   nightly:
     triggers:
       - schedule:
           cron: "0 0 * * *"
           filters:
             branches:
               only:
                 - main
                 - beta
     jobs:
       - test  workflows:
   nightly:
     triggers:
       - schedule:
           cron: "0 0 * * *"
           filters:
             branches:
               only:
                 - main
                 - beta
     jobs:
       - test  workflows:
  commit:
    jobs:
      - test
      - deploy
  nightly:
    triggers:
      - schedule:
          cron: "0 0 * * *"
          filters:
            branches:
              only:
                - main
                - /^release\/.*/
    jobs:
      - coverage  Using when or unless under workflows is supported in version: 2.1 configuration. Workflows are always run unless there is a when or unless filter that prevents the workflow from being run. If you want a workflow to run in every pipeline, do not add a when or unless filter.  version: 2.1

workflows:
  integration_tests:
    when: pipeline.git.branch == "main"
    jobs:
      - mytestjob

jobs:
...   Pipeline order protection in serial groups   Jobs in a serial group follow an order protection mechanism, as follows:     Jobs start in the order they join the queue, but are accepted based on pipeline number.   If a group is waiting/running and another job in the same project attempts to join the queue with a lower pipeline number, the job is skipped.   This immediate skip process exists to maintain order integrity, which is a safety process to avoid unexpected work in a build, for example, a deployment job running a previous version unexpectedly.     If there are no serial groups waiting/running, a pipeline with a lower number can start, such as restoring back to a previous pipeline via a rerun workflow.   # Creating multiple pipelines at the same time with the below config will results in
# all pipelines running test and build but only a single pipeline will run deploy at a time.

workflows:
  main-workflow:
    jobs:
      - test
      - build
      - deploy:
          serial-group: << pipeline.project.slug >>/deploy-group
          requires:
            - test
            - build  A list of jobs that must succeed or attain a specified status for the job to start. Note: When jobs in the current workflow that are listed as dependencies are not executed (due to a filter function for example), their requirement as a dependency for other jobs will be ignored by the requires option. However, if all dependencies of a job are filtered, then that job will not be executed either.   Possible types of requires items:     Job name (a required job that must succeed for the job to start)   Map of job name to status (a required job that must attain the specified status for the job to start)   Map of job name to a list of statuses (a required job that must attain one of the specified status for the job to start)     The possible status values are: success, failed and canceled.  workflows:
  my-workflow:
    jobs:
      - build
      - test:
          requires:
            - build
      - deploy:
          requires:
            - build
            - test
      - notify-build-canceled:
          requires:
            - build: canceled
      - cleanup:
          requires:
            - deploy:
              - failed
              - canceled  workflows:
  my-workflow:
    jobs:
      - build
      - test:
          requires:
            - build
      - hold:
          type: approval
          requires:
            - test
      - deploy:
          requires:
            - hold  Workflows will ignore job-level branching. If you use job-level branching and later add workflows, you must remove the branching at the job level and instead declare it in the workflows section of your config.yml.  # ...
workflows:
  build-deploy:
    jobs:
      - js_build
      - build_server_pdfs: # << the job to conditionally run based on the filter-by-branch-name.
          filters:
            branches:
              only: /server\/.*/ # the job build_server_pdfs will only run when the branch being built starts with server/  workflows:
  deploy:
    jobs:
      - init-service
      - test-service
      - build-service-image:
          requires:
            - init-service
      - dry-run-service:
          requires:
            - init-service
          filters: pipeline.git.branch != "main" and pipeline.git.branch != "canary"
      - publish-service:
          requires:
            - build-service-image
            - test-service
          filters: pipeline.git.branch == "main" or pipeline.git.tag starts-with "release"
      - deploy-service:
          context:
            - org-global
          requires:
            - publish-service
          filters: pipeline.git.branch == "main" and pipeline.parameters.my-custom-param starts-with "DEPLOY:"  filters: pipeline.git.branch == "main"  filters: pipeline.git.branch == "main" or pipeline.git.branch starts-with "integration-test"  filters: pipeline.git.branch == "main" and not (pipeline.trigger_source starts-with "api")  version: 2.1

parameters:
  run-storybook-tests:
    type: boolean
    default: false

...
# jobs configuration ommitted for brevity

workflows:
  build:
    jobs:
      - setup
      - storybook-tests:
          requires:
            - setup
          filters: |
            pipeline.parameters.run-storybook-tests
            or pipeline.git.branch == "dry-run-deploy"
            or pipeline.git.branch starts-with "deploy"  Using server? If you are using CircleCI server, replace https://circleci.com with your server hostname when interacting with the CircleCI API.  curl -X POST https://circleci.com/api/v2/project/circleci/<org-id>/<project-id>/pipeline/run \
  --header "Circle-Token: $CIRCLE_TOKEN" \
  --header "content-type: application/json" \
  --data {
  "definition_id": "<pipeline-definition-id>",
  "config": {"branch": "<your-branch-name>"},
  "checkout": {"branch": "<your-branch-name>"},
  "parameters": {"run-storybook-tests": "true"}
  }  Boolean negation.   Note that not has very high precedence and so binds very tightly. Use sub-expressions to apply not to more complex expressions. For example, with foo being true and bar being false:     not foo and bar evaluates to false   not (foo and bar) evaluates to true    workflows:
  dev_stage_pre-prod:
    jobs:
      - test_dev:
          filters:  # using regex filters requires the entire branch to match
            branches:
              only:  # only branches matching the below regex filters will run
                - dev
                - /user-.*/
      - test_stage:
          filters:
            branches:
              only: stage
      - test_pre-prod:
          filters:
            branches:
              only: /pre-prod(?:-.+)?$/  workflows:
  untagged-build:
    jobs:
      - build
  tagged-build:
    jobs:
      - build:
          filters:
            tags:
              only: /^v.*/  The matrix key is supported in version: 2.1 configuration  workflows:
  workflow:
    jobs:
      - build:
          matrix:
            parameters:
              version: ["0.1", "0.2", "0.3"]
              platform: ["macos", "windows", "linux"]  workflows:
  workflow:
    jobs:
      - build:
          name: build-macos-0.1
          version: "0.1"
          platform: macos
      - build:
          name: build-macos-0.2
          version: "0.2"
          platform: macos
      - build:
          name: build-macos-0.3
          version: "0.3"
          platform: macos
      - build:
          name: build-windows-0.1
          version: "0.1"
          platform: windows
      - ...  workflows:
  workflow:
    jobs:
      - build:
          matrix:
            parameters:
              a: [1, 2, 3]
              b: [4, 5, 6]
            exclude:
              - a: 3
                b: 5  workflows:
  workflow:
    jobs:
      - deploy:
          matrix:
            parameters:
              version: ["0.1", "0.2"]
      - another-job:
          requires:
            - deploy  workflows:
  workflow:
    jobs:
      - build:
          name: build-v<< matrix.version >>
          matrix:
            parameters:
              version: ["0.1", "0.2"]
      - deploy:
          name: deploy-v<< matrix.version >>
          matrix:
            parameters:
              version: ["0.1", "0.2"]
          requires:
            - build-v<< matrix.version >>  workflows:
  workflow:
    jobs:
      - build:
          name: build-v0.1
          version: "0.1"
      - build:
          name: build-v0.2
          version: "0.2"
      - deploy:
          name: deploy-v0.1
          version: "0.1"
          requires:
            - build-v0.1
      - deploy:
          name: deploy-v0.2
          version: "0.2"
          requires:
            - build-v0.2  Pre-steps and post-steps are supported in version: 2.1 configuration  version: 2.1

jobs:
  bar:
    machine:
      image: ubuntu-2004:2024.05.1
    steps:
      - checkout
      - run:
          command: echo "building"
      - run:
          command: echo "testing"

workflows:
  build:
    jobs:
      - bar:
          pre-steps: # steps to run before steps defined in the job bar
            - run:
                command: echo "install custom dependency"
          post-steps: # steps to run after steps defined in the job bar
            - run:
                command: echo "upload artifact to s3"  When using logic statements at the workflow level, do not include the condition: key (the condition key is only needed for job level logic statements).  workflows:
  my-workflow:
    when:
      or:
        - equal: [ main, << pipeline.git.branch >> ]
        - equal: [ staging, << pipeline.git.branch >> ]  Using Docker? Authenticating Docker pulls from image registries is recommended when using the Docker execution environment. Authenticated pulls allow access to private Docker images, and may also grant higher rate limits, depending on your registry provider. For further information see  Using Docker authenticated pulls.  version: 2.1
jobs:
  build:
    docker:
      - image: ubuntu:23.04

      - image: mongo:6.0.14
        command: [mongod, --smallfiles]

      - image: postgres:14.12
        # some containers require setting environment variables
        environment:
          POSTGRES_USER: user

      - image: redis@sha256:54057dd7e125ca41afe526a877e8bd35ec2cdd33b9217e022ed37bdcf7d09673

      - image: rabbitmq:3.12.12

    environment:
      TEST_REPORTS: /tmp/test-reports

    working_directory: ~/my-project

    steps:
      - checkout

      - run:
          command: echo 127.0.0.1 devhost | sudo tee -a /etc/hosts

      # Create Postgres users and database
      # Note the YAML heredoc '|' for nicer formatting
      - run: |
          sudo -u root createuser -h localhost --superuser ubuntu &&
          sudo createdb -h localhost test_db

      - restore_cache:
          keys:
            - v1-my-project-{{ checksum "project.clj" }}
            - v1-my-project-

      - run:
          environment:
            SSH_TARGET: "localhost"
            TEST_ENV: "linux"
          command: |
            set -xu
            mkdir -p ${TEST_REPORTS}
            run-tests.sh
            cp out/tests/*.xml ${TEST_REPORTS}

      - run: |
          set -xu
          mkdir -p /tmp/artifacts
          create_jars.sh << pipeline.number >>
          cp *.jar /tmp/artifacts

      - save_cache:
          key: v1-my-project-{{ checksum "project.clj" }}
          paths:
            - ~/.m2

      # Save artifacts
      - store_artifacts:
          path: /tmp/artifacts
          destination: build

      # Upload test results
      - store_test_results:
          path: /tmp/test-reports

  deploy-stage:
    docker:
      - image: ubuntu:23.04
    working_directory: /tmp/my-project
    steps:
      - run:
          name: Deploy if tests pass and branch is Staging
          command: ansible-playbook site.yml -i staging

  deploy-prod:
    docker:
      - image: ubuntu:23.04
    working_directory: /tmp/my-project
    steps:
      - run:
          name: Deploy if tests pass and branch is Main
          command: ansible-playbook site.yml -i production

workflows:
  build-deploy:
    jobs:
      - build:
          filters:
            branches:
              ignore:
                - develop
                - /feature-.*/
      - deploy-stage:
          requires:
            - build
          filters:
            branches:
              only: staging
      - deploy-prod:
          requires:
            - build
          filters:
            branches:
              only: main\n\n\n\nOrbs overview1 month ago3 min readCloudServer v4+On This PageIntroductionQuickstartUse an orbNode exampleBenefits of using orbsThe orb registryOrb designationsPublic or privateOrbs page in the CircleCI appSee also   Use orbs to:     Simplify configuration (.circleci/_config.yml)   Automate repeated processes   Accelerate project setup   Simplify integration with third-party tools       Introduction   Orbs are reusable packages of parameterizable configuration that can be used in any project. They are made up of reusable configuration elements, for example,  jobs,  commands, and  executors. Orbs are available for many languages, platforms, services, and tools. Visit the  Orbs Registry to search for orbs to help simplify your configuration.   If you would like to author your own orb, read more on the  Introduction to Authoring Orbs page.     Quickstart     Follow our  Node.js project quickstart guide.   Follow our  Python project quickstart guide.   Set up notifications using the  Slack orb.       Use an orb   An orb is identified by its slug which contains the namespace, and orb name. A namespace is a unique identifier referring to the organization authoring a set of orbs. The orb name will be followed by an @ symbol and a  semantic version string, identifying which version of the orb is being used. For example: <namespace>/<orb-name>@1.2.3.   Each orb within the  registry provides a  quickstart guide, which contains a sample code snippet for importing that specific orb, with its most recent version, into your .circleci/config.yml.   The example below shows how to import any orb into your CircleCI configuration file. Use the tabs to switch between a generic layout for importing any orb, and a specific example of importing the Node.JS orb:  NodeGeneric    version: 2.1

orbs:
  node: circleci/node@5.0.3        version: 2.1

orbs:
  <orb-name>: <namespace>/<orb-name>@x.y.z       After the orb has been imported into the configuration file, the elements provided by the orb are available as <orb-name>/<element>. Orb elements can include jobs, commands, and executors. The parameters available for each element are listed in the orb registry in a table under each element.   Most orbs will also include usage examples detailing common functionality, to further simplify the process of incorporating them into your projects. If you would like to contribute to an existing orb, or file an issue on the orb’s repository, many orb authors will include the git repository link.   Orb elements can be used in the same way as  reusable configuration elements. The Node example below shows how to use an orb’s default executor, and an orb command.   Node example  The Node orb provides a command,  install-packages, to install your node packages, automatically enable caching, and provide additional options through the use of parameters. To use the install-packages command, reference it in a job’s  steps.    version: 2.1

orbs:
  node: circleci/node@x.y # replace orb version

jobs:
  test:
    executor: node/default # use the default executor specified by the orb
    steps:
      - checkout
      - node/install-packages # Use a command from the orb in a job's steps       Benefits of using orbs   Orbs provide parameterizable configuration elements that can greatly simplify your configuration. To illustrate this, the following example shows a typical configuration for testing a Node.js application using the Node.JS orb (using the test job provided by the  circleci/node orb), compared to the configuration required without using the orb (defining a job with the required steps for testing the application).   Orbs let you pull in pre-defined, parameterized configuration elements into your project configuration. Taking it a step further, authoring your own orb lets you define parameterized configuration elements once and utilize them across multiple similar projects.  With OrbsWithout orbs    version: 2.1

orbs:
  node: circleci/node@x.y # replace orb version https://circleci.com/developer/orbs/orb/circleci/node#quick-start

workflows:
  test_my_app:
    jobs:
      - node/test:
          version: <node-version> # replace node version        version: 2.1

jobs:
  test:
    docker:
      - image: cimg/node:<node-version>
    steps:
      - checkout
      - restore_cache:
          keys:
            - node-deps-v1-{{ .Branch }}-{{checksum "package-lock.json"}}
      - run:
          name: install packages
          command: npm ci
      - save_cache:
          key: node-deps-v1-{{ .Branch }}-{{checksum "package-lock.json"}}
          paths:
            - ~/.npm
      - run:
          name: Run Tests
          command: npm run test

workflows:
  test_my_app:
    jobs:
      - test         The orb registry   The  Orb Registry is an open repository of all published orbs. Find the orb for your stack or consider developing and  publishing your own orb.        Orb designations     In order to use uncertified orbs (partner or community), your organization’s administrator must opt-in to allow uncertified orb usage on the Organization Settings  Security page for your org.        Orbs in the registry will appear with one of three different namespace designations:  DesignationDescriptionCertifiedWritten and tested by the CircleCI teamPartnerWritten by our technology partnersCommunityWritten by the community   Public or private  Orbs can be published in one of two ways:     Public: Searchable in the orb registry, and available for anyone to use   Private: Only available to use within your organization, and only findable in the registry with a direct URL and when authenticated     To understand these concepts further, read the  Public Orbs vs Private Orbs section of the Orb Concepts page.      Orbs page in the CircleCI app      The orbs page in the CircleCI web app is not currently available on CircleCI server.           Private orb details pages may only be viewed by logged-in members of your organization. Unpublished orbs will not have linked details pages.        To access the orbs page in the web app, navigate to Organization Settings and select Orbs from the sidebar.   The orbs page lists orbs created within your organization. You can view:     Orb type (public or private)   Orb usage (how many times the orb is used across all configurations)   Latest version   Description     Full orb details, including orb source, are accessible by clicking on the orb name. The orb details page is similar to the CircleCI orb registry in that the details page provides the orb’s contents, commands, and usage examples.     See also     Refer to  Orbs Concepts for high-level information about CircleCI orbs.   Refer to  Orbs FAQ for information on known issues and questions that have been addressed when using CircleCI orbs.   Refer to  Reusable Configuration Reference for examples of reusable orbs, commands, parameters, and executors.   Refer to  Orb Testing Methodologies for information on how to test orbs you have created.     Suggest an edit to this pageMake a contribution Learn how to contributeStill need help? Ask the CircleCI community Join the research community Visit our Support site\n\nOrbs overview1 month ago3 min readCloudServer v4+On This PageIntroductionQuickstartUse an orbNode exampleBenefits of using orbsThe orb registryOrb designationsPublic or privateOrbs page in the CircleCI appSee also   Use orbs to:     Simplify configuration (.circleci/_config.yml)   Automate repeated processes   Accelerate project setup   Simplify integration with third-party tools       Introduction   Orbs are reusable packages of parameterizable configuration that can be used in any project. They are made up of reusable configuration elements, for example,  jobs,  commands, and  executors. Orbs are available for many languages, platforms, services, and tools. Visit the  Orbs Registry to search for orbs to help simplify your configuration.   If you would like to author your own orb, read more on the  Introduction to Authoring Orbs page.     Quickstart     Follow our  Node.js project quickstart guide.   Follow our  Python project quickstart guide.   Set up notifications using the  Slack orb.       Use an orb   An orb is identified by its slug which contains the namespace, and orb name. A namespace is a unique identifier referring to the organization authoring a set of orbs. The orb name will be followed by an @ symbol and a  semantic version string, identifying which version of the orb is being used. For example: <namespace>/<orb-name>@1.2.3.   Each orb within the  registry provides a  quickstart guide, which contains a sample code snippet for importing that specific orb, with its most recent version, into your .circleci/config.yml.   The example below shows how to import any orb into your CircleCI configuration file. Use the tabs to switch between a generic layout for importing any orb, and a specific example of importing the Node.JS orb:  NodeGeneric    version: 2.1

orbs:
  node: circleci/node@5.0.3        version: 2.1

orbs:
  <orb-name>: <namespace>/<orb-name>@x.y.z       After the orb has been imported into the configuration file, the elements provided by the orb are available as <orb-name>/<element>. Orb elements can include jobs, commands, and executors. The parameters available for each element are listed in the orb registry in a table under each element.   Most orbs will also include usage examples detailing common functionality, to further simplify the process of incorporating them into your projects. If you would like to contribute to an existing orb, or file an issue on the orb’s repository, many orb authors will include the git repository link.   Orb elements can be used in the same way as  reusable configuration elements. The Node example below shows how to use an orb’s default executor, and an orb command.   Node example  The Node orb provides a command,  install-packages, to install your node packages, automatically enable caching, and provide additional options through the use of parameters. To use the install-packages command, reference it in a job’s  steps.    version: 2.1

orbs:
  node: circleci/node@x.y # replace orb version

jobs:
  test:
    executor: node/default # use the default executor specified by the orb
    steps:
      - checkout
      - node/install-packages # Use a command from the orb in a job's steps       Benefits of using orbs   Orbs provide parameterizable configuration elements that can greatly simplify your configuration. To illustrate this, the following example shows a typical configuration for testing a Node.js application using the Node.JS orb (using the test job provided by the  circleci/node orb), compared to the configuration required without using the orb (defining a job with the required steps for testing the application).   Orbs let you pull in pre-defined, parameterized configuration elements into your project configuration. Taking it a step further, authoring your own orb lets you define parameterized configuration elements once and utilize them across multiple similar projects.  With OrbsWithout orbs    version: 2.1

orbs:
  node: circleci/node@x.y # replace orb version https://circleci.com/developer/orbs/orb/circleci/node#quick-start

workflows:
  test_my_app:
    jobs:
      - node/test:
          version: <node-version> # replace node version        version: 2.1

jobs:
  test:
    docker:
      - image: cimg/node:<node-version>
    steps:
      - checkout
      - restore_cache:
          keys:
            - node-deps-v1-{{ .Branch }}-{{checksum "package-lock.json"}}
      - run:
          name: install packages
          command: npm ci
      - save_cache:
          key: node-deps-v1-{{ .Branch }}-{{checksum "package-lock.json"}}
          paths:
            - ~/.npm
      - run:
          name: Run Tests
          command: npm run test

workflows:
  test_my_app:
    jobs:
      - test         The orb registry   The  Orb Registry is an open repository of all published orbs. Find the orb for your stack or consider developing and  publishing your own orb.        Orb designations     In order to use uncertified orbs (partner or community), your organization’s administrator must opt-in to allow uncertified orb usage on the Organization Settings  Security page for your org.        Orbs in the registry will appear with one of three different namespace designations:  DesignationDescriptionCertifiedWritten and tested by the CircleCI teamPartnerWritten by our technology partnersCommunityWritten by the community   Public or private  Orbs can be published in one of two ways:     Public: Searchable in the orb registry, and available for anyone to use   Private: Only available to use within your organization, and only findable in the registry with a direct URL and when authenticated     To understand these concepts further, read the  Public Orbs vs Private Orbs section of the Orb Concepts page.      Orbs page in the CircleCI app      The orbs page in the CircleCI web app is not currently available on CircleCI server.           Private orb details pages may only be viewed by logged-in members of your organization. Unpublished orbs will not have linked details pages.        To access the orbs page in the web app, navigate to Organization Settings and select Orbs from the sidebar.   The orbs page lists orbs created within your organization. You can view:     Orb type (public or private)   Orb usage (how many times the orb is used across all configurations)   Latest version   Description     Full orb details, including orb source, are accessible by clicking on the orb name. The orb details page is similar to the CircleCI orb registry in that the details page provides the orb’s contents, commands, and usage examples.     See also     Refer to  Orbs Concepts for high-level information about CircleCI orbs.   Refer to  Orbs FAQ for information on known issues and questions that have been addressed when using CircleCI orbs.   Refer to  Reusable Configuration Reference for examples of reusable orbs, commands, parameters, and executors.   Refer to  Orb Testing Methodologies for information on how to test orbs you have created.     Suggest an edit to this pageMake a contribution Learn how to contributeStill need help? Ask the CircleCI community Join the research community Visit our Support site DocsTerms of UsePrivacy PolicyCookie PolicySecurity© 2025 Circle Internet Services, Inc., All Rights Reserved.\n\nversion: 2.1

orbs:
  node: circleci/node@5.0.3    version: 2.1

orbs:
  node: circleci/node@5.0.3    version: 2.1

orbs:
  <orb-name>: <namespace>/<orb-name>@x.y.z    version: 2.1

orbs:
  <orb-name>: <namespace>/<orb-name>@x.y.z  version: 2.1

orbs:
  node: circleci/node@x.y # replace orb version

jobs:
  test:
    executor: node/default # use the default executor specified by the orb
    steps:
      - checkout
      - node/install-packages # Use a command from the orb in a job's steps    version: 2.1

orbs:
  node: circleci/node@x.y # replace orb version https://circleci.com/developer/orbs/orb/circleci/node#quick-start

workflows:
  test_my_app:
    jobs:
      - node/test:
          version: <node-version> # replace node version    version: 2.1

orbs:
  node: circleci/node@x.y # replace orb version https://circleci.com/developer/orbs/orb/circleci/node#quick-start

workflows:
  test_my_app:
    jobs:
      - node/test:
          version: <node-version> # replace node version    version: 2.1

jobs:
  test:
    docker:
      - image: cimg/node:<node-version>
    steps:
      - checkout
      - restore_cache:
          keys:
            - node-deps-v1-{{ .Branch }}-{{checksum "package-lock.json"}}
      - run:
          name: install packages
          command: npm ci
      - save_cache:
          key: node-deps-v1-{{ .Branch }}-{{checksum "package-lock.json"}}
          paths:
            - ~/.npm
      - run:
          name: Run Tests
          command: npm run test

workflows:
  test_my_app:
    jobs:
      - test    version: 2.1

jobs:
  test:
    docker:
      - image: cimg/node:<node-version>
    steps:
      - checkout
      - restore_cache:
          keys:
            - node-deps-v1-{{ .Branch }}-{{checksum "package-lock.json"}}
      - run:
          name: install packages
          command: npm ci
      - save_cache:
          key: node-deps-v1-{{ .Branch }}-{{checksum "package-lock.json"}}
          paths:
            - ~/.npm
      - run:
          name: Run Tests
          command: npm run test

workflows:
  test_my_app:
    jobs:
      - test    In order to use uncertified orbs (partner or community), your organization’s administrator must opt-in to allow uncertified orb usage on the Organization Settings  Security page for your org.  The orbs page in the CircleCI web app is not currently available on CircleCI server.  Private orb details pages may only be viewed by logged-in members of your organization. Unpublished orbs will not have linked details pages.\n\n\n\n|   Marketplace
            
            
                
                    
                        
                            
                                Sign in\n|   Marketplace
            
            
                
                    
                        
                            
                                Sign in\nVisual Studio Code>Language Packs>CircleCINew to Visual Studio Code? Get it now.CircleCICircleCIcircleci.com |  85,877 installs |  (19) | FreeThe official CircleCI extension to create and manage your CI/CD pipelinesInstallationLaunch VS Code Quick Open (Ctrl+P), paste the following command, and press enter.CopyCopied to clipboardMore InfoOverviewVersion HistoryQ & ARating & ReviewThe official CircleCI VS Code extension is a new way to interact with CircleCI.
This extension provides an interface to visualize and manage CircleCI pipelines
directly from your IDE, as well as providing contextual help when creating,
modifying and editing CircleCI YAML config files. This way, it avoids expensive
context-switching between VS Code and your browser.
More practically, this extension allows you to:

Authenticate and connect VS Code to CircleCI
Browse and interact with your pipelines. Available actions include

Viewing pipelines, workflows, and jobs statuses
Viewing test outputs
Browsing job logs
Downloading artifacts
Approving jobs
Re-running builds
Debugging jobs with SSH


Be alerted through notifications when your workflows change status or need
your attention
Access in-file support when editing CircleCI YAML configuration files,
including:

Syntax validation
Syntax highlighting
Go-to-definition and go-to-reference
On-hover documentation and usage hints
Autocompletion


Launch commands to validate config files statically, or against your org
policy


    

Getting started
It’s easy to get started with CircleCI for VS Code.

Install the extension
You can install the CircleCI extension from within VS Code, or download it
from the marketplace.
⚠️ This extension is compatible with VS Code versions 1.85 or above.

Authenticate into CircleCI
Open the CircleCI Panel by clicking on the CircleCI icon on the activity bar
on the left of your screen, then click on “Log in”.
   
    

You will be prompted to enter a
Personal API Token. If you
don't have one, you can generate a new one for this purpose.
If you are an Enterprise customer, make sure to check the box and enter your
self-hosted server URL.

Setup your project
If your VS Code workspace contains one or more CircleCI projects, the
extension will detect them automatically, and the Pipelines Panel will be
populated with your most recent pipelines.
If no project is detected, open the settings page (through the VS Code
command CircleCI: Open Settings, or by clicking on the settings icon (⚙️)
at the top of the Pipelines Panel), and select your projects manually.
Please note that your manual selection will only be persisted if no projects
are detected automatically.
   ⚠️ Automatic project detection does not work for GitLab projects. Please select your project manually from the Settings page.





Configure your Pipelines Panel
By default, your Pipelines Panel will display all the latest pipelines run on
your project. However, you can configure it to show you only the pipelines
you are interested in.
All configurations are available in the Settings page, which you can open
with the command CircleCI: Open Settings or by clicking on the settings
icon (⚙️) at the top of the Pipelines Panel.
Specifically, you can choose to follow:

Only your pipelines, or those authored by anyone
All branches, only your current branch, or a specific branch. You can also
select the checkbox “Always display default branch”
Only pipelines that include workflows and jobs with specific statuses.


    


Configure notifications
You can set up pop-up notifications to warn you when a workflow in your
Pipelines Panel has changed status.
 
   
 
By default, you will receive a pop-up notification every time one of the
workflows in your Pipelines Panel enters a failing status, or needs your
approval.
If you wish to alter these defaults, you can:

Mute notifications (a toggle button to change this setting is also
available at the top of the Pipelines Panel)



Configure which workflow status changes you want to be notified about

Please note that you can only be notified about workflows that appear in your
Pipelines Panel.
 
     
 


The Pipelines Panel
The Pipelines Panel lists all CircleCI projects detected in your workspace. For
each project, it shows the most recent pipelines, jobs and workflows, and lets
you monitor their status and interact with them.

    

For some tree objects, you can perform actions by clicking on the icons which
appear when you hover over the item.
Project
Projects are the top level tree items, and they contain your pipelines.

If you don't follow a project, you can also use the panel to follow it.
Pipeline
Pipelines
are nested under projects. They are the CircleCI unit of change, and they
contain your workflows.

Workflow
Workflows
are nested under each Pipeline, and contain Jobs. Hovering over a Workflow lets
you:

Open in browser, to view workflow details in the CircleCI app, on your default
web browser
Rerun workflow from start, to re-triggered the entire workflow
Rerun workflow from failed, to re-triggered the workflow starting from the
first failed job

Job
Jobs
are nested under each Workflow, and can contain Tests and Artifacts. Hovering
over a Job lets you:

Approve the job (only if the job is on hold)
Cancel the job (only if the job is running)
Rerun the job with SSH (you can read more about this functionality in a later
section)
View job details


    

By expanding a Job, you can also:

Load tests, if you have configured your tests to upload test results to
CircleCI. Tests that CircleCI has detected as flaky will be prefaced by the
indication [FLAKY].
Load artifacts, to load any artifacts created by the Job. Once the
artifacts are loaded, you can download them by clicking on them.

Re-run with SSH
You can re-run jobs with SSH directly from VS Code, either:

through the Job Details page, by clicking on the green button on the top
right:



or by clicking on the action icon next to the job name in the Pipelines Panel.


    

In both cases, you will be presented with two options:

Open SSH session in terminal


    


Open SSH session in remote VS Code window

This feature requires the official VS Code extension
Remote - SSH.
You can find more information on Remote Development using SSH in VS Code
directly in the
VS Code docs.




    

To rerun your job with SSH, you will first have to set the path to your Github
or Bitbucket SSH key. The first time you attempt to re-run with SSH, the
extension will guide you to select the path of the relevant SSH key. However, if
you miss this step or want to modify it at a later time, you can do so from the
dedicated section of the settings page:

    

If the job you want to rerun uses parallelism, you will be able to select which
job you want to SSH into.

You can read more about debugging with SSH on CircleCI
in the Docs.

Status Bar
The Status Bar provides summary information about the state of the CircleCI
extension, your project and your most recent workflow.

    

Specifically, you might see the following statuses:

Not logged in - when clicking on the status bar, the login page will open
No project - when clicking on the status bar, the settings page will open
so you can select a project manually
Success / On hold / Failed, and similar workflow statuses - THIS refers to
the status of the top pipeline in your panel. When clicking on the status bar,
the relative workflow will come into focus on the CircleCI Pipelines Panel.
No internet - when your internet connection is lost

Config Helper
This extension provides in-file assistance with writing, editing and navigating
CircleCI Configuration files.
It is based on a CircleCI-specific Language Server, and offers:

Rich code navigation through “go-to-definition” and “go-to-reference”
commands. This is especially convenient when working on large configuration
files, to verify the definition of custom jobs, executors parameters, or in
turn view where any of them are referenced in the file. Assisted code
navigation also works for Orbs, allowing to explore their definition directly
in the IDE when using the go-to-definition feature on an orb-defined command
or parameter.


    


Contextual documentation and usage hints when hovering on specific keys,
so as to avoid having to continuously switch to the browser to check the docs
whenever you are editing your YAML config. Links to the official CircleCI
documentation are also provided on hover - for easier navigation.


    


Syntax validation - which makes it much easier to identify typos,
incorrect use of parameters, incomplete definitions, wrong types, invalid or
deprecated machine versions, etc.


    


Usage warnings - which can help identify deprecated parameters, unused
jobs or executors, or missing keys that prevent you from taking advantage of
CircleCI’s full capabilities


    


Auto completion, available both on built-in keys and parameters and on
user-defined variables


    

You can access a full overview of all errors, warnings and hints proposed by the
Config Helper in the Problems tab of VS Code.

    


The Config Helper is based on a dedicated Language Server for CircleCI YAML
files, which is Open Source. You can view its source code, contribute and add
issues directly on the project repository:
circleci-yaml-language-server.

Config validation commands
The extension also provides two commands that help you statically validate your
YAML config files without having to run a pipeline.

    


Validate current configuration file
Corresponds to the CLI command
circleci config validate,
and verifies statically that the config file is well formed. Please note that
this command only validates this file for structure and syntax errors, but
not for semantic error (e.g. this job does not exist).

Validate current configuration file against org policy
Corresponds to the CLI command
circleci policy decide,
and verifies that the configuration file complies with your organization
policies - if any are set.

Please note that this command is only available to Scale customers


View compiled version of current configuration file
This command resolves all orb references in your config file, and shows you
the full-length version of your config.


All these commands can also be invoked:

by right-clicking on a CircleCI YAML file:


    


by clicking on the CircleCI button on the top right corner of the page, when
focusing on a CircleCI YAML file. Please note that the button will not be
visible if you are editing a different file.


    

🆕 Test run your config (Open Preview)

NOTE: The ability to trigger a pipeline from VS Code with a unversioned
config is currently in Open Preview, and only available for projects
integrated through the GitHub OAuth app, or Bitbucket. To find out
which GitHub account type you have, see the
documentation about GitHub OAuth app integration.

Trigger pipelines from VS Code to iterate on your CircleCI config without
committing your trial and error changes to your version control system. Run and
validate your full pipeline, or select jobs and workflows to validate
individually. View the results of your test runs in the Pipelines Panel or in
the CircleCI web app, just the same as any other pipeline.

Prerequisites

v2.0 or higher of the CircleCI VS Code extension
A CircleCI account integrated through the GitHub OAuth app, or Bitbucket. To
find out which GitHub account type you have, check
this docs page.
Your org must have opted-in to this feature through Organization Settings. You
may need to ask your org admin to do so for you. See the section Feature
controls below for more details.
Your project must not make use of
dynamic configuration. This
feature is disabled for projects that use dynamic configuration.

NOTE: Unversioned config in CircleCI indicates that the
.circleci/config.yml on the branch where the pipeline is running is ignored,
and instead, the configuration file is overridden by a custom configuration file
passed as a parameter. The term “unversioned” refers to the fact the config file
is not versioned in the VCS. It is, however, stored in CircleCI along with the
pipeline, and it is available at any time in the CircleCI web app.

Please use caution when running pipelines with unversioned configuration, and take care to ensure no jobs with unintended effects are included in the run. For more details, see the section Security Implications below. 

Access to this feature is controlled by an opt-in setting which only organization admins can control. Once your organization has opted-in, you can opt-out for each individual project. For more details, see the section Feature-controls below.

Steps
The following steps show how to test run a pipeline from the VS Code extension:

Open VS Code and select the CircleCI logo in the sidebar. The Pipelines
and Run panels will be visible
Expand the Run panel to view your projects.
For each project, there is a button to trigger the config test run, and check
boxes for each workflow and job for you to choose which parts of your config
you want to run. Select your options, and click icon:play[]. Any local change
you make to your .circleci/config.yml file will be included in the test
run.
The pipeline is now visible in your dashboard in the CircleCI web app, at
app.circleci.com/pipelines/, and the
Pipelines Panel in the VS Code extension.

Feature controls
The ability to trigger pipelines from VS Code can be controlled at the org
level and at the project level.

Opt-in organization level setting. This can be changed only by
organization admins, and overrides project settings.
Setting location:
Organization Settings > Advanced > Allow triggering pipelines with unversioned config
in the Web App.

Opt-out project level setting.
Setting location:
Project Settings > VS Code integration > Allow triggering pipelines with unversioned config
in the Web App.


Security Implications
Running pipelines with unversioned config can cause security vulnerabilities.
Before enabling this feature, please acknowledge the risks outlined in the
official Docs.

Troubleshooting
Here are some frequently encountered issues, and some clarifications on each of
them.

“Your project could not be detected because no workspace is currently open”
You can fix this issue by opening a folder or workspace. Alternatively, you
can select to follow a CircleCI project manually from the Settings page.

The following errors concern the ability of the extension to link your
workspace to a Git repository.

“Your project could not be detected because we couldn’t find a Git repository associated with this workspace”
“Your project could not be detected because we were unable to get the list of git remotes”
“Your project could not be detected because we could not find default remote of your Git repository”
“Your project could not be detected because we were unable to get the URL of the Git remote XYZ”

When any of these errors occur, you might want to check that your workspace
has a valid Git remote URL. You can also fix this issue by selecting to follow
a CircleCI project manually from the Settings page.

“Your project could not be detected because CircleCI does not know this project”
This error indicates that the repository associated with your workspace
doesn’t appear to be a CircleCI project. If this is unexpected, verify the Git
remote URL associated with your repository, and ensure that you see this
project on the CircleCI web app. You can also address this issue by selecting
to follow a CircleCI project manually from the Settings page.

“Your project could not be detected because you don't follow this project on CircleCI”
When you see this error, you might want to visit the
Projects page on the CircleCI app
and ensure that you “follow” the project associated with this workspace.

“connection to server is erroring. Shutting down server”
This message indicates that the CircleCI Language Server has crashed. This
might be caused by an unexpected parsing error. For this reason, it is likely
that this issue will always occur on the same file. If you identify a file
that causes this error, it would be helpful if you could inform us at XXXXXX
(in the future on the LS open source repo)

When interacting with pipelines, workflows and jobs, you might see the
following errors.

“Cannot refresh pipelines: [runtime error message]”
“Download failed [runtime error message”’
“Cannot rerun workflow because: [runtime error message]”
“Job approval failed: [runtime error message]”

Please keep in mind that one of the causes for any of the above error messages
could be network issues. If you see any of these messages repeatedly, we
recommend you check your internet connection.

The following errors should never occur. Should you see any of them and be
able to reproduce them appearing, it would be helpful if you could report this
to us.

“Target entity can not be cancelled because it is not a workflow / job”
“Your project is not set up”
“Can not cancel your job because it has no job number”



Need support?
How to contact us
If you find any bugs with this extension or want to provide feedback, you can
contact us at
cci-vscode-feedback@circleci.com.
Documentation
You can find more information about CircleCI on our
official documentation.
How to contribute
The Language Server upon which the Conifg Helper is based is Open Source. If you
would like to contribute to the project, feel free to open a PR or get in touch
with us through the
circleci-yaml-language-server repository.
Additional resources
Data and Telemetry
The CircleCI VS Code extension collects usage data for product improvement
purposes, respecting the isTelemetryEnabled and telemetry.telemetryLevel
settings provided by VS Code.
It can be opted out through the VS Code settings page.
Privacy Policy
By signing in to this extension, you agree to the
CircleCI Privacy Policy.
Acknowledgements
This project was made possible by the community surrounding it. You can find
more information about the people and projects which contributed to this
extension in the file CREDITS.md.
We were also inspired by the great work done by community-built extensions:

Jody's Extension for CircleCI
CircleCI Status
vscode-circleci
circleci-conig-validator
Local-CI


© 2023 Circle Internet Services, Inc.

Contact usJobsPrivacyManage cookiesTerms of useTrademarks© 2025 Microsoft\nVisual Studio Code>Language Packs>CircleCINew to Visual Studio Code? Get it now.CircleCICircleCIcircleci.com |  85,877 installs |  (19) | FreeThe official CircleCI extension to create and manage your CI/CD pipelinesInstallationLaunch VS Code Quick Open (Ctrl+P), paste the following command, and press enter.CopyCopied to clipboardMore InfoOverviewVersion HistoryQ & ARating & ReviewThe official CircleCI VS Code extension is a new way to interact with CircleCI.
This extension provides an interface to visualize and manage CircleCI pipelines
directly from your IDE, as well as providing contextual help when creating,
modifying and editing CircleCI YAML config files. This way, it avoids expensive
context-switching between VS Code and your browser.
More practically, this extension allows you to:

Authenticate and connect VS Code to CircleCI
Browse and interact with your pipelines. Available actions include

Viewing pipelines, workflows, and jobs statuses
Viewing test outputs
Browsing job logs
Downloading artifacts
Approving jobs
Re-running builds
Debugging jobs with SSH


Be alerted through notifications when your workflows change status or need
your attention
Access in-file support when editing CircleCI YAML configuration files,
including:

Syntax validation
Syntax highlighting
Go-to-definition and go-to-reference
On-hover documentation and usage hints
Autocompletion


Launch commands to validate config files statically, or against your org
policy


    

Getting started
It’s easy to get started with CircleCI for VS Code.

Install the extension
You can install the CircleCI extension from within VS Code, or download it
from the marketplace.
⚠️ This extension is compatible with VS Code versions 1.85 or above.

Authenticate into CircleCI
Open the CircleCI Panel by clicking on the CircleCI icon on the activity bar
on the left of your screen, then click on “Log in”.
   
    

You will be prompted to enter a
Personal API Token. If you
don't have one, you can generate a new one for this purpose.
If you are an Enterprise customer, make sure to check the box and enter your
self-hosted server URL.

Setup your project
If your VS Code workspace contains one or more CircleCI projects, the
extension will detect them automatically, and the Pipelines Panel will be
populated with your most recent pipelines.
If no project is detected, open the settings page (through the VS Code
command CircleCI: Open Settings, or by clicking on the settings icon (⚙️)
at the top of the Pipelines Panel), and select your projects manually.
Please note that your manual selection will only be persisted if no projects
are detected automatically.
   ⚠️ Automatic project detection does not work for GitLab projects. Please select your project manually from the Settings page.





Configure your Pipelines Panel
By default, your Pipelines Panel will display all the latest pipelines run on
your project. However, you can configure it to show you only the pipelines
you are interested in.
All configurations are available in the Settings page, which you can open
with the command CircleCI: Open Settings or by clicking on the settings
icon (⚙️) at the top of the Pipelines Panel.
Specifically, you can choose to follow:

Only your pipelines, or those authored by anyone
All branches, only your current branch, or a specific branch. You can also
select the checkbox “Always display default branch”
Only pipelines that include workflows and jobs with specific statuses.


    


Configure notifications
You can set up pop-up notifications to warn you when a workflow in your
Pipelines Panel has changed status.
 
   
 
By default, you will receive a pop-up notification every time one of the
workflows in your Pipelines Panel enters a failing status, or needs your
approval.
If you wish to alter these defaults, you can:

Mute notifications (a toggle button to change this setting is also
available at the top of the Pipelines Panel)



Configure which workflow status changes you want to be notified about

Please note that you can only be notified about workflows that appear in your
Pipelines Panel.
 
     
 


The Pipelines Panel
The Pipelines Panel lists all CircleCI projects detected in your workspace. For
each project, it shows the most recent pipelines, jobs and workflows, and lets
you monitor their status and interact with them.

    

For some tree objects, you can perform actions by clicking on the icons which
appear when you hover over the item.
Project
Projects are the top level tree items, and they contain your pipelines.

If you don't follow a project, you can also use the panel to follow it.
Pipeline
Pipelines
are nested under projects. They are the CircleCI unit of change, and they
contain your workflows.

Workflow
Workflows
are nested under each Pipeline, and contain Jobs. Hovering over a Workflow lets
you:

Open in browser, to view workflow details in the CircleCI app, on your default
web browser
Rerun workflow from start, to re-triggered the entire workflow
Rerun workflow from failed, to re-triggered the workflow starting from the
first failed job

Job
Jobs
are nested under each Workflow, and can contain Tests and Artifacts. Hovering
over a Job lets you:

Approve the job (only if the job is on hold)
Cancel the job (only if the job is running)
Rerun the job with SSH (you can read more about this functionality in a later
section)
View job details


    

By expanding a Job, you can also:

Load tests, if you have configured your tests to upload test results to
CircleCI. Tests that CircleCI has detected as flaky will be prefaced by the
indication [FLAKY].
Load artifacts, to load any artifacts created by the Job. Once the
artifacts are loaded, you can download them by clicking on them.

Re-run with SSH
You can re-run jobs with SSH directly from VS Code, either:

through the Job Details page, by clicking on the green button on the top
right:



or by clicking on the action icon next to the job name in the Pipelines Panel.


    

In both cases, you will be presented with two options:

Open SSH session in terminal


    


Open SSH session in remote VS Code window

This feature requires the official VS Code extension
Remote - SSH.
You can find more information on Remote Development using SSH in VS Code
directly in the
VS Code docs.




    

To rerun your job with SSH, you will first have to set the path to your Github
or Bitbucket SSH key. The first time you attempt to re-run with SSH, the
extension will guide you to select the path of the relevant SSH key. However, if
you miss this step or want to modify it at a later time, you can do so from the
dedicated section of the settings page:

    

If the job you want to rerun uses parallelism, you will be able to select which
job you want to SSH into.

You can read more about debugging with SSH on CircleCI
in the Docs.

Status Bar
The Status Bar provides summary information about the state of the CircleCI
extension, your project and your most recent workflow.

    

Specifically, you might see the following statuses:

Not logged in - when clicking on the status bar, the login page will open
No project - when clicking on the status bar, the settings page will open
so you can select a project manually
Success / On hold / Failed, and similar workflow statuses - THIS refers to
the status of the top pipeline in your panel. When clicking on the status bar,
the relative workflow will come into focus on the CircleCI Pipelines Panel.
No internet - when your internet connection is lost

Config Helper
This extension provides in-file assistance with writing, editing and navigating
CircleCI Configuration files.
It is based on a CircleCI-specific Language Server, and offers:

Rich code navigation through “go-to-definition” and “go-to-reference”
commands. This is especially convenient when working on large configuration
files, to verify the definition of custom jobs, executors parameters, or in
turn view where any of them are referenced in the file. Assisted code
navigation also works for Orbs, allowing to explore their definition directly
in the IDE when using the go-to-definition feature on an orb-defined command
or parameter.


    


Contextual documentation and usage hints when hovering on specific keys,
so as to avoid having to continuously switch to the browser to check the docs
whenever you are editing your YAML config. Links to the official CircleCI
documentation are also provided on hover - for easier navigation.


    


Syntax validation - which makes it much easier to identify typos,
incorrect use of parameters, incomplete definitions, wrong types, invalid or
deprecated machine versions, etc.


    


Usage warnings - which can help identify deprecated parameters, unused
jobs or executors, or missing keys that prevent you from taking advantage of
CircleCI’s full capabilities


    


Auto completion, available both on built-in keys and parameters and on
user-defined variables


    

You can access a full overview of all errors, warnings and hints proposed by the
Config Helper in the Problems tab of VS Code.

    


The Config Helper is based on a dedicated Language Server for CircleCI YAML
files, which is Open Source. You can view its source code, contribute and add
issues directly on the project repository:
circleci-yaml-language-server.

Config validation commands
The extension also provides two commands that help you statically validate your
YAML config files without having to run a pipeline.

    


Validate current configuration file
Corresponds to the CLI command
circleci config validate,
and verifies statically that the config file is well formed. Please note that
this command only validates this file for structure and syntax errors, but
not for semantic error (e.g. this job does not exist).

Validate current configuration file against org policy
Corresponds to the CLI command
circleci policy decide,
and verifies that the configuration file complies with your organization
policies - if any are set.

Please note that this command is only available to Scale customers


View compiled version of current configuration file
This command resolves all orb references in your config file, and shows you
the full-length version of your config.


All these commands can also be invoked:

by right-clicking on a CircleCI YAML file:


    


by clicking on the CircleCI button on the top right corner of the page, when
focusing on a CircleCI YAML file. Please note that the button will not be
visible if you are editing a different file.


    

🆕 Test run your config (Open Preview)

NOTE: The ability to trigger a pipeline from VS Code with a unversioned
config is currently in Open Preview, and only available for projects
integrated through the GitHub OAuth app, or Bitbucket. To find out
which GitHub account type you have, see the
documentation about GitHub OAuth app integration.

Trigger pipelines from VS Code to iterate on your CircleCI config without
committing your trial and error changes to your version control system. Run and
validate your full pipeline, or select jobs and workflows to validate
individually. View the results of your test runs in the Pipelines Panel or in
the CircleCI web app, just the same as any other pipeline.

Prerequisites

v2.0 or higher of the CircleCI VS Code extension
A CircleCI account integrated through the GitHub OAuth app, or Bitbucket. To
find out which GitHub account type you have, check
this docs page.
Your org must have opted-in to this feature through Organization Settings. You
may need to ask your org admin to do so for you. See the section Feature
controls below for more details.
Your project must not make use of
dynamic configuration. This
feature is disabled for projects that use dynamic configuration.

NOTE: Unversioned config in CircleCI indicates that the
.circleci/config.yml on the branch where the pipeline is running is ignored,
and instead, the configuration file is overridden by a custom configuration file
passed as a parameter. The term “unversioned” refers to the fact the config file
is not versioned in the VCS. It is, however, stored in CircleCI along with the
pipeline, and it is available at any time in the CircleCI web app.

Please use caution when running pipelines with unversioned configuration, and take care to ensure no jobs with unintended effects are included in the run. For more details, see the section Security Implications below. 

Access to this feature is controlled by an opt-in setting which only organization admins can control. Once your organization has opted-in, you can opt-out for each individual project. For more details, see the section Feature-controls below.

Steps
The following steps show how to test run a pipeline from the VS Code extension:

Open VS Code and select the CircleCI logo in the sidebar. The Pipelines
and Run panels will be visible
Expand the Run panel to view your projects.
For each project, there is a button to trigger the config test run, and check
boxes for each workflow and job for you to choose which parts of your config
you want to run. Select your options, and click icon:play[]. Any local change
you make to your .circleci/config.yml file will be included in the test
run.
The pipeline is now visible in your dashboard in the CircleCI web app, at
app.circleci.com/pipelines/, and the
Pipelines Panel in the VS Code extension.

Feature controls
The ability to trigger pipelines from VS Code can be controlled at the org
level and at the project level.

Opt-in organization level setting. This can be changed only by
organization admins, and overrides project settings.
Setting location:
Organization Settings > Advanced > Allow triggering pipelines with unversioned config
in the Web App.

Opt-out project level setting.
Setting location:
Project Settings > VS Code integration > Allow triggering pipelines with unversioned config
in the Web App.


Security Implications
Running pipelines with unversioned config can cause security vulnerabilities.
Before enabling this feature, please acknowledge the risks outlined in the
official Docs.

Troubleshooting
Here are some frequently encountered issues, and some clarifications on each of
them.

“Your project could not be detected because no workspace is currently open”
You can fix this issue by opening a folder or workspace. Alternatively, you
can select to follow a CircleCI project manually from the Settings page.

The following errors concern the ability of the extension to link your
workspace to a Git repository.

“Your project could not be detected because we couldn’t find a Git repository associated with this workspace”
“Your project could not be detected because we were unable to get the list of git remotes”
“Your project could not be detected because we could not find default remote of your Git repository”
“Your project could not be detected because we were unable to get the URL of the Git remote XYZ”

When any of these errors occur, you might want to check that your workspace
has a valid Git remote URL. You can also fix this issue by selecting to follow
a CircleCI project manually from the Settings page.

“Your project could not be detected because CircleCI does not know this project”
This error indicates that the repository associated with your workspace
doesn’t appear to be a CircleCI project. If this is unexpected, verify the Git
remote URL associated with your repository, and ensure that you see this
project on the CircleCI web app. You can also address this issue by selecting
to follow a CircleCI project manually from the Settings page.

“Your project could not be detected because you don't follow this project on CircleCI”
When you see this error, you might want to visit the
Projects page on the CircleCI app
and ensure that you “follow” the project associated with this workspace.

“connection to server is erroring. Shutting down server”
This message indicates that the CircleCI Language Server has crashed. This
might be caused by an unexpected parsing error. For this reason, it is likely
that this issue will always occur on the same file. If you identify a file
that causes this error, it would be helpful if you could inform us at XXXXXX
(in the future on the LS open source repo)

When interacting with pipelines, workflows and jobs, you might see the
following errors.

“Cannot refresh pipelines: [runtime error message]”
“Download failed [runtime error message”’
“Cannot rerun workflow because: [runtime error message]”
“Job approval failed: [runtime error message]”

Please keep in mind that one of the causes for any of the above error messages
could be network issues. If you see any of these messages repeatedly, we
recommend you check your internet connection.

The following errors should never occur. Should you see any of them and be
able to reproduce them appearing, it would be helpful if you could report this
to us.

“Target entity can not be cancelled because it is not a workflow / job”
“Your project is not set up”
“Can not cancel your job because it has no job number”



Need support?
How to contact us
If you find any bugs with this extension or want to provide feedback, you can
contact us at
cci-vscode-feedback@circleci.com.
Documentation
You can find more information about CircleCI on our
official documentation.
How to contribute
The Language Server upon which the Conifg Helper is based is Open Source. If you
would like to contribute to the project, feel free to open a PR or get in touch
with us through the
circleci-yaml-language-server repository.
Additional resources
Data and Telemetry
The CircleCI VS Code extension collects usage data for product improvement
purposes, respecting the isTelemetryEnabled and telemetry.telemetryLevel
settings provided by VS Code.
It can be opted out through the VS Code settings page.
Privacy Policy
By signing in to this extension, you agree to the
CircleCI Privacy Policy.
Acknowledgements
This project was made possible by the community surrounding it. You can find
more information about the people and projects which contributed to this
extension in the file CREDITS.md.
We were also inspired by the great work done by community-built extensions:

Jody's Extension for CircleCI
CircleCI Status
vscode-circleci
circleci-conig-validator
Local-CI


© 2023 Circle Internet Services, Inc.

Contact usJobsPrivacyManage cookiesTerms of useTrademarks© 2025 Microsoft\nVisual Studio Code>Language Packs>CircleCINew to Visual Studio Code? Get it now.CircleCICircleCIcircleci.com |  85,877 installs |  (19) | FreeThe official CircleCI extension to create and manage your CI/CD pipelinesInstallationLaunch VS Code Quick Open (Ctrl+P), paste the following command, and press enter.CopyCopied to clipboardMore InfoOverviewVersion HistoryQ & ARating & ReviewThe official CircleCI VS Code extension is a new way to interact with CircleCI.
This extension provides an interface to visualize and manage CircleCI pipelines
directly from your IDE, as well as providing contextual help when creating,
modifying and editing CircleCI YAML config files. This way, it avoids expensive
context-switching between VS Code and your browser.
More practically, this extension allows you to:

Authenticate and connect VS Code to CircleCI
Browse and interact with your pipelines. Available actions include

Viewing pipelines, workflows, and jobs statuses
Viewing test outputs
Browsing job logs
Downloading artifacts
Approving jobs
Re-running builds
Debugging jobs with SSH


Be alerted through notifications when your workflows change status or need
your attention
Access in-file support when editing CircleCI YAML configuration files,
including:

Syntax validation
Syntax highlighting
Go-to-definition and go-to-reference
On-hover documentation and usage hints
Autocompletion


Launch commands to validate config files statically, or against your org
policy


    

Getting started
It’s easy to get started with CircleCI for VS Code.

Install the extension
You can install the CircleCI extension from within VS Code, or download it
from the marketplace.
⚠️ This extension is compatible with VS Code versions 1.85 or above.

Authenticate into CircleCI
Open the CircleCI Panel by clicking on the CircleCI icon on the activity bar
on the left of your screen, then click on “Log in”.
   
    

You will be prompted to enter a
Personal API Token. If you
don't have one, you can generate a new one for this purpose.
If you are an Enterprise customer, make sure to check the box and enter your
self-hosted server URL.

Setup your project
If your VS Code workspace contains one or more CircleCI projects, the
extension will detect them automatically, and the Pipelines Panel will be
populated with your most recent pipelines.
If no project is detected, open the settings page (through the VS Code
command CircleCI: Open Settings, or by clicking on the settings icon (⚙️)
at the top of the Pipelines Panel), and select your projects manually.
Please note that your manual selection will only be persisted if no projects
are detected automatically.
   ⚠️ Automatic project detection does not work for GitLab projects. Please select your project manually from the Settings page.





Configure your Pipelines Panel
By default, your Pipelines Panel will display all the latest pipelines run on
your project. However, you can configure it to show you only the pipelines
you are interested in.
All configurations are available in the Settings page, which you can open
with the command CircleCI: Open Settings or by clicking on the settings
icon (⚙️) at the top of the Pipelines Panel.
Specifically, you can choose to follow:

Only your pipelines, or those authored by anyone
All branches, only your current branch, or a specific branch. You can also
select the checkbox “Always display default branch”
Only pipelines that include workflows and jobs with specific statuses.


    


Configure notifications
You can set up pop-up notifications to warn you when a workflow in your
Pipelines Panel has changed status.
 
   
 
By default, you will receive a pop-up notification every time one of the
workflows in your Pipelines Panel enters a failing status, or needs your
approval.
If you wish to alter these defaults, you can:

Mute notifications (a toggle button to change this setting is also
available at the top of the Pipelines Panel)



Configure which workflow status changes you want to be notified about

Please note that you can only be notified about workflows that appear in your
Pipelines Panel.
 
     
 


The Pipelines Panel
The Pipelines Panel lists all CircleCI projects detected in your workspace. For
each project, it shows the most recent pipelines, jobs and workflows, and lets
you monitor their status and interact with them.

    

For some tree objects, you can perform actions by clicking on the icons which
appear when you hover over the item.
Project
Projects are the top level tree items, and they contain your pipelines.

If you don't follow a project, you can also use the panel to follow it.
Pipeline
Pipelines
are nested under projects. They are the CircleCI unit of change, and they
contain your workflows.

Workflow
Workflows
are nested under each Pipeline, and contain Jobs. Hovering over a Workflow lets
you:

Open in browser, to view workflow details in the CircleCI app, on your default
web browser
Rerun workflow from start, to re-triggered the entire workflow
Rerun workflow from failed, to re-triggered the workflow starting from the
first failed job

Job
Jobs
are nested under each Workflow, and can contain Tests and Artifacts. Hovering
over a Job lets you:

Approve the job (only if the job is on hold)
Cancel the job (only if the job is running)
Rerun the job with SSH (you can read more about this functionality in a later
section)
View job details


    

By expanding a Job, you can also:

Load tests, if you have configured your tests to upload test results to
CircleCI. Tests that CircleCI has detected as flaky will be prefaced by the
indication [FLAKY].
Load artifacts, to load any artifacts created by the Job. Once the
artifacts are loaded, you can download them by clicking on them.

Re-run with SSH
You can re-run jobs with SSH directly from VS Code, either:

through the Job Details page, by clicking on the green button on the top
right:



or by clicking on the action icon next to the job name in the Pipelines Panel.


    

In both cases, you will be presented with two options:

Open SSH session in terminal


    


Open SSH session in remote VS Code window

This feature requires the official VS Code extension
Remote - SSH.
You can find more information on Remote Development using SSH in VS Code
directly in the
VS Code docs.




    

To rerun your job with SSH, you will first have to set the path to your Github
or Bitbucket SSH key. The first time you attempt to re-run with SSH, the
extension will guide you to select the path of the relevant SSH key. However, if
you miss this step or want to modify it at a later time, you can do so from the
dedicated section of the settings page:

    

If the job you want to rerun uses parallelism, you will be able to select which
job you want to SSH into.

You can read more about debugging with SSH on CircleCI
in the Docs.

Status Bar
The Status Bar provides summary information about the state of the CircleCI
extension, your project and your most recent workflow.

    

Specifically, you might see the following statuses:

Not logged in - when clicking on the status bar, the login page will open
No project - when clicking on the status bar, the settings page will open
so you can select a project manually
Success / On hold / Failed, and similar workflow statuses - THIS refers to
the status of the top pipeline in your panel. When clicking on the status bar,
the relative workflow will come into focus on the CircleCI Pipelines Panel.
No internet - when your internet connection is lost

Config Helper
This extension provides in-file assistance with writing, editing and navigating
CircleCI Configuration files.
It is based on a CircleCI-specific Language Server, and offers:

Rich code navigation through “go-to-definition” and “go-to-reference”
commands. This is especially convenient when working on large configuration
files, to verify the definition of custom jobs, executors parameters, or in
turn view where any of them are referenced in the file. Assisted code
navigation also works for Orbs, allowing to explore their definition directly
in the IDE when using the go-to-definition feature on an orb-defined command
or parameter.


    


Contextual documentation and usage hints when hovering on specific keys,
so as to avoid having to continuously switch to the browser to check the docs
whenever you are editing your YAML config. Links to the official CircleCI
documentation are also provided on hover - for easier navigation.


    


Syntax validation - which makes it much easier to identify typos,
incorrect use of parameters, incomplete definitions, wrong types, invalid or
deprecated machine versions, etc.


    


Usage warnings - which can help identify deprecated parameters, unused
jobs or executors, or missing keys that prevent you from taking advantage of
CircleCI’s full capabilities


    


Auto completion, available both on built-in keys and parameters and on
user-defined variables


    

You can access a full overview of all errors, warnings and hints proposed by the
Config Helper in the Problems tab of VS Code.

    


The Config Helper is based on a dedicated Language Server for CircleCI YAML
files, which is Open Source. You can view its source code, contribute and add
issues directly on the project repository:
circleci-yaml-language-server.

Config validation commands
The extension also provides two commands that help you statically validate your
YAML config files without having to run a pipeline.

    


Validate current configuration file
Corresponds to the CLI command
circleci config validate,
and verifies statically that the config file is well formed. Please note that
this command only validates this file for structure and syntax errors, but
not for semantic error (e.g. this job does not exist).

Validate current configuration file against org policy
Corresponds to the CLI command
circleci policy decide,
and verifies that the configuration file complies with your organization
policies - if any are set.

Please note that this command is only available to Scale customers


View compiled version of current configuration file
This command resolves all orb references in your config file, and shows you
the full-length version of your config.


All these commands can also be invoked:

by right-clicking on a CircleCI YAML file:


    


by clicking on the CircleCI button on the top right corner of the page, when
focusing on a CircleCI YAML file. Please note that the button will not be
visible if you are editing a different file.


    

🆕 Test run your config (Open Preview)

NOTE: The ability to trigger a pipeline from VS Code with a unversioned
config is currently in Open Preview, and only available for projects
integrated through the GitHub OAuth app, or Bitbucket. To find out
which GitHub account type you have, see the
documentation about GitHub OAuth app integration.

Trigger pipelines from VS Code to iterate on your CircleCI config without
committing your trial and error changes to your version control system. Run and
validate your full pipeline, or select jobs and workflows to validate
individually. View the results of your test runs in the Pipelines Panel or in
the CircleCI web app, just the same as any other pipeline.

Prerequisites

v2.0 or higher of the CircleCI VS Code extension
A CircleCI account integrated through the GitHub OAuth app, or Bitbucket. To
find out which GitHub account type you have, check
this docs page.
Your org must have opted-in to this feature through Organization Settings. You
may need to ask your org admin to do so for you. See the section Feature
controls below for more details.
Your project must not make use of
dynamic configuration. This
feature is disabled for projects that use dynamic configuration.

NOTE: Unversioned config in CircleCI indicates that the
.circleci/config.yml on the branch where the pipeline is running is ignored,
and instead, the configuration file is overridden by a custom configuration file
passed as a parameter. The term “unversioned” refers to the fact the config file
is not versioned in the VCS. It is, however, stored in CircleCI along with the
pipeline, and it is available at any time in the CircleCI web app.

Please use caution when running pipelines with unversioned configuration, and take care to ensure no jobs with unintended effects are included in the run. For more details, see the section Security Implications below. 

Access to this feature is controlled by an opt-in setting which only organization admins can control. Once your organization has opted-in, you can opt-out for each individual project. For more details, see the section Feature-controls below.

Steps
The following steps show how to test run a pipeline from the VS Code extension:

Open VS Code and select the CircleCI logo in the sidebar. The Pipelines
and Run panels will be visible
Expand the Run panel to view your projects.
For each project, there is a button to trigger the config test run, and check
boxes for each workflow and job for you to choose which parts of your config
you want to run. Select your options, and click icon:play[]. Any local change
you make to your .circleci/config.yml file will be included in the test
run.
The pipeline is now visible in your dashboard in the CircleCI web app, at
app.circleci.com/pipelines/, and the
Pipelines Panel in the VS Code extension.

Feature controls
The ability to trigger pipelines from VS Code can be controlled at the org
level and at the project level.

Opt-in organization level setting. This can be changed only by
organization admins, and overrides project settings.
Setting location:
Organization Settings > Advanced > Allow triggering pipelines with unversioned config
in the Web App.

Opt-out project level setting.
Setting location:
Project Settings > VS Code integration > Allow triggering pipelines with unversioned config
in the Web App.


Security Implications
Running pipelines with unversioned config can cause security vulnerabilities.
Before enabling this feature, please acknowledge the risks outlined in the
official Docs.

Troubleshooting
Here are some frequently encountered issues, and some clarifications on each of
them.

“Your project could not be detected because no workspace is currently open”
You can fix this issue by opening a folder or workspace. Alternatively, you
can select to follow a CircleCI project manually from the Settings page.

The following errors concern the ability of the extension to link your
workspace to a Git repository.

“Your project could not be detected because we couldn’t find a Git repository associated with this workspace”
“Your project could not be detected because we were unable to get the list of git remotes”
“Your project could not be detected because we could not find default remote of your Git repository”
“Your project could not be detected because we were unable to get the URL of the Git remote XYZ”

When any of these errors occur, you might want to check that your workspace
has a valid Git remote URL. You can also fix this issue by selecting to follow
a CircleCI project manually from the Settings page.

“Your project could not be detected because CircleCI does not know this project”
This error indicates that the repository associated with your workspace
doesn’t appear to be a CircleCI project. If this is unexpected, verify the Git
remote URL associated with your repository, and ensure that you see this
project on the CircleCI web app. You can also address this issue by selecting
to follow a CircleCI project manually from the Settings page.

“Your project could not be detected because you don't follow this project on CircleCI”
When you see this error, you might want to visit the
Projects page on the CircleCI app
and ensure that you “follow” the project associated with this workspace.

“connection to server is erroring. Shutting down server”
This message indicates that the CircleCI Language Server has crashed. This
might be caused by an unexpected parsing error. For this reason, it is likely
that this issue will always occur on the same file. If you identify a file
that causes this error, it would be helpful if you could inform us at XXXXXX
(in the future on the LS open source repo)

When interacting with pipelines, workflows and jobs, you might see the
following errors.

“Cannot refresh pipelines: [runtime error message]”
“Download failed [runtime error message”’
“Cannot rerun workflow because: [runtime error message]”
“Job approval failed: [runtime error message]”

Please keep in mind that one of the causes for any of the above error messages
could be network issues. If you see any of these messages repeatedly, we
recommend you check your internet connection.

The following errors should never occur. Should you see any of them and be
able to reproduce them appearing, it would be helpful if you could report this
to us.

“Target entity can not be cancelled because it is not a workflow / job”
“Your project is not set up”
“Can not cancel your job because it has no job number”



Need support?
How to contact us
If you find any bugs with this extension or want to provide feedback, you can
contact us at
cci-vscode-feedback@circleci.com.
Documentation
You can find more information about CircleCI on our
official documentation.
How to contribute
The Language Server upon which the Conifg Helper is based is Open Source. If you
would like to contribute to the project, feel free to open a PR or get in touch
with us through the
circleci-yaml-language-server repository.
Additional resources
Data and Telemetry
The CircleCI VS Code extension collects usage data for product improvement
purposes, respecting the isTelemetryEnabled and telemetry.telemetryLevel
settings provided by VS Code.
It can be opted out through the VS Code settings page.
Privacy Policy
By signing in to this extension, you agree to the
CircleCI Privacy Policy.
Acknowledgements
This project was made possible by the community surrounding it. You can find
more information about the people and projects which contributed to this
extension in the file CREDITS.md.
We were also inspired by the great work done by community-built extensions:

Jody's Extension for CircleCI
CircleCI Status
vscode-circleci
circleci-conig-validator
Local-CI


© 2023 Circle Internet Services, Inc.

Contact usJobsPrivacyManage cookiesTerms of useTrademarks© 2025 Microsoft\nVisual Studio Code>Language Packs>CircleCINew to Visual Studio Code? Get it now.\nVisual Studio Code>Language Packs>CircleCINew to Visual Studio Code? Get it now.\nVisual Studio Code>Language Packs>CircleCI\nNew to Visual Studio Code? Get it now.\nNew to Visual Studio Code?\nCircleCICircleCIcircleci.com |  85,877 installs |  (19) | FreeThe official CircleCI extension to create and manage your CI/CD pipelinesInstallationLaunch VS Code Quick Open (Ctrl+P), paste the following command, and press enter.CopyCopied to clipboardMore InfoOverviewVersion HistoryQ & ARating & ReviewThe official CircleCI VS Code extension is a new way to interact with CircleCI.
This extension provides an interface to visualize and manage CircleCI pipelines
directly from your IDE, as well as providing contextual help when creating,
modifying and editing CircleCI YAML config files. This way, it avoids expensive
context-switching between VS Code and your browser.
More practically, this extension allows you to:

Authenticate and connect VS Code to CircleCI
Browse and interact with your pipelines. Available actions include

Viewing pipelines, workflows, and jobs statuses
Viewing test outputs
Browsing job logs
Downloading artifacts
Approving jobs
Re-running builds
Debugging jobs with SSH


Be alerted through notifications when your workflows change status or need
your attention
Access in-file support when editing CircleCI YAML configuration files,
including:

Syntax validation
Syntax highlighting
Go-to-definition and go-to-reference
On-hover documentation and usage hints
Autocompletion


Launch commands to validate config files statically, or against your org
policy


    

Getting started
It’s easy to get started with CircleCI for VS Code.

Install the extension
You can install the CircleCI extension from within VS Code, or download it
from the marketplace.
⚠️ This extension is compatible with VS Code versions 1.85 or above.

Authenticate into CircleCI
Open the CircleCI Panel by clicking on the CircleCI icon on the activity bar
on the left of your screen, then click on “Log in”.
   
    

You will be prompted to enter a
Personal API Token. If you
don't have one, you can generate a new one for this purpose.
If you are an Enterprise customer, make sure to check the box and enter your
self-hosted server URL.

Setup your project
If your VS Code workspace contains one or more CircleCI projects, the
extension will detect them automatically, and the Pipelines Panel will be
populated with your most recent pipelines.
If no project is detected, open the settings page (through the VS Code
command CircleCI: Open Settings, or by clicking on the settings icon (⚙️)
at the top of the Pipelines Panel), and select your projects manually.
Please note that your manual selection will only be persisted if no projects
are detected automatically.
   ⚠️ Automatic project detection does not work for GitLab projects. Please select your project manually from the Settings page.





Configure your Pipelines Panel
By default, your Pipelines Panel will display all the latest pipelines run on
your project. However, you can configure it to show you only the pipelines
you are interested in.
All configurations are available in the Settings page, which you can open
with the command CircleCI: Open Settings or by clicking on the settings
icon (⚙️) at the top of the Pipelines Panel.
Specifically, you can choose to follow:

Only your pipelines, or those authored by anyone
All branches, only your current branch, or a specific branch. You can also
select the checkbox “Always display default branch”
Only pipelines that include workflows and jobs with specific statuses.


    


Configure notifications
You can set up pop-up notifications to warn you when a workflow in your
Pipelines Panel has changed status.
 
   
 
By default, you will receive a pop-up notification every time one of the
workflows in your Pipelines Panel enters a failing status, or needs your
approval.
If you wish to alter these defaults, you can:

Mute notifications (a toggle button to change this setting is also
available at the top of the Pipelines Panel)



Configure which workflow status changes you want to be notified about

Please note that you can only be notified about workflows that appear in your
Pipelines Panel.
 
     
 


The Pipelines Panel
The Pipelines Panel lists all CircleCI projects detected in your workspace. For
each project, it shows the most recent pipelines, jobs and workflows, and lets
you monitor their status and interact with them.

    

For some tree objects, you can perform actions by clicking on the icons which
appear when you hover over the item.
Project
Projects are the top level tree items, and they contain your pipelines.

If you don't follow a project, you can also use the panel to follow it.
Pipeline
Pipelines
are nested under projects. They are the CircleCI unit of change, and they
contain your workflows.

Workflow
Workflows
are nested under each Pipeline, and contain Jobs. Hovering over a Workflow lets
you:

Open in browser, to view workflow details in the CircleCI app, on your default
web browser
Rerun workflow from start, to re-triggered the entire workflow
Rerun workflow from failed, to re-triggered the workflow starting from the
first failed job

Job
Jobs
are nested under each Workflow, and can contain Tests and Artifacts. Hovering
over a Job lets you:

Approve the job (only if the job is on hold)
Cancel the job (only if the job is running)
Rerun the job with SSH (you can read more about this functionality in a later
section)
View job details


    

By expanding a Job, you can also:

Load tests, if you have configured your tests to upload test results to
CircleCI. Tests that CircleCI has detected as flaky will be prefaced by the
indication [FLAKY].
Load artifacts, to load any artifacts created by the Job. Once the
artifacts are loaded, you can download them by clicking on them.

Re-run with SSH
You can re-run jobs with SSH directly from VS Code, either:

through the Job Details page, by clicking on the green button on the top
right:



or by clicking on the action icon next to the job name in the Pipelines Panel.


    

In both cases, you will be presented with two options:

Open SSH session in terminal


    


Open SSH session in remote VS Code window

This feature requires the official VS Code extension
Remote - SSH.
You can find more information on Remote Development using SSH in VS Code
directly in the
VS Code docs.




    

To rerun your job with SSH, you will first have to set the path to your Github
or Bitbucket SSH key. The first time you attempt to re-run with SSH, the
extension will guide you to select the path of the relevant SSH key. However, if
you miss this step or want to modify it at a later time, you can do so from the
dedicated section of the settings page:

    

If the job you want to rerun uses parallelism, you will be able to select which
job you want to SSH into.

You can read more about debugging with SSH on CircleCI
in the Docs.

Status Bar
The Status Bar provides summary information about the state of the CircleCI
extension, your project and your most recent workflow.

    

Specifically, you might see the following statuses:

Not logged in - when clicking on the status bar, the login page will open
No project - when clicking on the status bar, the settings page will open
so you can select a project manually
Success / On hold / Failed, and similar workflow statuses - THIS refers to
the status of the top pipeline in your panel. When clicking on the status bar,
the relative workflow will come into focus on the CircleCI Pipelines Panel.
No internet - when your internet connection is lost

Config Helper
This extension provides in-file assistance with writing, editing and navigating
CircleCI Configuration files.
It is based on a CircleCI-specific Language Server, and offers:

Rich code navigation through “go-to-definition” and “go-to-reference”
commands. This is especially convenient when working on large configuration
files, to verify the definition of custom jobs, executors parameters, or in
turn view where any of them are referenced in the file. Assisted code
navigation also works for Orbs, allowing to explore their definition directly
in the IDE when using the go-to-definition feature on an orb-defined command
or parameter.


    


Contextual documentation and usage hints when hovering on specific keys,
so as to avoid having to continuously switch to the browser to check the docs
whenever you are editing your YAML config. Links to the official CircleCI
documentation are also provided on hover - for easier navigation.


    


Syntax validation - which makes it much easier to identify typos,
incorrect use of parameters, incomplete definitions, wrong types, invalid or
deprecated machine versions, etc.


    


Usage warnings - which can help identify deprecated parameters, unused
jobs or executors, or missing keys that prevent you from taking advantage of
CircleCI’s full capabilities


    


Auto completion, available both on built-in keys and parameters and on
user-defined variables


    

You can access a full overview of all errors, warnings and hints proposed by the
Config Helper in the Problems tab of VS Code.

    


The Config Helper is based on a dedicated Language Server for CircleCI YAML
files, which is Open Source. You can view its source code, contribute and add
issues directly on the project repository:
circleci-yaml-language-server.

Config validation commands
The extension also provides two commands that help you statically validate your
YAML config files without having to run a pipeline.

    


Validate current configuration file
Corresponds to the CLI command
circleci config validate,
and verifies statically that the config file is well formed. Please note that
this command only validates this file for structure and syntax errors, but
not for semantic error (e.g. this job does not exist).

Validate current configuration file against org policy
Corresponds to the CLI command
circleci policy decide,
and verifies that the configuration file complies with your organization
policies - if any are set.

Please note that this command is only available to Scale customers


View compiled version of current configuration file
This command resolves all orb references in your config file, and shows you
the full-length version of your config.


All these commands can also be invoked:

by right-clicking on a CircleCI YAML file:


    


by clicking on the CircleCI button on the top right corner of the page, when
focusing on a CircleCI YAML file. Please note that the button will not be
visible if you are editing a different file.


    

🆕 Test run your config (Open Preview)

NOTE: The ability to trigger a pipeline from VS Code with a unversioned
config is currently in Open Preview, and only available for projects
integrated through the GitHub OAuth app, or Bitbucket. To find out
which GitHub account type you have, see the
documentation about GitHub OAuth app integration.

Trigger pipelines from VS Code to iterate on your CircleCI config without
committing your trial and error changes to your version control system. Run and
validate your full pipeline, or select jobs and workflows to validate
individually. View the results of your test runs in the Pipelines Panel or in
the CircleCI web app, just the same as any other pipeline.

Prerequisites

v2.0 or higher of the CircleCI VS Code extension
A CircleCI account integrated through the GitHub OAuth app, or Bitbucket. To
find out which GitHub account type you have, check
this docs page.
Your org must have opted-in to this feature through Organization Settings. You
may need to ask your org admin to do so for you. See the section Feature
controls below for more details.
Your project must not make use of
dynamic configuration. This
feature is disabled for projects that use dynamic configuration.

NOTE: Unversioned config in CircleCI indicates that the
.circleci/config.yml on the branch where the pipeline is running is ignored,
and instead, the configuration file is overridden by a custom configuration file
passed as a parameter. The term “unversioned” refers to the fact the config file
is not versioned in the VCS. It is, however, stored in CircleCI along with the
pipeline, and it is available at any time in the CircleCI web app.

Please use caution when running pipelines with unversioned configuration, and take care to ensure no jobs with unintended effects are included in the run. For more details, see the section Security Implications below. 

Access to this feature is controlled by an opt-in setting which only organization admins can control. Once your organization has opted-in, you can opt-out for each individual project. For more details, see the section Feature-controls below.

Steps
The following steps show how to test run a pipeline from the VS Code extension:

Open VS Code and select the CircleCI logo in the sidebar. The Pipelines
and Run panels will be visible
Expand the Run panel to view your projects.
For each project, there is a button to trigger the config test run, and check
boxes for each workflow and job for you to choose which parts of your config
you want to run. Select your options, and click icon:play[]. Any local change
you make to your .circleci/config.yml file will be included in the test
run.
The pipeline is now visible in your dashboard in the CircleCI web app, at
app.circleci.com/pipelines/, and the
Pipelines Panel in the VS Code extension.

Feature controls
The ability to trigger pipelines from VS Code can be controlled at the org
level and at the project level.

Opt-in organization level setting. This can be changed only by
organization admins, and overrides project settings.
Setting location:
Organization Settings > Advanced > Allow triggering pipelines with unversioned config
in the Web App.

Opt-out project level setting.
Setting location:
Project Settings > VS Code integration > Allow triggering pipelines with unversioned config
in the Web App.


Security Implications
Running pipelines with unversioned config can cause security vulnerabilities.
Before enabling this feature, please acknowledge the risks outlined in the
official Docs.

Troubleshooting
Here are some frequently encountered issues, and some clarifications on each of
them.

“Your project could not be detected because no workspace is currently open”
You can fix this issue by opening a folder or workspace. Alternatively, you
can select to follow a CircleCI project manually from the Settings page.

The following errors concern the ability of the extension to link your
workspace to a Git repository.

“Your project could not be detected because we couldn’t find a Git repository associated with this workspace”
“Your project could not be detected because we were unable to get the list of git remotes”
“Your project could not be detected because we could not find default remote of your Git repository”
“Your project could not be detected because we were unable to get the URL of the Git remote XYZ”

When any of these errors occur, you might want to check that your workspace
has a valid Git remote URL. You can also fix this issue by selecting to follow
a CircleCI project manually from the Settings page.

“Your project could not be detected because CircleCI does not know this project”
This error indicates that the repository associated with your workspace
doesn’t appear to be a CircleCI project. If this is unexpected, verify the Git
remote URL associated with your repository, and ensure that you see this
project on the CircleCI web app. You can also address this issue by selecting
to follow a CircleCI project manually from the Settings page.

“Your project could not be detected because you don't follow this project on CircleCI”
When you see this error, you might want to visit the
Projects page on the CircleCI app
and ensure that you “follow” the project associated with this workspace.

“connection to server is erroring. Shutting down server”
This message indicates that the CircleCI Language Server has crashed. This
might be caused by an unexpected parsing error. For this reason, it is likely
that this issue will always occur on the same file. If you identify a file
that causes this error, it would be helpful if you could inform us at XXXXXX
(in the future on the LS open source repo)

When interacting with pipelines, workflows and jobs, you might see the
following errors.

“Cannot refresh pipelines: [runtime error message]”
“Download failed [runtime error message”’
“Cannot rerun workflow because: [runtime error message]”
“Job approval failed: [runtime error message]”

Please keep in mind that one of the causes for any of the above error messages
could be network issues. If you see any of these messages repeatedly, we
recommend you check your internet connection.

The following errors should never occur. Should you see any of them and be
able to reproduce them appearing, it would be helpful if you could report this
to us.

“Target entity can not be cancelled because it is not a workflow / job”
“Your project is not set up”
“Can not cancel your job because it has no job number”



Need support?
How to contact us
If you find any bugs with this extension or want to provide feedback, you can
contact us at
cci-vscode-feedback@circleci.com.
Documentation
You can find more information about CircleCI on our
official documentation.
How to contribute
The Language Server upon which the Conifg Helper is based is Open Source. If you
would like to contribute to the project, feel free to open a PR or get in touch
with us through the
circleci-yaml-language-server repository.
Additional resources
Data and Telemetry
The CircleCI VS Code extension collects usage data for product improvement
purposes, respecting the isTelemetryEnabled and telemetry.telemetryLevel
settings provided by VS Code.
It can be opted out through the VS Code settings page.
Privacy Policy
By signing in to this extension, you agree to the
CircleCI Privacy Policy.
Acknowledgements
This project was made possible by the community surrounding it. You can find
more information about the people and projects which contributed to this
extension in the file CREDITS.md.
We were also inspired by the great work done by community-built extensions:

Jody's Extension for CircleCI
CircleCI Status
vscode-circleci
circleci-conig-validator
Local-CI


© 2023 Circle Internet Services, Inc.\nCircleCICircleCIcircleci.com |  85,877 installs |  (19) | FreeThe official CircleCI extension to create and manage your CI/CD pipelinesInstallationLaunch VS Code Quick Open (Ctrl+P), paste the following command, and press enter.CopyCopied to clipboardMore InfoOverviewVersion HistoryQ & ARating & ReviewThe official CircleCI VS Code extension is a new way to interact with CircleCI.
This extension provides an interface to visualize and manage CircleCI pipelines
directly from your IDE, as well as providing contextual help when creating,
modifying and editing CircleCI YAML config files. This way, it avoids expensive
context-switching between VS Code and your browser.
More practically, this extension allows you to:

Authenticate and connect VS Code to CircleCI
Browse and interact with your pipelines. Available actions include

Viewing pipelines, workflows, and jobs statuses
Viewing test outputs
Browsing job logs
Downloading artifacts
Approving jobs
Re-running builds
Debugging jobs with SSH


Be alerted through notifications when your workflows change status or need
your attention
Access in-file support when editing CircleCI YAML configuration files,
including:

Syntax validation
Syntax highlighting
Go-to-definition and go-to-reference
On-hover documentation and usage hints
Autocompletion


Launch commands to validate config files statically, or against your org
policy


    

Getting started
It’s easy to get started with CircleCI for VS Code.

Install the extension
You can install the CircleCI extension from within VS Code, or download it
from the marketplace.
⚠️ This extension is compatible with VS Code versions 1.85 or above.

Authenticate into CircleCI
Open the CircleCI Panel by clicking on the CircleCI icon on the activity bar
on the left of your screen, then click on “Log in”.
   
    

You will be prompted to enter a
Personal API Token. If you
don't have one, you can generate a new one for this purpose.
If you are an Enterprise customer, make sure to check the box and enter your
self-hosted server URL.

Setup your project
If your VS Code workspace contains one or more CircleCI projects, the
extension will detect them automatically, and the Pipelines Panel will be
populated with your most recent pipelines.
If no project is detected, open the settings page (through the VS Code
command CircleCI: Open Settings, or by clicking on the settings icon (⚙️)
at the top of the Pipelines Panel), and select your projects manually.
Please note that your manual selection will only be persisted if no projects
are detected automatically.
   ⚠️ Automatic project detection does not work for GitLab projects. Please select your project manually from the Settings page.





Configure your Pipelines Panel
By default, your Pipelines Panel will display all the latest pipelines run on
your project. However, you can configure it to show you only the pipelines
you are interested in.
All configurations are available in the Settings page, which you can open
with the command CircleCI: Open Settings or by clicking on the settings
icon (⚙️) at the top of the Pipelines Panel.
Specifically, you can choose to follow:

Only your pipelines, or those authored by anyone
All branches, only your current branch, or a specific branch. You can also
select the checkbox “Always display default branch”
Only pipelines that include workflows and jobs with specific statuses.


    


Configure notifications
You can set up pop-up notifications to warn you when a workflow in your
Pipelines Panel has changed status.
 
   
 
By default, you will receive a pop-up notification every time one of the
workflows in your Pipelines Panel enters a failing status, or needs your
approval.
If you wish to alter these defaults, you can:

Mute notifications (a toggle button to change this setting is also
available at the top of the Pipelines Panel)



Configure which workflow status changes you want to be notified about

Please note that you can only be notified about workflows that appear in your
Pipelines Panel.
 
     
 


The Pipelines Panel
The Pipelines Panel lists all CircleCI projects detected in your workspace. For
each project, it shows the most recent pipelines, jobs and workflows, and lets
you monitor their status and interact with them.

    

For some tree objects, you can perform actions by clicking on the icons which
appear when you hover over the item.
Project
Projects are the top level tree items, and they contain your pipelines.

If you don't follow a project, you can also use the panel to follow it.
Pipeline
Pipelines
are nested under projects. They are the CircleCI unit of change, and they
contain your workflows.

Workflow
Workflows
are nested under each Pipeline, and contain Jobs. Hovering over a Workflow lets
you:

Open in browser, to view workflow details in the CircleCI app, on your default
web browser
Rerun workflow from start, to re-triggered the entire workflow
Rerun workflow from failed, to re-triggered the workflow starting from the
first failed job

Job
Jobs
are nested under each Workflow, and can contain Tests and Artifacts. Hovering
over a Job lets you:

Approve the job (only if the job is on hold)
Cancel the job (only if the job is running)
Rerun the job with SSH (you can read more about this functionality in a later
section)
View job details


    

By expanding a Job, you can also:

Load tests, if you have configured your tests to upload test results to
CircleCI. Tests that CircleCI has detected as flaky will be prefaced by the
indication [FLAKY].
Load artifacts, to load any artifacts created by the Job. Once the
artifacts are loaded, you can download them by clicking on them.

Re-run with SSH
You can re-run jobs with SSH directly from VS Code, either:

through the Job Details page, by clicking on the green button on the top
right:



or by clicking on the action icon next to the job name in the Pipelines Panel.


    

In both cases, you will be presented with two options:

Open SSH session in terminal


    


Open SSH session in remote VS Code window

This feature requires the official VS Code extension
Remote - SSH.
You can find more information on Remote Development using SSH in VS Code
directly in the
VS Code docs.




    

To rerun your job with SSH, you will first have to set the path to your Github
or Bitbucket SSH key. The first time you attempt to re-run with SSH, the
extension will guide you to select the path of the relevant SSH key. However, if
you miss this step or want to modify it at a later time, you can do so from the
dedicated section of the settings page:

    

If the job you want to rerun uses parallelism, you will be able to select which
job you want to SSH into.

You can read more about debugging with SSH on CircleCI
in the Docs.

Status Bar
The Status Bar provides summary information about the state of the CircleCI
extension, your project and your most recent workflow.

    

Specifically, you might see the following statuses:

Not logged in - when clicking on the status bar, the login page will open
No project - when clicking on the status bar, the settings page will open
so you can select a project manually
Success / On hold / Failed, and similar workflow statuses - THIS refers to
the status of the top pipeline in your panel. When clicking on the status bar,
the relative workflow will come into focus on the CircleCI Pipelines Panel.
No internet - when your internet connection is lost

Config Helper
This extension provides in-file assistance with writing, editing and navigating
CircleCI Configuration files.
It is based on a CircleCI-specific Language Server, and offers:

Rich code navigation through “go-to-definition” and “go-to-reference”
commands. This is especially convenient when working on large configuration
files, to verify the definition of custom jobs, executors parameters, or in
turn view where any of them are referenced in the file. Assisted code
navigation also works for Orbs, allowing to explore their definition directly
in the IDE when using the go-to-definition feature on an orb-defined command
or parameter.


    


Contextual documentation and usage hints when hovering on specific keys,
so as to avoid having to continuously switch to the browser to check the docs
whenever you are editing your YAML config. Links to the official CircleCI
documentation are also provided on hover - for easier navigation.


    


Syntax validation - which makes it much easier to identify typos,
incorrect use of parameters, incomplete definitions, wrong types, invalid or
deprecated machine versions, etc.


    


Usage warnings - which can help identify deprecated parameters, unused
jobs or executors, or missing keys that prevent you from taking advantage of
CircleCI’s full capabilities


    


Auto completion, available both on built-in keys and parameters and on
user-defined variables


    

You can access a full overview of all errors, warnings and hints proposed by the
Config Helper in the Problems tab of VS Code.

    


The Config Helper is based on a dedicated Language Server for CircleCI YAML
files, which is Open Source. You can view its source code, contribute and add
issues directly on the project repository:
circleci-yaml-language-server.

Config validation commands
The extension also provides two commands that help you statically validate your
YAML config files without having to run a pipeline.

    


Validate current configuration file
Corresponds to the CLI command
circleci config validate,
and verifies statically that the config file is well formed. Please note that
this command only validates this file for structure and syntax errors, but
not for semantic error (e.g. this job does not exist).

Validate current configuration file against org policy
Corresponds to the CLI command
circleci policy decide,
and verifies that the configuration file complies with your organization
policies - if any are set.

Please note that this command is only available to Scale customers


View compiled version of current configuration file
This command resolves all orb references in your config file, and shows you
the full-length version of your config.


All these commands can also be invoked:

by right-clicking on a CircleCI YAML file:


    


by clicking on the CircleCI button on the top right corner of the page, when
focusing on a CircleCI YAML file. Please note that the button will not be
visible if you are editing a different file.


    

🆕 Test run your config (Open Preview)

NOTE: The ability to trigger a pipeline from VS Code with a unversioned
config is currently in Open Preview, and only available for projects
integrated through the GitHub OAuth app, or Bitbucket. To find out
which GitHub account type you have, see the
documentation about GitHub OAuth app integration.

Trigger pipelines from VS Code to iterate on your CircleCI config without
committing your trial and error changes to your version control system. Run and
validate your full pipeline, or select jobs and workflows to validate
individually. View the results of your test runs in the Pipelines Panel or in
the CircleCI web app, just the same as any other pipeline.

Prerequisites

v2.0 or higher of the CircleCI VS Code extension
A CircleCI account integrated through the GitHub OAuth app, or Bitbucket. To
find out which GitHub account type you have, check
this docs page.
Your org must have opted-in to this feature through Organization Settings. You
may need to ask your org admin to do so for you. See the section Feature
controls below for more details.
Your project must not make use of
dynamic configuration. This
feature is disabled for projects that use dynamic configuration.

NOTE: Unversioned config in CircleCI indicates that the
.circleci/config.yml on the branch where the pipeline is running is ignored,
and instead, the configuration file is overridden by a custom configuration file
passed as a parameter. The term “unversioned” refers to the fact the config file
is not versioned in the VCS. It is, however, stored in CircleCI along with the
pipeline, and it is available at any time in the CircleCI web app.

Please use caution when running pipelines with unversioned configuration, and take care to ensure no jobs with unintended effects are included in the run. For more details, see the section Security Implications below. 

Access to this feature is controlled by an opt-in setting which only organization admins can control. Once your organization has opted-in, you can opt-out for each individual project. For more details, see the section Feature-controls below.

Steps
The following steps show how to test run a pipeline from the VS Code extension:

Open VS Code and select the CircleCI logo in the sidebar. The Pipelines
and Run panels will be visible
Expand the Run panel to view your projects.
For each project, there is a button to trigger the config test run, and check
boxes for each workflow and job for you to choose which parts of your config
you want to run. Select your options, and click icon:play[]. Any local change
you make to your .circleci/config.yml file will be included in the test
run.
The pipeline is now visible in your dashboard in the CircleCI web app, at
app.circleci.com/pipelines/, and the
Pipelines Panel in the VS Code extension.

Feature controls
The ability to trigger pipelines from VS Code can be controlled at the org
level and at the project level.

Opt-in organization level setting. This can be changed only by
organization admins, and overrides project settings.
Setting location:
Organization Settings > Advanced > Allow triggering pipelines with unversioned config
in the Web App.

Opt-out project level setting.
Setting location:
Project Settings > VS Code integration > Allow triggering pipelines with unversioned config
in the Web App.


Security Implications
Running pipelines with unversioned config can cause security vulnerabilities.
Before enabling this feature, please acknowledge the risks outlined in the
official Docs.

Troubleshooting
Here are some frequently encountered issues, and some clarifications on each of
them.

“Your project could not be detected because no workspace is currently open”
You can fix this issue by opening a folder or workspace. Alternatively, you
can select to follow a CircleCI project manually from the Settings page.

The following errors concern the ability of the extension to link your
workspace to a Git repository.

“Your project could not be detected because we couldn’t find a Git repository associated with this workspace”
“Your project could not be detected because we were unable to get the list of git remotes”
“Your project could not be detected because we could not find default remote of your Git repository”
“Your project could not be detected because we were unable to get the URL of the Git remote XYZ”

When any of these errors occur, you might want to check that your workspace
has a valid Git remote URL. You can also fix this issue by selecting to follow
a CircleCI project manually from the Settings page.

“Your project could not be detected because CircleCI does not know this project”
This error indicates that the repository associated with your workspace
doesn’t appear to be a CircleCI project. If this is unexpected, verify the Git
remote URL associated with your repository, and ensure that you see this
project on the CircleCI web app. You can also address this issue by selecting
to follow a CircleCI project manually from the Settings page.

“Your project could not be detected because you don't follow this project on CircleCI”
When you see this error, you might want to visit the
Projects page on the CircleCI app
and ensure that you “follow” the project associated with this workspace.

“connection to server is erroring. Shutting down server”
This message indicates that the CircleCI Language Server has crashed. This
might be caused by an unexpected parsing error. For this reason, it is likely
that this issue will always occur on the same file. If you identify a file
that causes this error, it would be helpful if you could inform us at XXXXXX
(in the future on the LS open source repo)

When interacting with pipelines, workflows and jobs, you might see the
following errors.

“Cannot refresh pipelines: [runtime error message]”
“Download failed [runtime error message”’
“Cannot rerun workflow because: [runtime error message]”
“Job approval failed: [runtime error message]”

Please keep in mind that one of the causes for any of the above error messages
could be network issues. If you see any of these messages repeatedly, we
recommend you check your internet connection.

The following errors should never occur. Should you see any of them and be
able to reproduce them appearing, it would be helpful if you could report this
to us.

“Target entity can not be cancelled because it is not a workflow / job”
“Your project is not set up”
“Can not cancel your job because it has no job number”



Need support?
How to contact us
If you find any bugs with this extension or want to provide feedback, you can
contact us at
cci-vscode-feedback@circleci.com.
Documentation
You can find more information about CircleCI on our
official documentation.
How to contribute
The Language Server upon which the Conifg Helper is based is Open Source. If you
would like to contribute to the project, feel free to open a PR or get in touch
with us through the
circleci-yaml-language-server repository.
Additional resources
Data and Telemetry
The CircleCI VS Code extension collects usage data for product improvement
purposes, respecting the isTelemetryEnabled and telemetry.telemetryLevel
settings provided by VS Code.
It can be opted out through the VS Code settings page.
Privacy Policy
By signing in to this extension, you agree to the
CircleCI Privacy Policy.
Acknowledgements
This project was made possible by the community surrounding it. You can find
more information about the people and projects which contributed to this
extension in the file CREDITS.md.
We were also inspired by the great work done by community-built extensions:

Jody's Extension for CircleCI
CircleCI Status
vscode-circleci
circleci-conig-validator
Local-CI


© 2023 Circle Internet Services, Inc.\nCircleCICircleCIcircleci.com |  85,877 installs |  (19) | FreeThe official CircleCI extension to create and manage your CI/CD pipelinesInstallationLaunch VS Code Quick Open (Ctrl+P), paste the following command, and press enter.CopyCopied to clipboardMore InfoOverviewVersion HistoryQ & ARating & ReviewThe official CircleCI VS Code extension is a new way to interact with CircleCI.
This extension provides an interface to visualize and manage CircleCI pipelines
directly from your IDE, as well as providing contextual help when creating,
modifying and editing CircleCI YAML config files. This way, it avoids expensive
context-switching between VS Code and your browser.
More practically, this extension allows you to:

Authenticate and connect VS Code to CircleCI
Browse and interact with your pipelines. Available actions include

Viewing pipelines, workflows, and jobs statuses
Viewing test outputs
Browsing job logs
Downloading artifacts
Approving jobs
Re-running builds
Debugging jobs with SSH


Be alerted through notifications when your workflows change status or need
your attention
Access in-file support when editing CircleCI YAML configuration files,
including:

Syntax validation
Syntax highlighting
Go-to-definition and go-to-reference
On-hover documentation and usage hints
Autocompletion


Launch commands to validate config files statically, or against your org
policy


    

Getting started
It’s easy to get started with CircleCI for VS Code.

Install the extension
You can install the CircleCI extension from within VS Code, or download it
from the marketplace.
⚠️ This extension is compatible with VS Code versions 1.85 or above.

Authenticate into CircleCI
Open the CircleCI Panel by clicking on the CircleCI icon on the activity bar
on the left of your screen, then click on “Log in”.
   
    

You will be prompted to enter a
Personal API Token. If you
don't have one, you can generate a new one for this purpose.
If you are an Enterprise customer, make sure to check the box and enter your
self-hosted server URL.

Setup your project
If your VS Code workspace contains one or more CircleCI projects, the
extension will detect them automatically, and the Pipelines Panel will be
populated with your most recent pipelines.
If no project is detected, open the settings page (through the VS Code
command CircleCI: Open Settings, or by clicking on the settings icon (⚙️)
at the top of the Pipelines Panel), and select your projects manually.
Please note that your manual selection will only be persisted if no projects
are detected automatically.
   ⚠️ Automatic project detection does not work for GitLab projects. Please select your project manually from the Settings page.





Configure your Pipelines Panel
By default, your Pipelines Panel will display all the latest pipelines run on
your project. However, you can configure it to show you only the pipelines
you are interested in.
All configurations are available in the Settings page, which you can open
with the command CircleCI: Open Settings or by clicking on the settings
icon (⚙️) at the top of the Pipelines Panel.
Specifically, you can choose to follow:

Only your pipelines, or those authored by anyone
All branches, only your current branch, or a specific branch. You can also
select the checkbox “Always display default branch”
Only pipelines that include workflows and jobs with specific statuses.


    


Configure notifications
You can set up pop-up notifications to warn you when a workflow in your
Pipelines Panel has changed status.
 
   
 
By default, you will receive a pop-up notification every time one of the
workflows in your Pipelines Panel enters a failing status, or needs your
approval.
If you wish to alter these defaults, you can:

Mute notifications (a toggle button to change this setting is also
available at the top of the Pipelines Panel)



Configure which workflow status changes you want to be notified about

Please note that you can only be notified about workflows that appear in your
Pipelines Panel.
 
     
 


The Pipelines Panel
The Pipelines Panel lists all CircleCI projects detected in your workspace. For
each project, it shows the most recent pipelines, jobs and workflows, and lets
you monitor their status and interact with them.

    

For some tree objects, you can perform actions by clicking on the icons which
appear when you hover over the item.
Project
Projects are the top level tree items, and they contain your pipelines.

If you don't follow a project, you can also use the panel to follow it.
Pipeline
Pipelines
are nested under projects. They are the CircleCI unit of change, and they
contain your workflows.

Workflow
Workflows
are nested under each Pipeline, and contain Jobs. Hovering over a Workflow lets
you:

Open in browser, to view workflow details in the CircleCI app, on your default
web browser
Rerun workflow from start, to re-triggered the entire workflow
Rerun workflow from failed, to re-triggered the workflow starting from the
first failed job

Job
Jobs
are nested under each Workflow, and can contain Tests and Artifacts. Hovering
over a Job lets you:

Approve the job (only if the job is on hold)
Cancel the job (only if the job is running)
Rerun the job with SSH (you can read more about this functionality in a later
section)
View job details


    

By expanding a Job, you can also:

Load tests, if you have configured your tests to upload test results to
CircleCI. Tests that CircleCI has detected as flaky will be prefaced by the
indication [FLAKY].
Load artifacts, to load any artifacts created by the Job. Once the
artifacts are loaded, you can download them by clicking on them.

Re-run with SSH
You can re-run jobs with SSH directly from VS Code, either:

through the Job Details page, by clicking on the green button on the top
right:



or by clicking on the action icon next to the job name in the Pipelines Panel.


    

In both cases, you will be presented with two options:

Open SSH session in terminal


    


Open SSH session in remote VS Code window

This feature requires the official VS Code extension
Remote - SSH.
You can find more information on Remote Development using SSH in VS Code
directly in the
VS Code docs.




    

To rerun your job with SSH, you will first have to set the path to your Github
or Bitbucket SSH key. The first time you attempt to re-run with SSH, the
extension will guide you to select the path of the relevant SSH key. However, if
you miss this step or want to modify it at a later time, you can do so from the
dedicated section of the settings page:

    

If the job you want to rerun uses parallelism, you will be able to select which
job you want to SSH into.

You can read more about debugging with SSH on CircleCI
in the Docs.

Status Bar
The Status Bar provides summary information about the state of the CircleCI
extension, your project and your most recent workflow.

    

Specifically, you might see the following statuses:

Not logged in - when clicking on the status bar, the login page will open
No project - when clicking on the status bar, the settings page will open
so you can select a project manually
Success / On hold / Failed, and similar workflow statuses - THIS refers to
the status of the top pipeline in your panel. When clicking on the status bar,
the relative workflow will come into focus on the CircleCI Pipelines Panel.
No internet - when your internet connection is lost

Config Helper
This extension provides in-file assistance with writing, editing and navigating
CircleCI Configuration files.
It is based on a CircleCI-specific Language Server, and offers:

Rich code navigation through “go-to-definition” and “go-to-reference”
commands. This is especially convenient when working on large configuration
files, to verify the definition of custom jobs, executors parameters, or in
turn view where any of them are referenced in the file. Assisted code
navigation also works for Orbs, allowing to explore their definition directly
in the IDE when using the go-to-definition feature on an orb-defined command
or parameter.


    


Contextual documentation and usage hints when hovering on specific keys,
so as to avoid having to continuously switch to the browser to check the docs
whenever you are editing your YAML config. Links to the official CircleCI
documentation are also provided on hover - for easier navigation.


    


Syntax validation - which makes it much easier to identify typos,
incorrect use of parameters, incomplete definitions, wrong types, invalid or
deprecated machine versions, etc.


    


Usage warnings - which can help identify deprecated parameters, unused
jobs or executors, or missing keys that prevent you from taking advantage of
CircleCI’s full capabilities


    


Auto completion, available both on built-in keys and parameters and on
user-defined variables


    

You can access a full overview of all errors, warnings and hints proposed by the
Config Helper in the Problems tab of VS Code.

    


The Config Helper is based on a dedicated Language Server for CircleCI YAML
files, which is Open Source. You can view its source code, contribute and add
issues directly on the project repository:
circleci-yaml-language-server.

Config validation commands
The extension also provides two commands that help you statically validate your
YAML config files without having to run a pipeline.

    


Validate current configuration file
Corresponds to the CLI command
circleci config validate,
and verifies statically that the config file is well formed. Please note that
this command only validates this file for structure and syntax errors, but
not for semantic error (e.g. this job does not exist).

Validate current configuration file against org policy
Corresponds to the CLI command
circleci policy decide,
and verifies that the configuration file complies with your organization
policies - if any are set.

Please note that this command is only available to Scale customers


View compiled version of current configuration file
This command resolves all orb references in your config file, and shows you
the full-length version of your config.


All these commands can also be invoked:

by right-clicking on a CircleCI YAML file:


    


by clicking on the CircleCI button on the top right corner of the page, when
focusing on a CircleCI YAML file. Please note that the button will not be
visible if you are editing a different file.


    

🆕 Test run your config (Open Preview)

NOTE: The ability to trigger a pipeline from VS Code with a unversioned
config is currently in Open Preview, and only available for projects
integrated through the GitHub OAuth app, or Bitbucket. To find out
which GitHub account type you have, see the
documentation about GitHub OAuth app integration.

Trigger pipelines from VS Code to iterate on your CircleCI config without
committing your trial and error changes to your version control system. Run and
validate your full pipeline, or select jobs and workflows to validate
individually. View the results of your test runs in the Pipelines Panel or in
the CircleCI web app, just the same as any other pipeline.

Prerequisites

v2.0 or higher of the CircleCI VS Code extension
A CircleCI account integrated through the GitHub OAuth app, or Bitbucket. To
find out which GitHub account type you have, check
this docs page.
Your org must have opted-in to this feature through Organization Settings. You
may need to ask your org admin to do so for you. See the section Feature
controls below for more details.
Your project must not make use of
dynamic configuration. This
feature is disabled for projects that use dynamic configuration.

NOTE: Unversioned config in CircleCI indicates that the
.circleci/config.yml on the branch where the pipeline is running is ignored,
and instead, the configuration file is overridden by a custom configuration file
passed as a parameter. The term “unversioned” refers to the fact the config file
is not versioned in the VCS. It is, however, stored in CircleCI along with the
pipeline, and it is available at any time in the CircleCI web app.

Please use caution when running pipelines with unversioned configuration, and take care to ensure no jobs with unintended effects are included in the run. For more details, see the section Security Implications below. 

Access to this feature is controlled by an opt-in setting which only organization admins can control. Once your organization has opted-in, you can opt-out for each individual project. For more details, see the section Feature-controls below.

Steps
The following steps show how to test run a pipeline from the VS Code extension:

Open VS Code and select the CircleCI logo in the sidebar. The Pipelines
and Run panels will be visible
Expand the Run panel to view your projects.
For each project, there is a button to trigger the config test run, and check
boxes for each workflow and job for you to choose which parts of your config
you want to run. Select your options, and click icon:play[]. Any local change
you make to your .circleci/config.yml file will be included in the test
run.
The pipeline is now visible in your dashboard in the CircleCI web app, at
app.circleci.com/pipelines/, and the
Pipelines Panel in the VS Code extension.

Feature controls
The ability to trigger pipelines from VS Code can be controlled at the org
level and at the project level.

Opt-in organization level setting. This can be changed only by
organization admins, and overrides project settings.
Setting location:
Organization Settings > Advanced > Allow triggering pipelines with unversioned config
in the Web App.

Opt-out project level setting.
Setting location:
Project Settings > VS Code integration > Allow triggering pipelines with unversioned config
in the Web App.


Security Implications
Running pipelines with unversioned config can cause security vulnerabilities.
Before enabling this feature, please acknowledge the risks outlined in the
official Docs.

Troubleshooting
Here are some frequently encountered issues, and some clarifications on each of
them.

“Your project could not be detected because no workspace is currently open”
You can fix this issue by opening a folder or workspace. Alternatively, you
can select to follow a CircleCI project manually from the Settings page.

The following errors concern the ability of the extension to link your
workspace to a Git repository.

“Your project could not be detected because we couldn’t find a Git repository associated with this workspace”
“Your project could not be detected because we were unable to get the list of git remotes”
“Your project could not be detected because we could not find default remote of your Git repository”
“Your project could not be detected because we were unable to get the URL of the Git remote XYZ”

When any of these errors occur, you might want to check that your workspace
has a valid Git remote URL. You can also fix this issue by selecting to follow
a CircleCI project manually from the Settings page.

“Your project could not be detected because CircleCI does not know this project”
This error indicates that the repository associated with your workspace
doesn’t appear to be a CircleCI project. If this is unexpected, verify the Git
remote URL associated with your repository, and ensure that you see this
project on the CircleCI web app. You can also address this issue by selecting
to follow a CircleCI project manually from the Settings page.

“Your project could not be detected because you don't follow this project on CircleCI”
When you see this error, you might want to visit the
Projects page on the CircleCI app
and ensure that you “follow” the project associated with this workspace.

“connection to server is erroring. Shutting down server”
This message indicates that the CircleCI Language Server has crashed. This
might be caused by an unexpected parsing error. For this reason, it is likely
that this issue will always occur on the same file. If you identify a file
that causes this error, it would be helpful if you could inform us at XXXXXX
(in the future on the LS open source repo)

When interacting with pipelines, workflows and jobs, you might see the
following errors.

“Cannot refresh pipelines: [runtime error message]”
“Download failed [runtime error message”’
“Cannot rerun workflow because: [runtime error message]”
“Job approval failed: [runtime error message]”

Please keep in mind that one of the causes for any of the above error messages
could be network issues. If you see any of these messages repeatedly, we
recommend you check your internet connection.

The following errors should never occur. Should you see any of them and be
able to reproduce them appearing, it would be helpful if you could report this
to us.

“Target entity can not be cancelled because it is not a workflow / job”
“Your project is not set up”
“Can not cancel your job because it has no job number”



Need support?
How to contact us
If you find any bugs with this extension or want to provide feedback, you can
contact us at
cci-vscode-feedback@circleci.com.
Documentation
You can find more information about CircleCI on our
official documentation.
How to contribute
The Language Server upon which the Conifg Helper is based is Open Source. If you
would like to contribute to the project, feel free to open a PR or get in touch
with us through the
circleci-yaml-language-server repository.
Additional resources
Data and Telemetry
The CircleCI VS Code extension collects usage data for product improvement
purposes, respecting the isTelemetryEnabled and telemetry.telemetryLevel
settings provided by VS Code.
It can be opted out through the VS Code settings page.
Privacy Policy
By signing in to this extension, you agree to the
CircleCI Privacy Policy.
Acknowledgements
This project was made possible by the community surrounding it. You can find
more information about the people and projects which contributed to this
extension in the file CREDITS.md.
We were also inspired by the great work done by community-built extensions:

Jody's Extension for CircleCI
CircleCI Status
vscode-circleci
circleci-conig-validator
Local-CI


© 2023 Circle Internet Services, Inc.\nCircleCICircleCIcircleci.com |  85,877 installs |  (19) | FreeThe official CircleCI extension to create and manage your CI/CD pipelinesInstallationLaunch VS Code Quick Open (Ctrl+P), paste the following command, and press enter.CopyCopied to clipboardMore Info\nCircleCICircleCIcircleci.com |  85,877 installs |  (19) | FreeThe official CircleCI extension to create and manage your CI/CD pipelinesInstallationLaunch VS Code Quick Open (Ctrl+P), paste the following command, and press enter.CopyCopied to clipboardMore Info\nCircleCICircleCIcircleci.com |  85,877 installs |  (19) | FreeThe official CircleCI extension to create and manage your CI/CD pipelinesInstallationLaunch VS Code Quick Open (Ctrl+P), paste the following command, and press enter.CopyCopied to clipboardMore Info\nCircleCICircleCIcircleci.com |  85,877 installs |  (19) | FreeThe official CircleCI extension to create and manage your CI/CD pipelinesInstallationLaunch VS Code Quick Open (Ctrl+P), paste the following command, and press enter.CopyCopied to clipboardMore Info\nCircleCIcircleci.com |  85,877 installs |  (19) | Free\nThe official CircleCI extension to create and manage your CI/CD pipelines\nInstallationLaunch VS Code Quick Open (Ctrl+P), paste the following command, and press enter.CopyCopied to clipboardMore Info\nInstallationLaunch VS Code Quick Open (Ctrl+P), paste the following command, and press enter.CopyCopied to clipboardMore Info\nLaunch VS Code Quick Open (Ctrl+P), paste the following command, and press enter.\nCopyCopied to clipboardMore Info\nOverviewVersion HistoryQ & ARating & ReviewThe official CircleCI VS Code extension is a new way to interact with CircleCI.
This extension provides an interface to visualize and manage CircleCI pipelines
directly from your IDE, as well as providing contextual help when creating,
modifying and editing CircleCI YAML config files. This way, it avoids expensive
context-switching between VS Code and your browser.
More practically, this extension allows you to:

Authenticate and connect VS Code to CircleCI
Browse and interact with your pipelines. Available actions include

Viewing pipelines, workflows, and jobs statuses
Viewing test outputs
Browsing job logs
Downloading artifacts
Approving jobs
Re-running builds
Debugging jobs with SSH


Be alerted through notifications when your workflows change status or need
your attention
Access in-file support when editing CircleCI YAML configuration files,
including:

Syntax validation
Syntax highlighting
Go-to-definition and go-to-reference
On-hover documentation and usage hints
Autocompletion


Launch commands to validate config files statically, or against your org
policy


    

Getting started
It’s easy to get started with CircleCI for VS Code.

Install the extension
You can install the CircleCI extension from within VS Code, or download it
from the marketplace.
⚠️ This extension is compatible with VS Code versions 1.85 or above.

Authenticate into CircleCI
Open the CircleCI Panel by clicking on the CircleCI icon on the activity bar
on the left of your screen, then click on “Log in”.
   
    

You will be prompted to enter a
Personal API Token. If you
don't have one, you can generate a new one for this purpose.
If you are an Enterprise customer, make sure to check the box and enter your
self-hosted server URL.

Setup your project
If your VS Code workspace contains one or more CircleCI projects, the
extension will detect them automatically, and the Pipelines Panel will be
populated with your most recent pipelines.
If no project is detected, open the settings page (through the VS Code
command CircleCI: Open Settings, or by clicking on the settings icon (⚙️)
at the top of the Pipelines Panel), and select your projects manually.
Please note that your manual selection will only be persisted if no projects
are detected automatically.
   ⚠️ Automatic project detection does not work for GitLab projects. Please select your project manually from the Settings page.





Configure your Pipelines Panel
By default, your Pipelines Panel will display all the latest pipelines run on
your project. However, you can configure it to show you only the pipelines
you are interested in.
All configurations are available in the Settings page, which you can open
with the command CircleCI: Open Settings or by clicking on the settings
icon (⚙️) at the top of the Pipelines Panel.
Specifically, you can choose to follow:

Only your pipelines, or those authored by anyone
All branches, only your current branch, or a specific branch. You can also
select the checkbox “Always display default branch”
Only pipelines that include workflows and jobs with specific statuses.


    


Configure notifications
You can set up pop-up notifications to warn you when a workflow in your
Pipelines Panel has changed status.
 
   
 
By default, you will receive a pop-up notification every time one of the
workflows in your Pipelines Panel enters a failing status, or needs your
approval.
If you wish to alter these defaults, you can:

Mute notifications (a toggle button to change this setting is also
available at the top of the Pipelines Panel)



Configure which workflow status changes you want to be notified about

Please note that you can only be notified about workflows that appear in your
Pipelines Panel.
 
     
 


The Pipelines Panel
The Pipelines Panel lists all CircleCI projects detected in your workspace. For
each project, it shows the most recent pipelines, jobs and workflows, and lets
you monitor their status and interact with them.

    

For some tree objects, you can perform actions by clicking on the icons which
appear when you hover over the item.
Project
Projects are the top level tree items, and they contain your pipelines.

If you don't follow a project, you can also use the panel to follow it.
Pipeline
Pipelines
are nested under projects. They are the CircleCI unit of change, and they
contain your workflows.

Workflow
Workflows
are nested under each Pipeline, and contain Jobs. Hovering over a Workflow lets
you:

Open in browser, to view workflow details in the CircleCI app, on your default
web browser
Rerun workflow from start, to re-triggered the entire workflow
Rerun workflow from failed, to re-triggered the workflow starting from the
first failed job

Job
Jobs
are nested under each Workflow, and can contain Tests and Artifacts. Hovering
over a Job lets you:

Approve the job (only if the job is on hold)
Cancel the job (only if the job is running)
Rerun the job with SSH (you can read more about this functionality in a later
section)
View job details


    

By expanding a Job, you can also:

Load tests, if you have configured your tests to upload test results to
CircleCI. Tests that CircleCI has detected as flaky will be prefaced by the
indication [FLAKY].
Load artifacts, to load any artifacts created by the Job. Once the
artifacts are loaded, you can download them by clicking on them.

Re-run with SSH
You can re-run jobs with SSH directly from VS Code, either:

through the Job Details page, by clicking on the green button on the top
right:



or by clicking on the action icon next to the job name in the Pipelines Panel.


    

In both cases, you will be presented with two options:

Open SSH session in terminal


    


Open SSH session in remote VS Code window

This feature requires the official VS Code extension
Remote - SSH.
You can find more information on Remote Development using SSH in VS Code
directly in the
VS Code docs.




    

To rerun your job with SSH, you will first have to set the path to your Github
or Bitbucket SSH key. The first time you attempt to re-run with SSH, the
extension will guide you to select the path of the relevant SSH key. However, if
you miss this step or want to modify it at a later time, you can do so from the
dedicated section of the settings page:

    

If the job you want to rerun uses parallelism, you will be able to select which
job you want to SSH into.

You can read more about debugging with SSH on CircleCI
in the Docs.

Status Bar
The Status Bar provides summary information about the state of the CircleCI
extension, your project and your most recent workflow.

    

Specifically, you might see the following statuses:

Not logged in - when clicking on the status bar, the login page will open
No project - when clicking on the status bar, the settings page will open
so you can select a project manually
Success / On hold / Failed, and similar workflow statuses - THIS refers to
the status of the top pipeline in your panel. When clicking on the status bar,
the relative workflow will come into focus on the CircleCI Pipelines Panel.
No internet - when your internet connection is lost

Config Helper
This extension provides in-file assistance with writing, editing and navigating
CircleCI Configuration files.
It is based on a CircleCI-specific Language Server, and offers:

Rich code navigation through “go-to-definition” and “go-to-reference”
commands. This is especially convenient when working on large configuration
files, to verify the definition of custom jobs, executors parameters, or in
turn view where any of them are referenced in the file. Assisted code
navigation also works for Orbs, allowing to explore their definition directly
in the IDE when using the go-to-definition feature on an orb-defined command
or parameter.


    


Contextual documentation and usage hints when hovering on specific keys,
so as to avoid having to continuously switch to the browser to check the docs
whenever you are editing your YAML config. Links to the official CircleCI
documentation are also provided on hover - for easier navigation.


    


Syntax validation - which makes it much easier to identify typos,
incorrect use of parameters, incomplete definitions, wrong types, invalid or
deprecated machine versions, etc.


    


Usage warnings - which can help identify deprecated parameters, unused
jobs or executors, or missing keys that prevent you from taking advantage of
CircleCI’s full capabilities


    


Auto completion, available both on built-in keys and parameters and on
user-defined variables


    

You can access a full overview of all errors, warnings and hints proposed by the
Config Helper in the Problems tab of VS Code.

    


The Config Helper is based on a dedicated Language Server for CircleCI YAML
files, which is Open Source. You can view its source code, contribute and add
issues directly on the project repository:
circleci-yaml-language-server.

Config validation commands
The extension also provides two commands that help you statically validate your
YAML config files without having to run a pipeline.

    


Validate current configuration file
Corresponds to the CLI command
circleci config validate,
and verifies statically that the config file is well formed. Please note that
this command only validates this file for structure and syntax errors, but
not for semantic error (e.g. this job does not exist).

Validate current configuration file against org policy
Corresponds to the CLI command
circleci policy decide,
and verifies that the configuration file complies with your organization
policies - if any are set.

Please note that this command is only available to Scale customers


View compiled version of current configuration file
This command resolves all orb references in your config file, and shows you
the full-length version of your config.


All these commands can also be invoked:

by right-clicking on a CircleCI YAML file:


    


by clicking on the CircleCI button on the top right corner of the page, when
focusing on a CircleCI YAML file. Please note that the button will not be
visible if you are editing a different file.


    

🆕 Test run your config (Open Preview)

NOTE: The ability to trigger a pipeline from VS Code with a unversioned
config is currently in Open Preview, and only available for projects
integrated through the GitHub OAuth app, or Bitbucket. To find out
which GitHub account type you have, see the
documentation about GitHub OAuth app integration.

Trigger pipelines from VS Code to iterate on your CircleCI config without
committing your trial and error changes to your version control system. Run and
validate your full pipeline, or select jobs and workflows to validate
individually. View the results of your test runs in the Pipelines Panel or in
the CircleCI web app, just the same as any other pipeline.

Prerequisites

v2.0 or higher of the CircleCI VS Code extension
A CircleCI account integrated through the GitHub OAuth app, or Bitbucket. To
find out which GitHub account type you have, check
this docs page.
Your org must have opted-in to this feature through Organization Settings. You
may need to ask your org admin to do so for you. See the section Feature
controls below for more details.
Your project must not make use of
dynamic configuration. This
feature is disabled for projects that use dynamic configuration.

NOTE: Unversioned config in CircleCI indicates that the
.circleci/config.yml on the branch where the pipeline is running is ignored,
and instead, the configuration file is overridden by a custom configuration file
passed as a parameter. The term “unversioned” refers to the fact the config file
is not versioned in the VCS. It is, however, stored in CircleCI along with the
pipeline, and it is available at any time in the CircleCI web app.

Please use caution when running pipelines with unversioned configuration, and take care to ensure no jobs with unintended effects are included in the run. For more details, see the section Security Implications below. 

Access to this feature is controlled by an opt-in setting which only organization admins can control. Once your organization has opted-in, you can opt-out for each individual project. For more details, see the section Feature-controls below.

Steps
The following steps show how to test run a pipeline from the VS Code extension:

Open VS Code and select the CircleCI logo in the sidebar. The Pipelines
and Run panels will be visible
Expand the Run panel to view your projects.
For each project, there is a button to trigger the config test run, and check
boxes for each workflow and job for you to choose which parts of your config
you want to run. Select your options, and click icon:play[]. Any local change
you make to your .circleci/config.yml file will be included in the test
run.
The pipeline is now visible in your dashboard in the CircleCI web app, at
app.circleci.com/pipelines/, and the
Pipelines Panel in the VS Code extension.

Feature controls
The ability to trigger pipelines from VS Code can be controlled at the org
level and at the project level.

Opt-in organization level setting. This can be changed only by
organization admins, and overrides project settings.
Setting location:
Organization Settings > Advanced > Allow triggering pipelines with unversioned config
in the Web App.

Opt-out project level setting.
Setting location:
Project Settings > VS Code integration > Allow triggering pipelines with unversioned config
in the Web App.


Security Implications
Running pipelines with unversioned config can cause security vulnerabilities.
Before enabling this feature, please acknowledge the risks outlined in the
official Docs.

Troubleshooting
Here are some frequently encountered issues, and some clarifications on each of
them.

“Your project could not be detected because no workspace is currently open”
You can fix this issue by opening a folder or workspace. Alternatively, you
can select to follow a CircleCI project manually from the Settings page.

The following errors concern the ability of the extension to link your
workspace to a Git repository.

“Your project could not be detected because we couldn’t find a Git repository associated with this workspace”
“Your project could not be detected because we were unable to get the list of git remotes”
“Your project could not be detected because we could not find default remote of your Git repository”
“Your project could not be detected because we were unable to get the URL of the Git remote XYZ”

When any of these errors occur, you might want to check that your workspace
has a valid Git remote URL. You can also fix this issue by selecting to follow
a CircleCI project manually from the Settings page.

“Your project could not be detected because CircleCI does not know this project”
This error indicates that the repository associated with your workspace
doesn’t appear to be a CircleCI project. If this is unexpected, verify the Git
remote URL associated with your repository, and ensure that you see this
project on the CircleCI web app. You can also address this issue by selecting
to follow a CircleCI project manually from the Settings page.

“Your project could not be detected because you don't follow this project on CircleCI”
When you see this error, you might want to visit the
Projects page on the CircleCI app
and ensure that you “follow” the project associated with this workspace.

“connection to server is erroring. Shutting down server”
This message indicates that the CircleCI Language Server has crashed. This
might be caused by an unexpected parsing error. For this reason, it is likely
that this issue will always occur on the same file. If you identify a file
that causes this error, it would be helpful if you could inform us at XXXXXX
(in the future on the LS open source repo)

When interacting with pipelines, workflows and jobs, you might see the
following errors.

“Cannot refresh pipelines: [runtime error message]”
“Download failed [runtime error message”’
“Cannot rerun workflow because: [runtime error message]”
“Job approval failed: [runtime error message]”

Please keep in mind that one of the causes for any of the above error messages
could be network issues. If you see any of these messages repeatedly, we
recommend you check your internet connection.

The following errors should never occur. Should you see any of them and be
able to reproduce them appearing, it would be helpful if you could report this
to us.

“Target entity can not be cancelled because it is not a workflow / job”
“Your project is not set up”
“Can not cancel your job because it has no job number”



Need support?
How to contact us
If you find any bugs with this extension or want to provide feedback, you can
contact us at
cci-vscode-feedback@circleci.com.
Documentation
You can find more information about CircleCI on our
official documentation.
How to contribute
The Language Server upon which the Conifg Helper is based is Open Source. If you
would like to contribute to the project, feel free to open a PR or get in touch
with us through the
circleci-yaml-language-server repository.
Additional resources
Data and Telemetry
The CircleCI VS Code extension collects usage data for product improvement
purposes, respecting the isTelemetryEnabled and telemetry.telemetryLevel
settings provided by VS Code.
It can be opted out through the VS Code settings page.
Privacy Policy
By signing in to this extension, you agree to the
CircleCI Privacy Policy.
Acknowledgements
This project was made possible by the community surrounding it. You can find
more information about the people and projects which contributed to this
extension in the file CREDITS.md.
We were also inspired by the great work done by community-built extensions:

Jody's Extension for CircleCI
CircleCI Status
vscode-circleci
circleci-conig-validator
Local-CI


© 2023 Circle Internet Services, Inc.\nOverviewVersion HistoryQ & ARating & ReviewThe official CircleCI VS Code extension is a new way to interact with CircleCI.
This extension provides an interface to visualize and manage CircleCI pipelines
directly from your IDE, as well as providing contextual help when creating,
modifying and editing CircleCI YAML config files. This way, it avoids expensive
context-switching between VS Code and your browser.
More practically, this extension allows you to:

Authenticate and connect VS Code to CircleCI
Browse and interact with your pipelines. Available actions include

Viewing pipelines, workflows, and jobs statuses
Viewing test outputs
Browsing job logs
Downloading artifacts
Approving jobs
Re-running builds
Debugging jobs with SSH


Be alerted through notifications when your workflows change status or need
your attention
Access in-file support when editing CircleCI YAML configuration files,
including:

Syntax validation
Syntax highlighting
Go-to-definition and go-to-reference
On-hover documentation and usage hints
Autocompletion


Launch commands to validate config files statically, or against your org
policy


    

Getting started
It’s easy to get started with CircleCI for VS Code.

Install the extension
You can install the CircleCI extension from within VS Code, or download it
from the marketplace.
⚠️ This extension is compatible with VS Code versions 1.85 or above.

Authenticate into CircleCI
Open the CircleCI Panel by clicking on the CircleCI icon on the activity bar
on the left of your screen, then click on “Log in”.
   
    

You will be prompted to enter a
Personal API Token. If you
don't have one, you can generate a new one for this purpose.
If you are an Enterprise customer, make sure to check the box and enter your
self-hosted server URL.

Setup your project
If your VS Code workspace contains one or more CircleCI projects, the
extension will detect them automatically, and the Pipelines Panel will be
populated with your most recent pipelines.
If no project is detected, open the settings page (through the VS Code
command CircleCI: Open Settings, or by clicking on the settings icon (⚙️)
at the top of the Pipelines Panel), and select your projects manually.
Please note that your manual selection will only be persisted if no projects
are detected automatically.
   ⚠️ Automatic project detection does not work for GitLab projects. Please select your project manually from the Settings page.





Configure your Pipelines Panel
By default, your Pipelines Panel will display all the latest pipelines run on
your project. However, you can configure it to show you only the pipelines
you are interested in.
All configurations are available in the Settings page, which you can open
with the command CircleCI: Open Settings or by clicking on the settings
icon (⚙️) at the top of the Pipelines Panel.
Specifically, you can choose to follow:

Only your pipelines, or those authored by anyone
All branches, only your current branch, or a specific branch. You can also
select the checkbox “Always display default branch”
Only pipelines that include workflows and jobs with specific statuses.


    


Configure notifications
You can set up pop-up notifications to warn you when a workflow in your
Pipelines Panel has changed status.
 
   
 
By default, you will receive a pop-up notification every time one of the
workflows in your Pipelines Panel enters a failing status, or needs your
approval.
If you wish to alter these defaults, you can:

Mute notifications (a toggle button to change this setting is also
available at the top of the Pipelines Panel)



Configure which workflow status changes you want to be notified about

Please note that you can only be notified about workflows that appear in your
Pipelines Panel.
 
     
 


The Pipelines Panel
The Pipelines Panel lists all CircleCI projects detected in your workspace. For
each project, it shows the most recent pipelines, jobs and workflows, and lets
you monitor their status and interact with them.

    

For some tree objects, you can perform actions by clicking on the icons which
appear when you hover over the item.
Project
Projects are the top level tree items, and they contain your pipelines.

If you don't follow a project, you can also use the panel to follow it.
Pipeline
Pipelines
are nested under projects. They are the CircleCI unit of change, and they
contain your workflows.

Workflow
Workflows
are nested under each Pipeline, and contain Jobs. Hovering over a Workflow lets
you:

Open in browser, to view workflow details in the CircleCI app, on your default
web browser
Rerun workflow from start, to re-triggered the entire workflow
Rerun workflow from failed, to re-triggered the workflow starting from the
first failed job

Job
Jobs
are nested under each Workflow, and can contain Tests and Artifacts. Hovering
over a Job lets you:

Approve the job (only if the job is on hold)
Cancel the job (only if the job is running)
Rerun the job with SSH (you can read more about this functionality in a later
section)
View job details


    

By expanding a Job, you can also:

Load tests, if you have configured your tests to upload test results to
CircleCI. Tests that CircleCI has detected as flaky will be prefaced by the
indication [FLAKY].
Load artifacts, to load any artifacts created by the Job. Once the
artifacts are loaded, you can download them by clicking on them.

Re-run with SSH
You can re-run jobs with SSH directly from VS Code, either:

through the Job Details page, by clicking on the green button on the top
right:



or by clicking on the action icon next to the job name in the Pipelines Panel.


    

In both cases, you will be presented with two options:

Open SSH session in terminal


    


Open SSH session in remote VS Code window

This feature requires the official VS Code extension
Remote - SSH.
You can find more information on Remote Development using SSH in VS Code
directly in the
VS Code docs.




    

To rerun your job with SSH, you will first have to set the path to your Github
or Bitbucket SSH key. The first time you attempt to re-run with SSH, the
extension will guide you to select the path of the relevant SSH key. However, if
you miss this step or want to modify it at a later time, you can do so from the
dedicated section of the settings page:

    

If the job you want to rerun uses parallelism, you will be able to select which
job you want to SSH into.

You can read more about debugging with SSH on CircleCI
in the Docs.

Status Bar
The Status Bar provides summary information about the state of the CircleCI
extension, your project and your most recent workflow.

    

Specifically, you might see the following statuses:

Not logged in - when clicking on the status bar, the login page will open
No project - when clicking on the status bar, the settings page will open
so you can select a project manually
Success / On hold / Failed, and similar workflow statuses - THIS refers to
the status of the top pipeline in your panel. When clicking on the status bar,
the relative workflow will come into focus on the CircleCI Pipelines Panel.
No internet - when your internet connection is lost

Config Helper
This extension provides in-file assistance with writing, editing and navigating
CircleCI Configuration files.
It is based on a CircleCI-specific Language Server, and offers:

Rich code navigation through “go-to-definition” and “go-to-reference”
commands. This is especially convenient when working on large configuration
files, to verify the definition of custom jobs, executors parameters, or in
turn view where any of them are referenced in the file. Assisted code
navigation also works for Orbs, allowing to explore their definition directly
in the IDE when using the go-to-definition feature on an orb-defined command
or parameter.


    


Contextual documentation and usage hints when hovering on specific keys,
so as to avoid having to continuously switch to the browser to check the docs
whenever you are editing your YAML config. Links to the official CircleCI
documentation are also provided on hover - for easier navigation.


    


Syntax validation - which makes it much easier to identify typos,
incorrect use of parameters, incomplete definitions, wrong types, invalid or
deprecated machine versions, etc.


    


Usage warnings - which can help identify deprecated parameters, unused
jobs or executors, or missing keys that prevent you from taking advantage of
CircleCI’s full capabilities


    


Auto completion, available both on built-in keys and parameters and on
user-defined variables


    

You can access a full overview of all errors, warnings and hints proposed by the
Config Helper in the Problems tab of VS Code.

    


The Config Helper is based on a dedicated Language Server for CircleCI YAML
files, which is Open Source. You can view its source code, contribute and add
issues directly on the project repository:
circleci-yaml-language-server.

Config validation commands
The extension also provides two commands that help you statically validate your
YAML config files without having to run a pipeline.

    


Validate current configuration file
Corresponds to the CLI command
circleci config validate,
and verifies statically that the config file is well formed. Please note that
this command only validates this file for structure and syntax errors, but
not for semantic error (e.g. this job does not exist).

Validate current configuration file against org policy
Corresponds to the CLI command
circleci policy decide,
and verifies that the configuration file complies with your organization
policies - if any are set.

Please note that this command is only available to Scale customers


View compiled version of current configuration file
This command resolves all orb references in your config file, and shows you
the full-length version of your config.


All these commands can also be invoked:

by right-clicking on a CircleCI YAML file:


    


by clicking on the CircleCI button on the top right corner of the page, when
focusing on a CircleCI YAML file. Please note that the button will not be
visible if you are editing a different file.


    

🆕 Test run your config (Open Preview)

NOTE: The ability to trigger a pipeline from VS Code with a unversioned
config is currently in Open Preview, and only available for projects
integrated through the GitHub OAuth app, or Bitbucket. To find out
which GitHub account type you have, see the
documentation about GitHub OAuth app integration.

Trigger pipelines from VS Code to iterate on your CircleCI config without
committing your trial and error changes to your version control system. Run and
validate your full pipeline, or select jobs and workflows to validate
individually. View the results of your test runs in the Pipelines Panel or in
the CircleCI web app, just the same as any other pipeline.

Prerequisites

v2.0 or higher of the CircleCI VS Code extension
A CircleCI account integrated through the GitHub OAuth app, or Bitbucket. To
find out which GitHub account type you have, check
this docs page.
Your org must have opted-in to this feature through Organization Settings. You
may need to ask your org admin to do so for you. See the section Feature
controls below for more details.
Your project must not make use of
dynamic configuration. This
feature is disabled for projects that use dynamic configuration.

NOTE: Unversioned config in CircleCI indicates that the
.circleci/config.yml on the branch where the pipeline is running is ignored,
and instead, the configuration file is overridden by a custom configuration file
passed as a parameter. The term “unversioned” refers to the fact the config file
is not versioned in the VCS. It is, however, stored in CircleCI along with the
pipeline, and it is available at any time in the CircleCI web app.

Please use caution when running pipelines with unversioned configuration, and take care to ensure no jobs with unintended effects are included in the run. For more details, see the section Security Implications below. 

Access to this feature is controlled by an opt-in setting which only organization admins can control. Once your organization has opted-in, you can opt-out for each individual project. For more details, see the section Feature-controls below.

Steps
The following steps show how to test run a pipeline from the VS Code extension:

Open VS Code and select the CircleCI logo in the sidebar. The Pipelines
and Run panels will be visible
Expand the Run panel to view your projects.
For each project, there is a button to trigger the config test run, and check
boxes for each workflow and job for you to choose which parts of your config
you want to run. Select your options, and click icon:play[]. Any local change
you make to your .circleci/config.yml file will be included in the test
run.
The pipeline is now visible in your dashboard in the CircleCI web app, at
app.circleci.com/pipelines/, and the
Pipelines Panel in the VS Code extension.

Feature controls
The ability to trigger pipelines from VS Code can be controlled at the org
level and at the project level.

Opt-in organization level setting. This can be changed only by
organization admins, and overrides project settings.
Setting location:
Organization Settings > Advanced > Allow triggering pipelines with unversioned config
in the Web App.

Opt-out project level setting.
Setting location:
Project Settings > VS Code integration > Allow triggering pipelines with unversioned config
in the Web App.


Security Implications
Running pipelines with unversioned config can cause security vulnerabilities.
Before enabling this feature, please acknowledge the risks outlined in the
official Docs.

Troubleshooting
Here are some frequently encountered issues, and some clarifications on each of
them.

“Your project could not be detected because no workspace is currently open”
You can fix this issue by opening a folder or workspace. Alternatively, you
can select to follow a CircleCI project manually from the Settings page.

The following errors concern the ability of the extension to link your
workspace to a Git repository.

“Your project could not be detected because we couldn’t find a Git repository associated with this workspace”
“Your project could not be detected because we were unable to get the list of git remotes”
“Your project could not be detected because we could not find default remote of your Git repository”
“Your project could not be detected because we were unable to get the URL of the Git remote XYZ”

When any of these errors occur, you might want to check that your workspace
has a valid Git remote URL. You can also fix this issue by selecting to follow
a CircleCI project manually from the Settings page.

“Your project could not be detected because CircleCI does not know this project”
This error indicates that the repository associated with your workspace
doesn’t appear to be a CircleCI project. If this is unexpected, verify the Git
remote URL associated with your repository, and ensure that you see this
project on the CircleCI web app. You can also address this issue by selecting
to follow a CircleCI project manually from the Settings page.

“Your project could not be detected because you don't follow this project on CircleCI”
When you see this error, you might want to visit the
Projects page on the CircleCI app
and ensure that you “follow” the project associated with this workspace.

“connection to server is erroring. Shutting down server”
This message indicates that the CircleCI Language Server has crashed. This
might be caused by an unexpected parsing error. For this reason, it is likely
that this issue will always occur on the same file. If you identify a file
that causes this error, it would be helpful if you could inform us at XXXXXX
(in the future on the LS open source repo)

When interacting with pipelines, workflows and jobs, you might see the
following errors.

“Cannot refresh pipelines: [runtime error message]”
“Download failed [runtime error message”’
“Cannot rerun workflow because: [runtime error message]”
“Job approval failed: [runtime error message]”

Please keep in mind that one of the causes for any of the above error messages
could be network issues. If you see any of these messages repeatedly, we
recommend you check your internet connection.

The following errors should never occur. Should you see any of them and be
able to reproduce them appearing, it would be helpful if you could report this
to us.

“Target entity can not be cancelled because it is not a workflow / job”
“Your project is not set up”
“Can not cancel your job because it has no job number”



Need support?
How to contact us
If you find any bugs with this extension or want to provide feedback, you can
contact us at
cci-vscode-feedback@circleci.com.
Documentation
You can find more information about CircleCI on our
official documentation.
How to contribute
The Language Server upon which the Conifg Helper is based is Open Source. If you
would like to contribute to the project, feel free to open a PR or get in touch
with us through the
circleci-yaml-language-server repository.
Additional resources
Data and Telemetry
The CircleCI VS Code extension collects usage data for product improvement
purposes, respecting the isTelemetryEnabled and telemetry.telemetryLevel
settings provided by VS Code.
It can be opted out through the VS Code settings page.
Privacy Policy
By signing in to this extension, you agree to the
CircleCI Privacy Policy.
Acknowledgements
This project was made possible by the community surrounding it. You can find
more information about the people and projects which contributed to this
extension in the file CREDITS.md.
We were also inspired by the great work done by community-built extensions:

Jody's Extension for CircleCI
CircleCI Status
vscode-circleci
circleci-conig-validator
Local-CI


© 2023 Circle Internet Services, Inc.\nOverviewVersion HistoryQ & ARating & ReviewThe official CircleCI VS Code extension is a new way to interact with CircleCI.
This extension provides an interface to visualize and manage CircleCI pipelines
directly from your IDE, as well as providing contextual help when creating,
modifying and editing CircleCI YAML config files. This way, it avoids expensive
context-switching between VS Code and your browser.
More practically, this extension allows you to:

Authenticate and connect VS Code to CircleCI
Browse and interact with your pipelines. Available actions include

Viewing pipelines, workflows, and jobs statuses
Viewing test outputs
Browsing job logs
Downloading artifacts
Approving jobs
Re-running builds
Debugging jobs with SSH


Be alerted through notifications when your workflows change status or need
your attention
Access in-file support when editing CircleCI YAML configuration files,
including:

Syntax validation
Syntax highlighting
Go-to-definition and go-to-reference
On-hover documentation and usage hints
Autocompletion


Launch commands to validate config files statically, or against your org
policy


    

Getting started
It’s easy to get started with CircleCI for VS Code.

Install the extension
You can install the CircleCI extension from within VS Code, or download it
from the marketplace.
⚠️ This extension is compatible with VS Code versions 1.85 or above.

Authenticate into CircleCI
Open the CircleCI Panel by clicking on the CircleCI icon on the activity bar
on the left of your screen, then click on “Log in”.
   
    

You will be prompted to enter a
Personal API Token. If you
don't have one, you can generate a new one for this purpose.
If you are an Enterprise customer, make sure to check the box and enter your
self-hosted server URL.

Setup your project
If your VS Code workspace contains one or more CircleCI projects, the
extension will detect them automatically, and the Pipelines Panel will be
populated with your most recent pipelines.
If no project is detected, open the settings page (through the VS Code
command CircleCI: Open Settings, or by clicking on the settings icon (⚙️)
at the top of the Pipelines Panel), and select your projects manually.
Please note that your manual selection will only be persisted if no projects
are detected automatically.
   ⚠️ Automatic project detection does not work for GitLab projects. Please select your project manually from the Settings page.





Configure your Pipelines Panel
By default, your Pipelines Panel will display all the latest pipelines run on
your project. However, you can configure it to show you only the pipelines
you are interested in.
All configurations are available in the Settings page, which you can open
with the command CircleCI: Open Settings or by clicking on the settings
icon (⚙️) at the top of the Pipelines Panel.
Specifically, you can choose to follow:

Only your pipelines, or those authored by anyone
All branches, only your current branch, or a specific branch. You can also
select the checkbox “Always display default branch”
Only pipelines that include workflows and jobs with specific statuses.


    


Configure notifications
You can set up pop-up notifications to warn you when a workflow in your
Pipelines Panel has changed status.
 
   
 
By default, you will receive a pop-up notification every time one of the
workflows in your Pipelines Panel enters a failing status, or needs your
approval.
If you wish to alter these defaults, you can:

Mute notifications (a toggle button to change this setting is also
available at the top of the Pipelines Panel)



Configure which workflow status changes you want to be notified about

Please note that you can only be notified about workflows that appear in your
Pipelines Panel.
 
     
 


The Pipelines Panel
The Pipelines Panel lists all CircleCI projects detected in your workspace. For
each project, it shows the most recent pipelines, jobs and workflows, and lets
you monitor their status and interact with them.

    

For some tree objects, you can perform actions by clicking on the icons which
appear when you hover over the item.
Project
Projects are the top level tree items, and they contain your pipelines.

If you don't follow a project, you can also use the panel to follow it.
Pipeline
Pipelines
are nested under projects. They are the CircleCI unit of change, and they
contain your workflows.

Workflow
Workflows
are nested under each Pipeline, and contain Jobs. Hovering over a Workflow lets
you:

Open in browser, to view workflow details in the CircleCI app, on your default
web browser
Rerun workflow from start, to re-triggered the entire workflow
Rerun workflow from failed, to re-triggered the workflow starting from the
first failed job

Job
Jobs
are nested under each Workflow, and can contain Tests and Artifacts. Hovering
over a Job lets you:

Approve the job (only if the job is on hold)
Cancel the job (only if the job is running)
Rerun the job with SSH (you can read more about this functionality in a later
section)
View job details


    

By expanding a Job, you can also:

Load tests, if you have configured your tests to upload test results to
CircleCI. Tests that CircleCI has detected as flaky will be prefaced by the
indication [FLAKY].
Load artifacts, to load any artifacts created by the Job. Once the
artifacts are loaded, you can download them by clicking on them.

Re-run with SSH
You can re-run jobs with SSH directly from VS Code, either:

through the Job Details page, by clicking on the green button on the top
right:



or by clicking on the action icon next to the job name in the Pipelines Panel.


    

In both cases, you will be presented with two options:

Open SSH session in terminal


    


Open SSH session in remote VS Code window

This feature requires the official VS Code extension
Remote - SSH.
You can find more information on Remote Development using SSH in VS Code
directly in the
VS Code docs.




    

To rerun your job with SSH, you will first have to set the path to your Github
or Bitbucket SSH key. The first time you attempt to re-run with SSH, the
extension will guide you to select the path of the relevant SSH key. However, if
you miss this step or want to modify it at a later time, you can do so from the
dedicated section of the settings page:

    

If the job you want to rerun uses parallelism, you will be able to select which
job you want to SSH into.

You can read more about debugging with SSH on CircleCI
in the Docs.

Status Bar
The Status Bar provides summary information about the state of the CircleCI
extension, your project and your most recent workflow.

    

Specifically, you might see the following statuses:

Not logged in - when clicking on the status bar, the login page will open
No project - when clicking on the status bar, the settings page will open
so you can select a project manually
Success / On hold / Failed, and similar workflow statuses - THIS refers to
the status of the top pipeline in your panel. When clicking on the status bar,
the relative workflow will come into focus on the CircleCI Pipelines Panel.
No internet - when your internet connection is lost

Config Helper
This extension provides in-file assistance with writing, editing and navigating
CircleCI Configuration files.
It is based on a CircleCI-specific Language Server, and offers:

Rich code navigation through “go-to-definition” and “go-to-reference”
commands. This is especially convenient when working on large configuration
files, to verify the definition of custom jobs, executors parameters, or in
turn view where any of them are referenced in the file. Assisted code
navigation also works for Orbs, allowing to explore their definition directly
in the IDE when using the go-to-definition feature on an orb-defined command
or parameter.


    


Contextual documentation and usage hints when hovering on specific keys,
so as to avoid having to continuously switch to the browser to check the docs
whenever you are editing your YAML config. Links to the official CircleCI
documentation are also provided on hover - for easier navigation.


    


Syntax validation - which makes it much easier to identify typos,
incorrect use of parameters, incomplete definitions, wrong types, invalid or
deprecated machine versions, etc.


    


Usage warnings - which can help identify deprecated parameters, unused
jobs or executors, or missing keys that prevent you from taking advantage of
CircleCI’s full capabilities


    


Auto completion, available both on built-in keys and parameters and on
user-defined variables


    

You can access a full overview of all errors, warnings and hints proposed by the
Config Helper in the Problems tab of VS Code.

    


The Config Helper is based on a dedicated Language Server for CircleCI YAML
files, which is Open Source. You can view its source code, contribute and add
issues directly on the project repository:
circleci-yaml-language-server.

Config validation commands
The extension also provides two commands that help you statically validate your
YAML config files without having to run a pipeline.

    


Validate current configuration file
Corresponds to the CLI command
circleci config validate,
and verifies statically that the config file is well formed. Please note that
this command only validates this file for structure and syntax errors, but
not for semantic error (e.g. this job does not exist).

Validate current configuration file against org policy
Corresponds to the CLI command
circleci policy decide,
and verifies that the configuration file complies with your organization
policies - if any are set.

Please note that this command is only available to Scale customers


View compiled version of current configuration file
This command resolves all orb references in your config file, and shows you
the full-length version of your config.


All these commands can also be invoked:

by right-clicking on a CircleCI YAML file:


    


by clicking on the CircleCI button on the top right corner of the page, when
focusing on a CircleCI YAML file. Please note that the button will not be
visible if you are editing a different file.


    

🆕 Test run your config (Open Preview)

NOTE: The ability to trigger a pipeline from VS Code with a unversioned
config is currently in Open Preview, and only available for projects
integrated through the GitHub OAuth app, or Bitbucket. To find out
which GitHub account type you have, see the
documentation about GitHub OAuth app integration.

Trigger pipelines from VS Code to iterate on your CircleCI config without
committing your trial and error changes to your version control system. Run and
validate your full pipeline, or select jobs and workflows to validate
individually. View the results of your test runs in the Pipelines Panel or in
the CircleCI web app, just the same as any other pipeline.

Prerequisites

v2.0 or higher of the CircleCI VS Code extension
A CircleCI account integrated through the GitHub OAuth app, or Bitbucket. To
find out which GitHub account type you have, check
this docs page.
Your org must have opted-in to this feature through Organization Settings. You
may need to ask your org admin to do so for you. See the section Feature
controls below for more details.
Your project must not make use of
dynamic configuration. This
feature is disabled for projects that use dynamic configuration.

NOTE: Unversioned config in CircleCI indicates that the
.circleci/config.yml on the branch where the pipeline is running is ignored,
and instead, the configuration file is overridden by a custom configuration file
passed as a parameter. The term “unversioned” refers to the fact the config file
is not versioned in the VCS. It is, however, stored in CircleCI along with the
pipeline, and it is available at any time in the CircleCI web app.

Please use caution when running pipelines with unversioned configuration, and take care to ensure no jobs with unintended effects are included in the run. For more details, see the section Security Implications below. 

Access to this feature is controlled by an opt-in setting which only organization admins can control. Once your organization has opted-in, you can opt-out for each individual project. For more details, see the section Feature-controls below.

Steps
The following steps show how to test run a pipeline from the VS Code extension:

Open VS Code and select the CircleCI logo in the sidebar. The Pipelines
and Run panels will be visible
Expand the Run panel to view your projects.
For each project, there is a button to trigger the config test run, and check
boxes for each workflow and job for you to choose which parts of your config
you want to run. Select your options, and click icon:play[]. Any local change
you make to your .circleci/config.yml file will be included in the test
run.
The pipeline is now visible in your dashboard in the CircleCI web app, at
app.circleci.com/pipelines/, and the
Pipelines Panel in the VS Code extension.

Feature controls
The ability to trigger pipelines from VS Code can be controlled at the org
level and at the project level.

Opt-in organization level setting. This can be changed only by
organization admins, and overrides project settings.
Setting location:
Organization Settings > Advanced > Allow triggering pipelines with unversioned config
in the Web App.

Opt-out project level setting.
Setting location:
Project Settings > VS Code integration > Allow triggering pipelines with unversioned config
in the Web App.


Security Implications
Running pipelines with unversioned config can cause security vulnerabilities.
Before enabling this feature, please acknowledge the risks outlined in the
official Docs.

Troubleshooting
Here are some frequently encountered issues, and some clarifications on each of
them.

“Your project could not be detected because no workspace is currently open”
You can fix this issue by opening a folder or workspace. Alternatively, you
can select to follow a CircleCI project manually from the Settings page.

The following errors concern the ability of the extension to link your
workspace to a Git repository.

“Your project could not be detected because we couldn’t find a Git repository associated with this workspace”
“Your project could not be detected because we were unable to get the list of git remotes”
“Your project could not be detected because we could not find default remote of your Git repository”
“Your project could not be detected because we were unable to get the URL of the Git remote XYZ”

When any of these errors occur, you might want to check that your workspace
has a valid Git remote URL. You can also fix this issue by selecting to follow
a CircleCI project manually from the Settings page.

“Your project could not be detected because CircleCI does not know this project”
This error indicates that the repository associated with your workspace
doesn’t appear to be a CircleCI project. If this is unexpected, verify the Git
remote URL associated with your repository, and ensure that you see this
project on the CircleCI web app. You can also address this issue by selecting
to follow a CircleCI project manually from the Settings page.

“Your project could not be detected because you don't follow this project on CircleCI”
When you see this error, you might want to visit the
Projects page on the CircleCI app
and ensure that you “follow” the project associated with this workspace.

“connection to server is erroring. Shutting down server”
This message indicates that the CircleCI Language Server has crashed. This
might be caused by an unexpected parsing error. For this reason, it is likely
that this issue will always occur on the same file. If you identify a file
that causes this error, it would be helpful if you could inform us at XXXXXX
(in the future on the LS open source repo)

When interacting with pipelines, workflows and jobs, you might see the
following errors.

“Cannot refresh pipelines: [runtime error message]”
“Download failed [runtime error message”’
“Cannot rerun workflow because: [runtime error message]”
“Job approval failed: [runtime error message]”

Please keep in mind that one of the causes for any of the above error messages
could be network issues. If you see any of these messages repeatedly, we
recommend you check your internet connection.

The following errors should never occur. Should you see any of them and be
able to reproduce them appearing, it would be helpful if you could report this
to us.

“Target entity can not be cancelled because it is not a workflow / job”
“Your project is not set up”
“Can not cancel your job because it has no job number”



Need support?
How to contact us
If you find any bugs with this extension or want to provide feedback, you can
contact us at
cci-vscode-feedback@circleci.com.
Documentation
You can find more information about CircleCI on our
official documentation.
How to contribute
The Language Server upon which the Conifg Helper is based is Open Source. If you
would like to contribute to the project, feel free to open a PR or get in touch
with us through the
circleci-yaml-language-server repository.
Additional resources
Data and Telemetry
The CircleCI VS Code extension collects usage data for product improvement
purposes, respecting the isTelemetryEnabled and telemetry.telemetryLevel
settings provided by VS Code.
It can be opted out through the VS Code settings page.
Privacy Policy
By signing in to this extension, you agree to the
CircleCI Privacy Policy.
Acknowledgements
This project was made possible by the community surrounding it. You can find
more information about the people and projects which contributed to this
extension in the file CREDITS.md.
We were also inspired by the great work done by community-built extensions:

Jody's Extension for CircleCI
CircleCI Status
vscode-circleci
circleci-conig-validator
Local-CI


© 2023 Circle Internet Services, Inc.\nOverviewVersion HistoryQ & ARating & ReviewThe official CircleCI VS Code extension is a new way to interact with CircleCI.
This extension provides an interface to visualize and manage CircleCI pipelines
directly from your IDE, as well as providing contextual help when creating,
modifying and editing CircleCI YAML config files. This way, it avoids expensive
context-switching between VS Code and your browser.
More practically, this extension allows you to:

Authenticate and connect VS Code to CircleCI
Browse and interact with your pipelines. Available actions include

Viewing pipelines, workflows, and jobs statuses
Viewing test outputs
Browsing job logs
Downloading artifacts
Approving jobs
Re-running builds
Debugging jobs with SSH


Be alerted through notifications when your workflows change status or need
your attention
Access in-file support when editing CircleCI YAML configuration files,
including:

Syntax validation
Syntax highlighting
Go-to-definition and go-to-reference
On-hover documentation and usage hints
Autocompletion


Launch commands to validate config files statically, or against your org
policy


    

Getting started
It’s easy to get started with CircleCI for VS Code.

Install the extension
You can install the CircleCI extension from within VS Code, or download it
from the marketplace.
⚠️ This extension is compatible with VS Code versions 1.85 or above.

Authenticate into CircleCI
Open the CircleCI Panel by clicking on the CircleCI icon on the activity bar
on the left of your screen, then click on “Log in”.
   
    

You will be prompted to enter a
Personal API Token. If you
don't have one, you can generate a new one for this purpose.
If you are an Enterprise customer, make sure to check the box and enter your
self-hosted server URL.

Setup your project
If your VS Code workspace contains one or more CircleCI projects, the
extension will detect them automatically, and the Pipelines Panel will be
populated with your most recent pipelines.
If no project is detected, open the settings page (through the VS Code
command CircleCI: Open Settings, or by clicking on the settings icon (⚙️)
at the top of the Pipelines Panel), and select your projects manually.
Please note that your manual selection will only be persisted if no projects
are detected automatically.
   ⚠️ Automatic project detection does not work for GitLab projects. Please select your project manually from the Settings page.





Configure your Pipelines Panel
By default, your Pipelines Panel will display all the latest pipelines run on
your project. However, you can configure it to show you only the pipelines
you are interested in.
All configurations are available in the Settings page, which you can open
with the command CircleCI: Open Settings or by clicking on the settings
icon (⚙️) at the top of the Pipelines Panel.
Specifically, you can choose to follow:

Only your pipelines, or those authored by anyone
All branches, only your current branch, or a specific branch. You can also
select the checkbox “Always display default branch”
Only pipelines that include workflows and jobs with specific statuses.


    


Configure notifications
You can set up pop-up notifications to warn you when a workflow in your
Pipelines Panel has changed status.
 
   
 
By default, you will receive a pop-up notification every time one of the
workflows in your Pipelines Panel enters a failing status, or needs your
approval.
If you wish to alter these defaults, you can:

Mute notifications (a toggle button to change this setting is also
available at the top of the Pipelines Panel)



Configure which workflow status changes you want to be notified about

Please note that you can only be notified about workflows that appear in your
Pipelines Panel.
 
     
 


The Pipelines Panel
The Pipelines Panel lists all CircleCI projects detected in your workspace. For
each project, it shows the most recent pipelines, jobs and workflows, and lets
you monitor their status and interact with them.

    

For some tree objects, you can perform actions by clicking on the icons which
appear when you hover over the item.
Project
Projects are the top level tree items, and they contain your pipelines.

If you don't follow a project, you can also use the panel to follow it.
Pipeline
Pipelines
are nested under projects. They are the CircleCI unit of change, and they
contain your workflows.

Workflow
Workflows
are nested under each Pipeline, and contain Jobs. Hovering over a Workflow lets
you:

Open in browser, to view workflow details in the CircleCI app, on your default
web browser
Rerun workflow from start, to re-triggered the entire workflow
Rerun workflow from failed, to re-triggered the workflow starting from the
first failed job

Job
Jobs
are nested under each Workflow, and can contain Tests and Artifacts. Hovering
over a Job lets you:

Approve the job (only if the job is on hold)
Cancel the job (only if the job is running)
Rerun the job with SSH (you can read more about this functionality in a later
section)
View job details


    

By expanding a Job, you can also:

Load tests, if you have configured your tests to upload test results to
CircleCI. Tests that CircleCI has detected as flaky will be prefaced by the
indication [FLAKY].
Load artifacts, to load any artifacts created by the Job. Once the
artifacts are loaded, you can download them by clicking on them.

Re-run with SSH
You can re-run jobs with SSH directly from VS Code, either:

through the Job Details page, by clicking on the green button on the top
right:



or by clicking on the action icon next to the job name in the Pipelines Panel.


    

In both cases, you will be presented with two options:

Open SSH session in terminal


    


Open SSH session in remote VS Code window

This feature requires the official VS Code extension
Remote - SSH.
You can find more information on Remote Development using SSH in VS Code
directly in the
VS Code docs.




    

To rerun your job with SSH, you will first have to set the path to your Github
or Bitbucket SSH key. The first time you attempt to re-run with SSH, the
extension will guide you to select the path of the relevant SSH key. However, if
you miss this step or want to modify it at a later time, you can do so from the
dedicated section of the settings page:

    

If the job you want to rerun uses parallelism, you will be able to select which
job you want to SSH into.

You can read more about debugging with SSH on CircleCI
in the Docs.

Status Bar
The Status Bar provides summary information about the state of the CircleCI
extension, your project and your most recent workflow.

    

Specifically, you might see the following statuses:

Not logged in - when clicking on the status bar, the login page will open
No project - when clicking on the status bar, the settings page will open
so you can select a project manually
Success / On hold / Failed, and similar workflow statuses - THIS refers to
the status of the top pipeline in your panel. When clicking on the status bar,
the relative workflow will come into focus on the CircleCI Pipelines Panel.
No internet - when your internet connection is lost

Config Helper
This extension provides in-file assistance with writing, editing and navigating
CircleCI Configuration files.
It is based on a CircleCI-specific Language Server, and offers:

Rich code navigation through “go-to-definition” and “go-to-reference”
commands. This is especially convenient when working on large configuration
files, to verify the definition of custom jobs, executors parameters, or in
turn view where any of them are referenced in the file. Assisted code
navigation also works for Orbs, allowing to explore their definition directly
in the IDE when using the go-to-definition feature on an orb-defined command
or parameter.


    


Contextual documentation and usage hints when hovering on specific keys,
so as to avoid having to continuously switch to the browser to check the docs
whenever you are editing your YAML config. Links to the official CircleCI
documentation are also provided on hover - for easier navigation.


    


Syntax validation - which makes it much easier to identify typos,
incorrect use of parameters, incomplete definitions, wrong types, invalid or
deprecated machine versions, etc.


    


Usage warnings - which can help identify deprecated parameters, unused
jobs or executors, or missing keys that prevent you from taking advantage of
CircleCI’s full capabilities


    


Auto completion, available both on built-in keys and parameters and on
user-defined variables


    

You can access a full overview of all errors, warnings and hints proposed by the
Config Helper in the Problems tab of VS Code.

    


The Config Helper is based on a dedicated Language Server for CircleCI YAML
files, which is Open Source. You can view its source code, contribute and add
issues directly on the project repository:
circleci-yaml-language-server.

Config validation commands
The extension also provides two commands that help you statically validate your
YAML config files without having to run a pipeline.

    


Validate current configuration file
Corresponds to the CLI command
circleci config validate,
and verifies statically that the config file is well formed. Please note that
this command only validates this file for structure and syntax errors, but
not for semantic error (e.g. this job does not exist).

Validate current configuration file against org policy
Corresponds to the CLI command
circleci policy decide,
and verifies that the configuration file complies with your organization
policies - if any are set.

Please note that this command is only available to Scale customers


View compiled version of current configuration file
This command resolves all orb references in your config file, and shows you
the full-length version of your config.


All these commands can also be invoked:

by right-clicking on a CircleCI YAML file:


    


by clicking on the CircleCI button on the top right corner of the page, when
focusing on a CircleCI YAML file. Please note that the button will not be
visible if you are editing a different file.


    

🆕 Test run your config (Open Preview)

NOTE: The ability to trigger a pipeline from VS Code with a unversioned
config is currently in Open Preview, and only available for projects
integrated through the GitHub OAuth app, or Bitbucket. To find out
which GitHub account type you have, see the
documentation about GitHub OAuth app integration.

Trigger pipelines from VS Code to iterate on your CircleCI config without
committing your trial and error changes to your version control system. Run and
validate your full pipeline, or select jobs and workflows to validate
individually. View the results of your test runs in the Pipelines Panel or in
the CircleCI web app, just the same as any other pipeline.

Prerequisites

v2.0 or higher of the CircleCI VS Code extension
A CircleCI account integrated through the GitHub OAuth app, or Bitbucket. To
find out which GitHub account type you have, check
this docs page.
Your org must have opted-in to this feature through Organization Settings. You
may need to ask your org admin to do so for you. See the section Feature
controls below for more details.
Your project must not make use of
dynamic configuration. This
feature is disabled for projects that use dynamic configuration.

NOTE: Unversioned config in CircleCI indicates that the
.circleci/config.yml on the branch where the pipeline is running is ignored,
and instead, the configuration file is overridden by a custom configuration file
passed as a parameter. The term “unversioned” refers to the fact the config file
is not versioned in the VCS. It is, however, stored in CircleCI along with the
pipeline, and it is available at any time in the CircleCI web app.

Please use caution when running pipelines with unversioned configuration, and take care to ensure no jobs with unintended effects are included in the run. For more details, see the section Security Implications below. 

Access to this feature is controlled by an opt-in setting which only organization admins can control. Once your organization has opted-in, you can opt-out for each individual project. For more details, see the section Feature-controls below.

Steps
The following steps show how to test run a pipeline from the VS Code extension:

Open VS Code and select the CircleCI logo in the sidebar. The Pipelines
and Run panels will be visible
Expand the Run panel to view your projects.
For each project, there is a button to trigger the config test run, and check
boxes for each workflow and job for you to choose which parts of your config
you want to run. Select your options, and click icon:play[]. Any local change
you make to your .circleci/config.yml file will be included in the test
run.
The pipeline is now visible in your dashboard in the CircleCI web app, at
app.circleci.com/pipelines/, and the
Pipelines Panel in the VS Code extension.

Feature controls
The ability to trigger pipelines from VS Code can be controlled at the org
level and at the project level.

Opt-in organization level setting. This can be changed only by
organization admins, and overrides project settings.
Setting location:
Organization Settings > Advanced > Allow triggering pipelines with unversioned config
in the Web App.

Opt-out project level setting.
Setting location:
Project Settings > VS Code integration > Allow triggering pipelines with unversioned config
in the Web App.


Security Implications
Running pipelines with unversioned config can cause security vulnerabilities.
Before enabling this feature, please acknowledge the risks outlined in the
official Docs.

Troubleshooting
Here are some frequently encountered issues, and some clarifications on each of
them.

“Your project could not be detected because no workspace is currently open”
You can fix this issue by opening a folder or workspace. Alternatively, you
can select to follow a CircleCI project manually from the Settings page.

The following errors concern the ability of the extension to link your
workspace to a Git repository.

“Your project could not be detected because we couldn’t find a Git repository associated with this workspace”
“Your project could not be detected because we were unable to get the list of git remotes”
“Your project could not be detected because we could not find default remote of your Git repository”
“Your project could not be detected because we were unable to get the URL of the Git remote XYZ”

When any of these errors occur, you might want to check that your workspace
has a valid Git remote URL. You can also fix this issue by selecting to follow
a CircleCI project manually from the Settings page.

“Your project could not be detected because CircleCI does not know this project”
This error indicates that the repository associated with your workspace
doesn’t appear to be a CircleCI project. If this is unexpected, verify the Git
remote URL associated with your repository, and ensure that you see this
project on the CircleCI web app. You can also address this issue by selecting
to follow a CircleCI project manually from the Settings page.

“Your project could not be detected because you don't follow this project on CircleCI”
When you see this error, you might want to visit the
Projects page on the CircleCI app
and ensure that you “follow” the project associated with this workspace.

“connection to server is erroring. Shutting down server”
This message indicates that the CircleCI Language Server has crashed. This
might be caused by an unexpected parsing error. For this reason, it is likely
that this issue will always occur on the same file. If you identify a file
that causes this error, it would be helpful if you could inform us at XXXXXX
(in the future on the LS open source repo)

When interacting with pipelines, workflows and jobs, you might see the
following errors.

“Cannot refresh pipelines: [runtime error message]”
“Download failed [runtime error message”’
“Cannot rerun workflow because: [runtime error message]”
“Job approval failed: [runtime error message]”

Please keep in mind that one of the causes for any of the above error messages
could be network issues. If you see any of these messages repeatedly, we
recommend you check your internet connection.

The following errors should never occur. Should you see any of them and be
able to reproduce them appearing, it would be helpful if you could report this
to us.

“Target entity can not be cancelled because it is not a workflow / job”
“Your project is not set up”
“Can not cancel your job because it has no job number”



Need support?
How to contact us
If you find any bugs with this extension or want to provide feedback, you can
contact us at
cci-vscode-feedback@circleci.com.
Documentation
You can find more information about CircleCI on our
official documentation.
How to contribute
The Language Server upon which the Conifg Helper is based is Open Source. If you
would like to contribute to the project, feel free to open a PR or get in touch
with us through the
circleci-yaml-language-server repository.
Additional resources
Data and Telemetry
The CircleCI VS Code extension collects usage data for product improvement
purposes, respecting the isTelemetryEnabled and telemetry.telemetryLevel
settings provided by VS Code.
It can be opted out through the VS Code settings page.
Privacy Policy
By signing in to this extension, you agree to the
CircleCI Privacy Policy.
Acknowledgements
This project was made possible by the community surrounding it. You can find
more information about the people and projects which contributed to this
extension in the file CREDITS.md.
We were also inspired by the great work done by community-built extensions:

Jody's Extension for CircleCI
CircleCI Status
vscode-circleci
circleci-conig-validator
Local-CI


© 2023 Circle Internet Services, Inc.\nOverviewVersion HistoryQ & ARating & Review\nThe official CircleCI VS Code extension is a new way to interact with CircleCI.
This extension provides an interface to visualize and manage CircleCI pipelines
directly from your IDE, as well as providing contextual help when creating,
modifying and editing CircleCI YAML config files. This way, it avoids expensive
context-switching between VS Code and your browser.
More practically, this extension allows you to:

Authenticate and connect VS Code to CircleCI
Browse and interact with your pipelines. Available actions include

Viewing pipelines, workflows, and jobs statuses
Viewing test outputs
Browsing job logs
Downloading artifacts
Approving jobs
Re-running builds
Debugging jobs with SSH


Be alerted through notifications when your workflows change status or need
your attention
Access in-file support when editing CircleCI YAML configuration files,
including:

Syntax validation
Syntax highlighting
Go-to-definition and go-to-reference
On-hover documentation and usage hints
Autocompletion


Launch commands to validate config files statically, or against your org
policy


    

Getting started
It’s easy to get started with CircleCI for VS Code.

Install the extension
You can install the CircleCI extension from within VS Code, or download it
from the marketplace.
⚠️ This extension is compatible with VS Code versions 1.85 or above.

Authenticate into CircleCI
Open the CircleCI Panel by clicking on the CircleCI icon on the activity bar
on the left of your screen, then click on “Log in”.
   
    

You will be prompted to enter a
Personal API Token. If you
don't have one, you can generate a new one for this purpose.
If you are an Enterprise customer, make sure to check the box and enter your
self-hosted server URL.

Setup your project
If your VS Code workspace contains one or more CircleCI projects, the
extension will detect them automatically, and the Pipelines Panel will be
populated with your most recent pipelines.
If no project is detected, open the settings page (through the VS Code
command CircleCI: Open Settings, or by clicking on the settings icon (⚙️)
at the top of the Pipelines Panel), and select your projects manually.
Please note that your manual selection will only be persisted if no projects
are detected automatically.
   ⚠️ Automatic project detection does not work for GitLab projects. Please select your project manually from the Settings page.





Configure your Pipelines Panel
By default, your Pipelines Panel will display all the latest pipelines run on
your project. However, you can configure it to show you only the pipelines
you are interested in.
All configurations are available in the Settings page, which you can open
with the command CircleCI: Open Settings or by clicking on the settings
icon (⚙️) at the top of the Pipelines Panel.
Specifically, you can choose to follow:

Only your pipelines, or those authored by anyone
All branches, only your current branch, or a specific branch. You can also
select the checkbox “Always display default branch”
Only pipelines that include workflows and jobs with specific statuses.


    


Configure notifications
You can set up pop-up notifications to warn you when a workflow in your
Pipelines Panel has changed status.
 
   
 
By default, you will receive a pop-up notification every time one of the
workflows in your Pipelines Panel enters a failing status, or needs your
approval.
If you wish to alter these defaults, you can:

Mute notifications (a toggle button to change this setting is also
available at the top of the Pipelines Panel)



Configure which workflow status changes you want to be notified about

Please note that you can only be notified about workflows that appear in your
Pipelines Panel.
 
     
 


The Pipelines Panel
The Pipelines Panel lists all CircleCI projects detected in your workspace. For
each project, it shows the most recent pipelines, jobs and workflows, and lets
you monitor their status and interact with them.

    

For some tree objects, you can perform actions by clicking on the icons which
appear when you hover over the item.
Project
Projects are the top level tree items, and they contain your pipelines.

If you don't follow a project, you can also use the panel to follow it.
Pipeline
Pipelines
are nested under projects. They are the CircleCI unit of change, and they
contain your workflows.

Workflow
Workflows
are nested under each Pipeline, and contain Jobs. Hovering over a Workflow lets
you:

Open in browser, to view workflow details in the CircleCI app, on your default
web browser
Rerun workflow from start, to re-triggered the entire workflow
Rerun workflow from failed, to re-triggered the workflow starting from the
first failed job

Job
Jobs
are nested under each Workflow, and can contain Tests and Artifacts. Hovering
over a Job lets you:

Approve the job (only if the job is on hold)
Cancel the job (only if the job is running)
Rerun the job with SSH (you can read more about this functionality in a later
section)
View job details


    

By expanding a Job, you can also:

Load tests, if you have configured your tests to upload test results to
CircleCI. Tests that CircleCI has detected as flaky will be prefaced by the
indication [FLAKY].
Load artifacts, to load any artifacts created by the Job. Once the
artifacts are loaded, you can download them by clicking on them.

Re-run with SSH
You can re-run jobs with SSH directly from VS Code, either:

through the Job Details page, by clicking on the green button on the top
right:



or by clicking on the action icon next to the job name in the Pipelines Panel.


    

In both cases, you will be presented with two options:

Open SSH session in terminal


    


Open SSH session in remote VS Code window

This feature requires the official VS Code extension
Remote - SSH.
You can find more information on Remote Development using SSH in VS Code
directly in the
VS Code docs.




    

To rerun your job with SSH, you will first have to set the path to your Github
or Bitbucket SSH key. The first time you attempt to re-run with SSH, the
extension will guide you to select the path of the relevant SSH key. However, if
you miss this step or want to modify it at a later time, you can do so from the
dedicated section of the settings page:

    

If the job you want to rerun uses parallelism, you will be able to select which
job you want to SSH into.

You can read more about debugging with SSH on CircleCI
in the Docs.

Status Bar
The Status Bar provides summary information about the state of the CircleCI
extension, your project and your most recent workflow.

    

Specifically, you might see the following statuses:

Not logged in - when clicking on the status bar, the login page will open
No project - when clicking on the status bar, the settings page will open
so you can select a project manually
Success / On hold / Failed, and similar workflow statuses - THIS refers to
the status of the top pipeline in your panel. When clicking on the status bar,
the relative workflow will come into focus on the CircleCI Pipelines Panel.
No internet - when your internet connection is lost

Config Helper
This extension provides in-file assistance with writing, editing and navigating
CircleCI Configuration files.
It is based on a CircleCI-specific Language Server, and offers:

Rich code navigation through “go-to-definition” and “go-to-reference”
commands. This is especially convenient when working on large configuration
files, to verify the definition of custom jobs, executors parameters, or in
turn view where any of them are referenced in the file. Assisted code
navigation also works for Orbs, allowing to explore their definition directly
in the IDE when using the go-to-definition feature on an orb-defined command
or parameter.


    


Contextual documentation and usage hints when hovering on specific keys,
so as to avoid having to continuously switch to the browser to check the docs
whenever you are editing your YAML config. Links to the official CircleCI
documentation are also provided on hover - for easier navigation.


    


Syntax validation - which makes it much easier to identify typos,
incorrect use of parameters, incomplete definitions, wrong types, invalid or
deprecated machine versions, etc.


    


Usage warnings - which can help identify deprecated parameters, unused
jobs or executors, or missing keys that prevent you from taking advantage of
CircleCI’s full capabilities


    


Auto completion, available both on built-in keys and parameters and on
user-defined variables


    

You can access a full overview of all errors, warnings and hints proposed by the
Config Helper in the Problems tab of VS Code.

    


The Config Helper is based on a dedicated Language Server for CircleCI YAML
files, which is Open Source. You can view its source code, contribute and add
issues directly on the project repository:
circleci-yaml-language-server.

Config validation commands
The extension also provides two commands that help you statically validate your
YAML config files without having to run a pipeline.

    


Validate current configuration file
Corresponds to the CLI command
circleci config validate,
and verifies statically that the config file is well formed. Please note that
this command only validates this file for structure and syntax errors, but
not for semantic error (e.g. this job does not exist).

Validate current configuration file against org policy
Corresponds to the CLI command
circleci policy decide,
and verifies that the configuration file complies with your organization
policies - if any are set.

Please note that this command is only available to Scale customers


View compiled version of current configuration file
This command resolves all orb references in your config file, and shows you
the full-length version of your config.


All these commands can also be invoked:

by right-clicking on a CircleCI YAML file:


    


by clicking on the CircleCI button on the top right corner of the page, when
focusing on a CircleCI YAML file. Please note that the button will not be
visible if you are editing a different file.


    

🆕 Test run your config (Open Preview)

NOTE: The ability to trigger a pipeline from VS Code with a unversioned
config is currently in Open Preview, and only available for projects
integrated through the GitHub OAuth app, or Bitbucket. To find out
which GitHub account type you have, see the
documentation about GitHub OAuth app integration.

Trigger pipelines from VS Code to iterate on your CircleCI config without
committing your trial and error changes to your version control system. Run and
validate your full pipeline, or select jobs and workflows to validate
individually. View the results of your test runs in the Pipelines Panel or in
the CircleCI web app, just the same as any other pipeline.

Prerequisites

v2.0 or higher of the CircleCI VS Code extension
A CircleCI account integrated through the GitHub OAuth app, or Bitbucket. To
find out which GitHub account type you have, check
this docs page.
Your org must have opted-in to this feature through Organization Settings. You
may need to ask your org admin to do so for you. See the section Feature
controls below for more details.
Your project must not make use of
dynamic configuration. This
feature is disabled for projects that use dynamic configuration.

NOTE: Unversioned config in CircleCI indicates that the
.circleci/config.yml on the branch where the pipeline is running is ignored,
and instead, the configuration file is overridden by a custom configuration file
passed as a parameter. The term “unversioned” refers to the fact the config file
is not versioned in the VCS. It is, however, stored in CircleCI along with the
pipeline, and it is available at any time in the CircleCI web app.

Please use caution when running pipelines with unversioned configuration, and take care to ensure no jobs with unintended effects are included in the run. For more details, see the section Security Implications below. 

Access to this feature is controlled by an opt-in setting which only organization admins can control. Once your organization has opted-in, you can opt-out for each individual project. For more details, see the section Feature-controls below.

Steps
The following steps show how to test run a pipeline from the VS Code extension:

Open VS Code and select the CircleCI logo in the sidebar. The Pipelines
and Run panels will be visible
Expand the Run panel to view your projects.
For each project, there is a button to trigger the config test run, and check
boxes for each workflow and job for you to choose which parts of your config
you want to run. Select your options, and click icon:play[]. Any local change
you make to your .circleci/config.yml file will be included in the test
run.
The pipeline is now visible in your dashboard in the CircleCI web app, at
app.circleci.com/pipelines/, and the
Pipelines Panel in the VS Code extension.

Feature controls
The ability to trigger pipelines from VS Code can be controlled at the org
level and at the project level.

Opt-in organization level setting. This can be changed only by
organization admins, and overrides project settings.
Setting location:
Organization Settings > Advanced > Allow triggering pipelines with unversioned config
in the Web App.

Opt-out project level setting.
Setting location:
Project Settings > VS Code integration > Allow triggering pipelines with unversioned config
in the Web App.


Security Implications
Running pipelines with unversioned config can cause security vulnerabilities.
Before enabling this feature, please acknowledge the risks outlined in the
official Docs.

Troubleshooting
Here are some frequently encountered issues, and some clarifications on each of
them.

“Your project could not be detected because no workspace is currently open”
You can fix this issue by opening a folder or workspace. Alternatively, you
can select to follow a CircleCI project manually from the Settings page.

The following errors concern the ability of the extension to link your
workspace to a Git repository.

“Your project could not be detected because we couldn’t find a Git repository associated with this workspace”
“Your project could not be detected because we were unable to get the list of git remotes”
“Your project could not be detected because we could not find default remote of your Git repository”
“Your project could not be detected because we were unable to get the URL of the Git remote XYZ”

When any of these errors occur, you might want to check that your workspace
has a valid Git remote URL. You can also fix this issue by selecting to follow
a CircleCI project manually from the Settings page.

“Your project could not be detected because CircleCI does not know this project”
This error indicates that the repository associated with your workspace
doesn’t appear to be a CircleCI project. If this is unexpected, verify the Git
remote URL associated with your repository, and ensure that you see this
project on the CircleCI web app. You can also address this issue by selecting
to follow a CircleCI project manually from the Settings page.

“Your project could not be detected because you don't follow this project on CircleCI”
When you see this error, you might want to visit the
Projects page on the CircleCI app
and ensure that you “follow” the project associated with this workspace.

“connection to server is erroring. Shutting down server”
This message indicates that the CircleCI Language Server has crashed. This
might be caused by an unexpected parsing error. For this reason, it is likely
that this issue will always occur on the same file. If you identify a file
that causes this error, it would be helpful if you could inform us at XXXXXX
(in the future on the LS open source repo)

When interacting with pipelines, workflows and jobs, you might see the
following errors.

“Cannot refresh pipelines: [runtime error message]”
“Download failed [runtime error message”’
“Cannot rerun workflow because: [runtime error message]”
“Job approval failed: [runtime error message]”

Please keep in mind that one of the causes for any of the above error messages
could be network issues. If you see any of these messages repeatedly, we
recommend you check your internet connection.

The following errors should never occur. Should you see any of them and be
able to reproduce them appearing, it would be helpful if you could report this
to us.

“Target entity can not be cancelled because it is not a workflow / job”
“Your project is not set up”
“Can not cancel your job because it has no job number”



Need support?
How to contact us
If you find any bugs with this extension or want to provide feedback, you can
contact us at
cci-vscode-feedback@circleci.com.
Documentation
You can find more information about CircleCI on our
official documentation.
How to contribute
The Language Server upon which the Conifg Helper is based is Open Source. If you
would like to contribute to the project, feel free to open a PR or get in touch
with us through the
circleci-yaml-language-server repository.
Additional resources
Data and Telemetry
The CircleCI VS Code extension collects usage data for product improvement
purposes, respecting the isTelemetryEnabled and telemetry.telemetryLevel
settings provided by VS Code.
It can be opted out through the VS Code settings page.
Privacy Policy
By signing in to this extension, you agree to the
CircleCI Privacy Policy.
Acknowledgements
This project was made possible by the community surrounding it. You can find
more information about the people and projects which contributed to this
extension in the file CREDITS.md.
We were also inspired by the great work done by community-built extensions:

Jody's Extension for CircleCI
CircleCI Status
vscode-circleci
circleci-conig-validator
Local-CI


© 2023 Circle Internet Services, Inc.\nThe official CircleCI VS Code extension is a new way to interact with CircleCI.
This extension provides an interface to visualize and manage CircleCI pipelines
directly from your IDE, as well as providing contextual help when creating,
modifying and editing CircleCI YAML config files. This way, it avoids expensive
context-switching between VS Code and your browser.
More practically, this extension allows you to:

Authenticate and connect VS Code to CircleCI
Browse and interact with your pipelines. Available actions include

Viewing pipelines, workflows, and jobs statuses
Viewing test outputs
Browsing job logs
Downloading artifacts
Approving jobs
Re-running builds
Debugging jobs with SSH


Be alerted through notifications when your workflows change status or need
your attention
Access in-file support when editing CircleCI YAML configuration files,
including:

Syntax validation
Syntax highlighting
Go-to-definition and go-to-reference
On-hover documentation and usage hints
Autocompletion


Launch commands to validate config files statically, or against your org
policy


    

Getting started
It’s easy to get started with CircleCI for VS Code.

Install the extension
You can install the CircleCI extension from within VS Code, or download it
from the marketplace.
⚠️ This extension is compatible with VS Code versions 1.85 or above.

Authenticate into CircleCI
Open the CircleCI Panel by clicking on the CircleCI icon on the activity bar
on the left of your screen, then click on “Log in”.
   
    

You will be prompted to enter a
Personal API Token. If you
don't have one, you can generate a new one for this purpose.
If you are an Enterprise customer, make sure to check the box and enter your
self-hosted server URL.

Setup your project
If your VS Code workspace contains one or more CircleCI projects, the
extension will detect them automatically, and the Pipelines Panel will be
populated with your most recent pipelines.
If no project is detected, open the settings page (through the VS Code
command CircleCI: Open Settings, or by clicking on the settings icon (⚙️)
at the top of the Pipelines Panel), and select your projects manually.
Please note that your manual selection will only be persisted if no projects
are detected automatically.
   ⚠️ Automatic project detection does not work for GitLab projects. Please select your project manually from the Settings page.





Configure your Pipelines Panel
By default, your Pipelines Panel will display all the latest pipelines run on
your project. However, you can configure it to show you only the pipelines
you are interested in.
All configurations are available in the Settings page, which you can open
with the command CircleCI: Open Settings or by clicking on the settings
icon (⚙️) at the top of the Pipelines Panel.
Specifically, you can choose to follow:

Only your pipelines, or those authored by anyone
All branches, only your current branch, or a specific branch. You can also
select the checkbox “Always display default branch”
Only pipelines that include workflows and jobs with specific statuses.


    


Configure notifications
You can set up pop-up notifications to warn you when a workflow in your
Pipelines Panel has changed status.
 
   
 
By default, you will receive a pop-up notification every time one of the
workflows in your Pipelines Panel enters a failing status, or needs your
approval.
If you wish to alter these defaults, you can:

Mute notifications (a toggle button to change this setting is also
available at the top of the Pipelines Panel)



Configure which workflow status changes you want to be notified about

Please note that you can only be notified about workflows that appear in your
Pipelines Panel.
 
     
 


The Pipelines Panel
The Pipelines Panel lists all CircleCI projects detected in your workspace. For
each project, it shows the most recent pipelines, jobs and workflows, and lets
you monitor their status and interact with them.

    

For some tree objects, you can perform actions by clicking on the icons which
appear when you hover over the item.
Project
Projects are the top level tree items, and they contain your pipelines.

If you don't follow a project, you can also use the panel to follow it.
Pipeline
Pipelines
are nested under projects. They are the CircleCI unit of change, and they
contain your workflows.

Workflow
Workflows
are nested under each Pipeline, and contain Jobs. Hovering over a Workflow lets
you:

Open in browser, to view workflow details in the CircleCI app, on your default
web browser
Rerun workflow from start, to re-triggered the entire workflow
Rerun workflow from failed, to re-triggered the workflow starting from the
first failed job

Job
Jobs
are nested under each Workflow, and can contain Tests and Artifacts. Hovering
over a Job lets you:

Approve the job (only if the job is on hold)
Cancel the job (only if the job is running)
Rerun the job with SSH (you can read more about this functionality in a later
section)
View job details


    

By expanding a Job, you can also:

Load tests, if you have configured your tests to upload test results to
CircleCI. Tests that CircleCI has detected as flaky will be prefaced by the
indication [FLAKY].
Load artifacts, to load any artifacts created by the Job. Once the
artifacts are loaded, you can download them by clicking on them.

Re-run with SSH
You can re-run jobs with SSH directly from VS Code, either:

through the Job Details page, by clicking on the green button on the top
right:



or by clicking on the action icon next to the job name in the Pipelines Panel.


    

In both cases, you will be presented with two options:

Open SSH session in terminal


    


Open SSH session in remote VS Code window

This feature requires the official VS Code extension
Remote - SSH.
You can find more information on Remote Development using SSH in VS Code
directly in the
VS Code docs.




    

To rerun your job with SSH, you will first have to set the path to your Github
or Bitbucket SSH key. The first time you attempt to re-run with SSH, the
extension will guide you to select the path of the relevant SSH key. However, if
you miss this step or want to modify it at a later time, you can do so from the
dedicated section of the settings page:

    

If the job you want to rerun uses parallelism, you will be able to select which
job you want to SSH into.

You can read more about debugging with SSH on CircleCI
in the Docs.

Status Bar
The Status Bar provides summary information about the state of the CircleCI
extension, your project and your most recent workflow.

    

Specifically, you might see the following statuses:

Not logged in - when clicking on the status bar, the login page will open
No project - when clicking on the status bar, the settings page will open
so you can select a project manually
Success / On hold / Failed, and similar workflow statuses - THIS refers to
the status of the top pipeline in your panel. When clicking on the status bar,
the relative workflow will come into focus on the CircleCI Pipelines Panel.
No internet - when your internet connection is lost

Config Helper
This extension provides in-file assistance with writing, editing and navigating
CircleCI Configuration files.
It is based on a CircleCI-specific Language Server, and offers:

Rich code navigation through “go-to-definition” and “go-to-reference”
commands. This is especially convenient when working on large configuration
files, to verify the definition of custom jobs, executors parameters, or in
turn view where any of them are referenced in the file. Assisted code
navigation also works for Orbs, allowing to explore their definition directly
in the IDE when using the go-to-definition feature on an orb-defined command
or parameter.


    


Contextual documentation and usage hints when hovering on specific keys,
so as to avoid having to continuously switch to the browser to check the docs
whenever you are editing your YAML config. Links to the official CircleCI
documentation are also provided on hover - for easier navigation.


    


Syntax validation - which makes it much easier to identify typos,
incorrect use of parameters, incomplete definitions, wrong types, invalid or
deprecated machine versions, etc.


    


Usage warnings - which can help identify deprecated parameters, unused
jobs or executors, or missing keys that prevent you from taking advantage of
CircleCI’s full capabilities


    


Auto completion, available both on built-in keys and parameters and on
user-defined variables


    

You can access a full overview of all errors, warnings and hints proposed by the
Config Helper in the Problems tab of VS Code.

    


The Config Helper is based on a dedicated Language Server for CircleCI YAML
files, which is Open Source. You can view its source code, contribute and add
issues directly on the project repository:
circleci-yaml-language-server.

Config validation commands
The extension also provides two commands that help you statically validate your
YAML config files without having to run a pipeline.

    


Validate current configuration file
Corresponds to the CLI command
circleci config validate,
and verifies statically that the config file is well formed. Please note that
this command only validates this file for structure and syntax errors, but
not for semantic error (e.g. this job does not exist).

Validate current configuration file against org policy
Corresponds to the CLI command
circleci policy decide,
and verifies that the configuration file complies with your organization
policies - if any are set.

Please note that this command is only available to Scale customers


View compiled version of current configuration file
This command resolves all orb references in your config file, and shows you
the full-length version of your config.


All these commands can also be invoked:

by right-clicking on a CircleCI YAML file:


    


by clicking on the CircleCI button on the top right corner of the page, when
focusing on a CircleCI YAML file. Please note that the button will not be
visible if you are editing a different file.


    

🆕 Test run your config (Open Preview)

NOTE: The ability to trigger a pipeline from VS Code with a unversioned
config is currently in Open Preview, and only available for projects
integrated through the GitHub OAuth app, or Bitbucket. To find out
which GitHub account type you have, see the
documentation about GitHub OAuth app integration.

Trigger pipelines from VS Code to iterate on your CircleCI config without
committing your trial and error changes to your version control system. Run and
validate your full pipeline, or select jobs and workflows to validate
individually. View the results of your test runs in the Pipelines Panel or in
the CircleCI web app, just the same as any other pipeline.

Prerequisites

v2.0 or higher of the CircleCI VS Code extension
A CircleCI account integrated through the GitHub OAuth app, or Bitbucket. To
find out which GitHub account type you have, check
this docs page.
Your org must have opted-in to this feature through Organization Settings. You
may need to ask your org admin to do so for you. See the section Feature
controls below for more details.
Your project must not make use of
dynamic configuration. This
feature is disabled for projects that use dynamic configuration.

NOTE: Unversioned config in CircleCI indicates that the
.circleci/config.yml on the branch where the pipeline is running is ignored,
and instead, the configuration file is overridden by a custom configuration file
passed as a parameter. The term “unversioned” refers to the fact the config file
is not versioned in the VCS. It is, however, stored in CircleCI along with the
pipeline, and it is available at any time in the CircleCI web app.

Please use caution when running pipelines with unversioned configuration, and take care to ensure no jobs with unintended effects are included in the run. For more details, see the section Security Implications below. 

Access to this feature is controlled by an opt-in setting which only organization admins can control. Once your organization has opted-in, you can opt-out for each individual project. For more details, see the section Feature-controls below.

Steps
The following steps show how to test run a pipeline from the VS Code extension:

Open VS Code and select the CircleCI logo in the sidebar. The Pipelines
and Run panels will be visible
Expand the Run panel to view your projects.
For each project, there is a button to trigger the config test run, and check
boxes for each workflow and job for you to choose which parts of your config
you want to run. Select your options, and click icon:play[]. Any local change
you make to your .circleci/config.yml file will be included in the test
run.
The pipeline is now visible in your dashboard in the CircleCI web app, at
app.circleci.com/pipelines/, and the
Pipelines Panel in the VS Code extension.

Feature controls
The ability to trigger pipelines from VS Code can be controlled at the org
level and at the project level.

Opt-in organization level setting. This can be changed only by
organization admins, and overrides project settings.
Setting location:
Organization Settings > Advanced > Allow triggering pipelines with unversioned config
in the Web App.

Opt-out project level setting.
Setting location:
Project Settings > VS Code integration > Allow triggering pipelines with unversioned config
in the Web App.


Security Implications
Running pipelines with unversioned config can cause security vulnerabilities.
Before enabling this feature, please acknowledge the risks outlined in the
official Docs.

Troubleshooting
Here are some frequently encountered issues, and some clarifications on each of
them.

“Your project could not be detected because no workspace is currently open”
You can fix this issue by opening a folder or workspace. Alternatively, you
can select to follow a CircleCI project manually from the Settings page.

The following errors concern the ability of the extension to link your
workspace to a Git repository.

“Your project could not be detected because we couldn’t find a Git repository associated with this workspace”
“Your project could not be detected because we were unable to get the list of git remotes”
“Your project could not be detected because we could not find default remote of your Git repository”
“Your project could not be detected because we were unable to get the URL of the Git remote XYZ”

When any of these errors occur, you might want to check that your workspace
has a valid Git remote URL. You can also fix this issue by selecting to follow
a CircleCI project manually from the Settings page.

“Your project could not be detected because CircleCI does not know this project”
This error indicates that the repository associated with your workspace
doesn’t appear to be a CircleCI project. If this is unexpected, verify the Git
remote URL associated with your repository, and ensure that you see this
project on the CircleCI web app. You can also address this issue by selecting
to follow a CircleCI project manually from the Settings page.

“Your project could not be detected because you don't follow this project on CircleCI”
When you see this error, you might want to visit the
Projects page on the CircleCI app
and ensure that you “follow” the project associated with this workspace.

“connection to server is erroring. Shutting down server”
This message indicates that the CircleCI Language Server has crashed. This
might be caused by an unexpected parsing error. For this reason, it is likely
that this issue will always occur on the same file. If you identify a file
that causes this error, it would be helpful if you could inform us at XXXXXX
(in the future on the LS open source repo)

When interacting with pipelines, workflows and jobs, you might see the
following errors.

“Cannot refresh pipelines: [runtime error message]”
“Download failed [runtime error message”’
“Cannot rerun workflow because: [runtime error message]”
“Job approval failed: [runtime error message]”

Please keep in mind that one of the causes for any of the above error messages
could be network issues. If you see any of these messages repeatedly, we
recommend you check your internet connection.

The following errors should never occur. Should you see any of them and be
able to reproduce them appearing, it would be helpful if you could report this
to us.

“Target entity can not be cancelled because it is not a workflow / job”
“Your project is not set up”
“Can not cancel your job because it has no job number”



Need support?
How to contact us
If you find any bugs with this extension or want to provide feedback, you can
contact us at
cci-vscode-feedback@circleci.com.
Documentation
You can find more information about CircleCI on our
official documentation.
How to contribute
The Language Server upon which the Conifg Helper is based is Open Source. If you
would like to contribute to the project, feel free to open a PR or get in touch
with us through the
circleci-yaml-language-server repository.
Additional resources
Data and Telemetry
The CircleCI VS Code extension collects usage data for product improvement
purposes, respecting the isTelemetryEnabled and telemetry.telemetryLevel
settings provided by VS Code.
It can be opted out through the VS Code settings page.
Privacy Policy
By signing in to this extension, you agree to the
CircleCI Privacy Policy.
Acknowledgements
This project was made possible by the community surrounding it. You can find
more information about the people and projects which contributed to this
extension in the file CREDITS.md.
We were also inspired by the great work done by community-built extensions:

Jody's Extension for CircleCI
CircleCI Status
vscode-circleci
circleci-conig-validator
Local-CI


© 2023 Circle Internet Services, Inc.\nThe official CircleCI VS Code extension is a new way to interact with CircleCI.
This extension provides an interface to visualize and manage CircleCI pipelines
directly from your IDE, as well as providing contextual help when creating,
modifying and editing CircleCI YAML config files. This way, it avoids expensive
context-switching between VS Code and your browser.
More practically, this extension allows you to:

Authenticate and connect VS Code to CircleCI
Browse and interact with your pipelines. Available actions include

Viewing pipelines, workflows, and jobs statuses
Viewing test outputs
Browsing job logs
Downloading artifacts
Approving jobs
Re-running builds
Debugging jobs with SSH


Be alerted through notifications when your workflows change status or need
your attention
Access in-file support when editing CircleCI YAML configuration files,
including:

Syntax validation
Syntax highlighting
Go-to-definition and go-to-reference
On-hover documentation and usage hints
Autocompletion


Launch commands to validate config files statically, or against your org
policy


    

Getting started
It’s easy to get started with CircleCI for VS Code.

Install the extension
You can install the CircleCI extension from within VS Code, or download it
from the marketplace.
⚠️ This extension is compatible with VS Code versions 1.85 or above.

Authenticate into CircleCI
Open the CircleCI Panel by clicking on the CircleCI icon on the activity bar
on the left of your screen, then click on “Log in”.
   
    

You will be prompted to enter a
Personal API Token. If you
don't have one, you can generate a new one for this purpose.
If you are an Enterprise customer, make sure to check the box and enter your
self-hosted server URL.

Setup your project
If your VS Code workspace contains one or more CircleCI projects, the
extension will detect them automatically, and the Pipelines Panel will be
populated with your most recent pipelines.
If no project is detected, open the settings page (through the VS Code
command CircleCI: Open Settings, or by clicking on the settings icon (⚙️)
at the top of the Pipelines Panel), and select your projects manually.
Please note that your manual selection will only be persisted if no projects
are detected automatically.
   ⚠️ Automatic project detection does not work for GitLab projects. Please select your project manually from the Settings page.





Configure your Pipelines Panel
By default, your Pipelines Panel will display all the latest pipelines run on
your project. However, you can configure it to show you only the pipelines
you are interested in.
All configurations are available in the Settings page, which you can open
with the command CircleCI: Open Settings or by clicking on the settings
icon (⚙️) at the top of the Pipelines Panel.
Specifically, you can choose to follow:

Only your pipelines, or those authored by anyone
All branches, only your current branch, or a specific branch. You can also
select the checkbox “Always display default branch”
Only pipelines that include workflows and jobs with specific statuses.


    


Configure notifications
You can set up pop-up notifications to warn you when a workflow in your
Pipelines Panel has changed status.
 
   
 
By default, you will receive a pop-up notification every time one of the
workflows in your Pipelines Panel enters a failing status, or needs your
approval.
If you wish to alter these defaults, you can:

Mute notifications (a toggle button to change this setting is also
available at the top of the Pipelines Panel)



Configure which workflow status changes you want to be notified about

Please note that you can only be notified about workflows that appear in your
Pipelines Panel.
 
     
 


The Pipelines Panel
The Pipelines Panel lists all CircleCI projects detected in your workspace. For
each project, it shows the most recent pipelines, jobs and workflows, and lets
you monitor their status and interact with them.

    

For some tree objects, you can perform actions by clicking on the icons which
appear when you hover over the item.
Project
Projects are the top level tree items, and they contain your pipelines.

If you don't follow a project, you can also use the panel to follow it.
Pipeline
Pipelines
are nested under projects. They are the CircleCI unit of change, and they
contain your workflows.

Workflow
Workflows
are nested under each Pipeline, and contain Jobs. Hovering over a Workflow lets
you:

Open in browser, to view workflow details in the CircleCI app, on your default
web browser
Rerun workflow from start, to re-triggered the entire workflow
Rerun workflow from failed, to re-triggered the workflow starting from the
first failed job

Job
Jobs
are nested under each Workflow, and can contain Tests and Artifacts. Hovering
over a Job lets you:

Approve the job (only if the job is on hold)
Cancel the job (only if the job is running)
Rerun the job with SSH (you can read more about this functionality in a later
section)
View job details


    

By expanding a Job, you can also:

Load tests, if you have configured your tests to upload test results to
CircleCI. Tests that CircleCI has detected as flaky will be prefaced by the
indication [FLAKY].
Load artifacts, to load any artifacts created by the Job. Once the
artifacts are loaded, you can download them by clicking on them.

Re-run with SSH
You can re-run jobs with SSH directly from VS Code, either:

through the Job Details page, by clicking on the green button on the top
right:



or by clicking on the action icon next to the job name in the Pipelines Panel.


    

In both cases, you will be presented with two options:

Open SSH session in terminal


    


Open SSH session in remote VS Code window

This feature requires the official VS Code extension
Remote - SSH.
You can find more information on Remote Development using SSH in VS Code
directly in the
VS Code docs.




    

To rerun your job with SSH, you will first have to set the path to your Github
or Bitbucket SSH key. The first time you attempt to re-run with SSH, the
extension will guide you to select the path of the relevant SSH key. However, if
you miss this step or want to modify it at a later time, you can do so from the
dedicated section of the settings page:

    

If the job you want to rerun uses parallelism, you will be able to select which
job you want to SSH into.

You can read more about debugging with SSH on CircleCI
in the Docs.

Status Bar
The Status Bar provides summary information about the state of the CircleCI
extension, your project and your most recent workflow.

    

Specifically, you might see the following statuses:

Not logged in - when clicking on the status bar, the login page will open
No project - when clicking on the status bar, the settings page will open
so you can select a project manually
Success / On hold / Failed, and similar workflow statuses - THIS refers to
the status of the top pipeline in your panel. When clicking on the status bar,
the relative workflow will come into focus on the CircleCI Pipelines Panel.
No internet - when your internet connection is lost

Config Helper
This extension provides in-file assistance with writing, editing and navigating
CircleCI Configuration files.
It is based on a CircleCI-specific Language Server, and offers:

Rich code navigation through “go-to-definition” and “go-to-reference”
commands. This is especially convenient when working on large configuration
files, to verify the definition of custom jobs, executors parameters, or in
turn view where any of them are referenced in the file. Assisted code
navigation also works for Orbs, allowing to explore their definition directly
in the IDE when using the go-to-definition feature on an orb-defined command
or parameter.


    


Contextual documentation and usage hints when hovering on specific keys,
so as to avoid having to continuously switch to the browser to check the docs
whenever you are editing your YAML config. Links to the official CircleCI
documentation are also provided on hover - for easier navigation.


    


Syntax validation - which makes it much easier to identify typos,
incorrect use of parameters, incomplete definitions, wrong types, invalid or
deprecated machine versions, etc.


    


Usage warnings - which can help identify deprecated parameters, unused
jobs or executors, or missing keys that prevent you from taking advantage of
CircleCI’s full capabilities


    


Auto completion, available both on built-in keys and parameters and on
user-defined variables


    

You can access a full overview of all errors, warnings and hints proposed by the
Config Helper in the Problems tab of VS Code.

    


The Config Helper is based on a dedicated Language Server for CircleCI YAML
files, which is Open Source. You can view its source code, contribute and add
issues directly on the project repository:
circleci-yaml-language-server.

Config validation commands
The extension also provides two commands that help you statically validate your
YAML config files without having to run a pipeline.

    


Validate current configuration file
Corresponds to the CLI command
circleci config validate,
and verifies statically that the config file is well formed. Please note that
this command only validates this file for structure and syntax errors, but
not for semantic error (e.g. this job does not exist).

Validate current configuration file against org policy
Corresponds to the CLI command
circleci policy decide,
and verifies that the configuration file complies with your organization
policies - if any are set.

Please note that this command is only available to Scale customers


View compiled version of current configuration file
This command resolves all orb references in your config file, and shows you
the full-length version of your config.


All these commands can also be invoked:

by right-clicking on a CircleCI YAML file:


    


by clicking on the CircleCI button on the top right corner of the page, when
focusing on a CircleCI YAML file. Please note that the button will not be
visible if you are editing a different file.


    

🆕 Test run your config (Open Preview)

NOTE: The ability to trigger a pipeline from VS Code with a unversioned
config is currently in Open Preview, and only available for projects
integrated through the GitHub OAuth app, or Bitbucket. To find out
which GitHub account type you have, see the
documentation about GitHub OAuth app integration.

Trigger pipelines from VS Code to iterate on your CircleCI config without
committing your trial and error changes to your version control system. Run and
validate your full pipeline, or select jobs and workflows to validate
individually. View the results of your test runs in the Pipelines Panel or in
the CircleCI web app, just the same as any other pipeline.

Prerequisites

v2.0 or higher of the CircleCI VS Code extension
A CircleCI account integrated through the GitHub OAuth app, or Bitbucket. To
find out which GitHub account type you have, check
this docs page.
Your org must have opted-in to this feature through Organization Settings. You
may need to ask your org admin to do so for you. See the section Feature
controls below for more details.
Your project must not make use of
dynamic configuration. This
feature is disabled for projects that use dynamic configuration.

NOTE: Unversioned config in CircleCI indicates that the
.circleci/config.yml on the branch where the pipeline is running is ignored,
and instead, the configuration file is overridden by a custom configuration file
passed as a parameter. The term “unversioned” refers to the fact the config file
is not versioned in the VCS. It is, however, stored in CircleCI along with the
pipeline, and it is available at any time in the CircleCI web app.

Please use caution when running pipelines with unversioned configuration, and take care to ensure no jobs with unintended effects are included in the run. For more details, see the section Security Implications below. 

Access to this feature is controlled by an opt-in setting which only organization admins can control. Once your organization has opted-in, you can opt-out for each individual project. For more details, see the section Feature-controls below.

Steps
The following steps show how to test run a pipeline from the VS Code extension:

Open VS Code and select the CircleCI logo in the sidebar. The Pipelines
and Run panels will be visible
Expand the Run panel to view your projects.
For each project, there is a button to trigger the config test run, and check
boxes for each workflow and job for you to choose which parts of your config
you want to run. Select your options, and click icon:play[]. Any local change
you make to your .circleci/config.yml file will be included in the test
run.
The pipeline is now visible in your dashboard in the CircleCI web app, at
app.circleci.com/pipelines/, and the
Pipelines Panel in the VS Code extension.

Feature controls
The ability to trigger pipelines from VS Code can be controlled at the org
level and at the project level.

Opt-in organization level setting. This can be changed only by
organization admins, and overrides project settings.
Setting location:
Organization Settings > Advanced > Allow triggering pipelines with unversioned config
in the Web App.

Opt-out project level setting.
Setting location:
Project Settings > VS Code integration > Allow triggering pipelines with unversioned config
in the Web App.


Security Implications
Running pipelines with unversioned config can cause security vulnerabilities.
Before enabling this feature, please acknowledge the risks outlined in the
official Docs.

Troubleshooting
Here are some frequently encountered issues, and some clarifications on each of
them.

“Your project could not be detected because no workspace is currently open”
You can fix this issue by opening a folder or workspace. Alternatively, you
can select to follow a CircleCI project manually from the Settings page.

The following errors concern the ability of the extension to link your
workspace to a Git repository.

“Your project could not be detected because we couldn’t find a Git repository associated with this workspace”
“Your project could not be detected because we were unable to get the list of git remotes”
“Your project could not be detected because we could not find default remote of your Git repository”
“Your project could not be detected because we were unable to get the URL of the Git remote XYZ”

When any of these errors occur, you might want to check that your workspace
has a valid Git remote URL. You can also fix this issue by selecting to follow
a CircleCI project manually from the Settings page.

“Your project could not be detected because CircleCI does not know this project”
This error indicates that the repository associated with your workspace
doesn’t appear to be a CircleCI project. If this is unexpected, verify the Git
remote URL associated with your repository, and ensure that you see this
project on the CircleCI web app. You can also address this issue by selecting
to follow a CircleCI project manually from the Settings page.

“Your project could not be detected because you don't follow this project on CircleCI”
When you see this error, you might want to visit the
Projects page on the CircleCI app
and ensure that you “follow” the project associated with this workspace.

“connection to server is erroring. Shutting down server”
This message indicates that the CircleCI Language Server has crashed. This
might be caused by an unexpected parsing error. For this reason, it is likely
that this issue will always occur on the same file. If you identify a file
that causes this error, it would be helpful if you could inform us at XXXXXX
(in the future on the LS open source repo)

When interacting with pipelines, workflows and jobs, you might see the
following errors.

“Cannot refresh pipelines: [runtime error message]”
“Download failed [runtime error message”’
“Cannot rerun workflow because: [runtime error message]”
“Job approval failed: [runtime error message]”

Please keep in mind that one of the causes for any of the above error messages
could be network issues. If you see any of these messages repeatedly, we
recommend you check your internet connection.

The following errors should never occur. Should you see any of them and be
able to reproduce them appearing, it would be helpful if you could report this
to us.

“Target entity can not be cancelled because it is not a workflow / job”
“Your project is not set up”
“Can not cancel your job because it has no job number”



Need support?
How to contact us
If you find any bugs with this extension or want to provide feedback, you can
contact us at
cci-vscode-feedback@circleci.com.
Documentation
You can find more information about CircleCI on our
official documentation.
How to contribute
The Language Server upon which the Conifg Helper is based is Open Source. If you
would like to contribute to the project, feel free to open a PR or get in touch
with us through the
circleci-yaml-language-server repository.
Additional resources
Data and Telemetry
The CircleCI VS Code extension collects usage data for product improvement
purposes, respecting the isTelemetryEnabled and telemetry.telemetryLevel
settings provided by VS Code.
It can be opted out through the VS Code settings page.
Privacy Policy
By signing in to this extension, you agree to the
CircleCI Privacy Policy.
Acknowledgements
This project was made possible by the community surrounding it. You can find
more information about the people and projects which contributed to this
extension in the file CREDITS.md.
We were also inspired by the great work done by community-built extensions:

Jody's Extension for CircleCI
CircleCI Status
vscode-circleci
circleci-conig-validator
Local-CI


© 2023 Circle Internet Services, Inc.\nThe official CircleCI VS Code extension is a new way to interact with CircleCI.
This extension provides an interface to visualize and manage CircleCI pipelines
directly from your IDE, as well as providing contextual help when creating,
modifying and editing CircleCI YAML config files. This way, it avoids expensive
context-switching between VS Code and your browser.
More practically, this extension allows you to:

Authenticate and connect VS Code to CircleCI
Browse and interact with your pipelines. Available actions include

Viewing pipelines, workflows, and jobs statuses
Viewing test outputs
Browsing job logs
Downloading artifacts
Approving jobs
Re-running builds
Debugging jobs with SSH


Be alerted through notifications when your workflows change status or need
your attention
Access in-file support when editing CircleCI YAML configuration files,
including:

Syntax validation
Syntax highlighting
Go-to-definition and go-to-reference
On-hover documentation and usage hints
Autocompletion


Launch commands to validate config files statically, or against your org
policy


    

Getting started
It’s easy to get started with CircleCI for VS Code.

Install the extension
You can install the CircleCI extension from within VS Code, or download it
from the marketplace.
⚠️ This extension is compatible with VS Code versions 1.85 or above.

Authenticate into CircleCI
Open the CircleCI Panel by clicking on the CircleCI icon on the activity bar
on the left of your screen, then click on “Log in”.
   
    

You will be prompted to enter a
Personal API Token. If you
don't have one, you can generate a new one for this purpose.
If you are an Enterprise customer, make sure to check the box and enter your
self-hosted server URL.

Setup your project
If your VS Code workspace contains one or more CircleCI projects, the
extension will detect them automatically, and the Pipelines Panel will be
populated with your most recent pipelines.
If no project is detected, open the settings page (through the VS Code
command CircleCI: Open Settings, or by clicking on the settings icon (⚙️)
at the top of the Pipelines Panel), and select your projects manually.
Please note that your manual selection will only be persisted if no projects
are detected automatically.
   ⚠️ Automatic project detection does not work for GitLab projects. Please select your project manually from the Settings page.





Configure your Pipelines Panel
By default, your Pipelines Panel will display all the latest pipelines run on
your project. However, you can configure it to show you only the pipelines
you are interested in.
All configurations are available in the Settings page, which you can open
with the command CircleCI: Open Settings or by clicking on the settings
icon (⚙️) at the top of the Pipelines Panel.
Specifically, you can choose to follow:

Only your pipelines, or those authored by anyone
All branches, only your current branch, or a specific branch. You can also
select the checkbox “Always display default branch”
Only pipelines that include workflows and jobs with specific statuses.


    


Configure notifications
You can set up pop-up notifications to warn you when a workflow in your
Pipelines Panel has changed status.
 
   
 
By default, you will receive a pop-up notification every time one of the
workflows in your Pipelines Panel enters a failing status, or needs your
approval.
If you wish to alter these defaults, you can:

Mute notifications (a toggle button to change this setting is also
available at the top of the Pipelines Panel)



Configure which workflow status changes you want to be notified about

Please note that you can only be notified about workflows that appear in your
Pipelines Panel.
 
     
 


The Pipelines Panel
The Pipelines Panel lists all CircleCI projects detected in your workspace. For
each project, it shows the most recent pipelines, jobs and workflows, and lets
you monitor their status and interact with them.

    

For some tree objects, you can perform actions by clicking on the icons which
appear when you hover over the item.
Project
Projects are the top level tree items, and they contain your pipelines.

If you don't follow a project, you can also use the panel to follow it.
Pipeline
Pipelines
are nested under projects. They are the CircleCI unit of change, and they
contain your workflows.

Workflow
Workflows
are nested under each Pipeline, and contain Jobs. Hovering over a Workflow lets
you:

Open in browser, to view workflow details in the CircleCI app, on your default
web browser
Rerun workflow from start, to re-triggered the entire workflow
Rerun workflow from failed, to re-triggered the workflow starting from the
first failed job

Job
Jobs
are nested under each Workflow, and can contain Tests and Artifacts. Hovering
over a Job lets you:

Approve the job (only if the job is on hold)
Cancel the job (only if the job is running)
Rerun the job with SSH (you can read more about this functionality in a later
section)
View job details


    

By expanding a Job, you can also:

Load tests, if you have configured your tests to upload test results to
CircleCI. Tests that CircleCI has detected as flaky will be prefaced by the
indication [FLAKY].
Load artifacts, to load any artifacts created by the Job. Once the
artifacts are loaded, you can download them by clicking on them.

Re-run with SSH
You can re-run jobs with SSH directly from VS Code, either:

through the Job Details page, by clicking on the green button on the top
right:



or by clicking on the action icon next to the job name in the Pipelines Panel.


    

In both cases, you will be presented with two options:

Open SSH session in terminal


    


Open SSH session in remote VS Code window

This feature requires the official VS Code extension
Remote - SSH.
You can find more information on Remote Development using SSH in VS Code
directly in the
VS Code docs.




    

To rerun your job with SSH, you will first have to set the path to your Github
or Bitbucket SSH key. The first time you attempt to re-run with SSH, the
extension will guide you to select the path of the relevant SSH key. However, if
you miss this step or want to modify it at a later time, you can do so from the
dedicated section of the settings page:

    

If the job you want to rerun uses parallelism, you will be able to select which
job you want to SSH into.

You can read more about debugging with SSH on CircleCI
in the Docs.

Status Bar
The Status Bar provides summary information about the state of the CircleCI
extension, your project and your most recent workflow.

    

Specifically, you might see the following statuses:

Not logged in - when clicking on the status bar, the login page will open
No project - when clicking on the status bar, the settings page will open
so you can select a project manually
Success / On hold / Failed, and similar workflow statuses - THIS refers to
the status of the top pipeline in your panel. When clicking on the status bar,
the relative workflow will come into focus on the CircleCI Pipelines Panel.
No internet - when your internet connection is lost

Config Helper
This extension provides in-file assistance with writing, editing and navigating
CircleCI Configuration files.
It is based on a CircleCI-specific Language Server, and offers:

Rich code navigation through “go-to-definition” and “go-to-reference”
commands. This is especially convenient when working on large configuration
files, to verify the definition of custom jobs, executors parameters, or in
turn view where any of them are referenced in the file. Assisted code
navigation also works for Orbs, allowing to explore their definition directly
in the IDE when using the go-to-definition feature on an orb-defined command
or parameter.


    


Contextual documentation and usage hints when hovering on specific keys,
so as to avoid having to continuously switch to the browser to check the docs
whenever you are editing your YAML config. Links to the official CircleCI
documentation are also provided on hover - for easier navigation.


    


Syntax validation - which makes it much easier to identify typos,
incorrect use of parameters, incomplete definitions, wrong types, invalid or
deprecated machine versions, etc.


    


Usage warnings - which can help identify deprecated parameters, unused
jobs or executors, or missing keys that prevent you from taking advantage of
CircleCI’s full capabilities


    


Auto completion, available both on built-in keys and parameters and on
user-defined variables


    

You can access a full overview of all errors, warnings and hints proposed by the
Config Helper in the Problems tab of VS Code.

    


The Config Helper is based on a dedicated Language Server for CircleCI YAML
files, which is Open Source. You can view its source code, contribute and add
issues directly on the project repository:
circleci-yaml-language-server.

Config validation commands
The extension also provides two commands that help you statically validate your
YAML config files without having to run a pipeline.

    


Validate current configuration file
Corresponds to the CLI command
circleci config validate,
and verifies statically that the config file is well formed. Please note that
this command only validates this file for structure and syntax errors, but
not for semantic error (e.g. this job does not exist).

Validate current configuration file against org policy
Corresponds to the CLI command
circleci policy decide,
and verifies that the configuration file complies with your organization
policies - if any are set.

Please note that this command is only available to Scale customers


View compiled version of current configuration file
This command resolves all orb references in your config file, and shows you
the full-length version of your config.


All these commands can also be invoked:

by right-clicking on a CircleCI YAML file:


    


by clicking on the CircleCI button on the top right corner of the page, when
focusing on a CircleCI YAML file. Please note that the button will not be
visible if you are editing a different file.


    

🆕 Test run your config (Open Preview)

NOTE: The ability to trigger a pipeline from VS Code with a unversioned
config is currently in Open Preview, and only available for projects
integrated through the GitHub OAuth app, or Bitbucket. To find out
which GitHub account type you have, see the
documentation about GitHub OAuth app integration.

Trigger pipelines from VS Code to iterate on your CircleCI config without
committing your trial and error changes to your version control system. Run and
validate your full pipeline, or select jobs and workflows to validate
individually. View the results of your test runs in the Pipelines Panel or in
the CircleCI web app, just the same as any other pipeline.

Prerequisites

v2.0 or higher of the CircleCI VS Code extension
A CircleCI account integrated through the GitHub OAuth app, or Bitbucket. To
find out which GitHub account type you have, check
this docs page.
Your org must have opted-in to this feature through Organization Settings. You
may need to ask your org admin to do so for you. See the section Feature
controls below for more details.
Your project must not make use of
dynamic configuration. This
feature is disabled for projects that use dynamic configuration.

NOTE: Unversioned config in CircleCI indicates that the
.circleci/config.yml on the branch where the pipeline is running is ignored,
and instead, the configuration file is overridden by a custom configuration file
passed as a parameter. The term “unversioned” refers to the fact the config file
is not versioned in the VCS. It is, however, stored in CircleCI along with the
pipeline, and it is available at any time in the CircleCI web app.

Please use caution when running pipelines with unversioned configuration, and take care to ensure no jobs with unintended effects are included in the run. For more details, see the section Security Implications below. 

Access to this feature is controlled by an opt-in setting which only organization admins can control. Once your organization has opted-in, you can opt-out for each individual project. For more details, see the section Feature-controls below.

Steps
The following steps show how to test run a pipeline from the VS Code extension:

Open VS Code and select the CircleCI logo in the sidebar. The Pipelines
and Run panels will be visible
Expand the Run panel to view your projects.
For each project, there is a button to trigger the config test run, and check
boxes for each workflow and job for you to choose which parts of your config
you want to run. Select your options, and click icon:play[]. Any local change
you make to your .circleci/config.yml file will be included in the test
run.
The pipeline is now visible in your dashboard in the CircleCI web app, at
app.circleci.com/pipelines/, and the
Pipelines Panel in the VS Code extension.

Feature controls
The ability to trigger pipelines from VS Code can be controlled at the org
level and at the project level.

Opt-in organization level setting. This can be changed only by
organization admins, and overrides project settings.
Setting location:
Organization Settings > Advanced > Allow triggering pipelines with unversioned config
in the Web App.

Opt-out project level setting.
Setting location:
Project Settings > VS Code integration > Allow triggering pipelines with unversioned config
in the Web App.


Security Implications
Running pipelines with unversioned config can cause security vulnerabilities.
Before enabling this feature, please acknowledge the risks outlined in the
official Docs.

Troubleshooting
Here are some frequently encountered issues, and some clarifications on each of
them.

“Your project could not be detected because no workspace is currently open”
You can fix this issue by opening a folder or workspace. Alternatively, you
can select to follow a CircleCI project manually from the Settings page.

The following errors concern the ability of the extension to link your
workspace to a Git repository.

“Your project could not be detected because we couldn’t find a Git repository associated with this workspace”
“Your project could not be detected because we were unable to get the list of git remotes”
“Your project could not be detected because we could not find default remote of your Git repository”
“Your project could not be detected because we were unable to get the URL of the Git remote XYZ”

When any of these errors occur, you might want to check that your workspace
has a valid Git remote URL. You can also fix this issue by selecting to follow
a CircleCI project manually from the Settings page.

“Your project could not be detected because CircleCI does not know this project”
This error indicates that the repository associated with your workspace
doesn’t appear to be a CircleCI project. If this is unexpected, verify the Git
remote URL associated with your repository, and ensure that you see this
project on the CircleCI web app. You can also address this issue by selecting
to follow a CircleCI project manually from the Settings page.

“Your project could not be detected because you don't follow this project on CircleCI”
When you see this error, you might want to visit the
Projects page on the CircleCI app
and ensure that you “follow” the project associated with this workspace.

“connection to server is erroring. Shutting down server”
This message indicates that the CircleCI Language Server has crashed. This
might be caused by an unexpected parsing error. For this reason, it is likely
that this issue will always occur on the same file. If you identify a file
that causes this error, it would be helpful if you could inform us at XXXXXX
(in the future on the LS open source repo)

When interacting with pipelines, workflows and jobs, you might see the
following errors.

“Cannot refresh pipelines: [runtime error message]”
“Download failed [runtime error message”’
“Cannot rerun workflow because: [runtime error message]”
“Job approval failed: [runtime error message]”

Please keep in mind that one of the causes for any of the above error messages
could be network issues. If you see any of these messages repeatedly, we
recommend you check your internet connection.

The following errors should never occur. Should you see any of them and be
able to reproduce them appearing, it would be helpful if you could report this
to us.

“Target entity can not be cancelled because it is not a workflow / job”
“Your project is not set up”
“Can not cancel your job because it has no job number”



Need support?
How to contact us
If you find any bugs with this extension or want to provide feedback, you can
contact us at
cci-vscode-feedback@circleci.com.
Documentation
You can find more information about CircleCI on our
official documentation.
How to contribute
The Language Server upon which the Conifg Helper is based is Open Source. If you
would like to contribute to the project, feel free to open a PR or get in touch
with us through the
circleci-yaml-language-server repository.
Additional resources
Data and Telemetry
The CircleCI VS Code extension collects usage data for product improvement
purposes, respecting the isTelemetryEnabled and telemetry.telemetryLevel
settings provided by VS Code.
It can be opted out through the VS Code settings page.
Privacy Policy
By signing in to this extension, you agree to the
CircleCI Privacy Policy.
Acknowledgements
This project was made possible by the community surrounding it. You can find
more information about the people and projects which contributed to this
extension in the file CREDITS.md.
We were also inspired by the great work done by community-built extensions:

Jody's Extension for CircleCI
CircleCI Status
vscode-circleci
circleci-conig-validator
Local-CI


© 2023 Circle Internet Services, Inc.\nThe official CircleCI VS Code extension is a new way to interact with CircleCI.
This extension provides an interface to visualize and manage CircleCI pipelines
directly from your IDE, as well as providing contextual help when creating,
modifying and editing CircleCI YAML config files. This way, it avoids expensive
context-switching between VS Code and your browser.
More practically, this extension allows you to:

Authenticate and connect VS Code to CircleCI
Browse and interact with your pipelines. Available actions include

Viewing pipelines, workflows, and jobs statuses
Viewing test outputs
Browsing job logs
Downloading artifacts
Approving jobs
Re-running builds
Debugging jobs with SSH


Be alerted through notifications when your workflows change status or need
your attention
Access in-file support when editing CircleCI YAML configuration files,
including:

Syntax validation
Syntax highlighting
Go-to-definition and go-to-reference
On-hover documentation and usage hints
Autocompletion


Launch commands to validate config files statically, or against your org
policy


    

Getting started
It’s easy to get started with CircleCI for VS Code.

Install the extension
You can install the CircleCI extension from within VS Code, or download it
from the marketplace.
⚠️ This extension is compatible with VS Code versions 1.85 or above.

Authenticate into CircleCI
Open the CircleCI Panel by clicking on the CircleCI icon on the activity bar
on the left of your screen, then click on “Log in”.
   
    

You will be prompted to enter a
Personal API Token. If you
don't have one, you can generate a new one for this purpose.
If you are an Enterprise customer, make sure to check the box and enter your
self-hosted server URL.

Setup your project
If your VS Code workspace contains one or more CircleCI projects, the
extension will detect them automatically, and the Pipelines Panel will be
populated with your most recent pipelines.
If no project is detected, open the settings page (through the VS Code
command CircleCI: Open Settings, or by clicking on the settings icon (⚙️)
at the top of the Pipelines Panel), and select your projects manually.
Please note that your manual selection will only be persisted if no projects
are detected automatically.
   ⚠️ Automatic project detection does not work for GitLab projects. Please select your project manually from the Settings page.





Configure your Pipelines Panel
By default, your Pipelines Panel will display all the latest pipelines run on
your project. However, you can configure it to show you only the pipelines
you are interested in.
All configurations are available in the Settings page, which you can open
with the command CircleCI: Open Settings or by clicking on the settings
icon (⚙️) at the top of the Pipelines Panel.
Specifically, you can choose to follow:

Only your pipelines, or those authored by anyone
All branches, only your current branch, or a specific branch. You can also
select the checkbox “Always display default branch”
Only pipelines that include workflows and jobs with specific statuses.


    


Configure notifications
You can set up pop-up notifications to warn you when a workflow in your
Pipelines Panel has changed status.
 
   
 
By default, you will receive a pop-up notification every time one of the
workflows in your Pipelines Panel enters a failing status, or needs your
approval.
If you wish to alter these defaults, you can:

Mute notifications (a toggle button to change this setting is also
available at the top of the Pipelines Panel)



Configure which workflow status changes you want to be notified about

Please note that you can only be notified about workflows that appear in your
Pipelines Panel.
 
     
 


The Pipelines Panel
The Pipelines Panel lists all CircleCI projects detected in your workspace. For
each project, it shows the most recent pipelines, jobs and workflows, and lets
you monitor their status and interact with them.

    

For some tree objects, you can perform actions by clicking on the icons which
appear when you hover over the item.
Project
Projects are the top level tree items, and they contain your pipelines.

If you don't follow a project, you can also use the panel to follow it.
Pipeline
Pipelines
are nested under projects. They are the CircleCI unit of change, and they
contain your workflows.

Workflow
Workflows
are nested under each Pipeline, and contain Jobs. Hovering over a Workflow lets
you:

Open in browser, to view workflow details in the CircleCI app, on your default
web browser
Rerun workflow from start, to re-triggered the entire workflow
Rerun workflow from failed, to re-triggered the workflow starting from the
first failed job

Job
Jobs
are nested under each Workflow, and can contain Tests and Artifacts. Hovering
over a Job lets you:

Approve the job (only if the job is on hold)
Cancel the job (only if the job is running)
Rerun the job with SSH (you can read more about this functionality in a later
section)
View job details


    

By expanding a Job, you can also:

Load tests, if you have configured your tests to upload test results to
CircleCI. Tests that CircleCI has detected as flaky will be prefaced by the
indication [FLAKY].
Load artifacts, to load any artifacts created by the Job. Once the
artifacts are loaded, you can download them by clicking on them.

Re-run with SSH
You can re-run jobs with SSH directly from VS Code, either:

through the Job Details page, by clicking on the green button on the top
right:



or by clicking on the action icon next to the job name in the Pipelines Panel.


    

In both cases, you will be presented with two options:

Open SSH session in terminal


    


Open SSH session in remote VS Code window

This feature requires the official VS Code extension
Remote - SSH.
You can find more information on Remote Development using SSH in VS Code
directly in the
VS Code docs.




    

To rerun your job with SSH, you will first have to set the path to your Github
or Bitbucket SSH key. The first time you attempt to re-run with SSH, the
extension will guide you to select the path of the relevant SSH key. However, if
you miss this step or want to modify it at a later time, you can do so from the
dedicated section of the settings page:

    

If the job you want to rerun uses parallelism, you will be able to select which
job you want to SSH into.

You can read more about debugging with SSH on CircleCI
in the Docs.

Status Bar
The Status Bar provides summary information about the state of the CircleCI
extension, your project and your most recent workflow.

    

Specifically, you might see the following statuses:

Not logged in - when clicking on the status bar, the login page will open
No project - when clicking on the status bar, the settings page will open
so you can select a project manually
Success / On hold / Failed, and similar workflow statuses - THIS refers to
the status of the top pipeline in your panel. When clicking on the status bar,
the relative workflow will come into focus on the CircleCI Pipelines Panel.
No internet - when your internet connection is lost

Config Helper
This extension provides in-file assistance with writing, editing and navigating
CircleCI Configuration files.
It is based on a CircleCI-specific Language Server, and offers:

Rich code navigation through “go-to-definition” and “go-to-reference”
commands. This is especially convenient when working on large configuration
files, to verify the definition of custom jobs, executors parameters, or in
turn view where any of them are referenced in the file. Assisted code
navigation also works for Orbs, allowing to explore their definition directly
in the IDE when using the go-to-definition feature on an orb-defined command
or parameter.


    


Contextual documentation and usage hints when hovering on specific keys,
so as to avoid having to continuously switch to the browser to check the docs
whenever you are editing your YAML config. Links to the official CircleCI
documentation are also provided on hover - for easier navigation.


    


Syntax validation - which makes it much easier to identify typos,
incorrect use of parameters, incomplete definitions, wrong types, invalid or
deprecated machine versions, etc.


    


Usage warnings - which can help identify deprecated parameters, unused
jobs or executors, or missing keys that prevent you from taking advantage of
CircleCI’s full capabilities


    


Auto completion, available both on built-in keys and parameters and on
user-defined variables


    

You can access a full overview of all errors, warnings and hints proposed by the
Config Helper in the Problems tab of VS Code.

    


The Config Helper is based on a dedicated Language Server for CircleCI YAML
files, which is Open Source. You can view its source code, contribute and add
issues directly on the project repository:
circleci-yaml-language-server.

Config validation commands
The extension also provides two commands that help you statically validate your
YAML config files without having to run a pipeline.

    


Validate current configuration file
Corresponds to the CLI command
circleci config validate,
and verifies statically that the config file is well formed. Please note that
this command only validates this file for structure and syntax errors, but
not for semantic error (e.g. this job does not exist).

Validate current configuration file against org policy
Corresponds to the CLI command
circleci policy decide,
and verifies that the configuration file complies with your organization
policies - if any are set.

Please note that this command is only available to Scale customers


View compiled version of current configuration file
This command resolves all orb references in your config file, and shows you
the full-length version of your config.


All these commands can also be invoked:

by right-clicking on a CircleCI YAML file:


    


by clicking on the CircleCI button on the top right corner of the page, when
focusing on a CircleCI YAML file. Please note that the button will not be
visible if you are editing a different file.


    

🆕 Test run your config (Open Preview)

NOTE: The ability to trigger a pipeline from VS Code with a unversioned
config is currently in Open Preview, and only available for projects
integrated through the GitHub OAuth app, or Bitbucket. To find out
which GitHub account type you have, see the
documentation about GitHub OAuth app integration.

Trigger pipelines from VS Code to iterate on your CircleCI config without
committing your trial and error changes to your version control system. Run and
validate your full pipeline, or select jobs and workflows to validate
individually. View the results of your test runs in the Pipelines Panel or in
the CircleCI web app, just the same as any other pipeline.

Prerequisites

v2.0 or higher of the CircleCI VS Code extension
A CircleCI account integrated through the GitHub OAuth app, or Bitbucket. To
find out which GitHub account type you have, check
this docs page.
Your org must have opted-in to this feature through Organization Settings. You
may need to ask your org admin to do so for you. See the section Feature
controls below for more details.
Your project must not make use of
dynamic configuration. This
feature is disabled for projects that use dynamic configuration.

NOTE: Unversioned config in CircleCI indicates that the
.circleci/config.yml on the branch where the pipeline is running is ignored,
and instead, the configuration file is overridden by a custom configuration file
passed as a parameter. The term “unversioned” refers to the fact the config file
is not versioned in the VCS. It is, however, stored in CircleCI along with the
pipeline, and it is available at any time in the CircleCI web app.

Please use caution when running pipelines with unversioned configuration, and take care to ensure no jobs with unintended effects are included in the run. For more details, see the section Security Implications below. 

Access to this feature is controlled by an opt-in setting which only organization admins can control. Once your organization has opted-in, you can opt-out for each individual project. For more details, see the section Feature-controls below.

Steps
The following steps show how to test run a pipeline from the VS Code extension:

Open VS Code and select the CircleCI logo in the sidebar. The Pipelines
and Run panels will be visible
Expand the Run panel to view your projects.
For each project, there is a button to trigger the config test run, and check
boxes for each workflow and job for you to choose which parts of your config
you want to run. Select your options, and click icon:play[]. Any local change
you make to your .circleci/config.yml file will be included in the test
run.
The pipeline is now visible in your dashboard in the CircleCI web app, at
app.circleci.com/pipelines/, and the
Pipelines Panel in the VS Code extension.

Feature controls
The ability to trigger pipelines from VS Code can be controlled at the org
level and at the project level.

Opt-in organization level setting. This can be changed only by
organization admins, and overrides project settings.
Setting location:
Organization Settings > Advanced > Allow triggering pipelines with unversioned config
in the Web App.

Opt-out project level setting.
Setting location:
Project Settings > VS Code integration > Allow triggering pipelines with unversioned config
in the Web App.


Security Implications
Running pipelines with unversioned config can cause security vulnerabilities.
Before enabling this feature, please acknowledge the risks outlined in the
official Docs.

Troubleshooting
Here are some frequently encountered issues, and some clarifications on each of
them.

“Your project could not be detected because no workspace is currently open”
You can fix this issue by opening a folder or workspace. Alternatively, you
can select to follow a CircleCI project manually from the Settings page.

The following errors concern the ability of the extension to link your
workspace to a Git repository.

“Your project could not be detected because we couldn’t find a Git repository associated with this workspace”
“Your project could not be detected because we were unable to get the list of git remotes”
“Your project could not be detected because we could not find default remote of your Git repository”
“Your project could not be detected because we were unable to get the URL of the Git remote XYZ”

When any of these errors occur, you might want to check that your workspace
has a valid Git remote URL. You can also fix this issue by selecting to follow
a CircleCI project manually from the Settings page.

“Your project could not be detected because CircleCI does not know this project”
This error indicates that the repository associated with your workspace
doesn’t appear to be a CircleCI project. If this is unexpected, verify the Git
remote URL associated with your repository, and ensure that you see this
project on the CircleCI web app. You can also address this issue by selecting
to follow a CircleCI project manually from the Settings page.

“Your project could not be detected because you don't follow this project on CircleCI”
When you see this error, you might want to visit the
Projects page on the CircleCI app
and ensure that you “follow” the project associated with this workspace.

“connection to server is erroring. Shutting down server”
This message indicates that the CircleCI Language Server has crashed. This
might be caused by an unexpected parsing error. For this reason, it is likely
that this issue will always occur on the same file. If you identify a file
that causes this error, it would be helpful if you could inform us at XXXXXX
(in the future on the LS open source repo)

When interacting with pipelines, workflows and jobs, you might see the
following errors.

“Cannot refresh pipelines: [runtime error message]”
“Download failed [runtime error message”’
“Cannot rerun workflow because: [runtime error message]”
“Job approval failed: [runtime error message]”

Please keep in mind that one of the causes for any of the above error messages
could be network issues. If you see any of these messages repeatedly, we
recommend you check your internet connection.

The following errors should never occur. Should you see any of them and be
able to reproduce them appearing, it would be helpful if you could report this
to us.

“Target entity can not be cancelled because it is not a workflow / job”
“Your project is not set up”
“Can not cancel your job because it has no job number”



Need support?
How to contact us
If you find any bugs with this extension or want to provide feedback, you can
contact us at
cci-vscode-feedback@circleci.com.
Documentation
You can find more information about CircleCI on our
official documentation.
How to contribute
The Language Server upon which the Conifg Helper is based is Open Source. If you
would like to contribute to the project, feel free to open a PR or get in touch
with us through the
circleci-yaml-language-server repository.
Additional resources
Data and Telemetry
The CircleCI VS Code extension collects usage data for product improvement
purposes, respecting the isTelemetryEnabled and telemetry.telemetryLevel
settings provided by VS Code.
It can be opted out through the VS Code settings page.
Privacy Policy
By signing in to this extension, you agree to the
CircleCI Privacy Policy.
Acknowledgements
This project was made possible by the community surrounding it. You can find
more information about the people and projects which contributed to this
extension in the file CREDITS.md.
We were also inspired by the great work done by community-built extensions:

Jody's Extension for CircleCI
CircleCI Status
vscode-circleci
circleci-conig-validator
Local-CI


© 2023 Circle Internet Services, Inc.\nThe official CircleCI VS Code extension is a new way to interact with CircleCI.
This extension provides an interface to visualize and manage CircleCI pipelines
directly from your IDE, as well as providing contextual help when creating,
modifying and editing CircleCI YAML config files. This way, it avoids expensive
context-switching between VS Code and your browser.
More practically, this extension allows you to:

Authenticate and connect VS Code to CircleCI
Browse and interact with your pipelines. Available actions include

Viewing pipelines, workflows, and jobs statuses
Viewing test outputs
Browsing job logs
Downloading artifacts
Approving jobs
Re-running builds
Debugging jobs with SSH


Be alerted through notifications when your workflows change status or need
your attention
Access in-file support when editing CircleCI YAML configuration files,
including:

Syntax validation
Syntax highlighting
Go-to-definition and go-to-reference
On-hover documentation and usage hints
Autocompletion


Launch commands to validate config files statically, or against your org
policy


    

Getting started
It’s easy to get started with CircleCI for VS Code.

Install the extension
You can install the CircleCI extension from within VS Code, or download it
from the marketplace.
⚠️ This extension is compatible with VS Code versions 1.85 or above.

Authenticate into CircleCI
Open the CircleCI Panel by clicking on the CircleCI icon on the activity bar
on the left of your screen, then click on “Log in”.
   
    

You will be prompted to enter a
Personal API Token. If you
don't have one, you can generate a new one for this purpose.
If you are an Enterprise customer, make sure to check the box and enter your
self-hosted server URL.

Setup your project
If your VS Code workspace contains one or more CircleCI projects, the
extension will detect them automatically, and the Pipelines Panel will be
populated with your most recent pipelines.
If no project is detected, open the settings page (through the VS Code
command CircleCI: Open Settings, or by clicking on the settings icon (⚙️)
at the top of the Pipelines Panel), and select your projects manually.
Please note that your manual selection will only be persisted if no projects
are detected automatically.
   ⚠️ Automatic project detection does not work for GitLab projects. Please select your project manually from the Settings page.





Configure your Pipelines Panel
By default, your Pipelines Panel will display all the latest pipelines run on
your project. However, you can configure it to show you only the pipelines
you are interested in.
All configurations are available in the Settings page, which you can open
with the command CircleCI: Open Settings or by clicking on the settings
icon (⚙️) at the top of the Pipelines Panel.
Specifically, you can choose to follow:

Only your pipelines, or those authored by anyone
All branches, only your current branch, or a specific branch. You can also
select the checkbox “Always display default branch”
Only pipelines that include workflows and jobs with specific statuses.


    


Configure notifications
You can set up pop-up notifications to warn you when a workflow in your
Pipelines Panel has changed status.
 
   
 
By default, you will receive a pop-up notification every time one of the
workflows in your Pipelines Panel enters a failing status, or needs your
approval.
If you wish to alter these defaults, you can:

Mute notifications (a toggle button to change this setting is also
available at the top of the Pipelines Panel)



Configure which workflow status changes you want to be notified about

Please note that you can only be notified about workflows that appear in your
Pipelines Panel.
 
     
 


The Pipelines Panel
The Pipelines Panel lists all CircleCI projects detected in your workspace. For
each project, it shows the most recent pipelines, jobs and workflows, and lets
you monitor their status and interact with them.

    

For some tree objects, you can perform actions by clicking on the icons which
appear when you hover over the item.
Project
Projects are the top level tree items, and they contain your pipelines.

If you don't follow a project, you can also use the panel to follow it.
Pipeline
Pipelines
are nested under projects. They are the CircleCI unit of change, and they
contain your workflows.

Workflow
Workflows
are nested under each Pipeline, and contain Jobs. Hovering over a Workflow lets
you:

Open in browser, to view workflow details in the CircleCI app, on your default
web browser
Rerun workflow from start, to re-triggered the entire workflow
Rerun workflow from failed, to re-triggered the workflow starting from the
first failed job

Job
Jobs
are nested under each Workflow, and can contain Tests and Artifacts. Hovering
over a Job lets you:

Approve the job (only if the job is on hold)
Cancel the job (only if the job is running)
Rerun the job with SSH (you can read more about this functionality in a later
section)
View job details


    

By expanding a Job, you can also:

Load tests, if you have configured your tests to upload test results to
CircleCI. Tests that CircleCI has detected as flaky will be prefaced by the
indication [FLAKY].
Load artifacts, to load any artifacts created by the Job. Once the
artifacts are loaded, you can download them by clicking on them.

Re-run with SSH
You can re-run jobs with SSH directly from VS Code, either:

through the Job Details page, by clicking on the green button on the top
right:



or by clicking on the action icon next to the job name in the Pipelines Panel.


    

In both cases, you will be presented with two options:

Open SSH session in terminal


    


Open SSH session in remote VS Code window

This feature requires the official VS Code extension
Remote - SSH.
You can find more information on Remote Development using SSH in VS Code
directly in the
VS Code docs.




    

To rerun your job with SSH, you will first have to set the path to your Github
or Bitbucket SSH key. The first time you attempt to re-run with SSH, the
extension will guide you to select the path of the relevant SSH key. However, if
you miss this step or want to modify it at a later time, you can do so from the
dedicated section of the settings page:

    

If the job you want to rerun uses parallelism, you will be able to select which
job you want to SSH into.

You can read more about debugging with SSH on CircleCI
in the Docs.

Status Bar
The Status Bar provides summary information about the state of the CircleCI
extension, your project and your most recent workflow.

    

Specifically, you might see the following statuses:

Not logged in - when clicking on the status bar, the login page will open
No project - when clicking on the status bar, the settings page will open
so you can select a project manually
Success / On hold / Failed, and similar workflow statuses - THIS refers to
the status of the top pipeline in your panel. When clicking on the status bar,
the relative workflow will come into focus on the CircleCI Pipelines Panel.
No internet - when your internet connection is lost

Config Helper
This extension provides in-file assistance with writing, editing and navigating
CircleCI Configuration files.
It is based on a CircleCI-specific Language Server, and offers:

Rich code navigation through “go-to-definition” and “go-to-reference”
commands. This is especially convenient when working on large configuration
files, to verify the definition of custom jobs, executors parameters, or in
turn view where any of them are referenced in the file. Assisted code
navigation also works for Orbs, allowing to explore their definition directly
in the IDE when using the go-to-definition feature on an orb-defined command
or parameter.


    


Contextual documentation and usage hints when hovering on specific keys,
so as to avoid having to continuously switch to the browser to check the docs
whenever you are editing your YAML config. Links to the official CircleCI
documentation are also provided on hover - for easier navigation.


    


Syntax validation - which makes it much easier to identify typos,
incorrect use of parameters, incomplete definitions, wrong types, invalid or
deprecated machine versions, etc.


    


Usage warnings - which can help identify deprecated parameters, unused
jobs or executors, or missing keys that prevent you from taking advantage of
CircleCI’s full capabilities


    


Auto completion, available both on built-in keys and parameters and on
user-defined variables


    

You can access a full overview of all errors, warnings and hints proposed by the
Config Helper in the Problems tab of VS Code.

    


The Config Helper is based on a dedicated Language Server for CircleCI YAML
files, which is Open Source. You can view its source code, contribute and add
issues directly on the project repository:
circleci-yaml-language-server.

Config validation commands
The extension also provides two commands that help you statically validate your
YAML config files without having to run a pipeline.

    


Validate current configuration file
Corresponds to the CLI command
circleci config validate,
and verifies statically that the config file is well formed. Please note that
this command only validates this file for structure and syntax errors, but
not for semantic error (e.g. this job does not exist).

Validate current configuration file against org policy
Corresponds to the CLI command
circleci policy decide,
and verifies that the configuration file complies with your organization
policies - if any are set.

Please note that this command is only available to Scale customers


View compiled version of current configuration file
This command resolves all orb references in your config file, and shows you
the full-length version of your config.


All these commands can also be invoked:

by right-clicking on a CircleCI YAML file:


    


by clicking on the CircleCI button on the top right corner of the page, when
focusing on a CircleCI YAML file. Please note that the button will not be
visible if you are editing a different file.


    

🆕 Test run your config (Open Preview)

NOTE: The ability to trigger a pipeline from VS Code with a unversioned
config is currently in Open Preview, and only available for projects
integrated through the GitHub OAuth app, or Bitbucket. To find out
which GitHub account type you have, see the
documentation about GitHub OAuth app integration.

Trigger pipelines from VS Code to iterate on your CircleCI config without
committing your trial and error changes to your version control system. Run and
validate your full pipeline, or select jobs and workflows to validate
individually. View the results of your test runs in the Pipelines Panel or in
the CircleCI web app, just the same as any other pipeline.

Prerequisites

v2.0 or higher of the CircleCI VS Code extension
A CircleCI account integrated through the GitHub OAuth app, or Bitbucket. To
find out which GitHub account type you have, check
this docs page.
Your org must have opted-in to this feature through Organization Settings. You
may need to ask your org admin to do so for you. See the section Feature
controls below for more details.
Your project must not make use of
dynamic configuration. This
feature is disabled for projects that use dynamic configuration.

NOTE: Unversioned config in CircleCI indicates that the
.circleci/config.yml on the branch where the pipeline is running is ignored,
and instead, the configuration file is overridden by a custom configuration file
passed as a parameter. The term “unversioned” refers to the fact the config file
is not versioned in the VCS. It is, however, stored in CircleCI along with the
pipeline, and it is available at any time in the CircleCI web app.

Please use caution when running pipelines with unversioned configuration, and take care to ensure no jobs with unintended effects are included in the run. For more details, see the section Security Implications below. 

Access to this feature is controlled by an opt-in setting which only organization admins can control. Once your organization has opted-in, you can opt-out for each individual project. For more details, see the section Feature-controls below.

Steps
The following steps show how to test run a pipeline from the VS Code extension:

Open VS Code and select the CircleCI logo in the sidebar. The Pipelines
and Run panels will be visible
Expand the Run panel to view your projects.
For each project, there is a button to trigger the config test run, and check
boxes for each workflow and job for you to choose which parts of your config
you want to run. Select your options, and click icon:play[]. Any local change
you make to your .circleci/config.yml file will be included in the test
run.
The pipeline is now visible in your dashboard in the CircleCI web app, at
app.circleci.com/pipelines/, and the
Pipelines Panel in the VS Code extension.

Feature controls
The ability to trigger pipelines from VS Code can be controlled at the org
level and at the project level.

Opt-in organization level setting. This can be changed only by
organization admins, and overrides project settings.
Setting location:
Organization Settings > Advanced > Allow triggering pipelines with unversioned config
in the Web App.

Opt-out project level setting.
Setting location:
Project Settings > VS Code integration > Allow triggering pipelines with unversioned config
in the Web App.


Security Implications
Running pipelines with unversioned config can cause security vulnerabilities.
Before enabling this feature, please acknowledge the risks outlined in the
official Docs.

Troubleshooting
Here are some frequently encountered issues, and some clarifications on each of
them.

“Your project could not be detected because no workspace is currently open”
You can fix this issue by opening a folder or workspace. Alternatively, you
can select to follow a CircleCI project manually from the Settings page.

The following errors concern the ability of the extension to link your
workspace to a Git repository.

“Your project could not be detected because we couldn’t find a Git repository associated with this workspace”
“Your project could not be detected because we were unable to get the list of git remotes”
“Your project could not be detected because we could not find default remote of your Git repository”
“Your project could not be detected because we were unable to get the URL of the Git remote XYZ”

When any of these errors occur, you might want to check that your workspace
has a valid Git remote URL. You can also fix this issue by selecting to follow
a CircleCI project manually from the Settings page.

“Your project could not be detected because CircleCI does not know this project”
This error indicates that the repository associated with your workspace
doesn’t appear to be a CircleCI project. If this is unexpected, verify the Git
remote URL associated with your repository, and ensure that you see this
project on the CircleCI web app. You can also address this issue by selecting
to follow a CircleCI project manually from the Settings page.

“Your project could not be detected because you don't follow this project on CircleCI”
When you see this error, you might want to visit the
Projects page on the CircleCI app
and ensure that you “follow” the project associated with this workspace.

“connection to server is erroring. Shutting down server”
This message indicates that the CircleCI Language Server has crashed. This
might be caused by an unexpected parsing error. For this reason, it is likely
that this issue will always occur on the same file. If you identify a file
that causes this error, it would be helpful if you could inform us at XXXXXX
(in the future on the LS open source repo)

When interacting with pipelines, workflows and jobs, you might see the
following errors.

“Cannot refresh pipelines: [runtime error message]”
“Download failed [runtime error message”’
“Cannot rerun workflow because: [runtime error message]”
“Job approval failed: [runtime error message]”

Please keep in mind that one of the causes for any of the above error messages
could be network issues. If you see any of these messages repeatedly, we
recommend you check your internet connection.

The following errors should never occur. Should you see any of them and be
able to reproduce them appearing, it would be helpful if you could report this
to us.

“Target entity can not be cancelled because it is not a workflow / job”
“Your project is not set up”
“Can not cancel your job because it has no job number”



Need support?
How to contact us
If you find any bugs with this extension or want to provide feedback, you can
contact us at
cci-vscode-feedback@circleci.com.
Documentation
You can find more information about CircleCI on our
official documentation.
How to contribute
The Language Server upon which the Conifg Helper is based is Open Source. If you
would like to contribute to the project, feel free to open a PR or get in touch
with us through the
circleci-yaml-language-server repository.
Additional resources
Data and Telemetry
The CircleCI VS Code extension collects usage data for product improvement
purposes, respecting the isTelemetryEnabled and telemetry.telemetryLevel
settings provided by VS Code.
It can be opted out through the VS Code settings page.
Privacy Policy
By signing in to this extension, you agree to the
CircleCI Privacy Policy.
Acknowledgements
This project was made possible by the community surrounding it. You can find
more information about the people and projects which contributed to this
extension in the file CREDITS.md.
We were also inspired by the great work done by community-built extensions:

Jody's Extension for CircleCI
CircleCI Status
vscode-circleci
circleci-conig-validator
Local-CI


© 2023 Circle Internet Services, Inc.\nThe official CircleCI VS Code extension is a new way to interact with CircleCI.\nThis extension provides an interface to visualize and manage CircleCI pipelines
directly from your IDE, as well as providing contextual help when creating,
modifying and editing CircleCI YAML config files. This way, it avoids expensive
context-switching between VS Code and your browser.\nMore practically, this extension allows you to:\nAuthenticate and connect VS Code to CircleCI\nBrowse and interact with your pipelines. Available actions include

Viewing pipelines, workflows, and jobs statuses
Viewing test outputs
Browsing job logs
Downloading artifacts
Approving jobs
Re-running builds
Debugging jobs with SSH\nViewing pipelines, workflows, and jobs statuses\nDownloading artifacts\nDebugging jobs with SSH\nBe alerted through notifications when your workflows change status or need
your attention\nAccess in-file support when editing CircleCI YAML configuration files,
including:

Syntax validation
Syntax highlighting
Go-to-definition and go-to-reference
On-hover documentation and usage hints
Autocompletion\nGo-to-definition and go-to-reference\nOn-hover documentation and usage hints\nLaunch commands to validate config files statically, or against your org
policy\nIt’s easy to get started with CircleCI for VS Code.\nInstall the extension
You can install the CircleCI extension from within VS Code, or download it
from the marketplace.
⚠️ This extension is compatible with VS Code versions 1.85 or above.\nInstall the extension\nYou can install the CircleCI extension from within VS Code, or download it
from the marketplace.\n⚠️ This extension is compatible with VS Code versions 1.85 or above.\nAuthenticate into CircleCI
Open the CircleCI Panel by clicking on the CircleCI icon on the activity bar
on the left of your screen, then click on “Log in”.
   
    

You will be prompted to enter a
Personal API Token. If you
don't have one, you can generate a new one for this purpose.
If you are an Enterprise customer, make sure to check the box and enter your
self-hosted server URL.\nAuthenticate into CircleCI\nOpen the CircleCI Panel by clicking on the CircleCI icon on the activity bar
on the left of your screen, then click on “Log in”.\nYou will be prompted to enter a
Personal API Token. If you
don't have one, you can generate a new one for this purpose.\nIf you are an Enterprise customer, make sure to check the box and enter your
self-hosted server URL.\nSetup your project
If your VS Code workspace contains one or more CircleCI projects, the
extension will detect them automatically, and the Pipelines Panel will be
populated with your most recent pipelines.
If no project is detected, open the settings page (through the VS Code
command CircleCI: Open Settings, or by clicking on the settings icon (⚙️)
at the top of the Pipelines Panel), and select your projects manually.
Please note that your manual selection will only be persisted if no projects
are detected automatically.
   ⚠️ Automatic project detection does not work for GitLab projects. Please select your project manually from the Settings page.\nIf your VS Code workspace contains one or more CircleCI projects, the
extension will detect them automatically, and the Pipelines Panel will be
populated with your most recent pipelines.\nIf no project is detected, open the settings page (through the VS Code
command CircleCI: Open Settings, or by clicking on the settings icon (⚙️)
at the top of the Pipelines Panel), and select your projects manually.\nPlease note that your manual selection will only be persisted if no projects
are detected automatically.\n⚠️ Automatic project detection does not work for GitLab projects. Please select your project manually from the Settings page.\nConfigure your Pipelines Panel
By default, your Pipelines Panel will display all the latest pipelines run on
your project. However, you can configure it to show you only the pipelines
you are interested in.
All configurations are available in the Settings page, which you can open
with the command CircleCI: Open Settings or by clicking on the settings
icon (⚙️) at the top of the Pipelines Panel.
Specifically, you can choose to follow:

Only your pipelines, or those authored by anyone
All branches, only your current branch, or a specific branch. You can also
select the checkbox “Always display default branch”
Only pipelines that include workflows and jobs with specific statuses.\nConfigure your Pipelines Panel\nBy default, your Pipelines Panel will display all the latest pipelines run on
your project. However, you can configure it to show you only the pipelines
you are interested in.\nAll configurations are available in the Settings page, which you can open
with the command CircleCI: Open Settings or by clicking on the settings
icon (⚙️) at the top of the Pipelines Panel.\nSpecifically, you can choose to follow:\nOnly your pipelines, or those authored by anyone\nAll branches, only your current branch, or a specific branch. You can also
select the checkbox “Always display default branch”\nOnly pipelines that include workflows and jobs with specific statuses.\nConfigure notifications
You can set up pop-up notifications to warn you when a workflow in your
Pipelines Panel has changed status.
 
   
 
By default, you will receive a pop-up notification every time one of the
workflows in your Pipelines Panel enters a failing status, or needs your
approval.
If you wish to alter these defaults, you can:

Mute notifications (a toggle button to change this setting is also
available at the top of the Pipelines Panel)



Configure which workflow status changes you want to be notified about

Please note that you can only be notified about workflows that appear in your
Pipelines Panel.\nConfigure notifications\nYou can set up pop-up notifications to warn you when a workflow in your
Pipelines Panel has changed status.\nBy default, you will receive a pop-up notification every time one of the
workflows in your Pipelines Panel enters a failing status, or needs your
approval.\nIf you wish to alter these defaults, you can:\nMute notifications (a toggle button to change this setting is also
available at the top of the Pipelines Panel)\nConfigure which workflow status changes you want to be notified about\nPlease note that you can only be notified about workflows that appear in your
Pipelines Panel.\nThe Pipelines Panel lists all CircleCI projects detected in your workspace. For
each project, it shows the most recent pipelines, jobs and workflows, and lets
you monitor their status and interact with them.\nFor some tree objects, you can perform actions by clicking on the icons which
appear when you hover over the item.\nProjects are the top level tree items, and they contain your pipelines.\nIf you don't follow a project, you can also use the panel to follow it.\nPipelines
are nested under projects. They are the CircleCI unit of change, and they
contain your workflows.\nWorkflows
are nested under each Pipeline, and contain Jobs. Hovering over a Workflow lets
you:\nOpen in browser, to view workflow details in the CircleCI app, on your default
web browser\nRerun workflow from start, to re-triggered the entire workflow\nRerun workflow from failed, to re-triggered the workflow starting from the
first failed job\nJobs
are nested under each Workflow, and can contain Tests and Artifacts. Hovering
over a Job lets you:\nApprove the job (only if the job is on hold)\nCancel the job (only if the job is running)\nRerun the job with SSH (you can read more about this functionality in a later
section)\nBy expanding a Job, you can also:\nLoad tests, if you have configured your tests to upload test results to
CircleCI. Tests that CircleCI has detected as flaky will be prefaced by the
indication [FLAKY].\nLoad artifacts, to load any artifacts created by the Job. Once the
artifacts are loaded, you can download them by clicking on them.\nYou can re-run jobs with SSH directly from VS Code, either:\nthrough the Job Details page, by clicking on the green button on the top
right:\nor by clicking on the action icon next to the job name in the Pipelines Panel.\nIn both cases, you will be presented with two options:\nOpen SSH session in terminal\nOpen SSH session in remote VS Code window

This feature requires the official VS Code extension
Remote - SSH.
You can find more information on Remote Development using SSH in VS Code
directly in the
VS Code docs.\nOpen SSH session in remote VS Code window\nThis feature requires the official VS Code extension
Remote - SSH.
You can find more information on Remote Development using SSH in VS Code
directly in the
VS Code docs.\nTo rerun your job with SSH, you will first have to set the path to your Github
or Bitbucket SSH key. The first time you attempt to re-run with SSH, the
extension will guide you to select the path of the relevant SSH key. However, if
you miss this step or want to modify it at a later time, you can do so from the
dedicated section of the settings page:\nIf the job you want to rerun uses parallelism, you will be able to select which
job you want to SSH into.\nYou can read more about debugging with SSH on CircleCI
in the Docs.\nThe Status Bar provides summary information about the state of the CircleCI
extension, your project and your most recent workflow.\nSpecifically, you might see the following statuses:\nNot logged in - when clicking on the status bar, the login page will open\nNo project - when clicking on the status bar, the settings page will open
so you can select a project manually\nSuccess / On hold / Failed, and similar workflow statuses - THIS refers to
the status of the top pipeline in your panel. When clicking on the status bar,
the relative workflow will come into focus on the CircleCI Pipelines Panel.\nNo internet - when your internet connection is lost\nThis extension provides in-file assistance with writing, editing and navigating
CircleCI Configuration files.\nIt is based on a CircleCI-specific Language Server, and offers:\nRich code navigation through “go-to-definition” and “go-to-reference”
commands. This is especially convenient when working on large configuration
files, to verify the definition of custom jobs, executors parameters, or in
turn view where any of them are referenced in the file. Assisted code
navigation also works for Orbs, allowing to explore their definition directly
in the IDE when using the go-to-definition feature on an orb-defined command
or parameter.\nContextual documentation and usage hints when hovering on specific keys,
so as to avoid having to continuously switch to the browser to check the docs
whenever you are editing your YAML config. Links to the official CircleCI
documentation are also provided on hover - for easier navigation.\nSyntax validation - which makes it much easier to identify typos,
incorrect use of parameters, incomplete definitions, wrong types, invalid or
deprecated machine versions, etc.\nUsage warnings - which can help identify deprecated parameters, unused
jobs or executors, or missing keys that prevent you from taking advantage of
CircleCI’s full capabilities\nAuto completion, available both on built-in keys and parameters and on
user-defined variables\nYou can access a full overview of all errors, warnings and hints proposed by the
Config Helper in the Problems tab of VS Code.\nThe Config Helper is based on a dedicated Language Server for CircleCI YAML
files, which is Open Source. You can view its source code, contribute and add
issues directly on the project repository:
circleci-yaml-language-server.\ncircleci-yaml-language-server\nConfig validation commands\nThe extension also provides two commands that help you statically validate your
YAML config files without having to run a pipeline.\nValidate current configuration file
Corresponds to the CLI command
circleci config validate,
and verifies statically that the config file is well formed. Please note that
this command only validates this file for structure and syntax errors, but
not for semantic error (e.g. this job does not exist).\nValidate current configuration file\nCorresponds to the CLI command
circleci config validate,
and verifies statically that the config file is well formed. Please note that
this command only validates this file for structure and syntax errors, but
not for semantic error (e.g. this job does not exist).\ncircleci config validate\nValidate current configuration file against org policy
Corresponds to the CLI command
circleci policy decide,
and verifies that the configuration file complies with your organization
policies - if any are set.

Please note that this command is only available to Scale customers\nValidate current configuration file against org policy\nCorresponds to the CLI command
circleci policy decide,
and verifies that the configuration file complies with your organization
policies - if any are set.\ncircleci policy decide\nPlease note that this command is only available to Scale customers\nView compiled version of current configuration file
This command resolves all orb references in your config file, and shows you
the full-length version of your config.\nView compiled version of current configuration file\nThis command resolves all orb references in your config file, and shows you
the full-length version of your config.\nAll these commands can also be invoked:\nby right-clicking on a CircleCI YAML file:\nby clicking on the CircleCI button on the top right corner of the page, when
focusing on a CircleCI YAML file. Please note that the button will not be
visible if you are editing a different file.\n🆕 Test run your config (Open Preview)\nNOTE: The ability to trigger a pipeline from VS Code with a unversioned
config is currently in Open Preview, and only available for projects
integrated through the GitHub OAuth app, or Bitbucket. To find out
which GitHub account type you have, see the
documentation about GitHub OAuth app integration.\ndocumentation about GitHub OAuth app integration\nTrigger pipelines from VS Code to iterate on your CircleCI config without
committing your trial and error changes to your version control system. Run and
validate your full pipeline, or select jobs and workflows to validate
individually. View the results of your test runs in the Pipelines Panel or in
the CircleCI web app, just the same as any other pipeline.\nv2.0 or higher of the CircleCI VS Code extension\nA CircleCI account integrated through the GitHub OAuth app, or Bitbucket. To
find out which GitHub account type you have, check
this docs page.\nYour org must have opted-in to this feature through Organization Settings. You
may need to ask your org admin to do so for you. See the section Feature
controls below for more details.\nYour project must not make use of
dynamic configuration. This
feature is disabled for projects that use dynamic configuration.\ndynamic configuration\nNOTE: Unversioned config in CircleCI indicates that the
.circleci/config.yml on the branch where the pipeline is running is ignored,
and instead, the configuration file is overridden by a custom configuration file
passed as a parameter. The term “unversioned” refers to the fact the config file
is not versioned in the VCS. It is, however, stored in CircleCI along with the
pipeline, and it is available at any time in the CircleCI web app.\nPlease use caution when running pipelines with unversioned configuration, and take care to ensure no jobs with unintended effects are included in the run. For more details, see the section Security Implications below. 

Access to this feature is controlled by an opt-in setting which only organization admins can control. Once your organization has opted-in, you can opt-out for each individual project. For more details, see the section Feature-controls below.\nThe following steps show how to test run a pipeline from the VS Code extension:\nOpen VS Code and select the CircleCI logo in the sidebar. The Pipelines
and Run panels will be visible\nExpand the Run panel to view your projects.\nFor each project, there is a button to trigger the config test run, and check
boxes for each workflow and job for you to choose which parts of your config
you want to run. Select your options, and click icon:play[]. Any local change
you make to your .circleci/config.yml file will be included in the test
run.\nThe pipeline is now visible in your dashboard in the CircleCI web app, at
app.circleci.com/pipelines/, and the
Pipelines Panel in the VS Code extension.\napp.circleci.com/pipelines/\nThe ability to trigger pipelines from VS Code can be controlled at the org
level and at the project level.\nOpt-in organization level setting. This can be changed only by
organization admins, and overrides project settings.
Setting location:
Organization Settings > Advanced > Allow triggering pipelines with unversioned config
in the Web App.\nOpt-in organization level setting. This can be changed only by
organization admins, and overrides project settings.\nSetting location:
Organization Settings > Advanced > Allow triggering pipelines with unversioned config
in the Web App.\nOpt-out project level setting.
Setting location:
Project Settings > VS Code integration > Allow triggering pipelines with unversioned config
in the Web App.\nOpt-out project level setting.\nSetting location:
Project Settings > VS Code integration > Allow triggering pipelines with unversioned config
in the Web App.\nSecurity Implications\nRunning pipelines with unversioned config can cause security vulnerabilities.
Before enabling this feature, please acknowledge the risks outlined in the
official Docs.\nHere are some frequently encountered issues, and some clarifications on each of
them.\n“Your project could not be detected because no workspace is currently open”
You can fix this issue by opening a folder or workspace. Alternatively, you
can select to follow a CircleCI project manually from the Settings page.\n“Your project could not be detected because no workspace is currently open”\nYou can fix this issue by opening a folder or workspace. Alternatively, you
can select to follow a CircleCI project manually from the Settings page.\nThe following errors concern the ability of the extension to link your
workspace to a Git repository.

“Your project could not be detected because we couldn’t find a Git repository associated with this workspace”
“Your project could not be detected because we were unable to get the list of git remotes”
“Your project could not be detected because we could not find default remote of your Git repository”
“Your project could not be detected because we were unable to get the URL of the Git remote XYZ”

When any of these errors occur, you might want to check that your workspace
has a valid Git remote URL. You can also fix this issue by selecting to follow
a CircleCI project manually from the Settings page.\nThe following errors concern the ability of the extension to link your
workspace to a Git repository.\n“Your project could not be detected because we couldn’t find a Git repository associated with this workspace”\n“Your project could not be detected because we were unable to get the list of git remotes”\n“Your project could not be detected because we could not find default remote of your Git repository”\n“Your project could not be detected because we were unable to get the URL of the Git remote XYZ”\nWhen any of these errors occur, you might want to check that your workspace
has a valid Git remote URL. You can also fix this issue by selecting to follow
a CircleCI project manually from the Settings page.\n“Your project could not be detected because CircleCI does not know this project”
This error indicates that the repository associated with your workspace
doesn’t appear to be a CircleCI project. If this is unexpected, verify the Git
remote URL associated with your repository, and ensure that you see this
project on the CircleCI web app. You can also address this issue by selecting
to follow a CircleCI project manually from the Settings page.\n“Your project could not be detected because CircleCI does not know this project”\nThis error indicates that the repository associated with your workspace
doesn’t appear to be a CircleCI project. If this is unexpected, verify the Git
remote URL associated with your repository, and ensure that you see this
project on the CircleCI web app. You can also address this issue by selecting
to follow a CircleCI project manually from the Settings page.\n“Your project could not be detected because you don't follow this project on CircleCI”
When you see this error, you might want to visit the
Projects page on the CircleCI app
and ensure that you “follow” the project associated with this workspace.\n“Your project could not be detected because you don't follow this project on CircleCI”\nWhen you see this error, you might want to visit the
Projects page on the CircleCI app
and ensure that you “follow” the project associated with this workspace.\nProjects page on the CircleCI app\n“connection to server is erroring. Shutting down server”
This message indicates that the CircleCI Language Server has crashed. This
might be caused by an unexpected parsing error. For this reason, it is likely
that this issue will always occur on the same file. If you identify a file
that causes this error, it would be helpful if you could inform us at XXXXXX
(in the future on the LS open source repo)\n“connection to server is erroring. Shutting down server”\nThis message indicates that the CircleCI Language Server has crashed. This
might be caused by an unexpected parsing error. For this reason, it is likely
that this issue will always occur on the same file. If you identify a file
that causes this error, it would be helpful if you could inform us at XXXXXX
(in the future on the LS open source repo)\nWhen interacting with pipelines, workflows and jobs, you might see the
following errors.

“Cannot refresh pipelines: [runtime error message]”
“Download failed [runtime error message”’
“Cannot rerun workflow because: [runtime error message]”
“Job approval failed: [runtime error message]”

Please keep in mind that one of the causes for any of the above error messages
could be network issues. If you see any of these messages repeatedly, we
recommend you check your internet connection.\nWhen interacting with pipelines, workflows and jobs, you might see the
following errors.\n“Cannot refresh pipelines: [runtime error message]”\n“Download failed [runtime error message”’\n“Cannot rerun workflow because: [runtime error message]”\n“Job approval failed: [runtime error message]”\nPlease keep in mind that one of the causes for any of the above error messages
could be network issues. If you see any of these messages repeatedly, we
recommend you check your internet connection.\nThe following errors should never occur. Should you see any of them and be
able to reproduce them appearing, it would be helpful if you could report this
to us.

“Target entity can not be cancelled because it is not a workflow / job”
“Your project is not set up”
“Can not cancel your job because it has no job number”\nThe following errors should never occur. Should you see any of them and be
able to reproduce them appearing, it would be helpful if you could report this
to us.\n“Target entity can not be cancelled because it is not a workflow / job”\n“Your project is not set up”\n“Can not cancel your job because it has no job number”\nIf you find any bugs with this extension or want to provide feedback, you can
contact us at
cci-vscode-feedback@circleci.com.\ncci-vscode-feedback@circleci.com\nYou can find more information about CircleCI on our
official documentation.\nofficial documentation\nThe Language Server upon which the Conifg Helper is based is Open Source. If you
would like to contribute to the project, feel free to open a PR or get in touch
with us through the
circleci-yaml-language-server repository.\ncircleci-yaml-language-server repository\nThe CircleCI VS Code extension collects usage data for product improvement
purposes, respecting the isTelemetryEnabled and telemetry.telemetryLevel
settings provided by VS Code.\nIt can be opted out through the VS Code settings page.\nBy signing in to this extension, you agree to the
CircleCI Privacy Policy.\nCircleCI Privacy Policy\nThis project was made possible by the community surrounding it. You can find
more information about the people and projects which contributed to this
extension in the file CREDITS.md.\nWe were also inspired by the great work done by community-built extensions:\nJody's Extension for CircleCI\nJody's Extension for CircleCI\ncircleci-conig-validator\ncircleci-conig-validator\n© 2023 Circle Internet Services, Inc.\nContact usJobsPrivacyManage cookiesTerms of useTrademarks© 2025 Microsoft\nContact usJobsPrivacyManage cookiesTerms of useTrademarks© 2025 Microsoft\nContact usJobsPrivacyManage cookiesTerms of useTrademarks© 2025 Microsoft\nContact usJobsPrivacyManage cookiesTerms of useTrademarks\nContact usJobsPrivacyManage cookiesTerms of useTrademarks\n\n\nInstall and configure the CircleCI local CLI1 month ago3 min readCloudServer v4+On This PageInstallationLinux install with SnapmacOS install with HomebrewWindows install with ChocolateyAlternative installation methodManual installUpdating the CLIUpdating the legacy CLIConfigure the CLITelemetryUninstallNext stepsCLI articles in the support centreTroubleshooting   The  CircleCI command line interface (CLI) brings CircleCI’s advanced and powerful tools to your terminal.   Some of the things you can do with the CLI include:      Debug and validate your CircleCI configuration    Run jobs locally   Query CircleCI’s API    Create, publish, view, and manage orbs    Manage contexts    Split your tests to run across  parallel environments to reduce pipeline duration     This page covers the installation and usage of the CircleCI CLI. The expectation is you have basic knowledge of CI/CD,  CircleCI’s concepts. You should already have a CircleCI account, an account with a supported VCS, and have your terminal open and ready to go.     Installation   Install the CircleCI CLI using one of the methods described below.      If you have previously installed CLI prior to October 2018, you may need to do an extra one-time step to switch to the new CLI. See the  upgrade instructions.        For the majority of installations, we recommend one of the package managers outlined in the sections below to install the CircleCI CLI.   Linux install with Snap  The following commands will install the CircleCI CLI, Docker, and both the security and auto-update features that come along with  Snap packages.    sudo snap install docker circleci
sudo snap connect circleci:docker docker    With snap packages, the Docker command will use the Docker snap, not a version of Docker you may have previously installed. For security purposes, snap packages can only read/write files from within $HOME.    macOS install with Homebrew  If you are using  Homebrew with macOS, you can install the CLI with the following command:    brew install circleci    If you already have Docker for Mac installed, you can use this command instead:    brew install --ignore-dependencies circleci     Windows install with Chocolatey  For Windows users, CircleCI provides a  Chocolatey package:    choco install circleci-cli -y     Alternative installation method  Mac and Linux:    curl -fLSs https://raw.githubusercontent.com/CircleCI-Public/circleci-cli/main/install.sh | bash    By default, the CircleCI CLI tool will be installed to the /usr/local/bin directory. If you do not have write permissions to /usr/local/bin, you may need to run the above command with sudo after the pipe and before bash:    curl -fLSs https://raw.githubusercontent.com/CircleCI-Public/circleci-cli/main/install.sh | sudo bash    You can also install to an alternate location by defining the DESTDIR environment variable when invoking Bash:    curl -fLSs https://raw.githubusercontent.com/CircleCI-Public/circleci-cli/main/install.sh | DESTDIR=/opt/bin bash     Manual install  You can visit the  GitHub releases page for the CLI to manually download and install. This approach is best if you would like the installed CLI to be in a specific path on your system.      Updating the CLI   If you would just like to check for updates manually (and not install them), use the command:      circleci update check    For Linux and Windows installs, you can update to the newest version of the CLI using the following command:      circleci update    For macOS installations with Homebrew, you will need to run the following command to update:      brew upgrade circleci    Updating the legacy CLI  The newest version of the CLI is a  CircleCI-Public open source project. If you have the  old CLI installed, run the following commands to update and switch to the new CLI:    circleci update
circleci switch    This command may prompt you for sudo if your user does not have write permissions to the install directory, /usr/local/bin.      Configure the CLI   Before using the CLI, you need to generate a CircleCI API token from the  Personal API Token tab. After you get your token, configure the CLI by running:    circleci setup    The set up process will prompt you for configuration settings. If you are using the CLI with CircleCI cloud, use the default CircleCI host. If you are using CircleCI server, change the value to your installation address (for example, circleci.your-org.com).     Telemetry   The CircleCI CLI includes a telemetry feature that collects basic errors and feature usage data in order to help us improve the experience for everyone.   Telemetry works on an opt-in basis. When running a command for the first time, you will be asked for consent to enable telemetry. Telemetry is disabled by default for non-interactive terminals, ensuring that scripts that leverage the CLI run smoothly.   You can disable or enable telemetry any time in one of the following ways:     Run one of the following commands: circleci telemetry enable or circleci telemetry disable   To disable telemetry, set the CIRCLECI_CLI_TELEMETRY_OPTOUT environment variable to 1 or true       Uninstall   The commands for uninstalling the CircleCI CLI will vary depending on your original installation method.   Linux uninstall with Snap:    sudo snap remove circleci    macOS uninstall with Homebrew:    brew uninstall circleci    Windows uninstall with Chocolatey:    choco uninstall circleci-cli -y --remove dependencies    Alternative curl uninstall: Remove the circleci executable from usr/local/bin     Next steps      How to validate your CircleCI configuration    How to run a job in a container on your local machine    How to create, publish, view, and manage orbs    How to manage contexts    How to split your tests to run across  parallel environments to reduce pipeline duration        CLI articles in the support centre   If you wish to suggest ways we could improve the CLI  share your suggestion on the GitHub repository.      How to check private repositories with local jobs using the CircleCI CLI?    How to know if your project is using deprecated Machine images with the CLI?    How to validate a config that uses private Orbs with the CLI?    Understanding the difference between public, private and unlisted orbs    How to make your orbs private using the CircleCI CLI?    How to list your private orb using the CircleCI CLI?    How to delete an orb using the CircleCI CLI?    How to delete a project Docker Layer Cache with the CircleCI CLI?    Docker Layer Cache FAQ    How to rotate your self-hosted runner resource class tokens using the CircleCI CLI?    How to use the CLI to verify namespaces and resource classes have been created correctly when installing the CircleCI runner ?    How to use Reality Check to validate your CircleCI server installation for GitHub Enterprise via the CLI?     Troubleshooting     What if the CLI context commands error with "Must have admin permission"?    What if the CLI fails with panic: yaml: line 4: could not find expected ':'?    What if the CLI command circleci local execute fails with --storage-opt is supported only for overlay over xfs with 'pquota' mount option?    What if the CLI command circleci local execute fails with not implemented for cgroup v2 unified hierarchy?      Suggest an edit to this pageMake a contribution Learn how to contributeStill need help? Ask the CircleCI community Join the research community Visit our Support site\n\nInstall and configure the CircleCI local CLI1 month ago3 min readCloudServer v4+On This PageInstallationLinux install with SnapmacOS install with HomebrewWindows install with ChocolateyAlternative installation methodManual installUpdating the CLIUpdating the legacy CLIConfigure the CLITelemetryUninstallNext stepsCLI articles in the support centreTroubleshooting   The  CircleCI command line interface (CLI) brings CircleCI’s advanced and powerful tools to your terminal.   Some of the things you can do with the CLI include:      Debug and validate your CircleCI configuration    Run jobs locally   Query CircleCI’s API    Create, publish, view, and manage orbs    Manage contexts    Split your tests to run across  parallel environments to reduce pipeline duration     This page covers the installation and usage of the CircleCI CLI. The expectation is you have basic knowledge of CI/CD,  CircleCI’s concepts. You should already have a CircleCI account, an account with a supported VCS, and have your terminal open and ready to go.     Installation   Install the CircleCI CLI using one of the methods described below.      If you have previously installed CLI prior to October 2018, you may need to do an extra one-time step to switch to the new CLI. See the  upgrade instructions.        For the majority of installations, we recommend one of the package managers outlined in the sections below to install the CircleCI CLI.   Linux install with Snap  The following commands will install the CircleCI CLI, Docker, and both the security and auto-update features that come along with  Snap packages.    sudo snap install docker circleci
sudo snap connect circleci:docker docker    With snap packages, the Docker command will use the Docker snap, not a version of Docker you may have previously installed. For security purposes, snap packages can only read/write files from within $HOME.    macOS install with Homebrew  If you are using  Homebrew with macOS, you can install the CLI with the following command:    brew install circleci    If you already have Docker for Mac installed, you can use this command instead:    brew install --ignore-dependencies circleci     Windows install with Chocolatey  For Windows users, CircleCI provides a  Chocolatey package:    choco install circleci-cli -y     Alternative installation method  Mac and Linux:    curl -fLSs https://raw.githubusercontent.com/CircleCI-Public/circleci-cli/main/install.sh | bash    By default, the CircleCI CLI tool will be installed to the /usr/local/bin directory. If you do not have write permissions to /usr/local/bin, you may need to run the above command with sudo after the pipe and before bash:    curl -fLSs https://raw.githubusercontent.com/CircleCI-Public/circleci-cli/main/install.sh | sudo bash    You can also install to an alternate location by defining the DESTDIR environment variable when invoking Bash:    curl -fLSs https://raw.githubusercontent.com/CircleCI-Public/circleci-cli/main/install.sh | DESTDIR=/opt/bin bash     Manual install  You can visit the  GitHub releases page for the CLI to manually download and install. This approach is best if you would like the installed CLI to be in a specific path on your system.      Updating the CLI   If you would just like to check for updates manually (and not install them), use the command:      circleci update check    For Linux and Windows installs, you can update to the newest version of the CLI using the following command:      circleci update    For macOS installations with Homebrew, you will need to run the following command to update:      brew upgrade circleci    Updating the legacy CLI  The newest version of the CLI is a  CircleCI-Public open source project. If you have the  old CLI installed, run the following commands to update and switch to the new CLI:    circleci update
circleci switch    This command may prompt you for sudo if your user does not have write permissions to the install directory, /usr/local/bin.      Configure the CLI   Before using the CLI, you need to generate a CircleCI API token from the  Personal API Token tab. After you get your token, configure the CLI by running:    circleci setup    The set up process will prompt you for configuration settings. If you are using the CLI with CircleCI cloud, use the default CircleCI host. If you are using CircleCI server, change the value to your installation address (for example, circleci.your-org.com).     Telemetry   The CircleCI CLI includes a telemetry feature that collects basic errors and feature usage data in order to help us improve the experience for everyone.   Telemetry works on an opt-in basis. When running a command for the first time, you will be asked for consent to enable telemetry. Telemetry is disabled by default for non-interactive terminals, ensuring that scripts that leverage the CLI run smoothly.   You can disable or enable telemetry any time in one of the following ways:     Run one of the following commands: circleci telemetry enable or circleci telemetry disable   To disable telemetry, set the CIRCLECI_CLI_TELEMETRY_OPTOUT environment variable to 1 or true       Uninstall   The commands for uninstalling the CircleCI CLI will vary depending on your original installation method.   Linux uninstall with Snap:    sudo snap remove circleci    macOS uninstall with Homebrew:    brew uninstall circleci    Windows uninstall with Chocolatey:    choco uninstall circleci-cli -y --remove dependencies    Alternative curl uninstall: Remove the circleci executable from usr/local/bin     Next steps      How to validate your CircleCI configuration    How to run a job in a container on your local machine    How to create, publish, view, and manage orbs    How to manage contexts    How to split your tests to run across  parallel environments to reduce pipeline duration        CLI articles in the support centre   If you wish to suggest ways we could improve the CLI  share your suggestion on the GitHub repository.      How to check private repositories with local jobs using the CircleCI CLI?    How to know if your project is using deprecated Machine images with the CLI?    How to validate a config that uses private Orbs with the CLI?    Understanding the difference between public, private and unlisted orbs    How to make your orbs private using the CircleCI CLI?    How to list your private orb using the CircleCI CLI?    How to delete an orb using the CircleCI CLI?    How to delete a project Docker Layer Cache with the CircleCI CLI?    Docker Layer Cache FAQ    How to rotate your self-hosted runner resource class tokens using the CircleCI CLI?    How to use the CLI to verify namespaces and resource classes have been created correctly when installing the CircleCI runner ?    How to use Reality Check to validate your CircleCI server installation for GitHub Enterprise via the CLI?     Troubleshooting     What if the CLI context commands error with "Must have admin permission"?    What if the CLI fails with panic: yaml: line 4: could not find expected ':'?    What if the CLI command circleci local execute fails with --storage-opt is supported only for overlay over xfs with 'pquota' mount option?    What if the CLI command circleci local execute fails with not implemented for cgroup v2 unified hierarchy?      Suggest an edit to this pageMake a contribution Learn how to contributeStill need help? Ask the CircleCI community Join the research community Visit our Support site DocsTerms of UsePrivacy PolicyCookie PolicySecurity© 2025 Circle Internet Services, Inc., All Rights Reserved.\n\nIf you have previously installed CLI prior to October 2018, you may need to do an extra one-time step to switch to the new CLI. See the  upgrade instructions.  sudo snap install docker circleci
sudo snap connect circleci:docker docker  brew install circleci  brew install --ignore-dependencies circleci  choco install circleci-cli -y  curl -fLSs https://raw.githubusercontent.com/CircleCI-Public/circleci-cli/main/install.sh | bash  curl -fLSs https://raw.githubusercontent.com/CircleCI-Public/circleci-cli/main/install.sh | sudo bash  curl -fLSs https://raw.githubusercontent.com/CircleCI-Public/circleci-cli/main/install.sh | DESTDIR=/opt/bin bash    circleci update check    circleci update    brew upgrade circleci  circleci update
circleci switch  circleci setup  sudo snap remove circleci  brew uninstall circleci  choco uninstall circleci-cli -y --remove dependencies\n\n\n\nDeploys overview1 week ago13 min readCloudOn This PageIntroductionQuickstartHow it worksConceptsComponentDeliveryDeploymentCommandReleaseThe deploys UIThe dashboardFilter and group components and environments with labelsUse labels to filter components and environmentsAdd or edit labelsComponent labelsEnvironment labelsView all deployments for an environmentView all commands run for an environmentView all deployments for a componentView all commands run for a componentRequirementsToolingLabels and annotationsAutomatic deployment detection and deploy markersAutomatic detection of deploymentsManual configuration of automatically detected deploysOpt out of automatic deploy detectionRetention PolicyManual deploy marker setupDeploy statusKnown limitationsTroubleshootingWhy is my Deployment/Rollout not showing up in the components tab or releases timeline view?Why is my release is stuck in the Running state?Why are no new releases are showing up? and/or why are component versions not being updated?Why is restore version using Helm is timing out?Why is the restore version button not available for a component version?Why are all buttons disabled for a release?Why are all commands for my component failing?Next steps   Visualize and control your deployments with CircleCI deploys. The CircleCI deploys dashboard supports any deployment, and the deploys management tooling works with deployments to Kubernetes and Amazon SageMaker.     Introduction   CircleCI deploys gives you visibility into your Kubernetes deployments within the CircleCI web app, as well as access to commands and visualisations for managing deployments. From the CircleCI web app, you can:     Restore version   Scale component   Restart component     We support  Argo Rollouts for progressive delivery. Currently the  canary deployment strategy is supported, but in a future release  blue-green will also be supported. Some further controls are available for projects that use Argo Rollouts:     Retry Rollout   Promote Rollout   Cancel Rollout       Quickstart   To get started with CircleCI deploys for Kubernetes right away, refer to the following guides:      Tutorial 1: Set up CircleCI deploys    Tutorial 2: Configure your Kubernetes components    How-to: Manage deploys     To get set up with deploys for Amazon SageMaker, refer to the  Deploy to Amazon SageMaker page.     How it works   CircleCI integrates with your Kubernetes cluster to give you visibility and control over your release process through the CircleCI web app. We currently support Kubernetes Deployments and Argo Rollouts.        Configure environment integrations to install the CircleCI release agent into your Kubernetes clusters. Configure the release agent to only monitor the namespaces you require.   Developers can monitor deployments in the CircleCI web app, and run commands to manage those deployments from the UI. Commands are monitored by CircleCI and relayed to the release agent, which then runs the commands for you.     Concepts   The sections below explain some key software delivery concepts. Understanding these concepts will help you take full advantage of CircleCI deploys.   Component  A component in CircleCI is a collection of code and configuration that is deployed and released as a single unit. In Kubernetes terms, this would be a Deployment or Rollout object along with the related objects such as Pods, ReplicaSets, etc. that share a common circleci.com/component-name label.    Delivery  Delivery is the act of packaging code changes and making them available for Deployment. Continuous delivery is the prerequisite step for continuous deployment. With some variations on the technologies being used, the delivery process creates executables from code and then makes them available to be deployed to an environment at a subsequent time.    Deployment  Deployment is the act of putting a new component version into an environment, regardless of whether users and other services interact with the new version or a previous one. Depending on the deployment type, a release may happen either:     As a later task, such as switching over traffic shaping rules for a blue/green deployment.   As a direct consequence of the deployment, such as a standard Kubernetes rolling update.      Command  A command is a user-initiated action CircleCI performs on the user’s behalf to manipulate a specific component. Actions are run asynchronously via our release agent and the results are reported back to the CircleCI web app. You can see the results in the deployments dashboard, similarly to how step output works for CI jobs.   Some commands are available for all components. These are:     Restore version   Scale component   Restart component     A subset of commands are available for progressive deployments (when using Argo Rollouts). These are:     Retry deployment   Promote deployment   Cancel deployment      Release  A release is the act of updating a component to a new version in a specific environment, causing it to become available to an audience of users and other services.   A release can happen when an existing component is updated or when the first version for a new component is deployed.   In the deploys dashboard, deployments are tagged as Progressive if they refer to an Argo Rollout.   A deployment starts when the component version is updated, and ends when the new version has reached 100% availability, and all associated validations have been completed. In the case of a progressive deployment, this happens when the Rollout completes. In the case of a Kubernetes Deployment, this happens when the Deployment replicas are all available and ready.      The deploys UI   The CircleCI deploys UI is a powerful tool for visualising, monitoring and managing your deployments. The pages included in the deploys UI are described below.   The dashboard       Select Deploys in the CircleCI web app sidebar to enter the deploys dashboard. The dashboard shows the following:     Timeline: A timeline of deploys across your organization’s components and environments. You can use the filter dropdown menus at the top of the page to select a component and/or environment. You will see live status updates, deployment trigger source, deployment version version, deployment type (for example, progressive, when you are using an Argo Rollout). From here you can access the following:    The deployment details page for a specific deployment by clicking on the status badge or version number.   The component or environment details pages by clicking on the respective names.   The project dashboard for the CircleCI project associated with a deployment.   The job details page for the job that started the deployment.   The commit details page in your VCS for the commit that started the deployment.      Environments: List of environment integrations set up for your organization. From here you can:    Set up a new environment integration by selecting Create Environment Integration.   Access settings for each environment ().   Access the environment details view by selecting an environment name.      Components: A list of components and their associated projects. From here you can:    Set up a new component by selecting Create Component. From here you can select and environment that has a successful environment integration set up, and from there you can add a new component.   Get straight to the component’s project building on CircleCI by selecting the project name.   Access setting for each component ().         Filter and group components and environments with labels  Add labels to your components and environments to provide teams with a way to filter and group content in the deploys UI. Once a label is added, you can use this to filter your view to focus on the content relevant to your team.   Labels are composed of two values separated by a colon, for example, team:my-team-name. To specify multiple labels for a component or environment, you can separate them with a comma. For example, team:my-team-name, role:web. You can add up to 20 labels to a component or environment.   Use labels to filter components and environments  Once you have added labels to your components and environments, you can use them to filter your view in the deploys UI. In the timeline, environments, or components view, select a filter to reduce the content in the tab to only your selection. You can also use the label filter dropdown menu at the top of the page.    Add or edit labels  To add or edit labels follow the steps below.      Figure 1. Add and Edit environment and component labels   Component labels  To add or edit labels for a component, follow these steps:     Select Deploys in the CircleCI web app sidebar.   You are now in the timeline view. Select the Components tab.   Select the cog icon () for your component. You can use the filter at the top of the page to help find the component you want.   You are now on the component settings page. Select the edit button () in the labels panel.   Enter or edit your label(s) and select Done.      Environment labels  To add or edit labels for an environment, follow these steps:     Select Deploys in the CircleCI web app sidebar.   You are now in the timeline view. Select the Environments tab.   Select the cog icon () for your environment.   You are now on the environment settings page. Select the edit button () in the labels panel.   Enter or edit your label(s) and select Done.        View all deployments for an environment  To view all deployments for an environment, follow these steps:     Select Deploys in the CircleCI web app sidebar.   You are now in the timeline view. Select the Environments tab.   Select your environment by name.   You are now on the environment details page. Select the Deployments tab to view a list of all deployments for your chosen environment.      View all commands run for an environment  To view all commands run for an environment, follow these steps:     Select Deploys in the CircleCI web app sidebar.   You are now in the timeline view. Select the Environments tab.   Select your environment by name.   You are now on the environment details page. Select the Commands tab to view a list of all commands that have been run for your chosen environment.      View all deployments for a component  To view all deployments for a component, follow these steps:     Select Deploys in the CircleCI web app sidebar.   You are now in the timeline view. Select the Components tab.   Select your component by name. You can use the filter at the top of the page to help.   You are now on the component details page. Select the Deployments tab to view a list of all deployments for your chosen component.      View all commands run for a component  To view all commands run for a component, follow these steps:     Select Deploys in the CircleCI web app sidebar.   You are now in the timeline view. Select the Components tab.   Select your component by name. You can use the filter at the top of the page to help.   You are now on the component details page. Select the Commands tab to view a list of all commands run for your chosen component.        Requirements   Tooling  We test the versions listed here. Older versions may work but are not guaranteed.  ToolTested versionsKubernetes 1.29.0 1.28.0 1.27.0 Helm 3.12.0 3.11.0 Argo Rollouts (optional) 1.6.0 1.5.0    Labels and annotations  The following table shows a complete list of labels and annotations either required or available for configuring your environment integration.  Label/annotationValueRequired?Metadata.Labelscircleci.com/component-nameA name for your applicationYesMetadata.Labelscircleci.com/versionCurrent versionYesSpec.Template.Metadata.Labelscircleci.com/component-nameSee aboveYesSpec.Template.Metadata.Labelscircleci.com/versionSee aboveYesMetadata.Annotationscircleci.com/project-idProject ID for the CircleCI project associated with the job that deploys your componentYesMetadata.Annotationscircleci.com/operation-timeoutA  Go duration string, for example, 5m, 10m15sNo. Only needed to set a custom timeout duration. This option is only available if you are using Helm to configure your Kubernetes resources.Metadata.Annotationscircleci.com/restore-version-enabledfalseNo. Only set if you want to disable the restore version feature for your component.Metadata.Annotationscircleci.com/scale-component-enabledfalseNo. Only set if you want to disable the scale component feature for your component.Metadata.Annotationscircleci.com/restart-component-enabledfalseNo. Only set if you want to disable the restart component feature for your component.Metadata.Annotationscircleci.com/retry-release-enabledfalseNo. Only set if you want to disable the retry deployment feature for your component.Metadata.Annotationscircleci.com/promote-release-enabledfalseNo. Only set if you want to disable the promote deployment feature for your component.Metadata.Annotationscircleci.com/cancel-release-enabledfalseNo. Only set if you want to disable the cancel deployment feature for your component.     Automatic deployment detection and deploy markers   CircleCI automatically generates deploy markers for your deployment pipelines. Deploy markers provide a lightweight way to log your deployments without requiring a full CircleCI deploys setup. Deploy markers generate a log of all deployments in one place, for a clear overview of what has changed, without the need to search through your CI/CD pipelines. Deploy markers log all new deployments in one place and link back to the CI/CD pipelines that caused them. You can use deploy markers independently, without installing the CircleCI release agent.   Automatic detection of deployments  CircleCI looks for the word deploy in your job names to detect when a deployment may have happened and creates an auto-detected deploy marker.   When CircleCI creates a deploy marker for you automatically, we use the information available in your pipeline configuration to create the following:     Component: CircleCI created a component for the deployment and uses your project name to create a component name.   Environment integration: CircleCI creates an environment for you, using your job and workflow names to attempt to create a relevant name. If an environment name cannot be generated, the name will be autogenerated, and you can edit it later. The environment has the type AUTODETECTED.   Version: CircleCI uses the build number to populate the version for the purposes of displaying the deployment in the CircleCI web app.     If any of the following conditions are true, CircleCI will not automatically generate a deploy marker for a job even if the name contains the word deploy:     The job has a status other than SUCCESS.   Any of the following keywords and keyword combinations are present in the job name:    dry run   skip deploy   bypass deploy   deployed   validation   validate      The project related to the job has deployments created via the Kubernetes release agent or manual release-type jobs in the last two months.   You have opted out of the automatic deploy detection feature.   The detected environment integration name collides with an integration you have already set up.     Manual configuration of automatically detected deploys  Some points to consider when manually configuring an automatically detected deploy are as follows:     If you decide you would like to manually configure a deploy marker for an environment integration that was created as part of an automatically detected deploy, refer to the  Configure deploy markers page to set up a deploy marker and a new environment integration.   If you change a component name that was originally autodetected by CircleCI, we create a new component and the history will not carry over. If you do not update the component name, the history will carry over.   If your environment integration has an autogenerated name, you can edit the name as follows:    In the  CircleCI web app, select your organization.   Select Deploys in the sidebar.   Select the Environments tab.   Find your environment and select cog icon () to enter the environment integration settings page.   Select Edit.   Enter a new name and select Update.          Opt out of automatic deploy detection  If you do not want CircleCI to automatically create deploy markers for you, you can opt out of this feature either for a whole organization or per-project.   To opt out of automatic deploy detection for an entire organization, follow these steps:     In the  CircleCI web app, select your organization.   Select Organization settings in the sidebar.   Select Deploys.   Toggle the "Enable automatic deploy marker detection" option left. You will see a confirmation message in the bottom right hand corner of the app. To re-enable the feature, toggle the option to the right.     To opt out of automatic deploy detection for a project, follow these steps:     In the  CircleCI web app, select your organization.   Select Projects in the sidebar.   Find your project in the list, select the ellipsis (), select Project Settings.   Select Deploys.   Toggle the "Enable automatic deploy marker detection" option left. You will see a confirmation message in the bottom right hand corner of the app. To re-enable the feature, toggle the option to the right.      Retention Policy  Automatically detected deploys are retained for 30 days.    Manual deploy marker setup  If you would rather set up deploy markers yourself, see the  Configure deploy markers page.      Deploy status   A deployment can be in one of the following states:  StatusNotesRUNNINGThe deployment is currently in progress.FAILEDResources have reached an unhealthy status (pods for the new version of a Kubernetes component).SUCCESSThe Deployment or Rollout has all desired resources available (all pods specified by a Kubernetes Deployment or Argo Rollout).CANCELLEDThe deployment has been cancelled, either using the cancel deployment option, or by being superseded by another deployment.EXPIREDDeployment commands failed to be picked up by the release agent within the required time window.LOGGEDDeployment has been logged using a deploy marker and is available in the CircleCI deploys UI.    Known limitations     Restarting the release agent while a deployment is ongoing causes the release agent to lose track of the deployment status and fail to update the CircleCI services accordingly.   In the CircleCI deploys UI it is currently possible for you to attempt to restore a version that does not exist. All deployments are presented in the UI, including those outside of the scope of any version history limits you might have set. We do not currently filter out deployments for which there is no longer any data.  Depending on your setup, you will have options for configuring revision history limits: revisionHistoryLimit for Kubernetes and Argo Rollouts, and $HELM_MAX_HISTORY for Helm.   If you have these limits set, you can’t restore a version outside the limit. For example, if your limit is set to the last 10 deployments, you can not restore the 11th deployment back.   We are working on updates to:     Indicate out-of-scope deployments.   Prevent you from attempting to restore unavailable deployments   Provide a manual way for you to mark deployments as unavailable          Troubleshooting   Why is my Deployment/Rollout not showing up in the components tab or releases timeline view?    Check that the Deployment/Rollout is annotated with the required labels. More information is available in the  Set up guides. If the required labels were not present, then adding them should solve the problem.   If you are using a Deployment, check that the desired replicas is not set to 0. Deployments with 0 replicas are not reported as releases, even if they are scaled up subsequently. The configured value can be seen on the release agent deployment in the circleci-release-agent-system namespace. Here is an example in which the number of desired replicas is 2:   apiVersion: apps/v1
kind: Deployment
metadata:
  name: sample-deployment
  namespace: sample-namespace
spec:
  replicas: 2     Check that the Deployment/Rollout is in a namespace managed by the release agent. This can be verified by checking the MANAGED_NAMESPACES environment variable on the release agent deployment in the circleci-release-agent-system namespace. Here is an example in which only the default namespace is being managed:   apiVersion: apps/v1
kind: Deployment
metadata:
  name: circleci-release-agent
  namespace: circleci-release-agent-system
spec:
  template:
    spec:
      containers:
      - env:
        - name: MANAGED_NAMESPACES
          value: default        Why is my release is stuck in the Running state?    If you are using a Deployment, check whether it was deleted before the release could complete. In this scenario, this is an expected behavior. This experience will be improved upon in future release agent updates.   If you are using a Deployment, check whether the release agent restarted before all pods for the deployment could become ready. This is a known limitation that will be addressed in future updates of the release agent. Restarting a release agent while a release is ongoing will cause the release agent to lose track of the release status and fail to update the CircleCI services accordingly.      Why are no new releases are showing up? and/or why are component versions not being updated?    Check whether the token used by the release agent has been revoked:    Select Releases in the CircleCI web app sidebar   Select Configure Environments to enter the release environments view   Select your environment to view valid token details, including when the token was last used.  If the token has been last used longer than a minute ago, then this is likely to be the problem.       Check whether tokens are being shared between multiple release environments. This is not supported. Check this by following these steps:    Retrieve the token value from the token field in the circleci-release-agent secret in the circleci-release-agent-system namespace   Compare the value with the partially obscured value for the available Tokens in the CircleCI web app  If the token does not show up in the list, then it has been revoked or the value configured on the release agent is incorrect. In either case, creating a new token and reinstalling the Release Agent with the new value should solve the issue.          Why is restore version using Helm is timing out?  The time required for a Helm-based restore version to complete successfully is dependent on the specific configuration of the target component. For example, a large number of replicas will lead to a longer duration, which could cause a timeout. It is possible to specify a different timeout by adding the circleci.com/operation-timeout annotation to the Rollout or Deployment. The default value for this is 10 minutes. For steps see the  Configure your Kubernetes components page.    Why is the restore version button not available for a component version?  Check whether the component has been undeployed. If there are currently no live versions for a component, the Restore Version button will not be visible for that component until at least one version has been deployed.    Why are all buttons disabled for a release?  Check whether the release is a Rollback. If this is the case, then this is a known issue that will be solved in a future update to the CircleCI release agent.    Why are all commands for my component failing?  Check if the error message is “invalid or missing project ID“. In this case the component is missing a valid  Project ID.      Next steps      Set up CircleCI deploys   To try out CircleCI deploys for a Kubernetes deployment, visit the  Continuous delivery config examples repo.     Suggest an edit to this pageMake a contribution Learn how to contributeStill need help? Ask the CircleCI community Join the research community Visit our Support site\n\nDeploys overview1 week ago13 min readCloudOn This PageIntroductionQuickstartHow it worksConceptsComponentDeliveryDeploymentCommandReleaseThe deploys UIThe dashboardFilter and group components and environments with labelsUse labels to filter components and environmentsAdd or edit labelsComponent labelsEnvironment labelsView all deployments for an environmentView all commands run for an environmentView all deployments for a componentView all commands run for a componentRequirementsToolingLabels and annotationsAutomatic deployment detection and deploy markersAutomatic detection of deploymentsManual configuration of automatically detected deploysOpt out of automatic deploy detectionRetention PolicyManual deploy marker setupDeploy statusKnown limitationsTroubleshootingWhy is my Deployment/Rollout not showing up in the components tab or releases timeline view?Why is my release is stuck in the Running state?Why are no new releases are showing up? and/or why are component versions not being updated?Why is restore version using Helm is timing out?Why is the restore version button not available for a component version?Why are all buttons disabled for a release?Why are all commands for my component failing?Next steps   Visualize and control your deployments with CircleCI deploys. The CircleCI deploys dashboard supports any deployment, and the deploys management tooling works with deployments to Kubernetes and Amazon SageMaker.     Introduction   CircleCI deploys gives you visibility into your Kubernetes deployments within the CircleCI web app, as well as access to commands and visualisations for managing deployments. From the CircleCI web app, you can:     Restore version   Scale component   Restart component     We support  Argo Rollouts for progressive delivery. Currently the  canary deployment strategy is supported, but in a future release  blue-green will also be supported. Some further controls are available for projects that use Argo Rollouts:     Retry Rollout   Promote Rollout   Cancel Rollout       Quickstart   To get started with CircleCI deploys for Kubernetes right away, refer to the following guides:      Tutorial 1: Set up CircleCI deploys    Tutorial 2: Configure your Kubernetes components    How-to: Manage deploys     To get set up with deploys for Amazon SageMaker, refer to the  Deploy to Amazon SageMaker page.     How it works   CircleCI integrates with your Kubernetes cluster to give you visibility and control over your release process through the CircleCI web app. We currently support Kubernetes Deployments and Argo Rollouts.        Configure environment integrations to install the CircleCI release agent into your Kubernetes clusters. Configure the release agent to only monitor the namespaces you require.   Developers can monitor deployments in the CircleCI web app, and run commands to manage those deployments from the UI. Commands are monitored by CircleCI and relayed to the release agent, which then runs the commands for you.     Concepts   The sections below explain some key software delivery concepts. Understanding these concepts will help you take full advantage of CircleCI deploys.   Component  A component in CircleCI is a collection of code and configuration that is deployed and released as a single unit. In Kubernetes terms, this would be a Deployment or Rollout object along with the related objects such as Pods, ReplicaSets, etc. that share a common circleci.com/component-name label.    Delivery  Delivery is the act of packaging code changes and making them available for Deployment. Continuous delivery is the prerequisite step for continuous deployment. With some variations on the technologies being used, the delivery process creates executables from code and then makes them available to be deployed to an environment at a subsequent time.    Deployment  Deployment is the act of putting a new component version into an environment, regardless of whether users and other services interact with the new version or a previous one. Depending on the deployment type, a release may happen either:     As a later task, such as switching over traffic shaping rules for a blue/green deployment.   As a direct consequence of the deployment, such as a standard Kubernetes rolling update.      Command  A command is a user-initiated action CircleCI performs on the user’s behalf to manipulate a specific component. Actions are run asynchronously via our release agent and the results are reported back to the CircleCI web app. You can see the results in the deployments dashboard, similarly to how step output works for CI jobs.   Some commands are available for all components. These are:     Restore version   Scale component   Restart component     A subset of commands are available for progressive deployments (when using Argo Rollouts). These are:     Retry deployment   Promote deployment   Cancel deployment      Release  A release is the act of updating a component to a new version in a specific environment, causing it to become available to an audience of users and other services.   A release can happen when an existing component is updated or when the first version for a new component is deployed.   In the deploys dashboard, deployments are tagged as Progressive if they refer to an Argo Rollout.   A deployment starts when the component version is updated, and ends when the new version has reached 100% availability, and all associated validations have been completed. In the case of a progressive deployment, this happens when the Rollout completes. In the case of a Kubernetes Deployment, this happens when the Deployment replicas are all available and ready.      The deploys UI   The CircleCI deploys UI is a powerful tool for visualising, monitoring and managing your deployments. The pages included in the deploys UI are described below.   The dashboard       Select Deploys in the CircleCI web app sidebar to enter the deploys dashboard. The dashboard shows the following:     Timeline: A timeline of deploys across your organization’s components and environments. You can use the filter dropdown menus at the top of the page to select a component and/or environment. You will see live status updates, deployment trigger source, deployment version version, deployment type (for example, progressive, when you are using an Argo Rollout). From here you can access the following:    The deployment details page for a specific deployment by clicking on the status badge or version number.   The component or environment details pages by clicking on the respective names.   The project dashboard for the CircleCI project associated with a deployment.   The job details page for the job that started the deployment.   The commit details page in your VCS for the commit that started the deployment.      Environments: List of environment integrations set up for your organization. From here you can:    Set up a new environment integration by selecting Create Environment Integration.   Access settings for each environment ().   Access the environment details view by selecting an environment name.      Components: A list of components and their associated projects. From here you can:    Set up a new component by selecting Create Component. From here you can select and environment that has a successful environment integration set up, and from there you can add a new component.   Get straight to the component’s project building on CircleCI by selecting the project name.   Access setting for each component ().         Filter and group components and environments with labels  Add labels to your components and environments to provide teams with a way to filter and group content in the deploys UI. Once a label is added, you can use this to filter your view to focus on the content relevant to your team.   Labels are composed of two values separated by a colon, for example, team:my-team-name. To specify multiple labels for a component or environment, you can separate them with a comma. For example, team:my-team-name, role:web. You can add up to 20 labels to a component or environment.   Use labels to filter components and environments  Once you have added labels to your components and environments, you can use them to filter your view in the deploys UI. In the timeline, environments, or components view, select a filter to reduce the content in the tab to only your selection. You can also use the label filter dropdown menu at the top of the page.    Add or edit labels  To add or edit labels follow the steps below.      Figure 1. Add and Edit environment and component labels   Component labels  To add or edit labels for a component, follow these steps:     Select Deploys in the CircleCI web app sidebar.   You are now in the timeline view. Select the Components tab.   Select the cog icon () for your component. You can use the filter at the top of the page to help find the component you want.   You are now on the component settings page. Select the edit button () in the labels panel.   Enter or edit your label(s) and select Done.      Environment labels  To add or edit labels for an environment, follow these steps:     Select Deploys in the CircleCI web app sidebar.   You are now in the timeline view. Select the Environments tab.   Select the cog icon () for your environment.   You are now on the environment settings page. Select the edit button () in the labels panel.   Enter or edit your label(s) and select Done.        View all deployments for an environment  To view all deployments for an environment, follow these steps:     Select Deploys in the CircleCI web app sidebar.   You are now in the timeline view. Select the Environments tab.   Select your environment by name.   You are now on the environment details page. Select the Deployments tab to view a list of all deployments for your chosen environment.      View all commands run for an environment  To view all commands run for an environment, follow these steps:     Select Deploys in the CircleCI web app sidebar.   You are now in the timeline view. Select the Environments tab.   Select your environment by name.   You are now on the environment details page. Select the Commands tab to view a list of all commands that have been run for your chosen environment.      View all deployments for a component  To view all deployments for a component, follow these steps:     Select Deploys in the CircleCI web app sidebar.   You are now in the timeline view. Select the Components tab.   Select your component by name. You can use the filter at the top of the page to help.   You are now on the component details page. Select the Deployments tab to view a list of all deployments for your chosen component.      View all commands run for a component  To view all commands run for a component, follow these steps:     Select Deploys in the CircleCI web app sidebar.   You are now in the timeline view. Select the Components tab.   Select your component by name. You can use the filter at the top of the page to help.   You are now on the component details page. Select the Commands tab to view a list of all commands run for your chosen component.        Requirements   Tooling  We test the versions listed here. Older versions may work but are not guaranteed.  ToolTested versionsKubernetes 1.29.0 1.28.0 1.27.0 Helm 3.12.0 3.11.0 Argo Rollouts (optional) 1.6.0 1.5.0    Labels and annotations  The following table shows a complete list of labels and annotations either required or available for configuring your environment integration.  Label/annotationValueRequired?Metadata.Labelscircleci.com/component-nameA name for your applicationYesMetadata.Labelscircleci.com/versionCurrent versionYesSpec.Template.Metadata.Labelscircleci.com/component-nameSee aboveYesSpec.Template.Metadata.Labelscircleci.com/versionSee aboveYesMetadata.Annotationscircleci.com/project-idProject ID for the CircleCI project associated with the job that deploys your componentYesMetadata.Annotationscircleci.com/operation-timeoutA  Go duration string, for example, 5m, 10m15sNo. Only needed to set a custom timeout duration. This option is only available if you are using Helm to configure your Kubernetes resources.Metadata.Annotationscircleci.com/restore-version-enabledfalseNo. Only set if you want to disable the restore version feature for your component.Metadata.Annotationscircleci.com/scale-component-enabledfalseNo. Only set if you want to disable the scale component feature for your component.Metadata.Annotationscircleci.com/restart-component-enabledfalseNo. Only set if you want to disable the restart component feature for your component.Metadata.Annotationscircleci.com/retry-release-enabledfalseNo. Only set if you want to disable the retry deployment feature for your component.Metadata.Annotationscircleci.com/promote-release-enabledfalseNo. Only set if you want to disable the promote deployment feature for your component.Metadata.Annotationscircleci.com/cancel-release-enabledfalseNo. Only set if you want to disable the cancel deployment feature for your component.     Automatic deployment detection and deploy markers   CircleCI automatically generates deploy markers for your deployment pipelines. Deploy markers provide a lightweight way to log your deployments without requiring a full CircleCI deploys setup. Deploy markers generate a log of all deployments in one place, for a clear overview of what has changed, without the need to search through your CI/CD pipelines. Deploy markers log all new deployments in one place and link back to the CI/CD pipelines that caused them. You can use deploy markers independently, without installing the CircleCI release agent.   Automatic detection of deployments  CircleCI looks for the word deploy in your job names to detect when a deployment may have happened and creates an auto-detected deploy marker.   When CircleCI creates a deploy marker for you automatically, we use the information available in your pipeline configuration to create the following:     Component: CircleCI created a component for the deployment and uses your project name to create a component name.   Environment integration: CircleCI creates an environment for you, using your job and workflow names to attempt to create a relevant name. If an environment name cannot be generated, the name will be autogenerated, and you can edit it later. The environment has the type AUTODETECTED.   Version: CircleCI uses the build number to populate the version for the purposes of displaying the deployment in the CircleCI web app.     If any of the following conditions are true, CircleCI will not automatically generate a deploy marker for a job even if the name contains the word deploy:     The job has a status other than SUCCESS.   Any of the following keywords and keyword combinations are present in the job name:    dry run   skip deploy   bypass deploy   deployed   validation   validate      The project related to the job has deployments created via the Kubernetes release agent or manual release-type jobs in the last two months.   You have opted out of the automatic deploy detection feature.   The detected environment integration name collides with an integration you have already set up.     Manual configuration of automatically detected deploys  Some points to consider when manually configuring an automatically detected deploy are as follows:     If you decide you would like to manually configure a deploy marker for an environment integration that was created as part of an automatically detected deploy, refer to the  Configure deploy markers page to set up a deploy marker and a new environment integration.   If you change a component name that was originally autodetected by CircleCI, we create a new component and the history will not carry over. If you do not update the component name, the history will carry over.   If your environment integration has an autogenerated name, you can edit the name as follows:    In the  CircleCI web app, select your organization.   Select Deploys in the sidebar.   Select the Environments tab.   Find your environment and select cog icon () to enter the environment integration settings page.   Select Edit.   Enter a new name and select Update.          Opt out of automatic deploy detection  If you do not want CircleCI to automatically create deploy markers for you, you can opt out of this feature either for a whole organization or per-project.   To opt out of automatic deploy detection for an entire organization, follow these steps:     In the  CircleCI web app, select your organization.   Select Organization settings in the sidebar.   Select Deploys.   Toggle the "Enable automatic deploy marker detection" option left. You will see a confirmation message in the bottom right hand corner of the app. To re-enable the feature, toggle the option to the right.     To opt out of automatic deploy detection for a project, follow these steps:     In the  CircleCI web app, select your organization.   Select Projects in the sidebar.   Find your project in the list, select the ellipsis (), select Project Settings.   Select Deploys.   Toggle the "Enable automatic deploy marker detection" option left. You will see a confirmation message in the bottom right hand corner of the app. To re-enable the feature, toggle the option to the right.      Retention Policy  Automatically detected deploys are retained for 30 days.    Manual deploy marker setup  If you would rather set up deploy markers yourself, see the  Configure deploy markers page.      Deploy status   A deployment can be in one of the following states:  StatusNotesRUNNINGThe deployment is currently in progress.FAILEDResources have reached an unhealthy status (pods for the new version of a Kubernetes component).SUCCESSThe Deployment or Rollout has all desired resources available (all pods specified by a Kubernetes Deployment or Argo Rollout).CANCELLEDThe deployment has been cancelled, either using the cancel deployment option, or by being superseded by another deployment.EXPIREDDeployment commands failed to be picked up by the release agent within the required time window.LOGGEDDeployment has been logged using a deploy marker and is available in the CircleCI deploys UI.    Known limitations     Restarting the release agent while a deployment is ongoing causes the release agent to lose track of the deployment status and fail to update the CircleCI services accordingly.   In the CircleCI deploys UI it is currently possible for you to attempt to restore a version that does not exist. All deployments are presented in the UI, including those outside of the scope of any version history limits you might have set. We do not currently filter out deployments for which there is no longer any data.  Depending on your setup, you will have options for configuring revision history limits: revisionHistoryLimit for Kubernetes and Argo Rollouts, and $HELM_MAX_HISTORY for Helm.   If you have these limits set, you can’t restore a version outside the limit. For example, if your limit is set to the last 10 deployments, you can not restore the 11th deployment back.   We are working on updates to:     Indicate out-of-scope deployments.   Prevent you from attempting to restore unavailable deployments   Provide a manual way for you to mark deployments as unavailable          Troubleshooting   Why is my Deployment/Rollout not showing up in the components tab or releases timeline view?    Check that the Deployment/Rollout is annotated with the required labels. More information is available in the  Set up guides. If the required labels were not present, then adding them should solve the problem.   If you are using a Deployment, check that the desired replicas is not set to 0. Deployments with 0 replicas are not reported as releases, even if they are scaled up subsequently. The configured value can be seen on the release agent deployment in the circleci-release-agent-system namespace. Here is an example in which the number of desired replicas is 2:   apiVersion: apps/v1
kind: Deployment
metadata:
  name: sample-deployment
  namespace: sample-namespace
spec:
  replicas: 2     Check that the Deployment/Rollout is in a namespace managed by the release agent. This can be verified by checking the MANAGED_NAMESPACES environment variable on the release agent deployment in the circleci-release-agent-system namespace. Here is an example in which only the default namespace is being managed:   apiVersion: apps/v1
kind: Deployment
metadata:
  name: circleci-release-agent
  namespace: circleci-release-agent-system
spec:
  template:
    spec:
      containers:
      - env:
        - name: MANAGED_NAMESPACES
          value: default        Why is my release is stuck in the Running state?    If you are using a Deployment, check whether it was deleted before the release could complete. In this scenario, this is an expected behavior. This experience will be improved upon in future release agent updates.   If you are using a Deployment, check whether the release agent restarted before all pods for the deployment could become ready. This is a known limitation that will be addressed in future updates of the release agent. Restarting a release agent while a release is ongoing will cause the release agent to lose track of the release status and fail to update the CircleCI services accordingly.      Why are no new releases are showing up? and/or why are component versions not being updated?    Check whether the token used by the release agent has been revoked:    Select Releases in the CircleCI web app sidebar   Select Configure Environments to enter the release environments view   Select your environment to view valid token details, including when the token was last used.  If the token has been last used longer than a minute ago, then this is likely to be the problem.       Check whether tokens are being shared between multiple release environments. This is not supported. Check this by following these steps:    Retrieve the token value from the token field in the circleci-release-agent secret in the circleci-release-agent-system namespace   Compare the value with the partially obscured value for the available Tokens in the CircleCI web app  If the token does not show up in the list, then it has been revoked or the value configured on the release agent is incorrect. In either case, creating a new token and reinstalling the Release Agent with the new value should solve the issue.          Why is restore version using Helm is timing out?  The time required for a Helm-based restore version to complete successfully is dependent on the specific configuration of the target component. For example, a large number of replicas will lead to a longer duration, which could cause a timeout. It is possible to specify a different timeout by adding the circleci.com/operation-timeout annotation to the Rollout or Deployment. The default value for this is 10 minutes. For steps see the  Configure your Kubernetes components page.    Why is the restore version button not available for a component version?  Check whether the component has been undeployed. If there are currently no live versions for a component, the Restore Version button will not be visible for that component until at least one version has been deployed.    Why are all buttons disabled for a release?  Check whether the release is a Rollback. If this is the case, then this is a known issue that will be solved in a future update to the CircleCI release agent.    Why are all commands for my component failing?  Check if the error message is “invalid or missing project ID“. In this case the component is missing a valid  Project ID.      Next steps      Set up CircleCI deploys   To try out CircleCI deploys for a Kubernetes deployment, visit the  Continuous delivery config examples repo.     Suggest an edit to this pageMake a contribution Learn how to contributeStill need help? Ask the CircleCI community Join the research community Visit our Support site DocsTerms of UsePrivacy PolicyCookie PolicySecurity© 2025 Circle Internet Services, Inc., All Rights Reserved.\n\n1.29.0 1.28.0 1.27.0  3.12.0 3.11.0  1.6.0 1.5.0  apiVersion: apps/v1
kind: Deployment
metadata:
  name: sample-deployment
  namespace: sample-namespace
spec:
  replicas: 2  apiVersion: apps/v1
kind: Deployment
metadata:
  name: circleci-release-agent
  namespace: circleci-release-agent-system
spec:
  template:
    spec:
      containers:
      - env:
        - name: MANAGED_NAMESPACES
          value: default\n\n\n\nView entire changelog

    
      
        Config Policies soft fails UI
      
      
        Oct 03, 2023
        
          
          


  
    
    
    
    
    
    Enhancement
  


        
      
    

    
      Soft fails for CircleCI config policies are now displayed on the pipelines dashboard.

    

    
      
    
  



  
    >Previous changes
  
  
    
    
        








  
    
      Oct 02, 2023
    
    
      
        
        


  
    
    
    
    
    
    Maintenance
  


      
    
  
  
    
  
  
    
      Oct 02, 2023
    
    
      
        
        
        macOS Resource EOL    
        
      
    
    
      
        
        


  
    
    
    
    
    
    Maintenance
  


      
    

    
      
        
      
  

        
          








  
    
      Sep 11, 2023
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    
  
  
    
  
  
    
      Sep 11, 2023
    
    
      
        
        
        “Rerun failed tests” time savings in Web App    
        
      
    
    
      
        
        


  
    
    
    
    
    
    Enhancement\n\nView entire changelog

    
      
        Config Policies soft fails UI
      
      
        Oct 03, 2023
        
          
          


  
    
    
    
    
    
    Enhancement
  


        
      
    

    
      Soft fails for CircleCI config policies are now displayed on the pipelines dashboard.

    

    
      
    
  



  
    >Previous changes
  
  
    
    
        








  
    
      Oct 02, 2023
    
    
      
        
        


  
    
    
    
    
    
    Maintenance
  


      
    
  
  
    
  
  
    
      Oct 02, 2023
    
    
      
        
        
        macOS Resource EOL    
        
      
    
    
      
        
        


  
    
    
    
    
    
    Maintenance
  


      
    

    
      
        
      
  

        
          








  
    
      Sep 11, 2023
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    
  
  
    
  
  
    
      Sep 11, 2023
    
    
      
        
        
        “Rerun failed tests” time savings in Web App    
        
      
    
    
      
        
        


  
    
    
    
    
    
    Enhancement\n\nOct 02, 2023
    
    
      
        
        


  
    
    
    
    
    
    Maintenance
  


      
    
  
  
    
  
  
    
      Oct 02, 2023
    
    
      
        
        
        macOS Resource EOL    
        
      
    
    
      
        
        


  
    
    
    
    
    
    Maintenance
  


      
    

    
      
        
      
  

  
    
      Sep 11, 2023
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    
  
  
    
  
  
    
      Sep 11, 2023
    
    
      
        
        
        “Rerun failed tests” time savings in Web App    
        
      
    
    
      
        
        


  
    
    
    
    
    
    Enhancement\n\n\n\nDeploy to Amazon SageMaker1 week ago6 min readCloudOn This PagePrerequisites1. Set up a CircleCI environment integration2. Set up Amazon SageMaker accessa. OIDC Identity Providerb. Policyc. Role3. Set environment variables4. Set up your CircleCI configuration5. Build a model package version6. Use the orb7. Check in on your deployment      The  SageMaker orb is in open preview.        This how-to guide walks you through the steps to set up and use the Amazon SageMaker orb to deploy and release models to SageMaker. It uses the sample repository  example project repository as a reference, but you can adapt every step to your requirements. Through this guide, you will learn how to orchestrate model deployment to endpoints across different environments, as well as track and manage your deployments in the CircleCI deploys UI.   For further information about the orb and the CircleCI deploys feature see the following:      Deploys overview    Amazon SageMaker orb    Blog post: Using Amazon SageMaker orb to orchestrate model deployment across environments       Prerequisites   To follow along with this how-to guide you will need the following:     A CircleCI account connected to your code. You can  sign up for free   Basic knowledge of Amazon SageMaker   An AWS account with access to SageMaker   A SageMaker studio domain to follow along the training step, or an existing Model Package Registry if you have already trained one   A copy of the  example repository building on CircleCI. For steps to get the project set up, see the  Create a project in CircleCI page.       1. Set up a CircleCI environment integration   First, set up an environment integration to monitor your deployments from the CircleCI web app, and access options to manage promotions and rollbacks.     In the CircleCI web app, select Deploys from the sidebar   If this is your first environment integration, you will see an option to Create your first environment integration. If not, select the "Environments" tab, and then select Create Environment Integration        In the popup, select Amazon SageMaker from the "Type" dropdown. Follow the instructions on screen to generate and save a token.       2. Set up Amazon SageMaker access   a. OIDC Identity Provider  In this section you will create an IAM (Identity and Access Management) Identity Provider in your AWS IAM for the CircleCI OIDC Provider. The Amazon SageMaker orb uses OIDC. You may already have this set up, in which case you can skip this section. For more information on CircleCI OIDC functionality, see the  Using OpenID Connect tokens in jobs page.     Navigate to your AWS Management Console   Go to IAM  Access management  Identity providers   Select Add Provider        Under "Provider Type", select OpenID Connect   Enter your "Provider URL". This will be https://oidc.circleci.com/org/<your-organization-id>, where <your-organization-id> is the ID of your CircleCI organization.      To find your organization/user ID, select Organization Settings in the CircleCI web app side bar.             Select Get Thumbprint.   For "Audience" enter your organization ID.   Select Add Provider.      b. Policy    From your AWS management console, navigate to IAM  Policies   Select Create Policy.   Select JSON to select the JSON policy editor and then copy in the following permissions. We have organized the permissions into two groups. OrbPermissions and S3Access statements are used for the deployment of the model to the endpoints. The S3AccessTrainModel and SageMakerTrainModel statements are needed if you want to train the demo model we provide.     Update the S3 bucket information to match your setup. Create a bucket if one does not yet exist.         {
    "Version": "2012-10-17",
    "Statement": [
        {
            "Sid": "OrbPermissions",
            "Effect": "Allow",
            "Action": [
                "sagemaker:AddTags",
                "sagemaker:CreateEndpointConfig",
                "sagemaker:CreateModel",
                "sagemaker:DescribeEndpoint",
	 	        "sagemaker:DescribeEndpointConfig",
                "sagemaker:ListEndpoints",
                "sagemaker:ListModelPackages",
                "sagemaker:ListTags",
                "sagemaker:UpdateEndpoint",
                "iam:PassRole"
            ],
            "Resource": "*"
        },
        {
            "Sid": "S3Access",
            "Effect": "Allow",
            "Action": [
                "s3:GetObject",
                "s3:ListBucket"
            ],
            "Resource": [
                "arn:aws:s3:::<BUCKET_FOR_MODEL_ASSETS>/*"
            ]
        },
        {
            "Sid": "S3AccessTrainModel",
            "Effect": "Allow",
            "Action": [
                "s3:GetObject",
                "s3:ListBucket",
                "s3:PutObject"
            ],
            "Resource": [
                "arn:aws:s3:::sagemaker-sample-files/*",
                "arn:aws:s3:::circleci-sagemaker-pipeline",
                "arn:aws:s3:::circleci-sagemaker-pipeline/*"
            ]
        },
        {
            "Sid": "SageMakerTrainModel",
            "Effect": "Allow",
            "Action": [
                "sagemaker:CreateTrainingJob",
                "sagemaker:DescribeTrainingJob",
                "logs:DescribeLogStreams",
                "sagemaker:ListModelPackageGroups",
                "sagemaker:CreateModelPackage",
                "sagemaker:UpdateModelPackage"
            ],
            "Resource": "*"
        }
    ]
}     Scroll down and click Next   Give your policy a name and then click Create Policy      c. Role    From your AWS management console, navigate to IAM  Roles   Select Create Role.   Select Web Identity and then select the CircleCI provider you created above, and under Audience, select your org ID   Use the search function to find the policy you created above by name, select it and click Next   Give your Role a name, and then scroll to the Trust policy section. Set up the Trust relationship between the Role and the CircleCI OIDC Provider. Here is an example Policy. Remember to replace the placeholders <CIRCLECI-ORG-ID> and <CIRCLECI-PROJECT-ID> with your values.   {
	"Version": "2012-10-17",
	"Statement": [
        {
            "Effect": "Allow",
            "Principal": {
                "Federated": "arn:aws:iam::<AWS-ACCOUNT-ID>:oidc-provider/oidc.circleci.com/org/<CIRCLECI-ORG-ID>"
            },
            "Action": "sts:AssumeRoleWithWebIdentity",
            "Condition": {
                "StringLike": {
                    "oidc.circleci.com/org/<CIRCLECI-ORG-ID>:sub": "org/<CIRCLECI-ORG-ID>/project/<CIRCLECI-PROJECT-ID>/user/*"
                }
            }
        },
        {
			"Effect": "Allow",
			"Principal": {
				"Service": "sagemaker.amazonaws.com"
			},
			"Action": "sts:AssumeRole"
		}

    ]
}     Select Create Role.   Select your role from the list and copy the Role ARN, you will need this in the next section.             3. Set environment variables   The CircleCI Amazon SageMaker orb requires some environment variables to function. You can store these environment variables at the project level, or you can store them using a  context. The following steps show how to add the environment variables at the project level. You need to add two environment variables, as follows:     CCI_RELEASE_INTEGRATION_TOKEN: The orb connects your deployment to SageMaker with  CircleCI deploys. This gives you visibility into the Endpoint Configuration Updates, and what is currently active.   SAGEMAKER_EXECUTION_ROLE_ARN: This is the AWS IAM Role you configured with the necessary SageMaker permissions, and the OIDC Trust relationship.        Follow these steps to add the environment variables:     In the  CircleCI web app, select your org from the org cards on your user homepage.   Select Projects from the sidebar and locate your project from the list. You can use the search to help.   Select the ellipsis () next to your project and select Project Settings.       In the sidebar menu, select Environment Variables.   Select Add Environment Variable button to enter a name and value of the new environment variable.        Repeat step four for the second environment variable       4. Set up your CircleCI configuration   Take a look at the .circleci/config.yml for the  sample project. In the block of pipeline parameters at the top, you need to update the defaults with your values.    parameters:
  bucket:
    type: string
    default: circleci-sagemaker-pipeline
  model_desc:
    type: string
    default: "Kitten Classifier allowing us to distinguish between giraffes and kittens."
  model_name:
    type: string
    default: kitten-classifier
  project_id:
    type: string
    default: "e47ee9b0-446f-44cf-bec8-5407ceb06930"
  region_name:
    type: string
    default: us-east-1    Make the following updates:  ParameterDefaultbucketThe bucket you set up in the Role Policymodel_descA description of your modelmodel_nameThe name of the modelproject_idThe CircleCI project ID, you can find this on the Project Settings page in the CircleCI web appregion_nameThe region, for example, us-east-1    5. Build a model package version   The sample app used in this how-to guide uses a model commonly found in AWS documentation, Abalone. It has just been renamed. If you already have your own model, feel free to adapt the configuration file to use that one instead. All you will need to do is update the model_name parameter.   Assuming you are using our example repository, follow these steps to build a new model package version:     A workflow (model-train) is configured to run on the branch model-train. Checkout the model-train branch, and push it up to GitHub   The model-train workflow will make a new model package version in the model registry. If the model package doesn’t already exist, it will create it.     Every time you run this workflow by pushing to the model-train branch, anew model version is created.     6. Use the orb   Let’s break down the deploy-model-through-to-prod workflow. Our first job is aws-sagemaker/create_model. This job creates a model from your latest Model Package in the registry. This will be what we then deploy to the inference endpoints. In general, create-model just needs to be called one time at the beginning of your workflow:          - aws-sagemaker/create_model:
          # job name that will show in Workflow DAG
          name: create-model
          # s3 bucket where asset will be stored
          bucket: << pipeline.parameters.bucket >>
          # Name of the model in SageMaker that we will be deploying.
          model_name: << pipeline.parameters.model_name >>
          # We use the pipeline.id as the unique identifier for some of the configs we create
          circle_pipeline_id: << pipeline.id >>
          # Region where we are deploying to
          region_name: << pipeline.parameters.region_name >>
          filters: *main-branch-only      Aside from name and filters, all other parameters are passed in from our pipeline parameters.   name controls the name of this job visible in the Workflow graph in the CircleCI web app.   filters allows you to control what branch the job runs on.     Next, we need to create the endpoint configuration, this happens in the job aws-sagemaker/create_endpoint_configuration:          - aws-sagemaker/create_endpoint_configuration:
          name: dev:create-model-endpoint-config
          bucket: << pipeline.parameters.bucket >>
          model_name: << pipeline.parameters.model_name >>
          circle_pipeline_id: << pipeline.id >>
          circle_project_id: << pipeline.parameters.project_id >>
          region_name: << pipeline.parameters.region_name >>
          requires:
              - create-model
          filters: *main-branch-only      deploy_environment is an arbitrary string you can use to bucket your model releases, for example, dev, staging, testing, prod. In our example config, you can see we are only using two, dev and prod.     Next, we need to push out the updated configuration, this happens in the job aws-sagemaker/deploy_endpoint:          - aws-sagemaker/deploy_endpoint:
          name: dev:deploy-model-to-endpoint
          bucket: << pipeline.parameters.bucket >>
          model_name: << pipeline.parameters.model_name >>
          # Description for the model. q: can we make it optional?
          circle_pipeline_id: << pipeline.id >>
          circle_project_id: << pipeline.parameters.project_id >>
          model_desc: << pipeline.parameters.model_desc >>
          # You can find this value in the Project Settings in CircleCI
          region_name: << pipeline.parameters.region_name >>
          requires:
              - dev:create-model-endpoint-config
        filters: *main-branch-only      The only thing to set here is the deploy_environment so we know what endpoint_configuration to use. This will deploy your endpoint configuration.     Next, is an approval job. This stops the workflow from deploying to production until a human approves it. When this does get approval, we then repeat the above steps of aws-sagemaker/create_endpoint_configuration and aws-sagemaker/deploy_endpoint but with deploy_environment set to prod.:          - promote-model-to-prod-endpoint:
          type: approval
          requires:
            - dev:deploy-model-to-endpoint           7. Check in on your deployment   The CircleCI deploys UI offers you a single pane of glass to monitor all your deployments across environments. You can view deployment progress in real time, see what versions are currently deployed, and navigate to the SageMaker console. If you navigate to the deploys dashboard by clicking Deploys in the web app sidebar, you should now see something along the lines of the image below:        Select the component name to view details about the component, including the number of instances deployed. From this interface, you can navigate to Amazon SageMaker for live information on your endpoint.        Select the version to see the details page for the version being deployed. Clicking on a specific version lets you monitor deployment progress in real-time.        Suggest an edit to this pageMake a contribution Learn how to contributeStill need help? Ask the CircleCI community Join the research community Visit our Support site\n\nDeploy to Amazon SageMaker1 week ago6 min readCloudOn This PagePrerequisites1. Set up a CircleCI environment integration2. Set up Amazon SageMaker accessa. OIDC Identity Providerb. Policyc. Role3. Set environment variables4. Set up your CircleCI configuration5. Build a model package version6. Use the orb7. Check in on your deployment      The  SageMaker orb is in open preview.        This how-to guide walks you through the steps to set up and use the Amazon SageMaker orb to deploy and release models to SageMaker. It uses the sample repository  example project repository as a reference, but you can adapt every step to your requirements. Through this guide, you will learn how to orchestrate model deployment to endpoints across different environments, as well as track and manage your deployments in the CircleCI deploys UI.   For further information about the orb and the CircleCI deploys feature see the following:      Deploys overview    Amazon SageMaker orb    Blog post: Using Amazon SageMaker orb to orchestrate model deployment across environments       Prerequisites   To follow along with this how-to guide you will need the following:     A CircleCI account connected to your code. You can  sign up for free   Basic knowledge of Amazon SageMaker   An AWS account with access to SageMaker   A SageMaker studio domain to follow along the training step, or an existing Model Package Registry if you have already trained one   A copy of the  example repository building on CircleCI. For steps to get the project set up, see the  Create a project in CircleCI page.       1. Set up a CircleCI environment integration   First, set up an environment integration to monitor your deployments from the CircleCI web app, and access options to manage promotions and rollbacks.     In the CircleCI web app, select Deploys from the sidebar   If this is your first environment integration, you will see an option to Create your first environment integration. If not, select the "Environments" tab, and then select Create Environment Integration        In the popup, select Amazon SageMaker from the "Type" dropdown. Follow the instructions on screen to generate and save a token.       2. Set up Amazon SageMaker access   a. OIDC Identity Provider  In this section you will create an IAM (Identity and Access Management) Identity Provider in your AWS IAM for the CircleCI OIDC Provider. The Amazon SageMaker orb uses OIDC. You may already have this set up, in which case you can skip this section. For more information on CircleCI OIDC functionality, see the  Using OpenID Connect tokens in jobs page.     Navigate to your AWS Management Console   Go to IAM  Access management  Identity providers   Select Add Provider        Under "Provider Type", select OpenID Connect   Enter your "Provider URL". This will be https://oidc.circleci.com/org/<your-organization-id>, where <your-organization-id> is the ID of your CircleCI organization.      To find your organization/user ID, select Organization Settings in the CircleCI web app side bar.             Select Get Thumbprint.   For "Audience" enter your organization ID.   Select Add Provider.      b. Policy    From your AWS management console, navigate to IAM  Policies   Select Create Policy.   Select JSON to select the JSON policy editor and then copy in the following permissions. We have organized the permissions into two groups. OrbPermissions and S3Access statements are used for the deployment of the model to the endpoints. The S3AccessTrainModel and SageMakerTrainModel statements are needed if you want to train the demo model we provide.     Update the S3 bucket information to match your setup. Create a bucket if one does not yet exist.         {
    "Version": "2012-10-17",
    "Statement": [
        {
            "Sid": "OrbPermissions",
            "Effect": "Allow",
            "Action": [
                "sagemaker:AddTags",
                "sagemaker:CreateEndpointConfig",
                "sagemaker:CreateModel",
                "sagemaker:DescribeEndpoint",
	 	        "sagemaker:DescribeEndpointConfig",
                "sagemaker:ListEndpoints",
                "sagemaker:ListModelPackages",
                "sagemaker:ListTags",
                "sagemaker:UpdateEndpoint",
                "iam:PassRole"
            ],
            "Resource": "*"
        },
        {
            "Sid": "S3Access",
            "Effect": "Allow",
            "Action": [
                "s3:GetObject",
                "s3:ListBucket"
            ],
            "Resource": [
                "arn:aws:s3:::<BUCKET_FOR_MODEL_ASSETS>/*"
            ]
        },
        {
            "Sid": "S3AccessTrainModel",
            "Effect": "Allow",
            "Action": [
                "s3:GetObject",
                "s3:ListBucket",
                "s3:PutObject"
            ],
            "Resource": [
                "arn:aws:s3:::sagemaker-sample-files/*",
                "arn:aws:s3:::circleci-sagemaker-pipeline",
                "arn:aws:s3:::circleci-sagemaker-pipeline/*"
            ]
        },
        {
            "Sid": "SageMakerTrainModel",
            "Effect": "Allow",
            "Action": [
                "sagemaker:CreateTrainingJob",
                "sagemaker:DescribeTrainingJob",
                "logs:DescribeLogStreams",
                "sagemaker:ListModelPackageGroups",
                "sagemaker:CreateModelPackage",
                "sagemaker:UpdateModelPackage"
            ],
            "Resource": "*"
        }
    ]
}     Scroll down and click Next   Give your policy a name and then click Create Policy      c. Role    From your AWS management console, navigate to IAM  Roles   Select Create Role.   Select Web Identity and then select the CircleCI provider you created above, and under Audience, select your org ID   Use the search function to find the policy you created above by name, select it and click Next   Give your Role a name, and then scroll to the Trust policy section. Set up the Trust relationship between the Role and the CircleCI OIDC Provider. Here is an example Policy. Remember to replace the placeholders <CIRCLECI-ORG-ID> and <CIRCLECI-PROJECT-ID> with your values.   {
	"Version": "2012-10-17",
	"Statement": [
        {
            "Effect": "Allow",
            "Principal": {
                "Federated": "arn:aws:iam::<AWS-ACCOUNT-ID>:oidc-provider/oidc.circleci.com/org/<CIRCLECI-ORG-ID>"
            },
            "Action": "sts:AssumeRoleWithWebIdentity",
            "Condition": {
                "StringLike": {
                    "oidc.circleci.com/org/<CIRCLECI-ORG-ID>:sub": "org/<CIRCLECI-ORG-ID>/project/<CIRCLECI-PROJECT-ID>/user/*"
                }
            }
        },
        {
			"Effect": "Allow",
			"Principal": {
				"Service": "sagemaker.amazonaws.com"
			},
			"Action": "sts:AssumeRole"
		}

    ]
}     Select Create Role.   Select your role from the list and copy the Role ARN, you will need this in the next section.             3. Set environment variables   The CircleCI Amazon SageMaker orb requires some environment variables to function. You can store these environment variables at the project level, or you can store them using a  context. The following steps show how to add the environment variables at the project level. You need to add two environment variables, as follows:     CCI_RELEASE_INTEGRATION_TOKEN: The orb connects your deployment to SageMaker with  CircleCI deploys. This gives you visibility into the Endpoint Configuration Updates, and what is currently active.   SAGEMAKER_EXECUTION_ROLE_ARN: This is the AWS IAM Role you configured with the necessary SageMaker permissions, and the OIDC Trust relationship.        Follow these steps to add the environment variables:     In the  CircleCI web app, select your org from the org cards on your user homepage.   Select Projects from the sidebar and locate your project from the list. You can use the search to help.   Select the ellipsis () next to your project and select Project Settings.       In the sidebar menu, select Environment Variables.   Select Add Environment Variable button to enter a name and value of the new environment variable.        Repeat step four for the second environment variable       4. Set up your CircleCI configuration   Take a look at the .circleci/config.yml for the  sample project. In the block of pipeline parameters at the top, you need to update the defaults with your values.    parameters:
  bucket:
    type: string
    default: circleci-sagemaker-pipeline
  model_desc:
    type: string
    default: "Kitten Classifier allowing us to distinguish between giraffes and kittens."
  model_name:
    type: string
    default: kitten-classifier
  project_id:
    type: string
    default: "e47ee9b0-446f-44cf-bec8-5407ceb06930"
  region_name:
    type: string
    default: us-east-1    Make the following updates:  ParameterDefaultbucketThe bucket you set up in the Role Policymodel_descA description of your modelmodel_nameThe name of the modelproject_idThe CircleCI project ID, you can find this on the Project Settings page in the CircleCI web appregion_nameThe region, for example, us-east-1    5. Build a model package version   The sample app used in this how-to guide uses a model commonly found in AWS documentation, Abalone. It has just been renamed. If you already have your own model, feel free to adapt the configuration file to use that one instead. All you will need to do is update the model_name parameter.   Assuming you are using our example repository, follow these steps to build a new model package version:     A workflow (model-train) is configured to run on the branch model-train. Checkout the model-train branch, and push it up to GitHub   The model-train workflow will make a new model package version in the model registry. If the model package doesn’t already exist, it will create it.     Every time you run this workflow by pushing to the model-train branch, anew model version is created.     6. Use the orb   Let’s break down the deploy-model-through-to-prod workflow. Our first job is aws-sagemaker/create_model. This job creates a model from your latest Model Package in the registry. This will be what we then deploy to the inference endpoints. In general, create-model just needs to be called one time at the beginning of your workflow:          - aws-sagemaker/create_model:
          # job name that will show in Workflow DAG
          name: create-model
          # s3 bucket where asset will be stored
          bucket: << pipeline.parameters.bucket >>
          # Name of the model in SageMaker that we will be deploying.
          model_name: << pipeline.parameters.model_name >>
          # We use the pipeline.id as the unique identifier for some of the configs we create
          circle_pipeline_id: << pipeline.id >>
          # Region where we are deploying to
          region_name: << pipeline.parameters.region_name >>
          filters: *main-branch-only      Aside from name and filters, all other parameters are passed in from our pipeline parameters.   name controls the name of this job visible in the Workflow graph in the CircleCI web app.   filters allows you to control what branch the job runs on.     Next, we need to create the endpoint configuration, this happens in the job aws-sagemaker/create_endpoint_configuration:          - aws-sagemaker/create_endpoint_configuration:
          name: dev:create-model-endpoint-config
          bucket: << pipeline.parameters.bucket >>
          model_name: << pipeline.parameters.model_name >>
          circle_pipeline_id: << pipeline.id >>
          circle_project_id: << pipeline.parameters.project_id >>
          region_name: << pipeline.parameters.region_name >>
          requires:
              - create-model
          filters: *main-branch-only      deploy_environment is an arbitrary string you can use to bucket your model releases, for example, dev, staging, testing, prod. In our example config, you can see we are only using two, dev and prod.     Next, we need to push out the updated configuration, this happens in the job aws-sagemaker/deploy_endpoint:          - aws-sagemaker/deploy_endpoint:
          name: dev:deploy-model-to-endpoint
          bucket: << pipeline.parameters.bucket >>
          model_name: << pipeline.parameters.model_name >>
          # Description for the model. q: can we make it optional?
          circle_pipeline_id: << pipeline.id >>
          circle_project_id: << pipeline.parameters.project_id >>
          model_desc: << pipeline.parameters.model_desc >>
          # You can find this value in the Project Settings in CircleCI
          region_name: << pipeline.parameters.region_name >>
          requires:
              - dev:create-model-endpoint-config
        filters: *main-branch-only      The only thing to set here is the deploy_environment so we know what endpoint_configuration to use. This will deploy your endpoint configuration.     Next, is an approval job. This stops the workflow from deploying to production until a human approves it. When this does get approval, we then repeat the above steps of aws-sagemaker/create_endpoint_configuration and aws-sagemaker/deploy_endpoint but with deploy_environment set to prod.:          - promote-model-to-prod-endpoint:
          type: approval
          requires:
            - dev:deploy-model-to-endpoint           7. Check in on your deployment   The CircleCI deploys UI offers you a single pane of glass to monitor all your deployments across environments. You can view deployment progress in real time, see what versions are currently deployed, and navigate to the SageMaker console. If you navigate to the deploys dashboard by clicking Deploys in the web app sidebar, you should now see something along the lines of the image below:        Select the component name to view details about the component, including the number of instances deployed. From this interface, you can navigate to Amazon SageMaker for live information on your endpoint.        Select the version to see the details page for the version being deployed. Clicking on a specific version lets you monitor deployment progress in real-time.        Suggest an edit to this pageMake a contribution Learn how to contributeStill need help? Ask the CircleCI community Join the research community Visit our Support site DocsTerms of UsePrivacy PolicyCookie PolicySecurity© 2025 Circle Internet Services, Inc., All Rights Reserved.\n\nThe  SageMaker orb is in open preview.       To find your organization/user ID, select Organization Settings in the CircleCI web app side bar.      Update the S3 bucket information to match your setup. Create a bucket if one does not yet exist.  {
    "Version": "2012-10-17",
    "Statement": [
        {
            "Sid": "OrbPermissions",
            "Effect": "Allow",
            "Action": [
                "sagemaker:AddTags",
                "sagemaker:CreateEndpointConfig",
                "sagemaker:CreateModel",
                "sagemaker:DescribeEndpoint",
	 	        "sagemaker:DescribeEndpointConfig",
                "sagemaker:ListEndpoints",
                "sagemaker:ListModelPackages",
                "sagemaker:ListTags",
                "sagemaker:UpdateEndpoint",
                "iam:PassRole"
            ],
            "Resource": "*"
        },
        {
            "Sid": "S3Access",
            "Effect": "Allow",
            "Action": [
                "s3:GetObject",
                "s3:ListBucket"
            ],
            "Resource": [
                "arn:aws:s3:::<BUCKET_FOR_MODEL_ASSETS>/*"
            ]
        },
        {
            "Sid": "S3AccessTrainModel",
            "Effect": "Allow",
            "Action": [
                "s3:GetObject",
                "s3:ListBucket",
                "s3:PutObject"
            ],
            "Resource": [
                "arn:aws:s3:::sagemaker-sample-files/*",
                "arn:aws:s3:::circleci-sagemaker-pipeline",
                "arn:aws:s3:::circleci-sagemaker-pipeline/*"
            ]
        },
        {
            "Sid": "SageMakerTrainModel",
            "Effect": "Allow",
            "Action": [
                "sagemaker:CreateTrainingJob",
                "sagemaker:DescribeTrainingJob",
                "logs:DescribeLogStreams",
                "sagemaker:ListModelPackageGroups",
                "sagemaker:CreateModelPackage",
                "sagemaker:UpdateModelPackage"
            ],
            "Resource": "*"
        }
    ]
}  {
	"Version": "2012-10-17",
	"Statement": [
        {
            "Effect": "Allow",
            "Principal": {
                "Federated": "arn:aws:iam::<AWS-ACCOUNT-ID>:oidc-provider/oidc.circleci.com/org/<CIRCLECI-ORG-ID>"
            },
            "Action": "sts:AssumeRoleWithWebIdentity",
            "Condition": {
                "StringLike": {
                    "oidc.circleci.com/org/<CIRCLECI-ORG-ID>:sub": "org/<CIRCLECI-ORG-ID>/project/<CIRCLECI-PROJECT-ID>/user/*"
                }
            }
        },
        {
			"Effect": "Allow",
			"Principal": {
				"Service": "sagemaker.amazonaws.com"
			},
			"Action": "sts:AssumeRole"
		}

    ]
}      parameters:
  bucket:
    type: string
    default: circleci-sagemaker-pipeline
  model_desc:
    type: string
    default: "Kitten Classifier allowing us to distinguish between giraffes and kittens."
  model_name:
    type: string
    default: kitten-classifier
  project_id:
    type: string
    default: "e47ee9b0-446f-44cf-bec8-5407ceb06930"
  region_name:
    type: string
    default: us-east-1        - aws-sagemaker/create_model:
          # job name that will show in Workflow DAG
          name: create-model
          # s3 bucket where asset will be stored
          bucket: << pipeline.parameters.bucket >>
          # Name of the model in SageMaker that we will be deploying.
          model_name: << pipeline.parameters.model_name >>
          # We use the pipeline.id as the unique identifier for some of the configs we create
          circle_pipeline_id: << pipeline.id >>
          # Region where we are deploying to
          region_name: << pipeline.parameters.region_name >>
          filters: *main-branch-only        - aws-sagemaker/create_endpoint_configuration:
          name: dev:create-model-endpoint-config
          bucket: << pipeline.parameters.bucket >>
          model_name: << pipeline.parameters.model_name >>
          circle_pipeline_id: << pipeline.id >>
          circle_project_id: << pipeline.parameters.project_id >>
          region_name: << pipeline.parameters.region_name >>
          requires:
              - create-model
          filters: *main-branch-only        - aws-sagemaker/deploy_endpoint:
          name: dev:deploy-model-to-endpoint
          bucket: << pipeline.parameters.bucket >>
          model_name: << pipeline.parameters.model_name >>
          # Description for the model. q: can we make it optional?
          circle_pipeline_id: << pipeline.id >>
          circle_project_id: << pipeline.parameters.project_id >>
          model_desc: << pipeline.parameters.model_desc >>
          # You can find this value in the Project Settings in CircleCI
          region_name: << pipeline.parameters.region_name >>
          requires:
              - dev:create-model-endpoint-config
        filters: *main-branch-only        - promote-model-to-prod-endpoint:
          type: approval
          requires:
            - dev:deploy-model-to-endpoint\n\n\n\nEngineering ProductivityNov 16, 20235 min read
          
          Optimize your MLOps pipelines with inbound webhooks
          
            








  
    
      



    
  
  
    
      
        Masahiko Funaki
      
    
    
      
        Developer Advocate, CircleCI
      
    
  


            
          
        
      
      
        
        
          
            
              
              
                



              
            
          
        
        
      
    
    
      
      
        
          






  
    
Share on X
  
  
    Share on LinkedIn
  
  
    Share on Facebook
  

  
    
      Share on Reddit
    
    
      Share on Hacker News
    
  


        
        
          
            
            In a traditional DevOps implementation, you automate the build, test, release, and deploy process by setting up a CI/CD workflow that runs whenever a change is committed to a code repository. This approach is also useful in MLOps: If you make changes to your machine learning logic in your code, it can trigger your workflow. But what about changes that happen outside of your code repository?

Even if you’re using the same code, you might want to create a new model when the training data is updated. In this case, you will need to test the updated model with the existing test data. Additionally, you may want to evaluate new test data with the existing model. To automate these processes, you will need to trigger workflows based on events happening in your dataset or model registry.

In this article, I’ll demonstrate how you can use CircleCI’s inbound webhooks to trigger workflows from events outside of your code repository. As a basic example, I’ll explain how you can trigger model evaluations any time a new version of your model is published in Hugging Face.

Model testing in the CircleCI GPU environment

For demonstration purposes, let’s assume you have built an image-detection model based on Ultralytics’ YOLOv8. You’ve trained the model to detect whether individuals are wearing masks using the Roboflow Mask Wearing Image Dataset.



When the model is ready, you publish it to your Hugging Face repository.



Every time you update your model in Hugging Face, you’ll likely want to execute a comprehensive test set to gauge the model’s performance — whether it’s superior or inferior to its previous versions. To do that in an automated and easily scalable way, you can set up a CI/CD pipeline to run a testing workflow.

In our case, we want to set up a pipeline to test with a collection of image files. The pipeline will consist of a single test_model job configured to run on CircleCI’s hosted GPU resource class.

Here’s the complete config file, which we’ll be discussing below.

version: 2.1

jobs:
  test_model:
    machine:
      resource_class: gpu.nvidia.medium
      image: linux-cuda-11:default
    steps:
      - checkout
      - run:
          name: Check GPU status
          command: nvidia-smi
      - run:
          name: Set up Hugging Face CLI
          command:  pip3 install -U "huggingface_hub[cli]"
      - run:
          name: Set up a model from Hugging Face
          command: |
            cd /opt/circleci
            mkdir datasets; cd datasets
            huggingface-cli login --token $HUGGINGFACE_TOKEN
            huggingface-cli download mfunaki/cci-gpu-yolov8-maskdetection \
              mask_best.pt \
              --local-dir /opt/circleci/.pyenv/runs/detect/train/weights
      - run:
          name: Test the model
          command: |
            pip3 install ultralytics
            yolo task=detect mode=predict \
              model=/opt/circleci/.pyenv/runs/detect/train/weights/mask_best.pt \
              source=~/project/images
      - store_artifacts:
          path: /opt/circleci/.pyenv/runs/detect/predict
          destination: predict

workflows:
  mask_detection_testing:
    jobs:
      - test_model:
          context:
            - docker


Let’s break this down into individual steps. After setting up the Hugging Face CLI, our model file (mask_best.pt) is retrievable. It will then be stored under the directory /opt/circleci/.pyenv/runs/detect/train/weights to be employed by YOLOv8.

- run:
    name: Set up a model from Hugging Face
    command: |
      cd /opt/circleci
      mkdir datasets; cd datasets
      huggingface-cli login --token $HUGGINGFACE_TOKEN
      huggingface-cli download mfunaki/cci-gpu-yolov8-maskdetection \
        mask_best.pt \
        --local-dir /opt/circleci/.pyenv/runs/detect/train/weights


Subsequently, the model can be tested with image files stored in the images directory of this project’s repository.

- run:
    name: Test the model
    command: |
      pip3 install ultralytics
      yolo task=detect mode=predict \
        model=/opt/circleci/.pyenv/runs/detect/train/weights/mask_best.pt \
        source=~/project/images


The test results will be stored under the /opt/circleci/.pyenv/runs/detect/predict directory, so we will ensure these artifacts are housed in CircleCI.

- store_artifacts:
    path: /opt/circleci/.pyenv/runs/detect/predict
    destination: predict


After they’re stored, you have the option to download the detection results for each image file and review them.



Upon review, you’ll notice my face both with a white mask and without a mask were accurately detected, while my face with a black CircleCI mask was not detected.



Using webhooks to extend your MLOps automation

So far, we’ve set up a pipeline with a workflow consisting of our test_model job to evaluate model performance. Now we want to trigger our pipeline when the model is updated on Hugging Face.

Traditionally, you would need to trigger your pipeline manually, as there would be no way to detect changes to your Hugging Face repository. However, now with support for inbound webhooks in CircleCI, you can monitor and trigger pipelines from any source of change that can send a webhook or run a curl command.

To set this up for our example project, we’ll start by configuring a new webhook trigger in CircleCI. Navigate to Project Settings > Triggers and select Add Trigger. Select Inbound Webhook and fill in the details of your trigger source and trigger description.



When you complete the setup, you’ll have a webhook endpoint URL and secret you can use to set up webhook triggers from external sources.



Next you’ll need to set up the webhook on your trigger source. Navigate to the Hugging Face webhooks settings page. You will see the following fields:


  
    Target Repositories: Which Hugging Face repositories to watch for updates
  
  
    Webhook URL and Secret: The CircleCI endpoint that Hugging Face should call when your target repositories are updated
  
  
    Triggers: Which events in Hugging Face will trigger your webhook
  




Select your model repository, fill in your CircleCI webhook URL and secret, and that’s it! Now any time you deploy an update to Hugging Face, your webhook will trigger a new run of your testing workflow in CircleCI. By eliminating the need for manual pipeline triggers, you can achieve faster fastback loops and more efficient model delivery.

Conclusion

As software and software delivery practices continue to evolve, the old repo-centric model is no longer sufficient. To keep pace, your CI/CD platform should be responsive to the changes happening all throughout your software ecosystem.

With CircleCI’s support for inbound webhooks, you can trigger pipelines from anywhere, giving you better flexibility and control in managing your CI/CD pipelines. To try them out, sign up for a free account and start creating custom triggers based on the events that are most relevant to your development and deployment process.

Open preview for inbound webhooks begins on Friday, November 17, and will be available to users who authenticate via GitHub apps.

          

          
            
              
              
            
            
            
              
                
                
                
                  
                    Engineering Productivity
                  
                
              
            
            
          
        
      
      
        
          

        
      
    

    
      
        
          Similar posts you may enjoy
          

  
    

  
    
      



    
  

  
  
    
      CircleCI MCP server: Natural language CI for AI-driven workflows
    
    
      
        Apr 9, 20256 min read
      
    
  
  

  
    








  
    
      



    
  
  
    
      
        Michael Webster
      
    
    
      
        Principal Engineer
      
    
  


  

  
    

  
    
      



    
  

  
  
    
      What is penetration testing?
    
    
      
        Apr 7, 202510 min read
      
    
  
  

  
    








  
    
      



    
  
  
    
      
        Jacob Schmitt
      
    
    
      
        Senior Technical Content Marketing Manager
      
    
  


  

  
    

  
    
      



    
  

  
  
    
      How to use LLMs to generate test data (and why it matters more than ever)
    
    
      
        Apr 3, 20257 min read
      
    
  
  

  
    








  
    
      



    
  
  
    
      
        Ryan E. Hamilton
      
    
    
      
        Senior Software Engineer\n\nCancel
      
      
    
  
  
    
  


      













  
    
    

    
      
      
        
        
          
            
            
            
            
            
            Engineering ProductivityNov 16, 20235 min read
          
          Optimize your MLOps pipelines with inbound webhooks
          
            








  
    
      



    
  
  
    
      
        Masahiko Funaki
      
    
    
      
        Developer Advocate, CircleCI
      
    
  


            
          
        
      
      
        
        
          
            
              
              
                



              
            
          
        
        
      
    
    
      
      
        
          






  
    
Share on X
  
  
    Share on LinkedIn
  
  
    Share on Facebook
  

  
    
      Share on Reddit
    
    
      Share on Hacker News
    
  


        
        
          
            
            In a traditional DevOps implementation, you automate the build, test, release, and deploy process by setting up a CI/CD workflow that runs whenever a change is committed to a code repository. This approach is also useful in MLOps: If you make changes to your machine learning logic in your code, it can trigger your workflow. But what about changes that happen outside of your code repository?

Even if you’re using the same code, you might want to create a new model when the training data is updated. In this case, you will need to test the updated model with the existing test data. Additionally, you may want to evaluate new test data with the existing model. To automate these processes, you will need to trigger workflows based on events happening in your dataset or model registry.

In this article, I’ll demonstrate how you can use CircleCI’s inbound webhooks to trigger workflows from events outside of your code repository. As a basic example, I’ll explain how you can trigger model evaluations any time a new version of your model is published in Hugging Face.

Model testing in the CircleCI GPU environment

For demonstration purposes, let’s assume you have built an image-detection model based on Ultralytics’ YOLOv8. You’ve trained the model to detect whether individuals are wearing masks using the Roboflow Mask Wearing Image Dataset.



When the model is ready, you publish it to your Hugging Face repository.



Every time you update your model in Hugging Face, you’ll likely want to execute a comprehensive test set to gauge the model’s performance — whether it’s superior or inferior to its previous versions. To do that in an automated and easily scalable way, you can set up a CI/CD pipeline to run a testing workflow.

In our case, we want to set up a pipeline to test with a collection of image files. The pipeline will consist of a single test_model job configured to run on CircleCI’s hosted GPU resource class.

Here’s the complete config file, which we’ll be discussing below.

version: 2.1

jobs:
  test_model:
    machine:
      resource_class: gpu.nvidia.medium
      image: linux-cuda-11:default
    steps:
      - checkout
      - run:
          name: Check GPU status
          command: nvidia-smi
      - run:
          name: Set up Hugging Face CLI
          command:  pip3 install -U "huggingface_hub[cli]"
      - run:
          name: Set up a model from Hugging Face
          command: |
            cd /opt/circleci
            mkdir datasets; cd datasets
            huggingface-cli login --token $HUGGINGFACE_TOKEN
            huggingface-cli download mfunaki/cci-gpu-yolov8-maskdetection \
              mask_best.pt \
              --local-dir /opt/circleci/.pyenv/runs/detect/train/weights
      - run:
          name: Test the model
          command: |
            pip3 install ultralytics
            yolo task=detect mode=predict \
              model=/opt/circleci/.pyenv/runs/detect/train/weights/mask_best.pt \
              source=~/project/images
      - store_artifacts:
          path: /opt/circleci/.pyenv/runs/detect/predict
          destination: predict

workflows:
  mask_detection_testing:
    jobs:
      - test_model:
          context:
            - docker


Let’s break this down into individual steps. After setting up the Hugging Face CLI, our model file (mask_best.pt) is retrievable. It will then be stored under the directory /opt/circleci/.pyenv/runs/detect/train/weights to be employed by YOLOv8.

- run:
    name: Set up a model from Hugging Face
    command: |
      cd /opt/circleci
      mkdir datasets; cd datasets
      huggingface-cli login --token $HUGGINGFACE_TOKEN
      huggingface-cli download mfunaki/cci-gpu-yolov8-maskdetection \
        mask_best.pt \
        --local-dir /opt/circleci/.pyenv/runs/detect/train/weights


Subsequently, the model can be tested with image files stored in the images directory of this project’s repository.

- run:
    name: Test the model
    command: |
      pip3 install ultralytics
      yolo task=detect mode=predict \
        model=/opt/circleci/.pyenv/runs/detect/train/weights/mask_best.pt \
        source=~/project/images


The test results will be stored under the /opt/circleci/.pyenv/runs/detect/predict directory, so we will ensure these artifacts are housed in CircleCI.

- store_artifacts:
    path: /opt/circleci/.pyenv/runs/detect/predict
    destination: predict


After they’re stored, you have the option to download the detection results for each image file and review them.



Upon review, you’ll notice my face both with a white mask and without a mask were accurately detected, while my face with a black CircleCI mask was not detected.



Using webhooks to extend your MLOps automation

So far, we’ve set up a pipeline with a workflow consisting of our test_model job to evaluate model performance. Now we want to trigger our pipeline when the model is updated on Hugging Face.

Traditionally, you would need to trigger your pipeline manually, as there would be no way to detect changes to your Hugging Face repository. However, now with support for inbound webhooks in CircleCI, you can monitor and trigger pipelines from any source of change that can send a webhook or run a curl command.

To set this up for our example project, we’ll start by configuring a new webhook trigger in CircleCI. Navigate to Project Settings > Triggers and select Add Trigger. Select Inbound Webhook and fill in the details of your trigger source and trigger description.



When you complete the setup, you’ll have a webhook endpoint URL and secret you can use to set up webhook triggers from external sources.



Next you’ll need to set up the webhook on your trigger source. Navigate to the Hugging Face webhooks settings page. You will see the following fields:


  
    Target Repositories: Which Hugging Face repositories to watch for updates
  
  
    Webhook URL and Secret: The CircleCI endpoint that Hugging Face should call when your target repositories are updated
  
  
    Triggers: Which events in Hugging Face will trigger your webhook
  




Select your model repository, fill in your CircleCI webhook URL and secret, and that’s it! Now any time you deploy an update to Hugging Face, your webhook will trigger a new run of your testing workflow in CircleCI. By eliminating the need for manual pipeline triggers, you can achieve faster fastback loops and more efficient model delivery.

Conclusion

As software and software delivery practices continue to evolve, the old repo-centric model is no longer sufficient. To keep pace, your CI/CD platform should be responsive to the changes happening all throughout your software ecosystem.

With CircleCI’s support for inbound webhooks, you can trigger pipelines from anywhere, giving you better flexibility and control in managing your CI/CD pipelines. To try them out, sign up for a free account and start creating custom triggers based on the events that are most relevant to your development and deployment process.

Open preview for inbound webhooks begins on Friday, November 17, and will be available to users who authenticate via GitHub apps.

          

          
            
              
              
            
            
            
              
                
                
                
                  
                    Engineering Productivity
                  
                
              
            
            
          
        
      
      
        
          

        
      
    

    
      
        
          Similar posts you may enjoy
          

  
    

  
    
      



    
  

  
  
    
      CircleCI MCP server: Natural language CI for AI-driven workflows
    
    
      
        Apr 9, 20256 min read
      
    
  
  

  
    








  
    
      



    
  
  
    
      
        Michael Webster
      
    
    
      
        Principal Engineer
      
    
  


  

  
    

  
    
      



    
  

  
  
    
      What is penetration testing?
    
    
      
        Apr 7, 202510 min read
      
    
  
  

  
    








  
    
      



    
  
  
    
      
        Jacob Schmitt
      
    
    
      
        Senior Technical Content Marketing Manager
      
    
  


  

  
    

  
    
      



    
  

  
  
    
      How to use LLMs to generate test data (and why it matters more than ever)
    
    
      
        Apr 3, 20257 min read
      
    
  
  

  
    








  
    
      



    
  
  
    
      
        Ryan E. Hamilton
      
    
    
      
        Senior Software Engineer
      
    
  


  

  


        
      
    
  



  
    

    Copy to clipboard
  




  


  
    close
  
  
    
  



      




  
    
      
        
        CircleCI
      
    
    
      
        © 2025 Circle Internet Services, Inc.
        
          
            Terms of Use
          
            Privacy Policy
          
            Cookie Policy
          
        
      
      
  
    
    RSS
  
  
    
    LinkedIn
  
  
    
    GitHub
  
  
    

    X
  
  
    
    Twitch\n\nCancel
      
      
    
  
  
    
  


      













  
    
    

    
      
      
        
        
          
            
            
            
            
            
            Engineering ProductivityNov 16, 20235 min read
          
          Optimize your MLOps pipelines with inbound webhooks
          
            








  
    
      



    
  
  
    
      
        Masahiko Funaki
      
    
    
      
        Developer Advocate, CircleCI
      
    
  


            
          
        
      
      
        
        
          
            
              
              
                



              
            
          
        
        
      
    
    
      
      
        
          






  
    
Share on X
  
  
    Share on LinkedIn
  
  
    Share on Facebook
  

  
    
      Share on Reddit
    
    
      Share on Hacker News
    
  


        
        
          
            
            In a traditional DevOps implementation, you automate the build, test, release, and deploy process by setting up a CI/CD workflow that runs whenever a change is committed to a code repository. This approach is also useful in MLOps: If you make changes to your machine learning logic in your code, it can trigger your workflow. But what about changes that happen outside of your code repository?

Even if you’re using the same code, you might want to create a new model when the training data is updated. In this case, you will need to test the updated model with the existing test data. Additionally, you may want to evaluate new test data with the existing model. To automate these processes, you will need to trigger workflows based on events happening in your dataset or model registry.

In this article, I’ll demonstrate how you can use CircleCI’s inbound webhooks to trigger workflows from events outside of your code repository. As a basic example, I’ll explain how you can trigger model evaluations any time a new version of your model is published in Hugging Face.

Model testing in the CircleCI GPU environment

For demonstration purposes, let’s assume you have built an image-detection model based on Ultralytics’ YOLOv8. You’ve trained the model to detect whether individuals are wearing masks using the Roboflow Mask Wearing Image Dataset.



When the model is ready, you publish it to your Hugging Face repository.



Every time you update your model in Hugging Face, you’ll likely want to execute a comprehensive test set to gauge the model’s performance — whether it’s superior or inferior to its previous versions. To do that in an automated and easily scalable way, you can set up a CI/CD pipeline to run a testing workflow.

In our case, we want to set up a pipeline to test with a collection of image files. The pipeline will consist of a single test_model job configured to run on CircleCI’s hosted GPU resource class.

Here’s the complete config file, which we’ll be discussing below.

version: 2.1

jobs:
  test_model:
    machine:
      resource_class: gpu.nvidia.medium
      image: linux-cuda-11:default
    steps:
      - checkout
      - run:
          name: Check GPU status
          command: nvidia-smi
      - run:
          name: Set up Hugging Face CLI
          command:  pip3 install -U "huggingface_hub[cli]"
      - run:
          name: Set up a model from Hugging Face
          command: |
            cd /opt/circleci
            mkdir datasets; cd datasets
            huggingface-cli login --token $HUGGINGFACE_TOKEN
            huggingface-cli download mfunaki/cci-gpu-yolov8-maskdetection \
              mask_best.pt \
              --local-dir /opt/circleci/.pyenv/runs/detect/train/weights
      - run:
          name: Test the model
          command: |
            pip3 install ultralytics
            yolo task=detect mode=predict \
              model=/opt/circleci/.pyenv/runs/detect/train/weights/mask_best.pt \
              source=~/project/images
      - store_artifacts:
          path: /opt/circleci/.pyenv/runs/detect/predict
          destination: predict

workflows:
  mask_detection_testing:
    jobs:
      - test_model:
          context:
            - docker


Let’s break this down into individual steps. After setting up the Hugging Face CLI, our model file (mask_best.pt) is retrievable. It will then be stored under the directory /opt/circleci/.pyenv/runs/detect/train/weights to be employed by YOLOv8.

- run:
    name: Set up a model from Hugging Face
    command: |
      cd /opt/circleci
      mkdir datasets; cd datasets
      huggingface-cli login --token $HUGGINGFACE_TOKEN
      huggingface-cli download mfunaki/cci-gpu-yolov8-maskdetection \
        mask_best.pt \
        --local-dir /opt/circleci/.pyenv/runs/detect/train/weights


Subsequently, the model can be tested with image files stored in the images directory of this project’s repository.

- run:
    name: Test the model
    command: |
      pip3 install ultralytics
      yolo task=detect mode=predict \
        model=/opt/circleci/.pyenv/runs/detect/train/weights/mask_best.pt \
        source=~/project/images


The test results will be stored under the /opt/circleci/.pyenv/runs/detect/predict directory, so we will ensure these artifacts are housed in CircleCI.

- store_artifacts:
    path: /opt/circleci/.pyenv/runs/detect/predict
    destination: predict


After they’re stored, you have the option to download the detection results for each image file and review them.



Upon review, you’ll notice my face both with a white mask and without a mask were accurately detected, while my face with a black CircleCI mask was not detected.



Using webhooks to extend your MLOps automation

So far, we’ve set up a pipeline with a workflow consisting of our test_model job to evaluate model performance. Now we want to trigger our pipeline when the model is updated on Hugging Face.

Traditionally, you would need to trigger your pipeline manually, as there would be no way to detect changes to your Hugging Face repository. However, now with support for inbound webhooks in CircleCI, you can monitor and trigger pipelines from any source of change that can send a webhook or run a curl command.

To set this up for our example project, we’ll start by configuring a new webhook trigger in CircleCI. Navigate to Project Settings > Triggers and select Add Trigger. Select Inbound Webhook and fill in the details of your trigger source and trigger description.



When you complete the setup, you’ll have a webhook endpoint URL and secret you can use to set up webhook triggers from external sources.



Next you’ll need to set up the webhook on your trigger source. Navigate to the Hugging Face webhooks settings page. You will see the following fields:


  
    Target Repositories: Which Hugging Face repositories to watch for updates
  
  
    Webhook URL and Secret: The CircleCI endpoint that Hugging Face should call when your target repositories are updated
  
  
    Triggers: Which events in Hugging Face will trigger your webhook
  




Select your model repository, fill in your CircleCI webhook URL and secret, and that’s it! Now any time you deploy an update to Hugging Face, your webhook will trigger a new run of your testing workflow in CircleCI. By eliminating the need for manual pipeline triggers, you can achieve faster fastback loops and more efficient model delivery.

Conclusion

As software and software delivery practices continue to evolve, the old repo-centric model is no longer sufficient. To keep pace, your CI/CD platform should be responsive to the changes happening all throughout your software ecosystem.

With CircleCI’s support for inbound webhooks, you can trigger pipelines from anywhere, giving you better flexibility and control in managing your CI/CD pipelines. To try them out, sign up for a free account and start creating custom triggers based on the events that are most relevant to your development and deployment process.

Open preview for inbound webhooks begins on Friday, November 17, and will be available to users who authenticate via GitHub apps.

          

          
            
              
              
            
            
            
              
                
                
                
                  
                    Engineering Productivity
                  
                
              
            
            
          
        
      
      
        
          

        
      
    

    
      
        
          Similar posts you may enjoy
          

  
    

  
    
      



    
  

  
  
    
      CircleCI MCP server: Natural language CI for AI-driven workflows
    
    
      
        Apr 9, 20256 min read
      
    
  
  

  
    








  
    
      



    
  
  
    
      
        Michael Webster
      
    
    
      
        Principal Engineer
      
    
  


  

  
    

  
    
      



    
  

  
  
    
      What is penetration testing?
    
    
      
        Apr 7, 202510 min read
      
    
  
  

  
    








  
    
      



    
  
  
    
      
        Jacob Schmitt
      
    
    
      
        Senior Technical Content Marketing Manager
      
    
  


  

  
    

  
    
      



    
  

  
  
    
      How to use LLMs to generate test data (and why it matters more than ever)
    
    
      
        Apr 3, 20257 min read
      
    
  
  

  
    








  
    
      



    
  
  
    
      
        Ryan E. Hamilton
      
    
    
      
        Senior Software Engineer
      
    
  


  

  


        
      
    
  



  
    

    Copy to clipboard
  




  


  
    close
  
  
    
  



      




  
    
      
        
        CircleCI
      
    
    
      
        © 2025 Circle Internet Services, Inc.
        
          
            Terms of Use
          
            Privacy Policy
          
            Cookie Policy
          
        
      
      
  
    
    RSS
  
  
    
    LinkedIn
  
  
    
    GitHub
  
  
    

    X
  
  
    
    Twitch\n\n\n\nTutorialsNov 14, 202310 min read
          
          Deploy and re-evaluate LLM-powered apps with LangSmith and CircleCI
          
            








  
    
      



    
  
  
    
      
        
          Jacob Schmitt
        
      
    
    
      
        Senior Technical Content Marketing Manager
      
    
  


            
          
        
      
      
        
        
          
            
              
              
                



              
            
          
        
        
      
    
    
      
      
        
          






  
    
Share on X
  
  
    Share on LinkedIn
  
  
    Share on Facebook
  

  
    
      Share on Reddit
    
    
      Share on Hacker News
    
  


        
        
          
            
            In part 1 of this tutorial, we showed you how to build a large language model (LLM) application that uses retrieval-augmented generation (RAG) to query your own documentation and then test it using a CircleCI continuous integration (CI) pipeline.

In this follow-up tutorial, we’ll show you how to build the continuous delivery (CD) portion of the pipeline to help bring your LLM-powered apps safely into production. The pipeline will run a scheduled set of nightly evaluations on your LLM application, wait for a human to review the results of your automated evaluations, and then deploy the application to your production environment. This way, you can ship regular updates to your application, with deeper visibility into model performance and better responsiveness to user needs.


  Sample code: You can follow along with this tutorial by forking the example repository and cloning it to your local machine using Git.


What we’re building: an LLM deployment platform

The first part of this tutorial demonstrated how to build an application that answers questions about LangSmith’s documentation. This application relies on OpenAI large language model APIs managed with wrappers from LangChain, a popular open-source framework for building language model-powered applications.

The tutorial also covered how to implement a unit-testing suite with deterministic tests to confirm that the model was nominally functional by asking its name and having it perform basic arithmetic. It also contained nondeterministic unit tests implemented with LLM evaluators (separate LLMs that assess and score generated content for qualities like relevance, coherency, and adherence to guidelines).

To build on this functionality, we’ll show you how to build a simple continuous delivery pipeline to perform extensive nightly integration tests on the main branch and deploy the application to production.



However, to keep this tutorial focused on the practical aspects of CI/CD, there are some simplifications and assumptions:


  The CI test suite from part 1 is re-used for this CD test suite: Generally, a CD test suite should be more robust than just unit tests. However, we’re using the same tests in this tutorial so we can focus on implementing the pipeline.
  The LLM application is minimal, for demonstration purposes: The example application only accepts POST requests with inputs to the language model in JSON format and returns the output from the language model.
  The CircleCI pipeline will run on a self-hosted runner: We’ll keep things simple here by deploying the application as a Python Flask server to a self-hosted runner through CircleCI and then interacting with that server through curl commands.


Creating the CircleCI deployment pipeline

These steps use the same example repository and configuration file as part 1 of this tutorial. To successfully run your pipeline, you will need to uncomment the run-nightly-tests and deploy jobs along with the deployment-tests workflow in the provided .circleci/config.yml file.

The example LLM deployment method is adapted from the LangChain documentation.

Running the Python Flask application locally

If you’re not following from part 1, you should check the prerequisites listed there and follow the included steps to create the required .env file. You can then spin up the server locally with the following commands:

source ./tools/install-venv.sh  # install and enter the Python virtual env
flask --app rag/app run &       # spin up the Flask server


Note: The & will instantiate the server as a background process. To stop the server, you will need to bring the process back to the foreground with the Linux fg command and then press Ctrl+C. As another option, you could open two separate terminals: one for spinning up the server and one for issuing commands.

Once the server has spun up successfully, you should see something like this:



Take note of the port that the Flask server is listening to. In this case, the server is on localhost with port 5000. After the server is spun up, you should be able to interact with it by sending curl commands to the host and port using the following template:

curl -X POST -H "Content-Type: application/json" -d '{"message": "What is LangSmith?"}' http://localhost:5000


Note: Be sure to adjust the port number to the port number that your Flask server is listening to.

The server should send the input to the documentation_chain object and then return the answer in JSON format.



You can adjust the message field in the JSON request to ask the LLM different questions. For a production environment, you would most likely build on this with a web-based graphical interface to make it more user-friendly.

Building the test suite

To keep this tutorial focused on the CI/CD aspect of LLMOps, you can just reuse the unit tests introduced in the first part of this tutorial. In production scenarios, though, you will want to define your own tests for your use case, as every ML deployment is highly specialized.


  
    
      Test name
      Test type
      What it does
    
  
  
    
      test_name
      deterministic
      Asks the LLM what its name is and checks that the string bob appears in the answer.
    
    
      test_basic_arithmetic
      deterministic
      Asks the LLM what 5 + 7 is and checks that the string 12 appears in the answer
    
    
      test_llm_evaluators
      non-deterministic
      Asks the LLM questions in the example list of tuples, then uses an LLM evaluator available in LangSmith to judge whether the actual output was close enough to the desired output
    
  


Setting up the CircleCI deployment pipeline

Following from the previous tutorial, you will already have set up a CircleCI account, forked the example repository, and added it as a CircleCI project with the included .circleci/config.yml configuration file.

Defining workflows

In the .circleci/config.yml file, there is a workflow called deployment-tests that consists of three jobs: run-nightly-tests, hold, and deploy. This workflow has been commented out to avoid confusion in the first part of this tutorial. To use this workflow in your pipeline, make sure you first remove the comments.

Note that the config file is supplying the run-nightly-tests and deploy jobs with the same rag-context context that it supplied to the run-unit-tests job in part 1 of this tutorial.

To run the multiple jobs contained in one workflow in series rather than parallel, supply the requires flag so that each job will wait for the previous one to succeed before executing. If certain jobs can be done in parallel, then these flags can be omitted.

Rather than being triggered whenever the main branch is updated, this workflow is executed on a schedule, defined in cron syntax.

 deployment-tests:
    # Trigger on a schedule or when retrain branch is updated
    triggers:
      - schedule:
          cron: "0 0 * * *" # Daily at midnight
          filters:
            branches:
              only:
                - main
    jobs:
      - run-nightly-tests:
          context: rag-context  # This contains environment variables
      - hold: # A job that will require manual approval in the CircleCI web application.
          requires:
            - run-nightly-tests
          type: approval # This key-value pair will set your workflow to a status of "On Hold"
      - deploy:
          context: rag-context  # This contains environment variables
          requires:
            - hold


Note: If you authorized your CircleCI account via our GitHub App,  the scheduled workflows functionality is not currently supported for your account type. This feature is on our roadmap for a future release. In the meantime, your test suite will still trigger when a change is made to your main branch.

Adding jobs

The run-nightly-tests job is identical to the run-unit-tests job from the previous tutorial as we are using the same test suite for simplicity. You will need to remove the comments in the config file for this job to run.

 run-nightly-tests:
    machine: # executor type
      # for a full list of Linux VM execution environments, see
      # https://circleci.com/developer/images?imageType=machine
      image: ubuntu-2204:2023.07.2
    steps:
      - checkout  	# Check out the code in the project directory
      - install-venv
      - check-python  # Invoke command "check-python" after entering venv
      - run:
        command: source ./venv/bin/activate && pytest -s
        name: Run nightly tests


To start experimenting with your own tests, copy the example rag/test_rag.py file to a new file named rag/nightly_tests.py and tweak the existing tests or add your own. Then change the pytest command above to the command shown below:

source ./venv/bin/activate && pytest -s -k rag/nightly_tests.py


The hold job does not need to be defined — it’s a built-in job that is available in every CircleCI workflow. This job pauses the workflow after a certain job has been run and requires manual approval before continuing. This is especially useful when deploying LLM-powered applications because many language model tests are non-deterministic and will often need to be reviewed by a human.

Being able to automate the majority of an LLM workflow, only pausing for the specific tasks that require human approval, greatly speeds up LLM training, testing, and deployment workflows while ensuring the accuracy and quality of results. After the nightly tests have run and the LangSmith output has been verified, the pipeline will continue to the deployment phase. This keeps important decisions in human hands while automating all the steps prior to and after this decision.

The deploy job spins up a Python Flask server. This job uses a self-hosted machine runner rather than one of CircleCI’s cloud-hosted execution environments. This grants you full control over the execution environment, which can be useful in applications that require access to on-site compute assets or confidential data. Be sure to remove the comments from this job to run it in your pipeline.

  deploy:
    # For running on CircleCI's self-hosted runners
    machine: true
    resource_class: user/sample-project # TODO replace “user/sample-project” with your own self-hosted runner resource class details
    steps:
      - checkout
      - install-venv
      - check-python  # Invoke command "check-python" after entering venv
      - run:
        command: timeout --preserve-status --foreground 90 bash -c "source ./venv/bin/activate ; flask --app rag/app run" || true  # Run the server for 90 seconds to test
        name: Deploy application on self-hosted runner


It only takes five minutes to set up a self-hosted runner in CircleCI. To use this runner in a job, add its resource_class information to the .circleci/config.yml file. You should deploy this self-hosted runner to a system that you can log into, so that you can access your Flask server from localhost.

This is just to illustrate the simplest version of the workflow. In a production environment, you would likely want to deploy either to your own web infrastructure or to a hosted cloud service like Google Cloud Run or AWS ECS.

Putting it all together - a complete CI/CD pipeline for LangChain LLMs

This workflow will be run on the cron schedule defined in your workflow trigger. When the workflow has reached the hold job, it will pause awaiting approval. From here, you can look at the link in the logs to the LangSmith non-deterministic results and decide if the responses from the model were good enough to deploy the application.



Once approved, the workflow will continue and deploy the application to your production environment (in this case, the self-hosted machine runner).



After the deploy job runs, your Flask server will continue running as a long-lived process on your self-hosted runner. You can then interact with the deployed application using the curl command shown earlier.

curl -X POST -H "Content-Type: application/json" -d '{"message": "What is LangSmith?"}' http://localhost:5000




For demonstration purposes (and so you don’t have to set up a deployment server just to run this example), the Flask server will be launched on the machine runner, then the job will complete after 90 seconds so the workflow completes successfully. This way, you have enough time to issue the curl commands from before to confirm it is working properly.



Re-evaluating your LLM models

At this point, you’ve learned how to add a CI/CD workflow to your LLM-powered application development cycle. You can automatically build, test, evaluate, and deploy LLM-powered applications with every change to your application code or model prompts, shortening your development cycles for LLM-powered applications.

However, it’s important to remember that the behavior of AI models is far less predictable than that of traditional software and can evolve over time. Therefore, it’s impossible to have perfect test coverage even if you verify the outputs of many, many prompts to the model. It is almost a guarantee that your real-world users will prompt the model in a way that you don’t expect and get results that you don’t expect. To have a more stable and useful application, you want to minimize surprises like this.

This is why it’s a good idea to monitor how your users interact with your application under real-world conditions and bring those prompts and responses into your test suite. It’s not reasonable to do this for every prompt, but allowing LangSmith to store prompt data based on a random sample of users can be very enlightening.

You can do this by selectively instantiating the LangSmith client in your production application, as shown at the top of each unit test in rag/rag_test.py.

# Instantiate LangSmith client
client = Client()


Automate building, training, and evaluating LLM applications with CircleCI

LLM-powered applications are an exciting new frontier in software development, allowing you to provide more personalized, engaging, and user-centric experiences. But bringing these applications into production can be difficult and time consuming, often requiring extensive manual intervention.

By integrating LLM evaluations into your CI/CD pipeline, you not only save time and resources but also mitigate the inherent risks associated with manual evaluations and deployments.

To get started building your automated LLM evaluation and deployment pipeline, sign up for a free CircleCI account and take advantage of up to 6000 build minutes per month.

          

          
            
              
              
            
            
            
              
                
                
                
                  
                    Tutorials
                  
                
              
            
            
          
        
      
      
        
          

        
      
    

    
      
        
          Similar posts you may enjoy
          

  
    

  
    
      



    
  

  
  
    
      Build and evaluate LLM-powered apps with LangChain and CircleCI
    
    
      
        Nov 7, 202314 min read
      
    
  
  

  
    








  
    
      



    
  
  
    
      
        Jacob Schmitt
      
    
    
      
        Senior Technical Content Marketing Manager
      
    
  


  

  
    

  
    
      



    
  

  
  
    
      CI for machine learning: Build, test, train
    
    
      
        Jul 28, 202317 min read
      
    
  
  

  
    








  
    
      



    
  
  
    
      
        Jacob Schmitt
      
    
    
      
        Senior Technical Content Marketing Manager
      
    
  


  

  
    

  
    
      



    
  

  
  
    
      CD for machine learning: Deploy, monitor, retrain
    
    
      
        Aug 2, 202312 min read
      
    
  
  

  
    








  
    
      



    
  
  
    
      
        Jacob Schmitt
      
    
    
      
        Senior Technical Content Marketing Manager\n\nCancel
      
      
    
  
  
    
  


      













  
    
    

    
      
      
        
        
          
            
            
            
            
            
            TutorialsNov 14, 202310 min read
          
          Deploy and re-evaluate LLM-powered apps with LangSmith and CircleCI
          
            








  
    
      



    
  
  
    
      
        
          Jacob Schmitt
        
      
    
    
      
        Senior Technical Content Marketing Manager
      
    
  


            
          
        
      
      
        
        
          
            
              
              
                



              
            
          
        
        
      
    
    
      
      
        
          






  
    
Share on X
  
  
    Share on LinkedIn
  
  
    Share on Facebook
  

  
    
      Share on Reddit
    
    
      Share on Hacker News
    
  


        
        
          
            
            In part 1 of this tutorial, we showed you how to build a large language model (LLM) application that uses retrieval-augmented generation (RAG) to query your own documentation and then test it using a CircleCI continuous integration (CI) pipeline.

In this follow-up tutorial, we’ll show you how to build the continuous delivery (CD) portion of the pipeline to help bring your LLM-powered apps safely into production. The pipeline will run a scheduled set of nightly evaluations on your LLM application, wait for a human to review the results of your automated evaluations, and then deploy the application to your production environment. This way, you can ship regular updates to your application, with deeper visibility into model performance and better responsiveness to user needs.


  Sample code: You can follow along with this tutorial by forking the example repository and cloning it to your local machine using Git.


What we’re building: an LLM deployment platform

The first part of this tutorial demonstrated how to build an application that answers questions about LangSmith’s documentation. This application relies on OpenAI large language model APIs managed with wrappers from LangChain, a popular open-source framework for building language model-powered applications.

The tutorial also covered how to implement a unit-testing suite with deterministic tests to confirm that the model was nominally functional by asking its name and having it perform basic arithmetic. It also contained nondeterministic unit tests implemented with LLM evaluators (separate LLMs that assess and score generated content for qualities like relevance, coherency, and adherence to guidelines).

To build on this functionality, we’ll show you how to build a simple continuous delivery pipeline to perform extensive nightly integration tests on the main branch and deploy the application to production.



However, to keep this tutorial focused on the practical aspects of CI/CD, there are some simplifications and assumptions:


  The CI test suite from part 1 is re-used for this CD test suite: Generally, a CD test suite should be more robust than just unit tests. However, we’re using the same tests in this tutorial so we can focus on implementing the pipeline.
  The LLM application is minimal, for demonstration purposes: The example application only accepts POST requests with inputs to the language model in JSON format and returns the output from the language model.
  The CircleCI pipeline will run on a self-hosted runner: We’ll keep things simple here by deploying the application as a Python Flask server to a self-hosted runner through CircleCI and then interacting with that server through curl commands.


Creating the CircleCI deployment pipeline

These steps use the same example repository and configuration file as part 1 of this tutorial. To successfully run your pipeline, you will need to uncomment the run-nightly-tests and deploy jobs along with the deployment-tests workflow in the provided .circleci/config.yml file.

The example LLM deployment method is adapted from the LangChain documentation.

Running the Python Flask application locally

If you’re not following from part 1, you should check the prerequisites listed there and follow the included steps to create the required .env file. You can then spin up the server locally with the following commands:

source ./tools/install-venv.sh  # install and enter the Python virtual env
flask --app rag/app run &       # spin up the Flask server


Note: The & will instantiate the server as a background process. To stop the server, you will need to bring the process back to the foreground with the Linux fg command and then press Ctrl+C. As another option, you could open two separate terminals: one for spinning up the server and one for issuing commands.

Once the server has spun up successfully, you should see something like this:



Take note of the port that the Flask server is listening to. In this case, the server is on localhost with port 5000. After the server is spun up, you should be able to interact with it by sending curl commands to the host and port using the following template:

curl -X POST -H "Content-Type: application/json" -d '{"message": "What is LangSmith?"}' http://localhost:5000


Note: Be sure to adjust the port number to the port number that your Flask server is listening to.

The server should send the input to the documentation_chain object and then return the answer in JSON format.



You can adjust the message field in the JSON request to ask the LLM different questions. For a production environment, you would most likely build on this with a web-based graphical interface to make it more user-friendly.

Building the test suite

To keep this tutorial focused on the CI/CD aspect of LLMOps, you can just reuse the unit tests introduced in the first part of this tutorial. In production scenarios, though, you will want to define your own tests for your use case, as every ML deployment is highly specialized.


  
    
      Test name
      Test type
      What it does
    
  
  
    
      test_name
      deterministic
      Asks the LLM what its name is and checks that the string bob appears in the answer.
    
    
      test_basic_arithmetic
      deterministic
      Asks the LLM what 5 + 7 is and checks that the string 12 appears in the answer
    
    
      test_llm_evaluators
      non-deterministic
      Asks the LLM questions in the example list of tuples, then uses an LLM evaluator available in LangSmith to judge whether the actual output was close enough to the desired output
    
  


Setting up the CircleCI deployment pipeline

Following from the previous tutorial, you will already have set up a CircleCI account, forked the example repository, and added it as a CircleCI project with the included .circleci/config.yml configuration file.

Defining workflows

In the .circleci/config.yml file, there is a workflow called deployment-tests that consists of three jobs: run-nightly-tests, hold, and deploy. This workflow has been commented out to avoid confusion in the first part of this tutorial. To use this workflow in your pipeline, make sure you first remove the comments.

Note that the config file is supplying the run-nightly-tests and deploy jobs with the same rag-context context that it supplied to the run-unit-tests job in part 1 of this tutorial.

To run the multiple jobs contained in one workflow in series rather than parallel, supply the requires flag so that each job will wait for the previous one to succeed before executing. If certain jobs can be done in parallel, then these flags can be omitted.

Rather than being triggered whenever the main branch is updated, this workflow is executed on a schedule, defined in cron syntax.

 deployment-tests:
    # Trigger on a schedule or when retrain branch is updated
    triggers:
      - schedule:
          cron: "0 0 * * *" # Daily at midnight
          filters:
            branches:
              only:
                - main
    jobs:
      - run-nightly-tests:
          context: rag-context  # This contains environment variables
      - hold: # A job that will require manual approval in the CircleCI web application.
          requires:
            - run-nightly-tests
          type: approval # This key-value pair will set your workflow to a status of "On Hold"
      - deploy:
          context: rag-context  # This contains environment variables
          requires:
            - hold


Note: If you authorized your CircleCI account via our GitHub App,  the scheduled workflows functionality is not currently supported for your account type. This feature is on our roadmap for a future release. In the meantime, your test suite will still trigger when a change is made to your main branch.

Adding jobs

The run-nightly-tests job is identical to the run-unit-tests job from the previous tutorial as we are using the same test suite for simplicity. You will need to remove the comments in the config file for this job to run.

 run-nightly-tests:
    machine: # executor type
      # for a full list of Linux VM execution environments, see
      # https://circleci.com/developer/images?imageType=machine
      image: ubuntu-2204:2023.07.2
    steps:
      - checkout  	# Check out the code in the project directory
      - install-venv
      - check-python  # Invoke command "check-python" after entering venv
      - run:
        command: source ./venv/bin/activate && pytest -s
        name: Run nightly tests


To start experimenting with your own tests, copy the example rag/test_rag.py file to a new file named rag/nightly_tests.py and tweak the existing tests or add your own. Then change the pytest command above to the command shown below:

source ./venv/bin/activate && pytest -s -k rag/nightly_tests.py


The hold job does not need to be defined — it’s a built-in job that is available in every CircleCI workflow. This job pauses the workflow after a certain job has been run and requires manual approval before continuing. This is especially useful when deploying LLM-powered applications because many language model tests are non-deterministic and will often need to be reviewed by a human.

Being able to automate the majority of an LLM workflow, only pausing for the specific tasks that require human approval, greatly speeds up LLM training, testing, and deployment workflows while ensuring the accuracy and quality of results. After the nightly tests have run and the LangSmith output has been verified, the pipeline will continue to the deployment phase. This keeps important decisions in human hands while automating all the steps prior to and after this decision.

The deploy job spins up a Python Flask server. This job uses a self-hosted machine runner rather than one of CircleCI’s cloud-hosted execution environments. This grants you full control over the execution environment, which can be useful in applications that require access to on-site compute assets or confidential data. Be sure to remove the comments from this job to run it in your pipeline.

  deploy:
    # For running on CircleCI's self-hosted runners
    machine: true
    resource_class: user/sample-project # TODO replace “user/sample-project” with your own self-hosted runner resource class details
    steps:
      - checkout
      - install-venv
      - check-python  # Invoke command "check-python" after entering venv
      - run:
        command: timeout --preserve-status --foreground 90 bash -c "source ./venv/bin/activate ; flask --app rag/app run" || true  # Run the server for 90 seconds to test
        name: Deploy application on self-hosted runner


It only takes five minutes to set up a self-hosted runner in CircleCI. To use this runner in a job, add its resource_class information to the .circleci/config.yml file. You should deploy this self-hosted runner to a system that you can log into, so that you can access your Flask server from localhost.

This is just to illustrate the simplest version of the workflow. In a production environment, you would likely want to deploy either to your own web infrastructure or to a hosted cloud service like Google Cloud Run or AWS ECS.

Putting it all together - a complete CI/CD pipeline for LangChain LLMs

This workflow will be run on the cron schedule defined in your workflow trigger. When the workflow has reached the hold job, it will pause awaiting approval. From here, you can look at the link in the logs to the LangSmith non-deterministic results and decide if the responses from the model were good enough to deploy the application.



Once approved, the workflow will continue and deploy the application to your production environment (in this case, the self-hosted machine runner).



After the deploy job runs, your Flask server will continue running as a long-lived process on your self-hosted runner. You can then interact with the deployed application using the curl command shown earlier.

curl -X POST -H "Content-Type: application/json" -d '{"message": "What is LangSmith?"}' http://localhost:5000




For demonstration purposes (and so you don’t have to set up a deployment server just to run this example), the Flask server will be launched on the machine runner, then the job will complete after 90 seconds so the workflow completes successfully. This way, you have enough time to issue the curl commands from before to confirm it is working properly.



Re-evaluating your LLM models

At this point, you’ve learned how to add a CI/CD workflow to your LLM-powered application development cycle. You can automatically build, test, evaluate, and deploy LLM-powered applications with every change to your application code or model prompts, shortening your development cycles for LLM-powered applications.

However, it’s important to remember that the behavior of AI models is far less predictable than that of traditional software and can evolve over time. Therefore, it’s impossible to have perfect test coverage even if you verify the outputs of many, many prompts to the model. It is almost a guarantee that your real-world users will prompt the model in a way that you don’t expect and get results that you don’t expect. To have a more stable and useful application, you want to minimize surprises like this.

This is why it’s a good idea to monitor how your users interact with your application under real-world conditions and bring those prompts and responses into your test suite. It’s not reasonable to do this for every prompt, but allowing LangSmith to store prompt data based on a random sample of users can be very enlightening.

You can do this by selectively instantiating the LangSmith client in your production application, as shown at the top of each unit test in rag/rag_test.py.

# Instantiate LangSmith client
client = Client()


Automate building, training, and evaluating LLM applications with CircleCI

LLM-powered applications are an exciting new frontier in software development, allowing you to provide more personalized, engaging, and user-centric experiences. But bringing these applications into production can be difficult and time consuming, often requiring extensive manual intervention.

By integrating LLM evaluations into your CI/CD pipeline, you not only save time and resources but also mitigate the inherent risks associated with manual evaluations and deployments.

To get started building your automated LLM evaluation and deployment pipeline, sign up for a free CircleCI account and take advantage of up to 6000 build minutes per month.

          

          
            
              
              
            
            
            
              
                
                
                
                  
                    Tutorials
                  
                
              
            
            
          
        
      
      
        
          

        
      
    

    
      
        
          Similar posts you may enjoy
          

  
    

  
    
      



    
  

  
  
    
      Build and evaluate LLM-powered apps with LangChain and CircleCI
    
    
      
        Nov 7, 202314 min read
      
    
  
  

  
    








  
    
      



    
  
  
    
      
        Jacob Schmitt
      
    
    
      
        Senior Technical Content Marketing Manager
      
    
  


  

  
    

  
    
      



    
  

  
  
    
      CI for machine learning: Build, test, train
    
    
      
        Jul 28, 202317 min read
      
    
  
  

  
    








  
    
      



    
  
  
    
      
        Jacob Schmitt
      
    
    
      
        Senior Technical Content Marketing Manager
      
    
  


  

  
    

  
    
      



    
  

  
  
    
      CD for machine learning: Deploy, monitor, retrain
    
    
      
        Aug 2, 202312 min read
      
    
  
  

  
    








  
    
      



    
  
  
    
      
        Jacob Schmitt
      
    
    
      
        Senior Technical Content Marketing Manager
      
    
  


  

  


        
      
    
  



  
    

    Copy to clipboard
  




  


  
    close
  
  
    
  



      




  
    
      
        
        CircleCI
      
    
    
      
        © 2025 Circle Internet Services, Inc.
        
          
            Terms of Use
          
            Privacy Policy
          
            Cookie Policy
          
        
      
      
  
    
    RSS
  
  
    
    LinkedIn
  
  
    
    GitHub
  
  
    

    X
  
  
    
    Twitch\n\nCancel
      
      
    
  
  
    
  


      













  
    
    

    
      
      
        
        
          
            
            
            
            
            
            TutorialsNov 14, 202310 min read
          
          Deploy and re-evaluate LLM-powered apps with LangSmith and CircleCI
          
            








  
    
      



    
  
  
    
      
        
          Jacob Schmitt
        
      
    
    
      
        Senior Technical Content Marketing Manager
      
    
  


            
          
        
      
      
        
        
          
            
              
              
                



              
            
          
        
        
      
    
    
      
      
        
          






  
    
Share on X
  
  
    Share on LinkedIn
  
  
    Share on Facebook
  

  
    
      Share on Reddit
    
    
      Share on Hacker News
    
  


        
        
          
            
            In part 1 of this tutorial, we showed you how to build a large language model (LLM) application that uses retrieval-augmented generation (RAG) to query your own documentation and then test it using a CircleCI continuous integration (CI) pipeline.

In this follow-up tutorial, we’ll show you how to build the continuous delivery (CD) portion of the pipeline to help bring your LLM-powered apps safely into production. The pipeline will run a scheduled set of nightly evaluations on your LLM application, wait for a human to review the results of your automated evaluations, and then deploy the application to your production environment. This way, you can ship regular updates to your application, with deeper visibility into model performance and better responsiveness to user needs.


  Sample code: You can follow along with this tutorial by forking the example repository and cloning it to your local machine using Git.


What we’re building: an LLM deployment platform

The first part of this tutorial demonstrated how to build an application that answers questions about LangSmith’s documentation. This application relies on OpenAI large language model APIs managed with wrappers from LangChain, a popular open-source framework for building language model-powered applications.

The tutorial also covered how to implement a unit-testing suite with deterministic tests to confirm that the model was nominally functional by asking its name and having it perform basic arithmetic. It also contained nondeterministic unit tests implemented with LLM evaluators (separate LLMs that assess and score generated content for qualities like relevance, coherency, and adherence to guidelines).

To build on this functionality, we’ll show you how to build a simple continuous delivery pipeline to perform extensive nightly integration tests on the main branch and deploy the application to production.



However, to keep this tutorial focused on the practical aspects of CI/CD, there are some simplifications and assumptions:


  The CI test suite from part 1 is re-used for this CD test suite: Generally, a CD test suite should be more robust than just unit tests. However, we’re using the same tests in this tutorial so we can focus on implementing the pipeline.
  The LLM application is minimal, for demonstration purposes: The example application only accepts POST requests with inputs to the language model in JSON format and returns the output from the language model.
  The CircleCI pipeline will run on a self-hosted runner: We’ll keep things simple here by deploying the application as a Python Flask server to a self-hosted runner through CircleCI and then interacting with that server through curl commands.


Creating the CircleCI deployment pipeline

These steps use the same example repository and configuration file as part 1 of this tutorial. To successfully run your pipeline, you will need to uncomment the run-nightly-tests and deploy jobs along with the deployment-tests workflow in the provided .circleci/config.yml file.

The example LLM deployment method is adapted from the LangChain documentation.

Running the Python Flask application locally

If you’re not following from part 1, you should check the prerequisites listed there and follow the included steps to create the required .env file. You can then spin up the server locally with the following commands:

source ./tools/install-venv.sh  # install and enter the Python virtual env
flask --app rag/app run &       # spin up the Flask server


Note: The & will instantiate the server as a background process. To stop the server, you will need to bring the process back to the foreground with the Linux fg command and then press Ctrl+C. As another option, you could open two separate terminals: one for spinning up the server and one for issuing commands.

Once the server has spun up successfully, you should see something like this:



Take note of the port that the Flask server is listening to. In this case, the server is on localhost with port 5000. After the server is spun up, you should be able to interact with it by sending curl commands to the host and port using the following template:

curl -X POST -H "Content-Type: application/json" -d '{"message": "What is LangSmith?"}' http://localhost:5000


Note: Be sure to adjust the port number to the port number that your Flask server is listening to.

The server should send the input to the documentation_chain object and then return the answer in JSON format.



You can adjust the message field in the JSON request to ask the LLM different questions. For a production environment, you would most likely build on this with a web-based graphical interface to make it more user-friendly.

Building the test suite

To keep this tutorial focused on the CI/CD aspect of LLMOps, you can just reuse the unit tests introduced in the first part of this tutorial. In production scenarios, though, you will want to define your own tests for your use case, as every ML deployment is highly specialized.


  
    
      Test name
      Test type
      What it does
    
  
  
    
      test_name
      deterministic
      Asks the LLM what its name is and checks that the string bob appears in the answer.
    
    
      test_basic_arithmetic
      deterministic
      Asks the LLM what 5 + 7 is and checks that the string 12 appears in the answer
    
    
      test_llm_evaluators
      non-deterministic
      Asks the LLM questions in the example list of tuples, then uses an LLM evaluator available in LangSmith to judge whether the actual output was close enough to the desired output
    
  


Setting up the CircleCI deployment pipeline

Following from the previous tutorial, you will already have set up a CircleCI account, forked the example repository, and added it as a CircleCI project with the included .circleci/config.yml configuration file.

Defining workflows

In the .circleci/config.yml file, there is a workflow called deployment-tests that consists of three jobs: run-nightly-tests, hold, and deploy. This workflow has been commented out to avoid confusion in the first part of this tutorial. To use this workflow in your pipeline, make sure you first remove the comments.

Note that the config file is supplying the run-nightly-tests and deploy jobs with the same rag-context context that it supplied to the run-unit-tests job in part 1 of this tutorial.

To run the multiple jobs contained in one workflow in series rather than parallel, supply the requires flag so that each job will wait for the previous one to succeed before executing. If certain jobs can be done in parallel, then these flags can be omitted.

Rather than being triggered whenever the main branch is updated, this workflow is executed on a schedule, defined in cron syntax.

 deployment-tests:
    # Trigger on a schedule or when retrain branch is updated
    triggers:
      - schedule:
          cron: "0 0 * * *" # Daily at midnight
          filters:
            branches:
              only:
                - main
    jobs:
      - run-nightly-tests:
          context: rag-context  # This contains environment variables
      - hold: # A job that will require manual approval in the CircleCI web application.
          requires:
            - run-nightly-tests
          type: approval # This key-value pair will set your workflow to a status of "On Hold"
      - deploy:
          context: rag-context  # This contains environment variables
          requires:
            - hold


Note: If you authorized your CircleCI account via our GitHub App,  the scheduled workflows functionality is not currently supported for your account type. This feature is on our roadmap for a future release. In the meantime, your test suite will still trigger when a change is made to your main branch.

Adding jobs

The run-nightly-tests job is identical to the run-unit-tests job from the previous tutorial as we are using the same test suite for simplicity. You will need to remove the comments in the config file for this job to run.

 run-nightly-tests:
    machine: # executor type
      # for a full list of Linux VM execution environments, see
      # https://circleci.com/developer/images?imageType=machine
      image: ubuntu-2204:2023.07.2
    steps:
      - checkout  	# Check out the code in the project directory
      - install-venv
      - check-python  # Invoke command "check-python" after entering venv
      - run:
        command: source ./venv/bin/activate && pytest -s
        name: Run nightly tests


To start experimenting with your own tests, copy the example rag/test_rag.py file to a new file named rag/nightly_tests.py and tweak the existing tests or add your own. Then change the pytest command above to the command shown below:

source ./venv/bin/activate && pytest -s -k rag/nightly_tests.py


The hold job does not need to be defined — it’s a built-in job that is available in every CircleCI workflow. This job pauses the workflow after a certain job has been run and requires manual approval before continuing. This is especially useful when deploying LLM-powered applications because many language model tests are non-deterministic and will often need to be reviewed by a human.

Being able to automate the majority of an LLM workflow, only pausing for the specific tasks that require human approval, greatly speeds up LLM training, testing, and deployment workflows while ensuring the accuracy and quality of results. After the nightly tests have run and the LangSmith output has been verified, the pipeline will continue to the deployment phase. This keeps important decisions in human hands while automating all the steps prior to and after this decision.

The deploy job spins up a Python Flask server. This job uses a self-hosted machine runner rather than one of CircleCI’s cloud-hosted execution environments. This grants you full control over the execution environment, which can be useful in applications that require access to on-site compute assets or confidential data. Be sure to remove the comments from this job to run it in your pipeline.

  deploy:
    # For running on CircleCI's self-hosted runners
    machine: true
    resource_class: user/sample-project # TODO replace “user/sample-project” with your own self-hosted runner resource class details
    steps:
      - checkout
      - install-venv
      - check-python  # Invoke command "check-python" after entering venv
      - run:
        command: timeout --preserve-status --foreground 90 bash -c "source ./venv/bin/activate ; flask --app rag/app run" || true  # Run the server for 90 seconds to test
        name: Deploy application on self-hosted runner


It only takes five minutes to set up a self-hosted runner in CircleCI. To use this runner in a job, add its resource_class information to the .circleci/config.yml file. You should deploy this self-hosted runner to a system that you can log into, so that you can access your Flask server from localhost.

This is just to illustrate the simplest version of the workflow. In a production environment, you would likely want to deploy either to your own web infrastructure or to a hosted cloud service like Google Cloud Run or AWS ECS.

Putting it all together - a complete CI/CD pipeline for LangChain LLMs

This workflow will be run on the cron schedule defined in your workflow trigger. When the workflow has reached the hold job, it will pause awaiting approval. From here, you can look at the link in the logs to the LangSmith non-deterministic results and decide if the responses from the model were good enough to deploy the application.



Once approved, the workflow will continue and deploy the application to your production environment (in this case, the self-hosted machine runner).



After the deploy job runs, your Flask server will continue running as a long-lived process on your self-hosted runner. You can then interact with the deployed application using the curl command shown earlier.

curl -X POST -H "Content-Type: application/json" -d '{"message": "What is LangSmith?"}' http://localhost:5000




For demonstration purposes (and so you don’t have to set up a deployment server just to run this example), the Flask server will be launched on the machine runner, then the job will complete after 90 seconds so the workflow completes successfully. This way, you have enough time to issue the curl commands from before to confirm it is working properly.



Re-evaluating your LLM models

At this point, you’ve learned how to add a CI/CD workflow to your LLM-powered application development cycle. You can automatically build, test, evaluate, and deploy LLM-powered applications with every change to your application code or model prompts, shortening your development cycles for LLM-powered applications.

However, it’s important to remember that the behavior of AI models is far less predictable than that of traditional software and can evolve over time. Therefore, it’s impossible to have perfect test coverage even if you verify the outputs of many, many prompts to the model. It is almost a guarantee that your real-world users will prompt the model in a way that you don’t expect and get results that you don’t expect. To have a more stable and useful application, you want to minimize surprises like this.

This is why it’s a good idea to monitor how your users interact with your application under real-world conditions and bring those prompts and responses into your test suite. It’s not reasonable to do this for every prompt, but allowing LangSmith to store prompt data based on a random sample of users can be very enlightening.

You can do this by selectively instantiating the LangSmith client in your production application, as shown at the top of each unit test in rag/rag_test.py.

# Instantiate LangSmith client
client = Client()


Automate building, training, and evaluating LLM applications with CircleCI

LLM-powered applications are an exciting new frontier in software development, allowing you to provide more personalized, engaging, and user-centric experiences. But bringing these applications into production can be difficult and time consuming, often requiring extensive manual intervention.

By integrating LLM evaluations into your CI/CD pipeline, you not only save time and resources but also mitigate the inherent risks associated with manual evaluations and deployments.

To get started building your automated LLM evaluation and deployment pipeline, sign up for a free CircleCI account and take advantage of up to 6000 build minutes per month.

          

          
            
              
              
            
            
            
              
                
                
                
                  
                    Tutorials
                  
                
              
            
            
          
        
      
      
        
          

        
      
    

    
      
        
          Similar posts you may enjoy
          

  
    

  
    
      



    
  

  
  
    
      Build and evaluate LLM-powered apps with LangChain and CircleCI
    
    
      
        Nov 7, 202314 min read
      
    
  
  

  
    








  
    
      



    
  
  
    
      
        Jacob Schmitt
      
    
    
      
        Senior Technical Content Marketing Manager
      
    
  


  

  
    

  
    
      



    
  

  
  
    
      CI for machine learning: Build, test, train
    
    
      
        Jul 28, 202317 min read
      
    
  
  

  
    








  
    
      



    
  
  
    
      
        Jacob Schmitt
      
    
    
      
        Senior Technical Content Marketing Manager
      
    
  


  

  
    

  
    
      



    
  

  
  
    
      CD for machine learning: Deploy, monitor, retrain
    
    
      
        Aug 2, 202312 min read
      
    
  
  

  
    








  
    
      



    
  
  
    
      
        Jacob Schmitt
      
    
    
      
        Senior Technical Content Marketing Manager
      
    
  


  

  


        
      
    
  



  
    

    Copy to clipboard
  




  


  
    close
  
  
    
  



      




  
    
      
        
        CircleCI
      
    
    
      
        © 2025 Circle Internet Services, Inc.
        
          
            Terms of Use
          
            Privacy Policy
          
            Cookie Policy
          
        
      
      
  
    
    RSS
  
  
    
    LinkedIn
  
  
    
    GitHub
  
  
    

    X
  
  
    
    Twitch\n\n\n\nOrbsOrbs are shareable packages of CircleCI configuration you can use to simplify your builds. Choose from the many partner, community, or CircleCI authored orbs in our public registry below, or create a private orb that’s exclusive to your organization.Read documentationNewly published orbs may not appear on this page for up to 30 minutes.    Search OrbsFilter by Orb TypeAllSelect CategoriesSelect\n\n\n\nUsing Insights1 month ago1 min readCloudServer v4+On This PageOverviewUsageWorkflow overviewJob overviewSee also Overview   The CircleCI Insights dashboard provides an overview of the health and usage of your projects' build processes, including time-series and aggregated data on credit usage, success rates, and pipeline duration.   Insights is not a financial reporting tool, and should not be used for precise credit reporting. Credit reporting from Insights does not use the same source of truth as the billing information that is found in the Plan Overview page in the CircleCI web app, nor does the underlying data have the same data accuracy guarantees as the billing information. This may lead to discrepancies between credits reported from Insights, and the billing information in the Plan Overview page. For precise credit reporting, always use the Plan Overview page in the CircleCI web app.      Data is not real-time and there may be up to a 24 hour delay.        This document describes how to access and use the Insights dashboard on CircleCI cloud and server.     Usage   Insights across your organization can be accessed from the sidebar of the CircleCI web application.   To access a specific project’s Insights, view a pipeline’s workflow and click the Insights button. Alternatively, you may access the Insights page by opening a pipeline’s Actions menu while viewing the pipelines dashboard.  Access by sidebarAccess by workflowAccess by pipeline                            Workflow overview  The Insights workflow overview provides metrics plotted over time for all branches, or a select branch, of a particular project workflow. The following data is charted under the workflow overview:     Status (success versus failed) of up to 100 most recent workflow runs   Workflow success rate   Workflow duration (50th versus 95th percentile)   Workflow credit usage      Job overview  Select the Jobs tab next to Overview to view the following cumulative data on a per-job basis:     Total credits used   Duration (95th percentile)   Total runs   Success rate   Compute usage (average and max for CPU and RAM)        See also   Refer to the  Collect Test Data document for guidance on configuring Insights into your most failed tests.   Suggest an edit to this pageMake a contribution Learn how to contributeStill need help? Ask the CircleCI community Join the research community Visit our Support site\n\nUsing Insights1 month ago1 min readCloudServer v4+On This PageOverviewUsageWorkflow overviewJob overviewSee also Overview   The CircleCI Insights dashboard provides an overview of the health and usage of your projects' build processes, including time-series and aggregated data on credit usage, success rates, and pipeline duration.   Insights is not a financial reporting tool, and should not be used for precise credit reporting. Credit reporting from Insights does not use the same source of truth as the billing information that is found in the Plan Overview page in the CircleCI web app, nor does the underlying data have the same data accuracy guarantees as the billing information. This may lead to discrepancies between credits reported from Insights, and the billing information in the Plan Overview page. For precise credit reporting, always use the Plan Overview page in the CircleCI web app.      Data is not real-time and there may be up to a 24 hour delay.        This document describes how to access and use the Insights dashboard on CircleCI cloud and server.     Usage   Insights across your organization can be accessed from the sidebar of the CircleCI web application.   To access a specific project’s Insights, view a pipeline’s workflow and click the Insights button. Alternatively, you may access the Insights page by opening a pipeline’s Actions menu while viewing the pipelines dashboard.  Access by sidebarAccess by workflowAccess by pipeline                            Workflow overview  The Insights workflow overview provides metrics plotted over time for all branches, or a select branch, of a particular project workflow. The following data is charted under the workflow overview:     Status (success versus failed) of up to 100 most recent workflow runs   Workflow success rate   Workflow duration (50th versus 95th percentile)   Workflow credit usage      Job overview  Select the Jobs tab next to Overview to view the following cumulative data on a per-job basis:     Total credits used   Duration (95th percentile)   Total runs   Success rate   Compute usage (average and max for CPU and RAM)        See also   Refer to the  Collect Test Data document for guidance on configuring Insights into your most failed tests.   Suggest an edit to this pageMake a contribution Learn how to contributeStill need help? Ask the CircleCI community Join the research community Visit our Support site DocsTerms of UsePrivacy PolicyCookie PolicySecurity© 2025 Circle Internet Services, Inc., All Rights Reserved.\n\nData is not real-time and there may be up to a 24 hour delay.\n\n\n\nOptimization reference1 month ago3 min readCloudServer v4+On This PageOptimize your data usageCustom storage controlsWorkspacesReduce build timeDocker image choiceDocker layer cachingCaching dependenciesWorkflowsParallelismRerun failed testsResource classOptimize your configuration filesDynamic configurationOrbsSee also   This page provides an overview of the various ways you can optimize your CircleCI configuration. Each optimization method is described briefly, along with possible use cases.     Optimize your data usage   Custom storage controls  The  CircleCI web app provides controls to customize the storage retention period for workspaces, caches, and artifacts. You can find these settings by navigating to Plan  Usage Controls. By default, the storage periods are set to the maximum: 30 days for artifacts, and 15 days for caches and workspaces.   See the  Persisting Data page for more information on custom storage settings.    Workspaces  Workspaces are used to pass along data that is unique to a run and is needed for downstream jobs. A job that runs early in your workflow might fetch data and then make it available later for jobs that run later in that workflow.   To persist data from a job and make it available to downstream jobs via the  attach_workspace key, configure the job to use the  persist_to_workspace key. Files and directories named in the paths: property of persist_to_workspace will be uploaded to the workflow’s temporary workspace relative to the directory specified with the root key. The files and directories are then uploaded and made available for subsequent jobs (and re-runs of the workflow) to use.     Read more on the  Workspaces page.        Reduce build time   Docker image choice  Choosing the right Docker image for your project can have huge impact on build time. For example, choosing a basic language image means dependencies and tools need to be downloaded each time your pipeline is run, whereas, if you choose or build an image that has these dependencies and tools already installed, this time will be saved for each build run. When configuring your projects and specifying images, consider the following options:     CircleCI provides a range of  convenience images, typically based on official Docker images, but with a range of useful language tools pre-installed.   You can create  custom images, maximizing specificity for your projects. To help with this we provide  guidance for building images manually.      Docker layer caching  Docker layer caching is a feature that can help to reduce the build time of a Docker image in your build. DLC is useful if you find yourself frequently building Docker images as a regular part of your CI/CD process.   DLC is similar to caching dependencies, in that it saves the image layers that you build within your job, making them available on subsequent builds.     Read more on the  Docker Layer Caching page.      Caching dependencies  Caching should be one of the first things you consider when trying to optimize your jobs. If a job fetches data at any point, it is likely that you can make use of caching. A common example is the use of a package/dependency manager. If your project uses Yarn, Bundler, or Pip, for example, the dependencies downloaded during a job can be cached for later use rather than being re-downloaded on every build.     Read more on the  Caching Dependencies page.      Workflows  Workflows provide a means to define a collection of jobs and their run order. If at any point in your configuration you see a step where two jobs could happily run independent of one another, workflows may be helpful. Workflows also provide several other features to augment and improve your CI/CD configuration. Read more about workflows on the  Workflow page.     You can view examples of workflows in the  CircleCI demo workflows repository.      Parallelism  If your project has a large test suite, you can configure your build to use  parallelism together with either  CircleCI’s test splitting functionality, or a  third party application or library to split your tests across multiple machines. CircleCI supports automatic test allocation across machines/containers on a file-basis. You can also manually customize how tests are allocated.     Read more about splitting tests across parallel execution environments on the  Parallelism and test splitting page.   Refer to the  Use the CircleCI CLI to split tests how-to guide.   Follow the  Test splitting tutorial.      Rerun failed tests  Use the rerun failed tests feature to only rerun a subset of tests when a transient test failure arises, rather than rerunning the entire test suite.     For more information see the  Rerun failed tests page.      Resource class  Using resource_class, it is possible to specify CPU and RAM resources for each job. For a full list of available resource class options for CircleCI cloud see the  configuration reference. For an equivalent list for CircleCI server installations, contact your system administrator.   Examples of how to set a resource class:  DockerLinux VMmacOSWindowsArmGPU    jobs:
  my-build:
    docker:
      - image: cimg/base:current
    resource_class: xlarge
    steps:
    #  ...  other config        jobs:
  my-job:
    machine:
      image: ubuntu-2004:current
    resource_class: large
    steps:
    #  ...  other config        jobs:
  build:
    macos:
      xcode: "15.4.0"
    resource_class: m2pro.medium
    steps:
    #  ...  other config        jobs:
  build: # name of your job
    machine:
      image: 'windows-server-2022-gui:current'
    resource_class: windows.medium
    steps:
    #  ...  other config        jobs:
  my-job:
    machine:
      image: ubuntu-2004:202101-01
    resource_class: arm.medium
    steps:
    #  ...  other config        jobs:
  build:
    machine:
      image: linux-cuda-12:default
    resource_class: gpu.nvidia.medium
    steps:
    #  ...  other config       Open a  Support ticket if you would like access to the GPU execution environment.                 Read more about resource classes on the  resource class overview page.        Optimize your configuration files   Dynamic configuration  Use dynamic configuration to generate CircleCI config files dynamically, depending on specific pipeline values or file paths. Dynamic config allows you to:     Execute conditional workflows/commands.   Pass pipeline parameter values and/or generate additional configuration.   Trigger separate config.yml configurations, which exist outside the default parent .circleci/ directory.     Read more about dynamic configuration on the  Dynamic configuration overview page.    Orbs  Orbs are reusable packages of parameterizable configuration that can be used in any project. Use orbs to:     Simplify configuration (.circleci/_config.yml)   Automate repeated processes   Accelerate project setup   Simplify integration with third-party tools     Read more about orbs on the  Orbs overview page.      See also      Persisting Data   For a complete list of customizations, view the  Configuration Reference page.   For information about how Yarn can potentially speed up builds and reduce errors, view the  Caching Dependencies page.   Coinbase published an article titled  Continuous Integration at Coinbase: How we optimized CircleCI for speed and cut our build times by 75%.     Suggest an edit to this pageMake a contribution Learn how to contributeStill need help? Ask the CircleCI community Join the research community Visit our Support site\n\nOptimization reference1 month ago3 min readCloudServer v4+On This PageOptimize your data usageCustom storage controlsWorkspacesReduce build timeDocker image choiceDocker layer cachingCaching dependenciesWorkflowsParallelismRerun failed testsResource classOptimize your configuration filesDynamic configurationOrbsSee also   This page provides an overview of the various ways you can optimize your CircleCI configuration. Each optimization method is described briefly, along with possible use cases.     Optimize your data usage   Custom storage controls  The  CircleCI web app provides controls to customize the storage retention period for workspaces, caches, and artifacts. You can find these settings by navigating to Plan  Usage Controls. By default, the storage periods are set to the maximum: 30 days for artifacts, and 15 days for caches and workspaces.   See the  Persisting Data page for more information on custom storage settings.    Workspaces  Workspaces are used to pass along data that is unique to a run and is needed for downstream jobs. A job that runs early in your workflow might fetch data and then make it available later for jobs that run later in that workflow.   To persist data from a job and make it available to downstream jobs via the  attach_workspace key, configure the job to use the  persist_to_workspace key. Files and directories named in the paths: property of persist_to_workspace will be uploaded to the workflow’s temporary workspace relative to the directory specified with the root key. The files and directories are then uploaded and made available for subsequent jobs (and re-runs of the workflow) to use.     Read more on the  Workspaces page.        Reduce build time   Docker image choice  Choosing the right Docker image for your project can have huge impact on build time. For example, choosing a basic language image means dependencies and tools need to be downloaded each time your pipeline is run, whereas, if you choose or build an image that has these dependencies and tools already installed, this time will be saved for each build run. When configuring your projects and specifying images, consider the following options:     CircleCI provides a range of  convenience images, typically based on official Docker images, but with a range of useful language tools pre-installed.   You can create  custom images, maximizing specificity for your projects. To help with this we provide  guidance for building images manually.      Docker layer caching  Docker layer caching is a feature that can help to reduce the build time of a Docker image in your build. DLC is useful if you find yourself frequently building Docker images as a regular part of your CI/CD process.   DLC is similar to caching dependencies, in that it saves the image layers that you build within your job, making them available on subsequent builds.     Read more on the  Docker Layer Caching page.      Caching dependencies  Caching should be one of the first things you consider when trying to optimize your jobs. If a job fetches data at any point, it is likely that you can make use of caching. A common example is the use of a package/dependency manager. If your project uses Yarn, Bundler, or Pip, for example, the dependencies downloaded during a job can be cached for later use rather than being re-downloaded on every build.     Read more on the  Caching Dependencies page.      Workflows  Workflows provide a means to define a collection of jobs and their run order. If at any point in your configuration you see a step where two jobs could happily run independent of one another, workflows may be helpful. Workflows also provide several other features to augment and improve your CI/CD configuration. Read more about workflows on the  Workflow page.     You can view examples of workflows in the  CircleCI demo workflows repository.      Parallelism  If your project has a large test suite, you can configure your build to use  parallelism together with either  CircleCI’s test splitting functionality, or a  third party application or library to split your tests across multiple machines. CircleCI supports automatic test allocation across machines/containers on a file-basis. You can also manually customize how tests are allocated.     Read more about splitting tests across parallel execution environments on the  Parallelism and test splitting page.   Refer to the  Use the CircleCI CLI to split tests how-to guide.   Follow the  Test splitting tutorial.      Rerun failed tests  Use the rerun failed tests feature to only rerun a subset of tests when a transient test failure arises, rather than rerunning the entire test suite.     For more information see the  Rerun failed tests page.      Resource class  Using resource_class, it is possible to specify CPU and RAM resources for each job. For a full list of available resource class options for CircleCI cloud see the  configuration reference. For an equivalent list for CircleCI server installations, contact your system administrator.   Examples of how to set a resource class:  DockerLinux VMmacOSWindowsArmGPU    jobs:
  my-build:
    docker:
      - image: cimg/base:current
    resource_class: xlarge
    steps:
    #  ...  other config        jobs:
  my-job:
    machine:
      image: ubuntu-2004:current
    resource_class: large
    steps:
    #  ...  other config        jobs:
  build:
    macos:
      xcode: "15.4.0"
    resource_class: m2pro.medium
    steps:
    #  ...  other config        jobs:
  build: # name of your job
    machine:
      image: 'windows-server-2022-gui:current'
    resource_class: windows.medium
    steps:
    #  ...  other config        jobs:
  my-job:
    machine:
      image: ubuntu-2004:202101-01
    resource_class: arm.medium
    steps:
    #  ...  other config        jobs:
  build:
    machine:
      image: linux-cuda-12:default
    resource_class: gpu.nvidia.medium
    steps:
    #  ...  other config       Open a  Support ticket if you would like access to the GPU execution environment.                 Read more about resource classes on the  resource class overview page.        Optimize your configuration files   Dynamic configuration  Use dynamic configuration to generate CircleCI config files dynamically, depending on specific pipeline values or file paths. Dynamic config allows you to:     Execute conditional workflows/commands.   Pass pipeline parameter values and/or generate additional configuration.   Trigger separate config.yml configurations, which exist outside the default parent .circleci/ directory.     Read more about dynamic configuration on the  Dynamic configuration overview page.    Orbs  Orbs are reusable packages of parameterizable configuration that can be used in any project. Use orbs to:     Simplify configuration (.circleci/_config.yml)   Automate repeated processes   Accelerate project setup   Simplify integration with third-party tools     Read more about orbs on the  Orbs overview page.      See also      Persisting Data   For a complete list of customizations, view the  Configuration Reference page.   For information about how Yarn can potentially speed up builds and reduce errors, view the  Caching Dependencies page.   Coinbase published an article titled  Continuous Integration at Coinbase: How we optimized CircleCI for speed and cut our build times by 75%.     Suggest an edit to this pageMake a contribution Learn how to contributeStill need help? Ask the CircleCI community Join the research community Visit our Support site DocsTerms of UsePrivacy PolicyCookie PolicySecurity© 2025 Circle Internet Services, Inc., All Rights Reserved.\n\njobs:
  my-build:
    docker:
      - image: cimg/base:current
    resource_class: xlarge
    steps:
    #  ...  other config    jobs:
  my-build:
    docker:
      - image: cimg/base:current
    resource_class: xlarge
    steps:
    #  ...  other config    jobs:
  my-job:
    machine:
      image: ubuntu-2004:current
    resource_class: large
    steps:
    #  ...  other config    jobs:
  my-job:
    machine:
      image: ubuntu-2004:current
    resource_class: large
    steps:
    #  ...  other config    jobs:
  build:
    macos:
      xcode: "15.4.0"
    resource_class: m2pro.medium
    steps:
    #  ...  other config    jobs:
  build:
    macos:
      xcode: "15.4.0"
    resource_class: m2pro.medium
    steps:
    #  ...  other config    jobs:
  build: # name of your job
    machine:
      image: 'windows-server-2022-gui:current'
    resource_class: windows.medium
    steps:
    #  ...  other config    jobs:
  build: # name of your job
    machine:
      image: 'windows-server-2022-gui:current'
    resource_class: windows.medium
    steps:
    #  ...  other config    jobs:
  my-job:
    machine:
      image: ubuntu-2004:202101-01
    resource_class: arm.medium
    steps:
    #  ...  other config    jobs:
  my-job:
    machine:
      image: ubuntu-2004:202101-01
    resource_class: arm.medium
    steps:
    #  ...  other config    jobs:
  build:
    machine:
      image: linux-cuda-12:default
    resource_class: gpu.nvidia.medium
    steps:
    #  ...  other config       Open a  Support ticket if you would like access to the GPU execution environment.        jobs:
  build:
    machine:
      image: linux-cuda-12:default
    resource_class: gpu.nvidia.medium
    steps:
    #  ...  other config  Open a  Support ticket if you would like access to the GPU execution environment.\n\n\n\nInsights metrics glossary1 month ago3 min readCloudServer v4+On This PageOverviewGeneral metricsOrganization-level metricsWorkflow MetricsTrendsApproximate trendsDurationRepresentations of trend data Overview   This document provides definitions for all the metrics in CircleCI Insights. You can review metrics in the Insights dashboard as well as the Insights API.     General metrics   General metrics appear across the Insights experience and can refer to different entities, depending on the context. For example, the Runs metric may refer to a count of workflow executions or jobs, depending on the context.  TermDefinitionRunsThe count of executions in a selected time window.Total DurationThe sum of execution times for all workflows in a project.P95 DurationThe 95th percentile of execution times for an entity in a selected time window (that is, 95% of runs completed in the same or less amount of this time). The 95th percentile is a standard measure used to interpret performance data. It provides a measure of max value when outlier or transient values are excluded.P50 (median) DurationThe median execution time. Medians are a better measure of central tendency than arithmetic means because they are more resilient to skewness in datasets.Total CreditsThe sum of Docker layer caching (DLC) and compute credits during execution.Success RateThe percentage of runs that completed successfully, excluding cancelled runs. Calculated by 100 x (Successful Runs / All Runs - Cancelled Runs)    Organization-level metrics        Organization-level metrics allow you to analyze your organization’s performance.  TermDefinitionWorkflow RunsThe count of all workflows executions for an organization for the selected projects in the selected time frame.Total Workflow DurationThe total execution time of all workflows runs for an organization within the selected projects and time frame.Total CreditsThe total credits consumed across all selected projects in an organization.Overall Success RateThe percentage of runs that completed successfully across all runs in the selected projects and workflows. Excludes cancelled runs. (calculated by 100 x (All Successful Runs/ All Runs - Cancelled Runs))    Workflow Metrics       TermDefinitionTime to RecoveryTotal time spent in a failed state before a successful execution.Mean Time to Recovery (MTTR)The average time it takes to get back to a successful execution from a failed one (Calculated by total recovery time / # of failures). If there are no failed builds (and thus no recoveries) in the current time window, the MTTR value will be empty. Empty MTTR values will be treated as 0 when calculating Trends.ThroughputThe average (mean) number of builds of any status per day. Calculated by Sum of builds/ # of days.    Trends   Raw metric values are often difficult to interpret on their own. Trends provide additional context to Insights metrics by presenting a relative benchmark against previous performance. For instance, on the last 7-day view, trends will display the change in value or delta compared to the prior 7-day window.   Trends displayed in the CircleCI UI are calculated as 100 * (current value - previous value) / prior-value.   Trends received from the  CircleCI API are calculated as a ratio instead of a percentage with the following formula: (current-value / prior-value). These trends are 1-based and not 0-based.     A ratio of 1.0 indicates no change.   A value less than 1.0 indicates a negative trend, and a value greater than 1.0 indicates a positive trend.   A value of -1.0 is an infinite trend.     This also applies to the following API endpoints:      getOrgSummaryData    getWorkflowSummary.     Despite the trend being reported as a ratio via the API, the result returned is still effectively equivalent to the percentage that is shown in the UI. To compare the ratio from the API with the percentage reported in the UI, you can compute | trend-value - 1| (vertical line indicates absolute value). For example, if the API returns a ratio of 3.33, in the UI it will be shown as | 3.33 - 1 | = 2.33 which is equivalent to +233%.      Trends are available only for 24-hour, 7-day, and 30-day time windows.        Approximate trends  For percentile metrics like duration, approximation methods are used to find the prior window benchmarks.   Duration   P95 Duration  For P95 duration, trends data is calculated by using the worst-case performance of the previous time window as a benchmark. For example, to calculate the last 7-day trend information, Insights selects the worst/largest daily P95 duration of the previous 7 days as a benchmark. For the last 24-hour trends, Insights selects the worst hourly P95 of the previous 24 hours as a benchmark.  P50 Duration  For P50 duration, Trends compares current duration with the median performance of the prior time window. For example, the last 30-day trends for P50 duration are calculated by taking the median of the daily P50 values as a benchmark.       Representations of trend data  This section describes how your trend data may appear across various metrics.          Green: The metric is trending in the right direction.   Red: The metric is trending in the wrong direction.   Grey: A trend in either direction is not right or wrong.     Red and Green are used when describing the Success Rate, Throughput and MTTR metrics. Grey arrows are used when describing Runs, Duration and Total Credits    Percentages  Percentages indicate the relative percentage change for a metric in the selected time window compared to the prior window. For instance, if the success rate of a workflow in the last 7 days has increased to 60% from 40% in the prior 7 days, Trends displays the +50% change in the current time window.  Multiples  Multiples are used to indicate large swings in relative change over the selected period.  Arrows  Trend arrows with no values are used to indicate that the previous time window contains zero executions or no data.  No Trend Data  Empty trend values indicate that there has been no change in data between the two periods.      Suggest an edit to this pageMake a contribution Learn how to contributeStill need help? Ask the CircleCI community Join the research community Visit our Support site\n\nInsights metrics glossary1 month ago3 min readCloudServer v4+On This PageOverviewGeneral metricsOrganization-level metricsWorkflow MetricsTrendsApproximate trendsDurationRepresentations of trend data Overview   This document provides definitions for all the metrics in CircleCI Insights. You can review metrics in the Insights dashboard as well as the Insights API.     General metrics   General metrics appear across the Insights experience and can refer to different entities, depending on the context. For example, the Runs metric may refer to a count of workflow executions or jobs, depending on the context.  TermDefinitionRunsThe count of executions in a selected time window.Total DurationThe sum of execution times for all workflows in a project.P95 DurationThe 95th percentile of execution times for an entity in a selected time window (that is, 95% of runs completed in the same or less amount of this time). The 95th percentile is a standard measure used to interpret performance data. It provides a measure of max value when outlier or transient values are excluded.P50 (median) DurationThe median execution time. Medians are a better measure of central tendency than arithmetic means because they are more resilient to skewness in datasets.Total CreditsThe sum of Docker layer caching (DLC) and compute credits during execution.Success RateThe percentage of runs that completed successfully, excluding cancelled runs. Calculated by 100 x (Successful Runs / All Runs - Cancelled Runs)    Organization-level metrics        Organization-level metrics allow you to analyze your organization’s performance.  TermDefinitionWorkflow RunsThe count of all workflows executions for an organization for the selected projects in the selected time frame.Total Workflow DurationThe total execution time of all workflows runs for an organization within the selected projects and time frame.Total CreditsThe total credits consumed across all selected projects in an organization.Overall Success RateThe percentage of runs that completed successfully across all runs in the selected projects and workflows. Excludes cancelled runs. (calculated by 100 x (All Successful Runs/ All Runs - Cancelled Runs))    Workflow Metrics       TermDefinitionTime to RecoveryTotal time spent in a failed state before a successful execution.Mean Time to Recovery (MTTR)The average time it takes to get back to a successful execution from a failed one (Calculated by total recovery time / # of failures). If there are no failed builds (and thus no recoveries) in the current time window, the MTTR value will be empty. Empty MTTR values will be treated as 0 when calculating Trends.ThroughputThe average (mean) number of builds of any status per day. Calculated by Sum of builds/ # of days.    Trends   Raw metric values are often difficult to interpret on their own. Trends provide additional context to Insights metrics by presenting a relative benchmark against previous performance. For instance, on the last 7-day view, trends will display the change in value or delta compared to the prior 7-day window.   Trends displayed in the CircleCI UI are calculated as 100 * (current value - previous value) / prior-value.   Trends received from the  CircleCI API are calculated as a ratio instead of a percentage with the following formula: (current-value / prior-value). These trends are 1-based and not 0-based.     A ratio of 1.0 indicates no change.   A value less than 1.0 indicates a negative trend, and a value greater than 1.0 indicates a positive trend.   A value of -1.0 is an infinite trend.     This also applies to the following API endpoints:      getOrgSummaryData    getWorkflowSummary.     Despite the trend being reported as a ratio via the API, the result returned is still effectively equivalent to the percentage that is shown in the UI. To compare the ratio from the API with the percentage reported in the UI, you can compute | trend-value - 1| (vertical line indicates absolute value). For example, if the API returns a ratio of 3.33, in the UI it will be shown as | 3.33 - 1 | = 2.33 which is equivalent to +233%.      Trends are available only for 24-hour, 7-day, and 30-day time windows.        Approximate trends  For percentile metrics like duration, approximation methods are used to find the prior window benchmarks.   Duration   P95 Duration  For P95 duration, trends data is calculated by using the worst-case performance of the previous time window as a benchmark. For example, to calculate the last 7-day trend information, Insights selects the worst/largest daily P95 duration of the previous 7 days as a benchmark. For the last 24-hour trends, Insights selects the worst hourly P95 of the previous 24 hours as a benchmark.  P50 Duration  For P50 duration, Trends compares current duration with the median performance of the prior time window. For example, the last 30-day trends for P50 duration are calculated by taking the median of the daily P50 values as a benchmark.       Representations of trend data  This section describes how your trend data may appear across various metrics.          Green: The metric is trending in the right direction.   Red: The metric is trending in the wrong direction.   Grey: A trend in either direction is not right or wrong.     Red and Green are used when describing the Success Rate, Throughput and MTTR metrics. Grey arrows are used when describing Runs, Duration and Total Credits    Percentages  Percentages indicate the relative percentage change for a metric in the selected time window compared to the prior window. For instance, if the success rate of a workflow in the last 7 days has increased to 60% from 40% in the prior 7 days, Trends displays the +50% change in the current time window.  Multiples  Multiples are used to indicate large swings in relative change over the selected period.  Arrows  Trend arrows with no values are used to indicate that the previous time window contains zero executions or no data.  No Trend Data  Empty trend values indicate that there has been no change in data between the two periods.      Suggest an edit to this pageMake a contribution Learn how to contributeStill need help? Ask the CircleCI community Join the research community Visit our Support site DocsTerms of UsePrivacy PolicyCookie PolicySecurity© 2025 Circle Internet Services, Inc., All Rights Reserved.\n\nTrends are available only for 24-hour, 7-day, and 30-day time windows.\n\n\n\nTest splitting to speed up your pipelines2 weeks ago10 min readCloudServer v4+On This PageIntroductionAbout the sample appConfiguration walkthrough1. Add the project2. Set up test splitting3. View results4. Split by timing dataConclusionNext steps   This guide walks you through a basic example of test splitting in CircleCI. Test splitting helps speed up your pipelines.     Introduction   Test splitting is a technique in which tests are executed simultaneously across multiple execution environments. Test splitting takes advantage of a feature called  parallelism, which allows you to run a job in CircleCI on different nodes at the same time.   You may have a test suite that consists of dozens or hundreds of tests, and executing them one after the other can take up a lot of time. When you split tests, you have the opportunity to significantly reduce wait times and receive feedback more quickly.   Test splitting in CircleCI can work with many testing frameworks, including Jest, pytest, Maven, and Gradle.   In this tutorial, you will:     Set up a basic React app as a project in CircleCI.   Modify the project’s .circleci/config.yml file to split tests based on timing data.   View the resulting parallel test runs in the CircleCI web app.   See how test splitting can help decrease pipeline run times.     To complete this tutorial, you need:     A CircleCI account - if you do not have an account,  you can sign up for free.   A Version Control System (VCS) provider, such as GitHub, Bitbucket, or GitLab, connected to your CircleCI account. If you have not already done so, follow the steps in the  GitHub,  Bitbucket, or  GitLab integration pages to connect your VCS provider.       About the sample app   You will use a basic React app for this tutorial. The project repository is available on  GitHub. The app was created using  Create React App, and is set up to use the  Jest testing framework. It uses the  jest-junit reporter to export test results as JUnit XML files.   When you set up the project in CircleCI later in this tutorial, you’ll select the option to use a config.yml template that you can edit. The template used with this tutorial is a starter configuration that can be used with Node projects. Read the following section for a walkthrough of the configuration, or skip ahead to set up the project if you are already familiar with setting up Node projects in CircleCI.   Configuration walkthrough  The following is a copy of the .circleci/config.yml template that you will edit later.      Using Docker? Authenticating Docker pulls from image registries is recommended when using the Docker execution environment. Authenticated pulls allow access to private Docker images, and may also grant higher rate limits, depending on your registry provider. For further information see  Using Docker authenticated pulls.         version: 2.1

orbs:
  node: circleci/node@4.7

jobs:
  build-and-test:
    docker:
      - image: cimg/node:16.10
    steps:
      - checkout
      - node/install-packages:
          pkg-manager: npm
      - run:
          name: Run tests
          command: npm test

workflows:
  sample:
    jobs:
      - build-and-test      Line 1: This project uses the configuration version: 2.1. This enables CircleCI features such as orbs and reusable configuration. More information on config version 2.1 can be found in the  Configuration reference page.   Lines 3-4: This project uses the CircleCI Node  orb. The Node orb is a package of reusable configuration elements that allow you to execute tasks common to Node.js apps and help reduce complexity in your config.yml file. In this particular example, the orb’s install-packages command is used to install Node packages and configure Yarn as the default package manager using the pkg-manager parameter. More details on the Node orb can be found on the  Developer Hub.   Lines 18-21: The project pipeline consists of one workflow called sample. This workflow is comprised of one job, named build-and-test, which is made up of a few steps to check out the project code, install Node packages and set the default package manager, and run tests (lines 8 to 16).     Test splitting is typically set up within a job. In this tutorial you will modify the build-and-test job to define the following:     The number of parallel test runs.   Where the test suites are located.   How tests should be split (in this case, by timing).        1. Add the project   To get started, you need to get the sample app building as a project on CircleCI. If you are using GitHub the steps are slightly different depending on whether you have a GitHub OAuth app or CircleCI GitHub App integration. To find out which integration you have, see the  GitHub App integration page.  GitHub Oauth appBitbucket CloudGitLab / GitHub App / Bitbucket Data Center      Fork the repository on GitHub.   Open the  CircleCI web app. Make sure you are in the correct organization (for example, https://app.circleci.com/pipelines/github/<your-vcs-username>), then navigate to Projects.   Find the sample app on the list of projects, and select Set Up Project.   You will be prompted to select your config.yml file. In the window, select the "Fast: Take me to a config.yml template that I can edit" option. Select Set Up Project.   You will then see a list of sample configurations. Scroll down within the window until you see Node (Advanced), then choose Select.        You will be taken to the in-app configuration editor. The project actually uses Yarn, so you will need to edit the following steps so that they use yarn instead of npm, like so:   steps:
# Checkout the code as the first step.
  - checkout
# Next, the node orb's install-packages step will install the dependencies from a package.json.
# The orb install-packages step will also automatically cache them for faster future runs.
  - node/install-packages:
    # If you are using yarn, change the line below from "npm" to "yarn"
    pkg-manager: yarn
  - run:
    name: Run tests
    command: yarn test     After you have made these changes, go ahead and select Commit and Run. This will commit the changes in a new feature branch called circleci-project-setup and trigger a new pipeline. Select Dashboard from the web app side bar, and use the filters to find your project to watch your pipeline run.       Feel free to take a look at the steps run in the pipeline by expanding the green Success status and opening the build-and-test job.                Import the project code into Bitbucket, using the repo URL: https://github.com/CircleCI-Public/circleci-react-test-splitting-tutorial   Open the  CircleCI web app. Make sure you are in the correct organization (for example, https://app.circleci.com/pipelines/bitbucket/<your-vcs-username>), then navigate to Projects.   Find the sample app on the list of projects, and select Set Up Project.   You will be prompted to select your config.yml file. In the window, select the "Fast: Take me to a config.yml template that I can edit" option. Select Set Up Project.   You will then see a list of sample configurations. Scroll down within the window until you see Node (Advanced), then Select.        You will be taken to the in-app configuration editor. The project actually uses Yarn, so you will need to edit the following steps so that they use yarn instead of npm, like so:   steps:
# Checkout the code as the first step.
  - checkout
# Next, the node orb's install-packages step will install the dependencies from a package.json.
# The orb install-packages step will also automatically cache them for faster future runs.
  - node/install-packages:
    # If you are using yarn, change the line below from "npm" to "yarn"
    pkg-manager: yarn
  - run:
    name: Run tests
    command: yarn test     After you’ve made these changes, go ahead and select Commit and Run. This will commit the changes in a new feature branch called circleci-project-setup and trigger a new pipeline. Select Dashboard from the web app side bar, and use the filters to find your project to watch your pipeline run.       Feel free to take a look at the steps run in the pipeline by expanding the green Success status and opening the build-and-test job.                 Fork the repository if you are using GitHub, or import to Bitbucket or GitLab using the repository URL: https://github.com/CircleCI-Public/circleci-react-test-splitting-tutorial   Open the  CircleCI web app. Select your org from the user homepage, then select Projects in the sidebar.   Select Create Project and follow the in-app instructions to create a new project for your clone of the sample project.   You will be taken to the in-app configuration editor. Change the config template by clicking Change: Hello World. You will then be presented a list of sample configurations. Scroll down within the window until you see Node (Advanced), then Select.        The project actually uses Yarn, so you will need to edit the build-and-test job definition in the config so that it uses yarn instead of npm. Use the in-app editor to edit the step like so:   steps:
# Checkout the code as the first step.
  - checkout
# Next, the node orb's install-packages step will install the dependencies from a package.json.
# The orb install-packages step will also automatically cache them for faster future runs.
  - node/install-packages:
    # If you are using yarn, change the line below from "npm" to "yarn"
    pkg-manager: yarn
  - run:
    name: Run tests
    command: yarn test     After you’ve made these changes, go ahead and select Commit and Run. This will commit the changes in a new feature branch called circleci-project-setup and trigger a new pipeline. Select Dashboard from the web app side bar, and use the filters to find your project to watch your pipeline run.       Take a look at the steps run in the pipeline by expanding the green Success status and opening the build-and-test job.                 2. Set up test splitting   If you downloaded a local copy of the code repository, carry out the following steps in your text editor to modify .circleci/config.yml. Alternatively, if you are using GitHub OAuth or Bitbucket Cloud, you may edit the project’s configuration in the CircleCI web app by selecting a branch, and then clicking Edit Config.     In the build-and-test job, after the docker key, add the parallelism key with a value of 5.   parallelism: 5    For test splitting to work, the parallelism key has to be set to a value greater than 1, ensuring that the tests are distributed across multiple executors. Otherwise, if the value is 1, tests will be run sequentially within the same environment, and you do not get the benefit of reducing test times.   In this example, five separate Docker containers will spin up.    Within the steps key of the build-and-test job, make the following updates:    After the node/install-packages step, add a run command to create a new subdirectory named junit:   - run: mkdir ~/junit    Test results, including timing data, will be saved in this subdirectory of the executor.    Replace the existing run command named Run tests with the following:   - run:
      name: Test application
      command: |
          TEST=$(circleci tests glob "src/__tests__/*.js")
          echo "$TEST" | circleci tests run --command="xargs yarn test" --split-by=timings    This step uses the CircleCI CLI to pass in the location of the test suites and configure how the tests are split. You can use the circleci tests glob command to select the test files:     First, you want those that match the src/__tests__/*.js globbing pattern, that is, any .js files located in src/__tests__ and any of its subdirectories.   Then, the matching files are piped into circleci tests run, which creates the test split groupings and then runs your tests.   The --split-by=timings flag indicates that the tests should be split according to timing data. For other test splitting options, see the  Test splitting and parallelism page.     The circleci tests commands (glob and run) cannot be run locally via the CLI as they require information that only exists within a CircleCI container.            Add a step to copy the test results (saved as JUnit XML files) to the ~/junit subdirectory created in an earlier step. Using the when attribute with a value of always will execute this particular step always regardless of whether the preceding steps were executed successfully or not.   - run:
    command: cp junit.xml ~/junit/
    when: always     Finally, add a store_test_results step:   - store_test_results:
    path: ~/junit    This step uploads the test data to CircleCI and is required to split tests by timing data. This step allows test data to be accessible on the Tests tab of the job in the CircleCI web app, and can be helpful for debugging if tests fail. To read more about the Tests tab and test insights in CircleCI, visit the  Collect test data page.         Here is a full copy of the updated configuration:    version: 2.1

orbs:
    node: circleci/node@4.7

jobs:
    build-and-test:
        docker:
            - image: cimg/node:16.10
        parallelism: 5
        steps:
            - checkout
            - node/install-packages:
                pkg-manager: yarn
            - run: mkdir ~/junit
            - run:
                name: Test application
                command: |
                    TEST=$(circleci tests glob "src/__tests__/*.js")
                    echo "$TEST" | circleci tests run --command="xargs yarn test" --split-by=timings
            - run:
                command: cp junit.xml ~/junit/
                when: always
            - store_test_results:
                path: ~/junit

workflows:
    sample:
      jobs:
        - build-and-test    Once you have made these changes to .circleci/config.yml, go ahead and push the changes. This triggers the pipeline and runs the tests again, but this time the results are stored.     3. View results   In the CircleCI web app, take a look at the steps in the recently triggered pipeline by clicking on the Success status and opening the build-and-test job.     You may have noticed that this pipeline ran more quickly compared to earlier. The Node orb automatically caches node packages by default, so a cache exists from the earlier pipeline run. This helps speed up the install step.   You should also now see five parallel runs, as a result of the number of execution environments set by the parallelism key. Each Docker environment (node) is labeled by its index number (so you have numbers 0 through 4). You can select each node to see the individual steps that executed in each parallel run. The environment you are viewing will be highlighted in green.       You might also notice that the parallel run times are not all equal, nor is the overall run time of the pipeline cut down to precisely 1/5. Each executor runs the same steps, but there is a difference in terms of which executor runs which tests. There may also be some variation in how long each executor takes to spin up.   Splitting tests by timing is the best way to ensure tests are split as evenly as possible and parallel runs finish around the same time. With that said, you may need to play around with the parallelism level to find the number that works best for you.    In any of the parallel runs, open the Test application step. You will see which test suites and how many individual tests were executed in this particular run. You will also see this message in the output:   Error reading historical timing data: file does not exist
Requested weighting by historical based timing, but they are not present. Falling back to weighting by name.    CircleCI defaults to splitting tests by name. As this is the first time you are storing test data from the pipeline, CircleCI does not yet have timing data to work with.    Open the Timing tab in the job. This tab provides a visualization of how each parallel run did relative to each other.       The chart indicates which three steps within each run took the longest to complete. Hover over each section of the bar to see those respective steps.   You may also notice on the upper right corner within the Timing tab an indicator for idle time. In this pipeline, there was a total of 11 seconds between each finished run and the end of the longest run.        4. Split by timing data   In the previous step, you saw that test splitting defaulted to splitting tests based on name. Now that test data has been saved, CircleCI can now split your tests by timing the next time the pipeline runs.     Commit a change in your project to trigger the pipeline again.  For example, you can try upgrading to a newer version of the Node orb, such as circleci/node@5.0.2. Or you may choose to trigger a pipeline. On the Pipelines page in the CircleCI web app, select Trigger Pipeline.    Open the pipeline in the web app, and view the Test application step. This time, you should see Autodetected filename timings. in the output. This means that CircleCI is now splitting tests based on available timing data from preceding runs.        Lastly, open the Timing tab. In this particular example, you might find that the time taken for the testing step to complete is not drastically different from earlier, when tests were split by name. However, you may notice that the idle time between runs has now been cut down to only five seconds, compared to 11 seconds from earlier.       Conclusion   In this tutorial, you have configured your pipeline to split tests by timing data using parallelism and circleci tests commands. By storing test results, you also enabled access to test data and insights for further analysis.     Next steps     For a more in-depth discussion of the demo used in this tutorial, read our  A Guide to Test Splitting blog post.   Learn about  Test insights available in CircleCI.     Suggest an edit to this pageMake a contribution Learn how to contributeStill need help? Ask the CircleCI community Join the research community Visit our Support site\n\nTest splitting to speed up your pipelines2 weeks ago10 min readCloudServer v4+On This PageIntroductionAbout the sample appConfiguration walkthrough1. Add the project2. Set up test splitting3. View results4. Split by timing dataConclusionNext steps   This guide walks you through a basic example of test splitting in CircleCI. Test splitting helps speed up your pipelines.     Introduction   Test splitting is a technique in which tests are executed simultaneously across multiple execution environments. Test splitting takes advantage of a feature called  parallelism, which allows you to run a job in CircleCI on different nodes at the same time.   You may have a test suite that consists of dozens or hundreds of tests, and executing them one after the other can take up a lot of time. When you split tests, you have the opportunity to significantly reduce wait times and receive feedback more quickly.   Test splitting in CircleCI can work with many testing frameworks, including Jest, pytest, Maven, and Gradle.   In this tutorial, you will:     Set up a basic React app as a project in CircleCI.   Modify the project’s .circleci/config.yml file to split tests based on timing data.   View the resulting parallel test runs in the CircleCI web app.   See how test splitting can help decrease pipeline run times.     To complete this tutorial, you need:     A CircleCI account - if you do not have an account,  you can sign up for free.   A Version Control System (VCS) provider, such as GitHub, Bitbucket, or GitLab, connected to your CircleCI account. If you have not already done so, follow the steps in the  GitHub,  Bitbucket, or  GitLab integration pages to connect your VCS provider.       About the sample app   You will use a basic React app for this tutorial. The project repository is available on  GitHub. The app was created using  Create React App, and is set up to use the  Jest testing framework. It uses the  jest-junit reporter to export test results as JUnit XML files.   When you set up the project in CircleCI later in this tutorial, you’ll select the option to use a config.yml template that you can edit. The template used with this tutorial is a starter configuration that can be used with Node projects. Read the following section for a walkthrough of the configuration, or skip ahead to set up the project if you are already familiar with setting up Node projects in CircleCI.   Configuration walkthrough  The following is a copy of the .circleci/config.yml template that you will edit later.      Using Docker? Authenticating Docker pulls from image registries is recommended when using the Docker execution environment. Authenticated pulls allow access to private Docker images, and may also grant higher rate limits, depending on your registry provider. For further information see  Using Docker authenticated pulls.         version: 2.1

orbs:
  node: circleci/node@4.7

jobs:
  build-and-test:
    docker:
      - image: cimg/node:16.10
    steps:
      - checkout
      - node/install-packages:
          pkg-manager: npm
      - run:
          name: Run tests
          command: npm test

workflows:
  sample:
    jobs:
      - build-and-test      Line 1: This project uses the configuration version: 2.1. This enables CircleCI features such as orbs and reusable configuration. More information on config version 2.1 can be found in the  Configuration reference page.   Lines 3-4: This project uses the CircleCI Node  orb. The Node orb is a package of reusable configuration elements that allow you to execute tasks common to Node.js apps and help reduce complexity in your config.yml file. In this particular example, the orb’s install-packages command is used to install Node packages and configure Yarn as the default package manager using the pkg-manager parameter. More details on the Node orb can be found on the  Developer Hub.   Lines 18-21: The project pipeline consists of one workflow called sample. This workflow is comprised of one job, named build-and-test, which is made up of a few steps to check out the project code, install Node packages and set the default package manager, and run tests (lines 8 to 16).     Test splitting is typically set up within a job. In this tutorial you will modify the build-and-test job to define the following:     The number of parallel test runs.   Where the test suites are located.   How tests should be split (in this case, by timing).        1. Add the project   To get started, you need to get the sample app building as a project on CircleCI. If you are using GitHub the steps are slightly different depending on whether you have a GitHub OAuth app or CircleCI GitHub App integration. To find out which integration you have, see the  GitHub App integration page.  GitHub Oauth appBitbucket CloudGitLab / GitHub App / Bitbucket Data Center      Fork the repository on GitHub.   Open the  CircleCI web app. Make sure you are in the correct organization (for example, https://app.circleci.com/pipelines/github/<your-vcs-username>), then navigate to Projects.   Find the sample app on the list of projects, and select Set Up Project.   You will be prompted to select your config.yml file. In the window, select the "Fast: Take me to a config.yml template that I can edit" option. Select Set Up Project.   You will then see a list of sample configurations. Scroll down within the window until you see Node (Advanced), then choose Select.        You will be taken to the in-app configuration editor. The project actually uses Yarn, so you will need to edit the following steps so that they use yarn instead of npm, like so:   steps:
# Checkout the code as the first step.
  - checkout
# Next, the node orb's install-packages step will install the dependencies from a package.json.
# The orb install-packages step will also automatically cache them for faster future runs.
  - node/install-packages:
    # If you are using yarn, change the line below from "npm" to "yarn"
    pkg-manager: yarn
  - run:
    name: Run tests
    command: yarn test     After you have made these changes, go ahead and select Commit and Run. This will commit the changes in a new feature branch called circleci-project-setup and trigger a new pipeline. Select Dashboard from the web app side bar, and use the filters to find your project to watch your pipeline run.       Feel free to take a look at the steps run in the pipeline by expanding the green Success status and opening the build-and-test job.                Import the project code into Bitbucket, using the repo URL: https://github.com/CircleCI-Public/circleci-react-test-splitting-tutorial   Open the  CircleCI web app. Make sure you are in the correct organization (for example, https://app.circleci.com/pipelines/bitbucket/<your-vcs-username>), then navigate to Projects.   Find the sample app on the list of projects, and select Set Up Project.   You will be prompted to select your config.yml file. In the window, select the "Fast: Take me to a config.yml template that I can edit" option. Select Set Up Project.   You will then see a list of sample configurations. Scroll down within the window until you see Node (Advanced), then Select.        You will be taken to the in-app configuration editor. The project actually uses Yarn, so you will need to edit the following steps so that they use yarn instead of npm, like so:   steps:
# Checkout the code as the first step.
  - checkout
# Next, the node orb's install-packages step will install the dependencies from a package.json.
# The orb install-packages step will also automatically cache them for faster future runs.
  - node/install-packages:
    # If you are using yarn, change the line below from "npm" to "yarn"
    pkg-manager: yarn
  - run:
    name: Run tests
    command: yarn test     After you’ve made these changes, go ahead and select Commit and Run. This will commit the changes in a new feature branch called circleci-project-setup and trigger a new pipeline. Select Dashboard from the web app side bar, and use the filters to find your project to watch your pipeline run.       Feel free to take a look at the steps run in the pipeline by expanding the green Success status and opening the build-and-test job.                 Fork the repository if you are using GitHub, or import to Bitbucket or GitLab using the repository URL: https://github.com/CircleCI-Public/circleci-react-test-splitting-tutorial   Open the  CircleCI web app. Select your org from the user homepage, then select Projects in the sidebar.   Select Create Project and follow the in-app instructions to create a new project for your clone of the sample project.   You will be taken to the in-app configuration editor. Change the config template by clicking Change: Hello World. You will then be presented a list of sample configurations. Scroll down within the window until you see Node (Advanced), then Select.        The project actually uses Yarn, so you will need to edit the build-and-test job definition in the config so that it uses yarn instead of npm. Use the in-app editor to edit the step like so:   steps:
# Checkout the code as the first step.
  - checkout
# Next, the node orb's install-packages step will install the dependencies from a package.json.
# The orb install-packages step will also automatically cache them for faster future runs.
  - node/install-packages:
    # If you are using yarn, change the line below from "npm" to "yarn"
    pkg-manager: yarn
  - run:
    name: Run tests
    command: yarn test     After you’ve made these changes, go ahead and select Commit and Run. This will commit the changes in a new feature branch called circleci-project-setup and trigger a new pipeline. Select Dashboard from the web app side bar, and use the filters to find your project to watch your pipeline run.       Take a look at the steps run in the pipeline by expanding the green Success status and opening the build-and-test job.                 2. Set up test splitting   If you downloaded a local copy of the code repository, carry out the following steps in your text editor to modify .circleci/config.yml. Alternatively, if you are using GitHub OAuth or Bitbucket Cloud, you may edit the project’s configuration in the CircleCI web app by selecting a branch, and then clicking Edit Config.     In the build-and-test job, after the docker key, add the parallelism key with a value of 5.   parallelism: 5    For test splitting to work, the parallelism key has to be set to a value greater than 1, ensuring that the tests are distributed across multiple executors. Otherwise, if the value is 1, tests will be run sequentially within the same environment, and you do not get the benefit of reducing test times.   In this example, five separate Docker containers will spin up.    Within the steps key of the build-and-test job, make the following updates:    After the node/install-packages step, add a run command to create a new subdirectory named junit:   - run: mkdir ~/junit    Test results, including timing data, will be saved in this subdirectory of the executor.    Replace the existing run command named Run tests with the following:   - run:
      name: Test application
      command: |
          TEST=$(circleci tests glob "src/__tests__/*.js")
          echo "$TEST" | circleci tests run --command="xargs yarn test" --split-by=timings    This step uses the CircleCI CLI to pass in the location of the test suites and configure how the tests are split. You can use the circleci tests glob command to select the test files:     First, you want those that match the src/__tests__/*.js globbing pattern, that is, any .js files located in src/__tests__ and any of its subdirectories.   Then, the matching files are piped into circleci tests run, which creates the test split groupings and then runs your tests.   The --split-by=timings flag indicates that the tests should be split according to timing data. For other test splitting options, see the  Test splitting and parallelism page.     The circleci tests commands (glob and run) cannot be run locally via the CLI as they require information that only exists within a CircleCI container.            Add a step to copy the test results (saved as JUnit XML files) to the ~/junit subdirectory created in an earlier step. Using the when attribute with a value of always will execute this particular step always regardless of whether the preceding steps were executed successfully or not.   - run:
    command: cp junit.xml ~/junit/
    when: always     Finally, add a store_test_results step:   - store_test_results:
    path: ~/junit    This step uploads the test data to CircleCI and is required to split tests by timing data. This step allows test data to be accessible on the Tests tab of the job in the CircleCI web app, and can be helpful for debugging if tests fail. To read more about the Tests tab and test insights in CircleCI, visit the  Collect test data page.         Here is a full copy of the updated configuration:    version: 2.1

orbs:
    node: circleci/node@4.7

jobs:
    build-and-test:
        docker:
            - image: cimg/node:16.10
        parallelism: 5
        steps:
            - checkout
            - node/install-packages:
                pkg-manager: yarn
            - run: mkdir ~/junit
            - run:
                name: Test application
                command: |
                    TEST=$(circleci tests glob "src/__tests__/*.js")
                    echo "$TEST" | circleci tests run --command="xargs yarn test" --split-by=timings
            - run:
                command: cp junit.xml ~/junit/
                when: always
            - store_test_results:
                path: ~/junit

workflows:
    sample:
      jobs:
        - build-and-test    Once you have made these changes to .circleci/config.yml, go ahead and push the changes. This triggers the pipeline and runs the tests again, but this time the results are stored.     3. View results   In the CircleCI web app, take a look at the steps in the recently triggered pipeline by clicking on the Success status and opening the build-and-test job.     You may have noticed that this pipeline ran more quickly compared to earlier. The Node orb automatically caches node packages by default, so a cache exists from the earlier pipeline run. This helps speed up the install step.   You should also now see five parallel runs, as a result of the number of execution environments set by the parallelism key. Each Docker environment (node) is labeled by its index number (so you have numbers 0 through 4). You can select each node to see the individual steps that executed in each parallel run. The environment you are viewing will be highlighted in green.       You might also notice that the parallel run times are not all equal, nor is the overall run time of the pipeline cut down to precisely 1/5. Each executor runs the same steps, but there is a difference in terms of which executor runs which tests. There may also be some variation in how long each executor takes to spin up.   Splitting tests by timing is the best way to ensure tests are split as evenly as possible and parallel runs finish around the same time. With that said, you may need to play around with the parallelism level to find the number that works best for you.    In any of the parallel runs, open the Test application step. You will see which test suites and how many individual tests were executed in this particular run. You will also see this message in the output:   Error reading historical timing data: file does not exist
Requested weighting by historical based timing, but they are not present. Falling back to weighting by name.    CircleCI defaults to splitting tests by name. As this is the first time you are storing test data from the pipeline, CircleCI does not yet have timing data to work with.    Open the Timing tab in the job. This tab provides a visualization of how each parallel run did relative to each other.       The chart indicates which three steps within each run took the longest to complete. Hover over each section of the bar to see those respective steps.   You may also notice on the upper right corner within the Timing tab an indicator for idle time. In this pipeline, there was a total of 11 seconds between each finished run and the end of the longest run.        4. Split by timing data   In the previous step, you saw that test splitting defaulted to splitting tests based on name. Now that test data has been saved, CircleCI can now split your tests by timing the next time the pipeline runs.     Commit a change in your project to trigger the pipeline again.  For example, you can try upgrading to a newer version of the Node orb, such as circleci/node@5.0.2. Or you may choose to trigger a pipeline. On the Pipelines page in the CircleCI web app, select Trigger Pipeline.    Open the pipeline in the web app, and view the Test application step. This time, you should see Autodetected filename timings. in the output. This means that CircleCI is now splitting tests based on available timing data from preceding runs.        Lastly, open the Timing tab. In this particular example, you might find that the time taken for the testing step to complete is not drastically different from earlier, when tests were split by name. However, you may notice that the idle time between runs has now been cut down to only five seconds, compared to 11 seconds from earlier.       Conclusion   In this tutorial, you have configured your pipeline to split tests by timing data using parallelism and circleci tests commands. By storing test results, you also enabled access to test data and insights for further analysis.     Next steps     For a more in-depth discussion of the demo used in this tutorial, read our  A Guide to Test Splitting blog post.   Learn about  Test insights available in CircleCI.     Suggest an edit to this pageMake a contribution Learn how to contributeStill need help? Ask the CircleCI community Join the research community Visit our Support site DocsTerms of UsePrivacy PolicyCookie PolicySecurity© 2025 Circle Internet Services, Inc., All Rights Reserved.\n\nUsing Docker? Authenticating Docker pulls from image registries is recommended when using the Docker execution environment. Authenticated pulls allow access to private Docker images, and may also grant higher rate limits, depending on your registry provider. For further information see  Using Docker authenticated pulls.  version: 2.1

orbs:
  node: circleci/node@4.7

jobs:
  build-and-test:
    docker:
      - image: cimg/node:16.10
    steps:
      - checkout
      - node/install-packages:
          pkg-manager: npm
      - run:
          name: Run tests
          command: npm test

workflows:
  sample:
    jobs:
      - build-and-test      Fork the repository on GitHub.   Open the  CircleCI web app. Make sure you are in the correct organization (for example, https://app.circleci.com/pipelines/github/<your-vcs-username>), then navigate to Projects.   Find the sample app on the list of projects, and select Set Up Project.   You will be prompted to select your config.yml file. In the window, select the "Fast: Take me to a config.yml template that I can edit" option. Select Set Up Project.   You will then see a list of sample configurations. Scroll down within the window until you see Node (Advanced), then choose Select.        You will be taken to the in-app configuration editor. The project actually uses Yarn, so you will need to edit the following steps so that they use yarn instead of npm, like so:   steps:
# Checkout the code as the first step.
  - checkout
# Next, the node orb's install-packages step will install the dependencies from a package.json.
# The orb install-packages step will also automatically cache them for faster future runs.
  - node/install-packages:
    # If you are using yarn, change the line below from "npm" to "yarn"
    pkg-manager: yarn
  - run:
    name: Run tests
    command: yarn test     After you have made these changes, go ahead and select Commit and Run. This will commit the changes in a new feature branch called circleci-project-setup and trigger a new pipeline. Select Dashboard from the web app side bar, and use the filters to find your project to watch your pipeline run.       Feel free to take a look at the steps run in the pipeline by expanding the green Success status and opening the build-and-test job.             steps:
# Checkout the code as the first step.
  - checkout
# Next, the node orb's install-packages step will install the dependencies from a package.json.
# The orb install-packages step will also automatically cache them for faster future runs.
  - node/install-packages:
    # If you are using yarn, change the line below from "npm" to "yarn"
    pkg-manager: yarn
  - run:
    name: Run tests
    command: yarn test         Import the project code into Bitbucket, using the repo URL: https://github.com/CircleCI-Public/circleci-react-test-splitting-tutorial   Open the  CircleCI web app. Make sure you are in the correct organization (for example, https://app.circleci.com/pipelines/bitbucket/<your-vcs-username>), then navigate to Projects.   Find the sample app on the list of projects, and select Set Up Project.   You will be prompted to select your config.yml file. In the window, select the "Fast: Take me to a config.yml template that I can edit" option. Select Set Up Project.   You will then see a list of sample configurations. Scroll down within the window until you see Node (Advanced), then Select.        You will be taken to the in-app configuration editor. The project actually uses Yarn, so you will need to edit the following steps so that they use yarn instead of npm, like so:   steps:
# Checkout the code as the first step.
  - checkout
# Next, the node orb's install-packages step will install the dependencies from a package.json.
# The orb install-packages step will also automatically cache them for faster future runs.
  - node/install-packages:
    # If you are using yarn, change the line below from "npm" to "yarn"
    pkg-manager: yarn
  - run:
    name: Run tests
    command: yarn test     After you’ve made these changes, go ahead and select Commit and Run. This will commit the changes in a new feature branch called circleci-project-setup and trigger a new pipeline. Select Dashboard from the web app side bar, and use the filters to find your project to watch your pipeline run.       Feel free to take a look at the steps run in the pipeline by expanding the green Success status and opening the build-and-test job.             steps:
# Checkout the code as the first step.
  - checkout
# Next, the node orb's install-packages step will install the dependencies from a package.json.
# The orb install-packages step will also automatically cache them for faster future runs.
  - node/install-packages:
    # If you are using yarn, change the line below from "npm" to "yarn"
    pkg-manager: yarn
  - run:
    name: Run tests
    command: yarn test          Fork the repository if you are using GitHub, or import to Bitbucket or GitLab using the repository URL: https://github.com/CircleCI-Public/circleci-react-test-splitting-tutorial   Open the  CircleCI web app. Select your org from the user homepage, then select Projects in the sidebar.   Select Create Project and follow the in-app instructions to create a new project for your clone of the sample project.   You will be taken to the in-app configuration editor. Change the config template by clicking Change: Hello World. You will then be presented a list of sample configurations. Scroll down within the window until you see Node (Advanced), then Select.        The project actually uses Yarn, so you will need to edit the build-and-test job definition in the config so that it uses yarn instead of npm. Use the in-app editor to edit the step like so:   steps:
# Checkout the code as the first step.
  - checkout
# Next, the node orb's install-packages step will install the dependencies from a package.json.
# The orb install-packages step will also automatically cache them for faster future runs.
  - node/install-packages:
    # If you are using yarn, change the line below from "npm" to "yarn"
    pkg-manager: yarn
  - run:
    name: Run tests
    command: yarn test     After you’ve made these changes, go ahead and select Commit and Run. This will commit the changes in a new feature branch called circleci-project-setup and trigger a new pipeline. Select Dashboard from the web app side bar, and use the filters to find your project to watch your pipeline run.       Take a look at the steps run in the pipeline by expanding the green Success status and opening the build-and-test job.             steps:
# Checkout the code as the first step.
  - checkout
# Next, the node orb's install-packages step will install the dependencies from a package.json.
# The orb install-packages step will also automatically cache them for faster future runs.
  - node/install-packages:
    # If you are using yarn, change the line below from "npm" to "yarn"
    pkg-manager: yarn
  - run:
    name: Run tests
    command: yarn test      parallelism: 5  - run: mkdir ~/junit  - run:
      name: Test application
      command: |
          TEST=$(circleci tests glob "src/__tests__/*.js")
          echo "$TEST" | circleci tests run --command="xargs yarn test" --split-by=timings  The circleci tests commands (glob and run) cannot be run locally via the CLI as they require information that only exists within a CircleCI container.  - run:
    command: cp junit.xml ~/junit/
    when: always  - store_test_results:
    path: ~/junit  version: 2.1

orbs:
    node: circleci/node@4.7

jobs:
    build-and-test:
        docker:
            - image: cimg/node:16.10
        parallelism: 5
        steps:
            - checkout
            - node/install-packages:
                pkg-manager: yarn
            - run: mkdir ~/junit
            - run:
                name: Test application
                command: |
                    TEST=$(circleci tests glob "src/__tests__/*.js")
                    echo "$TEST" | circleci tests run --command="xargs yarn test" --split-by=timings
            - run:
                command: cp junit.xml ~/junit/
                when: always
            - store_test_results:
                path: ~/junit

workflows:
    sample:
      jobs:
        - build-and-test    Error reading historical timing data: file does not exist
Requested weighting by historical based timing, but they are not present. Falling back to weighting by name.\n\n\n\nChangelog
      
        
          Keep up to date with our latest releases and enhancements.

        
      
      
        

  
    
    
      
        
        Subscribe
      
    
  
    
    
      
        
        View roadmap
      
    
  

      
    
    
      
        
          

        

        
          





          
        
      
    
  





  
    
      
        
          
            








  
    
      Apr 16, 2025
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    
  
  
    
  
  
    
      Apr 16, 2025
    
    
      
        
        
        MCP Server Updated w/ Config Validation and Flaky Test Detection    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    

    
      
        
          
            Two new tools made available in the CircleCI MCP Server:

          
          
            
              
              


Keep reading 

            
          
        
        
          
            
              
                Two new tools made available in the CircleCI MCP Server:


  We added the config_helper tool to assist with CircleCI configuration tasks such as providing support for validating .circleci/config.yml files, recommending fixes, and suggesting best practice improvements.
  We added the find_flaky_tests tool to identify and analyze flaky tests in CircleCI projects, supporting both project URL and local git repository context.


Download the MCP Server here

              
              
              


Collapse 

            
          
        
      
    
      
        
      
  

          
        
          
            








  
    
      Apr 11, 2025
    
    
      
        
        


  
    
    
    
    
    
    Maintenance
  


      
    
  
  
    
  
  
    
      Apr 11, 2025
    
    
      
        
        
        Server Release 4.7.3    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Maintenance
  


      
    

    
      
        
          
            Updates

  oidc-tasks-service runs migrations before it’s main container is deployed
  Remote Docker and Machine jobs can now assume an IAM role by configuring machine_provisioner.providers.ec2.assumedRoleArn in your values.yaml


Bug Fixes

  /workflow-run/ route has been added to kong. Links for approval jobs will now be correctly routed on GHE
  The OIDC plugin now supports custom certificates
  A docker-provisioner custom config can not be provided in your helm upgrade command via --set-file
  upgraded nextjs to resolve related CVEs


          
          
        
        
      
    
      
        
          
          



  
  
  
  
  
  Server

        
      
  

          
        
          
            








  
    
      Apr 09, 2025
    
    
      
        
        


  
    
    
    
    
    
    New feature
  


      
    
  
  
    
  
  
    
      Apr 09, 2025
    
    
      
        
        
        MCP Server for CircleCI now available    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    New feature
  


      
    

    
      
        
          
            We’ve recently rolled out the CircleCI Model Context Protocol (MCP) Server. This enables developers using tools (Claude Code, Cursor, Windsurf, etc.) that support the MCP protocol to interact with CircleCI.

          
          
            
              
              


Keep reading 

            
          
        
        
          
            
              
                We’ve recently rolled out the CircleCI Model Context Protocol (MCP) Server. This enables developers using tools (Claude Code, Cursor, Windsurf, etc.) that support the MCP protocol to interact with CircleCI.

Agents and AI tools can now fulfill developer requests, such as “Find the latest failed pipeline on my branch and get logs.” This eliminates the need to navigate through the UI or use complex CLI commands to debug and solve problems.
This is the initial release, and we will continuously be updating what the server can do over the coming weeks. If you would like to contribute, please don’t hesitate to put in a pull request.

For more details and example use cases, check out our documentation and our blog post.

For questions or feedback, please open an issue on the GitHub repository.

              
              
              


Collapse 

            
          
        
      
    
      
        
      
  

          
        
          
            








  
    
      Apr 09, 2025
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    
  
  
    
  
  
    
      Apr 09, 2025
    
    
      
        
        
        Changes to dropdown options in "Add trigger" and "Add pipeline" forms    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    

    
      
        
          
            The “Trigger type” dropdown in the “Add trigger” form (Project Settings > Triggers) has been updated with the following changes:

          
          
            
              
              


Keep reading 

            
          
        
        
          
            
              
                The “Trigger type” dropdown in the “Add trigger” form (Project Settings > Triggers) has been updated with the following changes:


  “GitHub App” is now the default pre-selected  option for all organization types
  For organizations using CircleCI’s GitHub OAuth App integration, the dropdown now displays only the three valid trigger options: GitHub App, Custom Webhook, and Schedule




Similarly. the “Integration” dropdown in the “Add pipeline” form (Project Settings > Pipelines) has been updated with the following changes:


  “GitHub App” is now the default pre-selected  option for all organization types
  For organizations using CircleCI’s GitHub OAuth App integration, the dropdown now only includes the option “GitHub App”




              
              
              


Collapse 

            
          
        
      
    
      
        
      
  

          
        
          
            








  
    
      Apr 09, 2025
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    
  
  
    
  
  
    
      Apr 09, 2025
    
    
      
        
        
        Update - Breaking Change- April 28th 2025 - Skipped Status Will Now Return Success     
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    

    
      
        
          
            Clarification - All VCS status checks are impacted.

          
          
            
              
              


Keep reading 

            
          
        
        
          
            
              
                Clarification - All VCS status checks are impacted.

What is changing?

Status checks previously sent skipped job statuses as failures, now they will be sent as successful checks. This is to align with GitHub’s definition of skipped status.

This means that “skipped” will not prevent pull request merging, even if it is a required check.

List workflow jobs v2 API previously returned jobs with blocked statuses for jobs that never ran, now they will return as a skipped status.

Why are we doing this?

To improve the lifecycle of jobs and enable features such as finally jobs, all jobs will transition from blocked to one of the terminal states 
(success, failed, canceled, skipped, unauthorized).

When will it happen?

28th April 2025

              
              
              


Collapse 

            
          
        
      
    
      
        
      
  

          
        
          
            








  
    
      Apr 08, 2025
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    
  
  
    
  
  
    
      Apr 08, 2025
    
    
      
        
        
        CIRCLE_PULL_REQUEST env variable now populated for GitHub App pipelines     
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    

    
      
        
          
            The environment variable CIRCLE_PULL_REQUEST is now populated for all pipelines triggered from GitHub, regardless of integration type, whenever the triggering commit is associated with a pull request.

          
          
            
              
              


Keep reading 

            
          
        
        
          
            
              
                The environment variable CIRCLE_PULL_REQUEST is now populated for all pipelines triggered from GitHub, regardless of integration type, whenever the triggering commit is associated with a pull request.

For GitHub App pipelines specifically, the pipeline variable pipeline.event.context.github.pr_url is also populated with the same information.

Previously, the CIRCLE_PULL_REQUEST environment variable was only populated for pipelines that used CircleCI’s GitHub OAuth App integration.

              
              
              


Collapse 

            
          
        
      
    
      
        
      
  

          
        
          
            








  
    
      Apr 08, 2025
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    
  
  
    
  
  
    
      Apr 08, 2025
    
    
      
        
        
        Auto-populate trigger pipeline modal parameters based on selected pipeline.     
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    

    
      
        
          
            Parameters in the trigger pipeline modal now automatically populate based on the pipeline selected in the dropdown menu at the top of the form.

          
          
            
              
              


Keep reading 

            
          
        
        
          
            
              
                Parameters in the trigger pipeline modal now automatically populate based on the pipeline selected in the dropdown menu at the top of the form.

Currently, this feature is only available for pipelines that are configured with CircleCI’s GitHub App integration. For pipelines that use CircleCI’s GitHub OAuth App integration, parameters continue to auto-populate based on the config file used in the most recent pipeline run, regardless of whether it matches the pipeline that has been selected.

              
              
              


Collapse 

            
          
        
      
    
      
        
      
  

          
        
          
            








  
    
      Apr 03, 2025
    
    
      
        
        


  
    
    
    
    
    
    Maintenance
  


      
    
  
  
    
  
  
    
      Apr 03, 2025
    
    
      
        
        
        Docker Executor Infrastructure Upgrade - Complete    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Maintenance
  


      
    

    
      
        
          
            The host OS that Docker jobs run on is being upgraded to support new features and ongoing security and bug patches. This upgrade has now been rolled out to all customers.

          
          
            
              
              


Keep reading 

            
          
        
        
          
            
              
                The host OS that Docker jobs run on is being upgraded to support new features and ongoing security and bug patches. This upgrade has now been rolled out to all customers.

Learn more about this change in Discuss: Docker Executor Infrastructure Upgrade.

              
              
              


Collapse 

            
          
        
      
    
      
        
      
  

          
        
          
            








  
    
      Mar 28, 2025
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    
  
  
    
  
  
    
      Mar 28, 2025
    
    
      
        
        
        CI Skip and Only build PRs will no longer create pipelines    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    

    
      
        
          
            What is changing?

          
          
            
              
              


Keep reading 

            
          
        
        
          
            
              
                What is changing?

Workflows that were previously marked as not_run—due to CI skip conditions or the “only build PRs” feature flag—will no longer create pipelines. These pipelines will not appear in the UI or API. However, the trigger event will still be recorded in the audit logs.

Why are we doing this?

Showing skipped pipelines clutters the UI and API with information that’s irrelevant to users. This behavior is also inconsistent with other VCS integrations. Removing these entries increases consistency and improves the overall user experience.

When will it happen?

14th April 2025

              
              
              


Collapse 

            
          
        
      
    
      
        
      
  

          
        
          
            








  
    
      Mar 28, 2025
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    
  
  
    
  
  
    
      Mar 28, 2025
    
    
      
        
        
        Display "Authorize" button on the navbar if user has not authorized GitHub App    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    

    
      
        
          
            When using the GitHub App integration, each user needs to “authorize” the CircleCI GitHub App for their pipelines to be correctly attributed to them. Not doing so means:

          
          
            
              
              


Keep reading 

            
          
        
        
          
            
              
                When using the GitHub App integration, each user needs to “authorize” the CircleCI GitHub App for their pipelines to be correctly attributed to them. Not doing so means:


  their pipelines won’t have access to contexts
  their pipelines won’t run if they have enabled the setting “Prevent unregistered user spend”
  they can’t manually trigger pipelines through the UI


Previously, the “Authorize” button was only available in the Pipeline and Trigger forms - two pages that most users don’t commonly visit.

In order to make it as easy as possible for users to know that they are not “authorized” and to take action on it, we introduced a call to action on the navigation bar.

The “Authorize” button appears only when the organization has the GitHub App installed, and the current user is not yet authorized.



IMPORTANT: This change is being released incrementally to selected organizations to ensure optimal user experience before full deployment.

              
              
              


Collapse 

            
          
        
      
    
      
        
      
  

          
        
          
            








  
    
      Mar 28, 2025
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    
  
  
    
  
  
    
      Mar 28, 2025
    
    
      
        
        
        Disable SSH Rerun by Project    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    

    
      
        
          
            Project admins can now disable SSH rerun for individual projects via Project Settings>Advanced or the CircleCI v2 API.

          
          
        
        
      
    
      
        
      
  

          
        
          
            








  
    
      Mar 27, 2025
    
    
      
        
        


  
    
    
    
    
    
    Maintenance
  


      
    
  
  
    
  
  
    
      Mar 27, 2025
    
    
      
        
        
        Japanese Documentation Pages to be Discontinued    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Maintenance
  


      
    

    
      
        
          
            Effective April 1, 2025, all Japanese versions of our public documentation will be removed from the site. The language switcher will also be discontinued.

          
          
            
              
              


Keep reading 

            
          
        
        
          
            
              
                Effective April 1, 2025, all Japanese versions of our public documentation will be removed from the site. The language switcher will also be discontinued.

Please use the English version of these pages for the most accurate and up-to-date information about using CircleCI.

If you have questions or feedback about this change, please visit our community forum.

              
              
              


Collapse 

            
          
        
      
    
      
        
      
  

          
        
          
            








  
    
      Mar 27, 2025
    
    
      
        
        


  
    
    
    
    
    
    Maintenance
  


      
    
  
  
    
  
  
    
      Mar 27, 2025
    
    
      
        
        
        Docker Executor Infrastructure Upgrade - Docker ARM and IP Ranges    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Maintenance
  


      
    

    
      
        
          
            The host OS that Docker jobs run on is being upgraded to support new features and ongoing security and bug patches. This upgrade is being applied to jobs using Docker ARM and IP ranges from now through April 1.

          
          
            
              
              


Keep reading 

            
          
        
        
          
            
              
                The host OS that Docker jobs run on is being upgraded to support new features and ongoing security and bug patches. This upgrade is being applied to jobs using Docker ARM and IP ranges from now through April 1.

Learn more about this change in Discuss: Docker Executor Infrastructure Upgrade.

              
              
              


Collapse 

            
          
        
      
    
      
        
      
  

          
        
          
            








  
    
      Mar 26, 2025
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    
  
  
    
  
  
    
      Mar 26, 2025
    
    
      
        
        
        UI changes to the pipelines page    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    

    
      
        
          
            We have introduced some UI changes to the pipelines page:

          
          
            
              
              


Keep reading 

            
          
        
        
          
            
              
                We have introduced some UI changes to the pipelines page:




  
    The column previously named “Project” was renamed into “Pipeline”

    It displays pipeline name, pipeline number, and (only when looking at the All pipelines view) project name
  
  
    The column previously named “Trigger event” was renamed into “Checkout source”

    It continues to show the same information as before, but the avatar now shows the profile picture of the commit author, if that information is available. If it isn’t (this is currently the case for OAuth pipelines), the avatar does not show.
  To avoid this inconsistency, we plan on hiding the avatar also for other types of pipelines.
  
  
    A new column “Trigger event” was added

    It shows what event that triggered a pipeline (Push, Pull request, API, …). The avatar indicates who triggered the event, with a tooltip showing the username on hover.
  
  
    The headers of columns Pipeline and Trigger event each include tooltips, informing users that:
    
      it’s now possible to have multiple pipelines in the same project
      more GitHub trigger events options are now available
    

    These tooltips are visible to orgs that integrate with our GitHub OAuth app integration or GitHub App/GitLab/Bitbucket Data Center integrations. They are not visible to organizations that integrate with Bitbucket Cloud..
  


These changes are currently in preview, and additional improvements will be made in the coming weeks. If you have any feedback, please comment on this post on our community forum.

              
              
              


Collapse 

            
          
        
      
    
      
        
      
  

          
        
          
            








  
    
      Mar 26, 2025
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    
  
  
    
  
  
    
      Mar 26, 2025
    
    
      
        
        
        Context restriction APIs marked GA    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    

    
      
        
          
            The context restriction APIs have been promoted from experimental to generally available. Authorized users can now create, read, and delete project- and expression-based context restrictions via API. Security group context restrictions are not supported yet. Read the context API documentation.

          
          
        
        
      
    
      
        
          
          



  
  
  
  
  
  Dev tools

        
      
  

          
        
          
            








  
    
      Mar 18, 2025
    
    
      
        
        


  
    
    
    
    
    
    Maintenance
  


      
    
  
  
    
  
  
    
      Mar 18, 2025
    
    
      
        
        
        Runner Release 3.1.3    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Maintenance
  


      
    

    
      
        
          
            Runner Release 3.1.2
Machine Runner:

          
          
            
              
              


Keep reading 

            
          
        
        
          
            
              
                Runner Release 3.1.2
Machine Runner:


  Fixed a bug where an error downloading the task agent binary was not correctly propagated, causing the runner to get stuck without retrying the download and requiring a manual restart to unblock.


              
              
              


Collapse 

            
          
        
      
    
      
        
          
          



  
  
  
  
  
  Runner

        
      
  

          
        
          
            








  
    
      Mar 18, 2025
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    
  
  
    
  
  
    
      Mar 18, 2025
    
    
      
        
        
        New context timeout error messaging    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    

    
      
        
          
            A new error message has been added to the contexts page to help users differentiate between page timeouts and permission errors. Previously, it was unclear to the user whether page load issues could be resolved with a refresh. Now, users who have the correct permissions will see “Please try again in a few minutes.” if contexts take a long time to load.

          
          
        
        
      
    
      
        
      
  

          
        
          
            








  
    
      Mar 17, 2025
    
    
      
        
        


  
    
    
    
    
    
    New feature
  


      
    
  
  
    
  
  
    
      Mar 17, 2025
    
    
      
        
        
        Project overview page    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    New feature
  


      
    

    
      
        
          
            We’ve introduced a new project overview page, which allows users to get a quick sense of the health of their pipelines and see what changes have recently been deployed for a project all in one place. Users can access this page by clicking the Overview link from the Organization Home page or Projects page.

          
          
            
              
              


Keep reading 

            
          
        
        
          
            
              
                We’ve introduced a new project overview page, which allows users to get a quick sense of the health of their pipelines and see what changes have recently been deployed for a project all in one place. Users can access this page by clicking the Overview link from the Organization Home page or Projects page.

If you have any feedback on how we can improve this overview, please use the survey popup in the bottom right corner of the page to let us know!



              
              
              


Collapse 

            
          
        
      
    
      
        
      
  

          
        
          
            








  
    
      Mar 15, 2025
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    
  
  
    
  
  
    
      Mar 15, 2025
    
    
      
        
        
        Manage GitHub App installation from the organization settings page "VCS Connections"    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    

    
      
        
          
            The tab “VCS” in Organization Settings has been renamed into “VCS Connections”, and it now includes a section dedicated to the GitHub App integration.

          
          
            
              
              


Keep reading 

            
          
        
        
          
            
              
                The tab “VCS” in Organization Settings has been renamed into “VCS Connections”, and it now includes a section dedicated to the GitHub App integration.

If the CircleCI GitHub App is not installed, it provides an overview of the functionality enabled by the App.


If the CircleCI GitHub App is installed, it shows which GitHub organization it’s connected to, and lets admin access the configuration page


The settings button redirects to the GitHub installation page. 
The delete button opens a modal which requires additional user input to confirm uninstallation of the GitHub App. Both actions are restricted to organization admins only.

              
              
              


Collapse 

            
          
        
      
    
      
        
      
  

          
        
          
            








  
    
      Mar 14, 2025
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    
  
  
    
  
  
    
      Mar 14, 2025
    
    
      
        
        
        Prevent non-admin users from installing the GitHub App    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    

    
      
        
          
            The GitHub App pipeline and trigger forms have been updated to prevent non-admin users from attempting to install the CircleCI GitHub App.

          
          
        
        
      
    
      
        
      
  

          
        
          
            








  
    
      Mar 12, 2025
    
    
      
        
        


  
    
    
    
    
    
    Maintenance
  


      
    
  
  
    
  
  
    
      Mar 12, 2025
    
    
      
        
        
        Added automatic redirect for logged-out users     
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Maintenance
  


      
    

    
      
        
          
            Users who land on the user homepage while logged out are now automatically redirected to the login page.

          
          
        
        
      
    
      
        
      
  

          
        
          
            








  
    
      Mar 12, 2025
    
    
      
        
        


  
    
    
    
    
    
    New feature
  


      
    
  
  
    
  
  
    
      Mar 12, 2025
    
    
      
        
        
        Avoid commit conflicts in your pipelines with serial-jobs    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    New feature
  


      
    

    
      
        
          
            The queue orb was previously used to avoid multiple pipeline race conditions and conflicts. Serial-job provides native support for the functionality provided by the queue orb. Overtime we will expand the use cases we support to cover additional challenges like multi-job or workflows. The first release is serial-group for individual jobs.

          
          
            
              
              


Keep reading 

            
          
        
        
          
            
              
                The queue orb was previously used to avoid multiple pipeline race conditions and conflicts. Serial-job provides native support for the functionality provided by the queue orb. Overtime we will expand the use cases we support to cover additional challenges like multi-job or workflows. The first release is serial-group for individual jobs.

This allows an individual job to be serialized across the organization, project or branch based on the parameters you provide. Serialization will ensure the jobs are executed in the order in which the pipelines are started via commit, api or other triggering method.

To learn more about your options see the documentation.

              
              
              


Collapse 

            
          
        
      
    
      
        
      
  

          
        
          
            








  
    
      Mar 12, 2025
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    
  
  
    
  
  
    
      Mar 12, 2025
    
    
      
        
        
        Show in-app instructions for how to delete OAuth trigger    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    

    
      
        
          
            A growing number of GitHub OAuth customers have been looking to stop building their OAuth pipelines in favour of the new GitHub App pipelines which provide a broader range of triggering options.

          
          
            
              
              


Keep reading 

            
          
        
        
          
            
              
                A growing number of GitHub OAuth customers have been looking to stop building their OAuth pipelines in favour of the new GitHub App pipelines which provide a broader range of triggering options.

This is currently a manual process, which requires making changes in GitHub.

To avoid users having to refer to the docs for instructions, we added a “delete” icon next to the OAuth trigger (Project Settings > Triggers), which opens a modal containing instructions for how to disable the OAuth trigger manually.



              
              
              


Collapse 

            
          
        
      
    
      
        
      
  

          
        
          
            








  
    
      Mar 11, 2025
    
    
      
        
        


  
    
    
    
    
    
    Maintenance
  


      
    
  
  
    
  
  
    
      Mar 11, 2025
    
    
      
        
        
        Fixed infinite loading spinner on Pipelines page    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Maintenance
  


      
    

    
      
        
          
            A bug that was causing the loading spinner to spin infinitely when no additional pipelines were available after clicking the ‘See more’ button on the pipelines page has been fixed.

          
          
        
        
      
    
      
        
      
  

          
        
          
            








  
    
      Mar 06, 2025
    
    
      
        
        


  
    
    
    
    
    
    Maintenance
  


      
    
  
  
    
  
  
    
      Mar 06, 2025
    
    
      
        
        
        Bug fix when selecting repository for new projects    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Maintenance
  


      
    

    
      
        
          
            Users of CircleCI’s GitHub App integration would occasionally not be able to see a list of repositories to choose from when creating a new project.  This bug has been fixed.

          
          
        
        
      
    
      
        
      
  

          
        
          
            








  
    
      Mar 06, 2025
    
    
      
        
        


  
    
    
    
    
    
    Maintenance
  


      
    
  
  
    
  
  
    
      Mar 06, 2025
    
    
      
        
        
        Timing tab bug fixed    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Maintenance
  


      
    

    
      
        
          
            A bug that was causing the “Timing” tab in the CircleCI web app to show UUIDs instead of a string of the step name has been fixed.

          
          
        
        
      
    
      
        
      
  

          
        
          
            








  
    
      Mar 06, 2025
    
    
      
        
        


  
    
    
    
    
    
    Maintenance
  


      
    
  
  
    
  
  
    
      Mar 06, 2025
    
    
      
        
        
        Bug causing full dark screen on loading modal fixed    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Maintenance
  


      
    

    
      
        
          
            A bug that caused a nearly full dark screen when creating a new project in organizations that integrate with CircleCI’s GitHub App has now been fixed.

          
          
        
        
      
    
      
        
      
  

          
        
          
            








  
    
      Mar 04, 2025
    
    
      
        
        


  
    
    
    
    
    
    Maintenance
  


      
    
  
  
    
  
  
    
      Mar 04, 2025
    
    
      
        
        
        Release Agent Release 1.3.7    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Maintenance
  


      
    

    
      
        
          
            Changes:

  Patched critical CVEs


See more details here.

          
          
        
        
      
    
      
        
      
  

          
        
          
            








  
    
      Mar 04, 2025
    
    
      
        
        


  
    
    
    
    
    
    Maintenance
  


      
    
  
  
    
  
  
    
      Mar 04, 2025
    
    
      
        
        
        Minor changes to Pipeline Editor page    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Maintenance
  


      
    

    
      
        
          
            

  Added quick-start options to make it easier to understand what types of questions can be asked
  Loading screen adjusted to be smoother when a new pipeline is triggered
  Minor copy changes


          
          
        
        
      
    
      
        
      
  

          
        
          
            








  
    
      Mar 03, 2025
    
    
      
        
        


  
    
    
    
    
    
    Maintenance
  


      
    
  
  
    
  
  
    
      Mar 03, 2025
    
    
      
        
        
        OIDC signing keys updated    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Maintenance
  


      
    

    
      
        
          
            CircleCI periodically updates the keys used to sign OIDC tokens in alignment with security best practices. No customer action is required to continue using OIDC with previously configured services.

          
          
        
        
      
    
      
        
      
  

          
        
          
            








  
    
      Mar 03, 2025
    
    
      
        
        


  
    
    
    
    
    
    New feature
  


      
    
  
  
    
  
  
    
      Mar 03, 2025
    
    
      
        
        
        Single Sign On for GitHub OAuth and Bitbucket Cloud    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    New feature
  


      
    

    
      
        
          
            Single sign on (SSO) is now available for Cloud Scale plan customers with CircleCI organizations connected to GitHub OAuth and Bitbucket Cloud. Learn how to connect your identity provider and enforce SSO for users in your org.

          
          
        
        
      
    
      
        
      
  

          
        
          
            








  
    
      Feb 28, 2025
    
    
      
        
        


  
    
    
    
    
    
    Maintenance
  


      
    
  
  
    
  
  
    
      Feb 28, 2025
    
    
      
        
        
        Release Agent Release 1.3.6    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Maintenance
  


      
    

    
      
        
          
            Changes:

  Patched critical CVEs


See more details here.

          
          
        
        
      
    
      
        
      
  

          
        
          
            








  
    
      Feb 24, 2025
    
    
      
        
        


  
    
    
    
    
    
    New feature
  


      
    
  
  
    
  
  
    
      Feb 24, 2025
    
    
      
        
        
        Trigger pipelines on push to non-draft PR    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    New feature
  


      
    

    
      
        
          
            It is now possible to configure pipelines to be triggered only on pushes to non-draft Pull Requests.

          
          
            
              
              


Keep reading 

            
          
        
        
          
            
              
                It is now possible to configure pipelines to be triggered only on pushes to non-draft Pull Requests.

Who Can Use This?
This functionality is available to all customers that use GitHub.

If your organization is currently integrated with GitHub only through OAuth, an admin must take the one-time action of installing the CircleCI GitHub App to enable this functionality.



Getting Started

  Go to your project’s Project Settings > Pipelines, and ensure you have a “GitHub App” pipeline defined
  Go to Project Settings > Triggers, and define a GitHub App trigger
  In the “run on” menu, select “Pushes to open non-draft PRs”
  Trigger your GitHub App pipeline by pushing to a non-draft PR




For more details on newly supported GitHub trigger events and example use cases, check out our documentation.
For any questions or feedback, email benedetta@circleci.com.

              
              
              


Collapse 

            
          
        
      
    
      
        
      
  

          
        
          
            








  
    
      Feb 24, 2025
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    
  
  
    
  
  
    
      Feb 24, 2025
    
    
      
        
        
        Default value added to 'Config File Path' in 'Add pipeline' form    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    

    
      
        
          
            When creating a new pipeline (Project Settings > Pipeline), the field “Config File Path” now contains a default value (circleci/config.yml) that the user can edit, instead of a placeholder.

          
          
        
        
      
    
      
        
      
  

          
        
          
            








  
    
      Feb 24, 2025
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    
  
  
    
  
  
    
      Feb 24, 2025
    
    
      
        
        
        Fixed a bug preventing pipeline name edits    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    

    
      
        
          
            A bug prevented editing the pipeline name in Project Settings > Pipelines > Edit. 
This has now been fixed.

          
          
        
        
      
    
      
        
      
  

          
        
          
            








  
    
      Feb 24, 2025
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    
  
  
    
  
  
    
      Feb 24, 2025
    
    
      
        
        
        Added link to help troubleshoot GitHub App installation issues    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    

    
      
        
          
            The “Add Pipeline” form (Project Settings > Pipelines) now includes links to a Google Form that helps customers troubleshoot common issues related to GitHub App installation and permissions.

          
          
            
              
              


Keep reading 

            
          
        
        
          
            
              
                The “Add Pipeline” form (Project Settings > Pipelines) now includes links to a Google Form that helps customers troubleshoot common issues related to GitHub App installation and permissions.



              
              
              


Collapse 

            
          
        
      
    
      
        
      
  

          
        
          
            








  
    
      Feb 21, 2025
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    
  
  
    
  
  
    
      Feb 21, 2025
    
    
      
        
        
        Fixed a bug preventing repeated PR events on the same SHA from re-triggering pipelines    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    

    
      
        
          
            This bug has been fixed, and the note removed from the docs.

          
          
            
              
              


Keep reading 

            
          
        
        
          
            
              
                This bug has been fixed, and the note removed from the docs.



              
              
              


Collapse 

            
          
        
      
    
      
        
      
  

          
        
          
            








  
    
      Feb 21, 2025
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    
  
  
    
  
  
    
      Feb 21, 2025
    
    
      
        
        
        Release Agent Release 1.3.5    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    

    
      
        
          
            Changes:

  Fixed a bug that prevented the release agent from starting up when Argo Rollouts was not installed in the cluster


See more details here.

          
          
        
        
      
    
      
        
      
  

          
        
          
            








  
    
      Feb 21, 2025
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    
  
  
    
  
  
    
      Feb 21, 2025
    
    
      
        
        
        Updated wording for the 'Build forked pull request' project setting    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    

    
      
        
          
            The “build forked pull request” setting in Project Settings > Advanced has been updated to clarify that it only applies to OAuth pipelines, not GitHub App pipelines.

          
          
            
              
              


Keep reading 

            
          
        
        
          
            
              
                The “build forked pull request” setting in Project Settings > Advanced has been updated to clarify that it only applies to OAuth pipelines, not GitHub App pipelines.

This is an important clarification, given that organizations that use the GitHub OAuth App can now also run pipelines integrated via GitHub App to leverage new features.



              
              
              


Collapse 

            
          
        
      
    
      
        
      
  

          
        
          
            








  
    
      Feb 20, 2025
    
    
      
        
        


  
    
    
    
    
    
    New feature
  


      
    
  
  
    
  
  
    
      Feb 20, 2025
    
    
      
        
        
        Introducing a pipeline iteration experience for new users    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    New feature
  


      
    

    
      
        
          
            We have introduced a new pipeline iteration experience for new users in organizations integrated with GitHub App. This assisted experience is available after setting up new projects or through the Workflow and Jobs pages, where users can chat and receive real-time support for their pipelines.

          
          
        
        
      
    
      
        
      
  

          
        
          
            








  
    
      Feb 18, 2025
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    
  
  
    
  
  
    
      Feb 18, 2025
    
    
      
        
        
        Fixed pill size on Pipelines and Triggers pages    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    

    
      
        
          
            The pill sizes on the ‘Pipelines’ and ‘Triggers’ pages in Project Settings have been adjusted for consistency.

          
          
        
        
      
    
      
        
      
  

          
        
          
            








  
    
      Feb 17, 2025
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    
  
  
    
  
  
    
      Feb 17, 2025
    
    
      
        
        
        Updated wording for the 'Only Build Pull Requests' project setting    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    

    
      
        
          
            The “only build pull request” setting in Project Settings > Advanced has been updated to clarify that it only applies to OAuth pipelines, not GitHub App pipelines.

          
          
            
              
              


Keep reading 

            
          
        
        
          
            
              
                The “only build pull request” setting in Project Settings > Advanced has been updated to clarify that it only applies to OAuth pipelines, not GitHub App pipelines.

This is an important clarification, given that organizations that use the GitHub OAuth App can now also run pipelines integrated via GitHub App to leverage new features.



              
              
              


Collapse 

            
          
        
      
    
      
        
      
  

          
        
          
            








  
    
      Feb 17, 2025
    
    
      
    
  
  
    
  
  
    
      Feb 17, 2025
    
    
      
        
        
        Triggers page now includes columns "pipeline to trigger" and "events"     
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
    

    
      
        
          
            The triggers table displayed in Project Settings > Triggers now includes two additional columns: “Pipeline to trigger” and “events”.

          
          
            
              
              


Keep reading 

            
          
        
        
          
            
              
                The triggers table displayed in Project Settings > Triggers now includes two additional columns: “Pipeline to trigger” and “events”.

  Pipeline to trigger indicates the name of the pipeline associated with each trigger
  Events indicates which trigger events will cause the pipeline to run (e.g. “All pushes”, “PR opened”, “PR merged”, …)




              
              
              


Collapse 

            
          
        
      
    
      
        
      
  

          
        
          
            








  
    
      Feb 14, 2025
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    
  
  
    
  
  
    
      Feb 14, 2025
    
    
      
        
        
        Improved Error Summarizer opt-ins for organization admins    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    

    
      
        
          
            Organization admins can now enable the in-app Error Summarizer via a modal on the same page, eliminating the need to navigate to Organization Settings. If a user is not an organization admin, the modal will inform them that they need to contact their organization admin to enable the setting in Organization Settings > Advanced.

          
          
        
        
      
    
      
        
      
  

          
        
          
            








  
    
      Feb 13, 2025
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    
  
  
    
  
  
    
      Feb 13, 2025
    
    
      
        
        
        Release Agent Release 1.3.4    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    

    
      
        
          
            Changes

  Improved logging when rollout controller is not found
  Minor bug fixes


See more details here.

          
          
        
        
      
    
      
        
      
  

          
        
          
            








  
    
      Feb 13, 2025
    
    
      
        
        


  
    
    
    
    
    
    Maintenance
  


      
    
  
  
    
  
  
    
      Feb 13, 2025
    
    
      
        
        
        Runner Release 3.1.2    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Maintenance
  


      
    

    
      
        
          
            Runner Release 3.1.2
Container Runner:

          
          
            
              
              


Keep reading 

            
          
        
        
          
            
              
                Runner Release 3.1.2
Container Runner:


  Set resource requirements (requests and limits) on the orchestrator init container (https://github.com/circleci/runner-init). This change helps ensure the Pod is schedulable when resource quotas are applied.
  Added options to configure the image name for the orchestrator container. This can be used for hosting the image in a private registry or within an air-gapped environment on CircleCI server. Note this change requires version v101.1.3 of the Helm chart.


              
              
              


Collapse 

            
          
        
      
    
      
        
          
          



  
  
  
  
  
  Runner

        
      
  

          
        
          
            








  
    
      Feb 13, 2025
    
    
      
        
        


  
    
    
    
    
    
    Maintenance
  


      
    
  
  
    
  
  
    
      Feb 13, 2025
    
    
      
        
        
        Docker Executor Infrastructure Upgrade - In Progress    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Maintenance
  


      
    

    
      
        
          
            The host OS that Docker jobs run on has been upgraded to support new features and ongoing security and bug patches. This upgrade will roll out to all customers over the next few weeks. Affected customers have been notified via email. Learn more about this change in Discuss: Docker Executor Infrastructure Upgrade.

          
          
        
        
      
    
      
        
      
  

          
        
          
            








  
    
      Feb 07, 2025
    
    
      
        
        


  
    
    
    
    
    
    Maintenance
  


      
    
  
  
    
  
  
    
      Feb 07, 2025
    
    
      
        
        
        Server Release 4.5.8    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Maintenance
  


      
    

    
      
        
          
            Updates

  Patched critical CVEs in web-ui-insights and webhook-service.


Bug fixes

  Fixed a vulnerability that allowed unauthenticated access to artifacts associated with public repositories.
  Resolved a bug that prevented a job from being rerun using SSH.


          
          
        
        
      
    
      
        
          
          



  
  
  
  
  
  Server

        
      
  

          
        
          
            








  
    
      Feb 07, 2025
    
    
      
        
        


  
    
    
    
    
    
    Maintenance
  


      
    
  
  
    
  
  
    
      Feb 07, 2025
    
    
      
        
        
        Server Release 4.7.2    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Maintenance
  


      
    

    
      
        
          
            Updates

  Patched critical CVEs in web-ui-insights and webhook-service.


Bug fixes

  Fixed a vulnerability that allowed unauthenticated access to artifacts associated with public repositories.


          
          
        
        
      
    
      
        
          
          



  
  
  
  
  
  Server

        
      
  

          
        
          
            








  
    
      Feb 07, 2025
    
    
      
        
        


  
    
    
    
    
    
    Maintenance
  


      
    
  
  
    
  
  
    
      Feb 07, 2025
    
    
      
        
        
        Server Release 4.4.11    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Maintenance
  


      
    

    
      
        
          
            Updates

  Updated the library dependencies for runner-admin
  CVE patches for web-ui-insights and webhook-service


Bug fixes

  Fixed a vulnerability where artifacts relating to public repositories could be accessed without authentication
  Fixed a bug where workflows in a terminal state with blocked jobs were incorrectly cancelled when a new workflow was triggered with redundant pipeline cancellation enabled.


          
          
        
        
      
    
      
        
          
          



  
  
  
  
  
  Server

        
      
  

          
        
        
          
            
            
            
              
            
            
              












  
    




Previous

    
    

    
      
        





  
    
      1
    
  


      
        





  
    
      2
    
  


      
        





  
    
      3
    
  


      
    

    
      
      
        
…

      
      





  
    
      20
    
  


    

    




Next
  

  
  
    




Previous

    
    

    

    
    





  
    
      1
    
  



    
      
      
        
…

      
    

    
    
      





  
    
      20
    
  


    

    




Next
  



            
          
        
      
    

    
      
        
          Filter by status:
          
            
            
              


  


            
            
              


  
    
    
    
    
    
    New feature
  


            
            
              


  
    
    
    
    
    
    Maintenance
  


            
            
              


  
    
    
    
    
    
    Enhancement
  


            
          
        

        
          Filter by tag:
          
            
              
              



  
  
  
  
  
  Server

            
              
              



  
  
  
  
  
  Runner

            
              
              



  
  
  
  
  
  Images

            
              
              



  
  
  
  
  
  Orbs

            
              
              



  
  
  
  
  
  Dev tools

            
          
        

        
        

      
      
        
          


View most recent\n\nChangelog
      
        
          Keep up to date with our latest releases and enhancements.

        
      
      
        

  
    
    
      
        
        Subscribe
      
    
  
    
    
      
        
        View roadmap
      
    
  

      
    
    
      
        
          

        

        
          





          
        
      
    
  





  
    
      
        
          
            








  
    
      Apr 16, 2025
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    
  
  
    
  
  
    
      Apr 16, 2025
    
    
      
        
        
        MCP Server Updated w/ Config Validation and Flaky Test Detection    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    

    
      
        
          
            Two new tools made available in the CircleCI MCP Server:

          
          
            
              
              


Keep reading 

            
          
        
        
          
            
              
                Two new tools made available in the CircleCI MCP Server:


  We added the config_helper tool to assist with CircleCI configuration tasks such as providing support for validating .circleci/config.yml files, recommending fixes, and suggesting best practice improvements.
  We added the find_flaky_tests tool to identify and analyze flaky tests in CircleCI projects, supporting both project URL and local git repository context.


Download the MCP Server here

              
              
              


Collapse 

            
          
        
      
    
      
        
      
  

          
        
          
            








  
    
      Apr 11, 2025
    
    
      
        
        


  
    
    
    
    
    
    Maintenance
  


      
    
  
  
    
  
  
    
      Apr 11, 2025
    
    
      
        
        
        Server Release 4.7.3    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Maintenance
  


      
    

    
      
        
          
            Updates

  oidc-tasks-service runs migrations before it’s main container is deployed
  Remote Docker and Machine jobs can now assume an IAM role by configuring machine_provisioner.providers.ec2.assumedRoleArn in your values.yaml


Bug Fixes

  /workflow-run/ route has been added to kong. Links for approval jobs will now be correctly routed on GHE
  The OIDC plugin now supports custom certificates
  A docker-provisioner custom config can not be provided in your helm upgrade command via --set-file
  upgraded nextjs to resolve related CVEs


          
          
        
        
      
    
      
        
          
          



  
  
  
  
  
  Server

        
      
  

          
        
          
            








  
    
      Apr 09, 2025
    
    
      
        
        


  
    
    
    
    
    
    New feature
  


      
    
  
  
    
  
  
    
      Apr 09, 2025
    
    
      
        
        
        MCP Server for CircleCI now available    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    New feature
  


      
    

    
      
        
          
            We’ve recently rolled out the CircleCI Model Context Protocol (MCP) Server. This enables developers using tools (Claude Code, Cursor, Windsurf, etc.) that support the MCP protocol to interact with CircleCI.

          
          
            
              
              


Keep reading 

            
          
        
        
          
            
              
                We’ve recently rolled out the CircleCI Model Context Protocol (MCP) Server. This enables developers using tools (Claude Code, Cursor, Windsurf, etc.) that support the MCP protocol to interact with CircleCI.

Agents and AI tools can now fulfill developer requests, such as “Find the latest failed pipeline on my branch and get logs.” This eliminates the need to navigate through the UI or use complex CLI commands to debug and solve problems.
This is the initial release, and we will continuously be updating what the server can do over the coming weeks. If you would like to contribute, please don’t hesitate to put in a pull request.

For more details and example use cases, check out our documentation and our blog post.

For questions or feedback, please open an issue on the GitHub repository.

              
              
              


Collapse 

            
          
        
      
    
      
        
      
  

          
        
          
            








  
    
      Apr 09, 2025
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    
  
  
    
  
  
    
      Apr 09, 2025
    
    
      
        
        
        Changes to dropdown options in "Add trigger" and "Add pipeline" forms    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    

    
      
        
          
            The “Trigger type” dropdown in the “Add trigger” form (Project Settings > Triggers) has been updated with the following changes:

          
          
            
              
              


Keep reading 

            
          
        
        
          
            
              
                The “Trigger type” dropdown in the “Add trigger” form (Project Settings > Triggers) has been updated with the following changes:


  “GitHub App” is now the default pre-selected  option for all organization types
  For organizations using CircleCI’s GitHub OAuth App integration, the dropdown now displays only the three valid trigger options: GitHub App, Custom Webhook, and Schedule




Similarly. the “Integration” dropdown in the “Add pipeline” form (Project Settings > Pipelines) has been updated with the following changes:


  “GitHub App” is now the default pre-selected  option for all organization types
  For organizations using CircleCI’s GitHub OAuth App integration, the dropdown now only includes the option “GitHub App”




              
              
              


Collapse 

            
          
        
      
    
      
        
      
  

          
        
          
            








  
    
      Apr 09, 2025
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    
  
  
    
  
  
    
      Apr 09, 2025
    
    
      
        
        
        Update - Breaking Change- April 28th 2025 - Skipped Status Will Now Return Success     
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    

    
      
        
          
            Clarification - All VCS status checks are impacted.

          
          
            
              
              


Keep reading 

            
          
        
        
          
            
              
                Clarification - All VCS status checks are impacted.

What is changing?

Status checks previously sent skipped job statuses as failures, now they will be sent as successful checks. This is to align with GitHub’s definition of skipped status.

This means that “skipped” will not prevent pull request merging, even if it is a required check.

List workflow jobs v2 API previously returned jobs with blocked statuses for jobs that never ran, now they will return as a skipped status.

Why are we doing this?

To improve the lifecycle of jobs and enable features such as finally jobs, all jobs will transition from blocked to one of the terminal states 
(success, failed, canceled, skipped, unauthorized).

When will it happen?

28th April 2025

              
              
              


Collapse 

            
          
        
      
    
      
        
      
  

          
        
          
            








  
    
      Apr 08, 2025
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    
  
  
    
  
  
    
      Apr 08, 2025
    
    
      
        
        
        CIRCLE_PULL_REQUEST env variable now populated for GitHub App pipelines     
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    

    
      
        
          
            The environment variable CIRCLE_PULL_REQUEST is now populated for all pipelines triggered from GitHub, regardless of integration type, whenever the triggering commit is associated with a pull request.

          
          
            
              
              


Keep reading 

            
          
        
        
          
            
              
                The environment variable CIRCLE_PULL_REQUEST is now populated for all pipelines triggered from GitHub, regardless of integration type, whenever the triggering commit is associated with a pull request.

For GitHub App pipelines specifically, the pipeline variable pipeline.event.context.github.pr_url is also populated with the same information.

Previously, the CIRCLE_PULL_REQUEST environment variable was only populated for pipelines that used CircleCI’s GitHub OAuth App integration.

              
              
              


Collapse 

            
          
        
      
    
      
        
      
  

          
        
          
            








  
    
      Apr 08, 2025
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    
  
  
    
  
  
    
      Apr 08, 2025
    
    
      
        
        
        Auto-populate trigger pipeline modal parameters based on selected pipeline.     
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    

    
      
        
          
            Parameters in the trigger pipeline modal now automatically populate based on the pipeline selected in the dropdown menu at the top of the form.

          
          
            
              
              


Keep reading 

            
          
        
        
          
            
              
                Parameters in the trigger pipeline modal now automatically populate based on the pipeline selected in the dropdown menu at the top of the form.

Currently, this feature is only available for pipelines that are configured with CircleCI’s GitHub App integration. For pipelines that use CircleCI’s GitHub OAuth App integration, parameters continue to auto-populate based on the config file used in the most recent pipeline run, regardless of whether it matches the pipeline that has been selected.

              
              
              


Collapse 

            
          
        
      
    
      
        
      
  

          
        
          
            








  
    
      Apr 03, 2025
    
    
      
        
        


  
    
    
    
    
    
    Maintenance
  


      
    
  
  
    
  
  
    
      Apr 03, 2025
    
    
      
        
        
        Docker Executor Infrastructure Upgrade - Complete    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Maintenance
  


      
    

    
      
        
          
            The host OS that Docker jobs run on is being upgraded to support new features and ongoing security and bug patches. This upgrade has now been rolled out to all customers.

          
          
            
              
              


Keep reading 

            
          
        
        
          
            
              
                The host OS that Docker jobs run on is being upgraded to support new features and ongoing security and bug patches. This upgrade has now been rolled out to all customers.

Learn more about this change in Discuss: Docker Executor Infrastructure Upgrade.

              
              
              


Collapse 

            
          
        
      
    
      
        
      
  

          
        
          
            








  
    
      Mar 28, 2025
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    
  
  
    
  
  
    
      Mar 28, 2025
    
    
      
        
        
        CI Skip and Only build PRs will no longer create pipelines    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    

    
      
        
          
            What is changing?

          
          
            
              
              


Keep reading 

            
          
        
        
          
            
              
                What is changing?

Workflows that were previously marked as not_run—due to CI skip conditions or the “only build PRs” feature flag—will no longer create pipelines. These pipelines will not appear in the UI or API. However, the trigger event will still be recorded in the audit logs.

Why are we doing this?

Showing skipped pipelines clutters the UI and API with information that’s irrelevant to users. This behavior is also inconsistent with other VCS integrations. Removing these entries increases consistency and improves the overall user experience.

When will it happen?

14th April 2025

              
              
              


Collapse 

            
          
        
      
    
      
        
      
  

          
        
          
            








  
    
      Mar 28, 2025
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    
  
  
    
  
  
    
      Mar 28, 2025
    
    
      
        
        
        Display "Authorize" button on the navbar if user has not authorized GitHub App    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    

    
      
        
          
            When using the GitHub App integration, each user needs to “authorize” the CircleCI GitHub App for their pipelines to be correctly attributed to them. Not doing so means:

          
          
            
              
              


Keep reading 

            
          
        
        
          
            
              
                When using the GitHub App integration, each user needs to “authorize” the CircleCI GitHub App for their pipelines to be correctly attributed to them. Not doing so means:


  their pipelines won’t have access to contexts
  their pipelines won’t run if they have enabled the setting “Prevent unregistered user spend”
  they can’t manually trigger pipelines through the UI


Previously, the “Authorize” button was only available in the Pipeline and Trigger forms - two pages that most users don’t commonly visit.

In order to make it as easy as possible for users to know that they are not “authorized” and to take action on it, we introduced a call to action on the navigation bar.

The “Authorize” button appears only when the organization has the GitHub App installed, and the current user is not yet authorized.



IMPORTANT: This change is being released incrementally to selected organizations to ensure optimal user experience before full deployment.

              
              
              


Collapse 

            
          
        
      
    
      
        
      
  

          
        
          
            








  
    
      Mar 28, 2025
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    
  
  
    
  
  
    
      Mar 28, 2025
    
    
      
        
        
        Disable SSH Rerun by Project    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    

    
      
        
          
            Project admins can now disable SSH rerun for individual projects via Project Settings>Advanced or the CircleCI v2 API.

          
          
        
        
      
    
      
        
      
  

          
        
          
            








  
    
      Mar 27, 2025
    
    
      
        
        


  
    
    
    
    
    
    Maintenance
  


      
    
  
  
    
  
  
    
      Mar 27, 2025
    
    
      
        
        
        Japanese Documentation Pages to be Discontinued    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Maintenance
  


      
    

    
      
        
          
            Effective April 1, 2025, all Japanese versions of our public documentation will be removed from the site. The language switcher will also be discontinued.

          
          
            
              
              


Keep reading 

            
          
        
        
          
            
              
                Effective April 1, 2025, all Japanese versions of our public documentation will be removed from the site. The language switcher will also be discontinued.

Please use the English version of these pages for the most accurate and up-to-date information about using CircleCI.

If you have questions or feedback about this change, please visit our community forum.

              
              
              


Collapse 

            
          
        
      
    
      
        
      
  

          
        
          
            








  
    
      Mar 27, 2025
    
    
      
        
        


  
    
    
    
    
    
    Maintenance
  


      
    
  
  
    
  
  
    
      Mar 27, 2025
    
    
      
        
        
        Docker Executor Infrastructure Upgrade - Docker ARM and IP Ranges    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Maintenance
  


      
    

    
      
        
          
            The host OS that Docker jobs run on is being upgraded to support new features and ongoing security and bug patches. This upgrade is being applied to jobs using Docker ARM and IP ranges from now through April 1.

          
          
            
              
              


Keep reading 

            
          
        
        
          
            
              
                The host OS that Docker jobs run on is being upgraded to support new features and ongoing security and bug patches. This upgrade is being applied to jobs using Docker ARM and IP ranges from now through April 1.

Learn more about this change in Discuss: Docker Executor Infrastructure Upgrade.

              
              
              


Collapse 

            
          
        
      
    
      
        
      
  

          
        
          
            








  
    
      Mar 26, 2025
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    
  
  
    
  
  
    
      Mar 26, 2025
    
    
      
        
        
        UI changes to the pipelines page    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    

    
      
        
          
            We have introduced some UI changes to the pipelines page:

          
          
            
              
              


Keep reading 

            
          
        
        
          
            
              
                We have introduced some UI changes to the pipelines page:




  
    The column previously named “Project” was renamed into “Pipeline”

    It displays pipeline name, pipeline number, and (only when looking at the All pipelines view) project name
  
  
    The column previously named “Trigger event” was renamed into “Checkout source”

    It continues to show the same information as before, but the avatar now shows the profile picture of the commit author, if that information is available. If it isn’t (this is currently the case for OAuth pipelines), the avatar does not show.
  To avoid this inconsistency, we plan on hiding the avatar also for other types of pipelines.
  
  
    A new column “Trigger event” was added

    It shows what event that triggered a pipeline (Push, Pull request, API, …). The avatar indicates who triggered the event, with a tooltip showing the username on hover.
  
  
    The headers of columns Pipeline and Trigger event each include tooltips, informing users that:
    
      it’s now possible to have multiple pipelines in the same project
      more GitHub trigger events options are now available
    

    These tooltips are visible to orgs that integrate with our GitHub OAuth app integration or GitHub App/GitLab/Bitbucket Data Center integrations. They are not visible to organizations that integrate with Bitbucket Cloud..
  


These changes are currently in preview, and additional improvements will be made in the coming weeks. If you have any feedback, please comment on this post on our community forum.

              
              
              


Collapse 

            
          
        
      
    
      
        
      
  

          
        
          
            








  
    
      Mar 26, 2025
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    
  
  
    
  
  
    
      Mar 26, 2025
    
    
      
        
        
        Context restriction APIs marked GA    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    

    
      
        
          
            The context restriction APIs have been promoted from experimental to generally available. Authorized users can now create, read, and delete project- and expression-based context restrictions via API. Security group context restrictions are not supported yet. Read the context API documentation.

          
          
        
        
      
    
      
        
          
          



  
  
  
  
  
  Dev tools

        
      
  

          
        
          
            








  
    
      Mar 18, 2025
    
    
      
        
        


  
    
    
    
    
    
    Maintenance
  


      
    
  
  
    
  
  
    
      Mar 18, 2025
    
    
      
        
        
        Runner Release 3.1.3    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Maintenance
  


      
    

    
      
        
          
            Runner Release 3.1.2
Machine Runner:

          
          
            
              
              


Keep reading 

            
          
        
        
          
            
              
                Runner Release 3.1.2
Machine Runner:


  Fixed a bug where an error downloading the task agent binary was not correctly propagated, causing the runner to get stuck without retrying the download and requiring a manual restart to unblock.


              
              
              


Collapse 

            
          
        
      
    
      
        
          
          



  
  
  
  
  
  Runner

        
      
  

          
        
          
            








  
    
      Mar 18, 2025
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    
  
  
    
  
  
    
      Mar 18, 2025
    
    
      
        
        
        New context timeout error messaging    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    

    
      
        
          
            A new error message has been added to the contexts page to help users differentiate between page timeouts and permission errors. Previously, it was unclear to the user whether page load issues could be resolved with a refresh. Now, users who have the correct permissions will see “Please try again in a few minutes.” if contexts take a long time to load.

          
          
        
        
      
    
      
        
      
  

          
        
          
            








  
    
      Mar 17, 2025
    
    
      
        
        


  
    
    
    
    
    
    New feature
  


      
    
  
  
    
  
  
    
      Mar 17, 2025
    
    
      
        
        
        Project overview page    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    New feature
  


      
    

    
      
        
          
            We’ve introduced a new project overview page, which allows users to get a quick sense of the health of their pipelines and see what changes have recently been deployed for a project all in one place. Users can access this page by clicking the Overview link from the Organization Home page or Projects page.

          
          
            
              
              


Keep reading 

            
          
        
        
          
            
              
                We’ve introduced a new project overview page, which allows users to get a quick sense of the health of their pipelines and see what changes have recently been deployed for a project all in one place. Users can access this page by clicking the Overview link from the Organization Home page or Projects page.

If you have any feedback on how we can improve this overview, please use the survey popup in the bottom right corner of the page to let us know!



              
              
              


Collapse 

            
          
        
      
    
      
        
      
  

          
        
          
            








  
    
      Mar 15, 2025
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    
  
  
    
  
  
    
      Mar 15, 2025
    
    
      
        
        
        Manage GitHub App installation from the organization settings page "VCS Connections"    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    

    
      
        
          
            The tab “VCS” in Organization Settings has been renamed into “VCS Connections”, and it now includes a section dedicated to the GitHub App integration.

          
          
            
              
              


Keep reading 

            
          
        
        
          
            
              
                The tab “VCS” in Organization Settings has been renamed into “VCS Connections”, and it now includes a section dedicated to the GitHub App integration.

If the CircleCI GitHub App is not installed, it provides an overview of the functionality enabled by the App.


If the CircleCI GitHub App is installed, it shows which GitHub organization it’s connected to, and lets admin access the configuration page


The settings button redirects to the GitHub installation page. 
The delete button opens a modal which requires additional user input to confirm uninstallation of the GitHub App. Both actions are restricted to organization admins only.

              
              
              


Collapse 

            
          
        
      
    
      
        
      
  

          
        
          
            








  
    
      Mar 14, 2025
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    
  
  
    
  
  
    
      Mar 14, 2025
    
    
      
        
        
        Prevent non-admin users from installing the GitHub App    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    

    
      
        
          
            The GitHub App pipeline and trigger forms have been updated to prevent non-admin users from attempting to install the CircleCI GitHub App.

          
          
        
        
      
    
      
        
      
  

          
        
          
            








  
    
      Mar 12, 2025
    
    
      
        
        


  
    
    
    
    
    
    Maintenance
  


      
    
  
  
    
  
  
    
      Mar 12, 2025
    
    
      
        
        
        Added automatic redirect for logged-out users     
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Maintenance
  


      
    

    
      
        
          
            Users who land on the user homepage while logged out are now automatically redirected to the login page.

          
          
        
        
      
    
      
        
      
  

          
        
          
            








  
    
      Mar 12, 2025
    
    
      
        
        


  
    
    
    
    
    
    New feature
  


      
    
  
  
    
  
  
    
      Mar 12, 2025
    
    
      
        
        
        Avoid commit conflicts in your pipelines with serial-jobs    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    New feature
  


      
    

    
      
        
          
            The queue orb was previously used to avoid multiple pipeline race conditions and conflicts. Serial-job provides native support for the functionality provided by the queue orb. Overtime we will expand the use cases we support to cover additional challenges like multi-job or workflows. The first release is serial-group for individual jobs.

          
          
            
              
              


Keep reading 

            
          
        
        
          
            
              
                The queue orb was previously used to avoid multiple pipeline race conditions and conflicts. Serial-job provides native support for the functionality provided by the queue orb. Overtime we will expand the use cases we support to cover additional challenges like multi-job or workflows. The first release is serial-group for individual jobs.

This allows an individual job to be serialized across the organization, project or branch based on the parameters you provide. Serialization will ensure the jobs are executed in the order in which the pipelines are started via commit, api or other triggering method.

To learn more about your options see the documentation.

              
              
              


Collapse 

            
          
        
      
    
      
        
      
  

          
        
          
            








  
    
      Mar 12, 2025
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    
  
  
    
  
  
    
      Mar 12, 2025
    
    
      
        
        
        Show in-app instructions for how to delete OAuth trigger    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    

    
      
        
          
            A growing number of GitHub OAuth customers have been looking to stop building their OAuth pipelines in favour of the new GitHub App pipelines which provide a broader range of triggering options.

          
          
            
              
              


Keep reading 

            
          
        
        
          
            
              
                A growing number of GitHub OAuth customers have been looking to stop building their OAuth pipelines in favour of the new GitHub App pipelines which provide a broader range of triggering options.

This is currently a manual process, which requires making changes in GitHub.

To avoid users having to refer to the docs for instructions, we added a “delete” icon next to the OAuth trigger (Project Settings > Triggers), which opens a modal containing instructions for how to disable the OAuth trigger manually.



              
              
              


Collapse 

            
          
        
      
    
      
        
      
  

          
        
          
            








  
    
      Mar 11, 2025
    
    
      
        
        


  
    
    
    
    
    
    Maintenance
  


      
    
  
  
    
  
  
    
      Mar 11, 2025
    
    
      
        
        
        Fixed infinite loading spinner on Pipelines page    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Maintenance
  


      
    

    
      
        
          
            A bug that was causing the loading spinner to spin infinitely when no additional pipelines were available after clicking the ‘See more’ button on the pipelines page has been fixed.

          
          
        
        
      
    
      
        
      
  

          
        
          
            








  
    
      Mar 06, 2025
    
    
      
        
        


  
    
    
    
    
    
    Maintenance
  


      
    
  
  
    
  
  
    
      Mar 06, 2025
    
    
      
        
        
        Bug fix when selecting repository for new projects    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Maintenance
  


      
    

    
      
        
          
            Users of CircleCI’s GitHub App integration would occasionally not be able to see a list of repositories to choose from when creating a new project.  This bug has been fixed.

          
          
        
        
      
    
      
        
      
  

          
        
          
            








  
    
      Mar 06, 2025
    
    
      
        
        


  
    
    
    
    
    
    Maintenance
  


      
    
  
  
    
  
  
    
      Mar 06, 2025
    
    
      
        
        
        Timing tab bug fixed    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Maintenance
  


      
    

    
      
        
          
            A bug that was causing the “Timing” tab in the CircleCI web app to show UUIDs instead of a string of the step name has been fixed.

          
          
        
        
      
    
      
        
      
  

          
        
          
            








  
    
      Mar 06, 2025
    
    
      
        
        


  
    
    
    
    
    
    Maintenance
  


      
    
  
  
    
  
  
    
      Mar 06, 2025
    
    
      
        
        
        Bug causing full dark screen on loading modal fixed    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Maintenance
  


      
    

    
      
        
          
            A bug that caused a nearly full dark screen when creating a new project in organizations that integrate with CircleCI’s GitHub App has now been fixed.

          
          
        
        
      
    
      
        
      
  

          
        
          
            








  
    
      Mar 04, 2025
    
    
      
        
        


  
    
    
    
    
    
    Maintenance
  


      
    
  
  
    
  
  
    
      Mar 04, 2025
    
    
      
        
        
        Release Agent Release 1.3.7    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Maintenance
  


      
    

    
      
        
          
            Changes:

  Patched critical CVEs


See more details here.

          
          
        
        
      
    
      
        
      
  

          
        
          
            








  
    
      Mar 04, 2025
    
    
      
        
        


  
    
    
    
    
    
    Maintenance
  


      
    
  
  
    
  
  
    
      Mar 04, 2025
    
    
      
        
        
        Minor changes to Pipeline Editor page    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Maintenance
  


      
    

    
      
        
          
            

  Added quick-start options to make it easier to understand what types of questions can be asked
  Loading screen adjusted to be smoother when a new pipeline is triggered
  Minor copy changes


          
          
        
        
      
    
      
        
      
  

          
        
          
            








  
    
      Mar 03, 2025
    
    
      
        
        


  
    
    
    
    
    
    Maintenance
  


      
    
  
  
    
  
  
    
      Mar 03, 2025
    
    
      
        
        
        OIDC signing keys updated    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Maintenance
  


      
    

    
      
        
          
            CircleCI periodically updates the keys used to sign OIDC tokens in alignment with security best practices. No customer action is required to continue using OIDC with previously configured services.

          
          
        
        
      
    
      
        
      
  

          
        
          
            








  
    
      Mar 03, 2025
    
    
      
        
        


  
    
    
    
    
    
    New feature
  


      
    
  
  
    
  
  
    
      Mar 03, 2025
    
    
      
        
        
        Single Sign On for GitHub OAuth and Bitbucket Cloud    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    New feature
  


      
    

    
      
        
          
            Single sign on (SSO) is now available for Cloud Scale plan customers with CircleCI organizations connected to GitHub OAuth and Bitbucket Cloud. Learn how to connect your identity provider and enforce SSO for users in your org.

          
          
        
        
      
    
      
        
      
  

          
        
          
            








  
    
      Feb 28, 2025
    
    
      
        
        


  
    
    
    
    
    
    Maintenance
  


      
    
  
  
    
  
  
    
      Feb 28, 2025
    
    
      
        
        
        Release Agent Release 1.3.6    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Maintenance
  


      
    

    
      
        
          
            Changes:

  Patched critical CVEs


See more details here.

          
          
        
        
      
    
      
        
      
  

          
        
          
            








  
    
      Feb 24, 2025
    
    
      
        
        


  
    
    
    
    
    
    New feature
  


      
    
  
  
    
  
  
    
      Feb 24, 2025
    
    
      
        
        
        Trigger pipelines on push to non-draft PR    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    New feature
  


      
    

    
      
        
          
            It is now possible to configure pipelines to be triggered only on pushes to non-draft Pull Requests.

          
          
            
              
              


Keep reading 

            
          
        
        
          
            
              
                It is now possible to configure pipelines to be triggered only on pushes to non-draft Pull Requests.

Who Can Use This?
This functionality is available to all customers that use GitHub.

If your organization is currently integrated with GitHub only through OAuth, an admin must take the one-time action of installing the CircleCI GitHub App to enable this functionality.



Getting Started

  Go to your project’s Project Settings > Pipelines, and ensure you have a “GitHub App” pipeline defined
  Go to Project Settings > Triggers, and define a GitHub App trigger
  In the “run on” menu, select “Pushes to open non-draft PRs”
  Trigger your GitHub App pipeline by pushing to a non-draft PR




For more details on newly supported GitHub trigger events and example use cases, check out our documentation.
For any questions or feedback, email benedetta@circleci.com.

              
              
              


Collapse 

            
          
        
      
    
      
        
      
  

          
        
          
            








  
    
      Feb 24, 2025
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    
  
  
    
  
  
    
      Feb 24, 2025
    
    
      
        
        
        Default value added to 'Config File Path' in 'Add pipeline' form    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    

    
      
        
          
            When creating a new pipeline (Project Settings > Pipeline), the field “Config File Path” now contains a default value (circleci/config.yml) that the user can edit, instead of a placeholder.

          
          
        
        
      
    
      
        
      
  

          
        
          
            








  
    
      Feb 24, 2025
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    
  
  
    
  
  
    
      Feb 24, 2025
    
    
      
        
        
        Fixed a bug preventing pipeline name edits    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    

    
      
        
          
            A bug prevented editing the pipeline name in Project Settings > Pipelines > Edit. 
This has now been fixed.

          
          
        
        
      
    
      
        
      
  

          
        
          
            








  
    
      Feb 24, 2025
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    
  
  
    
  
  
    
      Feb 24, 2025
    
    
      
        
        
        Added link to help troubleshoot GitHub App installation issues    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    

    
      
        
          
            The “Add Pipeline” form (Project Settings > Pipelines) now includes links to a Google Form that helps customers troubleshoot common issues related to GitHub App installation and permissions.

          
          
            
              
              


Keep reading 

            
          
        
        
          
            
              
                The “Add Pipeline” form (Project Settings > Pipelines) now includes links to a Google Form that helps customers troubleshoot common issues related to GitHub App installation and permissions.



              
              
              


Collapse 

            
          
        
      
    
      
        
      
  

          
        
          
            








  
    
      Feb 21, 2025
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    
  
  
    
  
  
    
      Feb 21, 2025
    
    
      
        
        
        Fixed a bug preventing repeated PR events on the same SHA from re-triggering pipelines    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    

    
      
        
          
            This bug has been fixed, and the note removed from the docs.

          
          
            
              
              


Keep reading 

            
          
        
        
          
            
              
                This bug has been fixed, and the note removed from the docs.



              
              
              


Collapse 

            
          
        
      
    
      
        
      
  

          
        
          
            








  
    
      Feb 21, 2025
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    
  
  
    
  
  
    
      Feb 21, 2025
    
    
      
        
        
        Release Agent Release 1.3.5    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    

    
      
        
          
            Changes:

  Fixed a bug that prevented the release agent from starting up when Argo Rollouts was not installed in the cluster


See more details here.

          
          
        
        
      
    
      
        
      
  

          
        
          
            








  
    
      Feb 21, 2025
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    
  
  
    
  
  
    
      Feb 21, 2025
    
    
      
        
        
        Updated wording for the 'Build forked pull request' project setting    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    

    
      
        
          
            The “build forked pull request” setting in Project Settings > Advanced has been updated to clarify that it only applies to OAuth pipelines, not GitHub App pipelines.

          
          
            
              
              


Keep reading 

            
          
        
        
          
            
              
                The “build forked pull request” setting in Project Settings > Advanced has been updated to clarify that it only applies to OAuth pipelines, not GitHub App pipelines.

This is an important clarification, given that organizations that use the GitHub OAuth App can now also run pipelines integrated via GitHub App to leverage new features.



              
              
              


Collapse 

            
          
        
      
    
      
        
      
  

          
        
          
            








  
    
      Feb 20, 2025
    
    
      
        
        


  
    
    
    
    
    
    New feature
  


      
    
  
  
    
  
  
    
      Feb 20, 2025
    
    
      
        
        
        Introducing a pipeline iteration experience for new users    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    New feature
  


      
    

    
      
        
          
            We have introduced a new pipeline iteration experience for new users in organizations integrated with GitHub App. This assisted experience is available after setting up new projects or through the Workflow and Jobs pages, where users can chat and receive real-time support for their pipelines.

          
          
        
        
      
    
      
        
      
  

          
        
          
            








  
    
      Feb 18, 2025
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    
  
  
    
  
  
    
      Feb 18, 2025
    
    
      
        
        
        Fixed pill size on Pipelines and Triggers pages    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    

    
      
        
          
            The pill sizes on the ‘Pipelines’ and ‘Triggers’ pages in Project Settings have been adjusted for consistency.

          
          
        
        
      
    
      
        
      
  

          
        
          
            








  
    
      Feb 17, 2025
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    
  
  
    
  
  
    
      Feb 17, 2025
    
    
      
        
        
        Updated wording for the 'Only Build Pull Requests' project setting    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    

    
      
        
          
            The “only build pull request” setting in Project Settings > Advanced has been updated to clarify that it only applies to OAuth pipelines, not GitHub App pipelines.

          
          
            
              
              


Keep reading 

            
          
        
        
          
            
              
                The “only build pull request” setting in Project Settings > Advanced has been updated to clarify that it only applies to OAuth pipelines, not GitHub App pipelines.

This is an important clarification, given that organizations that use the GitHub OAuth App can now also run pipelines integrated via GitHub App to leverage new features.



              
              
              


Collapse 

            
          
        
      
    
      
        
      
  

          
        
          
            








  
    
      Feb 17, 2025
    
    
      
    
  
  
    
  
  
    
      Feb 17, 2025
    
    
      
        
        
        Triggers page now includes columns "pipeline to trigger" and "events"     
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
    

    
      
        
          
            The triggers table displayed in Project Settings > Triggers now includes two additional columns: “Pipeline to trigger” and “events”.

          
          
            
              
              


Keep reading 

            
          
        
        
          
            
              
                The triggers table displayed in Project Settings > Triggers now includes two additional columns: “Pipeline to trigger” and “events”.

  Pipeline to trigger indicates the name of the pipeline associated with each trigger
  Events indicates which trigger events will cause the pipeline to run (e.g. “All pushes”, “PR opened”, “PR merged”, …)




              
              
              


Collapse 

            
          
        
      
    
      
        
      
  

          
        
          
            








  
    
      Feb 14, 2025
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    
  
  
    
  
  
    
      Feb 14, 2025
    
    
      
        
        
        Improved Error Summarizer opt-ins for organization admins    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    

    
      
        
          
            Organization admins can now enable the in-app Error Summarizer via a modal on the same page, eliminating the need to navigate to Organization Settings. If a user is not an organization admin, the modal will inform them that they need to contact their organization admin to enable the setting in Organization Settings > Advanced.

          
          
        
        
      
    
      
        
      
  

          
        
          
            








  
    
      Feb 13, 2025
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    
  
  
    
  
  
    
      Feb 13, 2025
    
    
      
        
        
        Release Agent Release 1.3.4    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    

    
      
        
          
            Changes

  Improved logging when rollout controller is not found
  Minor bug fixes


See more details here.

          
          
        
        
      
    
      
        
      
  

          
        
          
            








  
    
      Feb 13, 2025
    
    
      
        
        


  
    
    
    
    
    
    Maintenance
  


      
    
  
  
    
  
  
    
      Feb 13, 2025
    
    
      
        
        
        Runner Release 3.1.2    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Maintenance
  


      
    

    
      
        
          
            Runner Release 3.1.2
Container Runner:

          
          
            
              
              


Keep reading 

            
          
        
        
          
            
              
                Runner Release 3.1.2
Container Runner:


  Set resource requirements (requests and limits) on the orchestrator init container (https://github.com/circleci/runner-init). This change helps ensure the Pod is schedulable when resource quotas are applied.
  Added options to configure the image name for the orchestrator container. This can be used for hosting the image in a private registry or within an air-gapped environment on CircleCI server. Note this change requires version v101.1.3 of the Helm chart.


              
              
              


Collapse 

            
          
        
      
    
      
        
          
          



  
  
  
  
  
  Runner

        
      
  

          
        
          
            








  
    
      Feb 13, 2025
    
    
      
        
        


  
    
    
    
    
    
    Maintenance
  


      
    
  
  
    
  
  
    
      Feb 13, 2025
    
    
      
        
        
        Docker Executor Infrastructure Upgrade - In Progress    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Maintenance
  


      
    

    
      
        
          
            The host OS that Docker jobs run on has been upgraded to support new features and ongoing security and bug patches. This upgrade will roll out to all customers over the next few weeks. Affected customers have been notified via email. Learn more about this change in Discuss: Docker Executor Infrastructure Upgrade.

          
          
        
        
      
    
      
        
      
  

          
        
          
            








  
    
      Feb 07, 2025
    
    
      
        
        


  
    
    
    
    
    
    Maintenance
  


      
    
  
  
    
  
  
    
      Feb 07, 2025
    
    
      
        
        
        Server Release 4.5.8    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Maintenance
  


      
    

    
      
        
          
            Updates

  Patched critical CVEs in web-ui-insights and webhook-service.


Bug fixes

  Fixed a vulnerability that allowed unauthenticated access to artifacts associated with public repositories.
  Resolved a bug that prevented a job from being rerun using SSH.


          
          
        
        
      
    
      
        
          
          



  
  
  
  
  
  Server

        
      
  

          
        
          
            








  
    
      Feb 07, 2025
    
    
      
        
        


  
    
    
    
    
    
    Maintenance
  


      
    
  
  
    
  
  
    
      Feb 07, 2025
    
    
      
        
        
        Server Release 4.7.2    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Maintenance
  


      
    

    
      
        
          
            Updates

  Patched critical CVEs in web-ui-insights and webhook-service.


Bug fixes

  Fixed a vulnerability that allowed unauthenticated access to artifacts associated with public repositories.


          
          
        
        
      
    
      
        
          
          



  
  
  
  
  
  Server

        
      
  

          
        
          
            








  
    
      Feb 07, 2025
    
    
      
        
        


  
    
    
    
    
    
    Maintenance
  


      
    
  
  
    
  
  
    
      Feb 07, 2025
    
    
      
        
        
        Server Release 4.4.11    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Maintenance
  


      
    

    
      
        
          
            Updates

  Updated the library dependencies for runner-admin
  CVE patches for web-ui-insights and webhook-service


Bug fixes

  Fixed a vulnerability where artifacts relating to public repositories could be accessed without authentication
  Fixed a bug where workflows in a terminal state with blocked jobs were incorrectly cancelled when a new workflow was triggered with redundant pipeline cancellation enabled.


          
          
        
        
      
    
      
        
          
          



  
  
  
  
  
  Server

        
      
  

          
        
        
          
            
            
            
              
            
            
              












  
    




Previous

    
    

    
      
        





  
    
      1
    
  


      
        





  
    
      2
    
  


      
        





  
    
      3
    
  


      
    

    
      
      
        
…

      
      





  
    
      20
    
  


    

    




Next
  

  
  
    




Previous

    
    

    

    
    





  
    
      1
    
  



    
      
      
        
…

      
    

    
    
      





  
    
      20
    
  


    

    




Next
  



            
          
        
      
    

    
      
        
          Filter by status:
          
            
            
              


  


            
            
              


  
    
    
    
    
    
    New feature
  


            
            
              


  
    
    
    
    
    
    Maintenance
  


            
            
              


  
    
    
    
    
    
    Enhancement
  


            
          
        

        
          Filter by tag:
          
            
              
              



  
  
  
  
  
  Server

            
              
              



  
  
  
  
  
  Runner

            
              
              



  
  
  
  
  
  Images

            
              
              



  
  
  
  
  
  Orbs

            
              
              



  
  
  
  
  
  Dev tools

            
          
        

        
        

      
      
        
          


View most recent\n\nApr 16, 2025
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    
  
  
    
  
  
    
      Apr 16, 2025
    
    
      
        
        
        MCP Server Updated w/ Config Validation and Flaky Test Detection    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    

    
      
        
          
            Two new tools made available in the CircleCI MCP Server:

          
          
            
              
              


Keep reading 

            
          
        
        
          
            
              
                Two new tools made available in the CircleCI MCP Server:


  We added the config_helper tool to assist with CircleCI configuration tasks such as providing support for validating .circleci/config.yml files, recommending fixes, and suggesting best practice improvements.
  We added the find_flaky_tests tool to identify and analyze flaky tests in CircleCI projects, supporting both project URL and local git repository context.


Download the MCP Server here

              
              
              


Collapse 

            
          
        
      
    
      
        
      
  

  
    
      Apr 11, 2025
    
    
      
        
        


  
    
    
    
    
    
    Maintenance
  


      
    
  
  
    
  
  
    
      Apr 11, 2025
    
    
      
        
        
        Server Release 4.7.3    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Maintenance
  


      
    

    
      
        
          
            Updates

  oidc-tasks-service runs migrations before it’s main container is deployed
  Remote Docker and Machine jobs can now assume an IAM role by configuring machine_provisioner.providers.ec2.assumedRoleArn in your values.yaml


Bug Fixes

  /workflow-run/ route has been added to kong. Links for approval jobs will now be correctly routed on GHE
  The OIDC plugin now supports custom certificates
  A docker-provisioner custom config can not be provided in your helm upgrade command via --set-file
  upgraded nextjs to resolve related CVEs


          
          
        
        
      
    
      
        
          
          



  
  
  
  
  
  Server

        
      
  

  
    
      Apr 09, 2025
    
    
      
        
        


  
    
    
    
    
    
    New feature
  


      
    
  
  
    
  
  
    
      Apr 09, 2025
    
    
      
        
        
        MCP Server for CircleCI now available    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    New feature
  


      
    

    
      
        
          
            We’ve recently rolled out the CircleCI Model Context Protocol (MCP) Server. This enables developers using tools (Claude Code, Cursor, Windsurf, etc.) that support the MCP protocol to interact with CircleCI.

          
          
            
              
              


Keep reading 

            
          
        
        
          
            
              
                We’ve recently rolled out the CircleCI Model Context Protocol (MCP) Server. This enables developers using tools (Claude Code, Cursor, Windsurf, etc.) that support the MCP protocol to interact with CircleCI.

Agents and AI tools can now fulfill developer requests, such as “Find the latest failed pipeline on my branch and get logs.” This eliminates the need to navigate through the UI or use complex CLI commands to debug and solve problems.
This is the initial release, and we will continuously be updating what the server can do over the coming weeks. If you would like to contribute, please don’t hesitate to put in a pull request.

For more details and example use cases, check out our documentation and our blog post.

For questions or feedback, please open an issue on the GitHub repository.

              
              
              


Collapse 

            
          
        
      
    
      
        
      
  

  
    
      Apr 09, 2025
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    
  
  
    
  
  
    
      Apr 09, 2025
    
    
      
        
        
        Changes to dropdown options in "Add trigger" and "Add pipeline" forms    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    

    
      
        
          
            The “Trigger type” dropdown in the “Add trigger” form (Project Settings > Triggers) has been updated with the following changes:

          
          
            
              
              


Keep reading 

            
          
        
        
          
            
              
                The “Trigger type” dropdown in the “Add trigger” form (Project Settings > Triggers) has been updated with the following changes:


  “GitHub App” is now the default pre-selected  option for all organization types
  For organizations using CircleCI’s GitHub OAuth App integration, the dropdown now displays only the three valid trigger options: GitHub App, Custom Webhook, and Schedule




Similarly. the “Integration” dropdown in the “Add pipeline” form (Project Settings > Pipelines) has been updated with the following changes:


  “GitHub App” is now the default pre-selected  option for all organization types
  For organizations using CircleCI’s GitHub OAuth App integration, the dropdown now only includes the option “GitHub App”




              
              
              


Collapse 

            
          
        
      
    
      
        
      
  

  
    
      Apr 09, 2025
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    
  
  
    
  
  
    
      Apr 09, 2025
    
    
      
        
        
        Update - Breaking Change- April 28th 2025 - Skipped Status Will Now Return Success     
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    

    
      
        
          
            Clarification - All VCS status checks are impacted.

          
          
            
              
              


Keep reading 

            
          
        
        
          
            
              
                Clarification - All VCS status checks are impacted.

What is changing?

Status checks previously sent skipped job statuses as failures, now they will be sent as successful checks. This is to align with GitHub’s definition of skipped status.

This means that “skipped” will not prevent pull request merging, even if it is a required check.

List workflow jobs v2 API previously returned jobs with blocked statuses for jobs that never ran, now they will return as a skipped status.

Why are we doing this?

To improve the lifecycle of jobs and enable features such as finally jobs, all jobs will transition from blocked to one of the terminal states 
(success, failed, canceled, skipped, unauthorized).

When will it happen?

28th April 2025

              
              
              


Collapse 

            
          
        
      
    
      
        
      
  

  
    
      Apr 08, 2025
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    
  
  
    
  
  
    
      Apr 08, 2025
    
    
      
        
        
        CIRCLE_PULL_REQUEST env variable now populated for GitHub App pipelines     
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    

    
      
        
          
            The environment variable CIRCLE_PULL_REQUEST is now populated for all pipelines triggered from GitHub, regardless of integration type, whenever the triggering commit is associated with a pull request.

          
          
            
              
              


Keep reading 

            
          
        
        
          
            
              
                The environment variable CIRCLE_PULL_REQUEST is now populated for all pipelines triggered from GitHub, regardless of integration type, whenever the triggering commit is associated with a pull request.

For GitHub App pipelines specifically, the pipeline variable pipeline.event.context.github.pr_url is also populated with the same information.

Previously, the CIRCLE_PULL_REQUEST environment variable was only populated for pipelines that used CircleCI’s GitHub OAuth App integration.

              
              
              


Collapse 

            
          
        
      
    
      
        
      
  

  
    
      Apr 08, 2025
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    
  
  
    
  
  
    
      Apr 08, 2025
    
    
      
        
        
        Auto-populate trigger pipeline modal parameters based on selected pipeline.     
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    

    
      
        
          
            Parameters in the trigger pipeline modal now automatically populate based on the pipeline selected in the dropdown menu at the top of the form.

          
          
            
              
              


Keep reading 

            
          
        
        
          
            
              
                Parameters in the trigger pipeline modal now automatically populate based on the pipeline selected in the dropdown menu at the top of the form.

Currently, this feature is only available for pipelines that are configured with CircleCI’s GitHub App integration. For pipelines that use CircleCI’s GitHub OAuth App integration, parameters continue to auto-populate based on the config file used in the most recent pipeline run, regardless of whether it matches the pipeline that has been selected.

              
              
              


Collapse 

            
          
        
      
    
      
        
      
  

  
    
      Apr 03, 2025
    
    
      
        
        


  
    
    
    
    
    
    Maintenance
  


      
    
  
  
    
  
  
    
      Apr 03, 2025
    
    
      
        
        
        Docker Executor Infrastructure Upgrade - Complete    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Maintenance
  


      
    

    
      
        
          
            The host OS that Docker jobs run on is being upgraded to support new features and ongoing security and bug patches. This upgrade has now been rolled out to all customers.

          
          
            
              
              


Keep reading 

            
          
        
        
          
            
              
                The host OS that Docker jobs run on is being upgraded to support new features and ongoing security and bug patches. This upgrade has now been rolled out to all customers.

Learn more about this change in Discuss: Docker Executor Infrastructure Upgrade.

              
              
              


Collapse 

            
          
        
      
    
      
        
      
  

  
    
      Mar 28, 2025
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    
  
  
    
  
  
    
      Mar 28, 2025
    
    
      
        
        
        CI Skip and Only build PRs will no longer create pipelines    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    

    
      
        
          
            What is changing?

          
          
            
              
              


Keep reading 

            
          
        
        
          
            
              
                What is changing?

Workflows that were previously marked as not_run—due to CI skip conditions or the “only build PRs” feature flag—will no longer create pipelines. These pipelines will not appear in the UI or API. However, the trigger event will still be recorded in the audit logs.

Why are we doing this?

Showing skipped pipelines clutters the UI and API with information that’s irrelevant to users. This behavior is also inconsistent with other VCS integrations. Removing these entries increases consistency and improves the overall user experience.

When will it happen?

14th April 2025

              
              
              


Collapse 

            
          
        
      
    
      
        
      
  

  
    
      Mar 28, 2025
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    
  
  
    
  
  
    
      Mar 28, 2025
    
    
      
        
        
        Display "Authorize" button on the navbar if user has not authorized GitHub App    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    

    
      
        
          
            When using the GitHub App integration, each user needs to “authorize” the CircleCI GitHub App for their pipelines to be correctly attributed to them. Not doing so means:

          
          
            
              
              


Keep reading 

            
          
        
        
          
            
              
                When using the GitHub App integration, each user needs to “authorize” the CircleCI GitHub App for their pipelines to be correctly attributed to them. Not doing so means:


  their pipelines won’t have access to contexts
  their pipelines won’t run if they have enabled the setting “Prevent unregistered user spend”
  they can’t manually trigger pipelines through the UI


Previously, the “Authorize” button was only available in the Pipeline and Trigger forms - two pages that most users don’t commonly visit.

In order to make it as easy as possible for users to know that they are not “authorized” and to take action on it, we introduced a call to action on the navigation bar.

The “Authorize” button appears only when the organization has the GitHub App installed, and the current user is not yet authorized.



IMPORTANT: This change is being released incrementally to selected organizations to ensure optimal user experience before full deployment.

              
              
              


Collapse 

            
          
        
      
    
      
        
      
  

  
    
      Mar 28, 2025
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    
  
  
    
  
  
    
      Mar 28, 2025
    
    
      
        
        
        Disable SSH Rerun by Project    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    

    
      
        
          
            Project admins can now disable SSH rerun for individual projects via Project Settings>Advanced or the CircleCI v2 API.

          
          
        
        
      
    
      
        
      
  

  
    
      Mar 27, 2025
    
    
      
        
        


  
    
    
    
    
    
    Maintenance
  


      
    
  
  
    
  
  
    
      Mar 27, 2025
    
    
      
        
        
        Japanese Documentation Pages to be Discontinued    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Maintenance
  


      
    

    
      
        
          
            Effective April 1, 2025, all Japanese versions of our public documentation will be removed from the site. The language switcher will also be discontinued.

          
          
            
              
              


Keep reading 

            
          
        
        
          
            
              
                Effective April 1, 2025, all Japanese versions of our public documentation will be removed from the site. The language switcher will also be discontinued.

Please use the English version of these pages for the most accurate and up-to-date information about using CircleCI.

If you have questions or feedback about this change, please visit our community forum.

              
              
              


Collapse 

            
          
        
      
    
      
        
      
  

  
    
      Mar 27, 2025
    
    
      
        
        


  
    
    
    
    
    
    Maintenance
  


      
    
  
  
    
  
  
    
      Mar 27, 2025
    
    
      
        
        
        Docker Executor Infrastructure Upgrade - Docker ARM and IP Ranges    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Maintenance
  


      
    

    
      
        
          
            The host OS that Docker jobs run on is being upgraded to support new features and ongoing security and bug patches. This upgrade is being applied to jobs using Docker ARM and IP ranges from now through April 1.

          
          
            
              
              


Keep reading 

            
          
        
        
          
            
              
                The host OS that Docker jobs run on is being upgraded to support new features and ongoing security and bug patches. This upgrade is being applied to jobs using Docker ARM and IP ranges from now through April 1.

Learn more about this change in Discuss: Docker Executor Infrastructure Upgrade.

              
              
              


Collapse 

            
          
        
      
    
      
        
      
  

  
    
      Mar 26, 2025
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    
  
  
    
  
  
    
      Mar 26, 2025
    
    
      
        
        
        UI changes to the pipelines page    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    

    
      
        
          
            We have introduced some UI changes to the pipelines page:

          
          
            
              
              


Keep reading 

            
          
        
        
          
            
              
                We have introduced some UI changes to the pipelines page:




  
    The column previously named “Project” was renamed into “Pipeline”

    It displays pipeline name, pipeline number, and (only when looking at the All pipelines view) project name
  
  
    The column previously named “Trigger event” was renamed into “Checkout source”

    It continues to show the same information as before, but the avatar now shows the profile picture of the commit author, if that information is available. If it isn’t (this is currently the case for OAuth pipelines), the avatar does not show.
  To avoid this inconsistency, we plan on hiding the avatar also for other types of pipelines.
  
  
    A new column “Trigger event” was added

    It shows what event that triggered a pipeline (Push, Pull request, API, …). The avatar indicates who triggered the event, with a tooltip showing the username on hover.
  
  
    The headers of columns Pipeline and Trigger event each include tooltips, informing users that:
    
      it’s now possible to have multiple pipelines in the same project
      more GitHub trigger events options are now available
    

    These tooltips are visible to orgs that integrate with our GitHub OAuth app integration or GitHub App/GitLab/Bitbucket Data Center integrations. They are not visible to organizations that integrate with Bitbucket Cloud..
  


These changes are currently in preview, and additional improvements will be made in the coming weeks. If you have any feedback, please comment on this post on our community forum.

              
              
              


Collapse 

            
          
        
      
    
      
        
      
  

  
    
      Mar 26, 2025
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    
  
  
    
  
  
    
      Mar 26, 2025
    
    
      
        
        
        Context restriction APIs marked GA    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    

    
      
        
          
            The context restriction APIs have been promoted from experimental to generally available. Authorized users can now create, read, and delete project- and expression-based context restrictions via API. Security group context restrictions are not supported yet. Read the context API documentation.

          
          
        
        
      
    
      
        
          
          



  
  
  
  
  
  Dev tools

        
      
  

  
    
      Mar 18, 2025
    
    
      
        
        


  
    
    
    
    
    
    Maintenance
  


      
    
  
  
    
  
  
    
      Mar 18, 2025
    
    
      
        
        
        Runner Release 3.1.3    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Maintenance
  


      
    

    
      
        
          
            Runner Release 3.1.2
Machine Runner:

          
          
            
              
              


Keep reading 

            
          
        
        
          
            
              
                Runner Release 3.1.2
Machine Runner:


  Fixed a bug where an error downloading the task agent binary was not correctly propagated, causing the runner to get stuck without retrying the download and requiring a manual restart to unblock.


              
              
              


Collapse 

            
          
        
      
    
      
        
          
          



  
  
  
  
  
  Runner

        
      
  

  
    
      Mar 18, 2025
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    
  
  
    
  
  
    
      Mar 18, 2025
    
    
      
        
        
        New context timeout error messaging    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    

    
      
        
          
            A new error message has been added to the contexts page to help users differentiate between page timeouts and permission errors. Previously, it was unclear to the user whether page load issues could be resolved with a refresh. Now, users who have the correct permissions will see “Please try again in a few minutes.” if contexts take a long time to load.

          
          
        
        
      
    
      
        
      
  

  
    
      Mar 17, 2025
    
    
      
        
        


  
    
    
    
    
    
    New feature
  


      
    
  
  
    
  
  
    
      Mar 17, 2025
    
    
      
        
        
        Project overview page    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    New feature
  


      
    

    
      
        
          
            We’ve introduced a new project overview page, which allows users to get a quick sense of the health of their pipelines and see what changes have recently been deployed for a project all in one place. Users can access this page by clicking the Overview link from the Organization Home page or Projects page.

          
          
            
              
              


Keep reading 

            
          
        
        
          
            
              
                We’ve introduced a new project overview page, which allows users to get a quick sense of the health of their pipelines and see what changes have recently been deployed for a project all in one place. Users can access this page by clicking the Overview link from the Organization Home page or Projects page.

If you have any feedback on how we can improve this overview, please use the survey popup in the bottom right corner of the page to let us know!



              
              
              


Collapse 

            
          
        
      
    
      
        
      
  

  
    
      Mar 15, 2025
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    
  
  
    
  
  
    
      Mar 15, 2025
    
    
      
        
        
        Manage GitHub App installation from the organization settings page "VCS Connections"    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    

    
      
        
          
            The tab “VCS” in Organization Settings has been renamed into “VCS Connections”, and it now includes a section dedicated to the GitHub App integration.

          
          
            
              
              


Keep reading 

            
          
        
        
          
            
              
                The tab “VCS” in Organization Settings has been renamed into “VCS Connections”, and it now includes a section dedicated to the GitHub App integration.

If the CircleCI GitHub App is not installed, it provides an overview of the functionality enabled by the App.


If the CircleCI GitHub App is installed, it shows which GitHub organization it’s connected to, and lets admin access the configuration page


The settings button redirects to the GitHub installation page. 
The delete button opens a modal which requires additional user input to confirm uninstallation of the GitHub App. Both actions are restricted to organization admins only.

              
              
              


Collapse 

            
          
        
      
    
      
        
      
  

  
    
      Mar 14, 2025
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    
  
  
    
  
  
    
      Mar 14, 2025
    
    
      
        
        
        Prevent non-admin users from installing the GitHub App    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    

    
      
        
          
            The GitHub App pipeline and trigger forms have been updated to prevent non-admin users from attempting to install the CircleCI GitHub App.

          
          
        
        
      
    
      
        
      
  

  
    
      Mar 12, 2025
    
    
      
        
        


  
    
    
    
    
    
    Maintenance
  


      
    
  
  
    
  
  
    
      Mar 12, 2025
    
    
      
        
        
        Added automatic redirect for logged-out users     
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Maintenance
  


      
    

    
      
        
          
            Users who land on the user homepage while logged out are now automatically redirected to the login page.

          
          
        
        
      
    
      
        
      
  

  
    
      Mar 12, 2025
    
    
      
        
        


  
    
    
    
    
    
    New feature
  


      
    
  
  
    
  
  
    
      Mar 12, 2025
    
    
      
        
        
        Avoid commit conflicts in your pipelines with serial-jobs    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    New feature
  


      
    

    
      
        
          
            The queue orb was previously used to avoid multiple pipeline race conditions and conflicts. Serial-job provides native support for the functionality provided by the queue orb. Overtime we will expand the use cases we support to cover additional challenges like multi-job or workflows. The first release is serial-group for individual jobs.

          
          
            
              
              


Keep reading 

            
          
        
        
          
            
              
                The queue orb was previously used to avoid multiple pipeline race conditions and conflicts. Serial-job provides native support for the functionality provided by the queue orb. Overtime we will expand the use cases we support to cover additional challenges like multi-job or workflows. The first release is serial-group for individual jobs.

This allows an individual job to be serialized across the organization, project or branch based on the parameters you provide. Serialization will ensure the jobs are executed in the order in which the pipelines are started via commit, api or other triggering method.

To learn more about your options see the documentation.

              
              
              


Collapse 

            
          
        
      
    
      
        
      
  

  
    
      Mar 12, 2025
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    
  
  
    
  
  
    
      Mar 12, 2025
    
    
      
        
        
        Show in-app instructions for how to delete OAuth trigger    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    

    
      
        
          
            A growing number of GitHub OAuth customers have been looking to stop building their OAuth pipelines in favour of the new GitHub App pipelines which provide a broader range of triggering options.

          
          
            
              
              


Keep reading 

            
          
        
        
          
            
              
                A growing number of GitHub OAuth customers have been looking to stop building their OAuth pipelines in favour of the new GitHub App pipelines which provide a broader range of triggering options.

This is currently a manual process, which requires making changes in GitHub.

To avoid users having to refer to the docs for instructions, we added a “delete” icon next to the OAuth trigger (Project Settings > Triggers), which opens a modal containing instructions for how to disable the OAuth trigger manually.



              
              
              


Collapse 

            
          
        
      
    
      
        
      
  

  
    
      Mar 11, 2025
    
    
      
        
        


  
    
    
    
    
    
    Maintenance
  


      
    
  
  
    
  
  
    
      Mar 11, 2025
    
    
      
        
        
        Fixed infinite loading spinner on Pipelines page    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Maintenance
  


      
    

    
      
        
          
            A bug that was causing the loading spinner to spin infinitely when no additional pipelines were available after clicking the ‘See more’ button on the pipelines page has been fixed.

          
          
        
        
      
    
      
        
      
  

  
    
      Mar 06, 2025
    
    
      
        
        


  
    
    
    
    
    
    Maintenance
  


      
    
  
  
    
  
  
    
      Mar 06, 2025
    
    
      
        
        
        Bug fix when selecting repository for new projects    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Maintenance
  


      
    

    
      
        
          
            Users of CircleCI’s GitHub App integration would occasionally not be able to see a list of repositories to choose from when creating a new project.  This bug has been fixed.

          
          
        
        
      
    
      
        
      
  

  
    
      Mar 06, 2025
    
    
      
        
        


  
    
    
    
    
    
    Maintenance
  


      
    
  
  
    
  
  
    
      Mar 06, 2025
    
    
      
        
        
        Timing tab bug fixed    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Maintenance
  


      
    

    
      
        
          
            A bug that was causing the “Timing” tab in the CircleCI web app to show UUIDs instead of a string of the step name has been fixed.

          
          
        
        
      
    
      
        
      
  

  
    
      Mar 06, 2025
    
    
      
        
        


  
    
    
    
    
    
    Maintenance
  


      
    
  
  
    
  
  
    
      Mar 06, 2025
    
    
      
        
        
        Bug causing full dark screen on loading modal fixed    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Maintenance
  


      
    

    
      
        
          
            A bug that caused a nearly full dark screen when creating a new project in organizations that integrate with CircleCI’s GitHub App has now been fixed.

          
          
        
        
      
    
      
        
      
  

  
    
      Mar 04, 2025
    
    
      
        
        


  
    
    
    
    
    
    Maintenance
  


      
    
  
  
    
  
  
    
      Mar 04, 2025
    
    
      
        
        
        Release Agent Release 1.3.7    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Maintenance
  


      
    

    
      
        
          
            Changes:

  Patched critical CVEs


See more details here.

          
          
        
        
      
    
      
        
      
  

  
    
      Mar 04, 2025
    
    
      
        
        


  
    
    
    
    
    
    Maintenance
  


      
    
  
  
    
  
  
    
      Mar 04, 2025
    
    
      
        
        
        Minor changes to Pipeline Editor page    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Maintenance
  


      
    

    
      
        
          
            

  Added quick-start options to make it easier to understand what types of questions can be asked
  Loading screen adjusted to be smoother when a new pipeline is triggered
  Minor copy changes


          
          
        
        
      
    
      
        
      
  

  
    
      Mar 03, 2025
    
    
      
        
        


  
    
    
    
    
    
    Maintenance
  


      
    
  
  
    
  
  
    
      Mar 03, 2025
    
    
      
        
        
        OIDC signing keys updated    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Maintenance
  


      
    

    
      
        
          
            CircleCI periodically updates the keys used to sign OIDC tokens in alignment with security best practices. No customer action is required to continue using OIDC with previously configured services.

          
          
        
        
      
    
      
        
      
  

  
    
      Mar 03, 2025
    
    
      
        
        


  
    
    
    
    
    
    New feature
  


      
    
  
  
    
  
  
    
      Mar 03, 2025
    
    
      
        
        
        Single Sign On for GitHub OAuth and Bitbucket Cloud    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    New feature
  


      
    

    
      
        
          
            Single sign on (SSO) is now available for Cloud Scale plan customers with CircleCI organizations connected to GitHub OAuth and Bitbucket Cloud. Learn how to connect your identity provider and enforce SSO for users in your org.

          
          
        
        
      
    
      
        
      
  

  
    
      Feb 28, 2025
    
    
      
        
        


  
    
    
    
    
    
    Maintenance
  


      
    
  
  
    
  
  
    
      Feb 28, 2025
    
    
      
        
        
        Release Agent Release 1.3.6    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Maintenance
  


      
    

    
      
        
          
            Changes:

  Patched critical CVEs


See more details here.

          
          
        
        
      
    
      
        
      
  

  
    
      Feb 24, 2025
    
    
      
        
        


  
    
    
    
    
    
    New feature
  


      
    
  
  
    
  
  
    
      Feb 24, 2025
    
    
      
        
        
        Trigger pipelines on push to non-draft PR    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    New feature
  


      
    

    
      
        
          
            It is now possible to configure pipelines to be triggered only on pushes to non-draft Pull Requests.

          
          
            
              
              


Keep reading 

            
          
        
        
          
            
              
                It is now possible to configure pipelines to be triggered only on pushes to non-draft Pull Requests.

Who Can Use This?
This functionality is available to all customers that use GitHub.

If your organization is currently integrated with GitHub only through OAuth, an admin must take the one-time action of installing the CircleCI GitHub App to enable this functionality.



Getting Started

  Go to your project’s Project Settings > Pipelines, and ensure you have a “GitHub App” pipeline defined
  Go to Project Settings > Triggers, and define a GitHub App trigger
  In the “run on” menu, select “Pushes to open non-draft PRs”
  Trigger your GitHub App pipeline by pushing to a non-draft PR




For more details on newly supported GitHub trigger events and example use cases, check out our documentation.
For any questions or feedback, email benedetta@circleci.com.

              
              
              


Collapse 

            
          
        
      
    
      
        
      
  

  
    
      Feb 24, 2025
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    
  
  
    
  
  
    
      Feb 24, 2025
    
    
      
        
        
        Default value added to 'Config File Path' in 'Add pipeline' form    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    

    
      
        
          
            When creating a new pipeline (Project Settings > Pipeline), the field “Config File Path” now contains a default value (circleci/config.yml) that the user can edit, instead of a placeholder.

          
          
        
        
      
    
      
        
      
  

  
    
      Feb 24, 2025
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    
  
  
    
  
  
    
      Feb 24, 2025
    
    
      
        
        
        Fixed a bug preventing pipeline name edits    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    

    
      
        
          
            A bug prevented editing the pipeline name in Project Settings > Pipelines > Edit. 
This has now been fixed.

          
          
        
        
      
    
      
        
      
  

  
    
      Feb 24, 2025
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    
  
  
    
  
  
    
      Feb 24, 2025
    
    
      
        
        
        Added link to help troubleshoot GitHub App installation issues    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    

    
      
        
          
            The “Add Pipeline” form (Project Settings > Pipelines) now includes links to a Google Form that helps customers troubleshoot common issues related to GitHub App installation and permissions.

          
          
            
              
              


Keep reading 

            
          
        
        
          
            
              
                The “Add Pipeline” form (Project Settings > Pipelines) now includes links to a Google Form that helps customers troubleshoot common issues related to GitHub App installation and permissions.



              
              
              


Collapse 

            
          
        
      
    
      
        
      
  

  
    
      Feb 21, 2025
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    
  
  
    
  
  
    
      Feb 21, 2025
    
    
      
        
        
        Fixed a bug preventing repeated PR events on the same SHA from re-triggering pipelines    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    

    
      
        
          
            This bug has been fixed, and the note removed from the docs.

          
          
            
              
              


Keep reading 

            
          
        
        
          
            
              
                This bug has been fixed, and the note removed from the docs.



              
              
              


Collapse 

            
          
        
      
    
      
        
      
  

  
    
      Feb 21, 2025
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    
  
  
    
  
  
    
      Feb 21, 2025
    
    
      
        
        
        Release Agent Release 1.3.5    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    

    
      
        
          
            Changes:

  Fixed a bug that prevented the release agent from starting up when Argo Rollouts was not installed in the cluster


See more details here.

          
          
        
        
      
    
      
        
      
  

  
    
      Feb 21, 2025
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    
  
  
    
  
  
    
      Feb 21, 2025
    
    
      
        
        
        Updated wording for the 'Build forked pull request' project setting    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    

    
      
        
          
            The “build forked pull request” setting in Project Settings > Advanced has been updated to clarify that it only applies to OAuth pipelines, not GitHub App pipelines.

          
          
            
              
              


Keep reading 

            
          
        
        
          
            
              
                The “build forked pull request” setting in Project Settings > Advanced has been updated to clarify that it only applies to OAuth pipelines, not GitHub App pipelines.

This is an important clarification, given that organizations that use the GitHub OAuth App can now also run pipelines integrated via GitHub App to leverage new features.



              
              
              


Collapse 

            
          
        
      
    
      
        
      
  

  
    
      Feb 20, 2025
    
    
      
        
        


  
    
    
    
    
    
    New feature
  


      
    
  
  
    
  
  
    
      Feb 20, 2025
    
    
      
        
        
        Introducing a pipeline iteration experience for new users    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    New feature
  


      
    

    
      
        
          
            We have introduced a new pipeline iteration experience for new users in organizations integrated with GitHub App. This assisted experience is available after setting up new projects or through the Workflow and Jobs pages, where users can chat and receive real-time support for their pipelines.

          
          
        
        
      
    
      
        
      
  

  
    
      Feb 18, 2025
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    
  
  
    
  
  
    
      Feb 18, 2025
    
    
      
        
        
        Fixed pill size on Pipelines and Triggers pages    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    

    
      
        
          
            The pill sizes on the ‘Pipelines’ and ‘Triggers’ pages in Project Settings have been adjusted for consistency.

          
          
        
        
      
    
      
        
      
  

  
    
      Feb 17, 2025
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    
  
  
    
  
  
    
      Feb 17, 2025
    
    
      
        
        
        Updated wording for the 'Only Build Pull Requests' project setting    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    

    
      
        
          
            The “only build pull request” setting in Project Settings > Advanced has been updated to clarify that it only applies to OAuth pipelines, not GitHub App pipelines.

          
          
            
              
              


Keep reading 

            
          
        
        
          
            
              
                The “only build pull request” setting in Project Settings > Advanced has been updated to clarify that it only applies to OAuth pipelines, not GitHub App pipelines.

This is an important clarification, given that organizations that use the GitHub OAuth App can now also run pipelines integrated via GitHub App to leverage new features.



              
              
              


Collapse 

            
          
        
      
    
      
        
      
  

  
    
      Feb 17, 2025
    
    
      
    
  
  
    
  
  
    
      Feb 17, 2025
    
    
      
        
        
        Triggers page now includes columns "pipeline to trigger" and "events"     
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
    

    
      
        
          
            The triggers table displayed in Project Settings > Triggers now includes two additional columns: “Pipeline to trigger” and “events”.

          
          
            
              
              


Keep reading 

            
          
        
        
          
            
              
                The triggers table displayed in Project Settings > Triggers now includes two additional columns: “Pipeline to trigger” and “events”.

  Pipeline to trigger indicates the name of the pipeline associated with each trigger
  Events indicates which trigger events will cause the pipeline to run (e.g. “All pushes”, “PR opened”, “PR merged”, …)




              
              
              


Collapse 

            
          
        
      
    
      
        
      
  

  
    
      Feb 14, 2025
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    
  
  
    
  
  
    
      Feb 14, 2025
    
    
      
        
        
        Improved Error Summarizer opt-ins for organization admins    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    

    
      
        
          
            Organization admins can now enable the in-app Error Summarizer via a modal on the same page, eliminating the need to navigate to Organization Settings. If a user is not an organization admin, the modal will inform them that they need to contact their organization admin to enable the setting in Organization Settings > Advanced.

          
          
        
        
      
    
      
        
      
  

  
    
      Feb 13, 2025
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    
  
  
    
  
  
    
      Feb 13, 2025
    
    
      
        
        
        Release Agent Release 1.3.4    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Enhancement
  


      
    

    
      
        
          
            Changes

  Improved logging when rollout controller is not found
  Minor bug fixes


See more details here.

          
          
        
        
      
    
      
        
      
  

  
    
      Feb 13, 2025
    
    
      
        
        


  
    
    
    
    
    
    Maintenance
  


      
    
  
  
    
  
  
    
      Feb 13, 2025
    
    
      
        
        
        Runner Release 3.1.2    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Maintenance
  


      
    

    
      
        
          
            Runner Release 3.1.2
Container Runner:

          
          
            
              
              


Keep reading 

            
          
        
        
          
            
              
                Runner Release 3.1.2
Container Runner:


  Set resource requirements (requests and limits) on the orchestrator init container (https://github.com/circleci/runner-init). This change helps ensure the Pod is schedulable when resource quotas are applied.
  Added options to configure the image name for the orchestrator container. This can be used for hosting the image in a private registry or within an air-gapped environment on CircleCI server. Note this change requires version v101.1.3 of the Helm chart.


              
              
              


Collapse 

            
          
        
      
    
      
        
          
          



  
  
  
  
  
  Runner

        
      
  

  
    
      Feb 13, 2025
    
    
      
        
        


  
    
    
    
    
    
    Maintenance
  


      
    
  
  
    
  
  
    
      Feb 13, 2025
    
    
      
        
        
        Docker Executor Infrastructure Upgrade - In Progress    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Maintenance
  


      
    

    
      
        
          
            The host OS that Docker jobs run on has been upgraded to support new features and ongoing security and bug patches. This upgrade will roll out to all customers over the next few weeks. Affected customers have been notified via email. Learn more about this change in Discuss: Docker Executor Infrastructure Upgrade.

          
          
        
        
      
    
      
        
      
  

  
    
      Feb 07, 2025
    
    
      
        
        


  
    
    
    
    
    
    Maintenance
  


      
    
  
  
    
  
  
    
      Feb 07, 2025
    
    
      
        
        
        Server Release 4.5.8    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Maintenance
  


      
    

    
      
        
          
            Updates

  Patched critical CVEs in web-ui-insights and webhook-service.


Bug fixes

  Fixed a vulnerability that allowed unauthenticated access to artifacts associated with public repositories.
  Resolved a bug that prevented a job from being rerun using SSH.


          
          
        
        
      
    
      
        
          
          



  
  
  
  
  
  Server

        
      
  

  
    
      Feb 07, 2025
    
    
      
        
        


  
    
    
    
    
    
    Maintenance
  


      
    
  
  
    
  
  
    
      Feb 07, 2025
    
    
      
        
        
        Server Release 4.7.2    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Maintenance
  


      
    

    
      
        
          
            Updates

  Patched critical CVEs in web-ui-insights and webhook-service.


Bug fixes

  Fixed a vulnerability that allowed unauthenticated access to artifacts associated with public repositories.


          
          
        
        
      
    
      
        
          
          



  
  
  
  
  
  Server

        
      
  

  
    
      Feb 07, 2025
    
    
      
        
        


  
    
    
    
    
    
    Maintenance
  


      
    
  
  
    
  
  
    
      Feb 07, 2025
    
    
      
        
        
        Server Release 4.4.11    
        
          


  
    
      
    
    Copy URL to clipboard
    Copied!
    Error!
  

        
      
    
    
      
        
        


  
    
    
    
    
    
    Maintenance
  


      
    

    
      
        
          
            Updates

  Updated the library dependencies for runner-admin
  CVE patches for web-ui-insights and webhook-service


Bug fixes

  Fixed a vulnerability where artifacts relating to public repositories could be accessed without authentication
  Fixed a bug where workflows in a terminal state with blocked jobs were incorrectly cancelled when a new workflow was triggered with redundant pipeline cancellation enabled.


          
          
        
        
      
    
      
        
          
          



  
  
  
  
  
  Server\n\n\n\nAccelerate your DevOps practices with CircleCI integrations
    Build your ideal toolchain. Explore integrations that bring flexibility and power to your CI/CD workflows.
  


  
    
      Filter by
      
        
          
            
              Select a filter…
              
                All integrations
                
                  
                  
                  
                    Artifacts / Registry
                  
                
                  
                  
                  
                    Build
                  
                
                  
                  
                  
                    Cloud Platform
                  
                
                  
                  
                  
                    Code Analysis
                  
                
                  
                  
                  
                    Collaboration
                  
                
                  
                  
                  
                    Containers
                  
                
                  
                  
                  
                    Deployment
                  
                
                  
                  
                  
                    Infra Automation
                  
                
                  
                  
                  
                    Kubernetes
                  
                
                  
                  
                  
                    Language / Framework
                  
                
                  
                  
                  
                    Monitoring
                  
                
                  
                  
                  
                    Notifications
                  
                
                  
                  
                  
                    Reporting
                  
                
                  
                  
                  
                    Security
                  
                
                  
                  
                  
                    Testing
                  
                
              
            
            
              
            
          
        
        
          
            All integrations
          
        
          
          
          
            
              Artifacts / Registry
            
          
        
          
          
          
            
              Build
            
          
        
          
          
          
            
              Cloud Platform
            
          
        
          
          
          
            
              Code Analysis
            
          
        
          
          
          
            
              Collaboration
            
          
        
          
          
          
            
              Containers
            
          
        
          
          
          
            
              Deployment
            
          
        
          
          
          
            
              Infra Automation
            
          
        
          
          
          
            
              Kubernetes
            
          
        
          
          
          
            
              Language / Framework
            
          
        
          
          
          
            
              Monitoring
            
          
        
          
          
          
            
              Notifications
            
          
        
          
          
          
            
              Reporting
            
          
        
          
          
          
            
              Security
            
          
        
          
          
          
            
              Testing
            
          
        
        
      
    
      
        
          
            All integrations
          
          
            
            
            
              
                Artifacts / Registry
              
            
          
            
            
            
              
                Build
              
            
          
            
            
            
              
                Cloud Platform
              
            
          
            
            
            
              
                Code Analysis
              
            
          
            
            
            
              
                Collaboration
              
            
          
            
            
            
              
                Containers
              
            
          
            
            
            
              
                Deployment
              
            
          
            
            
            
              
                Infra Automation
              
            
          
            
            
            
              
                Kubernetes
              
            
          
            
            
            
              
                Language / Framework
              
            
          
            
            
            
              
                Monitoring
              
            
          
            
            
            
              
                Notifications
              
            
          
            
            
            
              
                Reporting
              
            
          
            
            
            
              
                Security
              
            
          
            
            
            
              
                Testing
              
            
          
        
      
      
        
        All integrations

        
          
          
          
            
            
            
            
            
            
              
                
                
                  ACCELQ
                  
                    
                      
                      
                      
                        
                          Testing
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      ACCELQ
                      Testing
                      
                        ACCELQ is a cloud-based continuous testing platform that automates API, web, mobile, DB, and packaged applications without writing code.

                      
                      
                        
                          
                            Visit ACCELQ website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


View documentation 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Accurics
                  
                    
                      
                      
                      
                        
                          Security
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Accurics
                      Security
                      
                        Accurics codifies security into development pipelines to detect and fix cloud infrastructure risks. It maintains the secure posture in runtime by mitigating risks from infrastructure changes.

                      
                      
                        
                          
                            Visit Accurics website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


View documentation 

                        
                      
                        
                        
                        
                        
                          


Watch video overview 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Alcide.io
                  
                    
                      
                      
                      
                        
                          Security
                        
                      
                    
                      
                      
                      
                        
                          Kubernetes
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Alcide.io
                      Security
                      
                        Alcide delivers code-to-production security for workloads running on Kubernetes. Alcide Advisor performs customizable static and active checks of resources, workloads running inside the cluster, as well as checks of the cluster infrastructure itself.

                      
                      
                        
                          
                            Visit Alcide.io website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


View documentation 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Altostra
                  
                    
                      
                      
                      
                        
                          Deployment
                        
                      
                    
                      
                      
                      
                        
                          Infra Automation
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Altostra
                      Deployment
                      
                        Altostra is a no-code infrastructure platform that accelerates modern cloud application development like microservices, serverless applications, and more.

                      
                      
                        
                          
                            Visit Altostra website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


View documentation 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Anchore
                  
                    
                      
                      
                      
                        
                          Security
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Anchore
                      Security
                      
                        Anchore allows both operators and developers to perform detailed analysis, run queries, and define policies on container images for CI/CD pipelines. Only containers that meet your organization’s requirements are deployed into production.

                      
                      
                        
                          
                            Visit Anchore website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


View documentation 

                        
                      
                        
                        
                        
                        
                          


Watch video overview 

                        
                      
                        
                        
                        
                        
                          


Read blog post 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Android
                  
                    
                      
                      
                      
                        
                          Language / Framework
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Android
                      Language / Framework
                      
                        Alcide delivers code-to-production security for workloads running on Kubernetes. Alcide Advisor performs customizable static and active checks of resources, workloads running inside the cluster, as well as checks of the cluster infrastructure itself.

                      
                      
                        
                          
                            Visit Android website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Anecdotes
                  
                    
                      
                      
                      
                        
                          Monitoring
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Anecdotes
                      Monitoring
                      
                        The anecdotes Compliance OS is a data-based Compliance automation and management solution. With anecdotes, cloud-first companies can turn compliance into a business driver.

                      
                      
                        
                          
                            Visit Anecdotes website
                          
                        
                      
                    
                    
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Aqua Security
                  
                    
                      
                      
                      
                        
                          Security
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Aqua Security
                      Security
                      
                        Aqua Security provides a full dev-to-prod security solution for containers and cloud native applications on Kubernetes, Docker, OpenShift, Fargate, AWS, and other container platforms.

                      
                      
                        
                          
                            Visit Aqua Security website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Arm
                  
                    
                      
                      
                      
                        
                          Cloud Platform
                        
                      
                    
                      
                      
                      
                        
                          Infra Automation
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Arm
                      Cloud Platform
                      
                        Arm technology is the industry standard for IoT and embedded devices. Arm offers a range of processor designs, dev tools and software, and an ecosystem of partners for AI and end-to-end security.

                      
                      
                        
                          
                            Visit Arm website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Autify
                  
                    
                      
                      
                      
                        
                          Testing
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Autify
                      Testing
                      
                        Autify makes testing automation easy for anyone by allowing them to automate the testing of web and mobile applications without writing program codes.

                      
                      
                        
                          
                            Visit Autify website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View web orb
                        
                        
                      
                        
                        
                        
                        
                          


View CLI orb 

                        
                      
                        
                        
                        
                        
                          


View mobile orb 

                        
                      
                        
                        
                        
                        
                          


View documentation 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  AWS CLI
                  
                    
                      
                      
                      
                        
                          Cloud Platform
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      AWS CLI
                      Cloud Platform
                      
                        Install and configure the AWS command-line interface. As an AWS Technology Partner, CircleCI makes it easy to integrate CI/CD workflows with AWS using orbs. View AWS Marketplace

                      
                      
                        
                          
                            Visit AWS CLI website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View AWS CLI orb
                        
                        
                      
                        
                        
                        
                        
                          


Learn more 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  AWS CodeDeploy
                  
                    
                      
                      
                      
                        
                          Deployment
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      AWS CodeDeploy
                      Deployment
                      
                        Deploy applications to AWS CodeDeploy. As an AWS Technology Partner, CircleCI makes it easy to integrate CI/CD workflows with AWS using orbs.

                      
                      
                        
                          
                            Visit AWS CodeDeploy website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


Learn more 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Amazon ECR
                  
                    
                      
                      
                      
                        
                          Artifacts / Registry
                        
                      
                    
                      
                      
                      
                        
                          Containers
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Amazon ECR
                      Artifacts / Registry
                      
                        Build images and push them to the Amazon Elastic Container Registry. As an AWS Technology Partner, CircleCI makes it easy to integrate CI/CD workflows with AWS using orbs.

                      
                      
                        
                          
                            Visit Amazon ECR website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


Learn more 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Amazon ECS
                  
                    
                      
                      
                      
                        
                          Deployment
                        
                      
                    
                      
                      
                      
                        
                          Containers
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Amazon ECS
                      Deployment
                      
                        An orb for working with Amazon Elastic Container Service. As an AWS Technology Partner, CircleCI makes it easy to integrate CI/CD workflows with AWS using orbs.

                      
                      
                        
                          
                            Visit Amazon ECS website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


Learn more 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Amazon EKS
                  
                    
                      
                      
                      
                        
                          Deployment
                        
                      
                    
                      
                      
                      
                        
                          Containers
                        
                      
                    
                      
                      
                      
                        
                          Kubernetes
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Amazon EKS
                      Deployment
                      
                        An orb for working with Amazon Elastic Container Service for Kubernetes. As an AWS Technology Partner, CircleCI makes it easy to integrate CI/CD workflows with AWS using orbs. that make it easier than ever.

                      
                      
                        
                          
                            Visit Amazon EKS website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


Learn more 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Amazon Elastic Beanstalk
                  
                    
                      
                      
                      
                        
                          Deployment
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Amazon Elastic Beanstalk
                      Deployment
                      
                        Deploy and scale web applications and services via AWS Elastic Beanstalk with CircleCI. As an AWS Technology Partner, CircleCI makes it easy to integrate CI/CD workflows with AWS using orbs.

                      
                      
                        
                          
                            Visit Amazon Elastic Beanstalk website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


View documentation 

                        
                      
                        
                        
                        
                        
                          


Learn more 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Amazon Health
                  
                    
                      
                      
                      
                        
                          Deployment
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Amazon Health
                      Deployment
                      
                        AWS Health is a RESTful web service that uses HTTPS as a transport and JSON as a message serialization format.

                      
                      
                        
                          
                            Visit Amazon Health website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  AWS SAM Serverless
                  
                    
                      
                      
                      
                        
                          Deployment
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      AWS SAM Serverless
                      Deployment
                      
                        Build, test, and deploy your AWS serverless applications on CircleCI utilizing the AWS SAM Serverless Application Model.

                      
                      
                        
                          
                            Visit AWS SAM Serverless website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


Learn more 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Amazon S3
                  
                    
                      
                      
                      
                        
                          Artifacts / Registry
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Amazon S3
                      Artifacts / Registry
                      
                        A set of tools for working with Amazon S3. Requirements: bash. As an AWS Partner Network Advanced Technology Partner, CircleCI makes it
 easy to integrate CI/CD workflows with AWS. Now with CircleCI orbs for AWS
 that make it easier than ever.

                      
                      
                        
                          
                            Visit Amazon S3 website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


Learn more 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Azure ACR
                  
                    
                      
                      
                      
                        
                          Containers
                        
                      
                    
                      
                      
                      
                        
                          Artifacts / Registry
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Azure ACR
                      Containers
                      
                        Build images and push them to Azure Container Registry. CircleCI partners with Azure and Sirrus7 in the DevOps Acceleration Engine offering in the Azure Marketplace. Also, with orbs for Azure, it’s easy to integrate.

                      
                      
                        
                          
                            Visit Azure ACR website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


Learn more 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Azure AKS
                  
                    
                      
                      
                      
                        
                          Containers
                        
                      
                    
                      
                      
                      
                        
                          Deployment
                        
                      
                    
                      
                      
                      
                        
                          Kubernetes
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Azure AKS
                      Containers
                      
                        CircleCI partners with Azure and Sirrus7 in the DevOps Acceleration Engine offering in the Azure Marketplace. Also, with orbs for Azure, it’s easy to integrate.

                      
                      
                        
                          
                            Visit Azure AKS website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


Learn more 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Azure CLI
                  
                    
                      
                      
                      
                        
                          Cloud Platform
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Azure CLI
                      Cloud Platform
                      
                        Install, initialize, and log into the Azure command-line interface. CircleCI partners with Azure and Sirrus7 in the DevOps Acceleration Engine offering in the Azure Marketplace. Also, with orbs for Azure, it’s easy to integrate.

                      
                      
                        
                          
                            Visit Azure CLI website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


Learn more 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Bitbucket
                  
                    
                      
                      
                      
                        
                          Cloud Platform
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Bitbucket
                      Cloud Platform
                      
                        CircleCI integrates with Bitbucket in a single click, enabling build triggers and build statuses within the Bitbucket UI.

                      
                      
                        
                          
                            Visit Bitbucket website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          Learn more
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Blackfire.io
                  
                    
                      
                      
                      
                        
                          Testing
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Blackfire.io
                      Testing
                      
                        Configures Blackfire agent to aggregate profile data collected by the probe from your application engine before sending it to servers.

                      
                      
                        
                          
                            Visit Blackfire.io website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View agent orb
                        
                        
                      
                        
                        
                        
                        
                          


View documentation 

                        
                      
                        
                        
                        
                        
                          


View PHP orb 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Bridgecrew
                  
                    
                      
                      
                      
                        
                          Security
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Bridgecrew
                      Security
                      
                        Bridgecrew is changing the way teams secure their cloud. By leveraging security-as-code and automation, Bridgecrew identifies and fixes cloud infrastructure misconfigurations in run-time and build-time.

                      
                      
                        
                          
                            Visit Bridgecrew website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


View documentation 

                        
                      
                        
                        
                        
                        
                          


View webinar 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Buildtrakr
                  
                    
                      
                      
                      
                        
                          Reporting
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Buildtrakr
                      Reporting
                      
                        Buildtrakr surfaces critical metrics, powerful drill-down and trend analysis to help you better understand build performance and cost. Buildtrakr is brought to you by the team at Plandek (www.plandek.com) the world-leading end-to-end delivery analytics platform.

                      
                      
                        
                          
                            Visit Buildtrakr website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          Learn more
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  CheckMarx
                  
                    
                      
                      
                      
                        
                          Security
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      CheckMarx
                      Security
                      
                        Checkmarx is the global leader in software security solutions for modern enterprise software development. Their comprehensive software security platform unifies with DevOps to provide static and interactive application security testing, software composition analysis, developer AppSec awareness, and training programs to remediate risk from vulnerabilities. Checkmarx is trusted by more than 40 of the Fortune 100 companies and half of the Fortune 50, including leading organizations like SAP, Samsung, and Salesforce.

                      
                      
                        
                          
                            Visit CheckMarx website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Cloud Foundry
                  
                    
                      
                      
                      
                        
                          Deployment
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Cloud Foundry
                      Deployment
                      
                        Cloud Foundry makes it faster and easier to build, test, deploy and scale applications, providing a choice of clouds, developer frameworks, and application services. It is an open source project and is available through a variety of private cloud distributions and public cloud instances.

                      
                      
                        
                          
                            Visit Cloud Foundry website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  CloudQA
                  
                    
                      
                      
                      
                        
                          Testing
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      CloudQA
                      Testing
                      
                        CloudQA is a codeless test automation tool designed to reduce the effort, cost, and complexity of software testing.  CloudQA helps organizations speed up their testing by 5x with a no-code approach.

                      
                      
                        
                          
                            Visit CloudQA website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


View documentation 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Cloudsmith
                  
                    
                      
                      
                      
                        
                          Artifacts / Registry
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Cloudsmith
                      Artifacts / Registry
                      
                        Cloudsmith is a hosted universal package management service that provides secure repositories to store, share and collaborate on published software assets.

                      
                      
                        
                          
                            Visit Cloudsmith website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


View documentation 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Codecov
                  
                    
                      
                      
                      
                        
                          Code Analysis
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Codecov
                      Code Analysis
                      
                        Codecov is the leading dedicated code coverage solution, helping teams improve code review workflow and quality. Use Codecov’s highly integrated tools to group, merge, archive, and compare coverage reports.

                      
                      
                        
                          
                            Visit Codecov website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


Read blog post 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  CodeScene
                  
                    
                      
                      
                      
                        
                          Code Analysis
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      CodeScene
                      Code Analysis
                      
                        CodeScene is a powerful visualization tool that uses predictive analytics to prioritize technical debt, detect code at risk for defects, and even uncover team productivity bottlenecks.

                      
                      
                        
                          
                            Visit CodeScene website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


View documentation 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  CommitLint
                  
                    
                      
                      
                      
                        
                          Testing
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      CommitLint
                      Testing
                      
                        CommitLint helps your team stick to commit conventions. Npm-installed configurations are supported, making it easy to share commit conventions.

                      
                      
                        
                          
                            Visit CommitLint website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


View documentation 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  ConfigCat
                  
                    
                      
                      
                      
                        
                          Code Analysis
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      ConfigCat
                      Code Analysis
                      
                        ConfigCat is a feature flag and configuration management platform that provides a single place to manage frontend, backend, mobile, and desktop apps.

                      
                      
                        
                          
                            Visit ConfigCat website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Contrast Security
                  
                    
                      
                      
                      
                        
                          Security
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Contrast Security
                      Security
                      
                        Contrast Security is the world’s leading provider of instrumentation technology that embeds highly effective vulnerability analysis and exploit prevention directly into modern software.

                      
                      
                        
                          
                            Visit Contrast Security website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Convox
                  
                    
                      
                      
                      
                        
                          Deployment
                        
                      
                    
                      
                      
                      
                        
                          Kubernetes
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Convox
                      Deployment
                      
                        Convox allows teams of all sizes to develop, deploy, and scale their apps. From local development to production deployments, Convox makes it easy. Stop spending time on infrastructure and focus on your apps.

                      
                      
                        
                          
                            Visit Convox website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


View documentation 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Coralogix
                  
                    
                      
                      
                      
                        
                          Monitoring
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Coralogix
                      Monitoring
                      
                        Coralogix is a machine learning-based logging platform that helps software companies manage their log data, ensure quality version release, and automatically identify problems in their production.

                      
                      
                        
                          
                            Visit Coralogix website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


View documentation 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Coveralls
                  
                    
                      
                      
                      
                        
                          Code Analysis
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Coveralls
                      Code Analysis
                      
                        Posts coverage to Coveralls for analysis & tracking, and adds coverage change in a comment on PR builds.

                      
                      
                        
                          
                            Visit Coveralls website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Cypress
                  
                    
                      
                      
                      
                        
                          Testing
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Cypress
                      Testing
                      
                        Cypress is a front end automated testing tool, created for the modern web. Cypress provides better, faster, and more reliable testing for anything that runs in a browser.

                      
                      
                        
                          
                            Visit Cypress website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


Watch video overview 

                        
                      
                        
                        
                        
                        
                          


Read blog post 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Datadog
                  
                    
                      
                      
                      
                        
                          Monitoring
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Datadog
                      Monitoring
                      
                        Datadog is a monitoring platform bringing together data from servers, containers, databases, and third-party services. Datadog helps teams avoid downtime and resolve performance issues to ensure customers get the best user experience.

                      
                      
                        
                          
                            Visit Datadog website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View documentation
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  datree policy
                  
                    
                      
                      
                      
                        
                          Code Analysis
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      datree policy
                      Code Analysis
                      
                        datree is a Git-level production gatekeeper. Control changes, prevent mishaps, and deploy safely with datree.

                      
                      
                        
                          
                            Visit datree policy website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


View documentation 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  datree CLI
                  
                    
                      
                      
                      
                        
                          Kubernetes
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      datree CLI
                      Kubernetes
                      
                        datree is a Git-level production gatekeeper. Control changes, prevent mishaps, and deploy safely with datree.

                      
                      
                        
                          
                            Visit datree CLI website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  DBmaestro
                  
                    
                      
                      
                      
                        
                          Deployment
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      DBmaestro
                      Deployment
                      
                        DBmaestro is a leader in the database delivery automation category, whose platform empowers organizations to automate, secure, and govern database delivery pipelines.

                      
                      
                        
                          
                            Visit DBmaestro website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


Video Tutorial 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  DeepFactor
                  
                    
                      
                      
                      
                        
                          Security
                        
                      
                    
                      
                      
                      
                        
                          Monitoring
                        
                      
                    
                      
                      
                      
                        
                          Kubernetes
                        
                      
                    
                      
                      
                      
                        
                          Containers
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      DeepFactor
                      Security
                      
                        Find and fix runtime security, compliance, and behavior issues in custom and third party code within your pipeline.

                      
                      
                        
                          
                            Visit DeepFactor website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


View documentation 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  DeepSource
                  
                    
                      
                      
                      
                        
                          Testing
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      DeepSource
                      Testing
                      
                        DeepSource continuously analyzes source code changes to find and fix security and performance issues,  anti-patterns, and bug-risks before they make it into production.

                      
                      
                        
                          
                            Visit DeepSource website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


View documentation 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  DefenseCode
                  
                    
                      
                      
                      
                        
                          Security
                        
                      
                    
                      
                      
                      
                        
                          Testing
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      DefenseCode
                      Security
                      
                        DefenseCode provides accurate, fast security products that seamlessly integrate into the software development lifecycle. Comprehensive and in-depth security analysis for both SAST and DAST.

                      
                      
                        
                          
                            Visit DefenseCode website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  DeployHub
                  
                    
                      
                      
                      
                        
                          Deployment
                        
                      
                    
                      
                      
                      
                        
                          Kubernetes
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      DeployHub
                      Deployment
                      
                        DeployHub is a central catalog of deployable objects where developers can publish to and deploy from. DeployHub is essential for both agile practices
 and modern microservices architectures.

                      
                      
                        
                          
                            Visit DeployHub website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


Video tutorial 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Docker Hub
                  
                    
                      
                      
                      
                        
                          Containers
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Docker Hub
                      Containers
                      
                        Docker Hub is the world’s largest repository of container images with an array of content sources including container community developers, open source projects and independent software vendors (ISV) building and distributing their code in containers.

                      
                      
                        
                          
                            Visit Docker Hub website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  F0cal
                  
                    
                      
                      
                      
                        
                          Containers
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      F0cal
                      Containers
                      
                        FØCAL lets you provision, build, and test your code on edge devices like NVidia, Intel, AMD, and Raspberry Pi, directly on your desktop.

                      
                      
                        
                          
                            Visit F0cal website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Fairwinds
                  
                    
                      
                      
                      
                        
                          Kubernetes
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Fairwinds
                      Kubernetes
                      
                        Fairwinds is a cloud-native infrastructure provider that builds and maintains Kubernetes clusters.

                      
                      
                        
                          
                            Visit Fairwinds website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


View documentation 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Flutter
                  
                    
                      
                      
                      
                        
                          Language / Framework
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Flutter
                      Language / Framework
                      
                        Flutter is Google's UI toolkit for building natively compiled applications for mobile, web, desktop, and embedded devices from a single codebase.

                      
                      
                        
                          
                            Visit Flutter website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Fortanix
                  
                    
                      
                      
                      
                        
                          Security
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Fortanix
                      Security
                      
                        Fortanix uses Runtime Encryption to keep keys, data, and applications protected from external and internal threats including malicious insiders, cloud providers, OS-level hacks and network intruders.

                      
                      
                        
                          
                            Visit Fortanix website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Fossa
                  
                    
                      
                      
                      
                        
                          Security
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Fossa
                      Security
                      
                        FOSSA provides automated, real-time licensing and vulnerability management for open source code anywhere in your software stack.

                      
                      
                        
                          
                            Visit Fossa website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


View documentation 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  GameCI
                  
                    
                      
                      
                      
                        
                          Language / Framework
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      GameCI
                      Language / Framework
                      
                        The fastest and easiest way to automatically test and build your game projects. GameCI offers friendly functional APIs, that does not require much technical knowledge to configure. Making customisations is easily done by forking our projects, giving much flexibility.

                      
                      
                        
                          
                            Visit GameCI website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Genymotion
                  
                    
                      
                      
                      
                        
                          Testing
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Genymotion
                      Testing
                      
                        Genymotion Cloud SaaS provides Android virtual devices on the Cloud with various configurations and Android versions. Start many virtual devices and test at scale for mobile automation testing.

                      
                      
                        
                          
                            Visit Genymotion website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


Read blog post 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Ghost Inspector
                  
                    
                      
                      
                      
                        
                          Testing
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Ghost Inspector
                      Testing
                      
                        Ghost Inspector is an automated browser testing and monitoring solution that allows teams to easily build and manage tests that ensure their website or application is functioning properly.

                      
                      
                        
                          
                            Visit Ghost Inspector website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


View documentation 

                        
                      
                        
                        
                        
                        
                          


Read blog post 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  GitGuardian
                  
                    
                      
                      
                      
                        
                          Security
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      GitGuardian
                      Security
                      
                        GitGuardian helps software-driven organizations secure the SDLC with automated secrets detection and remediation.

                      
                      
                        
                          
                            Visit GitGuardian website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  GitHub
                  
                    
                      
                      
                      
                        
                          Cloud Platform
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      GitHub
                      Cloud Platform
                      
                        CircleCI integrates with GitHub.com or GitHub Enterprise with a single click, enabling build triggers and GitHub Checks integration.

                      
                      
                        
                          
                            Visit GitHub website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          Learn more
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  GitHub CLI
                  
                    
                      
                      
                      
                        
                          Deployment
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      GitHub CLI
                      Deployment
                      
                        CircleCI’s seamless integration with GitHub’s release features is easier than ever with the GitHub CLI orb.

                      
                      
                        
                          
                            Visit GitHub CLI website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


View documentation 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  GitLab
                  
                    
                      
                      
                      
                        
                          Cloud Platform
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      GitLab
                      Cloud Platform
                      
                        CircleCI integrates with GitLab SaaS via OAuth or personal API and GitLab self-managed via personal access token.

                      
                      
                        
                          
                            Visit GitLab website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View documentation
                        
                        
                      
                        
                        
                        
                        
                          


Learn more 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  GCP Binary Authorization
                  
                    
                      
                      
                      
                        
                          Security
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      GCP Binary Authorization
                      Security
                      
                        Binary Authorization is a deploy-time security control that ensures only trusted container images are deployed on Google Kubernetes Engine (GKE).

                      
                      
                        
                          
                            Visit GCP Binary Authorization website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Google Cloud CLI
                  
                    
                      
                      
                      
                        
                          Cloud Platform
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Google Cloud CLI
                      Cloud Platform
                      
                        Install and configure the Google Cloud CLI (gcloud). As a GCP Partner with PaaS and DevOps capabilities, CircleCI makes it easy to integrate CI/CD workflows with GCP. Now with CircleCI orbs for GCP that make it easier than ever.

                      
                      
                        
                          
                            Visit Google Cloud CLI website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


Learn more 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Google Cloud GCR
                  
                    
                      
                      
                      
                        
                          Artifacts / Registry
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Google Cloud GCR
                      Artifacts / Registry
                      
                        An orb for working with Google Container Registry. As a GCP Partner with PaaS and DevOps capabilities, CircleCI makes it easy to integrate CI/CD workflows with GCP. Now with CircleCI orbs for GCP that make it easier than ever.

                      
                      
                        
                          
                            Visit Google Cloud GCR website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Google Cloud GKE
                  
                    
                      
                      
                      
                        
                          Deployment
                        
                      
                    
                      
                      
                      
                        
                          Kubernetes
                        
                      
                    
                      
                      
                      
                        
                          Containers
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Google Cloud GKE
                      Deployment
                      
                        An orb for working with Google Kubernetes Engine. As a GCP Partner with PaaS and DevOps capabilities, CircleCI makes it easy to integrate CI/CD workflows with GCP. Now with CircleCI orbs for GCP that make it easier than ever.

                      
                      
                        
                          
                            Visit Google Cloud GKE website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Google Cloud Run
                  
                    
                      
                      
                      
                        
                          Deployment
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Google Cloud Run
                      Deployment
                      
                        Build and deploy stateless images to Google Cloud Run as serverless applications.

                      
                      
                        
                          
                            Visit Google Cloud Run website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Gradle
                  
                    
                      
                      
                      
                        
                          Build
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Gradle
                      Build
                      
                        From mobile apps to microservices, from small startups to big enterprises, Gradle helps teams build, automate and deliver better software, faster.

                      
                      
                        
                          
                            Visit Gradle website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Happo
                  
                    
                      
                      
                      
                        
                          Testing
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Happo
                      Testing
                      
                        Happo is a cross-browser screenshot testing tool. It helps you prevent visual regressions before they reach production, and lets you see how a change visually effects the UI.

                      
                      
                        
                          
                            Visit Happo website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Helm
                  
                    
                      
                      
                      
                        
                          Deployment
                        
                      
                    
                      
                      
                      
                        
                          Kubernetes
                        
                      
                    
                      
                      
                      
                        
                          Containers
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Helm
                      Deployment
                      
                        Helm helps you manage Kubernetes applications — Helm Charts help you define, install, and upgrade even the most complex Kubernetes application. Charts are easy to create, version, share, and publish — so start using Helm and stop the copy-and-paste.

                      
                      
                        
                          
                            Visit Helm website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Heroku
                  
                    
                      
                      
                      
                        
                          Cloud Platform
                        
                      
                    
                      
                      
                      
                        
                          Deployment
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Heroku
                      Cloud Platform
                      
                        CircleCI seamlessly integrates with Heroku to help improve your deployment workflow. Now easier than ever with the CircleCI orb for Heroku.

                      
                      
                        
                          
                            Visit Heroku website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          Learn more
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Honey​badger.io
                  
                    
                      
                      
                      
                        
                          Monitoring
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Honey​badger.io
                      Monitoring
                      
                        Honeybadger combines exception, uptime and check-in monitoring into one easy-to-use platform. Instant error notifications help teams understand what is causing each exception and which users are affected.

                      
                      
                        
                          
                            Visit Honey​badger.io website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Honeycomb
                  
                    
                      
                      
                      
                        
                          Monitoring
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Honeycomb
                      Monitoring
                      
                        Honeycomb is a tool for introspecting and interrogating your production systems. Observe and rapidly debug using Honeycomb’s deep analytics tool to achieve production excellence.

                      
                      
                        
                          
                            Visit Honeycomb website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Hugo
                  
                    
                      
                      
                      
                        
                          Language / Framework
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Hugo
                      Language / Framework
                      
                        Hugo is one of the most popular open-source static site generators. With its amazing speed and flexibility, Hugo makes building websites fun again.

                      
                      
                        
                          
                            Visit Hugo website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Humanitec
                  
                    
                      
                      
                      
                        
                          Kubernetes
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Humanitec
                      Kubernetes
                      
                        Humanitec’s platform allows developers to master continuous delivery for Kubernetes-ready applications, driving higher deployment frequency, lower lead times, and better developer satisfaction.

                      
                      
                        
                          
                            Visit Humanitec website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View documentation
                        
                        
                      
                        
                        
                        
                        
                          


Watch video overview 

                        
                      
                        
                        
                        
                        
                          


Read blog post 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Indeni
                  
                    
                      
                      
                      
                        
                          Security
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Indeni
                      Security
                      
                        Indeni is the leader in security infrastructure automation, pioneering a new way to manage security infrastructure and IaC.

                      
                      
                        
                          
                            Visit Indeni website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


View documentation 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Instana
                  
                    
                      
                      
                      
                        
                          Containers
                        
                      
                    
                      
                      
                      
                        
                          Monitoring
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Instana
                      Containers
                      
                        Instana’s enterprise observability platform discovers, maps, and monitors services, infrastructure components, and dependencies in real time.

                      
                      
                        
                          
                            Visit Instana website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


View documentation 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Ionir
                  
                    
                      
                      
                      
                        
                          Kubernetes
                        
                      
                    
                      
                      
                      
                        
                          Infra Automation
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Ionir
                      Kubernetes
                      
                        Ionir’s container-native storage and data management platform for Kubernetes combines software-defined storage with data mobility for a single data cloud for applications across all infrastructures.

                      
                      
                        
                          
                            Visit Ionir website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


View documentation 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Jira
                  
                    
                      
                      
                      
                        
                          Collaboration
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Jira
                      Collaboration
                      
                        Jira is a family of products built to help all types of teams manage their work. Jira offers several products and deployment options that are purpose-built for Software, IT, Business, Ops teams, and more.

                      
                      
                        
                          
                            Visit Jira website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  jq
                  
                    
                      
                      
                      
                        
                          Language / Framework
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      jq
                      Language / Framework
                      
                        jq is a lightweight and flexible command-line JSON processor. jq is written in portable C, and it has zero runtime dependencies.

                      
                      
                        
                          
                            Visit jq website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  k6
                  
                    
                      
                      
                      
                        
                          Testing
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      k6
                      Testing
                      
                        k6 is a modern load testing tool that provides a clean, approachable scripting API, local and cloud execution, and flexible configuration.

                      
                      
                        
                          
                            Visit k6 website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


View documentation 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Kaholo
                  
                    
                      
                      
                      
                        
                          Build
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Kaholo
                      Build
                      
                        Use Kaholo to build automation pipelines with a simple drag and drop interface.

                      
                      
                        
                          
                            Visit Kaholo website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View documentation
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Katalon
                  
                    
                      
                      
                      
                        
                          Testing
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Katalon
                      Testing
                      
                        Executes Katalon tests with CircleCI by pushing your test scripts, and changing the Katalon Studio version starting from 7.0 to run the test with a variety of options supported.

                      
                      
                        
                          
                            Visit Katalon website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Kobiton
                  
                    
                      
                      
                      
                        
                          Testing
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Kobiton
                      Testing
                      
                        Kobiton is how companies make their mobile apps work better everywhere. Using real devices and next-gen automation, test your app in a fraction of the time it would normally take.

                      
                      
                        
                          
                            Visit Kobiton website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Kubernetes
                  
                    
                      
                      
                      
                        
                          Kubernetes
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Kubernetes
                      Kubernetes
                      
                        Kubernetes is an open source system for automating deployment, scaling, and management of containerized applications.

                      
                      
                        
                          
                            Visit Kubernetes website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Kublr
                  
                    
                      
                      
                      
                        
                          Kubernetes
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Kublr
                      Kubernetes
                      
                        Kublr is a container management platform focused specifically on the needs of enterprise customers. Focusing on the Kubernetes and infrastructure layer, Kublr provides the operations and governance capabilities that enterprises need to run reliably at scale.

                      
                      
                        
                          
                            Visit Kublr website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Lacework
                  
                    
                      
                      
                      
                        
                          Security
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Lacework
                      Security
                      
                        Lacework delivers security and compliance for the cloud. Their cloud-native security platform delivers build-time to run-time threat detection, behavioral anomaly detection, and cloud compliance across multi-cloud environments, workloads, containers, and Kubernetes. Customers significantly drive down costs by eliminating unnecessary hardware, rule writing, and inaccurate alerts. Lacework is trusted worldwide by cloud-embracing enterprise companies. They are a privately held company based in Mountain View, California, and are funded by Sutter Hill Ventures, Liberty Global Ventures, Spike Ventures, the Webb Investment Network (WIN), and AME Cloud Ventures.

                      
                      
                        
                          
                            Visit Lacework website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  LambdaTest
                  
                    
                      
                      
                      
                        
                          Testing
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      LambdaTest
                      Testing
                      
                        LambdaTest is a cloud-based, cross-browser testing platform where users can perform automated and manual compatibility testing of their website or web app on a combination of 2000+ different browsers & OSs.

                      
                      
                        
                          
                            Visit LambdaTest website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  LaunchDarkly
                  
                    
                      
                      
                      
                        
                          Deployment
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      LaunchDarkly
                      Deployment
                      
                        LaunchDarkly is the feature management platform that software teams use to build better software, faster with less risk. Teams can control their entire feature lifecycles from concept to launch to value.

                      
                      
                        
                          
                            Visit LaunchDarkly website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Lightspin
                  
                    
                      
                      
                      
                        
                          Security
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Lightspin
                      Security
                      
                        Lightspin’s multi-layer CNAPP solution minimizes effort, secures your hybrid cloud environment, and provides prioritization and remediation of critical potential attack paths across your cloud stack.

                      
                      
                        
                          
                            Visit Lightspin website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  LocalStack
                  
                    
                      
                      
                      
                        
                          Cloud Platform
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      LocalStack
                      Cloud Platform
                      
                        LocalStack provides a fully functional local cloud stack for testing cloud and serverless apps offline.

                      
                      
                        
                          
                            Visit LocalStack website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  LogDNA
                  
                    
                      
                      
                      
                        
                          Monitoring
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      LogDNA
                      Monitoring
                      
                        LogDNA’s log management platform provides deep insight into development and production environments. LogDNA allows teams to ingest, aggregate and view log data regardless of data residency and infrastructure.

                      
                      
                        
                          
                            Visit LogDNA website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Logz.io
                  
                    
                      
                      
                      
                        
                          Monitoring
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Logz.io
                      Monitoring
                      
                        Delivers the ELK Stack and Grafana as a fully managed service.

                      
                      
                        
                          
                            Visit Logz.io website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Mabl
                  
                    
                      
                      
                      
                        
                          Testing
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Mabl
                      Testing
                      
                        Mabl empowers software development teams to integrate end-to-end testing into the entire CI/CD development lifecycle.

                      
                      
                        
                          
                            Visit Mabl website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


View documentation 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  macOS
                  
                    
                      
                      
                      
                        
                          Cloud Platform
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      macOS
                      Cloud Platform
                      
                        macOS is the primary operating system for Apple's Mac computers. Within the market of desktop, laptop and home computers, and by web usage, it is the second most widely used desktop OS, after Microsoft Windows.

                      
                      
                        
                          
                            Visit macOS website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Manas.Tech
                  
                    
                      
                      
                      
                        
                          Language / Framework
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Manas.Tech
                      Language / Framework
                      
                        Helps developers perform common tasks for the Crystal programming language.

                      
                      
                        
                          
                            Visit Manas.Tech website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


View documentation 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  MathWorks
                  
                    
                      
                      
                      
                        
                          Language / Framework
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      MathWorks
                      Language / Framework
                      
                        MathWorks is the leading developer of mathematical computing software for engineers and scientists.

                      
                      
                        
                          
                            Visit MathWorks website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


View documentation 

                        
                      
                        
                        
                        
                        
                          


Read blog post 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Maven
                  
                    
                      
                      
                      
                        
                          Build
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Maven
                      Build
                      
                        Apache Maven is a software project management and comprehension tool. Based on the concept of a project object model (POM), Maven can manage a project's build, reporting and documentation from a central piece of information.

                      
                      
                        
                          
                            Visit Maven website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  MuukTest
                  
                    
                      
                      
                      
                        
                          Testing
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      MuukTest
                      Testing
                      
                        Current test automation tools require extensive development skills and manually defining the items to test. We create and execute test scripts automatically after analyzing the software application.

                      
                      
                        
                          
                            Visit MuukTest website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


View documentation 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Neocortix
                  
                    
                      
                      
                      
                        
                          Testing
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Neocortix
                      Testing
                      
                        Neocortix is a distributed cloud computing company that runs on a worldwide network of mobile devices to help with processes like load testing, web crawling, and network telemetry.

                      
                      
                        
                          
                            Visit Neocortix website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Neuralegion / Nexploit
                  
                    
                      
                      
                      
                        
                          Testing
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Neuralegion / Nexploit
                      Testing
                      
                        NeuraLegion is an application security testing platform that helps eliminate a shortage of security personnel by enabling developers & QA teams to run their own security tests.

                      
                      
                        
                          
                            Visit Neuralegion / Nexploit website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


View documentation 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  NeuVector
                  
                    
                      
                      
                      
                        
                          Security
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      NeuVector
                      Security
                      
                        NeuVector is a run-time container network security platform that delivers highly integrated, automated security for Kubernetes, employing a firewall with packet-level interrogation and enforcement.

                      
                      
                        
                          
                            Visit NeuVector website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


View documentation 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  New Relic
                  
                    
                      
                      
                      
                        
                          Monitoring
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      New Relic
                      Monitoring
                      
                        The leading observability platform for Dev and Ops teams to join and solve problems using data. Analyze and troubleshoot on your entire software stack with AI to detect and resolve incidents faster.

                      
                      
                        
                          
                            Visit New Relic website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          Install quickstart
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Nightfall
                  
                    
                      
                      
                      
                        
                          Code Analysis
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Nightfall
                      Code Analysis
                      
                        Nightfall is the first cloud-native data loss prevention platform that uses machine learning to discover, classify, and protect sensitive data.

                      
                      
                        
                          
                            Visit Nightfall website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Nirmata
                  
                    
                      
                      
                      
                        
                          Kubernetes
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Nirmata
                      Kubernetes
                      
                        Nirmata provides visibility, governance, and life-cycle management of Kubernetes clusters and workloads. The Kubernetes management platform accelerates the adoption of open-source and cloud-native technologies.

                      
                      
                        
                          
                            Visit Nirmata website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Node
                  
                    
                      
                      
                      
                        
                          Language / Framework
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Node
                      Language / Framework
                      
                        As an asynchronous event driven JavaScript runtime, Node is designed to build scalable network applications.

                      
                      
                        
                          
                            Visit Node website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  NowSecure
                  
                    
                      
                      
                      
                        
                          Testing
                        
                      
                    
                      
                      
                      
                        
                          Security
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      NowSecure
                      Testing
                      
                        NowSecure integrates automated mobile appsec testing into the DevOps toolchain. Built to give fast-moving mobile appdev teams the power of a fully automated dynamic pen test on every build in <15 mins with no false positives.

                      
                      
                        
                          
                            Visit NowSecure website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


Watch video overview 

                        
                      
                        
                        
                        
                        
                          


Read blog post 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  OpenShift
                  
                    
                      
                      
                      
                        
                          Deployment
                        
                      
                    
                      
                      
                      
                        
                          Kubernetes
                        
                      
                    
                      
                      
                      
                        
                          Containers
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      OpenShift
                      Deployment
                      
                        OpenShift is an open source container application platform based on the Kubernetes container orchestrator for enterprise application development and deployment.

                      
                      
                        
                          
                            Visit OpenShift website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  OpsGenie
                  
                    
                      
                      
                      
                        
                          Notifications
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      OpsGenie
                      Notifications
                      
                        Opsgenie is an incident management platform for operating always-on services, that helps teams plan for service disruptions and stay in control during incidents.

                      
                      
                        
                          
                            Visit OpsGenie website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Oxygen
                  
                    
                      
                      
                      
                        
                          Testing
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Oxygen
                      Testing
                      
                        Oxygen, contributed by CloudBeat, is an open source test automation framework and IDE that helps engineers write automation tests in minutes. Oxygen simplifies work with Selenium and Appium and other tests such as API, DB and IoT tests.

                      
                      
                        
                          
                            Visit Oxygen website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  packagecloud
                  
                    
                      
                      
                      
                        
                          Artifacts / Registry
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      packagecloud
                      Artifacts / Registry
                      
                        A unified, developer-friendly interface for all artifacts, packagecloud contains hosted npm, Maven, RPM, Debian, PyPi and RubyGem repositories with a focus on security and ease of use.

                      
                      
                        
                          
                            Visit packagecloud website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Packtracker
                  
                    
                      
                      
                      
                        
                          Code Analysis
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Packtracker
                      Code Analysis
                      
                        Packtracker.io is a tool that analyzes your webpack bundle over time to help you find bundle bloat, reduce repetition between chunks, and improve your caching strategies.

                      
                      
                        
                          
                            Visit Packtracker website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


View documentation 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Pantheon
                  
                    
                      
                      
                      
                        
                          Deployment
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Pantheon
                      Deployment
                      
                        Pantheon is a WebOps platform for Drupal and WordPress that helps organizations get more value from their sites through high-performance hosting, automated workflows, and professional tools for teams.

                      
                      
                        
                          
                            Visit Pantheon website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


View documentation 

                        
                      
                        
                        
                        
                        
                          


Read blog post 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Percy
                  
                    
                      
                      
                      
                        
                          Testing
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Percy
                      Testing
                      
                        Percy is an all-in-one visual testing solution, integrating with tests and the CI environment to detect visual regressions and give visual insight into every product change.

                      
                      
                        
                          
                            Visit Percy website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


Read blog post 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Pmbot
                  
                    
                      
                      
                      
                        
                          Code Analysis
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Pmbot
                      Code Analysis
                      
                        Pmbot helps teams keep their dependencies up to date without breaking their code.

                      
                      
                        
                          
                            Visit Pmbot website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


View documentation 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Portshift
                  
                    
                      
                      
                      
                        
                          Kubernetes
                        
                      
                    
                      
                      
                      
                        
                          Security
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Portshift
                      Kubernetes
                      
                        Allows users to perform vulnerability scans and to collect image identity attributes.

                      
                      
                        
                          
                            Visit Portshift website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


View documentation 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Postman
                  
                    
                      
                      
                      
                        
                          Testing
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Postman
                      Testing
                      
                        Postman is the only complete API development environment, for API developers, used by more than 5 million developers and 100,000 companies worldwide.

                      
                      
                        
                          
                            Visit Postman website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  PractiTest
                  
                    
                      
                      
                      
                        
                          Testing
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      PractiTest
                      Testing
                      
                        PractiTest is a leading SaaS Test Management system that helps companies release quality products by orchestrating manual, automated, and CI/CD tests.

                      
                      
                        
                          
                            Visit PractiTest website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


View documentation 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  PreFlight
                  
                    
                      
                      
                      
                        
                          Testing
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      PreFlight
                      Testing
                      
                        Preflight offers code-free, automated UI testing. Create tests by recording in your own product, then run tests across different environments, browsers and screen sizes.

                      
                      
                        
                          
                            Visit PreFlight website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


View documentation 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Prisma Cloud
                  
                    
                      
                      
                      
                        
                          Security
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Prisma Cloud
                      Security
                      
                        Palo Alto Networks provides integrated best-in-breed capabilities for the most comprehensive cybersecurity portfolio on the planet, enabling organizations to be secure today and prepared for tomorrow.

                      
                      
                        
                          
                            Visit Prisma Cloud website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


View documentation 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Probely
                  
                    
                      
                      
                      
                        
                          Security
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Probely
                      Security
                      
                        Probely allows agile teams to identify, manage, and fix security vulnerabilities in their web applications. Integrate Probely directly into your CI/CD pipelines to fully automate security.

                      
                      
                        
                          
                            Visit Probely website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


View documentation 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Provar
                  
                    
                      
                      
                      
                        
                          Testing
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Provar
                      Testing
                      
                        Provar uses Salesforce integration to build smarter tests. It specializes in advanced Salesforce features, such as Visualforce and the Service Cloud Console. Provar suggests the best field locators to build robust tests. Provar is a point-and-click tool and doesn’t need coding experience.

                      
                      
                        
                          
                            Visit Provar website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Pulumi
                  
                    
                      
                      
                      
                        
                          Infra Automation
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Pulumi
                      Infra Automation
                      
                        Pulumi provides a cloud development model for serverless functions, container apps, and data infrastructure for any cloud.

                      
                      
                        
                          
                            Visit Pulumi website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


View documentation 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Quali
                  
                    
                      
                      
                      
                        
                          Infra Automation
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Quali
                      Infra Automation
                      
                        Quali is an Environments-as-a-Service platform that delivers self-service access to on-demand environments.

                      
                      
                        
                          
                            Visit Quali website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Rafay
                  
                    
                      
                      
                      
                        
                          Deployment
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Rafay
                      Deployment
                      
                        Rafay provides a SaaS-based platform that lets you create, deploy, operate, monitor, and upgrade Kubernetes clusters & K8s resident apps across multi-clouds and environments.

                      
                      
                        
                          
                            Visit Rafay website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Rainforest​QA
                  
                    
                      
                      
                      
                        
                          Testing
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Rainforest​QA
                      Testing
                      
                        RainforestQA is a QA platform that allows you to write test cases in natural language, run them concurrently across multiple platforms, and get detailed bug reports that developers can act on.

                      
                      
                        
                          
                            Visit Rainforest​QA website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  realMethods
                  
                    
                      
                      
                      
                        
                          Code Analysis
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      realMethods
                      Code Analysis
                      
                        realMethods makes it easy to get running on CircleCI, by generating MVP quality applications for all major tech stacks committed to your Git repo with a ready to deploy CircleCI config file.

                      
                      
                        
                          
                            Visit realMethods website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Rezilion
                  
                    
                      
                      
                      
                        
                          Security
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Rezilion
                      Security
                      
                        Rezilion’s platform automatically secures the software you deliver with by detecting, prioritizing, and eliminating risk. Rezilion accelerates software security to free up time to build.

                      
                      
                        
                          
                            Visit Rezilion website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


View documentation 

                        
                      
                        
                        
                        
                        
                          


View integration 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Reflect
                  
                    
                      
                      
                      
                        
                          Testing
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Reflect
                      Testing
                      
                        No-code test automation for web applications

                      
                      
                        
                          
                            Visit Reflect website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Retool
                  
                    
                      
                      
                      
                        
                          Build
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Retool
                      Build
                      
                        Retool is the fast way to build your own custom internal tools. Retool is used by tens of thousands of companies from Amazon to Allbirds to NBC for support workflows, operations dashboards, and more.

                      
                      
                        
                          
                            Visit Retool website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View documentation
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Rollbar
                  
                    
                      
                      
                      
                        
                          Monitoring
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Rollbar
                      Monitoring
                      
                        Rollbar helps engineering teams deploy often and with confidence. Use Rollbar to detect all production errors in real-time and debug them in minutes - before users notice.

                      
                      
                        
                          
                            Visit Rollbar website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Rookout
                  
                    
                      
                      
                      
                        
                          Reporting
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Rookout
                      Reporting
                      
                        Rookout slashes debugging time and effort across the full product cycle, from development through staging and production. Get data visibility and collection without restarts, redeployments or added code.

                      
                      
                        
                          
                            Visit Rookout website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Rust
                  
                    
                      
                      
                      
                        
                          Language / Framework
                        
                      
                    
                      
                      
                      
                        
                          Build
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Rust
                      Language / Framework
                      
                        Easily build, test, lint, and run your Rust applications on CircleCI with automated caching.

                      
                      
                        
                          
                            Visit Rust website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Salesforce APEX
                  
                    
                      
                      
                      
                        
                          Language / Framework
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Salesforce APEX
                      Language / Framework
                      
                        Salesforce is a customer success platform that uses social and mobile cloud technologies to help companies connect with customers, partners, and employees in new ways.

                      
                      
                        
                          
                            Visit Salesforce APEX website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


View documentation 

                        
                      
                        
                        
                        
                        
                          


Learn more 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Salesforce SFDX
                  
                    
                      
                      
                      
                        
                          Deployment
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Salesforce SFDX
                      Deployment
                      
                        Salesforce is a customer success platform that uses social and mobile cloud technologies to help companies connect with customers, partners, and employees in new ways.

                      
                      
                        
                          
                            Visit Salesforce SFDX website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


Learn more 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Sauce Labs
                  
                    
                      
                      
                      
                        
                          Testing
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Sauce Labs
                      Testing
                      
                        Sauce Connect Proxy is a built-in HTTP proxy that allows testers to get to Dev/QA sites that are behind a firewall. The Sauce Labs Orbs integration sets up and launches Sauce Connect Proxy at the beginning of the build as a background task and terminates the connection at the end of the build. This can be configured to work with additional proxies and firewalls.

                      
                      
                        
                          
                            Visit Sauce Labs website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


View documentation 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  SecretHub
                  
                    
                      
                      
                      
                        
                          Security
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      SecretHub
                      Security
                      
                        Loads secrets into jobs through codified and auditable secret templates.

                      
                      
                        
                          
                            Visit SecretHub website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


View documentation 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Serverless
                  
                    
                      
                      
                      
                        
                          Deployment
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Serverless
                      Deployment
                      
                        The Serverless Framework gives you everything you need to develop, deploy, monitor and secure serverless applications on any cloud.

                      
                      
                        
                          
                            Visit Serverless website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Shiftleft
                  
                    
                      
                      
                      
                        
                          Security
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Shiftleft
                      Security
                      
                        ShiftLeft is a continuous application security platform. Their Inspect product helps identify vulnerabilities and sensitive data leakage in your code.

                      
                      
                        
                          
                            Visit Shiftleft website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Shipa
                  
                    
                      
                      
                      
                        
                          Kubernetes
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Shipa
                      Kubernetes
                      
                        Shipa delivers a unique cloud-native application management framework. Use Shipa and CircleCI to speed up development by eliminating workflow inefficiencies.

                      
                      
                        
                          
                            Visit Shipa website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


View documentation 

                        
                      
                        
                        
                        
                        
                          


Read blog post 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Shipyard
                  
                    
                      
                      
                      
                        
                          Build
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Shipyard
                      Build
                      
                        Shipyard creates and manages copies of your environments so you get a unique, shareable environment for every branch and PR, making it easy to collaborate.

                      
                      
                        
                          
                            Visit Shipyard website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


View documentation 

                        
                      
                        
                        
                        
                        
                          


Read blog post 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Sken.ai
                  
                    
                      
                      
                      
                        
                          Code Analysis
                        
                      
                    
                      
                      
                      
                        
                          Security
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Sken.ai
                      Code Analysis
                      
                        Sken.ai is the only application security testing product that offers comprehensive testing for DevOps without the need for security expertise.

                      
                      
                        
                          
                            Visit Sken.ai website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Slack
                  
                    
                      
                      
                      
                        
                          Notifications
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Slack
                      Notifications
                      
                        Slack is a collaboration hub, where the right people and the right information come together, helping everyone get work done.

                      
                      
                        
                          
                            Visit Slack website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Snyk
                  
                    
                      
                      
                      
                        
                          Security
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Snyk
                      Security
                      
                        Snyk is a developer-first security solution platform that finds and fixes vulnerabilities and license violations in open source dependencies and containers.

                      
                      
                        
                          
                            Visit Snyk website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


View documentation 

                        
                      
                        
                        
                        
                        
                          


View webinar 

                        
                      
                        
                        
                        
                        
                          


Read blog post 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  SonarSource
                  
                    
                      
                      
                      
                        
                          Security
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      SonarSource
                      Security
                      
                        SonarSource provides open source and commercial products that help developers and organizations manage the quality and security of their code.

                      
                      
                        
                          
                            Visit SonarSource website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Sonatype
                  
                    
                      
                      
                      
                        
                          Artifacts / Registry
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Sonatype
                      Artifacts / Registry
                      
                        Innovate faster while mitigating the security risks inherent in open source. Sonatype’s Nexus platform combines in-depth component intelligence with real-time remediation guidance to automate and scale open source governance across every stage of the modern DevOps pipeline.

                      
                      
                        
                          
                            Visit Sonatype website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  SOOS
                  
                    
                      
                      
                      
                        
                          Security
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      SOOS
                      Security
                      
                        SOOS makes easy-to-use, affordable developer security tools to monitor and fix open source vulnerability and license issues. Stop shopping and start scanning with SOOS today.

                      
                      
                        
                          
                            Visit SOOS website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Spectral
                  
                    
                      
                      
                      
                        
                          Security
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Spectral
                      Security
                      
                        Spectral empowers companies and developers to secure and ship software freely on any platform, through real-time detection and mitigation of security flaws.

                      
                      
                        
                          
                            Visit Spectral website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Spinnaker
                  
                    
                      
                      
                      
                        
                          Deployment
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Spinnaker
                      Deployment
                      
                        Spinnaker is an open source, multi-cloud continuous delivery platform for releasing software changes with high velocity and confidence.

                      
                      
                        
                          
                            Visit Spinnaker website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Squadcast
                  
                    
                      
                      
                      
                        
                          Cloud Platform
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Squadcast
                      Cloud Platform
                      
                        Squadcast is cloud-based software designed around Site Reliability Engineering (SRE) practices that provides incident management and on-call scheduling capabilities.

                      
                      
                        
                          
                            Visit Squadcast website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View blog
                        
                        
                      
                        
                        
                        
                        
                          


View documentation 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  StackHawk
                  
                    
                      
                      
                      
                        
                          Security
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      StackHawk
                      Security
                      
                        StackHawk makes it simple for developers to find, triage, and fix application security bugs. Scan your app for AppSec bugs, triage and fix with docs, and automate to prevent bugs from hitting prod.

                      
                      
                        
                          
                            Visit StackHawk website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


View documentation 

                        
                      
                        
                        
                        
                        
                          


Read blog post 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  StackPulse
                  
                    
                      
                      
                      
                        
                          Security
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      StackPulse
                      Security
                      
                        StackPulse is a reliability platform for developers, SREs and on-call engineers, helping teams remediate production incidents faster by turning incident response workflows into code-based playbooks.

                      
                      
                        
                          
                            Visit StackPulse website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


View documentation 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Styra
                  
                    
                      
                      
                      
                        
                          Kubernetes
                        
                      
                    
                      
                      
                      
                        
                          Security
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Styra
                      Kubernetes
                      
                        Styra enables enterprises to define, enforce, and validate security across their Kubernetes environments. Styra’s simple graphical library of customizable policies lets Security and DevOps teams mitigate risks, reduce human error, and accelerate development.

                      
                      
                        
                          
                            Visit Styra website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


View documentation 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Sumo Logic
                  
                    
                      
                      
                      
                        
                          Reporting
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Sumo Logic
                      Reporting
                      
                        Sumo Logic is a cloud-based data analytics company that provides real-time metrics across the application lifecycle and stack.

                      
                      
                        
                          
                            Visit Sumo Logic website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Sysdig
                  
                    
                      
                      
                      
                        
                          Containers
                        
                      
                    
                      
                      
                      
                        
                          Security
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Sysdig
                      Containers
                      
                        Sysdig is a SaaS platform built on an open source stack that includes Falco and sysdig OSS, the open standards for runtime threat detection and response.

                      
                      
                        
                          
                            Visit Sysdig website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Terraform
                  
                    
                      
                      
                      
                        
                          Infra Automation
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Terraform
                      Infra Automation
                      
                        HashiCorp enables organizations to adopt consistent workflows to provision, secure, connect, and run any infrastructure for any app. Their open source tools are downloaded tens of millions of times each year.

                      
                      
                        
                          
                            Visit Terraform website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


View documentation 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  TestFairy
                  
                    
                      
                      
                      
                        
                          Testing
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      TestFairy
                      Testing
                      
                        TestFairy is a mobile testing platform helping teams streamline their mobile development process. TestFairy provides developers with an all-in-one platform that handles app distribution, video recording, and bug and crash reporting on private clouds or on-premises.

                      
                      
                        
                          
                            Visit TestFairy website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


View documentation 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Testim
                  
                    
                      
                      
                      
                        
                          Testing
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Testim
                      Testing
                      
                        Testim uses artificial intelligence to speed-up the authoring, execution, and maintenance of web and mobile automated tests. Kick your runs off instantly through your CI/CD pipeline.

                      
                      
                        
                          
                            Visit Testim website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Testlio
                  
                    
                      
                      
                      
                        
                          Testing
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Testlio
                      Testing
                      
                        Testlio is the originator of networked testing. A combination of platform, freelancers, and services enable digital product companies to deliver great customer experiences, quickly.

                      
                      
                        
                          
                            Visit Testlio website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Thundra
                  
                    
                      
                      
                      
                        
                          Monitoring
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Thundra
                      Monitoring
                      
                        Thundra is a software company for developers who build, debug, test, and deliver modern microservices on cloud. Thundra provides a shift-left observability approach for developers.

                      
                      
                        
                          
                            Visit Thundra website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Twilio
                  
                    
                      
                      
                      
                        
                          Notifications
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Twilio
                      Notifications
                      
                        Twilio serves as the building blocks to add messaging, voice, and video in your web and mobile applications.

                      
                      
                        
                          
                            Visit Twilio website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Unmock
                  
                    
                      
                      
                      
                        
                          Testing
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Unmock
                      Testing
                      
                        Unmock's goal is to create a semantically and functionally accurate mock of the internet. Developers can test their code without calling real APIs from their CI/CD server.

                      
                      
                        
                          
                            Visit Unmock website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


View documentation 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  UPX
                  
                    
                      
                      
                      
                        
                          Build
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      UPX
                      Build
                      
                        UPX is a free, portable, extendable, high-performance executable packer for several executable formats.

                      
                      
                        
                          
                            Visit UPX website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  VMware Code Stream
                  
                    
                      
                      
                      
                        
                          Deployment
                        
                      
                    
                      
                      
                      
                        
                          Kubernetes
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      VMware Code Stream
                      Deployment
                      
                        VMware Code Stream provides release automation and continuous delivery to enable frequent, reliable releases of application and IT code.

                      
                      
                        
                          
                            Visit VMware Code Stream website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Wallarm
                  
                    
                      
                      
                      
                        
                          Security
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Wallarm
                      Security
                      
                        Wallarm is an application security platform that provides security coverage for APIs using a testing engine that is built to automate security in CI/CD pipelines.

                      
                      
                        
                          
                            Visit Wallarm website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Waypoint
                  
                    
                      
                      
                      
                        
                          Deployment
                        
                      
                    
                      
                      
                      
                        
                          Build
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Waypoint
                      Deployment
                      
                        HashiCorp enables organizations to adopt consistent workflows to provision, secure, connect, and run infrastructure for any app. Their open source tools are downloaded tens of millions of times each year.

                      
                      
                        
                          
                            Visit Waypoint website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


View documentation 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  WhiteSource
                  
                    
                      
                      
                      
                        
                          Security
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      WhiteSource
                      Security
                      
                        WhiteSource helps teams harness the power of open source without compromising on security or agility. Integrating with the SDLC, it continuously monitors and issues alerts in real-time on problematic components.

                      
                      
                        
                          
                            Visit WhiteSource website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View scan orb
                        
                        
                      
                        
                        
                        
                        
                          


View vulnerability orb 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Windows
                  
                    
                      
                      
                      
                        
                          Cloud Platform
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Windows
                      Cloud Platform
                      
                        Windows is an operating system that exists under Microsoft and is designed to help customers thrive in today’s mobile-first and cloud-first world.

                      
                      
                        
                          
                            Visit Windows website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  xMatters
                  
                    
                      
                      
                      
                        
                          Notifications
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      xMatters
                      Notifications
                      
                        xMatters is a digital service availability platform that helps enterprises prevent, manage, and resolve IT incidents before they can become business problems. xMatters automates key processes through integrations.

                      
                      
                        
                          
                            Visit xMatters website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


View documentation 

                        
                      
                        
                        
                        
                        
                          


View webinar 

                        
                      
                    
                  
                
              
            
          
        
        
          
            
              Don’t see a partner you need?
              
              Request a new integration.
            
          
          
            
            


Submit a request\n\nAccelerate your DevOps practices with CircleCI integrations
    Build your ideal toolchain. Explore integrations that bring flexibility and power to your CI/CD workflows.
  


  
    
      Filter by
      
        
          
            
              Select a filter…
              
                All integrations
                
                  
                  
                  
                    Artifacts / Registry
                  
                
                  
                  
                  
                    Build
                  
                
                  
                  
                  
                    Cloud Platform
                  
                
                  
                  
                  
                    Code Analysis
                  
                
                  
                  
                  
                    Collaboration
                  
                
                  
                  
                  
                    Containers
                  
                
                  
                  
                  
                    Deployment
                  
                
                  
                  
                  
                    Infra Automation
                  
                
                  
                  
                  
                    Kubernetes
                  
                
                  
                  
                  
                    Language / Framework
                  
                
                  
                  
                  
                    Monitoring
                  
                
                  
                  
                  
                    Notifications
                  
                
                  
                  
                  
                    Reporting
                  
                
                  
                  
                  
                    Security
                  
                
                  
                  
                  
                    Testing
                  
                
              
            
            
              
            
          
        
        
          
            All integrations
          
        
          
          
          
            
              Artifacts / Registry
            
          
        
          
          
          
            
              Build
            
          
        
          
          
          
            
              Cloud Platform
            
          
        
          
          
          
            
              Code Analysis
            
          
        
          
          
          
            
              Collaboration
            
          
        
          
          
          
            
              Containers
            
          
        
          
          
          
            
              Deployment
            
          
        
          
          
          
            
              Infra Automation
            
          
        
          
          
          
            
              Kubernetes
            
          
        
          
          
          
            
              Language / Framework
            
          
        
          
          
          
            
              Monitoring
            
          
        
          
          
          
            
              Notifications
            
          
        
          
          
          
            
              Reporting
            
          
        
          
          
          
            
              Security
            
          
        
          
          
          
            
              Testing
            
          
        
        
      
    
      
        
          
            All integrations
          
          
            
            
            
              
                Artifacts / Registry
              
            
          
            
            
            
              
                Build
              
            
          
            
            
            
              
                Cloud Platform
              
            
          
            
            
            
              
                Code Analysis
              
            
          
            
            
            
              
                Collaboration
              
            
          
            
            
            
              
                Containers
              
            
          
            
            
            
              
                Deployment
              
            
          
            
            
            
              
                Infra Automation
              
            
          
            
            
            
              
                Kubernetes
              
            
          
            
            
            
              
                Language / Framework
              
            
          
            
            
            
              
                Monitoring
              
            
          
            
            
            
              
                Notifications
              
            
          
            
            
            
              
                Reporting
              
            
          
            
            
            
              
                Security
              
            
          
            
            
            
              
                Testing
              
            
          
        
      
      
        
        All integrations

        
          
          
          
            
            
            
            
            
            
              
                
                
                  ACCELQ
                  
                    
                      
                      
                      
                        
                          Testing
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      ACCELQ
                      Testing
                      
                        ACCELQ is a cloud-based continuous testing platform that automates API, web, mobile, DB, and packaged applications without writing code.

                      
                      
                        
                          
                            Visit ACCELQ website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


View documentation 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Accurics
                  
                    
                      
                      
                      
                        
                          Security
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Accurics
                      Security
                      
                        Accurics codifies security into development pipelines to detect and fix cloud infrastructure risks. It maintains the secure posture in runtime by mitigating risks from infrastructure changes.

                      
                      
                        
                          
                            Visit Accurics website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


View documentation 

                        
                      
                        
                        
                        
                        
                          


Watch video overview 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Alcide.io
                  
                    
                      
                      
                      
                        
                          Security
                        
                      
                    
                      
                      
                      
                        
                          Kubernetes
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Alcide.io
                      Security
                      
                        Alcide delivers code-to-production security for workloads running on Kubernetes. Alcide Advisor performs customizable static and active checks of resources, workloads running inside the cluster, as well as checks of the cluster infrastructure itself.

                      
                      
                        
                          
                            Visit Alcide.io website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


View documentation 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Altostra
                  
                    
                      
                      
                      
                        
                          Deployment
                        
                      
                    
                      
                      
                      
                        
                          Infra Automation
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Altostra
                      Deployment
                      
                        Altostra is a no-code infrastructure platform that accelerates modern cloud application development like microservices, serverless applications, and more.

                      
                      
                        
                          
                            Visit Altostra website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


View documentation 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Anchore
                  
                    
                      
                      
                      
                        
                          Security
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Anchore
                      Security
                      
                        Anchore allows both operators and developers to perform detailed analysis, run queries, and define policies on container images for CI/CD pipelines. Only containers that meet your organization’s requirements are deployed into production.

                      
                      
                        
                          
                            Visit Anchore website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


View documentation 

                        
                      
                        
                        
                        
                        
                          


Watch video overview 

                        
                      
                        
                        
                        
                        
                          


Read blog post 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Android
                  
                    
                      
                      
                      
                        
                          Language / Framework
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Android
                      Language / Framework
                      
                        Alcide delivers code-to-production security for workloads running on Kubernetes. Alcide Advisor performs customizable static and active checks of resources, workloads running inside the cluster, as well as checks of the cluster infrastructure itself.

                      
                      
                        
                          
                            Visit Android website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Anecdotes
                  
                    
                      
                      
                      
                        
                          Monitoring
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Anecdotes
                      Monitoring
                      
                        The anecdotes Compliance OS is a data-based Compliance automation and management solution. With anecdotes, cloud-first companies can turn compliance into a business driver.

                      
                      
                        
                          
                            Visit Anecdotes website
                          
                        
                      
                    
                    
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Aqua Security
                  
                    
                      
                      
                      
                        
                          Security
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Aqua Security
                      Security
                      
                        Aqua Security provides a full dev-to-prod security solution for containers and cloud native applications on Kubernetes, Docker, OpenShift, Fargate, AWS, and other container platforms.

                      
                      
                        
                          
                            Visit Aqua Security website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Arm
                  
                    
                      
                      
                      
                        
                          Cloud Platform
                        
                      
                    
                      
                      
                      
                        
                          Infra Automation
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Arm
                      Cloud Platform
                      
                        Arm technology is the industry standard for IoT and embedded devices. Arm offers a range of processor designs, dev tools and software, and an ecosystem of partners for AI and end-to-end security.

                      
                      
                        
                          
                            Visit Arm website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Autify
                  
                    
                      
                      
                      
                        
                          Testing
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Autify
                      Testing
                      
                        Autify makes testing automation easy for anyone by allowing them to automate the testing of web and mobile applications without writing program codes.

                      
                      
                        
                          
                            Visit Autify website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View web orb
                        
                        
                      
                        
                        
                        
                        
                          


View CLI orb 

                        
                      
                        
                        
                        
                        
                          


View mobile orb 

                        
                      
                        
                        
                        
                        
                          


View documentation 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  AWS CLI
                  
                    
                      
                      
                      
                        
                          Cloud Platform
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      AWS CLI
                      Cloud Platform
                      
                        Install and configure the AWS command-line interface. As an AWS Technology Partner, CircleCI makes it easy to integrate CI/CD workflows with AWS using orbs. View AWS Marketplace

                      
                      
                        
                          
                            Visit AWS CLI website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View AWS CLI orb
                        
                        
                      
                        
                        
                        
                        
                          


Learn more 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  AWS CodeDeploy
                  
                    
                      
                      
                      
                        
                          Deployment
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      AWS CodeDeploy
                      Deployment
                      
                        Deploy applications to AWS CodeDeploy. As an AWS Technology Partner, CircleCI makes it easy to integrate CI/CD workflows with AWS using orbs.

                      
                      
                        
                          
                            Visit AWS CodeDeploy website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


Learn more 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Amazon ECR
                  
                    
                      
                      
                      
                        
                          Artifacts / Registry
                        
                      
                    
                      
                      
                      
                        
                          Containers
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Amazon ECR
                      Artifacts / Registry
                      
                        Build images and push them to the Amazon Elastic Container Registry. As an AWS Technology Partner, CircleCI makes it easy to integrate CI/CD workflows with AWS using orbs.

                      
                      
                        
                          
                            Visit Amazon ECR website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


Learn more 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Amazon ECS
                  
                    
                      
                      
                      
                        
                          Deployment
                        
                      
                    
                      
                      
                      
                        
                          Containers
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Amazon ECS
                      Deployment
                      
                        An orb for working with Amazon Elastic Container Service. As an AWS Technology Partner, CircleCI makes it easy to integrate CI/CD workflows with AWS using orbs.

                      
                      
                        
                          
                            Visit Amazon ECS website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


Learn more 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Amazon EKS
                  
                    
                      
                      
                      
                        
                          Deployment
                        
                      
                    
                      
                      
                      
                        
                          Containers
                        
                      
                    
                      
                      
                      
                        
                          Kubernetes
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Amazon EKS
                      Deployment
                      
                        An orb for working with Amazon Elastic Container Service for Kubernetes. As an AWS Technology Partner, CircleCI makes it easy to integrate CI/CD workflows with AWS using orbs. that make it easier than ever.

                      
                      
                        
                          
                            Visit Amazon EKS website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


Learn more 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Amazon Elastic Beanstalk
                  
                    
                      
                      
                      
                        
                          Deployment
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Amazon Elastic Beanstalk
                      Deployment
                      
                        Deploy and scale web applications and services via AWS Elastic Beanstalk with CircleCI. As an AWS Technology Partner, CircleCI makes it easy to integrate CI/CD workflows with AWS using orbs.

                      
                      
                        
                          
                            Visit Amazon Elastic Beanstalk website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


View documentation 

                        
                      
                        
                        
                        
                        
                          


Learn more 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Amazon Health
                  
                    
                      
                      
                      
                        
                          Deployment
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Amazon Health
                      Deployment
                      
                        AWS Health is a RESTful web service that uses HTTPS as a transport and JSON as a message serialization format.

                      
                      
                        
                          
                            Visit Amazon Health website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  AWS SAM Serverless
                  
                    
                      
                      
                      
                        
                          Deployment
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      AWS SAM Serverless
                      Deployment
                      
                        Build, test, and deploy your AWS serverless applications on CircleCI utilizing the AWS SAM Serverless Application Model.

                      
                      
                        
                          
                            Visit AWS SAM Serverless website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


Learn more 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Amazon S3
                  
                    
                      
                      
                      
                        
                          Artifacts / Registry
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Amazon S3
                      Artifacts / Registry
                      
                        A set of tools for working with Amazon S3. Requirements: bash. As an AWS Partner Network Advanced Technology Partner, CircleCI makes it
 easy to integrate CI/CD workflows with AWS. Now with CircleCI orbs for AWS
 that make it easier than ever.

                      
                      
                        
                          
                            Visit Amazon S3 website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


Learn more 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Azure ACR
                  
                    
                      
                      
                      
                        
                          Containers
                        
                      
                    
                      
                      
                      
                        
                          Artifacts / Registry
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Azure ACR
                      Containers
                      
                        Build images and push them to Azure Container Registry. CircleCI partners with Azure and Sirrus7 in the DevOps Acceleration Engine offering in the Azure Marketplace. Also, with orbs for Azure, it’s easy to integrate.

                      
                      
                        
                          
                            Visit Azure ACR website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


Learn more 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Azure AKS
                  
                    
                      
                      
                      
                        
                          Containers
                        
                      
                    
                      
                      
                      
                        
                          Deployment
                        
                      
                    
                      
                      
                      
                        
                          Kubernetes
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Azure AKS
                      Containers
                      
                        CircleCI partners with Azure and Sirrus7 in the DevOps Acceleration Engine offering in the Azure Marketplace. Also, with orbs for Azure, it’s easy to integrate.

                      
                      
                        
                          
                            Visit Azure AKS website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


Learn more 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Azure CLI
                  
                    
                      
                      
                      
                        
                          Cloud Platform
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Azure CLI
                      Cloud Platform
                      
                        Install, initialize, and log into the Azure command-line interface. CircleCI partners with Azure and Sirrus7 in the DevOps Acceleration Engine offering in the Azure Marketplace. Also, with orbs for Azure, it’s easy to integrate.

                      
                      
                        
                          
                            Visit Azure CLI website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


Learn more 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Bitbucket
                  
                    
                      
                      
                      
                        
                          Cloud Platform
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Bitbucket
                      Cloud Platform
                      
                        CircleCI integrates with Bitbucket in a single click, enabling build triggers and build statuses within the Bitbucket UI.

                      
                      
                        
                          
                            Visit Bitbucket website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          Learn more
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Blackfire.io
                  
                    
                      
                      
                      
                        
                          Testing
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Blackfire.io
                      Testing
                      
                        Configures Blackfire agent to aggregate profile data collected by the probe from your application engine before sending it to servers.

                      
                      
                        
                          
                            Visit Blackfire.io website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View agent orb
                        
                        
                      
                        
                        
                        
                        
                          


View documentation 

                        
                      
                        
                        
                        
                        
                          


View PHP orb 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Bridgecrew
                  
                    
                      
                      
                      
                        
                          Security
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Bridgecrew
                      Security
                      
                        Bridgecrew is changing the way teams secure their cloud. By leveraging security-as-code and automation, Bridgecrew identifies and fixes cloud infrastructure misconfigurations in run-time and build-time.

                      
                      
                        
                          
                            Visit Bridgecrew website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


View documentation 

                        
                      
                        
                        
                        
                        
                          


View webinar 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Buildtrakr
                  
                    
                      
                      
                      
                        
                          Reporting
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Buildtrakr
                      Reporting
                      
                        Buildtrakr surfaces critical metrics, powerful drill-down and trend analysis to help you better understand build performance and cost. Buildtrakr is brought to you by the team at Plandek (www.plandek.com) the world-leading end-to-end delivery analytics platform.

                      
                      
                        
                          
                            Visit Buildtrakr website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          Learn more
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  CheckMarx
                  
                    
                      
                      
                      
                        
                          Security
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      CheckMarx
                      Security
                      
                        Checkmarx is the global leader in software security solutions for modern enterprise software development. Their comprehensive software security platform unifies with DevOps to provide static and interactive application security testing, software composition analysis, developer AppSec awareness, and training programs to remediate risk from vulnerabilities. Checkmarx is trusted by more than 40 of the Fortune 100 companies and half of the Fortune 50, including leading organizations like SAP, Samsung, and Salesforce.

                      
                      
                        
                          
                            Visit CheckMarx website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Cloud Foundry
                  
                    
                      
                      
                      
                        
                          Deployment
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Cloud Foundry
                      Deployment
                      
                        Cloud Foundry makes it faster and easier to build, test, deploy and scale applications, providing a choice of clouds, developer frameworks, and application services. It is an open source project and is available through a variety of private cloud distributions and public cloud instances.

                      
                      
                        
                          
                            Visit Cloud Foundry website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  CloudQA
                  
                    
                      
                      
                      
                        
                          Testing
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      CloudQA
                      Testing
                      
                        CloudQA is a codeless test automation tool designed to reduce the effort, cost, and complexity of software testing.  CloudQA helps organizations speed up their testing by 5x with a no-code approach.

                      
                      
                        
                          
                            Visit CloudQA website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


View documentation 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Cloudsmith
                  
                    
                      
                      
                      
                        
                          Artifacts / Registry
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Cloudsmith
                      Artifacts / Registry
                      
                        Cloudsmith is a hosted universal package management service that provides secure repositories to store, share and collaborate on published software assets.

                      
                      
                        
                          
                            Visit Cloudsmith website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


View documentation 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Codecov
                  
                    
                      
                      
                      
                        
                          Code Analysis
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Codecov
                      Code Analysis
                      
                        Codecov is the leading dedicated code coverage solution, helping teams improve code review workflow and quality. Use Codecov’s highly integrated tools to group, merge, archive, and compare coverage reports.

                      
                      
                        
                          
                            Visit Codecov website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


Read blog post 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  CodeScene
                  
                    
                      
                      
                      
                        
                          Code Analysis
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      CodeScene
                      Code Analysis
                      
                        CodeScene is a powerful visualization tool that uses predictive analytics to prioritize technical debt, detect code at risk for defects, and even uncover team productivity bottlenecks.

                      
                      
                        
                          
                            Visit CodeScene website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


View documentation 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  CommitLint
                  
                    
                      
                      
                      
                        
                          Testing
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      CommitLint
                      Testing
                      
                        CommitLint helps your team stick to commit conventions. Npm-installed configurations are supported, making it easy to share commit conventions.

                      
                      
                        
                          
                            Visit CommitLint website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


View documentation 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  ConfigCat
                  
                    
                      
                      
                      
                        
                          Code Analysis
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      ConfigCat
                      Code Analysis
                      
                        ConfigCat is a feature flag and configuration management platform that provides a single place to manage frontend, backend, mobile, and desktop apps.

                      
                      
                        
                          
                            Visit ConfigCat website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Contrast Security
                  
                    
                      
                      
                      
                        
                          Security
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Contrast Security
                      Security
                      
                        Contrast Security is the world’s leading provider of instrumentation technology that embeds highly effective vulnerability analysis and exploit prevention directly into modern software.

                      
                      
                        
                          
                            Visit Contrast Security website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Convox
                  
                    
                      
                      
                      
                        
                          Deployment
                        
                      
                    
                      
                      
                      
                        
                          Kubernetes
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Convox
                      Deployment
                      
                        Convox allows teams of all sizes to develop, deploy, and scale their apps. From local development to production deployments, Convox makes it easy. Stop spending time on infrastructure and focus on your apps.

                      
                      
                        
                          
                            Visit Convox website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


View documentation 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Coralogix
                  
                    
                      
                      
                      
                        
                          Monitoring
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Coralogix
                      Monitoring
                      
                        Coralogix is a machine learning-based logging platform that helps software companies manage their log data, ensure quality version release, and automatically identify problems in their production.

                      
                      
                        
                          
                            Visit Coralogix website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


View documentation 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Coveralls
                  
                    
                      
                      
                      
                        
                          Code Analysis
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Coveralls
                      Code Analysis
                      
                        Posts coverage to Coveralls for analysis & tracking, and adds coverage change in a comment on PR builds.

                      
                      
                        
                          
                            Visit Coveralls website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Cypress
                  
                    
                      
                      
                      
                        
                          Testing
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Cypress
                      Testing
                      
                        Cypress is a front end automated testing tool, created for the modern web. Cypress provides better, faster, and more reliable testing for anything that runs in a browser.

                      
                      
                        
                          
                            Visit Cypress website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


Watch video overview 

                        
                      
                        
                        
                        
                        
                          


Read blog post 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Datadog
                  
                    
                      
                      
                      
                        
                          Monitoring
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Datadog
                      Monitoring
                      
                        Datadog is a monitoring platform bringing together data from servers, containers, databases, and third-party services. Datadog helps teams avoid downtime and resolve performance issues to ensure customers get the best user experience.

                      
                      
                        
                          
                            Visit Datadog website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View documentation
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  datree policy
                  
                    
                      
                      
                      
                        
                          Code Analysis
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      datree policy
                      Code Analysis
                      
                        datree is a Git-level production gatekeeper. Control changes, prevent mishaps, and deploy safely with datree.

                      
                      
                        
                          
                            Visit datree policy website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


View documentation 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  datree CLI
                  
                    
                      
                      
                      
                        
                          Kubernetes
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      datree CLI
                      Kubernetes
                      
                        datree is a Git-level production gatekeeper. Control changes, prevent mishaps, and deploy safely with datree.

                      
                      
                        
                          
                            Visit datree CLI website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  DBmaestro
                  
                    
                      
                      
                      
                        
                          Deployment
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      DBmaestro
                      Deployment
                      
                        DBmaestro is a leader in the database delivery automation category, whose platform empowers organizations to automate, secure, and govern database delivery pipelines.

                      
                      
                        
                          
                            Visit DBmaestro website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


Video Tutorial 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  DeepFactor
                  
                    
                      
                      
                      
                        
                          Security
                        
                      
                    
                      
                      
                      
                        
                          Monitoring
                        
                      
                    
                      
                      
                      
                        
                          Kubernetes
                        
                      
                    
                      
                      
                      
                        
                          Containers
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      DeepFactor
                      Security
                      
                        Find and fix runtime security, compliance, and behavior issues in custom and third party code within your pipeline.

                      
                      
                        
                          
                            Visit DeepFactor website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


View documentation 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  DeepSource
                  
                    
                      
                      
                      
                        
                          Testing
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      DeepSource
                      Testing
                      
                        DeepSource continuously analyzes source code changes to find and fix security and performance issues,  anti-patterns, and bug-risks before they make it into production.

                      
                      
                        
                          
                            Visit DeepSource website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


View documentation 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  DefenseCode
                  
                    
                      
                      
                      
                        
                          Security
                        
                      
                    
                      
                      
                      
                        
                          Testing
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      DefenseCode
                      Security
                      
                        DefenseCode provides accurate, fast security products that seamlessly integrate into the software development lifecycle. Comprehensive and in-depth security analysis for both SAST and DAST.

                      
                      
                        
                          
                            Visit DefenseCode website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  DeployHub
                  
                    
                      
                      
                      
                        
                          Deployment
                        
                      
                    
                      
                      
                      
                        
                          Kubernetes
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      DeployHub
                      Deployment
                      
                        DeployHub is a central catalog of deployable objects where developers can publish to and deploy from. DeployHub is essential for both agile practices
 and modern microservices architectures.

                      
                      
                        
                          
                            Visit DeployHub website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


Video tutorial 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Docker Hub
                  
                    
                      
                      
                      
                        
                          Containers
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Docker Hub
                      Containers
                      
                        Docker Hub is the world’s largest repository of container images with an array of content sources including container community developers, open source projects and independent software vendors (ISV) building and distributing their code in containers.

                      
                      
                        
                          
                            Visit Docker Hub website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  F0cal
                  
                    
                      
                      
                      
                        
                          Containers
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      F0cal
                      Containers
                      
                        FØCAL lets you provision, build, and test your code on edge devices like NVidia, Intel, AMD, and Raspberry Pi, directly on your desktop.

                      
                      
                        
                          
                            Visit F0cal website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Fairwinds
                  
                    
                      
                      
                      
                        
                          Kubernetes
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Fairwinds
                      Kubernetes
                      
                        Fairwinds is a cloud-native infrastructure provider that builds and maintains Kubernetes clusters.

                      
                      
                        
                          
                            Visit Fairwinds website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


View documentation 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Flutter
                  
                    
                      
                      
                      
                        
                          Language / Framework
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Flutter
                      Language / Framework
                      
                        Flutter is Google's UI toolkit for building natively compiled applications for mobile, web, desktop, and embedded devices from a single codebase.

                      
                      
                        
                          
                            Visit Flutter website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Fortanix
                  
                    
                      
                      
                      
                        
                          Security
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Fortanix
                      Security
                      
                        Fortanix uses Runtime Encryption to keep keys, data, and applications protected from external and internal threats including malicious insiders, cloud providers, OS-level hacks and network intruders.

                      
                      
                        
                          
                            Visit Fortanix website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Fossa
                  
                    
                      
                      
                      
                        
                          Security
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Fossa
                      Security
                      
                        FOSSA provides automated, real-time licensing and vulnerability management for open source code anywhere in your software stack.

                      
                      
                        
                          
                            Visit Fossa website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


View documentation 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  GameCI
                  
                    
                      
                      
                      
                        
                          Language / Framework
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      GameCI
                      Language / Framework
                      
                        The fastest and easiest way to automatically test and build your game projects. GameCI offers friendly functional APIs, that does not require much technical knowledge to configure. Making customisations is easily done by forking our projects, giving much flexibility.

                      
                      
                        
                          
                            Visit GameCI website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Genymotion
                  
                    
                      
                      
                      
                        
                          Testing
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Genymotion
                      Testing
                      
                        Genymotion Cloud SaaS provides Android virtual devices on the Cloud with various configurations and Android versions. Start many virtual devices and test at scale for mobile automation testing.

                      
                      
                        
                          
                            Visit Genymotion website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


Read blog post 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Ghost Inspector
                  
                    
                      
                      
                      
                        
                          Testing
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Ghost Inspector
                      Testing
                      
                        Ghost Inspector is an automated browser testing and monitoring solution that allows teams to easily build and manage tests that ensure their website or application is functioning properly.

                      
                      
                        
                          
                            Visit Ghost Inspector website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


View documentation 

                        
                      
                        
                        
                        
                        
                          


Read blog post 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  GitGuardian
                  
                    
                      
                      
                      
                        
                          Security
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      GitGuardian
                      Security
                      
                        GitGuardian helps software-driven organizations secure the SDLC with automated secrets detection and remediation.

                      
                      
                        
                          
                            Visit GitGuardian website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  GitHub
                  
                    
                      
                      
                      
                        
                          Cloud Platform
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      GitHub
                      Cloud Platform
                      
                        CircleCI integrates with GitHub.com or GitHub Enterprise with a single click, enabling build triggers and GitHub Checks integration.

                      
                      
                        
                          
                            Visit GitHub website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          Learn more
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  GitHub CLI
                  
                    
                      
                      
                      
                        
                          Deployment
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      GitHub CLI
                      Deployment
                      
                        CircleCI’s seamless integration with GitHub’s release features is easier than ever with the GitHub CLI orb.

                      
                      
                        
                          
                            Visit GitHub CLI website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


View documentation 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  GitLab
                  
                    
                      
                      
                      
                        
                          Cloud Platform
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      GitLab
                      Cloud Platform
                      
                        CircleCI integrates with GitLab SaaS via OAuth or personal API and GitLab self-managed via personal access token.

                      
                      
                        
                          
                            Visit GitLab website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View documentation
                        
                        
                      
                        
                        
                        
                        
                          


Learn more 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  GCP Binary Authorization
                  
                    
                      
                      
                      
                        
                          Security
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      GCP Binary Authorization
                      Security
                      
                        Binary Authorization is a deploy-time security control that ensures only trusted container images are deployed on Google Kubernetes Engine (GKE).

                      
                      
                        
                          
                            Visit GCP Binary Authorization website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Google Cloud CLI
                  
                    
                      
                      
                      
                        
                          Cloud Platform
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Google Cloud CLI
                      Cloud Platform
                      
                        Install and configure the Google Cloud CLI (gcloud). As a GCP Partner with PaaS and DevOps capabilities, CircleCI makes it easy to integrate CI/CD workflows with GCP. Now with CircleCI orbs for GCP that make it easier than ever.

                      
                      
                        
                          
                            Visit Google Cloud CLI website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


Learn more 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Google Cloud GCR
                  
                    
                      
                      
                      
                        
                          Artifacts / Registry
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Google Cloud GCR
                      Artifacts / Registry
                      
                        An orb for working with Google Container Registry. As a GCP Partner with PaaS and DevOps capabilities, CircleCI makes it easy to integrate CI/CD workflows with GCP. Now with CircleCI orbs for GCP that make it easier than ever.

                      
                      
                        
                          
                            Visit Google Cloud GCR website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Google Cloud GKE
                  
                    
                      
                      
                      
                        
                          Deployment
                        
                      
                    
                      
                      
                      
                        
                          Kubernetes
                        
                      
                    
                      
                      
                      
                        
                          Containers
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Google Cloud GKE
                      Deployment
                      
                        An orb for working with Google Kubernetes Engine. As a GCP Partner with PaaS and DevOps capabilities, CircleCI makes it easy to integrate CI/CD workflows with GCP. Now with CircleCI orbs for GCP that make it easier than ever.

                      
                      
                        
                          
                            Visit Google Cloud GKE website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Google Cloud Run
                  
                    
                      
                      
                      
                        
                          Deployment
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Google Cloud Run
                      Deployment
                      
                        Build and deploy stateless images to Google Cloud Run as serverless applications.

                      
                      
                        
                          
                            Visit Google Cloud Run website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Gradle
                  
                    
                      
                      
                      
                        
                          Build
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Gradle
                      Build
                      
                        From mobile apps to microservices, from small startups to big enterprises, Gradle helps teams build, automate and deliver better software, faster.

                      
                      
                        
                          
                            Visit Gradle website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Happo
                  
                    
                      
                      
                      
                        
                          Testing
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Happo
                      Testing
                      
                        Happo is a cross-browser screenshot testing tool. It helps you prevent visual regressions before they reach production, and lets you see how a change visually effects the UI.

                      
                      
                        
                          
                            Visit Happo website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Helm
                  
                    
                      
                      
                      
                        
                          Deployment
                        
                      
                    
                      
                      
                      
                        
                          Kubernetes
                        
                      
                    
                      
                      
                      
                        
                          Containers
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Helm
                      Deployment
                      
                        Helm helps you manage Kubernetes applications — Helm Charts help you define, install, and upgrade even the most complex Kubernetes application. Charts are easy to create, version, share, and publish — so start using Helm and stop the copy-and-paste.

                      
                      
                        
                          
                            Visit Helm website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Heroku
                  
                    
                      
                      
                      
                        
                          Cloud Platform
                        
                      
                    
                      
                      
                      
                        
                          Deployment
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Heroku
                      Cloud Platform
                      
                        CircleCI seamlessly integrates with Heroku to help improve your deployment workflow. Now easier than ever with the CircleCI orb for Heroku.

                      
                      
                        
                          
                            Visit Heroku website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          Learn more
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Honey​badger.io
                  
                    
                      
                      
                      
                        
                          Monitoring
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Honey​badger.io
                      Monitoring
                      
                        Honeybadger combines exception, uptime and check-in monitoring into one easy-to-use platform. Instant error notifications help teams understand what is causing each exception and which users are affected.

                      
                      
                        
                          
                            Visit Honey​badger.io website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Honeycomb
                  
                    
                      
                      
                      
                        
                          Monitoring
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Honeycomb
                      Monitoring
                      
                        Honeycomb is a tool for introspecting and interrogating your production systems. Observe and rapidly debug using Honeycomb’s deep analytics tool to achieve production excellence.

                      
                      
                        
                          
                            Visit Honeycomb website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Hugo
                  
                    
                      
                      
                      
                        
                          Language / Framework
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Hugo
                      Language / Framework
                      
                        Hugo is one of the most popular open-source static site generators. With its amazing speed and flexibility, Hugo makes building websites fun again.

                      
                      
                        
                          
                            Visit Hugo website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Humanitec
                  
                    
                      
                      
                      
                        
                          Kubernetes
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Humanitec
                      Kubernetes
                      
                        Humanitec’s platform allows developers to master continuous delivery for Kubernetes-ready applications, driving higher deployment frequency, lower lead times, and better developer satisfaction.

                      
                      
                        
                          
                            Visit Humanitec website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View documentation
                        
                        
                      
                        
                        
                        
                        
                          


Watch video overview 

                        
                      
                        
                        
                        
                        
                          


Read blog post 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Indeni
                  
                    
                      
                      
                      
                        
                          Security
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Indeni
                      Security
                      
                        Indeni is the leader in security infrastructure automation, pioneering a new way to manage security infrastructure and IaC.

                      
                      
                        
                          
                            Visit Indeni website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


View documentation 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Instana
                  
                    
                      
                      
                      
                        
                          Containers
                        
                      
                    
                      
                      
                      
                        
                          Monitoring
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Instana
                      Containers
                      
                        Instana’s enterprise observability platform discovers, maps, and monitors services, infrastructure components, and dependencies in real time.

                      
                      
                        
                          
                            Visit Instana website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


View documentation 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Ionir
                  
                    
                      
                      
                      
                        
                          Kubernetes
                        
                      
                    
                      
                      
                      
                        
                          Infra Automation
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Ionir
                      Kubernetes
                      
                        Ionir’s container-native storage and data management platform for Kubernetes combines software-defined storage with data mobility for a single data cloud for applications across all infrastructures.

                      
                      
                        
                          
                            Visit Ionir website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


View documentation 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Jira
                  
                    
                      
                      
                      
                        
                          Collaboration
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Jira
                      Collaboration
                      
                        Jira is a family of products built to help all types of teams manage their work. Jira offers several products and deployment options that are purpose-built for Software, IT, Business, Ops teams, and more.

                      
                      
                        
                          
                            Visit Jira website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  jq
                  
                    
                      
                      
                      
                        
                          Language / Framework
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      jq
                      Language / Framework
                      
                        jq is a lightweight and flexible command-line JSON processor. jq is written in portable C, and it has zero runtime dependencies.

                      
                      
                        
                          
                            Visit jq website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  k6
                  
                    
                      
                      
                      
                        
                          Testing
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      k6
                      Testing
                      
                        k6 is a modern load testing tool that provides a clean, approachable scripting API, local and cloud execution, and flexible configuration.

                      
                      
                        
                          
                            Visit k6 website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


View documentation 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Kaholo
                  
                    
                      
                      
                      
                        
                          Build
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Kaholo
                      Build
                      
                        Use Kaholo to build automation pipelines with a simple drag and drop interface.

                      
                      
                        
                          
                            Visit Kaholo website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View documentation
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Katalon
                  
                    
                      
                      
                      
                        
                          Testing
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Katalon
                      Testing
                      
                        Executes Katalon tests with CircleCI by pushing your test scripts, and changing the Katalon Studio version starting from 7.0 to run the test with a variety of options supported.

                      
                      
                        
                          
                            Visit Katalon website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Kobiton
                  
                    
                      
                      
                      
                        
                          Testing
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Kobiton
                      Testing
                      
                        Kobiton is how companies make their mobile apps work better everywhere. Using real devices and next-gen automation, test your app in a fraction of the time it would normally take.

                      
                      
                        
                          
                            Visit Kobiton website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Kubernetes
                  
                    
                      
                      
                      
                        
                          Kubernetes
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Kubernetes
                      Kubernetes
                      
                        Kubernetes is an open source system for automating deployment, scaling, and management of containerized applications.

                      
                      
                        
                          
                            Visit Kubernetes website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Kublr
                  
                    
                      
                      
                      
                        
                          Kubernetes
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Kublr
                      Kubernetes
                      
                        Kublr is a container management platform focused specifically on the needs of enterprise customers. Focusing on the Kubernetes and infrastructure layer, Kublr provides the operations and governance capabilities that enterprises need to run reliably at scale.

                      
                      
                        
                          
                            Visit Kublr website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Lacework
                  
                    
                      
                      
                      
                        
                          Security
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Lacework
                      Security
                      
                        Lacework delivers security and compliance for the cloud. Their cloud-native security platform delivers build-time to run-time threat detection, behavioral anomaly detection, and cloud compliance across multi-cloud environments, workloads, containers, and Kubernetes. Customers significantly drive down costs by eliminating unnecessary hardware, rule writing, and inaccurate alerts. Lacework is trusted worldwide by cloud-embracing enterprise companies. They are a privately held company based in Mountain View, California, and are funded by Sutter Hill Ventures, Liberty Global Ventures, Spike Ventures, the Webb Investment Network (WIN), and AME Cloud Ventures.

                      
                      
                        
                          
                            Visit Lacework website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  LambdaTest
                  
                    
                      
                      
                      
                        
                          Testing
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      LambdaTest
                      Testing
                      
                        LambdaTest is a cloud-based, cross-browser testing platform where users can perform automated and manual compatibility testing of their website or web app on a combination of 2000+ different browsers & OSs.

                      
                      
                        
                          
                            Visit LambdaTest website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  LaunchDarkly
                  
                    
                      
                      
                      
                        
                          Deployment
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      LaunchDarkly
                      Deployment
                      
                        LaunchDarkly is the feature management platform that software teams use to build better software, faster with less risk. Teams can control their entire feature lifecycles from concept to launch to value.

                      
                      
                        
                          
                            Visit LaunchDarkly website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Lightspin
                  
                    
                      
                      
                      
                        
                          Security
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Lightspin
                      Security
                      
                        Lightspin’s multi-layer CNAPP solution minimizes effort, secures your hybrid cloud environment, and provides prioritization and remediation of critical potential attack paths across your cloud stack.

                      
                      
                        
                          
                            Visit Lightspin website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  LocalStack
                  
                    
                      
                      
                      
                        
                          Cloud Platform
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      LocalStack
                      Cloud Platform
                      
                        LocalStack provides a fully functional local cloud stack for testing cloud and serverless apps offline.

                      
                      
                        
                          
                            Visit LocalStack website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  LogDNA
                  
                    
                      
                      
                      
                        
                          Monitoring
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      LogDNA
                      Monitoring
                      
                        LogDNA’s log management platform provides deep insight into development and production environments. LogDNA allows teams to ingest, aggregate and view log data regardless of data residency and infrastructure.

                      
                      
                        
                          
                            Visit LogDNA website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Logz.io
                  
                    
                      
                      
                      
                        
                          Monitoring
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Logz.io
                      Monitoring
                      
                        Delivers the ELK Stack and Grafana as a fully managed service.

                      
                      
                        
                          
                            Visit Logz.io website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Mabl
                  
                    
                      
                      
                      
                        
                          Testing
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Mabl
                      Testing
                      
                        Mabl empowers software development teams to integrate end-to-end testing into the entire CI/CD development lifecycle.

                      
                      
                        
                          
                            Visit Mabl website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


View documentation 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  macOS
                  
                    
                      
                      
                      
                        
                          Cloud Platform
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      macOS
                      Cloud Platform
                      
                        macOS is the primary operating system for Apple's Mac computers. Within the market of desktop, laptop and home computers, and by web usage, it is the second most widely used desktop OS, after Microsoft Windows.

                      
                      
                        
                          
                            Visit macOS website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Manas.Tech
                  
                    
                      
                      
                      
                        
                          Language / Framework
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Manas.Tech
                      Language / Framework
                      
                        Helps developers perform common tasks for the Crystal programming language.

                      
                      
                        
                          
                            Visit Manas.Tech website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


View documentation 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  MathWorks
                  
                    
                      
                      
                      
                        
                          Language / Framework
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      MathWorks
                      Language / Framework
                      
                        MathWorks is the leading developer of mathematical computing software for engineers and scientists.

                      
                      
                        
                          
                            Visit MathWorks website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


View documentation 

                        
                      
                        
                        
                        
                        
                          


Read blog post 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Maven
                  
                    
                      
                      
                      
                        
                          Build
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Maven
                      Build
                      
                        Apache Maven is a software project management and comprehension tool. Based on the concept of a project object model (POM), Maven can manage a project's build, reporting and documentation from a central piece of information.

                      
                      
                        
                          
                            Visit Maven website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  MuukTest
                  
                    
                      
                      
                      
                        
                          Testing
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      MuukTest
                      Testing
                      
                        Current test automation tools require extensive development skills and manually defining the items to test. We create and execute test scripts automatically after analyzing the software application.

                      
                      
                        
                          
                            Visit MuukTest website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


View documentation 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Neocortix
                  
                    
                      
                      
                      
                        
                          Testing
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Neocortix
                      Testing
                      
                        Neocortix is a distributed cloud computing company that runs on a worldwide network of mobile devices to help with processes like load testing, web crawling, and network telemetry.

                      
                      
                        
                          
                            Visit Neocortix website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Neuralegion / Nexploit
                  
                    
                      
                      
                      
                        
                          Testing
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Neuralegion / Nexploit
                      Testing
                      
                        NeuraLegion is an application security testing platform that helps eliminate a shortage of security personnel by enabling developers & QA teams to run their own security tests.

                      
                      
                        
                          
                            Visit Neuralegion / Nexploit website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


View documentation 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  NeuVector
                  
                    
                      
                      
                      
                        
                          Security
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      NeuVector
                      Security
                      
                        NeuVector is a run-time container network security platform that delivers highly integrated, automated security for Kubernetes, employing a firewall with packet-level interrogation and enforcement.

                      
                      
                        
                          
                            Visit NeuVector website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


View documentation 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  New Relic
                  
                    
                      
                      
                      
                        
                          Monitoring
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      New Relic
                      Monitoring
                      
                        The leading observability platform for Dev and Ops teams to join and solve problems using data. Analyze and troubleshoot on your entire software stack with AI to detect and resolve incidents faster.

                      
                      
                        
                          
                            Visit New Relic website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          Install quickstart
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Nightfall
                  
                    
                      
                      
                      
                        
                          Code Analysis
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Nightfall
                      Code Analysis
                      
                        Nightfall is the first cloud-native data loss prevention platform that uses machine learning to discover, classify, and protect sensitive data.

                      
                      
                        
                          
                            Visit Nightfall website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Nirmata
                  
                    
                      
                      
                      
                        
                          Kubernetes
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Nirmata
                      Kubernetes
                      
                        Nirmata provides visibility, governance, and life-cycle management of Kubernetes clusters and workloads. The Kubernetes management platform accelerates the adoption of open-source and cloud-native technologies.

                      
                      
                        
                          
                            Visit Nirmata website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Node
                  
                    
                      
                      
                      
                        
                          Language / Framework
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Node
                      Language / Framework
                      
                        As an asynchronous event driven JavaScript runtime, Node is designed to build scalable network applications.

                      
                      
                        
                          
                            Visit Node website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  NowSecure
                  
                    
                      
                      
                      
                        
                          Testing
                        
                      
                    
                      
                      
                      
                        
                          Security
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      NowSecure
                      Testing
                      
                        NowSecure integrates automated mobile appsec testing into the DevOps toolchain. Built to give fast-moving mobile appdev teams the power of a fully automated dynamic pen test on every build in <15 mins with no false positives.

                      
                      
                        
                          
                            Visit NowSecure website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


Watch video overview 

                        
                      
                        
                        
                        
                        
                          


Read blog post 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  OpenShift
                  
                    
                      
                      
                      
                        
                          Deployment
                        
                      
                    
                      
                      
                      
                        
                          Kubernetes
                        
                      
                    
                      
                      
                      
                        
                          Containers
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      OpenShift
                      Deployment
                      
                        OpenShift is an open source container application platform based on the Kubernetes container orchestrator for enterprise application development and deployment.

                      
                      
                        
                          
                            Visit OpenShift website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  OpsGenie
                  
                    
                      
                      
                      
                        
                          Notifications
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      OpsGenie
                      Notifications
                      
                        Opsgenie is an incident management platform for operating always-on services, that helps teams plan for service disruptions and stay in control during incidents.

                      
                      
                        
                          
                            Visit OpsGenie website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Oxygen
                  
                    
                      
                      
                      
                        
                          Testing
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Oxygen
                      Testing
                      
                        Oxygen, contributed by CloudBeat, is an open source test automation framework and IDE that helps engineers write automation tests in minutes. Oxygen simplifies work with Selenium and Appium and other tests such as API, DB and IoT tests.

                      
                      
                        
                          
                            Visit Oxygen website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  packagecloud
                  
                    
                      
                      
                      
                        
                          Artifacts / Registry
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      packagecloud
                      Artifacts / Registry
                      
                        A unified, developer-friendly interface for all artifacts, packagecloud contains hosted npm, Maven, RPM, Debian, PyPi and RubyGem repositories with a focus on security and ease of use.

                      
                      
                        
                          
                            Visit packagecloud website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Packtracker
                  
                    
                      
                      
                      
                        
                          Code Analysis
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Packtracker
                      Code Analysis
                      
                        Packtracker.io is a tool that analyzes your webpack bundle over time to help you find bundle bloat, reduce repetition between chunks, and improve your caching strategies.

                      
                      
                        
                          
                            Visit Packtracker website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


View documentation 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Pantheon
                  
                    
                      
                      
                      
                        
                          Deployment
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Pantheon
                      Deployment
                      
                        Pantheon is a WebOps platform for Drupal and WordPress that helps organizations get more value from their sites through high-performance hosting, automated workflows, and professional tools for teams.

                      
                      
                        
                          
                            Visit Pantheon website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


View documentation 

                        
                      
                        
                        
                        
                        
                          


Read blog post 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Percy
                  
                    
                      
                      
                      
                        
                          Testing
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Percy
                      Testing
                      
                        Percy is an all-in-one visual testing solution, integrating with tests and the CI environment to detect visual regressions and give visual insight into every product change.

                      
                      
                        
                          
                            Visit Percy website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


Read blog post 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Pmbot
                  
                    
                      
                      
                      
                        
                          Code Analysis
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Pmbot
                      Code Analysis
                      
                        Pmbot helps teams keep their dependencies up to date without breaking their code.

                      
                      
                        
                          
                            Visit Pmbot website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


View documentation 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Portshift
                  
                    
                      
                      
                      
                        
                          Kubernetes
                        
                      
                    
                      
                      
                      
                        
                          Security
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Portshift
                      Kubernetes
                      
                        Allows users to perform vulnerability scans and to collect image identity attributes.

                      
                      
                        
                          
                            Visit Portshift website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


View documentation 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Postman
                  
                    
                      
                      
                      
                        
                          Testing
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Postman
                      Testing
                      
                        Postman is the only complete API development environment, for API developers, used by more than 5 million developers and 100,000 companies worldwide.

                      
                      
                        
                          
                            Visit Postman website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  PractiTest
                  
                    
                      
                      
                      
                        
                          Testing
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      PractiTest
                      Testing
                      
                        PractiTest is a leading SaaS Test Management system that helps companies release quality products by orchestrating manual, automated, and CI/CD tests.

                      
                      
                        
                          
                            Visit PractiTest website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


View documentation 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  PreFlight
                  
                    
                      
                      
                      
                        
                          Testing
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      PreFlight
                      Testing
                      
                        Preflight offers code-free, automated UI testing. Create tests by recording in your own product, then run tests across different environments, browsers and screen sizes.

                      
                      
                        
                          
                            Visit PreFlight website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


View documentation 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Prisma Cloud
                  
                    
                      
                      
                      
                        
                          Security
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Prisma Cloud
                      Security
                      
                        Palo Alto Networks provides integrated best-in-breed capabilities for the most comprehensive cybersecurity portfolio on the planet, enabling organizations to be secure today and prepared for tomorrow.

                      
                      
                        
                          
                            Visit Prisma Cloud website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


View documentation 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Probely
                  
                    
                      
                      
                      
                        
                          Security
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Probely
                      Security
                      
                        Probely allows agile teams to identify, manage, and fix security vulnerabilities in their web applications. Integrate Probely directly into your CI/CD pipelines to fully automate security.

                      
                      
                        
                          
                            Visit Probely website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


View documentation 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Provar
                  
                    
                      
                      
                      
                        
                          Testing
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Provar
                      Testing
                      
                        Provar uses Salesforce integration to build smarter tests. It specializes in advanced Salesforce features, such as Visualforce and the Service Cloud Console. Provar suggests the best field locators to build robust tests. Provar is a point-and-click tool and doesn’t need coding experience.

                      
                      
                        
                          
                            Visit Provar website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Pulumi
                  
                    
                      
                      
                      
                        
                          Infra Automation
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Pulumi
                      Infra Automation
                      
                        Pulumi provides a cloud development model for serverless functions, container apps, and data infrastructure for any cloud.

                      
                      
                        
                          
                            Visit Pulumi website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


View documentation 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Quali
                  
                    
                      
                      
                      
                        
                          Infra Automation
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Quali
                      Infra Automation
                      
                        Quali is an Environments-as-a-Service platform that delivers self-service access to on-demand environments.

                      
                      
                        
                          
                            Visit Quali website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Rafay
                  
                    
                      
                      
                      
                        
                          Deployment
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Rafay
                      Deployment
                      
                        Rafay provides a SaaS-based platform that lets you create, deploy, operate, monitor, and upgrade Kubernetes clusters & K8s resident apps across multi-clouds and environments.

                      
                      
                        
                          
                            Visit Rafay website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Rainforest​QA
                  
                    
                      
                      
                      
                        
                          Testing
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Rainforest​QA
                      Testing
                      
                        RainforestQA is a QA platform that allows you to write test cases in natural language, run them concurrently across multiple platforms, and get detailed bug reports that developers can act on.

                      
                      
                        
                          
                            Visit Rainforest​QA website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  realMethods
                  
                    
                      
                      
                      
                        
                          Code Analysis
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      realMethods
                      Code Analysis
                      
                        realMethods makes it easy to get running on CircleCI, by generating MVP quality applications for all major tech stacks committed to your Git repo with a ready to deploy CircleCI config file.

                      
                      
                        
                          
                            Visit realMethods website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Rezilion
                  
                    
                      
                      
                      
                        
                          Security
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Rezilion
                      Security
                      
                        Rezilion’s platform automatically secures the software you deliver with by detecting, prioritizing, and eliminating risk. Rezilion accelerates software security to free up time to build.

                      
                      
                        
                          
                            Visit Rezilion website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


View documentation 

                        
                      
                        
                        
                        
                        
                          


View integration 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Reflect
                  
                    
                      
                      
                      
                        
                          Testing
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Reflect
                      Testing
                      
                        No-code test automation for web applications

                      
                      
                        
                          
                            Visit Reflect website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Retool
                  
                    
                      
                      
                      
                        
                          Build
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Retool
                      Build
                      
                        Retool is the fast way to build your own custom internal tools. Retool is used by tens of thousands of companies from Amazon to Allbirds to NBC for support workflows, operations dashboards, and more.

                      
                      
                        
                          
                            Visit Retool website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View documentation
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Rollbar
                  
                    
                      
                      
                      
                        
                          Monitoring
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Rollbar
                      Monitoring
                      
                        Rollbar helps engineering teams deploy often and with confidence. Use Rollbar to detect all production errors in real-time and debug them in minutes - before users notice.

                      
                      
                        
                          
                            Visit Rollbar website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Rookout
                  
                    
                      
                      
                      
                        
                          Reporting
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Rookout
                      Reporting
                      
                        Rookout slashes debugging time and effort across the full product cycle, from development through staging and production. Get data visibility and collection without restarts, redeployments or added code.

                      
                      
                        
                          
                            Visit Rookout website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Rust
                  
                    
                      
                      
                      
                        
                          Language / Framework
                        
                      
                    
                      
                      
                      
                        
                          Build
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Rust
                      Language / Framework
                      
                        Easily build, test, lint, and run your Rust applications on CircleCI with automated caching.

                      
                      
                        
                          
                            Visit Rust website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Salesforce APEX
                  
                    
                      
                      
                      
                        
                          Language / Framework
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Salesforce APEX
                      Language / Framework
                      
                        Salesforce is a customer success platform that uses social and mobile cloud technologies to help companies connect with customers, partners, and employees in new ways.

                      
                      
                        
                          
                            Visit Salesforce APEX website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


View documentation 

                        
                      
                        
                        
                        
                        
                          


Learn more 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Salesforce SFDX
                  
                    
                      
                      
                      
                        
                          Deployment
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Salesforce SFDX
                      Deployment
                      
                        Salesforce is a customer success platform that uses social and mobile cloud technologies to help companies connect with customers, partners, and employees in new ways.

                      
                      
                        
                          
                            Visit Salesforce SFDX website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


Learn more 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Sauce Labs
                  
                    
                      
                      
                      
                        
                          Testing
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Sauce Labs
                      Testing
                      
                        Sauce Connect Proxy is a built-in HTTP proxy that allows testers to get to Dev/QA sites that are behind a firewall. The Sauce Labs Orbs integration sets up and launches Sauce Connect Proxy at the beginning of the build as a background task and terminates the connection at the end of the build. This can be configured to work with additional proxies and firewalls.

                      
                      
                        
                          
                            Visit Sauce Labs website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


View documentation 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  SecretHub
                  
                    
                      
                      
                      
                        
                          Security
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      SecretHub
                      Security
                      
                        Loads secrets into jobs through codified and auditable secret templates.

                      
                      
                        
                          
                            Visit SecretHub website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


View documentation 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Serverless
                  
                    
                      
                      
                      
                        
                          Deployment
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Serverless
                      Deployment
                      
                        The Serverless Framework gives you everything you need to develop, deploy, monitor and secure serverless applications on any cloud.

                      
                      
                        
                          
                            Visit Serverless website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Shiftleft
                  
                    
                      
                      
                      
                        
                          Security
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Shiftleft
                      Security
                      
                        ShiftLeft is a continuous application security platform. Their Inspect product helps identify vulnerabilities and sensitive data leakage in your code.

                      
                      
                        
                          
                            Visit Shiftleft website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Shipa
                  
                    
                      
                      
                      
                        
                          Kubernetes
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Shipa
                      Kubernetes
                      
                        Shipa delivers a unique cloud-native application management framework. Use Shipa and CircleCI to speed up development by eliminating workflow inefficiencies.

                      
                      
                        
                          
                            Visit Shipa website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


View documentation 

                        
                      
                        
                        
                        
                        
                          


Read blog post 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Shipyard
                  
                    
                      
                      
                      
                        
                          Build
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Shipyard
                      Build
                      
                        Shipyard creates and manages copies of your environments so you get a unique, shareable environment for every branch and PR, making it easy to collaborate.

                      
                      
                        
                          
                            Visit Shipyard website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


View documentation 

                        
                      
                        
                        
                        
                        
                          


Read blog post 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Sken.ai
                  
                    
                      
                      
                      
                        
                          Code Analysis
                        
                      
                    
                      
                      
                      
                        
                          Security
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Sken.ai
                      Code Analysis
                      
                        Sken.ai is the only application security testing product that offers comprehensive testing for DevOps without the need for security expertise.

                      
                      
                        
                          
                            Visit Sken.ai website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Slack
                  
                    
                      
                      
                      
                        
                          Notifications
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Slack
                      Notifications
                      
                        Slack is a collaboration hub, where the right people and the right information come together, helping everyone get work done.

                      
                      
                        
                          
                            Visit Slack website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Snyk
                  
                    
                      
                      
                      
                        
                          Security
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Snyk
                      Security
                      
                        Snyk is a developer-first security solution platform that finds and fixes vulnerabilities and license violations in open source dependencies and containers.

                      
                      
                        
                          
                            Visit Snyk website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


View documentation 

                        
                      
                        
                        
                        
                        
                          


View webinar 

                        
                      
                        
                        
                        
                        
                          


Read blog post 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  SonarSource
                  
                    
                      
                      
                      
                        
                          Security
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      SonarSource
                      Security
                      
                        SonarSource provides open source and commercial products that help developers and organizations manage the quality and security of their code.

                      
                      
                        
                          
                            Visit SonarSource website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Sonatype
                  
                    
                      
                      
                      
                        
                          Artifacts / Registry
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Sonatype
                      Artifacts / Registry
                      
                        Innovate faster while mitigating the security risks inherent in open source. Sonatype’s Nexus platform combines in-depth component intelligence with real-time remediation guidance to automate and scale open source governance across every stage of the modern DevOps pipeline.

                      
                      
                        
                          
                            Visit Sonatype website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  SOOS
                  
                    
                      
                      
                      
                        
                          Security
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      SOOS
                      Security
                      
                        SOOS makes easy-to-use, affordable developer security tools to monitor and fix open source vulnerability and license issues. Stop shopping and start scanning with SOOS today.

                      
                      
                        
                          
                            Visit SOOS website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Spectral
                  
                    
                      
                      
                      
                        
                          Security
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Spectral
                      Security
                      
                        Spectral empowers companies and developers to secure and ship software freely on any platform, through real-time detection and mitigation of security flaws.

                      
                      
                        
                          
                            Visit Spectral website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Spinnaker
                  
                    
                      
                      
                      
                        
                          Deployment
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Spinnaker
                      Deployment
                      
                        Spinnaker is an open source, multi-cloud continuous delivery platform for releasing software changes with high velocity and confidence.

                      
                      
                        
                          
                            Visit Spinnaker website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Squadcast
                  
                    
                      
                      
                      
                        
                          Cloud Platform
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Squadcast
                      Cloud Platform
                      
                        Squadcast is cloud-based software designed around Site Reliability Engineering (SRE) practices that provides incident management and on-call scheduling capabilities.

                      
                      
                        
                          
                            Visit Squadcast website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View blog
                        
                        
                      
                        
                        
                        
                        
                          


View documentation 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  StackHawk
                  
                    
                      
                      
                      
                        
                          Security
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      StackHawk
                      Security
                      
                        StackHawk makes it simple for developers to find, triage, and fix application security bugs. Scan your app for AppSec bugs, triage and fix with docs, and automate to prevent bugs from hitting prod.

                      
                      
                        
                          
                            Visit StackHawk website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


View documentation 

                        
                      
                        
                        
                        
                        
                          


Read blog post 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  StackPulse
                  
                    
                      
                      
                      
                        
                          Security
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      StackPulse
                      Security
                      
                        StackPulse is a reliability platform for developers, SREs and on-call engineers, helping teams remediate production incidents faster by turning incident response workflows into code-based playbooks.

                      
                      
                        
                          
                            Visit StackPulse website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


View documentation 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Styra
                  
                    
                      
                      
                      
                        
                          Kubernetes
                        
                      
                    
                      
                      
                      
                        
                          Security
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Styra
                      Kubernetes
                      
                        Styra enables enterprises to define, enforce, and validate security across their Kubernetes environments. Styra’s simple graphical library of customizable policies lets Security and DevOps teams mitigate risks, reduce human error, and accelerate development.

                      
                      
                        
                          
                            Visit Styra website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


View documentation 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Sumo Logic
                  
                    
                      
                      
                      
                        
                          Reporting
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Sumo Logic
                      Reporting
                      
                        Sumo Logic is a cloud-based data analytics company that provides real-time metrics across the application lifecycle and stack.

                      
                      
                        
                          
                            Visit Sumo Logic website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Sysdig
                  
                    
                      
                      
                      
                        
                          Containers
                        
                      
                    
                      
                      
                      
                        
                          Security
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Sysdig
                      Containers
                      
                        Sysdig is a SaaS platform built on an open source stack that includes Falco and sysdig OSS, the open standards for runtime threat detection and response.

                      
                      
                        
                          
                            Visit Sysdig website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Terraform
                  
                    
                      
                      
                      
                        
                          Infra Automation
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Terraform
                      Infra Automation
                      
                        HashiCorp enables organizations to adopt consistent workflows to provision, secure, connect, and run any infrastructure for any app. Their open source tools are downloaded tens of millions of times each year.

                      
                      
                        
                          
                            Visit Terraform website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


View documentation 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  TestFairy
                  
                    
                      
                      
                      
                        
                          Testing
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      TestFairy
                      Testing
                      
                        TestFairy is a mobile testing platform helping teams streamline their mobile development process. TestFairy provides developers with an all-in-one platform that handles app distribution, video recording, and bug and crash reporting on private clouds or on-premises.

                      
                      
                        
                          
                            Visit TestFairy website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


View documentation 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Testim
                  
                    
                      
                      
                      
                        
                          Testing
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Testim
                      Testing
                      
                        Testim uses artificial intelligence to speed-up the authoring, execution, and maintenance of web and mobile automated tests. Kick your runs off instantly through your CI/CD pipeline.

                      
                      
                        
                          
                            Visit Testim website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Testlio
                  
                    
                      
                      
                      
                        
                          Testing
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Testlio
                      Testing
                      
                        Testlio is the originator of networked testing. A combination of platform, freelancers, and services enable digital product companies to deliver great customer experiences, quickly.

                      
                      
                        
                          
                            Visit Testlio website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Thundra
                  
                    
                      
                      
                      
                        
                          Monitoring
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Thundra
                      Monitoring
                      
                        Thundra is a software company for developers who build, debug, test, and deliver modern microservices on cloud. Thundra provides a shift-left observability approach for developers.

                      
                      
                        
                          
                            Visit Thundra website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Twilio
                  
                    
                      
                      
                      
                        
                          Notifications
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Twilio
                      Notifications
                      
                        Twilio serves as the building blocks to add messaging, voice, and video in your web and mobile applications.

                      
                      
                        
                          
                            Visit Twilio website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Unmock
                  
                    
                      
                      
                      
                        
                          Testing
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Unmock
                      Testing
                      
                        Unmock's goal is to create a semantically and functionally accurate mock of the internet. Developers can test their code without calling real APIs from their CI/CD server.

                      
                      
                        
                          
                            Visit Unmock website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


View documentation 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  UPX
                  
                    
                      
                      
                      
                        
                          Build
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      UPX
                      Build
                      
                        UPX is a free, portable, extendable, high-performance executable packer for several executable formats.

                      
                      
                        
                          
                            Visit UPX website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  VMware Code Stream
                  
                    
                      
                      
                      
                        
                          Deployment
                        
                      
                    
                      
                      
                      
                        
                          Kubernetes
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      VMware Code Stream
                      Deployment
                      
                        VMware Code Stream provides release automation and continuous delivery to enable frequent, reliable releases of application and IT code.

                      
                      
                        
                          
                            Visit VMware Code Stream website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Wallarm
                  
                    
                      
                      
                      
                        
                          Security
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Wallarm
                      Security
                      
                        Wallarm is an application security platform that provides security coverage for APIs using a testing engine that is built to automate security in CI/CD pipelines.

                      
                      
                        
                          
                            Visit Wallarm website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Waypoint
                  
                    
                      
                      
                      
                        
                          Deployment
                        
                      
                    
                      
                      
                      
                        
                          Build
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Waypoint
                      Deployment
                      
                        HashiCorp enables organizations to adopt consistent workflows to provision, secure, connect, and run infrastructure for any app. Their open source tools are downloaded tens of millions of times each year.

                      
                      
                        
                          
                            Visit Waypoint website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


View documentation 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  WhiteSource
                  
                    
                      
                      
                      
                        
                          Security
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      WhiteSource
                      Security
                      
                        WhiteSource helps teams harness the power of open source without compromising on security or agility. Integrating with the SDLC, it continuously monitors and issues alerts in real-time on problematic components.

                      
                      
                        
                          
                            Visit WhiteSource website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View scan orb
                        
                        
                      
                        
                        
                        
                        
                          


View vulnerability orb 

                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  Windows
                  
                    
                      
                      
                      
                        
                          Cloud Platform
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      Windows
                      Cloud Platform
                      
                        Windows is an operating system that exists under Microsoft and is designed to help customers thrive in today’s mobile-first and cloud-first world.

                      
                      
                        
                          
                            Visit Windows website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                    
                  
                
              
            
          
            
            
            
            
            
            
              
                
                
                  xMatters
                  
                    
                      
                      
                      
                        
                          Notifications
                        
                      
                    
                    
                  
                
              
            

            
              close
              
                
                  
                    
                      
close
                    
                    
                      
                      xMatters
                      Notifications
                      
                        xMatters is a digital service availability platform that helps enterprises prevent, manage, and resolve IT incidents before they can become business problems. xMatters automates key processes through integrations.

                      
                      
                        
                          
                            Visit xMatters website
                          
                        
                      
                    
                    
                      
                        
                        
                        
                        
                        
                          View orb
                        
                        
                      
                        
                        
                        
                        
                          


View documentation 

                        
                      
                        
                        
                        
                        
                          


View webinar 

                        
                      
                    
                  
                
              
            
          
        
        
          
            
              Don’t see a partner you need?
              
              Request a new integration.
            
          
          
            
            


Submit a request\n\n\n\nExamples and guides overview2 weeks ago1 min readCloudServer v4+On This PageLanguage guidesPlatform guidesNext steps   This page provides a collection of examples to help you learn how to build, test, and deploy applications written in the most common programming languages, frameworks, and platforms on CircleCI.   If you are new to CircleCI, we recommend going through our  Quickstart Guide for getting your first successful pipeline.   For basic examples of adding pipeline jobs in a specific execution environment such as a Docker container or Linux VM, review our  Hello World document.     Language guides   To get a project up and running on CircleCI, see the following quickstart guides:      Configure a Node.js application on CircleCI    Configure a Python application on CircleCI    Configure a Go application on CircleCI     We have created demo applications in various languages so you can learn by example. Each language listed below has an associated guide and public repository on GitHub.  Language GuideFrameworkGitHub Repo Name Configuring a Node.js Application on CircleCI^Vue.js sample-javascript-cfd Configuring a Python Application on CircleCI^Flask sample-python-cfd JavaSpring Boot sample-java-cfd C#/.NETASP.NET Core sample-dotnet-cfd Mono repo - Python backend and Node.js frontendFlask, Vue.js sample-monorepo-cfd    Platform guides   Use the tutorial associated with your platform to learn about the customization that is possible in a  .circleci/config.yml.  Platform guideDescription macOS Project TutorialSet up a macOS project in CircleCI. Testing iOSSet up and test iOS projects in CircleCI. Windows Project TutorialFull example of setting up a .NET project in CircleCI.    Next steps     Read the  Sample config.yml Files document for examples of using concurrent workflows, sequential workflows, fan-in/fan-out workflows, and building Linux and iOS in one configuration file.   Refer to the  Configuration reference page for detailed syntax.     Suggest an edit to this pageMake a contribution Learn how to contributeStill need help? Ask the CircleCI community Join the research community Visit our Support site\n\nExamples and guides overview2 weeks ago1 min readCloudServer v4+On This PageLanguage guidesPlatform guidesNext steps   This page provides a collection of examples to help you learn how to build, test, and deploy applications written in the most common programming languages, frameworks, and platforms on CircleCI.   If you are new to CircleCI, we recommend going through our  Quickstart Guide for getting your first successful pipeline.   For basic examples of adding pipeline jobs in a specific execution environment such as a Docker container or Linux VM, review our  Hello World document.     Language guides   To get a project up and running on CircleCI, see the following quickstart guides:      Configure a Node.js application on CircleCI    Configure a Python application on CircleCI    Configure a Go application on CircleCI     We have created demo applications in various languages so you can learn by example. Each language listed below has an associated guide and public repository on GitHub.  Language GuideFrameworkGitHub Repo Name Configuring a Node.js Application on CircleCI^Vue.js sample-javascript-cfd Configuring a Python Application on CircleCI^Flask sample-python-cfd JavaSpring Boot sample-java-cfd C#/.NETASP.NET Core sample-dotnet-cfd Mono repo - Python backend and Node.js frontendFlask, Vue.js sample-monorepo-cfd    Platform guides   Use the tutorial associated with your platform to learn about the customization that is possible in a  .circleci/config.yml.  Platform guideDescription macOS Project TutorialSet up a macOS project in CircleCI. Testing iOSSet up and test iOS projects in CircleCI. Windows Project TutorialFull example of setting up a .NET project in CircleCI.    Next steps     Read the  Sample config.yml Files document for examples of using concurrent workflows, sequential workflows, fan-in/fan-out workflows, and building Linux and iOS in one configuration file.   Refer to the  Configuration reference page for detailed syntax.     Suggest an edit to this pageMake a contribution Learn how to contributeStill need help? Ask the CircleCI community Join the research community Visit our Support site DocsTerms of UsePrivacy PolicyCookie PolicySecurity© 2025 Circle Internet Services, Inc., All Rights Reserved.\n\n\n\nJoin the CircleCI research panel
      
        
          The CircleCI research team is putting together a pool of people to talk shop, critique prototypes, and help us make your job quicker, safer, and painless.

Want to be part of this influential group?

        
      
      
        

  
    
    
      
        
        Join the panel
      
    
  

      
    
    
      
        
          

        

        
          





          
        
      
    
  





  
  
    
      
        
          
          
            Here are the details
            
          
        
      
      
        
          
  
  
    
    Sign up
    Anyone can sign up, even if you don’t currently use CircleCI.

  
  

        
          
  
  
    
    After you join
    We’ll send you an email when there’s something for you to weigh-in on.

  
  

        
          
  
  
    
    Always optional
    Responding is always optional, so how you participate is up to you.

  
  

        
          
  
  
    
    Opt-out or in
    Opt-out and opt back in at any time - we’re always happy to hear from you.

  
  

        
      
    
  

























  
  
    
      

    
  






  
    
      Frequently asked questions
      

    
    
      
        
        
        
        
        
        
          How do I opt-in?
          Click on the sign up button above to fill out a form that will help us determine when a project is a good fit for you. That way, only the most relevant invitations land in your inbox.

        
      
        
        
        
        
        
        
          What will I do? What types of studies? How long will it take?
          We offer all kinds of research activities. From prototype explorations to quick surveys, to hour-long deep dives on the problems you’re solving in the wild. When we send an invite, we’ll always tell you what to expect.

        
      
        
        
        
        
        
        
          What type of people are you looking for?
          From individual contributors to team leads and CTOs across every industry if your work is directly related to the software development lifecycle, we want to talk to you.

        
      
        
        
        
        
        
        
          Is my information confidential?
          Absolutely. Any information shared here is used to match you with studies, invite you to take part in them, and nothing else.

        
      
        
        
        
        
        
        
          How old do I need to be?
          You must be 18 years or older.\n\nJoin the CircleCI research panel
      
        
          The CircleCI research team is putting together a pool of people to talk shop, critique prototypes, and help us make your job quicker, safer, and painless.

Want to be part of this influential group?

        
      
      
        

  
    
    
      
        
        Join the panel
      
    
  

      
    
    
      
        
          

        

        
          





          
        
      
    
  





  
  
    
      
        
          
          
            Here are the details
            
          
        
      
      
        
          
  
  
    
    Sign up
    Anyone can sign up, even if you don’t currently use CircleCI.

  
  

        
          
  
  
    
    After you join
    We’ll send you an email when there’s something for you to weigh-in on.

  
  

        
          
  
  
    
    Always optional
    Responding is always optional, so how you participate is up to you.

  
  

        
          
  
  
    
    Opt-out or in
    Opt-out and opt back in at any time - we’re always happy to hear from you.

  
  

        
      
    
  

























  
  
    
      

    
  






  
    
      Frequently asked questions
      

    
    
      
        
        
        
        
        
        
          How do I opt-in?
          Click on the sign up button above to fill out a form that will help us determine when a project is a good fit for you. That way, only the most relevant invitations land in your inbox.

        
      
        
        
        
        
        
        
          What will I do? What types of studies? How long will it take?
          We offer all kinds of research activities. From prototype explorations to quick surveys, to hour-long deep dives on the problems you’re solving in the wild. When we send an invite, we’ll always tell you what to expect.

        
      
        
        
        
        
        
        
          What type of people are you looking for?
          From individual contributors to team leads and CTOs across every industry if your work is directly related to the software development lifecycle, we want to talk to you.

        
      
        
        
        
        
        
        
          Is my information confidential?
          Absolutely. Any information shared here is used to match you with studies, invite you to take part in them, and nothing else.

        
      
        
        
        
        
        
        
          How old do I need to be?
          You must be 18 years or older.\n\n\n\nWebsite Terms of Use
      
      
          Last Updated:
          
            July 30, 2024
          
      
      
        
These Website Terms of Use (the “Terms of Use”) apply to the CircleCI web site located at  https://circleci.com/, and all subdomains of and associated sites linked to or by https://circleci.com/ by Circle Internet Services, Inc. (“CircleCI”), its subsidiaries and/or affiliates, including any CircleCI sites around the world (collectively, the “Site”). The Site is owned and operated by CircleCI. Please read these Terms of Use carefully before using the Site. By accessing or using the Site, or any of the content on the Site, you represent that you have read, understand, and agree to be legally bound by these Terms of Use. If you do not accept these Terms of Use, do not use the Site or any of the CircleCI Content (defined below).

CircleCI reserves the right, at its sole discretion, to change, modify, add or remove portions of these Terms of Use at any time. It is your responsibility to check these Terms of Use periodically for changes. Your continued use of the Site following the posting of any changes will mean that you accept and agree to the changes.

You represent to CircleCI that you are lawfully able to enter into contracts (e.g., you are not a minor). If you are accessing the Site for an entity, such as the company you work for, you represent that you have authority to bind that entity to these Terms of Use, and you agree that “you” and “your” as used in these Terms of Use includes both you personally and the entity you represent.

Other Terms and Conditions
These Terms of Use do not govern the use of our continuous integration/continuous deployment software-as-a-service offering or any other software, including downloadable software, and related technologies that may be made available by us to interoperate with the foregoing (collectively, the “Services”). If you are accessing or using the Services – even if you are doing so through a free trial or evaluation – then you are subject to CircleCI’s Software as a Service Agreement (currently available at https://circleci.com/legal/terms-of-service/) or such other written contract as may be separately agreed and entered into between you and CircleCI.

Additional terms and conditions may apply to specific portions or features of the Site, including contests, promotions or other similar features, and all such terms are made a part of these Terms of Use by this reference. You agree to abide by such other terms and conditions, including where applicable representing that you are of sufficient legal age to use or participate in such service or feature. If there is a conflict between these Terms of Use and the terms posted for or applicable to a specific portion of the Site or for any service offered on or through the Site, the latter terms shall control with respect to your use of that portion of the Site or the specific service.

CircleCI’s obligations, if any, with regard to its products and services are governed solely by the agreements pursuant to which they are provided, and nothing on this Site should be construed to alter such agreements.

CircleCI may make changes to any products or services offered on the Site, or to the applicable prices for any such products or services, at any time, without notice. The materials on the Site with respect to products and services may be out of date, and CircleCI makes no commitment to update the materials on the Site with respect to such products and services.

The following terms also govern and apply to your use of the Site, and they are incorporated herein by this reference:


  Acceptable Use Policy,
  Cookie Policy,
  Copyright Infringement Notice and Takedown Policy,
  Privacy Policy, and
  Trademark Usage Guidelines.


The foregoing terms may be changed from time to time and such changes are effective immediately upon their posting on the Site.

CircleCI Content

All text, graphics, user interfaces, visual interfaces, images, trademarks, logos, sounds, music, artwork and computer code (collectively, “CircleCI Content”), including but not limited to the design, structure, selection, coordination, expression, “look and feel” and arrangement of such CircleCI Content, contained on the Site is owned, controlled or licensed by or to CircleCI, and may be protected by trade dress, copyright, patent and trademark laws, and various other intellectual property rights and unfair competition laws.

CircleCI hereby grants to you a limited, revocable, non-sublicensable license to access, display and perform the CircleCI Content (excluding any computer code) solely for your personal, non-commercial use and solely as necessary to access and use the Site. Except as expressly permitted by CircleCI in these Terms of Use or on the Site, you may not copy, download, stream, capture, reproduce, duplicate, archive, upload, modify, translate, create derivative works based upon, publish, broadcast, transmit, retransmit, distribute, perform, display, sell or otherwise use or transfer any CircleCI Content. You may not, either directly or through the use of any device, software, online resource or other means, remove, alter, bypass, avoid, interfere with or circumvent any copyright, trademark or other proprietary notice on the Site or CircleCI Content or any digital rights management mechanism, device, or other content protection or access control measure associated with the Site or CircleCI Content.

Third-Party Services

The Site may make available, or third parties may provide, links to other websites, applications, resources, advertisements, content or other products or services created, hosted or made available by third parties (“Third-Party Service(s)”), and such third parties may use other third parties to provide portions of the Third-Party Service to you, such as technology, development or payment services. When you access or use a Third-Party Service, you are interacting with the applicable third party, not with CircleCI, and you do so at your own risk. CircleCI is not responsible for, and makes no warranties, express or implied, as to, the Third-Party Services or the providers of such Third-Party Services (including without limitation the accuracy or completeness of the information provided by such Third-Party Service or the privacy practices of any third party). Inclusion of any Third-Party Service or a link thereto on the Site does not imply approval or endorsement of such Third-Party Service. CircleCI is not responsible or liable for the content or practices of any Third-Party Service or third party, even if such Third-Party Service links to, or is linked by, the Site.

Privacy Policy

CircleCI’s Privacy Policy applies to your use of this Site, and its terms are made a part of these Terms of Use by this reference. To view CircleCI’s Privacy Policy, click here. Additionally, by using the Site, you acknowledge and agree that Internet transmissions are never completely private or secure. You understand that any message or information you send to the Site may be read or intercepted by others, even if there is a special notice that a particular transmission (for example, credit card information) is encrypted.

Your Content

By posting, displaying, publishing or making available for download or use any content on the Site (other than personal information that is subject to the Privacy Policy), you hereby grant CircleCI a perpetual, worldwide, nonexclusive, irrevocable, royalty-free, sublicensable (through multiple tiers) license to perform, display, reproduce, prepare derivative works from, distribute, sell, sublicense, transfer and otherwise use without restriction all or any part of such content.

Compliance with Laws

You represent that, in agreeing to, and performing under, these Terms of Use, you are not violating, and will not violate, any governmental laws, rules, regulations or orders that are applicable to your use of the Site (“Applicable Laws”). Without limiting the foregoing, you represent that, in connection with your performance under these Terms of Use, you shall: (a) comply with Applicable Laws relating to anti-bribery and anti-corruption, which may include the US Foreign Corrupt Practices Act of 1977 and the UK Bribery Act 2010; (b) comply with Applicable Laws administered by the U.S. Commerce Bureau of Industry and Security, U.S. Treasury Office of Foreign Assets Control or other governmental entity imposing export controls and trade sanctions (collectively, “Export Laws”); and (c) not directly or indirectly export, re-export or otherwise deliver any CircleCI software, content or services in violation of any Export Laws, or broker, finance or otherwise facilitate any transaction in violation of any Export Laws. You represent that you are not prohibited from receiving software, CircleCI Content, or other services pursuant to these Terms of Use under Applicable Laws, including Export Laws.

Void Where Prohibited

Although the Site is accessible worldwide, not all features, products or services discussed, referenced, provided or offered through or on the Site are available to all persons or in all geographic locations, or appropriate or available for use outside the United States. CircleCI reserves the right to limit, in its sole discretion, the provision and quantity of any feature, product or service to any person or geographic area. Any offer for any feature, product or service made on the Site is void where prohibited. If you choose to access the Site from outside the United States, you do so on your own initiative and you are solely responsible for complying with applicable local laws.

Indemnity

You agree to defend, indemnify and hold harmless CircleCI, its affiliates and their respective employees, contractors, agents, officers and directors from and against any and all claims, damages, obligations, losses, liabilities, costs, debt or expenses (including without limitation attorneys’ fees) arising out of or related to any claim, suit, action or proceeding by a third party arising out of or relating to (i) your use of the Site, (ii) your breach of these Terms of Use (including any CircleCI policy referenced in these Terms of Use), (iii) your violation of any law, or (iv) any content that you post, upload or cause to interface with the Site, or otherwise transfer, process, use or store in connection with the Site.

Disclaimers

THE SITE AND ALL CONTENT AND OTHER ITEMS MADE AVAILABLE BY CIRCLECI ARE PROVIDED ON AN “AS IS” AND “AS AVAILABLE” BASIS WITHOUT WARRANTIES OF ANY KIND, WHETHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, INCLUDING ANY IMPLIED WARRANTY OF TITLE, MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, OR NON-INFRINGEMENT, TO THE MAXIMUM EXTENT PERMITTED BY APPLICABLE LAW. CIRCLECI ASSUMES NO LIABILITY OR RESPONSIBILITY FOR ANY (i) ERRORS, MISTAKES OR INACCURACIES OF DATA OR INFORMATION POSTED, DISPLAYED, PUBLISHED OR MADE AVAILABLE FOR DOWNLOAD OR USE ON THE SITE, (ii) PERSONAL INJURY OR PROPERTY DAMAGE, OF ANY NATURE WHATSOEVER, RESULTING FROM USE OF THE SITE, (iii) ANY INTERRUPTION OR CESSATION OF TRANSMISSION TO OR FROM THE SITE, OR (iv) THE DEFAMATORY, OFFENSIVE OR ILLEGAL CONDUCT OF ANY THIRD PARTY NOT UNDER CIRCLECI’S CONTROL.

Limitation of Liability

TO THE FULLEST EXTENT PERMITTED BY APPLICABLE LAW: (a) IN NO EVENT SHALL CIRCLECI, ITS AFFILIATES OR THEIR RESPECTIVE EMPLOYEES, CONTRACTORS, AGENTS, OFFICERS OR DIRECTORS BE LIABLE FOR ANY INDIRECT, PUNITIVE, INCIDENTAL, SPECIAL, CONSEQUENTIAL OR EXEMPLARY DAMAGES, INCLUDING WITHOUT LIMITATION DAMAGES FOR BUSINESS INTERRUPTION, LOSS OF PROFITS, GOODWILL, USE, DATA OR OTHER INTANGIBLE LOSSES ARISING OUT OF OR RELATING TO THE SITE OR YOUR USE OF THE SITE; AND (b) IN NO EVENT SHALL CIRCLECI’S CUMULATIVE AND AGGREGATE LIABILITY UNDER THESE TERMS OF USE EXCEED ONE HUNDRED U.S. DOLLARS. THE EXCLUSIONS AND LIMITATIONS IN THIS SECTION APPLY WHETHER THE ALLEGED LIABILITY IS BASED ON CONTRACT, TORT, NEGLIGENCE, STRICT LIABILITY OR ANY OTHER BASIS, EVEN IF YOU HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. SOME JURISDICTIONS DO NOT ALLOW LIMITATIONS OF LIABILITY, SO THE FOREGOING LIMITATION MAY NOT APPLY TO YOU.

Responsibility for End Users

You are responsible for violations of these Terms of Use by anyone using the Site with your permission or using your account on an unauthorized basis. Your use of the Site to assist another person in an activity that would violate these Terms of Use if performed by you is a violation of these Terms of Use. These Terms of Use apply to anyone accessing or using the Site; however, each provision in these Terms of Use shall be interpreted to include, and apply to, any action directly or indirectly taken, authorized, facilitated, promoted, encouraged or permitted by a user of the Site, even if such person did not themselves violate the provision.

Employment Opportunities

CircleCI may, from time to time, post employment opportunities on the Site and/or invite users to submit applications for employment to CircleCI. If you choose to submit your name, contact information, resume and/or other personal information to CircleCI in response to such employment listings, you are authorizing CircleCI to use this information for all lawful and legitimate hiring, employment and other business purposes. CircleCI also reserves the right, at its discretion, to forward such information to CircleCI‘s subsidiaries and affiliates for their legitimate business purposes. Nothing in these Terms of Use or contained on the Site will constitute a promise by CircleCI to review any such information, or to contact, interview or employ any individual who submits such information.

Digital Millennium Copyright Act

CircleCI respects the rights of copyright holders and abides by the federal Digital Millennium Copyright Act and similar regulations in other jurisdictions by responding to written notifications of alleged infringement by copyright holders. To provide a notification of alleged copyright infringement, please follow the procedures set forth in our Copyright Infringement Notice and Takedown Policy.

U.S. Government Rights

The Site is provided to the U.S. Government as “commercial items,” “commercial computer software,” “commercial computer software documentation,” and “technical data” with the same rights and restrictions generally applicable to the Site. If you are using the Site on behalf of the U.S. Government and these terms fail to meet the U.S. Government’s needs or are inconsistent in any respect with federal law, you must immediately discontinue use of the Site. The terms listed above are defined in the Federal Acquisition Regulation and the Defense Federal Acquisition Regulation Supplement.

Violation of These Terms of Use

CircleCI may disclose any information we have about you (including your identity) if we determine that such disclosure is necessary in connection with any investigation or complaint regarding your use of the Site, or to identify, contact or bring legal action against someone who may be causing injury to or interference with (either intentionally or unintentionally) CircleCI’s rights or property, or the rights or property of visitors to or users of the Site, including CircleCI’s customers. CircleCI reserves the right at all times to disclose any information that CircleCI deems necessary to comply with any applicable law, regulation, legal process or governmental request. CircleCI also may disclose your information when CircleCI determines that applicable law requires or permits such disclosure, including exchanging information with other companies and organizations for fraud protection purposes.

You acknowledge and agree that CircleCI may preserve any transmittal or communication by you with CircleCI, and may also disclose such data if required to do so by law or CircleCI determines that such preservation or disclosure is reasonably necessary to (1) comply with legal process, (2) enforce these Terms of Use, (3) respond to claims that any such data violates the rights of others, or (4) protect the rights, property or personal safety of CircleCI, its employees, users of or visitors to the Site, and the public.

You agree that CircleCI may, in its sole discretion and without prior notice, terminate your access to the Site and/or block your future access to the Site, for cause, for reasons including (but is not limited to) (1) requests by law enforcement or other government agencies, (2) a request by you (self-initiated account deletions), (3) discontinuance or material modification of the Site or any service offered on or through the Site, (4) unexpected technical issues or problems, or (5) our determination that you have violated these Terms of Use or other agreements or guidelines which may be associated with your use of the Site.

If CircleCI does take any legal action against you as a result of your violation of these Terms of Use, CircleCI will be entitled to recover from you, and you agree to pay, all reasonable attorneys’ fees and costs of such action, in addition to any other relief granted to CircleCI. You agree that CircleCI will not be liable to you or to any third party for termination of your access to the Site as a result of any violation of these Terms of Use.  You also agree that any violation by you of these Terms of Use will constitute an unlawful and unfair business practice, and will cause irreparable harm to CircleCI, for which monetary damages would be inadequate, and you consent to CircleCI seeking any injunctive or equitable relief that CircleCI deems necessary or appropriate in such circumstances. These remedies are in addition to any other remedies CircleCI may have at law or in equity.

Electronic Communications

When you visit the Site or send emails to CircleCI, you are communicating with CircleCI electronically; and you consent to receive communications from CircleCI electronically. CircleCI will communicate with you by email or by posting notices on the Site. You agree that all agreements, notices, disclosures and other communications that CircleCI provides to you electronically satisfy any legal requirement that such communications be in writing.

Governing Law

You agree that all matters relating to your access to or use of the Site, including all disputes, will be governed by the laws of the United States and by the laws of the State of California without regard to its conflicts of laws provisions. You agree to the personal jurisdiction by and venue in the state and federal courts in San Francisco County, California, and waive any objection to such jurisdiction or venue.

Miscellaneous

These Terms of Use constitute the complete and exclusive statement of the agreement between you and CircleCI and supersede all proposals, oral or written, and all other communications between you and CircleCI relating to the subject matter of these Terms of Use. In the event any information posted on the Site from time to time conflicts with any provision of these Terms of Use, the applicable provision of these Terms of Use shall control. Any terms and conditions of any other instrument issued by you in connection with these Terms of Use which are in addition to, inconsistent with or different from these Terms of Use shall be of no force or effect. These Terms of Use do not, and shall not be construed to, create any partnership, joint venture, employer-employee, agency or franchisor-franchisee relationship between you and CircleCI. You may not assign, transfer or sublicense all or any of your rights or obligations under these Terms of Use without CircleCI’s express prior written consent. CircleCI may assign, transfer or sublicense all or any of CircleCI’s rights or obligations under these Terms of Use without restriction. The failure of CircleCI to exercise or enforce any condition, term or provision of these Terms of Use will not operate as a waiver of such condition, term or provision. Any waiver by CircleCI of any condition, term or provision of these Terms of Use shall not be construed as a waiver of any other condition, term or provision. If any provision of these Terms of Use is held invalid or unenforceable, the remainder of these Terms of Use shall continue in full force and effect. You agree that a printed version of these Terms of Use and of any notice given in electronic form shall be admissible in judicial or administrative proceedings based upon or relating to these Terms of Use to the same extent and subject to the same conditions as other business documents and records originally generated and maintained in printed form. CircleCI will not be responsible for failures to fulfill any obligations due to causes beyond its control. Non-English translations of these Terms of Use are provided for convenience only. In the event of any ambiguity or conflict between translations, the English version is authoritative and controls.

Contact Us

Please contact CircleCI with any questions regarding these Terms of Use.\n\nLegal
  







  
    
      
        
        
        
          
          
            
              
                Software as a Service Agreement
              
            
            
          
        
          
          
            
              
                Software License Agreement
              
            
            
          
        
          
          
            
              
                AI Functionality Terms
              
            
            
          
        
          
          
            
              
                Code Sharing Terms of Service
              
            
            
          
        
          
          
            
              
                Self-Hosted Applications Terms
              
            
            
          
        
          
          
            
              
                Acceptable Use Policy
              
            
            
          
        
          
          
            
              
                Cookie Policy
              
            
            
          
        
          
          
            
              
                Privacy Policy
              
            
            
          
        
          
          
            
              
                CircleCI’s Commitment to Data Privacy
              
            
            
          
        
          
          
            
              
                 Trademark Usage Guidelines
              
            
            
          
        
          
          
            
              
                Copyright Infringement Notice and Takedown Policy
              
            
            
          
        
          
          
            
              
                Website Terms of Use
              
            
            
              
              


  Other Terms and Conditions
  CircleCI Content
  Third-Party Services
  Privacy Policy
  Your Content
  Compliance with Laws
  Void Where Prohibited
  Indemnity
  Disclaimers
  Limitation of Liability
  Responsibility for End Users
  Employment Opportunities
  Digital Millennium Copyright Act
  U.S. Government Rights
  Violation of These Terms of Use
  Electronic Communications
  Governing Law
  Miscellaneous
  Contact Us




            
          
        
      
    
  
  
    
      
        Website Terms of Use
      
      
          Last Updated:
          
            July 30, 2024
          
      
      
        
These Website Terms of Use (the “Terms of Use”) apply to the CircleCI web site located at  https://circleci.com/, and all subdomains of and associated sites linked to or by https://circleci.com/ by Circle Internet Services, Inc. (“CircleCI”), its subsidiaries and/or affiliates, including any CircleCI sites around the world (collectively, the “Site”). The Site is owned and operated by CircleCI. Please read these Terms of Use carefully before using the Site. By accessing or using the Site, or any of the content on the Site, you represent that you have read, understand, and agree to be legally bound by these Terms of Use. If you do not accept these Terms of Use, do not use the Site or any of the CircleCI Content (defined below).

CircleCI reserves the right, at its sole discretion, to change, modify, add or remove portions of these Terms of Use at any time. It is your responsibility to check these Terms of Use periodically for changes. Your continued use of the Site following the posting of any changes will mean that you accept and agree to the changes.

You represent to CircleCI that you are lawfully able to enter into contracts (e.g., you are not a minor). If you are accessing the Site for an entity, such as the company you work for, you represent that you have authority to bind that entity to these Terms of Use, and you agree that “you” and “your” as used in these Terms of Use includes both you personally and the entity you represent.

Other Terms and Conditions
These Terms of Use do not govern the use of our continuous integration/continuous deployment software-as-a-service offering or any other software, including downloadable software, and related technologies that may be made available by us to interoperate with the foregoing (collectively, the “Services”). If you are accessing or using the Services – even if you are doing so through a free trial or evaluation – then you are subject to CircleCI’s Software as a Service Agreement (currently available at https://circleci.com/legal/terms-of-service/) or such other written contract as may be separately agreed and entered into between you and CircleCI.

Additional terms and conditions may apply to specific portions or features of the Site, including contests, promotions or other similar features, and all such terms are made a part of these Terms of Use by this reference. You agree to abide by such other terms and conditions, including where applicable representing that you are of sufficient legal age to use or participate in such service or feature. If there is a conflict between these Terms of Use and the terms posted for or applicable to a specific portion of the Site or for any service offered on or through the Site, the latter terms shall control with respect to your use of that portion of the Site or the specific service.

CircleCI’s obligations, if any, with regard to its products and services are governed solely by the agreements pursuant to which they are provided, and nothing on this Site should be construed to alter such agreements.

CircleCI may make changes to any products or services offered on the Site, or to the applicable prices for any such products or services, at any time, without notice. The materials on the Site with respect to products and services may be out of date, and CircleCI makes no commitment to update the materials on the Site with respect to such products and services.

The following terms also govern and apply to your use of the Site, and they are incorporated herein by this reference:


  Acceptable Use Policy,
  Cookie Policy,
  Copyright Infringement Notice and Takedown Policy,
  Privacy Policy, and
  Trademark Usage Guidelines.


The foregoing terms may be changed from time to time and such changes are effective immediately upon their posting on the Site.

CircleCI Content

All text, graphics, user interfaces, visual interfaces, images, trademarks, logos, sounds, music, artwork and computer code (collectively, “CircleCI Content”), including but not limited to the design, structure, selection, coordination, expression, “look and feel” and arrangement of such CircleCI Content, contained on the Site is owned, controlled or licensed by or to CircleCI, and may be protected by trade dress, copyright, patent and trademark laws, and various other intellectual property rights and unfair competition laws.

CircleCI hereby grants to you a limited, revocable, non-sublicensable license to access, display and perform the CircleCI Content (excluding any computer code) solely for your personal, non-commercial use and solely as necessary to access and use the Site. Except as expressly permitted by CircleCI in these Terms of Use or on the Site, you may not copy, download, stream, capture, reproduce, duplicate, archive, upload, modify, translate, create derivative works based upon, publish, broadcast, transmit, retransmit, distribute, perform, display, sell or otherwise use or transfer any CircleCI Content. You may not, either directly or through the use of any device, software, online resource or other means, remove, alter, bypass, avoid, interfere with or circumvent any copyright, trademark or other proprietary notice on the Site or CircleCI Content or any digital rights management mechanism, device, or other content protection or access control measure associated with the Site or CircleCI Content.

Third-Party Services

The Site may make available, or third parties may provide, links to other websites, applications, resources, advertisements, content or other products or services created, hosted or made available by third parties (“Third-Party Service(s)”), and such third parties may use other third parties to provide portions of the Third-Party Service to you, such as technology, development or payment services. When you access or use a Third-Party Service, you are interacting with the applicable third party, not with CircleCI, and you do so at your own risk. CircleCI is not responsible for, and makes no warranties, express or implied, as to, the Third-Party Services or the providers of such Third-Party Services (including without limitation the accuracy or completeness of the information provided by such Third-Party Service or the privacy practices of any third party). Inclusion of any Third-Party Service or a link thereto on the Site does not imply approval or endorsement of such Third-Party Service. CircleCI is not responsible or liable for the content or practices of any Third-Party Service or third party, even if such Third-Party Service links to, or is linked by, the Site.

Privacy Policy

CircleCI’s Privacy Policy applies to your use of this Site, and its terms are made a part of these Terms of Use by this reference. To view CircleCI’s Privacy Policy, click here. Additionally, by using the Site, you acknowledge and agree that Internet transmissions are never completely private or secure. You understand that any message or information you send to the Site may be read or intercepted by others, even if there is a special notice that a particular transmission (for example, credit card information) is encrypted.

Your Content

By posting, displaying, publishing or making available for download or use any content on the Site (other than personal information that is subject to the Privacy Policy), you hereby grant CircleCI a perpetual, worldwide, nonexclusive, irrevocable, royalty-free, sublicensable (through multiple tiers) license to perform, display, reproduce, prepare derivative works from, distribute, sell, sublicense, transfer and otherwise use without restriction all or any part of such content.

Compliance with Laws

You represent that, in agreeing to, and performing under, these Terms of Use, you are not violating, and will not violate, any governmental laws, rules, regulations or orders that are applicable to your use of the Site (“Applicable Laws”). Without limiting the foregoing, you represent that, in connection with your performance under these Terms of Use, you shall: (a) comply with Applicable Laws relating to anti-bribery and anti-corruption, which may include the US Foreign Corrupt Practices Act of 1977 and the UK Bribery Act 2010; (b) comply with Applicable Laws administered by the U.S. Commerce Bureau of Industry and Security, U.S. Treasury Office of Foreign Assets Control or other governmental entity imposing export controls and trade sanctions (collectively, “Export Laws”); and (c) not directly or indirectly export, re-export or otherwise deliver any CircleCI software, content or services in violation of any Export Laws, or broker, finance or otherwise facilitate any transaction in violation of any Export Laws. You represent that you are not prohibited from receiving software, CircleCI Content, or other services pursuant to these Terms of Use under Applicable Laws, including Export Laws.

Void Where Prohibited

Although the Site is accessible worldwide, not all features, products or services discussed, referenced, provided or offered through or on the Site are available to all persons or in all geographic locations, or appropriate or available for use outside the United States. CircleCI reserves the right to limit, in its sole discretion, the provision and quantity of any feature, product or service to any person or geographic area. Any offer for any feature, product or service made on the Site is void where prohibited. If you choose to access the Site from outside the United States, you do so on your own initiative and you are solely responsible for complying with applicable local laws.

Indemnity

You agree to defend, indemnify and hold harmless CircleCI, its affiliates and their respective employees, contractors, agents, officers and directors from and against any and all claims, damages, obligations, losses, liabilities, costs, debt or expenses (including without limitation attorneys’ fees) arising out of or related to any claim, suit, action or proceeding by a third party arising out of or relating to (i) your use of the Site, (ii) your breach of these Terms of Use (including any CircleCI policy referenced in these Terms of Use), (iii) your violation of any law, or (iv) any content that you post, upload or cause to interface with the Site, or otherwise transfer, process, use or store in connection with the Site.

Disclaimers

THE SITE AND ALL CONTENT AND OTHER ITEMS MADE AVAILABLE BY CIRCLECI ARE PROVIDED ON AN “AS IS” AND “AS AVAILABLE” BASIS WITHOUT WARRANTIES OF ANY KIND, WHETHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, INCLUDING ANY IMPLIED WARRANTY OF TITLE, MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, OR NON-INFRINGEMENT, TO THE MAXIMUM EXTENT PERMITTED BY APPLICABLE LAW. CIRCLECI ASSUMES NO LIABILITY OR RESPONSIBILITY FOR ANY (i) ERRORS, MISTAKES OR INACCURACIES OF DATA OR INFORMATION POSTED, DISPLAYED, PUBLISHED OR MADE AVAILABLE FOR DOWNLOAD OR USE ON THE SITE, (ii) PERSONAL INJURY OR PROPERTY DAMAGE, OF ANY NATURE WHATSOEVER, RESULTING FROM USE OF THE SITE, (iii) ANY INTERRUPTION OR CESSATION OF TRANSMISSION TO OR FROM THE SITE, OR (iv) THE DEFAMATORY, OFFENSIVE OR ILLEGAL CONDUCT OF ANY THIRD PARTY NOT UNDER CIRCLECI’S CONTROL.

Limitation of Liability

TO THE FULLEST EXTENT PERMITTED BY APPLICABLE LAW: (a) IN NO EVENT SHALL CIRCLECI, ITS AFFILIATES OR THEIR RESPECTIVE EMPLOYEES, CONTRACTORS, AGENTS, OFFICERS OR DIRECTORS BE LIABLE FOR ANY INDIRECT, PUNITIVE, INCIDENTAL, SPECIAL, CONSEQUENTIAL OR EXEMPLARY DAMAGES, INCLUDING WITHOUT LIMITATION DAMAGES FOR BUSINESS INTERRUPTION, LOSS OF PROFITS, GOODWILL, USE, DATA OR OTHER INTANGIBLE LOSSES ARISING OUT OF OR RELATING TO THE SITE OR YOUR USE OF THE SITE; AND (b) IN NO EVENT SHALL CIRCLECI’S CUMULATIVE AND AGGREGATE LIABILITY UNDER THESE TERMS OF USE EXCEED ONE HUNDRED U.S. DOLLARS. THE EXCLUSIONS AND LIMITATIONS IN THIS SECTION APPLY WHETHER THE ALLEGED LIABILITY IS BASED ON CONTRACT, TORT, NEGLIGENCE, STRICT LIABILITY OR ANY OTHER BASIS, EVEN IF YOU HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. SOME JURISDICTIONS DO NOT ALLOW LIMITATIONS OF LIABILITY, SO THE FOREGOING LIMITATION MAY NOT APPLY TO YOU.

Responsibility for End Users

You are responsible for violations of these Terms of Use by anyone using the Site with your permission or using your account on an unauthorized basis. Your use of the Site to assist another person in an activity that would violate these Terms of Use if performed by you is a violation of these Terms of Use. These Terms of Use apply to anyone accessing or using the Site; however, each provision in these Terms of Use shall be interpreted to include, and apply to, any action directly or indirectly taken, authorized, facilitated, promoted, encouraged or permitted by a user of the Site, even if such person did not themselves violate the provision.

Employment Opportunities

CircleCI may, from time to time, post employment opportunities on the Site and/or invite users to submit applications for employment to CircleCI. If you choose to submit your name, contact information, resume and/or other personal information to CircleCI in response to such employment listings, you are authorizing CircleCI to use this information for all lawful and legitimate hiring, employment and other business purposes. CircleCI also reserves the right, at its discretion, to forward such information to CircleCI‘s subsidiaries and affiliates for their legitimate business purposes. Nothing in these Terms of Use or contained on the Site will constitute a promise by CircleCI to review any such information, or to contact, interview or employ any individual who submits such information.

Digital Millennium Copyright Act

CircleCI respects the rights of copyright holders and abides by the federal Digital Millennium Copyright Act and similar regulations in other jurisdictions by responding to written notifications of alleged infringement by copyright holders. To provide a notification of alleged copyright infringement, please follow the procedures set forth in our Copyright Infringement Notice and Takedown Policy.

U.S. Government Rights

The Site is provided to the U.S. Government as “commercial items,” “commercial computer software,” “commercial computer software documentation,” and “technical data” with the same rights and restrictions generally applicable to the Site. If you are using the Site on behalf of the U.S. Government and these terms fail to meet the U.S. Government’s needs or are inconsistent in any respect with federal law, you must immediately discontinue use of the Site. The terms listed above are defined in the Federal Acquisition Regulation and the Defense Federal Acquisition Regulation Supplement.

Violation of These Terms of Use

CircleCI may disclose any information we have about you (including your identity) if we determine that such disclosure is necessary in connection with any investigation or complaint regarding your use of the Site, or to identify, contact or bring legal action against someone who may be causing injury to or interference with (either intentionally or unintentionally) CircleCI’s rights or property, or the rights or property of visitors to or users of the Site, including CircleCI’s customers. CircleCI reserves the right at all times to disclose any information that CircleCI deems necessary to comply with any applicable law, regulation, legal process or governmental request. CircleCI also may disclose your information when CircleCI determines that applicable law requires or permits such disclosure, including exchanging information with other companies and organizations for fraud protection purposes.

You acknowledge and agree that CircleCI may preserve any transmittal or communication by you with CircleCI, and may also disclose such data if required to do so by law or CircleCI determines that such preservation or disclosure is reasonably necessary to (1) comply with legal process, (2) enforce these Terms of Use, (3) respond to claims that any such data violates the rights of others, or (4) protect the rights, property or personal safety of CircleCI, its employees, users of or visitors to the Site, and the public.

You agree that CircleCI may, in its sole discretion and without prior notice, terminate your access to the Site and/or block your future access to the Site, for cause, for reasons including (but is not limited to) (1) requests by law enforcement or other government agencies, (2) a request by you (self-initiated account deletions), (3) discontinuance or material modification of the Site or any service offered on or through the Site, (4) unexpected technical issues or problems, or (5) our determination that you have violated these Terms of Use or other agreements or guidelines which may be associated with your use of the Site.

If CircleCI does take any legal action against you as a result of your violation of these Terms of Use, CircleCI will be entitled to recover from you, and you agree to pay, all reasonable attorneys’ fees and costs of such action, in addition to any other relief granted to CircleCI. You agree that CircleCI will not be liable to you or to any third party for termination of your access to the Site as a result of any violation of these Terms of Use.  You also agree that any violation by you of these Terms of Use will constitute an unlawful and unfair business practice, and will cause irreparable harm to CircleCI, for which monetary damages would be inadequate, and you consent to CircleCI seeking any injunctive or equitable relief that CircleCI deems necessary or appropriate in such circumstances. These remedies are in addition to any other remedies CircleCI may have at law or in equity.

Electronic Communications

When you visit the Site or send emails to CircleCI, you are communicating with CircleCI electronically; and you consent to receive communications from CircleCI electronically. CircleCI will communicate with you by email or by posting notices on the Site. You agree that all agreements, notices, disclosures and other communications that CircleCI provides to you electronically satisfy any legal requirement that such communications be in writing.

Governing Law

You agree that all matters relating to your access to or use of the Site, including all disputes, will be governed by the laws of the United States and by the laws of the State of California without regard to its conflicts of laws provisions. You agree to the personal jurisdiction by and venue in the state and federal courts in San Francisco County, California, and waive any objection to such jurisdiction or venue.

Miscellaneous

These Terms of Use constitute the complete and exclusive statement of the agreement between you and CircleCI and supersede all proposals, oral or written, and all other communications between you and CircleCI relating to the subject matter of these Terms of Use. In the event any information posted on the Site from time to time conflicts with any provision of these Terms of Use, the applicable provision of these Terms of Use shall control. Any terms and conditions of any other instrument issued by you in connection with these Terms of Use which are in addition to, inconsistent with or different from these Terms of Use shall be of no force or effect. These Terms of Use do not, and shall not be construed to, create any partnership, joint venture, employer-employee, agency or franchisor-franchisee relationship between you and CircleCI. You may not assign, transfer or sublicense all or any of your rights or obligations under these Terms of Use without CircleCI’s express prior written consent. CircleCI may assign, transfer or sublicense all or any of CircleCI’s rights or obligations under these Terms of Use without restriction. The failure of CircleCI to exercise or enforce any condition, term or provision of these Terms of Use will not operate as a waiver of such condition, term or provision. Any waiver by CircleCI of any condition, term or provision of these Terms of Use shall not be construed as a waiver of any other condition, term or provision. If any provision of these Terms of Use is held invalid or unenforceable, the remainder of these Terms of Use shall continue in full force and effect. You agree that a printed version of these Terms of Use and of any notice given in electronic form shall be admissible in judicial or administrative proceedings based upon or relating to these Terms of Use to the same extent and subject to the same conditions as other business documents and records originally generated and maintained in printed form. CircleCI will not be responsible for failures to fulfill any obligations due to causes beyond its control. Non-English translations of these Terms of Use are provided for convenience only. In the event of any ambiguity or conflict between translations, the English version is authoritative and controls.

Contact Us

Please contact CircleCI with any questions regarding these Terms of Use.\n\nLegal
  







  
    
      
        
        
        
          
          
            
              
                Software as a Service Agreement
              
            
            
          
        
          
          
            
              
                Software License Agreement
              
            
            
          
        
          
          
            
              
                AI Functionality Terms
              
            
            
          
        
          
          
            
              
                Code Sharing Terms of Service
              
            
            
          
        
          
          
            
              
                Self-Hosted Applications Terms
              
            
            
          
        
          
          
            
              
                Acceptable Use Policy
              
            
            
          
        
          
          
            
              
                Cookie Policy
              
            
            
          
        
          
          
            
              
                Privacy Policy
              
            
            
          
        
          
          
            
              
                CircleCI’s Commitment to Data Privacy
              
            
            
          
        
          
          
            
              
                 Trademark Usage Guidelines
              
            
            
          
        
          
          
            
              
                Copyright Infringement Notice and Takedown Policy
              
            
            
          
        
          
          
            
              
                Website Terms of Use
              
            
            
              
              


  Other Terms and Conditions
  CircleCI Content
  Third-Party Services
  Privacy Policy
  Your Content
  Compliance with Laws
  Void Where Prohibited
  Indemnity
  Disclaimers
  Limitation of Liability
  Responsibility for End Users
  Employment Opportunities
  Digital Millennium Copyright Act
  U.S. Government Rights
  Violation of These Terms of Use
  Electronic Communications
  Governing Law
  Miscellaneous
  Contact Us




            
          
        
      
    
  
  
    
      
        Website Terms of Use
      
      
          Last Updated:
          
            July 30, 2024
          
      
      
        
These Website Terms of Use (the “Terms of Use”) apply to the CircleCI web site located at  https://circleci.com/, and all subdomains of and associated sites linked to or by https://circleci.com/ by Circle Internet Services, Inc. (“CircleCI”), its subsidiaries and/or affiliates, including any CircleCI sites around the world (collectively, the “Site”). The Site is owned and operated by CircleCI. Please read these Terms of Use carefully before using the Site. By accessing or using the Site, or any of the content on the Site, you represent that you have read, understand, and agree to be legally bound by these Terms of Use. If you do not accept these Terms of Use, do not use the Site or any of the CircleCI Content (defined below).

CircleCI reserves the right, at its sole discretion, to change, modify, add or remove portions of these Terms of Use at any time. It is your responsibility to check these Terms of Use periodically for changes. Your continued use of the Site following the posting of any changes will mean that you accept and agree to the changes.

You represent to CircleCI that you are lawfully able to enter into contracts (e.g., you are not a minor). If you are accessing the Site for an entity, such as the company you work for, you represent that you have authority to bind that entity to these Terms of Use, and you agree that “you” and “your” as used in these Terms of Use includes both you personally and the entity you represent.

Other Terms and Conditions
These Terms of Use do not govern the use of our continuous integration/continuous deployment software-as-a-service offering or any other software, including downloadable software, and related technologies that may be made available by us to interoperate with the foregoing (collectively, the “Services”). If you are accessing or using the Services – even if you are doing so through a free trial or evaluation – then you are subject to CircleCI’s Software as a Service Agreement (currently available at https://circleci.com/legal/terms-of-service/) or such other written contract as may be separately agreed and entered into between you and CircleCI.

Additional terms and conditions may apply to specific portions or features of the Site, including contests, promotions or other similar features, and all such terms are made a part of these Terms of Use by this reference. You agree to abide by such other terms and conditions, including where applicable representing that you are of sufficient legal age to use or participate in such service or feature. If there is a conflict between these Terms of Use and the terms posted for or applicable to a specific portion of the Site or for any service offered on or through the Site, the latter terms shall control with respect to your use of that portion of the Site or the specific service.

CircleCI’s obligations, if any, with regard to its products and services are governed solely by the agreements pursuant to which they are provided, and nothing on this Site should be construed to alter such agreements.

CircleCI may make changes to any products or services offered on the Site, or to the applicable prices for any such products or services, at any time, without notice. The materials on the Site with respect to products and services may be out of date, and CircleCI makes no commitment to update the materials on the Site with respect to such products and services.

The following terms also govern and apply to your use of the Site, and they are incorporated herein by this reference:


  Acceptable Use Policy,
  Cookie Policy,
  Copyright Infringement Notice and Takedown Policy,
  Privacy Policy, and
  Trademark Usage Guidelines.


The foregoing terms may be changed from time to time and such changes are effective immediately upon their posting on the Site.

CircleCI Content

All text, graphics, user interfaces, visual interfaces, images, trademarks, logos, sounds, music, artwork and computer code (collectively, “CircleCI Content”), including but not limited to the design, structure, selection, coordination, expression, “look and feel” and arrangement of such CircleCI Content, contained on the Site is owned, controlled or licensed by or to CircleCI, and may be protected by trade dress, copyright, patent and trademark laws, and various other intellectual property rights and unfair competition laws.

CircleCI hereby grants to you a limited, revocable, non-sublicensable license to access, display and perform the CircleCI Content (excluding any computer code) solely for your personal, non-commercial use and solely as necessary to access and use the Site. Except as expressly permitted by CircleCI in these Terms of Use or on the Site, you may not copy, download, stream, capture, reproduce, duplicate, archive, upload, modify, translate, create derivative works based upon, publish, broadcast, transmit, retransmit, distribute, perform, display, sell or otherwise use or transfer any CircleCI Content. You may not, either directly or through the use of any device, software, online resource or other means, remove, alter, bypass, avoid, interfere with or circumvent any copyright, trademark or other proprietary notice on the Site or CircleCI Content or any digital rights management mechanism, device, or other content protection or access control measure associated with the Site or CircleCI Content.

Third-Party Services

The Site may make available, or third parties may provide, links to other websites, applications, resources, advertisements, content or other products or services created, hosted or made available by third parties (“Third-Party Service(s)”), and such third parties may use other third parties to provide portions of the Third-Party Service to you, such as technology, development or payment services. When you access or use a Third-Party Service, you are interacting with the applicable third party, not with CircleCI, and you do so at your own risk. CircleCI is not responsible for, and makes no warranties, express or implied, as to, the Third-Party Services or the providers of such Third-Party Services (including without limitation the accuracy or completeness of the information provided by such Third-Party Service or the privacy practices of any third party). Inclusion of any Third-Party Service or a link thereto on the Site does not imply approval or endorsement of such Third-Party Service. CircleCI is not responsible or liable for the content or practices of any Third-Party Service or third party, even if such Third-Party Service links to, or is linked by, the Site.

Privacy Policy

CircleCI’s Privacy Policy applies to your use of this Site, and its terms are made a part of these Terms of Use by this reference. To view CircleCI’s Privacy Policy, click here. Additionally, by using the Site, you acknowledge and agree that Internet transmissions are never completely private or secure. You understand that any message or information you send to the Site may be read or intercepted by others, even if there is a special notice that a particular transmission (for example, credit card information) is encrypted.

Your Content

By posting, displaying, publishing or making available for download or use any content on the Site (other than personal information that is subject to the Privacy Policy), you hereby grant CircleCI a perpetual, worldwide, nonexclusive, irrevocable, royalty-free, sublicensable (through multiple tiers) license to perform, display, reproduce, prepare derivative works from, distribute, sell, sublicense, transfer and otherwise use without restriction all or any part of such content.

Compliance with Laws

You represent that, in agreeing to, and performing under, these Terms of Use, you are not violating, and will not violate, any governmental laws, rules, regulations or orders that are applicable to your use of the Site (“Applicable Laws”). Without limiting the foregoing, you represent that, in connection with your performance under these Terms of Use, you shall: (a) comply with Applicable Laws relating to anti-bribery and anti-corruption, which may include the US Foreign Corrupt Practices Act of 1977 and the UK Bribery Act 2010; (b) comply with Applicable Laws administered by the U.S. Commerce Bureau of Industry and Security, U.S. Treasury Office of Foreign Assets Control or other governmental entity imposing export controls and trade sanctions (collectively, “Export Laws”); and (c) not directly or indirectly export, re-export or otherwise deliver any CircleCI software, content or services in violation of any Export Laws, or broker, finance or otherwise facilitate any transaction in violation of any Export Laws. You represent that you are not prohibited from receiving software, CircleCI Content, or other services pursuant to these Terms of Use under Applicable Laws, including Export Laws.

Void Where Prohibited

Although the Site is accessible worldwide, not all features, products or services discussed, referenced, provided or offered through or on the Site are available to all persons or in all geographic locations, or appropriate or available for use outside the United States. CircleCI reserves the right to limit, in its sole discretion, the provision and quantity of any feature, product or service to any person or geographic area. Any offer for any feature, product or service made on the Site is void where prohibited. If you choose to access the Site from outside the United States, you do so on your own initiative and you are solely responsible for complying with applicable local laws.

Indemnity

You agree to defend, indemnify and hold harmless CircleCI, its affiliates and their respective employees, contractors, agents, officers and directors from and against any and all claims, damages, obligations, losses, liabilities, costs, debt or expenses (including without limitation attorneys’ fees) arising out of or related to any claim, suit, action or proceeding by a third party arising out of or relating to (i) your use of the Site, (ii) your breach of these Terms of Use (including any CircleCI policy referenced in these Terms of Use), (iii) your violation of any law, or (iv) any content that you post, upload or cause to interface with the Site, or otherwise transfer, process, use or store in connection with the Site.

Disclaimers

THE SITE AND ALL CONTENT AND OTHER ITEMS MADE AVAILABLE BY CIRCLECI ARE PROVIDED ON AN “AS IS” AND “AS AVAILABLE” BASIS WITHOUT WARRANTIES OF ANY KIND, WHETHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, INCLUDING ANY IMPLIED WARRANTY OF TITLE, MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, OR NON-INFRINGEMENT, TO THE MAXIMUM EXTENT PERMITTED BY APPLICABLE LAW. CIRCLECI ASSUMES NO LIABILITY OR RESPONSIBILITY FOR ANY (i) ERRORS, MISTAKES OR INACCURACIES OF DATA OR INFORMATION POSTED, DISPLAYED, PUBLISHED OR MADE AVAILABLE FOR DOWNLOAD OR USE ON THE SITE, (ii) PERSONAL INJURY OR PROPERTY DAMAGE, OF ANY NATURE WHATSOEVER, RESULTING FROM USE OF THE SITE, (iii) ANY INTERRUPTION OR CESSATION OF TRANSMISSION TO OR FROM THE SITE, OR (iv) THE DEFAMATORY, OFFENSIVE OR ILLEGAL CONDUCT OF ANY THIRD PARTY NOT UNDER CIRCLECI’S CONTROL.

Limitation of Liability

TO THE FULLEST EXTENT PERMITTED BY APPLICABLE LAW: (a) IN NO EVENT SHALL CIRCLECI, ITS AFFILIATES OR THEIR RESPECTIVE EMPLOYEES, CONTRACTORS, AGENTS, OFFICERS OR DIRECTORS BE LIABLE FOR ANY INDIRECT, PUNITIVE, INCIDENTAL, SPECIAL, CONSEQUENTIAL OR EXEMPLARY DAMAGES, INCLUDING WITHOUT LIMITATION DAMAGES FOR BUSINESS INTERRUPTION, LOSS OF PROFITS, GOODWILL, USE, DATA OR OTHER INTANGIBLE LOSSES ARISING OUT OF OR RELATING TO THE SITE OR YOUR USE OF THE SITE; AND (b) IN NO EVENT SHALL CIRCLECI’S CUMULATIVE AND AGGREGATE LIABILITY UNDER THESE TERMS OF USE EXCEED ONE HUNDRED U.S. DOLLARS. THE EXCLUSIONS AND LIMITATIONS IN THIS SECTION APPLY WHETHER THE ALLEGED LIABILITY IS BASED ON CONTRACT, TORT, NEGLIGENCE, STRICT LIABILITY OR ANY OTHER BASIS, EVEN IF YOU HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. SOME JURISDICTIONS DO NOT ALLOW LIMITATIONS OF LIABILITY, SO THE FOREGOING LIMITATION MAY NOT APPLY TO YOU.

Responsibility for End Users

You are responsible for violations of these Terms of Use by anyone using the Site with your permission or using your account on an unauthorized basis. Your use of the Site to assist another person in an activity that would violate these Terms of Use if performed by you is a violation of these Terms of Use. These Terms of Use apply to anyone accessing or using the Site; however, each provision in these Terms of Use shall be interpreted to include, and apply to, any action directly or indirectly taken, authorized, facilitated, promoted, encouraged or permitted by a user of the Site, even if such person did not themselves violate the provision.

Employment Opportunities

CircleCI may, from time to time, post employment opportunities on the Site and/or invite users to submit applications for employment to CircleCI. If you choose to submit your name, contact information, resume and/or other personal information to CircleCI in response to such employment listings, you are authorizing CircleCI to use this information for all lawful and legitimate hiring, employment and other business purposes. CircleCI also reserves the right, at its discretion, to forward such information to CircleCI‘s subsidiaries and affiliates for their legitimate business purposes. Nothing in these Terms of Use or contained on the Site will constitute a promise by CircleCI to review any such information, or to contact, interview or employ any individual who submits such information.

Digital Millennium Copyright Act

CircleCI respects the rights of copyright holders and abides by the federal Digital Millennium Copyright Act and similar regulations in other jurisdictions by responding to written notifications of alleged infringement by copyright holders. To provide a notification of alleged copyright infringement, please follow the procedures set forth in our Copyright Infringement Notice and Takedown Policy.

U.S. Government Rights

The Site is provided to the U.S. Government as “commercial items,” “commercial computer software,” “commercial computer software documentation,” and “technical data” with the same rights and restrictions generally applicable to the Site. If you are using the Site on behalf of the U.S. Government and these terms fail to meet the U.S. Government’s needs or are inconsistent in any respect with federal law, you must immediately discontinue use of the Site. The terms listed above are defined in the Federal Acquisition Regulation and the Defense Federal Acquisition Regulation Supplement.

Violation of These Terms of Use

CircleCI may disclose any information we have about you (including your identity) if we determine that such disclosure is necessary in connection with any investigation or complaint regarding your use of the Site, or to identify, contact or bring legal action against someone who may be causing injury to or interference with (either intentionally or unintentionally) CircleCI’s rights or property, or the rights or property of visitors to or users of the Site, including CircleCI’s customers. CircleCI reserves the right at all times to disclose any information that CircleCI deems necessary to comply with any applicable law, regulation, legal process or governmental request. CircleCI also may disclose your information when CircleCI determines that applicable law requires or permits such disclosure, including exchanging information with other companies and organizations for fraud protection purposes.

You acknowledge and agree that CircleCI may preserve any transmittal or communication by you with CircleCI, and may also disclose such data if required to do so by law or CircleCI determines that such preservation or disclosure is reasonably necessary to (1) comply with legal process, (2) enforce these Terms of Use, (3) respond to claims that any such data violates the rights of others, or (4) protect the rights, property or personal safety of CircleCI, its employees, users of or visitors to the Site, and the public.

You agree that CircleCI may, in its sole discretion and without prior notice, terminate your access to the Site and/or block your future access to the Site, for cause, for reasons including (but is not limited to) (1) requests by law enforcement or other government agencies, (2) a request by you (self-initiated account deletions), (3) discontinuance or material modification of the Site or any service offered on or through the Site, (4) unexpected technical issues or problems, or (5) our determination that you have violated these Terms of Use or other agreements or guidelines which may be associated with your use of the Site.

If CircleCI does take any legal action against you as a result of your violation of these Terms of Use, CircleCI will be entitled to recover from you, and you agree to pay, all reasonable attorneys’ fees and costs of such action, in addition to any other relief granted to CircleCI. You agree that CircleCI will not be liable to you or to any third party for termination of your access to the Site as a result of any violation of these Terms of Use.  You also agree that any violation by you of these Terms of Use will constitute an unlawful and unfair business practice, and will cause irreparable harm to CircleCI, for which monetary damages would be inadequate, and you consent to CircleCI seeking any injunctive or equitable relief that CircleCI deems necessary or appropriate in such circumstances. These remedies are in addition to any other remedies CircleCI may have at law or in equity.

Electronic Communications

When you visit the Site or send emails to CircleCI, you are communicating with CircleCI electronically; and you consent to receive communications from CircleCI electronically. CircleCI will communicate with you by email or by posting notices on the Site. You agree that all agreements, notices, disclosures and other communications that CircleCI provides to you electronically satisfy any legal requirement that such communications be in writing.

Governing Law

You agree that all matters relating to your access to or use of the Site, including all disputes, will be governed by the laws of the United States and by the laws of the State of California without regard to its conflicts of laws provisions. You agree to the personal jurisdiction by and venue in the state and federal courts in San Francisco County, California, and waive any objection to such jurisdiction or venue.

Miscellaneous

These Terms of Use constitute the complete and exclusive statement of the agreement between you and CircleCI and supersede all proposals, oral or written, and all other communications between you and CircleCI relating to the subject matter of these Terms of Use. In the event any information posted on the Site from time to time conflicts with any provision of these Terms of Use, the applicable provision of these Terms of Use shall control. Any terms and conditions of any other instrument issued by you in connection with these Terms of Use which are in addition to, inconsistent with or different from these Terms of Use shall be of no force or effect. These Terms of Use do not, and shall not be construed to, create any partnership, joint venture, employer-employee, agency or franchisor-franchisee relationship between you and CircleCI. You may not assign, transfer or sublicense all or any of your rights or obligations under these Terms of Use without CircleCI’s express prior written consent. CircleCI may assign, transfer or sublicense all or any of CircleCI’s rights or obligations under these Terms of Use without restriction. The failure of CircleCI to exercise or enforce any condition, term or provision of these Terms of Use will not operate as a waiver of such condition, term or provision. Any waiver by CircleCI of any condition, term or provision of these Terms of Use shall not be construed as a waiver of any other condition, term or provision. If any provision of these Terms of Use is held invalid or unenforceable, the remainder of these Terms of Use shall continue in full force and effect. You agree that a printed version of these Terms of Use and of any notice given in electronic form shall be admissible in judicial or administrative proceedings based upon or relating to these Terms of Use to the same extent and subject to the same conditions as other business documents and records originally generated and maintained in printed form. CircleCI will not be responsible for failures to fulfill any obligations due to causes beyond its control. Non-English translations of these Terms of Use are provided for convenience only. In the event of any ambiguity or conflict between translations, the English version is authoritative and controls.

Contact Us

Please contact CircleCI with any questions regarding these Terms of Use.\n\n\n\n