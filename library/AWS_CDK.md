# AWS_CDK

## Crawl Summary
The crawled AWS CDK documentation provides detailed technical information including the framework's dual components (Construct Library and CLI), support for multiple programming languages, and benefits such as IAC, unified code management, and reproducible CloudFormation deployments. It includes explicit code examples in TypeScript, JavaScript, Python, Java, C#, and Go with exact parameter values (e.g., maxAzs=3, cpu=512, desiredCount=6, memoryLimitMiB=2048) and step-by-step construct instantiation. It also lists CloudFormation resource types generated by a typical CDK deployment.

## Normalised Extract
## Table of Contents
1. AWS CDK Overview & Benefits
2. Programming Languages & Constructs
3. Code Examples
   - TypeScript
   - JavaScript
   - Python
   - Java
   - C#
   - Go
4. CloudFormation Resources
5. Technical Features & References

## 1. AWS CDK Overview & Benefits
- Definition: Open-source framework for defining cloud infrastructure in code.
- Components: Construct Library and CDK CLI.
- Benefit: Infrastructure as Code with native programming language constructs.

## 2. Programming Languages & Constructs
- Languages: TypeScript, JavaScript, Python, Java, C# (.Net), Go.
- Constructs: Reusable components that model AWS resources.

## 3. Code Examples

### TypeScript
Code demonstrates creation of a VPC with a maximum of 3 Availability Zones, a Cluster, and a load-balanced Fargate service with:
- cpu: 512 (default 256)
- desiredCount: 6 (default 1)
- memoryLimitMiB: 2048 (default 512)
- publicLoadBalancer: true (default false)

### JavaScript
Follows the same pattern as the TypeScript example with equivalent parameters and instantiations.

### Python
Defines a Stack subclass that instantiates a VPC, Cluster, and ApplicationLoadBalancedFargateService using similar parameters.

### Java
Uses Builders to create the VPC, Cluster, and ApplicationLoadBalancedFargateService with explicit method chaining and parameter declarations.

### C#
Instantiates VPC, Cluster, and Fargate Service in a Stack with strong typing, using property objects for configuration.

### Go
Creates a new CDK Stack, defines VPC and Cluster objects, and uses the patterns API to configure an ApplicationLoadBalancedFargateService with jsii wrappers for numeric and boolean values.

## 4. CloudFormation Resources
List of resource types generated includes:
- AWS::EC2::EIP, InternetGateway, NatGateway, Route, RouteTable, SecurityGroup, Subnet, SubnetRouteTableAssociation, VPCGatewayAttachment, VPC
- AWS::ECS::Cluster, Service, TaskDefinition
- AWS::ElasticLoadBalancingV2::Listener, LoadBalancer, TargetGroup
- AWS::IAM::Policy, Role
- AWS::Logs::LogGroup

## 5. Technical Features & References
- GitHub Repository (aws-cdk) for repository access and contributing.
- API Reference for exact class and method specifications.
- Construct Programming Model for extending constructs to other domains (CDKtf, CDK8s, Projen).
- Construct Hub for sharing and discovering constructs.

## Supplementary Details
### Configuration Options & Parameter Details

- **VPC Configuration:**
  - Parameter: maxAzs
  - Value: 3 (default uses all AZs in the region)

- **Fargate Service Configuration:**
  - cpu: 512 (override default 256)
  - desiredCount: 6 (override default 1)
  - memoryLimitMiB / memory_limit_mib: 2048 (override default 512)
  - publicLoadBalancer: true (override default false)

### Implementation Steps

1. Instantiate a VPC with a specified number of AZs using new ec2.Vpc(this, "MyVpc", {maxAzs: 3}).
2. Create an ECS Cluster linked to the VPC (new ecs.Cluster(this, "MyCluster", { vpc })).
3. Create a load-balanced Fargate Service using the appropriate construct from ecs_patterns, providing the required cluster, cpu, desiredCount, taskImageOptions with an image from registry, memoryLimitMiB, and publicLoadBalancer flag.
4. Deploy the stack to generate a CloudFormation template with over 500 lines that include defined resource types.

### Best Practices

- Use constructs to encapsulate reusable infrastructure patterns.
- Use stacks to group related resources for easier deployments and rollbacks.
- Validate parameter overrides (e.g., cpu, memory) against defaults to ensure expected performance.
- Leverage IDE features in languages like TypeScript and Python for syntax checking and intelligent code completion.

### Troubleshooting Procedures

- If the deployment fails, inspect the generated AWS CloudFormation template for missing parameters or misconfigurations.
- Use AWS CloudFormation's rollback messages to pinpoint configuration errors.
- Validate the runtime environment (e.g., Node.js version for TypeScript/JavaScript) and dependencies installed for the CDK app.
- Run CDK CLI commands such as `cdk synth` to generate and inspect the output template before deployment.


## Reference Details
### Complete API Specifications & SDK Method Signatures

#### TypeScript Example

Method Signature:

export class MyEcsConstructStack extends Stack {
  constructor(scope: App, id: string, props?: StackProps) {
    // super call and construct initialization
  }
}

Parameters:
- scope: App (represents the CDK app context)
- id: string (unique identifier for the stack)
- props?: StackProps (optional configuration properties for the stack)

Return Type: Instance of MyEcsConstructStack extending Stack

#### JavaScript Example

class MyEcsConstructStack extends Stack {
  constructor(scope, id, props) {
    // super(scope, id, props) call
  }
}

#### Python Example

class MyEcsConstructStack(Stack):
    def __init__(self, scope: Construct, id: str, **kwargs) -> None:
        super().__init__(scope, id, **kwargs)
        # VPC and cluster instantiation

Parameter Types:
- scope: Construct
- id: str
- kwargs: Additional StackProps

#### Java Example

public MyEcsConstructStack(final Construct scope, final String id, StackProps props) {
    super(scope, id, props);
    // VPC created using Vpc.Builder
}

Method Specifications:
- Vpc.Builder.create(this, "MyVpc").maxAzs(3).build();
- Cluster.Builder.create(this, "MyCluster").vpc(vpc).build();
- ApplicationLoadBalancedFargateService.Builder.create(this, "MyFargateService")
      .cluster(cluster)
      .cpu(512)
      .desiredCount(6)
      .taskImageOptions(ApplicationLoadBalancedTaskImageOptions.builder()
          .image(ContainerImage.fromRegistry("amazon/amazon-ecs-sample"))
          .build())
      .memoryLimitMiB(2048)
      .publicLoadBalancer(true)
      .build();

#### C# Example

public MyEcsConstructStack(Construct scope, string id, IStackProps props = null) : base(scope, id, props) {
   var vpc = new Vpc(this, "MyVpc", new VpcProps { MaxAzs = 3 });
   var cluster = new Cluster(this, "MyCluster", new ClusterProps { Vpc = vpc });
   new ApplicationLoadBalancedFargateService(this, "MyFargateService", new ApplicationLoadBalancedFargateServiceProps {
       Cluster = cluster,
       Cpu = 512,
       DesiredCount = 6,
       TaskImageOptions = new ApplicationLoadBalancedTaskImageOptions {
           Image = ContainerImage.FromRegistry("amazon/amazon-ecs-sample")
       },
       MemoryLimitMiB = 2048,
       PublicLoadBalancer = true,
   });
}

#### Go Example

func NewMyEcsConstructStack(scope constructs.Construct, id string, props *MyEcsConstructStackProps) awscdk.Stack {
    var sprops awscdk.StackProps
    if props != nil {
      sprops = props.StackProps
    }
    stack := awscdk.NewStack(scope, &id, &sprops)
    vpc := awsec2.NewVpc(stack, jsii.String("MyVpc"), &awsec2.VpcProps{
        MaxAzs: jsii.Number(3),
    })
    cluster := awsecs.NewCluster(stack, jsii.String("MyCluster"), &awsecs.ClusterProps{
        Vpc: vpc,
    })
    awsecspatterns.NewApplicationLoadBalancedFargateService(stack, jsii.String("MyFargateService"),
      &awsecspatterns.ApplicationLoadBalancedFargateServiceProps{
          Cluster:        cluster,
          Cpu:            jsii.Number(512),
          DesiredCount:   jsii.Number(6),
          MemoryLimitMiB: jsii.Number(2048),
          TaskImageOptions: &awsecspatterns.ApplicationLoadBalancedTaskImageOptions{
              Image: awsecs.ContainerImage_FromRegistry(jsii.String("amazon/amazon-ecs-sample"), nil),
          },
          PublicLoadBalancer: jsii.Bool(true),
      })
    return stack
}

### Troubleshooting Commands & Expected Outputs

- Command: `cdk synth`
  - Expected Output: A valid CloudFormation template printed to STDOUT.
- Command: `cdk deploy`
  - Expected Output: The stack deployment progress and a final confirmation with deployed resource IDs.

All parameters and configurations are to be used exactly as specified without further modification. These code examples and API signatures are intended for direct application in development environments.

## Original Source
AWS CDK Documentation
https://docs.aws.amazon.com/cdk/latest/guide/home.html

## Digest of AWS_CDK

# AWS CDK Developer Guide

**Retrieval Date:** 2023-10-24

## Overview

The AWS Cloud Development Kit (AWS CDK) is an open-source software development framework for defining cloud infrastructure in code and provisioning it through AWS CloudFormation. It consists of two primary parts:

- **AWS CDK Construct Library**: A collection of pre-written, modular, reusable constructs for quickly developing your infrastructure. These constructs abstract AWS CloudFormation resources with sensible defaults and common patterns.
- **AWS CDK CLI (Toolkit)**: A command line tool for creating, managing, and deploying AWS CDK apps.

The AWS CDK supports multiple programming languages including TypeScript, JavaScript, Python, Java, C#/.Net, and Go.

## Table of Contents

1. [CDK Overview & Benefits](#cdk-overview--benefits)
2. [Programming Languages & Constructs](#programming-languages--constructs)
3. [Code Examples](#code-examples)
   - TypeScript
   - JavaScript
   - Python
   - Java
   - C#
   - Go
4. [CloudFormation Resources Generated](#cloudformation-resources-generated)
5. [Technical Features & References](#technical-features--references)

## CDK Overview & Benefits

- **Infrastructure as Code (IaC):** Write, deploy, and manage your infrastructure using familiar programming concepts (parameters, loops, conditionals) which results in structured infrastructure management.
- **Unified Application and Infrastructure Code:** Define both your application logic and infrastructure in one place, utilizing modern IDE features like syntax highlighting and code completion.
- **Deployment via AWS CloudFormation:** Automates resource provisioning with rollback on errors, leveraging AWS CloudFormation’s maturity.
- **Rapid Development using Constructs:** Use pre-built constructs or create custom ones to rapidly develop cloud solutions.

## Programming Languages & Constructs

AWS CDK allows you to define cloud components (constructs) using:

- TypeScript
- JavaScript
- Python
- Java
- C#/.Net
- Go

These constructs are composed into stacks and apps for deployment with AWS CloudFormation.

## Code Examples

### TypeScript

```typescript
export class MyEcsConstructStack extends Stack {
  constructor(scope: App, id: string, props?: StackProps) {
    super(scope, id, props);

    const vpc = new ec2.Vpc(this, "MyVpc", {
      maxAzs: 3 // Default is all AZs in region
    });

    const cluster = new ecs.Cluster(this, "MyCluster", {
      vpc: vpc
    });

    // Create a load-balanced Fargate service
    new ecs_patterns.ApplicationLoadBalancedFargateService(this, "MyFargateService", {
      cluster: cluster, // Required
      cpu: 512,         // Default is 256
      desiredCount: 6,  // Default is 1
      taskImageOptions: { 
        image: ecs.ContainerImage.fromRegistry("amazon/amazon-ecs-sample")
      },
      memoryLimitMiB: 2048, // Default is 512
      publicLoadBalancer: true // Default is false
    });
  }
}
```

### JavaScript

```javascript
class MyEcsConstructStack extends Stack {
  constructor(scope, id, props) {
    super(scope, id, props);

    const vpc = new ec2.Vpc(this, "MyVpc", {
      maxAzs: 3 // Default is all AZs in region
    });

    const cluster = new ecs.Cluster(this, "MyCluster", {
      vpc: vpc
    });

    // Create a load-balanced Fargate service
    new ecs_patterns.ApplicationLoadBalancedFargateService(this, "MyFargateService", {
      cluster: cluster, // Required
      cpu: 512,         // Default is 256
      desiredCount: 6,  // Default is 1
      taskImageOptions: { 
        image: ecs.ContainerImage.fromRegistry("amazon/amazon-ecs-sample")
      },
      memoryLimitMiB: 2048, // Default is 512
      publicLoadBalancer: true // Default is false
    });
  }
}

module.exports = { MyEcsConstructStack };
```

### Python

```python
class MyEcsConstructStack(Stack):

    def __init__(self, scope: Construct, id: str, **kwargs) -> None:
        super().__init__(scope, id, **kwargs)

        vpc = ec2.Vpc(self, "MyVpc", max_azs=3)  # default is all AZs in region

        cluster = ecs.Cluster(self, "MyCluster", vpc=vpc)

        ecs_patterns.ApplicationLoadBalancedFargateService(
            self, "MyFargateService",
            cluster=cluster,            # Required
            cpu=512,                    # Default is 256
            desired_count=6,            # Default is 1
            task_image_options=ecs_patterns.ApplicationLoadBalancedTaskImageOptions(
                image=ecs.ContainerImage.from_registry("amazon/amazon-ecs-sample")
            ),
            memory_limit_mib=2048,      # Default is 512
            public_load_balancer=True   # Default is False
        )
```

### Java

```java
public class MyEcsConstructStack extends Stack {

    public MyEcsConstructStack(final Construct scope, final String id) {
        this(scope, id, null);
    }

    public MyEcsConstructStack(final Construct scope, final String id, StackProps props) {
        super(scope, id, props);

        Vpc vpc = Vpc.Builder.create(this, "MyVpc")
                .maxAzs(3)
                .build();

        Cluster cluster = Cluster.Builder.create(this, "MyCluster")
                .vpc(vpc)
                .build();

        ApplicationLoadBalancedFargateService.Builder.create(this, "MyFargateService")
                .cluster(cluster)
                .cpu(512)
                .desiredCount(6)
                .taskImageOptions(
                    ApplicationLoadBalancedTaskImageOptions.builder()
                        .image(ContainerImage.fromRegistry("amazon/amazon-ecs-sample"))
                        .build()
                )
                .memoryLimitMiB(2048)
                .publicLoadBalancer(true)
                .build();
    }
}
```

### C#

```csharp
public class MyEcsConstructStack : Stack
{
    public MyEcsConstructStack(Construct scope, string id, IStackProps props = null) : base(scope, id, props)
    {
        var vpc = new Vpc(this, "MyVpc", new VpcProps
        {
            MaxAzs = 3
        });

        var cluster = new Cluster(this, "MyCluster", new ClusterProps
        {
            Vpc = vpc
        });

        new ApplicationLoadBalancedFargateService(this, "MyFargateService",
            new ApplicationLoadBalancedFargateServiceProps
            {
                Cluster = cluster,
                Cpu = 512,
                DesiredCount = 6,
                TaskImageOptions = new ApplicationLoadBalancedTaskImageOptions
                {
                    Image = ContainerImage.FromRegistry("amazon/amazon-ecs-sample")
                },
                MemoryLimitMiB = 2048,
                PublicLoadBalancer = true
            });
    }
}
```

### Go

```go
func NewMyEcsConstructStack(scope constructs.Construct, id string, props *MyEcsConstructStackProps) awscdk.Stack {

    var sprops awscdk.StackProps
    if props != nil {
        sprops = props.StackProps
    }

    stack := awscdk.NewStack(scope, &id, &sprops)

    vpc := awsec2.NewVpc(stack, jsii.String("MyVpc"), &awsec2.VpcProps{
        MaxAzs: jsii.Number(3), // Default is all AZs in region
    })

    cluster := awsecs.NewCluster(stack, jsii.String("MyCluster"), &awsecs.ClusterProps{
        Vpc: vpc,
    })

    awsecspatterns.NewApplicationLoadBalancedFargateService(stack, jsii.String("MyFargateService"),
        &awsecspatterns.ApplicationLoadBalancedFargateServiceProps{
            Cluster:        cluster,           // Required
            Cpu:            jsii.Number(512),  // Default is 256
            DesiredCount:   jsii.Number(6),    // Default is 1
            MemoryLimitMiB: jsii.Number(2048), // Default is 512
            TaskImageOptions: &awsecspatterns.ApplicationLoadBalancedTaskImageOptions{
                Image: awsecs.ContainerImage_FromRegistry(jsii.String("amazon/amazon-ecs-sample"), nil),
            },
            PublicLoadBalancer: jsii.Bool(true), // Default is false
        })

    return stack
}
```

## CloudFormation Resources Generated

Deploying the AWS CDK app typically produces a CloudFormation template of more than 500 lines creating over 50 resources including but not limited to:

- AWS::EC2::EIP
- AWS::EC2::InternetGateway
- AWS::EC2::NatGateway
- AWS::EC2::Route
- AWS::EC2::RouteTable
- AWS::EC2::SecurityGroup
- AWS::EC2::Subnet
- AWS::EC2::SubnetRouteTableAssociation
- AWS::EC2::VPCGatewayAttachment
- AWS::EC2::VPC
- AWS::ECS::Cluster
- AWS::ECS::Service
- AWS::ECS::TaskDefinition
- AWS::ElasticLoadBalancingV2::Listener
- AWS::ElasticLoadBalancingV2::LoadBalancer
- AWS::ElasticLoadBalancingV2::TargetGroup
- AWS::IAM::Policy
- AWS::IAM::Role
- AWS::Logs::LogGroup

## Technical Features & References

- **GitHub Repository:** [aws-cdk](https://github.com/aws/aws-cdk) for issue tracking, license, releases and contributions.
- **API Reference:** Detailed APIs provided by the AWS CDK Construct Library.
- **Construct Programming Model (CPM):** Extends AWS CDK concepts to tools such as CDK for Terraform (CDKtf), CDK for Kubernetes (CDK8s) and Projen.
- **Construct Hub:** An online registry for finding, publishing and sharing AWS CDK libraries.


## Attribution
- Source: AWS CDK Documentation
- URL: https://docs.aws.amazon.com/cdk/latest/guide/home.html
- License: License: AWS Documentation License
- Crawl Date: 2025-04-17T18:39:25.658Z
- Data Size: 1433781 bytes
- Links Found: 131049

## Retrieved
2025-04-17
