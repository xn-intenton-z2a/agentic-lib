# .github/workflows/wfr-fix-failing-build.yml
name: âˆž Fix failing build - WORK IN PROGRESS

on:
  workflow_call:
    inputs:
      target:
        description: 'The target file to review. e.g. "src/lib/main.js"'
        type: string
        required: false
        default: 'src/lib/main.js'
      branch:
        description: 'The prefix for the issue branch. e.g. "issue-".'
        type: string
        required: true
      buildScript:
        description: 'The script must be runnable as: `npm ci ; <script>` and succeed with a zero exit code. e.g. `npm run build`'
        type: string
        required: false
        default: 'echo "No build script specified."'
      testScript:
        description: 'The script must be runnable as: `npm ci ; <script>` and succeed with a zero exit code. e.g. `npm test`'
        type: string
        required: false
        default: 'npm test'
      mainScript:
        description: 'The script must be runnable as: `npm ci ; <script>` and succeed with a zero exit code. e.g. `node src/lib/main.js`'
        type: string
        required: false
        default: 'node src/lib/main.js'
      model:
        description: 'The OpenAI model to use. e.g. "o3-mini"'
        type: string
        required: false
        default: 'o3-mini'
      gitUserEmail:
        description: 'The email to use for git commits. e.g. "action@github.com"'
        type: string
        required: false
        default: 'action@github.com'
      gitUserName:
        description: 'The name to use for git commits. e.g. "GitHub Actions[bot]"'
        type: string
        required: false
        default: 'GitHub Actions[bot]'
    secrets:
      PERSONAL_ACCESS_TOKEN:
        required: false
      CHATGPT_API_SECRET_KEY:
        required: true
    outputs:
      fixApplied:
        value: ${{ jobs.fix-failing-build.outputs.fixApplied }}
      message:
        value: ${{ jobs.fix-failing-build.outputs.message }}

jobs:
  fix-failing-build:
    runs-on: ubuntu-latest

    env:
      target: ${{ inputs.target || 'src/lib/main.js' }}
      branch: ${{ inputs.branch || 'issue-' }}
      buildScript: ${{ inputs.buildScript || 'npm run build' }}
      testScript: ${{ inputs.testScript || 'npm test' }}
      mainScript: ${{ inputs.mainScript || 'node src/lib/main.js' }}
      mainScriptTimeout: '5m'
      model: ${{ inputs.model || 'o3-mini' }}
      chatgptApiSecretKey: ${{ secrets.CHATGPT_API_SECRET_KEY }}
      gitUserEmail: ${{ inputs.gitUserEmail || 'action@github.com' }}
      gitUserName: ${{ inputs.gitUserName || 'GitHub Actions[bot]' }}

    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Check GitHub authentication
        if: ${{ env.npmAuthOrganisation != '' }}
        shell: bash
        run: |
          curl --include --header "Authorization: token ${{ secrets.PERSONAL_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}" https://api.github.com/user

      - name: Set up .npmrc
        if: ${{ env.npmAuthOrganisation != '' }}
        shell: bash
        run: |
          echo "${{ env.npmAuthOrganisation }}:registry=https://npm.pkg.github.com" >> .npmrc
          echo "//npm.pkg.github.com/:_authToken=${{ secrets.PERSONAL_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}" >> .npmrc
          echo "always-auth=true" >> .npmrc

      - run: npm ci

      - name: Tear down .npmrc
        if: ${{ env.npmAuthOrganisation != '' }}
        shell: bash
        run: rm -f .npmrc

      - name: List dependencies
        id: list
        shell: bash
        run: |
          output=$(npm list 2>&1)
          echo "output<<EOF" >> "$GITHUB_OUTPUT"
          echo "$output" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          echo "output=${output}"

      - name: Build project (tolerantly)
        id: build
        shell: bash
        run: |
          set +e
          output=$(${{ env.buildScript }} 2>&1)
          echo "output<<EOF" >> "$GITHUB_OUTPUT"
          echo "$output" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          echo "output=${output}"
          exit 0

      - name: Run tests (tolerantly)
        id: test
        shell: bash
        run: |
          set +e
          output=$(${{ env.testScript }} 2>&1)
          echo "output<<EOF" >> "$GITHUB_OUTPUT"
          echo "$output" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          echo "output=${output}"
          exit 0

      - name: Run main (tolerantly)
        id: main
        shell: bash
        run: |
          set +e
          output=$(timeout ${{ env.mainScriptTimeout }} ${{ env.mainScript }} 2>&1)
          echo "output<<EOF" >> "$GITHUB_OUTPUT"
          echo "$output" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          echo "output=${output}"
          exit 0

      - name: update-target
        id: update-target
        uses: actions/github-script@v7
        env:
          listOutput: ${{ steps.list.outputs.output }}
          buildOutput: ${{ steps.build.outputs.output }}
          testOutput: ${{ steps.test.outputs.output }}
          mainOutput: ${{ steps.main.outputs.output }}
        with:
          github-token: ${{ secrets.PERSONAL_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}
          script: |
            const target = process.env.target;
            const model = process.env.model;
            const apiKey = process.env.chatgptApiSecretKey;
            const listOutput = process.env.listOutput;
            const buildScript = process.env.buildScript;
            const buildOutput = process.env.buildOutput;
            const testScript = process.env.testScript;
            const testOutput = process.env.testOutput;
            const mainScript = process.env.mainScript;
            const mainOutput = process.env.mainOutput;

            const fs = require('fs');
            const OpenAI = require('openai').default;
            const { z } = require('zod');
            require('dotenv').config();

            if (!apiKey) { 
              core.setFailed("Missing CHATGPT_API_SECRET_KEY"); 
            }
            const openai = new OpenAI({ apiKey });

            const sourceFileContent = fs.readFileSync(target, 'utf8');
            
            const prompt = `
            You are providing the entire new content of the source file, with all necessary changes applied to resolve any issues visible.
            Consider the file content, dependency list, build output, test output, and main output.
            
            Source for file: ${target}
            SOURCE_FILE_START
            ${sourceFileContent}
            SOURCE_FILE_END
            
            Dependency list from command: npm list
            TEST_OUTPUT_START
            ${listOutput}
            TEST_OUTPUT_END    

            Build output from command: ${buildScript}
            TEST_OUTPUT_START
            ${buildOutput}
            TEST_OUTPUT_END      
            
            Test output from command: ${testScript}
            TEST_OUTPUT_START
            ${testOutput}
            TEST_OUTPUT_END            

            Main output from command: ${mainScript}
            MAIN_OUTPUT_START
            ${mainOutput}
            MAIN_OUTPUT_END    
            
            Please produce an updated version of the file that resolves any issues visible.
            Answer strictly with a JSON object following this schema:
            
            {
              "updatedSourceFileContent": "REPLACE: The entire new content of the source file, with all necessary changes applied.",
              "message": "REPLACE: A short sentence explaining the change applied suitable for a commit message."
            }
            
            Ensure valid JSON.
            `;
            
            const ResponseSchema = z.object({ updatedSourceFileContent: z.string(), message: z.string() });
            
            // Define the function schema for functional calling
            const updateSourceFile = [{
              type: "function",
              function: {
                name: "updateSourceFile",
                description: "Return an updated version of the source file content along with a commit message. Use the provided file content, dependency list, build output, test output, and main output to generate the update.",
                parameters: {
                  type: "object",
                  properties: {
                    updatedSourceFileContent: {
                      type: "string",
                      description: "The entire new content of the source file, with all necessary changes applied."
                    },
                    message: {
                      type: "string",
                      description: "A short sentence explaining the change applied suitable for a commit message."
                    }
                  },
                  required: ["updatedSourceFileContent", "message"],
                  additionalProperties: false
                },
                strict: true
              }
            }];
            
            // Call OpenAI using function calling format
            const response = await openai.chat.completions.create({
              model,
              messages: [
                { role: "system", content: "You are a code fixer that returns an updated source file content to resolve issues. Answer strictly with a JSON object that adheres to the provided function schema." },
                { role: "user", content: prompt }
              ],
              tools: updateSourceFile
            });
            
            let fixApplied;
            let result;
            if (response.choices[0].message.tool_calls && response.choices[0].message.tool_calls.length > 0) {
              try {
                result = JSON.parse(response.choices[0].message.tool_calls[0].function.arguments);
              } catch (e) {
                fixApplied = false;
                core.setFailed(`Failed to parse function call arguments: ${e.message}`);
              }
            } else if (response.choices[0].message.content) {
              try {
                result = JSON.parse(response.choices[0].message.content);
              } catch (e) {
                fixApplied = false;
                core.setFailed(`Failed to parse response content: ${e.message}`);
              }
            } else {
              fixApplied = false;
              core.setFailed("No valid response received from OpenAI.");
            }
            
            try {
              const parsed = ResponseSchema.parse(result);
              // Sanitize commit message: retain only alphanumerics, spaces, and basic URL-safe punctuation (-, _, ., ~)
              const sanitizedMessage = parsed.message.replace(/[^A-Za-z0-9 \-\_\.\~]/g, '').replace(/\s+/g, ' ').trim();
              core.setOutput("message", sanitizedMessage);
              core.info(`message: "${sanitizedMessage}"`);
            
              fs.writeFileSync(target, parsed.updatedSourceFileContent, 'utf8');
              core.info(`Target file '${target}' has been updated.`);
            
              fixApplied = true;
            } catch (e) {
              fixApplied = false;
              core.setFailed(`Failed to parse ChatGPT response: ${e.message}`);
            }
            
            core.setOutput("fixApplied", fixApplied);
            core.setOutput("response", JSON.stringify(response));
            core.setOutput("usage", JSON.stringify(response.usage));
            core.info(`fixApplied: "${fixApplied}"`);
            core.info(`response: "${JSON.stringify(response)}"`);
            core.info(`usage: "${JSON.stringify(response.usage)}"`);

      - run: cat ${{ env.target }}

      - name: Examine the git working copy
        shell: bash
        run: |
          git config --local user.email '${{ env.gitUserEmail }}'
          git config --local user.name '${{ env.gitUserName }}'
          git status -v
          git diff ${{ env.target }}

      - name: Commit to new branch
        id: commit
        continue-on-error: true
        run: |
          git config --local user.email '${{ env.gitUserEmail }}'
          git config --local user.name '${{ env.gitUserName }}'
          git status -v
          git switch -c '${{ env.branch }}'
          git add -v --all '${{ env.target }}'
          git diff '${{ env.target }}'
          git commit -m "${{ steps.update-target.outputs.message }}"
          git push --set-upstream origin '${{ env.branch }}' -v
          git status -v

    outputs:
      fixApplied: ${{ steps.update-target.outputs.fixApplied }}
      message: ${{ steps.update-target.outputs.message }}
