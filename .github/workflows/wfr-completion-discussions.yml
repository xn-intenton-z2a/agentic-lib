# .github/workflows/wfr-completion-discussions.yml
#
# agentic-lib
# Copyright (C) 2025 Polycode Limited
#
# This file is part of agentic-lib.
#
# agentic-lib is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License v3.0 (GPL‑3).
# along with this program. If not, see <https://www.gnu.org/licenses/>.
#
# IMPORTANT: Any derived work must include the following attribution:
# "This work is derived from https://github.com/xn-intenton-z2a/agentic-lib"
#

name: ∞ discussions-response

on:
  workflow_call:
    inputs:
      discussionTitle:
        description: 'The title of the discussion'
        required: true
        type: string
      discussionBody:
        description: 'The body of the discussion'
        required: true
        type: string
      discussionUrl:
        description: 'The URL of the discussion'
        required: false
        type: string
        default: ''
      discussionState:
        description: 'The state of the discussion'
        required: false
        type: string
        default: ''
      discussionCategoryName:
        description: 'The category name of the discussion'
        required: false
        type: string
        default: ''
      discussionUserInformation:
        description: 'Information about the discussion user'
        required: false
        type: string
        default: ''
      discussionLabels:
        description: 'The labels of the discussion'
        required: false
        type: string
        default: ''
      discussionReactions:
        description: 'The reactions to the discussion'
        required: false
        type: string
        default: ''
      discussionLabelFilter:
        description: 'Filter discussions by this label'
        required: false
        type: string
        default: 'automated'
      allSourcePaths:
        description: 'The source file(s) to review. e.g. "src/lib/" or multiple files separated by semicolons "src/lib/;src/utils/utils.js"'
        type: string
        required: false
        default: 'src/lib/'
      allTestsPaths:
        description: 'The test file(s) to review. e.g. "tests/unit/" or multiple files separated by semicolons "tests/unit/;tests/utils/utils.test.js"'
        type: string
        required: false
        default: 'tests/unit/'
      documentationPath:
        description: 'The documentation file(s) to write to. e.g. "docs/" or multiple files separated by semicolons "docs/api;docs/API.md"'
        type: string
        required: false
        default: 'docs/'
      readmeFilepath:
        description: 'The README file to review. e.g. "README.md"'
        type: string
        required: false
        default: 'README.md'
      missionFilepath:
        description: 'The MISSION statement file. e.g. "MISSION.md"'
        type: string
        required: false
        default: 'MISSION.md'
      contributingFilepath:
        description: 'The CONTRIBUTING file to review. e.g. "CONTRIBUTING.md"'
        type: string
        required: false
        default: 'CONTRIBUTING.md'
      dependenciesFilepath:
        description: 'The dependencies file to review. e.g. "package.json"'
        type: string
        required: false
        default: 'package.json'
      workflowPathGlob:
        description: 'The workflow path glob to review. e.g. ".github/workflows/agent-*.yml"'
        type: string
        required: false
        default: '.github/workflows/agent-*.yml'
      buildScript:
        description: 'The script must be runnable as: `npm ci ; <script>` and succeed with a zero exit code. e.g. `npm run build`'
        type: string
        required: false
        default: 'echo "No build script specified."'
      testScript:
        description: 'The script must be runnable as: `npm ci ; <script>` and succeed with a zero exit code. e.g. `npm test`'
        type: string
        required: false
        default: 'npm test'
      mainScript:
        description: 'The script must be runnable as: `npm ci ; <script>` and succeed with a zero exit code. e.g. `npm run start`'
        type: string
        required: false
        default: 'npm run start'
      model:
        description: 'The OpenAI model to use. e.g. "o3-mini"'
        type: string
        required: false
        default: ${{ vars.CHATGPT_API_MODEL || 'o4-mini' }}
      promptFilepath:
        description: 'The file containing the prompt text. e.g. ".github/agents/agent-discussion-bot.md"'
        type: string
        required: true
      npmAuthOrganisation:
        description: 'The npm auth organisation to use. e.g. "@xn-intenton-z2a"'
        type: string
        required: false
      lastActivityName:
        description: 'The name of the last activity. e.g. "stats"'
        type: string
        required: false
      lastActivityBranchName:
        description: 'The name of the last activity branch. e.g. "main"'
        type: string
        required: false
      branchPrefix:
        description: 'The prefix for the issue branch. e.g. "agentic-lib-issue-"'
        type: string
        required: false
        default: 'agentic-lib-issue-'
      nextIssue:
        description: 'The next issue to review. e.g. "123 My issue automated"'
        type: string
        required: false
      cache:
        description: 'The cache to use for npm. e.g. "npm"'
        type: string
        required: false
        default: 'npm'
      gitUserEmail:
        description: 'The email to use for git commits. e.g. "action@github.com"'
        type: string
        required: false
        default: 'action@github.com'
      gitUserName:
        description: 'The name to use for git commits. e.g. "GitHub Actions[bot]"'
        type: string
        required: false
        default: 'GitHub Actions[bot]'
      agentConfigContent:
        description: 'The content of the agent config file. e.g. Yaml read from "./github/agents/agent-config.yaml"'
        type: string
        required: false
        default: ''
    secrets:
      PERSONAL_ACCESS_TOKEN:
        required: false
      CHATGPT_API_SECRET_KEY:
        required: true
    outputs:
      action:
        description: 'The action to take. Options: nop, reply-without-action, create-feature, seed-repository'
        value: ${{ jobs.generate-response.outputs.action }}
      detail:
        description: 'The detail of the action (such as the feature title)'
        value: ${{ jobs.generate-response.outputs.detail }}
      reply:
        description: 'The reply to post'
        value: ${{ jobs.generate-response.outputs.reply }}

jobs:
  generate-stats-json:
    uses: xn-intenton-z2a/agentic-lib/.github/workflows/wfr-github-stats-json.yml@main
    with:
      npmAuthOrganisation: ${{ inputs.npmAuthOrganisation || '' }}
      cache: ${{ inputs.cache || 'npm' }}
    secrets:
      PERSONAL_ACCESS_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}

  generate-response:
    needs:
      - generate-stats-json
    runs-on: ubuntu-latest
    env:
      discussionTitle: ${{ inputs.discussionTitle }}
      discussionBody: ${{ inputs.discussionBody }}
      discussionUrl: ${{ inputs.discussionUrl }}
      discussionState: ${{ inputs.discussionState }}
      discussionCategoryName: ${{ inputs.discussionCategoryName }}
      discussionUserInformation: ${{ inputs.discussionUserInformation }}
      discussionLabels: ${{ inputs.discussionLabels }}
      discussionReactions: ${{ inputs.discussionReactions }}
      discussionLabelFilter: ${{ inputs.discussionLabelFilter || 'automated' }}
      allSourcePaths: ${{ inputs.allSourcePaths || 'src/lib/' }}
      allTestsPaths: ${{ inputs.allTestsPaths || 'tests/unit/' }}
      documentationPath: ${{ inputs.documentationPath || 'docs/' }}
      readmeFilepath: ${{ inputs.readmeFilepath || 'README.md' }}
      missionFilepath: ${{ inputs.missionFilepath || 'MISSION.md' }}
      contributingFilepath: ${{ inputs.contributingFilepath || 'CONTRIBUTING.md' }}
      dependenciesFilepath: ${{ inputs.dependenciesFilepath || 'package.json' }}
      workflowPathGlob: ${{ inputs.workflowPathGlob || '.github/workflows/agent-*.yml' }}
      installScript: ${{ 'npm install' }}
      buildScript: ${{ inputs.buildScript || 'echo "No build script specified."' }}
      testScript: ${{ inputs.testScript || 'npm test' }}
      testScriptTimeout: '5m'
      mainScript: ${{ inputs.mainScript || 'npm run start' }}
      mainScriptTimeout: '5m'
      statsJson: ${{ needs.generate-stats-json.outputs.statsJson }}
      model: ${{ inputs.model || 'o4-mini' }}
      chatgptApiSecretKey: ${{ secrets.CHATGPT_API_SECRET_KEY }}
      cache: ${{ inputs.cache || 'npm' }}
      promptFilepath: ${{ inputs.promptFilepath || '.github/agents/agent-discussion-bot.md' }}
      npmAuthOrganisation: ${{ inputs.npmAuthOrganisation || '' }}
      gitUserEmail: ${{ inputs.gitUserEmail || 'action@github.com' }}
      gitUserName: ${{ inputs.gitUserName || 'GitHub Actions[bot]' }}
      agentConfigContent: ${{ inputs.agentConfigContent || '' }}

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.ref }}

      - name: Get latest from remote
        run: |
          git config --local user.email "${{ env.gitUserEmail }}"
          git config --local user.name "${{ env.gitUserName }}"
          git pull --ff-only origin ${{ github.ref }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: ${{ env.cache }}

      - name: Check GitHub authentication
        if: ${{ env.npmAuthOrganisation != '' }}
        shell: bash
        run: |
          curl --include --header "Authorization: token ${{ secrets.PERSONAL_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}" https://api.github.com/user

      - name: Set up .npmrc
        if: ${{ env.npmAuthOrganisation != '' }}
        shell: bash
        run: |
          echo "${{ env.npmAuthOrganisation }}:registry=https://npm.pkg.github.com" >> .npmrc
          echo "//npm.pkg.github.com/:_authToken=${{ secrets.PERSONAL_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}" >> .npmrc
          echo "always-auth=true" >> .npmrc

      - run: npm ci || npm install

      - name: Fetch last 50 commits
        id: commits
        uses: actions/github-script@v7
        with:
          script: |
            try {
              const { execSync } = require('child_process');
              let commits = execSync('git log -n 50 --pretty=format:"Commit: %h%nAuthor: %an <%ae>%nDate: %ad%nMessage: %s%n%n"').toString();

              // Strip conflicting directives by replacing START, END, ", ', ` with "?"
              commits = commits.replace(/START/g, '?')
                              .replace(/END/g, '?')
                              .replace(/"/g, '?')
                              .replace(/'/g, '?')
                              .replace(/`/g, '?');

              core.setOutput('commits', commits);
            } catch (error) {
              core.warning(`Error fetching commits: ${error.message}`);
              core.setOutput('commits', '');
            }

      - name: List all repository files
        id: repo_files
        uses: actions/github-script@v7
        with:
          script: |
            try {
              const { execSync } = require('child_process');
              // List all tracked files in the repository, excluding node_modules
              const files = execSync('git ls-files | grep -v "^node_modules/"').toString().trim();
              const filesList = files.split('\n').join('\n- ');
              const filesOutput = `# Repository Files\n- ${filesList}`;
              core.setOutput('files', filesOutput);
            } catch (error) {
              core.warning(`Error listing repository files: ${error.message}`);
              core.setOutput('files', '');
            }

      - name: List source files
        id: source_files
        uses: actions/github-script@v7
        env:
          allSourcePaths: ${{ env.allSourcePaths }}
        with:
          script: |
            const fs = require('fs');
            const path = require('path');
            const { execSync } = require('child_process');

            try {
              const sourcePaths = process.env.allSourcePaths.split(';');
              let output = "";

              for (const sourcePath of sourcePaths) {
                const trimmedPath = sourcePath.trim();

                try {
                  const stats = fs.statSync(trimmedPath);

                  if (stats.isDirectory()) {
                    // If it's a directory, find all relevant files
                    const fileExtensions = ['.js', '.ts', '.jsx', '.tsx', '.py', '.java', '.go'];
                    const findCommand = `find "${trimmedPath}" -type f ${fileExtensions.map(ext => `-name "*${ext}"`).join(' -o ')} 2>/dev/null`;

                    try {
                      const files = execSync(findCommand).toString().split('\n').filter(Boolean);

                      for (const file of files) {
                        try {
                          const content = fs.readFileSync(file, 'utf8');
                          output += `File: ${file}\n${content}\n\n`;
                        } catch (readError) {
                          core.warning(`Error reading file ${file}: ${readError.message}`);
                        }
                      }
                    } catch (findError) {
                      core.warning(`Error finding files in directory ${trimmedPath}: ${findError.message}`);
                    }
                  } else if (stats.isFile()) {
                    // If it's a file, read it directly
                    try {
                      const content = fs.readFileSync(trimmedPath, 'utf8');
                      output += `File: ${trimmedPath}\n${content}\n\n`;
                    } catch (readError) {
                      core.warning(`Error reading file ${trimmedPath}: ${readError.message}`);
                    }
                  }
                } catch (statError) {
                  core.warning(`Source path '${trimmedPath}' does not exist or cannot be accessed.`);
                }
              }

              core.setOutput('output', output);
            } catch (error) {
              core.warning(`Error processing source files: ${error.message}`);
              core.setOutput('output', '');
            }

      - name: List test files
        id: test_files
        uses: actions/github-script@v7
        env:
          allTestsPaths: ${{ env.allTestsPaths }}
        with:
          script: |
            const fs = require('fs');
            const path = require('path');
            const { execSync } = require('child_process');

            try {
              const testPaths = process.env.allTestsPaths.split(';');
              let output = "";

              for (const testPath of testPaths) {
                const trimmedPath = testPath.trim();

                try {
                  const stats = fs.statSync(trimmedPath);

                  if (stats.isDirectory()) {
                    // If it's a directory, find all relevant test files
                    const fileExtensions = ['.js', '.ts', '.jsx', '.tsx', '.test.js', '.test.ts', '.spec.js', '.spec.ts'];
                    const findCommand = `find "${trimmedPath}" -type f ${fileExtensions.map(ext => `-name "*${ext}"`).join(' -o ')} 2>/dev/null`;

                    try {
                      const files = execSync(findCommand).toString().split('\n').filter(Boolean);

                      for (const file of files) {
                        try {
                          const content = fs.readFileSync(file, 'utf8');
                          output += `File: ${file}\n${content}\n\n`;
                        } catch (readError) {
                          core.warning(`Error reading test file ${file}: ${readError.message}`);
                        }
                      }
                    } catch (findError) {
                      core.warning(`Error finding test files in directory ${trimmedPath}: ${findError.message}`);
                    }
                  } else if (stats.isFile()) {
                    // If it's a file, read it directly
                    try {
                      const content = fs.readFileSync(trimmedPath, 'utf8');
                      output += `File: ${trimmedPath}\n${content}\n\n`;
                    } catch (readError) {
                      core.warning(`Error reading test file ${trimmedPath}: ${readError.message}`);
                    }
                  }
                } catch (statError) {
                  core.warning(`Test path '${trimmedPath}' does not exist or cannot be accessed.`);
                }
              }

              core.setOutput('output', output);
            } catch (error) {
              core.warning(`Error processing test files: ${error.message}`);
              core.setOutput('output', '');
            }

      - name: Read documentation files
        id: docs_files
        uses: actions/github-script@v7
        env:
          documentationPath: ${{ env.documentationPath }}
        with:
          script: |
            const fs = require('fs');
            const path = require('path');
            const { execSync } = require('child_process');

            try {
              const trimmedPath = process.env.documentationPath.trim();
              let output = "";

              try {
                const stats = fs.statSync(trimmedPath);

                if (stats.isDirectory()) {
                  // If it's a directory, find all markdown files
                  const findCommand = `find "${trimmedPath}" -type f -name "*.md" 2>/dev/null`;

                  try {
                    const files = execSync(findCommand).toString().split('\n').filter(Boolean);

                    for (const file of files) {
                      try {
                        const content = fs.readFileSync(file, 'utf8');
                        output += `File: ${file}\n${content}\n\n`;
                      } catch (readError) {
                        core.warning(`Error reading documentation file ${file}: ${readError.message}`);
                      }
                    }
                  } catch (findError) {
                    core.warning(`Error finding documentation files in directory ${trimmedPath}: ${findError.message}`);
                  }
                } else if (stats.isFile()) {
                  // If it's a file, read it directly
                  try {
                    const content = fs.readFileSync(trimmedPath, 'utf8');
                    output += `File: ${trimmedPath}\n${content}\n\n`;
                  } catch (readError) {
                    core.warning(`Error reading documentation file ${trimmedPath}: ${readError.message}`);
                  }
                }
              } catch (statError) {
                core.warning(`Documentation path '${trimmedPath}' does not exist or cannot be accessed.`);
              }

              core.setOutput('output', output);
            } catch (error) {
              core.warning(`Error processing documentation files: ${error.message}`);
              core.setOutput('output', '');
            }

      - name: Read README file
        id: readme
        uses: actions/github-script@v7
        env:
          readmeFilepath: ${{ env.readmeFilepath }}
        with:
          script: |
            const fs = require('fs');

            try {
              const readmeFilepath = process.env.readmeFilepath;

              try {
                const content = fs.readFileSync(readmeFilepath, 'utf8');
                core.setOutput('content', content);
              } catch (error) {
                core.warning(`README file '${readmeFilepath}' does not exist or cannot be read: ${error.message}`);
                core.setOutput('content', '');
              }
            } catch (error) {
              core.warning(`Error processing README file: ${error.message}`);
              core.setOutput('content', '');
            }

      - name: Read MISSION file
        id: mission
        uses: actions/github-script@v7
        env:
          missionFilepath: ${{ env.missionFilepath }}
        with:
          script: |
            const fs = require('fs');

            try {
              const missionFilepath = process.env.missionFilepath;

              try {
                const content = fs.readFileSync(missionFilepath, 'utf8');
                core.setOutput('content', content);
              } catch (error) {
                core.warning(`MISSION file '${missionFilepath}' does not exist or cannot be read: ${error.message}`);
                core.setOutput('content', '');
              }
            } catch (error) {
              core.warning(`Error processing MISSION file: ${error.message}`);
              core.setOutput('content', '');
            }

      - name: Read CONTRIBUTING file
        id: contributing
        uses: actions/github-script@v7
        env:
          contributingFilepath: ${{ env.contributingFilepath }}
        with:
          script: |
            const fs = require('fs');

            try {
              const contributingFilepath = process.env.contributingFilepath;

              try {
                const content = fs.readFileSync(contributingFilepath, 'utf8');
                core.setOutput('content', content);
              } catch (error) {
                core.warning(`CONTRIBUTING file '${contributingFilepath}' does not exist or cannot be read: ${error.message}`);
                core.setOutput('content', '');
              }
            } catch (error) {
              core.warning(`Error processing CONTRIBUTING file: ${error.message}`);
              core.setOutput('content', '');
            }

      - name: Read dependencies file
        id: dependencies
        uses: actions/github-script@v7
        env:
          dependenciesFilepath: ${{ env.dependenciesFilepath }}
        with:
          script: |
            const fs = require('fs');

            try {
              const dependenciesFilepath = process.env.dependenciesFilepath;

              try {
                const content = fs.readFileSync(dependenciesFilepath, 'utf8');
                core.setOutput('content', content);
              } catch (error) {
                core.warning(`Dependencies file '${dependenciesFilepath}' does not exist or cannot be read: ${error.message}`);
                core.setOutput('content', '');
              }
            } catch (error) {
              core.warning(`Error processing dependencies file: ${error.message}`);
              core.setOutput('content', '');
            }

      - name: Read prompt file
        id: prompt
        uses: actions/github-script@v7
        env:
          promptFilepath: ${{ env.promptFilepath }}
        with:
          script: |
            const fs = require('fs');

            try {
              const promptFilepath = process.env.promptFilepath;

              try {
                const content = fs.readFileSync(promptFilepath, 'utf8');
                core.setOutput('content', content);
              } catch (error) {
                core.warning(`Prompt file '${promptFilepath}' does not exist or cannot be read: ${error.message}`);
                core.setOutput('content', '');
              }
            } catch (error) {
              core.warning(`Error processing prompt file: ${error.message}`);
              core.setOutput('content', '');
            }

      - name: Read workflow files
        id: workflow_files
        uses: actions/github-script@v7
        env:
          workflowPathGlob: ${{ env.workflowPathGlob }}
        with:
          script: |
            const fs = require('fs');
            const globMatcher = require('glob');

            try {
              const workflowPathGlob = process.env.workflowPathGlob;
              let output = "";

              // Find all files matching the glob pattern
              const files = globMatcher.sync(workflowPathGlob);

              if (files.length === 0) {
                core.warning(`No workflow files found matching pattern: ${workflowPathGlob}`);
                core.setOutput('content', '');
                return;
              } else {
                core.info(`Found workflow files matching pattern ${workflowPathGlob}: ${files.join(', ')}`);
              }

              for (const file of files) {
                core.info(`Reading workflow file: ${file}`);
                try {
                  let content = fs.readFileSync(file, 'utf8');

                  // Strip conflicting directives by replacing START, END, ", ', ` with "?"
                  content = content.replace(/START/g, '?')
                                  .replace(/END/g, '?')
                                  .replace(/"/g, '?')
                                  .replace(/'/g, '?')
                                  .replace(/`/g, '?');

                  output += `File: ${file}\n${content}\n\n`;
                } catch (error) {
                  core.warning(`Error reading workflow file ${file}: ${error.message}`);
                }
              }

              core.info(`Workflow files content read: ${output.length} characters`);
              core.setOutput('workflowFilesContent', output);
            } catch (error) {
              core.warning(`Error processing workflow files: ${error.message}`);
              core.setOutput('workflowFilesContent', '');
            }

      - name: Install dependencies
        id: install
        shell: bash
        run: |
          set +e
          output=$(${{ env.installScript }} 2>&1)
          echo "output<<EOF" >> "$GITHUB_OUTPUT"
          echo "$output" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          echo "output=${output}"
          exit 0

      - name: Build project
        id: build
        shell: bash
        run: |
          set +e
          output=$(${{ env.buildScript }} 2>&1)
          echo "output<<EOF" >> "$GITHUB_OUTPUT"
          echo "$output" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          echo "output=${output}"
          exit 0

      - name: Run tests
        id: test
        shell: bash
        run: |
          set +e
          output=$(timeout ${{ env.testScriptTimeout }} ${{ env.testScript }} 2>&1)
          echo "output<<EOF" >> "$GITHUB_OUTPUT"
          echo "$output" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          echo "output=${output}"
          exit 0

      - name: Run main
        id: main
        shell: bash
        run: |
          set +e
          output=$(timeout ${{ env.mainScriptTimeout }} ${{ env.mainScript }} 2>&1)
          echo "output<<EOF" >> "$GITHUB_OUTPUT"
          echo "$output" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          echo "output=${output}"
          exit 0

      - name: Generate response
        id: response
        uses: actions/github-script@v7
        env:
          promptContent: ${{ steps.prompt.outputs.content }}
          discussionLabelFilter: ${{ env.discussionLabelFilter }}
          commits: ${{ steps.commits.outputs.commits }}
          repoFiles: ${{ steps.repo_files.outputs.files }}
          sourceFiles: ${{ steps.source_files.outputs.output }}
          testFiles: ${{ steps.test_files.outputs.output }}
          docsFiles: ${{ steps.docs_files.outputs.output }}
          readmeContent: ${{ steps.readme.outputs.content }}
          missionContent: ${{ steps.mission.outputs.content }}
          contributingContent: ${{ steps.contributing.outputs.content }}
          dependenciesContent: ${{ steps.dependencies.outputs.content }}
          workflowFilesContent: ${{ steps.workflow_files.outputs.workflowFilesContent }}
          installOutput: ${{ steps.install.outputs.output }}
          buildOutput: ${{ steps.build.outputs.output }}
          testOutput: ${{ steps.test.outputs.output }}
          mainOutput: ${{ steps.main.outputs.output }}
          statsJson: ${{ needs.generate-stats-json.outputs.statsJson }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const OpenAI = require('openai').default;
            const { z } = require('zod');
            require('dotenv').config();

            const apiKey = process.env.chatgptApiSecretKey;
            if (!apiKey) { 
              core.setFailed("Missing chatgptApiSecretKey");
              return;
            }
            const openai = new OpenAI({ apiKey });

            const discussionTitle = process.env.discussionTitle;
            const discussionBody = process.env.discussionBody;
            const discussionUrl = process.env.discussionUrl;
            const discussionState = process.env.discussionState;
            const discussionCategoryName = process.env.discussionCategoryName;
            const discussionUserInformation = process.env.discussionUserInformation;
            const discussionLabels = process.env.discussionLabels;
            const discussionReactions = process.env.discussionReactions;
            const commits = process.env.commits;
            const repoFiles = process.env.repoFiles;
            const sourceFiles = process.env.sourceFiles;
            const testFiles = process.env.testFiles;
            const docsFiles = process.env.docsFiles;
            const readmeContent = process.env.readmeContent;
            const missionContent = process.env.missionContent;
            const contributingContent = process.env.contributingContent;
            const dependenciesContent = process.env.dependenciesContent;
            const workflowFilesContent = process.env.workflowFilesContent;
            const installScript = process.env.installScript;
            const installOutput = process.env.installOutput;
            const buildScript = process.env.buildScript;
            const buildOutput = process.env.buildOutput;
            const testScript = process.env.testScript;
            const testOutput = process.env.testOutput;
            const mainScript = process.env.mainScript;
            const mainOutput = process.env.mainOutput;
            const statsJson = process.env.statsJson;
            const promptContent = process.env.promptContent;
            const agentConfigContent = process.env.agentConfigContent;
            const model = process.env.model;

            core.info(`Discussion title: ${discussionTitle}`);
            core.info(`Discussion body: ${discussionBody}`);
            core.info(`Discussion URL: ${discussionUrl}`);
            core.info(`Discussion state: ${discussionState}`);
            core.info(`Discussion category name: ${discussionCategoryName}`);
            core.info(`Discussion user information: ${discussionUserInformation}`);
            core.info(`Discussion labels: ${discussionLabels}`);
            core.info(`Discussion reactions: ${discussionReactions}`);
            core.info(`installScript: ${installScript}`);
            core.info(`installOutput: ${installOutput}`);
            core.info(`buildScript: ${buildScript}`);
            core.info(`buildOutput: ${buildOutput}`);
            core.info(`testScript: ${testScript}`);
            core.info(`testOutput: ${testOutput}`);
            core.info(`mainScript: ${mainScript}`);
            core.info(`mainOutput: ${mainOutput}`);
            core.info(`statsJson: ${statsJson}`);

            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const maxCommentsPerDiscussion = 100; // Limit the number of comments per discussion
            const maxDiscussionsPerPage = 100; // Maximum discussions per page in GitHub API
            const labelFilter = process.env.discussionLabelFilter || 'automated';

            core.info(`Filtering discussions by label: ${labelFilter}`);

            let allDiscussionsText;
            try {
              let allDiscussions = [];
              let hasNextPage = true;
              let endCursor = null;

              // Use pagination to fetch all discussions
              while (hasNextPage) {
                // GraphQL query with cursor-based pagination
                const query = `
                  query($owner: String!, $repo: String!, $cursor: String) {
                    repository(owner: $owner, name: $repo) {
                      discussions(first: ${maxDiscussionsPerPage}, after: $cursor, orderBy: {field: CREATED_AT, direction: DESC}) {
                        pageInfo {
                          hasNextPage
                          endCursor
                        }
                        nodes {
                          title
                          number
                          author {
                            login
                          }
                          createdAt
                          url
                          body
                          labels(first: 10) {
                            nodes {
                              name
                            }
                          }
                          comments(first: ${maxCommentsPerDiscussion}) {
                            nodes {
                              author {
                                login
                              }
                              createdAt
                              body
                            }
                          }
                        }
                      }
                    }
                  }
                `;

                const variables = {
                  owner: owner,
                  repo: repo,
                  cursor: endCursor
                };

                const result = await github.graphql(query, variables);

                const pageInfo = result.repository.discussions.pageInfo;
                const discussions = result.repository.discussions.nodes;

                // Filter discussions by label
                const filteredDiscussions = discussions.filter(discussion => {
                  if (!discussion.labels || !discussion.labels.nodes) {
                    return false;
                  }

                  const labels = discussion.labels.nodes.map(label => label.name);
                  return labels.includes(labelFilter);
                });

                core.info(`Filtered ${discussions.length} discussions to ${filteredDiscussions.length} with label '${labelFilter}'`);

                allDiscussions = allDiscussions.concat(filteredDiscussions);

                hasNextPage = pageInfo.hasNextPage;
                endCursor = pageInfo.endCursor;

                // Log progress
                core.info(`Fetched ${discussions.length} discussions, filtered to ${filteredDiscussions.length}. Total so far: ${allDiscussions.length}`);

                // Break if we've fetched all discussions or reached a reasonable limit
                if (!hasNextPage || allDiscussions.length >= 1000) {
                  break;
                }
              }

              let discussionsText = "";
              for (const discussion of allDiscussions) {
                discussionsText += `Discussion: ${discussion.title}\n`;
                discussionsText += `Author: ${discussion.author ? discussion.author.login : 'Unknown'}\n`;
                discussionsText += `Created: ${discussion.createdAt}\n`;
                discussionsText += `URL: ${discussion.url}\n`;
                discussionsText += `Body: ${discussion.body}\n`;

                // Add labels information
                if (discussion.labels && discussion.labels.nodes) {
                  const labels = discussion.labels.nodes.map(label => label.name).join(', ');
                  discussionsText += `Labels: ${labels}\n`;
                }

                // Process comments from GraphQL response
                const comments = discussion.comments.nodes;
                if (comments.length > 0) {
                  discussionsText += "Comments:\n";
                  for (const comment of comments) {
                    discussionsText += `  Author: ${comment.author ? comment.author.login : 'Unknown'}\n`;
                    discussionsText += `  Created: ${comment.createdAt}\n`;
                    discussionsText += `  Body: ${comment.body}\n\n`;
                  }
                }

                discussionsText += "\n---\n\n";
              }

              core.info(`Total discussions fetched and filtered by label '${labelFilter}': ${allDiscussions.length}`);

              // Strip conflicting directives by replacing START, END, ", ', ` with "?"
              discussionsText = discussionsText.replace(/START/g, '?')
                                             .replace(/END/g, '?')
                                             .replace(/"/g, '?')
                                             .replace(/'/g, '?')
                                             .replace(/`/g, '?');

              core.setOutput('allDiscussionsText', discussionsText);
              allDiscussionsText = discussionsText;
            } catch (error) {
              core.warning(`Error fetching discussions: ${error.message}`);
              core.setOutput('allDiscussionsText', '');
              allDiscussionsText = '';
            }

            const chatGptPrompt = `
            ${promptContent}

            Based on the post that you are responding to and in the context of the current GitHub Discussions thread,
            please decide which action to take or none. The discussion contents may be an unmoderated conversation,
            so please use your best judgment to determine the most appropriate action which may be to ignore the discussion.
            The action choices are:
              - nop
              - reply-without-action
              - create-feature
              - seed-repository
              - mission-complete
              - stop
            The detail can be blank if we are re-seeding without changing the mission or the mission statement or a 
            sentence describing the feature.

            And you may reply asking for clarification or more information or stating that action has been taken.
            Explain which action you took and why. If the repository seems to making good progress you may suggest
            waiting (and estimate the time). If the suggested mission or feature is not practical given the capabilities 
            of this repository, please explain why and suggest a more practical mission or feature. If the discussion
            post is non-sensical or spam, please ignore it and take no action by replying with "nop".

            If the goals of the mission have been met you may declare "mission-complete" by choosing the action "mission-complete".
            Similarly, if the repository is not progressing towards the mission you may declare "stop" by choosing the action "stop".

            If the repository has been in a stagnant state for a while, you may suggest to "seed-repository" by choosing the action "seed-repository".

            Consider the following when generating your response:
              * Current discussion <- this is the discussion you are responding to.
              * Previous discussions and comments
              * Recent commits
              * Repository file paths
              * Workflow files content
              * Source file content
              * Test file content
              * Documentation file content
              * README file content
              * MISSION file content
              * Contributing file content
              * Dependencies file content
              * Agent configuration file content
              * Dependency install output
              * Build output
              * Test output
              * Main execution output
              * Stats JSON content

            Current discussion:
            CURRENT_DISCUSSION_START
            Title: ${discussionTitle}
            Body: ${discussionBody}
            URL: ${discussionUrl}
            State: ${discussionState}
            Category: ${discussionCategoryName}
            User: ${discussionUserInformation}
            Labels: ${discussionLabels}
            Reactions: ${discussionReactions}
            CURRENT_DISCUSSION_END

            Previous discussions and comments:
            PREVIOUS_DISCUSSIONS_START
            ${allDiscussionsText}
            PREVIOUS_DISCUSSIONS_END

            Recent commits:
            RECENT_COMMITS_START
            ${commits}
            RECENT_COMMITS_END

            Repository files:
            REPOSITORY_FILES_START
            ${repoFiles}
            REPOSITORY_FILES_END

            Workflow files:
            WORKFLOW_FILES_START
            ${workflowFilesContent}
            WORKFLOW_FILES_END

            Source files:
            SOURCE_FILES_START
            ${sourceFiles}
            SOURCE_FILES_END

            Test files:
            TEST_FILES_START
            ${testFiles}
            TEST_FILES_END

            Documentation files:
            DOCS_FILES_START
            ${docsFiles}
            DOCS_FILES_END

            README file:
            README_FILE_START
            ${readmeContent}
            README_FILE_END

            MISSION file:
            MISSION_FILE_START
            ${missionContent}
            MISSION_FILE_END

            Contributing file:
            CONTRIBUTING_FILE_START
            ${contributingContent}
            CONTRIBUTING_FILE_END

            Dependencies file:
            DEPENDENCIES_FILE_START
            ${dependenciesContent}
            DEPENDENCIES_FILE_END

            Agent configuration file:
            AGENT_CONFIG_FILE_START
            ${agentConfigContent}
            AGENT_CONFIG_FILE_END

            Dependencies install from command: ${installScript}
            DEPENDENCIES_INSTALL_START
            ${installOutput}
            DEPENDENCIES_INSTALL_END    

            Build output from command: ${buildScript}
            BUILD_OUTPUT_START
            ${buildOutput}
            BUILD_OUTPUT_END      

            Test output from command: ${testScript}
            TEST_OUTPUT_START
            ${testOutput}
            TEST_OUTPUT_END            

            Main execution output from command: ${mainScript}
            MAIN_OUTPUT_START
            ${mainOutput}
            MAIN_OUTPUT_END

            Stats JSON content:
            STATS_JSON_START
            ${statsJson}
            STATS_JSON_END

            Answer strictly with a JSON object following this schema:
            {
              "action": "One of: nop, reply-without-action, create-feature, seed-repository, mission-complete, stop", // Pick one
              "detail": "", // Blank if we are re-seeding without changing the mission or the mission statement or a sentence describing the feature.
              "reply": "The text of the reply to post" // The reply to post in the discussion
            }
            Ensure valid JSON.
            `;

            const promptFilePath = 'prompt.txt';
            fs.writeFileSync(promptFilePath, chatGptPrompt);
            core.setOutput("promptFilePath", promptFilePath);
            core.info("promptFilePath: " + promptFilePath);

            const ResponseSchema = z.object({ 
              action: z.string(), 
              detail: z.string(), 
              reply: z.string() 
            });

            // Define the function schema for function calling
            const tools = [{
              type: "function",
              function: {
                name: "generate_discussion_response",
                description: "Generate a response to a discussion post with an appropriate action. Return an object with action, detail, and reply.",
                parameters: {
                  type: "object",
                  properties: {
                    action: { 
                      type: "string", 
                      description: "The action to take. One of: nop, reply-without-action, create-feature, seed-repository, mission-complete, stop" 
                    },
                    detail: { 
                      type: "string", 
                      description: "Blank if we are re-seeding without changing the mission or the mission statement or a sentence describing the feature." 
                    },
                    reply: { 
                      type: "string", 
                      description: "The reply to post in the discussion" 
                    }
                  },
                  required: ["action", "detail", "reply"],
                  additionalProperties: false
                },
                strict: true
              }
            }];

            // Call OpenAI using function calling format
            const request = {
              model,
              messages: [
                { role: "system", content: "You are responding to a GitHub discussion as the voice of the repository. Answer strictly with a JSON object following the provided function schema." },
                { role: "user", content: chatGptPrompt }
              ],
              tools: tools
            });
            
            const requestFilePath = 'request.json';
            fs.writeFileSync(requestFilePath, JSON.stringify(request, null, 2));
            core.setOutput("requestFilePath", requestFilePath);
            core.info("requestFilePath: " + requestFilePath);
            const response = await openai.chat.completions.create(request);
            
            const responseFilePath = 'response.json';
            fs.writeFileSync(responseFilePath, JSON.stringify(response, null, 2));
            core.setOutput("responseFilePath", responseFilePath);
            core.info("responseFilePath: " + responseFilePath);

            let result;
            if (response.choices[0].message.tool_calls && response.choices[0].message.tool_calls.length > 0) {
              try {
                result = JSON.parse(response.choices[0].message.tool_calls[0].function.arguments);
              } catch (e) {
                core.setFailed(`Failed to parse function call arguments: ${e.message}`);
                return;
              }
            } else if (response.choices[0].message.content) {
              try {
                result = JSON.parse(response.choices[0].message.content);
              } catch (e) {
                core.setFailed(`Failed to parse response content: ${e.message}`);
                return;
              }
            } else {
              core.setFailed("No valid response received from OpenAI.");
              return;
            }

            try {
              let parsed;
              try {
                parsed = ResponseSchema.parse(result);
                const resultFilePath = 'result.json';
                fs.writeFileSync(resultFilePath, JSON.stringify(parsed, null, 2));
                core.setOutput("resultFilePath", resultFilePath);
                core.info("resultFilePath: " + resultFilePath);
              } catch (e) {
                core.setFailed(`Failed to parse ChatGPT response: ${e.message}`);
                return;
              }
            
              core.setOutput("action", parsed.action);
              core.setOutput("detail", parsed.detail);
              core.setOutput("reply", parsed.reply);
              core.info(`action: "${parsed.action}"`);
              core.info(`detail: "${parsed.detail}"`);
              core.info(`reply: "${parsed.reply}"`);
            } catch (e) {
              core.setFailed(`Failed to parse ChatGPT response: ${e.message}`);
              return;
            }

            core.setOutput("response", JSON.stringify(response));
            core.setOutput("usage", JSON.stringify(response.usage));
            core.info(`response: "${JSON.stringify(response)}"`);
            core.info(`usage: "${JSON.stringify(response.usage)}"`);

      - name: Tear down .npmrc
        if: ${{ env.npmAuthOrganisation != '' }}
        shell: bash
        run: rm -f .npmrc

      - name: Upload prompt file as an artifact
        if: ${{ !cancelled() }}
        uses: actions/upload-artifact@v4
        with:
          name: response-prompt.txt
          path: ${{ steps.response.outputs.promptFilePath }}
          retention-days: 7

      - name: Upload request file as an artifact
        if: ${{ !cancelled() }}
        uses: actions/upload-artifact@v4
        with:
          name: response-request.json
          path: ${{ steps.response.outputs.requestFilePath }}
          retention-days: 7

      - name: Upload response file as an artifact
        if: ${{ !cancelled() }}
        uses: actions/upload-artifact@v4
        with:
          name: response-response.json
          path: ${{ steps.response.outputs.responseFilePath }}
          retention-days: 7

      - name: Upload result file as an artifact
        if: ${{ !cancelled() }}
        uses: actions/upload-artifact@v4
        with:
          name: response-result.json
          path: ${{ steps.response.outputs.resultFilePath }}

    outputs:
      action: ${{ steps.response.outputs.action }}
      detail: ${{ steps.response.outputs.detail }}
      reply: ${{ steps.response.outputs.reply }}
