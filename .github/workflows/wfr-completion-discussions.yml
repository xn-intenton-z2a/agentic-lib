# .github/workflows/wfr-completion-discussions.yml
#
# agentic-lib
# Copyright (C) 2025 Polycode Limited
#
# This file is part of agentic-lib.
#
# agentic-lib is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License v3.0 (GPL‑3).
# along with this program. If not, see <https://www.gnu.org/licenses/>.
#
# IMPORTANT: Any derived work must include the following attribution:
# "This work is derived from https://github.com/xn-intenton-z2a/agentic-lib"
#

name: ∞ discussions-response

on:
  workflow_call:
    inputs:
      discussionTitle:
        description: 'The title of the discussion'
        required: true
        type: string
      discussionBody:
        description: 'The body of the discussion'
        required: true
        type: string
      discussionUrl:
        description: 'The URL of the discussion'
        required: false
        type: string
        default: ''
      allSourcePaths:
        description: 'The source file(s) to review. e.g. "src/lib/" or multiple files separated by semicolons "src/lib/;src/utils/utils.js"'
        type: string
        required: false
        default: 'src/lib/'
      allTestsPaths:
        description: 'The test file(s) to review. e.g. "tests/unit/" or multiple files separated by semicolons "tests/unit/;tests/utils/utils.test.js"'
        type: string
        required: false
        default: 'tests/unit/'
      documentationPath:
        description: 'The documentation file(s) to write to. e.g. "docs/" or multiple files separated by semicolons "docs/api;docs/API.md"'
        type: string
        required: false
        default: 'docs/'
      readmeFilepath:
        description: 'The README file to review. e.g. "README.md"'
        type: string
        required: false
        default: 'README.md'
      missionFilepath:
        description: 'The MISSION statement file. e.g. "MISSION.md"'
        type: string
        required: false
        default: 'MISSION.md'
      contributingFilepath:
        description: 'The CONTRIBUTING file to review. e.g. "CONTRIBUTING.md"'
        type: string
        required: false
        default: 'CONTRIBUTING.md'
      dependenciesFilepath:
        description: 'The dependencies file to review. e.g. "package.json"'
        type: string
        required: false
        default: 'package.json'
      workflowPathGlob:
        description: 'The workflow path glob to review. e.g. ".github/workflows/agent-*.yml"'
        type: string
        required: false
        default: '.github/workflows/agent-*.yml'
      model:
        description: 'The OpenAI model to use. e.g. "o3-mini"'
        type: string
        required: false
        default: ${{ vars.CHATGPT_API_MODEL || 'o4-mini' }}
      cache:
        description: 'The cache to use for npm. e.g. "npm"'
        type: string
        required: false
        default: 'npm'
      promptFilepath:
        description: 'The file containing the prompt text. e.g. ".github/agents/agent-discussion-bot.md"'
        type: string
        required: true
      npmAuthOrganisation:
        description: 'The GitHub organisation to authenticate with for npm. e.g. "xn-intenton-z2a"'
        type: string
        required: false
        default: ''
      gitUserEmail:
        description: 'The email to use for git commits. e.g. "action@github.com"'
        type: string
        required: false
        default: 'action@github.com'
      gitUserName:
        description: 'The name to use for git commits. e.g. "GitHub Actions[bot]"'
        type: string
        required: false
        default: 'GitHub Actions[bot]'
      agentConfigContent:
        description: 'The content of the agent config file. e.g. Yaml read from "./github/agents/agent-config.yaml"'
        type: string
        required: false
        default: ''
    secrets:
      PERSONAL_ACCESS_TOKEN:
        required: false
      CHATGPT_API_SECRET_KEY:
        required: true
    outputs:
      action:
        description: 'The action to take. Options: nop, reply-without-action, create-issue, create-feature, seed-repository'
        value: ${{ jobs.generate-response.outputs.action }}
      detail:
        description: 'The detail of the action (such as the feature title)'
        value: ${{ jobs.generate-response.outputs.detail }}
      reply:
        description: 'The reply to post'
        value: ${{ jobs.generate-response.outputs.reply }}

jobs:
  generate-response:
    runs-on: ubuntu-latest

    env:
      discussionTitle: ${{ inputs.discussionTitle }}
      discussionBody: ${{ inputs.discussionBody }}
      discussionUrl: ${{ inputs.discussionUrl }}
      allSourcePaths: ${{ inputs.allSourcePaths || 'src/lib/' }}
      allTestsPaths: ${{ inputs.allTestsPaths || 'tests/unit/' }}
      documentationPath: ${{ inputs.documentationPath || 'docs/' }}
      readmeFilepath: ${{ inputs.readmeFilepath || 'README.md' }}
      missionFilepath: ${{ inputs.missionFilepath || 'MISSION.md' }}
      contributingFilepath: ${{ inputs.contributingFilepath || 'CONTRIBUTING.md' }}
      dependenciesFilepath: ${{ inputs.dependenciesFilepath || 'package.json' }}
      model: ${{ inputs.model || 'o4-mini' }}
      chatgptApiSecretKey: ${{ secrets.CHATGPT_API_SECRET_KEY }}
      cache: ${{ inputs.cache || 'npm' }}
      promptFilepath: ${{ inputs.promptFilepath || '.github/agents/agent-discussion-bot.md' }}
      npmAuthOrganisation: ${{ inputs.npmAuthOrganisation || '' }}
      gitUserEmail: ${{ inputs.gitUserEmail || 'action@github.com' }}
      gitUserName: ${{ inputs.gitUserName || 'GitHub Actions[bot]' }}
      agentConfigContent: ${{ inputs.agentConfigContent || '' }}

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.ref }}

      - name: Get latest from remote
        run: |
          git config --local user.email "${{ env.gitUserEmail }}"
          git config --local user.name "${{ env.gitUserName }}"
          git pull --ff-only origin ${{ github.ref }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: ${{ env.cache }}

      - name: Check GitHub authentication
        if: ${{ env.npmAuthOrganisation != '' }}
        shell: bash
        run: |
          curl --include --header "Authorization: token ${{ secrets.PERSONAL_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}" https://api.github.com/user

      - name: Set up .npmrc
        if: ${{ env.npmAuthOrganisation != '' }}
        shell: bash
        run: |
          echo "${{ env.npmAuthOrganisation }}:registry=https://npm.pkg.github.com" >> .npmrc
          echo "//npm.pkg.github.com/:_authToken=${{ secrets.PERSONAL_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}" >> .npmrc
          echo "always-auth=true" >> .npmrc

      - run: npm ci

      - name: Fetch repository discussions
        id: discussions
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            try {
              // Use GraphQL API to fetch repository discussions with comments
              const query = `
                query($owner: String!, $repo: String!) {
                  repository(owner: $owner, name: $repo) {
                    discussions(first: 10, orderBy: {field: CREATED_AT, direction: DESC}) {
                      nodes {
                        title
                        number
                        author {
                          login
                        }
                        createdAt
                        url
                        body
                        comments(first: 10) {
                          nodes {
                            author {
                              login
                            }
                            createdAt
                            body
                          }
                        }
                      }
                    }
                  }
                }
              `;

              const result = await github.graphql(query, {
                owner: owner,
                repo: repo
              });

              const discussions = result.repository.discussions.nodes;

              let discussionsText = "";
              for (const discussion of discussions) {
                discussionsText += `Discussion: ${discussion.title}\n`;
                discussionsText += `Author: ${discussion.author ? discussion.author.login : 'Unknown'}\n`;
                discussionsText += `Created: ${discussion.createdAt}\n`;
                discussionsText += `URL: ${discussion.url}\n`;
                discussionsText += `Body: ${discussion.body}\n`;

                // Process comments from GraphQL response
                const comments = discussion.comments.nodes;
                if (comments.length > 0) {
                  discussionsText += "Comments:\n";
                  for (const comment of comments) {
                    discussionsText += `  Author: ${comment.author ? comment.author.login : 'Unknown'}\n`;
                    discussionsText += `  Created: ${comment.createdAt}\n`;
                    discussionsText += `  Body: ${comment.body}\n\n`;
                  }
                }

                discussionsText += "\n---\n\n";
              }

              core.setOutput('discussions', discussionsText);
            } catch (error) {
              core.warning(`Error fetching discussions: ${error.message}`);
              core.setOutput('discussions', '');
            }

      - name: Fetch last 10 commits
        id: commits
        uses: actions/github-script@v7
        with:
          script: |
            try {
              const { execSync } = require('child_process');
              const commits = execSync('git log -n 10 --pretty=format:"Commit: %h%nAuthor: %an <%ae>%nDate: %ad%nMessage: %s%n%n"').toString();
              core.setOutput('commits', commits);
            } catch (error) {
              core.warning(`Error fetching commits: ${error.message}`);
              core.setOutput('commits', '');
            }

      - name: List all repository files
        id: repo_files
        uses: actions/github-script@v7
        with:
          script: |
            try {
              const { execSync } = require('child_process');
              // List all tracked files in the repository, excluding node_modules
              const files = execSync('git ls-files | grep -v "^node_modules/"').toString().trim();
              const filesList = files.split('\n').join('\n- ');
              const filesOutput = `# Repository Files\n- ${filesList}`;
              core.setOutput('files', filesOutput);
            } catch (error) {
              core.warning(`Error listing repository files: ${error.message}`);
              core.setOutput('files', '');
            }

      - name: List source files
        id: source_files
        uses: actions/github-script@v7
        env:
          allSourcePaths: ${{ env.allSourcePaths }}
        with:
          script: |
            const fs = require('fs');
            const path = require('path');
            const { execSync } = require('child_process');

            try {
              const sourcePaths = process.env.allSourcePaths.split(';');
              let output = "";

              for (const sourcePath of sourcePaths) {
                const trimmedPath = sourcePath.trim();

                try {
                  const stats = fs.statSync(trimmedPath);

                  if (stats.isDirectory()) {
                    // If it's a directory, find all relevant files
                    const fileExtensions = ['.js', '.ts', '.jsx', '.tsx', '.py', '.java', '.go'];
                    const findCommand = `find "${trimmedPath}" -type f ${fileExtensions.map(ext => `-name "*${ext}"`).join(' -o ')} 2>/dev/null`;

                    try {
                      const files = execSync(findCommand).toString().split('\n').filter(Boolean);

                      for (const file of files) {
                        try {
                          const content = fs.readFileSync(file, 'utf8');
                          output += `File: ${file}\n${content}\n\n`;
                        } catch (readError) {
                          core.warning(`Error reading file ${file}: ${readError.message}`);
                        }
                      }
                    } catch (findError) {
                      core.warning(`Error finding files in directory ${trimmedPath}: ${findError.message}`);
                    }
                  } else if (stats.isFile()) {
                    // If it's a file, read it directly
                    try {
                      const content = fs.readFileSync(trimmedPath, 'utf8');
                      output += `File: ${trimmedPath}\n${content}\n\n`;
                    } catch (readError) {
                      core.warning(`Error reading file ${trimmedPath}: ${readError.message}`);
                    }
                  }
                } catch (statError) {
                  core.warning(`Source path '${trimmedPath}' does not exist or cannot be accessed.`);
                }
              }

              core.setOutput('output', output);
            } catch (error) {
              core.warning(`Error processing source files: ${error.message}`);
              core.setOutput('output', '');
            }

      - name: List test files
        id: test_files
        uses: actions/github-script@v7
        env:
          allTestsPaths: ${{ env.allTestsPaths }}
        with:
          script: |
            const fs = require('fs');
            const path = require('path');
            const { execSync } = require('child_process');

            try {
              const testPaths = process.env.allTestsPaths.split(';');
              let output = "";

              for (const testPath of testPaths) {
                const trimmedPath = testPath.trim();

                try {
                  const stats = fs.statSync(trimmedPath);

                  if (stats.isDirectory()) {
                    // If it's a directory, find all relevant test files
                    const fileExtensions = ['.js', '.ts', '.jsx', '.tsx', '.test.js', '.test.ts', '.spec.js', '.spec.ts'];
                    const findCommand = `find "${trimmedPath}" -type f ${fileExtensions.map(ext => `-name "*${ext}"`).join(' -o ')} 2>/dev/null`;

                    try {
                      const files = execSync(findCommand).toString().split('\n').filter(Boolean);

                      for (const file of files) {
                        try {
                          const content = fs.readFileSync(file, 'utf8');
                          output += `File: ${file}\n${content}\n\n`;
                        } catch (readError) {
                          core.warning(`Error reading test file ${file}: ${readError.message}`);
                        }
                      }
                    } catch (findError) {
                      core.warning(`Error finding test files in directory ${trimmedPath}: ${findError.message}`);
                    }
                  } else if (stats.isFile()) {
                    // If it's a file, read it directly
                    try {
                      const content = fs.readFileSync(trimmedPath, 'utf8');
                      output += `File: ${trimmedPath}\n${content}\n\n`;
                    } catch (readError) {
                      core.warning(`Error reading test file ${trimmedPath}: ${readError.message}`);
                    }
                  }
                } catch (statError) {
                  core.warning(`Test path '${trimmedPath}' does not exist or cannot be accessed.`);
                }
              }

              core.setOutput('output', output);
            } catch (error) {
              core.warning(`Error processing test files: ${error.message}`);
              core.setOutput('output', '');
            }

      - name: Read documentation files
        id: docs_files
        uses: actions/github-script@v7
        env:
          documentationPath: ${{ env.documentationPath }}
        with:
          script: |
            const fs = require('fs');
            const path = require('path');
            const { execSync } = require('child_process');

            try {
              const trimmedPath = process.env.documentationPath.trim();
              let output = "";

              try {
                const stats = fs.statSync(trimmedPath);

                if (stats.isDirectory()) {
                  // If it's a directory, find all markdown files
                  const findCommand = `find "${trimmedPath}" -type f -name "*.md" 2>/dev/null`;

                  try {
                    const files = execSync(findCommand).toString().split('\n').filter(Boolean);

                    for (const file of files) {
                      try {
                        const content = fs.readFileSync(file, 'utf8');
                        output += `File: ${file}\n${content}\n\n`;
                      } catch (readError) {
                        core.warning(`Error reading documentation file ${file}: ${readError.message}`);
                      }
                    }
                  } catch (findError) {
                    core.warning(`Error finding documentation files in directory ${trimmedPath}: ${findError.message}`);
                  }
                } else if (stats.isFile()) {
                  // If it's a file, read it directly
                  try {
                    const content = fs.readFileSync(trimmedPath, 'utf8');
                    output += `File: ${trimmedPath}\n${content}\n\n`;
                  } catch (readError) {
                    core.warning(`Error reading documentation file ${trimmedPath}: ${readError.message}`);
                  }
                }
              } catch (statError) {
                core.warning(`Documentation path '${trimmedPath}' does not exist or cannot be accessed.`);
              }

              core.setOutput('output', output);
            } catch (error) {
              core.warning(`Error processing documentation files: ${error.message}`);
              core.setOutput('output', '');
            }

      - name: Read README file
        id: readme
        uses: actions/github-script@v7
        env:
          readmeFilepath: ${{ env.readmeFilepath }}
        with:
          script: |
            const fs = require('fs');

            try {
              const readmeFilepath = process.env.readmeFilepath;

              try {
                const content = fs.readFileSync(readmeFilepath, 'utf8');
                core.setOutput('content', content);
              } catch (error) {
                core.warning(`README file '${readmeFilepath}' does not exist or cannot be read: ${error.message}`);
                core.setOutput('content', '');
              }
            } catch (error) {
              core.warning(`Error processing README file: ${error.message}`);
              core.setOutput('content', '');
            }

      - name: Read MISSION file
        id: mission
        uses: actions/github-script@v7
        env:
          missionFilepath: ${{ env.missionFilepath }}
        with:
          script: |
            const fs = require('fs');

            try {
              const missionFilepath = process.env.missionFilepath;

              try {
                const content = fs.readFileSync(missionFilepath, 'utf8');
                core.setOutput('content', content);
              } catch (error) {
                core.warning(`MISSION file '${missionFilepath}' does not exist or cannot be read: ${error.message}`);
                core.setOutput('content', '');
              }
            } catch (error) {
              core.warning(`Error processing MISSION file: ${error.message}`);
              core.setOutput('content', '');
            }

      - name: Read CONTRIBUTING file
        id: contributing
        uses: actions/github-script@v7
        env:
          contributingFilepath: ${{ env.contributingFilepath }}
        with:
          script: |
            const fs = require('fs');

            try {
              const contributingFilepath = process.env.contributingFilepath;

              try {
                const content = fs.readFileSync(contributingFilepath, 'utf8');
                core.setOutput('content', content);
              } catch (error) {
                core.warning(`CONTRIBUTING file '${contributingFilepath}' does not exist or cannot be read: ${error.message}`);
                core.setOutput('content', '');
              }
            } catch (error) {
              core.warning(`Error processing CONTRIBUTING file: ${error.message}`);
              core.setOutput('content', '');
            }

      - name: Read dependencies file
        id: dependencies
        uses: actions/github-script@v7
        env:
          dependenciesFilepath: ${{ env.dependenciesFilepath }}
        with:
          script: |
            const fs = require('fs');

            try {
              const dependenciesFilepath = process.env.dependenciesFilepath;

              try {
                const content = fs.readFileSync(dependenciesFilepath, 'utf8');
                core.setOutput('content', content);
              } catch (error) {
                core.warning(`Dependencies file '${dependenciesFilepath}' does not exist or cannot be read: ${error.message}`);
                core.setOutput('content', '');
              }
            } catch (error) {
              core.warning(`Error processing dependencies file: ${error.message}`);
              core.setOutput('content', '');
            }

      - name: Read prompt file
        id: prompt
        uses: actions/github-script@v7
        env:
          promptFilepath: ${{ env.promptFilepath }}
        with:
          script: |
            const fs = require('fs');

            try {
              const promptFilepath = process.env.promptFilepath;

              try {
                const content = fs.readFileSync(promptFilepath, 'utf8');
                core.setOutput('content', content);
              } catch (error) {
                core.warning(`Prompt file '${promptFilepath}' does not exist or cannot be read: ${error.message}`);
                core.setOutput('content', '');
              }
            } catch (error) {
              core.warning(`Error processing prompt file: ${error.message}`);
              core.setOutput('content', '');
            }

      - name: Read workflow files
        id: workflow_files
        uses: actions/github-script@v7
        env:
          workflowPathGlob: ${{ env.workflowPathGlob }}
        with:
          script: |
            const fs = require('fs');
            const globMatcher = require('glob');

            try {
              const workflowPathGlob = process.env.workflowPathGlob;
              let output = "";

              // Find all files matching the glob pattern
              const files = globMatcher.sync(workflowPathGlob);

              if (files.length === 0) {
                core.warning(`No workflow files found matching pattern: ${workflowPathGlob}`);
                core.setOutput('content', '');
                return;
              }

              for (const file of files) {
                try {
                  let content = fs.readFileSync(file, 'utf8');

                  // Strip conflicting directives by replacing START, END, ", ', ` with "?"
                  content = content.replace(/START/g, '?')
                                  .replace(/END/g, '?')
                                  .replace(/"/g, '?')
                                  .replace(/'/g, '?')
                                  .replace(/`/g, '?');

                  output += `File: ${file}\n${content}\n\n`;
                } catch (error) {
                  core.warning(`Error reading workflow file ${file}: ${error.message}`);
                }
              }

              core.setOutput('content', output);
            } catch (error) {
              core.warning(`Error processing workflow files: ${error.message}`);
              core.setOutput('content', '');
            }

      - name: Generate response
        id: response
        uses: actions/github-script@v7
        env:
          discussions: ${{ steps.discussions.outputs.discussions }}
          commits: ${{ steps.commits.outputs.commits }}
          repoFiles: ${{ steps.repo_files.outputs.files }}
          sourceFiles: ${{ steps.source_files.outputs.output }}
          testFiles: ${{ steps.test_files.outputs.output }}
          docsFiles: ${{ steps.docs_files.outputs.output }}
          readmeContent: ${{ steps.readme.outputs.content }}
          missionContent: ${{ steps.mission.outputs.content }}
          contributingContent: ${{ steps.contributing.outputs.content }}
          dependenciesContent: ${{ steps.dependencies.outputs.content }}
          workflowFilesContent: ${{ steps.workflow_files.outputs.content }}
          promptContent: ${{ steps.prompt.outputs.content }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const OpenAI = require('openai').default;
            const { z } = require('zod');
            require('dotenv').config();

            const apiKey = process.env.chatgptApiSecretKey;
            if (!apiKey) { 
              core.setFailed("Missing chatgptApiSecretKey"); 
            }
            const openai = new OpenAI({ apiKey });

            const discussionTitle = process.env.discussionTitle;
            const discussionBody = process.env.discussionBody;
            const discussionUrl = process.env.discussionUrl;
            const discussions = process.env.discussions;
            const commits = process.env.commits;
            const repoFiles = process.env.repoFiles;
            const sourceFiles = process.env.sourceFiles;
            const testFiles = process.env.testFiles;
            const docsFiles = process.env.docsFiles;
            const readmeContent = process.env.readmeContent;
            const missionContent = process.env.missionContent;
            const contributingContent = process.env.contributingContent;
            const dependenciesContent = process.env.dependenciesContent;
            const workflowFilesContent = process.env.workflowFilesContent;
            const promptContent = process.env.promptContent;
            const agentConfigContent = process.env.agentConfigContent;
            const model = process.env.model;

            core.info(`Discussion title: ${discussionTitle}`);
            core.info(`Discussion body: ${discussionBody}`);
            core.info(`Discussion URL: ${discussionUrl}`);

            const chatGptPrompt = `
            ${promptContent}

            Based on the post that you are responding to and in the context of the current GitHub Discussions thread,
            please decide which action to take or none. The discussion contents may be an unmoderated conversation,
            so please use your best judgment to determine the most appropriate action which maybe to ignore the discussion.
            The action choices are:
              - nop
              - reply-without-action
              - create-issue
              - create-feature
              - seed-repository
            You may also include the detail of the action (such as the feature title).
            And you may reply asking for clarification or more information or stating that action has been taken.
            Explain which action you took and why.

            Consider the following when generating your response:
              * Current discussion
              * Previous discussions and comments
              * Recent commits
              * Repository file paths
              * Workflow files content
              * Source file content
              * Test file content
              * Documentation file content
              * README file content
              * MISSION file content
              * Contributing file content
              * Dependencies file content
              * Agent configuration file content

            Current discussion:
            CURRENT_DISCUSSION_START
            Title: ${discussionTitle}
            Body: ${discussionBody}
            URL: ${discussionUrl}
            CURRENT_DISCUSSION_END

            Previous discussions and comments:
            PREVIOUS_DISCUSSIONS_START
            ${discussions}
            PREVIOUS_DISCUSSIONS_END

            Recent commits:
            RECENT_COMMITS_START
            ${commits}
            RECENT_COMMITS_END

            Repository files:
            REPOSITORY_FILES_START
            ${repoFiles}
            REPOSITORY_FILES_END

            Workflow files:
            WORKFLOW_FILES_START
            ${workflowFilesContent}
            WORKFLOW_FILES_END

            Source files:
            SOURCE_FILES_START
            ${sourceFiles}
            SOURCE_FILES_END

            Test files:
            TEST_FILES_START
            ${testFiles}
            TEST_FILES_END

            Documentation files:
            DOCS_FILES_START
            ${docsFiles}
            DOCS_FILES_END

            README file:
            README_FILE_START
            ${readmeContent}
            README_FILE_END

            MISSION file:
            MISSION_FILE_START
            ${missionContent}
            MISSION_FILE_END

            Contributing file:
            CONTRIBUTING_FILE_START
            ${contributingContent}
            CONTRIBUTING_FILE_END

            Dependencies file:
            DEPENDENCIES_FILE_START
            ${dependenciesContent}
            DEPENDENCIES_FILE_END

            Agent configuration file:
            AGENT_CONFIG_FILE_START
            ${agentConfigContent}
            AGENT_CONFIG_FILE_END

            Answer strictly with a JSON object following this schema:
            {
              "action": "One of: nop, reply-without-action, create-issue, create-feature, seed-repository", // Pick one
              "detail": "The detail of the action", // For example, the feature title or issue description
              "reply": "The reply to post" // The reply to post in the discussion
            }
            Ensure valid JSON.
            `;

            core.info("prompt start: **********************************************");
            core.info(`${chatGptPrompt}`);
            core.info("prompt end:   **********************************************");

            const ResponseSchema = z.object({ 
              action: z.string(), 
              detail: z.string(), 
              reply: z.string() 
            });

            // Define the function schema for function calling
            const tools = [{
              type: "function",
              function: {
                name: "generate_discussion_response",
                description: "Generate a response to a discussion post with an appropriate action. Return an object with action, detail, and reply.",
                parameters: {
                  type: "object",
                  properties: {
                    action: { 
                      type: "string", 
                      description: "The action to take. One of: 'nop', 'reply-without-action', 'create-issue', 'create-feature', 'seed-repository'" 
                    },
                    detail: { 
                      type: "string", 
                      description: "The detail of the action (such as the feature title or issue description)" 
                    },
                    reply: { 
                      type: "string", 
                      description: "The reply to post in the discussion" 
                    }
                  },
                  required: ["action", "detail", "reply"],
                  additionalProperties: false
                },
                strict: true
              }
            }];

            // Call OpenAI using function calling format
            const response = await openai.chat.completions.create({
              model,
              messages: [
                { role: "system", content: "You are responding to a GitHub discussion as the voice of the repository. Answer strictly with a JSON object following the provided function schema." },
                { role: "user", content: chatGptPrompt }
              ],
              tools: tools
            });

            let result;
            if (response.choices[0].message.tool_calls && response.choices[0].message.tool_calls.length > 0) {
              try {
                result = JSON.parse(response.choices[0].message.tool_calls[0].function.arguments);
              } catch (e) {
                core.setFailed(`Failed to parse function call arguments: ${e.message}`);
              }
            } else if (response.choices[0].message.content) {
              try {
                result = JSON.parse(response.choices[0].message.content);
              } catch (e) {
                core.setFailed(`Failed to parse response content: ${e.message}`);
              }
            } else {
              core.setFailed("No valid response received from OpenAI.");
            }

            try {
              core.info("raw response start: **********************************************");
              core.info(`raw response: "${JSON.stringify(result)}"`);
              core.info("raw response end: ************************************************");
              const parsed = ResponseSchema.parse(result);
              core.info(`parsed response: "${JSON.stringify(parsed)}"`);
              core.setOutput("action", parsed.action);
              core.setOutput("detail", parsed.detail);
              core.setOutput("reply", parsed.reply);
              core.info(`action: "${parsed.action}"`);
              core.info(`detail: "${parsed.detail}"`);
              core.info(`reply: "${parsed.reply}"`);
            } catch (e) {
              core.setFailed(`Failed to parse ChatGPT response: ${e.message}`);
            }

            core.setOutput("response", JSON.stringify(response));
            core.setOutput("usage", JSON.stringify(response.usage));
            core.info(`response: "${JSON.stringify(response)}"`);
            core.info(`usage: "${JSON.stringify(response.usage)}"`);

      - name: Tear down .npmrc
        if: ${{ env.npmAuthOrganisation != '' }}
        shell: bash
        run: rm -f .npmrc

    outputs:
      action: ${{ steps.response.outputs.action }}
      detail: ${{ steps.response.outputs.detail }}
      reply: ${{ steps.response.outputs.reply }}
