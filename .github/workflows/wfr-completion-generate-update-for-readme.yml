# .github/workflows/wfr-completion-generate-update-for-readme.yml
#
# agentic-lib
# Copyright (C) 2025 Polycode Limited
#
# This file is part of agentic-lib.
#
# agentic-lib is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License v3.0 (GPL‑3).
# along with this program. If not, see <https://www.gnu.org/licenses/>.
#
# IMPORTANT: Any derived work must include the following attribution:
# "This work is derived from https://github.com/xn-intenton-z2a/agentic-lib"
#

name: ∞ wfr-update-readme

on:
  workflow_call:
    inputs:
      featuresPath:
        description: 'The directory to create/update the features in. e.g. "features/"'
        type: string
        required: false
        default: 'features/'
      allSourcePaths:
        description: 'The source file(s) to review (for context only). e.g. "src/lib/" or multiple files separated by semicolons "src/lib/;src/utils/utils.js"'
        type: string
        required: false
        default: 'src/lib/'
      allTestsPaths:
        description: 'The test file(s) to review (for context only). e.g. "tests/unit/" or multiple files separated by semicolons "tests/unit/;tests/utils/utils.test.js"'
        type: string
        required: false
        default: 'tests/unit/'
      documentationPath:
        description: 'The documentation file(s) to write to. e.g. "docs/" or multiple files separated by semicolons "docs/api;docs/API.md"'
        type: string
        required: false
        default: 'docs/'
      readmeFilepath:
        description: 'The README file to update. e.g. "README.md"'
        type: string
        required: false
        default: 'README.md'
      missionFilepath:
        description: 'The MISSION statement file. e.g. "MISSION.md"'
        type: string
        required: false
        default: 'MISSION.md'
      contributingFilepath:
        description: 'The CONTRIBUTING file to review. e.g. "CONTRIBUTING.md"'
        type: string
        required: false
        default: 'CONTRIBUTING.md'
      dependenciesFilepath:
        description: 'The dependencies file to review. e.g. "package.json"'
        type: string
        required: false
        default: 'package.json'
      formattingFilepath:
        description: 'The formatting file to review. e.g. ".prettierrc"'
        type: string
        required: false
        default: '.prettierrc'
      lintingFilepath:
        description: 'The linting file to review. e.g. "eslint.config.js"'
        type: string
        required: false
        default: 'eslint.config.js'
      intentionFilepath:
        description: 'The intention file to review. e.g. "intentïon.md"'
        type: string
        required: false
        default: 'intentïon.md'
      buildScript:
        description: 'The script must be runnable as: `npm ci ; <script>` and succeed with a zero exit code. e.g. `npm run build`'
        type: string
        required: false
        default: 'echo "No build script specified."'
      testScript:
        description: 'The script must be runnable as: `npm ci ; <script>` and succeed with a zero exit code. e.g. `npm test`'
        type: string
        required: false
        default: 'npm test'
      mainScript:
        description: 'The script must be runnable as: `npm ci ; <script>` and succeed with a zero exit code. e.g. `npm run start`'
        type: string
        required: false
        default: 'npm run start'
      model:
        description: 'The OpenAI model to use. e.g. "o3-mini"'
        type: string
        required: false
        default: ${{ vars.CHATGPT_API_MODEL || 'o4-mini' }}
      branch:
        description: 'The branch to use for the update. e.g. "agentic-lib-issue-123"'
        type: string
        required: false
        default: ${{ github.ref }}
      npmAuthOrganisation:
        description: 'The GitHub organisation to authenticate with for npm. e.g. "xn-intenton-z2a"'
        type: string
        required: false
        default: ''
      gitUserEmail:
        description: 'The email to use for git commits. e.g. "action@github.com"'
        type: string
        required: false
        default: 'action@github.com'
      gitUserName:
        description: 'The name to use for git commits. e.g. "GitHub Actions[bot]"'
        type: string
        required: false
        default: 'GitHub Actions[bot]'
      cache:
        description: 'The cache to use for npm. e.g. "npm"'
        type: string
        required: false
        default: 'npm'
      promptFilepath:
        description: 'The file containing the prompt text. e.g. ".github/agents/agent-ready-issue.md"'
        type: string
        required: true
      s3BucketUrl:
        description: 'The S3 bucket URL with prefix to use. e.g. "s3://my-bucket/prefix"'
        type: string
        required: false
        default: ''
      iamRoleArn:
        description: 'The ARN of the IAM role to assume. e.g. "arn:aws:iam::123456789012:role/my-role"'
        type: string
        required: false
        default: ''
      agentConfigContent:
        description: 'The content of the agent config file. e.g. Yaml read from "./github/agents/agent-config.yaml"'
        type: string
        required: false
        default: ''
      writeableFilepaths:
        description: 'Semicolon-separated list of file paths that can be written by the workflow. e.g. "elaborator-sandbox/SOURCES.md;elaborator-sandbox/library/;engineer-sandbox/features/;engineer-sandbox/source/;engineer-sandbox/tests/;engineer-sandbox/docs/"'
        type: string
        required: false
        default: ''
    secrets:
      PERSONAL_ACCESS_TOKEN:
        required: false
      CHATGPT_API_SECRET_KEY:
        required: true
    outputs:
      updateApplied:
        value: ${{ jobs.apply-update.outputs.updateApplied }}
      message:
        value: ${{ jobs.apply-update.outputs.message }}
      installAfterUpdateOutcome:
        value: ${{ jobs.apply-update.outputs.installAfterUpdateOutcome }}
      ciAfterUpdateOutcome:
        value: ${{ jobs.apply-update.outputs.ciAfterUpdateOutcome }}
      testAfterUpdateOutcome:
        value: ${{ jobs.apply-update.outputs.testAfterUpdateOutcome }}
      mainAfterUpdateOutcome:
        value: ${{ jobs.apply-update.outputs.mainAfterUpdateOutcome }}
      commitOutcome:
        value: ${{ jobs.apply-update.outputs.commitOutcome }}
      postResolutionCommentOutcome:
        value: ${{ jobs.start-issue.outputs.postResolutionCommentOutcome }}
      allValidationStepsSuccessful:
        value: ${{ jobs.start-issue.outputs.allValidationStepsSuccessful }}
      gitDiff:
        description: 'The changes applied as seen by a git diff of the workspace after the changes were applied'
        value: ${{ jobs.apply-update.outputs.gitDiff }}
      usage:
        description: 'The LLM API usage of the action'
        value: ${{ jobs.apply-update.outputs.usage }}

jobs:
  apply-update:
    runs-on: ubuntu-latest

    env:
      featuresPath: ${{ inputs.featuresPath || 'features/' }}
      allSourcePaths: ${{ inputs.allSourcePaths || '' }}
      allTestsPaths: ${{ inputs.allTestsPaths || '' }}
      documentationPath: ${{ inputs.documentationPath || '' }}
      readmeFilepath: ${{ inputs.readmeFilepath || 'README.md' }}
      missionFilepath: ${{ inputs.missionFilepath || 'MISSION.md' }}
      contributingFilepath: ${{ inputs.contributingFilepath || 'CONTRIBUTING.md' }}
      dependenciesFilepath: ${{ inputs.dependenciesFilepath || 'package.json' }}
      formattingFilepath: ${{ inputs.formattingFilepath || '.prettierrc' }}
      lintingFilepath: ${{ inputs.lintingFilepath || 'eslint.config.js' }}
      intentionFilepath: ${{ inputs.intentionFilepath || 'intentïon.md' }}
      buildScript: ${{ inputs.buildScript || 'npm run build' }}
      testScript: ${{ inputs.testScript || 'npm test' }}
      testScriptTimeout: '5m'
      mainScript: ${{ inputs.mainScript || 'npm run start' }}
      mainScriptTimeout: '5m'
      model: ${{ inputs.model || vars.CHATGPT_API_MODEL || 'o4-mini' }}
      chatgptApiSecretKey: ${{ secrets.CHATGPT_API_SECRET_KEY }}
      npmAuthOrganisation: ${{ inputs.npmAuthOrganisation || '' }}
      branch: ${{ inputs.branch || github.ref }}
      gitUserEmail: ${{ inputs.gitUserEmail || 'action@github.com' }}
      gitUserName: ${{ inputs.gitUserName || 'GitHub Actions[bot]' }}
      cache: ${{ inputs.cache || 'npm' }}
      promptFilepath: ${{ inputs.promptFilepath || '.github/agents/agent-update-readme.md' }}
      s3BucketUrl: ${{ inputs.s3BucketUrl || '' }}
      iamRoleArn: ${{ inputs.iamRoleArn || '' }}
      agentConfigContent: ${{ inputs.agentConfigContent || '' }}
      writeableFilepaths: ${{ inputs.writeableFilepaths || '' }}

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ env.branch }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: ${{ env.cache }}

      - name: Check GitHub authentication
        if: ${{ env.npmAuthOrganisation != '' }}
        shell: bash
        run: |
          curl --include --header "Authorization: token ${{ secrets.PERSONAL_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}" https://api.github.com/user

      - name: Set up .npmrc
        if: ${{ env.npmAuthOrganisation != '' }}
        shell: bash
        run: |
          echo "${{ env.npmAuthOrganisation }}:registry=https://npm.pkg.github.com" >> .npmrc
          echo "//npm.pkg.github.com/:_authToken=${{ secrets.PERSONAL_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}" >> .npmrc
          echo "always-auth=true" >> .npmrc

      - name: List current features
        id: features
        shell: bash
        run: |
          output=$(find "${{ env.featuresPath }}" -maxdepth 1 -type f -name '*.md' -print -exec echo "# {}" \; -exec cat {} \; 2>&1 || echo 'none')
          echo "output<<EOF" >> "$GITHUB_OUTPUT"
          echo "$output" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          echo "output=${output}"

      - name: Install dependencies
        id: install
        shell: bash
        run: |
          set +e
          output=$(npm install 2>&1)
          echo "output<<EOF" >> "$GITHUB_OUTPUT"
          echo "$output" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          echo "output=${output}"
          exit 0

      - name: Build project
        id: build
        shell: bash
        run: |
          set +e
          output=$(${{ env.buildScript }} 2>&1)
          echo "output<<EOF" >> "$GITHUB_OUTPUT"
          echo "$output" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          echo "output=${output}"
          exit 0

      - name: Tear down .npmrc
        if: ${{ env.npmAuthOrganisation != '' }}
        shell: bash
        run: rm -f .npmrc

      - name: Run tests
        id: test
        shell: bash
        run: |
          set +e
          output=$(timeout ${{ env.testScriptTimeout }} ${{ env.testScript }} 2>&1)
          echo "output<<EOF" >> "$GITHUB_OUTPUT"
          echo "$output" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          echo "output=${output}"
          exit 0

      - name: Run main
        id: main
        shell: bash
        run: |
          set +e
          output=$(timeout ${{ env.mainScriptTimeout }} ${{ env.mainScript }} 2>&1)
          echo "output<<EOF" >> "$GITHUB_OUTPUT"
          echo "$output" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          echo "output=${output}"
          exit 0

      - name: update-readme
        id: update-readme
        uses: actions/github-script@v7
        env:
          installOutput: ${{ steps.install.outputs.output }}
          buildOutput: ${{ steps.build.outputs.output }}
          testOutput: ${{ steps.test.outputs.output }}
          mainOutput: ${{ steps.main.outputs.output }}
          currentFeatures: ${{ steps.features.outputs.output }}
        with:
          github-token: ${{ secrets.PERSONAL_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}
          script: |
            const currentFeatures = process.env.currentFeatures;
            const allSourcePaths = process.env.allSourcePaths;
            const allTestsPaths = process.env.allTestsPaths;
            const readmeFilepath = process.env.readmeFilepath;
            const missionFilepath = process.env.missionFilepath;
            const contributingFilepath = process.env.contributingFilepath;
            const dependenciesFilepath = process.env.dependenciesFilepath;
            const formattingFilepath = process.env.formattingFilepath;
            const lintingFilepath = process.env.lintingFilepath;
            const documentationPath = process.env.documentationPath.replace(/\/+$/, '');
            const model = process.env.model;
            const apiKey = process.env.chatgptApiSecretKey;
            const promptFilepath = process.env.promptFilepath;
            const installOutput = process.env.installOutput;
            const dependenciesListOutput = process.env.dependenciesListOutput;
            const intentionFilepath = process.env.intentionFilepath;
            const buildScript = process.env.buildScript;
            const buildOutput = process.env.buildOutput;
            const testScript = process.env.testScript;
            const testOutput = process.env.testOutput;
            const mainScript = process.env.mainScript;
            const mainOutput = process.env.mainOutput;
            const agentConfigContent = process.env.agentConfigContent;
            const writeableFilepaths = process.env.writeableFilepaths;

            const fs = require('fs');
            const path = require('path');
            const OpenAI = require('openai').default;
            const { z } = require('zod');
            const { minimatch } = require('minimatch');
            require('dotenv').config();

            // Function to check if a file path matches any of the allowed patterns
            function isFilePathAllowed(filePath, writeableFilepaths) {
              // Ensure writeableFilepaths is an array
              const patterns = Array.isArray(writeableFilepaths) ? writeableFilepaths : String(writeableFilepaths).split(',');
              core.info(`Checking if file path '${filePath}' is allowed in writeableFilepaths: ${patterns}`);
              return patterns.some(pattern => (
                minimatch(filePath, pattern.trim()) || 
                minimatch(filePath, `${pattern.trim()}*`) || 
                minimatch(filePath, `${pattern.trim()}**`) || 
                minimatch(filePath, `${pattern.trim()}/**`)
              ));
            }

            if (!apiKey) { 
              core.setFailed("Missing CHATGPT_API_SECRET_KEY");
              return;
            }
            const openai = new OpenAI({ apiKey });

            core.info(`currentFeatures: "${currentFeatures}"`);
            core.info(`allSourcePaths: "${allSourcePaths}"`);
            core.info(`allTestsPaths: "${allTestsPaths}"`);
            core.info(`readmeFilepath: "${readmeFilepath}"`);
            core.info(`missionFilepath: "${missionFilepath}"`);
            core.info(`contributingFilepath: "${contributingFilepath}"`);
            core.info(`dependenciesFilepath: "${dependenciesFilepath}"`);
            core.info(`formattingFilepath: "${formattingFilepath}"`);
            core.info(`lintingFilepath: "${lintingFilepath}"`);
            core.info(`agentConfigContent: "${agentConfigContent}"`);
            core.info(`writeableFilepaths: "${writeableFilepaths}"`);

            function isWriteable(filepath) {
              const patterns = writeableFilepaths.split(';').map(file => file.trim());
              core.info(`Checking if writing to filepath '${filepath}' is allowed in writeableFilepaths: ${patterns}`);
              return patterns.some(pattern => (
                minimatch(filepath, pattern) || 
                minimatch(filepath, `${pattern}*`) || 
                minimatch(filepath, `${pattern}**`) || 
                minimatch(filepath, `${pattern}/**`)
              ));
            }

            // Handle multiple source files (for context only)
            const srcFiles = allSourcePaths.split(';');
            let sourceFileContents = {};
            for (const file of srcFiles) {
              try {
                const trimmedFile = file.trim();
                if (fs.existsSync(trimmedFile)) {
                  const stats = fs.statSync(trimmedFile);
                  if (stats.isDirectory()) {
                    // If it's a directory, read all files in the directory
                    const files = fs.readdirSync(trimmedFile);
                    for (const subFile of files) {
                      const fullPath = path.join(trimmedFile, subFile);
                      if (fs.statSync(fullPath).isFile()) {
                        sourceFileContents[fullPath] = fs.readFileSync(fullPath, 'utf8');
                        core.info(`Source file '${fullPath}' from directory has been loaded (length ${sourceFileContents[fullPath].length}).`);
                      }
                    }
                  } else {
                    // It's a file, read it directly
                    sourceFileContents[trimmedFile] = fs.readFileSync(trimmedFile, 'utf8');
                    core.info(`Source file '${trimmedFile}' has been loaded (length ${sourceFileContents[trimmedFile].length}).`);
                  }
                } else {
                  core.warning(`Source file '${trimmedFile}' does not exist.`);
                }
              } catch (e) {
                core.warning(`Error reading source file '${file}': ${e.message}`);
              }
            }

            // Handle multiple test files (for context only)
            const testFiles = allTestsPaths.split(';');
            let testsFileContents = {};
            for (const file of testFiles) {
              try {
                const trimmedFile = file.trim();
                if (fs.existsSync(trimmedFile)) {
                  const stats = fs.statSync(trimmedFile);
                  if (stats.isDirectory()) {
                    // If it's a directory, read all files in the directory
                    const files = fs.readdirSync(trimmedFile);
                    for (const subFile of files) {
                      const fullPath = path.join(trimmedFile, subFile);
                      if (fs.statSync(fullPath).isFile()) {
                        testsFileContents[fullPath] = fs.readFileSync(fullPath, 'utf8');
                        core.info(`Test file '${fullPath}' from directory has been loaded (length ${testsFileContents[fullPath].length}).`);
                      }
                    }
                  } else {
                    // It's a file, read it directly
                    testsFileContents[trimmedFile] = fs.readFileSync(trimmedFile, 'utf8');
                    core.info(`Test file '${trimmedFile}' has been loaded (length ${testsFileContents[trimmedFile].length}).`);
                  }
                } else {
                  core.warning(`Test file '${trimmedFile}' does not exist.`);
                }
              } catch (e) {
                core.warning(`Error reading test file '${file}': ${e.message}`);
              }
            }

            let readmeFilepathContent;
            try {
              readmeFilepathContent = fs.readFileSync(readmeFilepath, 'utf8');
            } catch (e) {
              core.warning(`Error reading README file '${readmeFilepath}': ${e.message}`);
              readmeFilepathContent = '';
            }

            // Handle documents path to file or directory
            let docsFileContents = {};
            try {
              const trimmedFile = documentationPath.trim();
              if (fs.existsSync(trimmedFile)) {
                const stats = fs.statSync(trimmedFile);
                if (stats.isDirectory()) {
                  // If it's a directory, read all files in the directory
                  const files = fs.readdirSync(trimmedFile);
                  for (const subFile of files) {
                    const fullPath = path.join(trimmedFile, subFile);
                    if (fs.statSync(fullPath).isFile()) {
                      docsFileContents[fullPath] = fs.readFileSync(fullPath, 'utf8');
                      core.info(`Docs file '${fullPath}' from directory has been loaded (length ${docsFileContents[fullPath].length}).`);
                    }
                  }
                } else {
                  // It's a file, read it directly
                  docsFileContents[trimmedFile] = fs.readFileSync(trimmedFile, 'utf8');
                  core.info(`Docs file '${trimmedFile}' has been loaded (length ${docsFileContents[trimmedFile].length}).`);
                }
              } else {
                // Create directory if it doesn't exist
                const docsDir = path.dirname(trimmedFile);
                if (!fs.existsSync(docsDir)) {
                  fs.mkdirSync(docsDir, { recursive: true });
                }
                docsFileContents[trimmedFile] = '';
                core.info(`Docs file '${trimmedFile}' does not exist and will be created.`);
              }
            } catch (e) {
              core.warning(`Error reading docs file '${file}': ${e.message}`);
            }

            let missionFilepathContent;
            try {
              missionFilepathContent = fs.readFileSync(missionFilepath, 'utf8');
            } catch (e) {
                core.warning(`Error reading MISSION file '${missionFilepath}': ${e.message}`);
                missionFilepathContent = '';
            }

            let contributingFilepathContent;
            try {
              contributingFilepathContent = fs.readFileSync(contributingFilepath, 'utf8');
            } catch (e) {
              core.warning(`Error reading CONTRIBUTING file '${contributingFilepath}': ${e.message}`);
              contributingFilepathContent = '';
            }

             let dependenciesFilepathContent;
            try {
              dependenciesFilepathContent = fs.readFileSync(dependenciesFilepath, 'utf8');
            } catch (e) {
              core.warning(`Error reading dependencies file '${dependenciesFilepath}': ${e.message}`);
              dependenciesFilepathContent = '';
            }

            let promptContent;
            try {
              promptContent = fs.readFileSync(promptFilepath, 'utf8');
            } catch (e) {
              core.warning(`Error reading prompt file '${promptFilepath}': ${e.message}`);
              promptContent = '';
            }

            core.info(`Readme file '${readmeFilepath}' has been loaded (length ${readmeFilepathContent.length}).`);
            core.info(`Mission file '${missionFilepath}' has been loaded (length ${missionFilepathContent.length}).`);
            core.info(`Contributing file '${contributingFilepath}' has been loaded (length ${contributingFilepathContent.length}).`);
            core.info(`Dependencies file '${dependenciesFilepath}' has been loaded (length ${dependenciesFilepathContent.length}).`);
            core.info(`Prompt file '${promptFilepath}' has been loaded (length ${promptContent.length}).`);

            // intention Filepath contents 
            let intentionContent = '';
            try {
              const intentionFilepath = process.env.intentionFilepath;
              if (fs.existsSync(intentionFilepath)) {
                intentionContent = fs.readFileSync(intentionFilepath, 'utf8');
                core.info(`Intention file content: ${intentionContent}`);
              } else {
                core.warning(`Intention file '${intentionFilepath}' does not exist.`);
              }
            } catch (error) {
              core.warning(`Error reading intention file: ${error.message}`);
            }

            const chatGptPrompt = `
            ${promptContent}
            
            The intentïon file contents is a log of both taken in the repository since the last repository seed and you
            should see an alignment between the intentïon file entries and commits in the repository (where a commit is required).
            Use this log to determine the current direction of the repository towards its mission. The combination of the
            repository code, tests, dependencies and supporting documentation show the current state of the repository.

            Consider the following when refining your response:
              * Current feature names and specifications in the repository
              * intentïon file contents
              * Source file content (for context only)
              * Test file content (for context only)
              * Documentation file content
              * README file content
              * MISSION file content
              * Contributing file content
              * Dependencies file content
              * Dependency install output
              * Issue details (if any)
              * Build output
              * Test output
              * Main execution output
              * Agent configuration file content

            Current feature names and specifications (for context, read only):
            CURRENT_FEATURES_START
            ${currentFeatures}
            CURRENT_FEATURES_END
            
            intentïon file contents:
            INTENTION_FILE_START
            ${intentionContent}
            INTENTION_FILE_END

            Source files (for context only, DO NOT UPDATE):
            SOURCE_FILES_START
            ${Object.entries(sourceFileContents).map(([file, content]) => `File: ${file}\n${content}\n`).join('\n')}
            SOURCE_FILES_END

            Test files (for context only, DO NOT UPDATE):
            TEST_FILES_START
            ${Object.entries(testsFileContents).map(([file, content]) => `File: ${file}\n${content}\n`).join('\n')}
            TEST_FILES_END

            Documentation files (to be updated if necessary):
            DOCS_FILES_START
            ${Object.entries(docsFileContents).map(([file, content]) => `File: ${file}\n${content}\n`).join('\n')}
            DOCS_FILES_END

            README file (primary focus, to be updated): ${readmeFilepath}
            README_FILE_START
            ${readmeFilepathContent}
            README_FILE_END

            MISSION file (for context, read only): ${missionFilepath}
            MISSION_FILE_START
            ${missionFilepathContent}
            MISSION_FILE_END

            Contributing file (for context, read only): ${contributingFilepath}
            CONTRIBUTING_FILE_START
            ${contributingFilepathContent}
            CONTRIBUTING_FILE_END

            Dependencies file (for context, read only): ${dependenciesFilepath}
            DEPENDENCIES_FILE_START
            ${dependenciesFilepathContent}
            DEPENDENCIES_FILE_END   

            Dependencies install from command: npm install
            DEPENDENCIES_INSTALL_START
            ${installOutput}
            DEPENDENCIES_INSTALL_END    

            Build output from command: ${buildScript}
            BUILD_OUTPUT_START
            ${buildOutput}
            BUILD_OUTPUT_END      

            Test output from command: ${testScript}
            TEST_OUTPUT_START
            ${testOutput}
            TEST_OUTPUT_END            

            Main execution output from command: ${mainScript}
            MAIN_OUTPUT_START
            ${mainOutput}
            MAIN_OUTPUT_END    

            Agent configuration file:
            AGENT_CONFIG_FILE_START
            ${agentConfigContent}
            AGENT_CONFIG_FILE_END

            Please produce updated versions of the README and documentation files to ensure they accurately reflect the current state of the codebase.
            Remember:
            1. The README is the primary focus, but other documentation files can be updated as well if needed
            2. Source files (srcFiles) and test files (testFiles) should NOT be updated
            3. Preserve existing README content even if it describes features not yet implemented
            4. Update the README if it conflicts with current source code, tests, or documentation
            5. If documentation files are out of date compared to the source code or tests, update them to be consistent

            If there are no changes required, please provide the original content and state that no changes are necessary in the message.

            Paths in (updatedFile01Filepath, updatedFile02Filepath, etc...) must begin with one of: ${writeableFilepaths}

            Answer strictly with a JSON object following this schema:
            {
              "message": "A short sentence explaining the changes applied (or why no changes were applied) suitable for a commit message or PR text.",
              "updatedFile01Filepath": "${readmeFilepath}",
              "updatedFile01Contents": "The entire new content of the README file, with all necessary changes applied, if any.",
              "updatedFile02Filepath":  "${documentationPath}/USAGE.md",
              "updatedFile02Contents": "The entire new content of the file, with all necessary changes applied, if any.",
              "updatedFile03Filepath": "unused",
              "updatedFile03Contents": "unused",
              "updatedFile04Filepath": "unused",
              "updatedFile04Contents": "unused",
              "updatedFile05Filepath": "unused",
              "updatedFile05Contents": "unused",
              "updatedFile06Filepath": "unused",
              "updatedFile06Contents": "unused",
              "updatedFile07Filepath": "unused",
              "updatedFile07Contents": "unused",
              "updatedFile08Filepath": "unused",
              "updatedFile08Contents": "unused",
              "updatedFile09Filepath": "unused",
              "updatedFile09Contents": "unused",
              "updatedFile10Filepath": "unused",
              "updatedFile10Contents": "unused",
              "updatedFile11Filepath": "unused",
              "updatedFile11Contents": "unused",
              "updatedFile12Filepath": "unused",
              "updatedFile12Contents": "unused",
              "updatedFile13Filepath": "unused",
              "updatedFile13Contents": "unused",
              "updatedFile14Filepath": "unused",
              "updatedFile14Contents": "unused",
              "updatedFile15Filepath": "unused",
              "updatedFile15Contents": "unused",
              "updatedFile16Filepath": "unused",
              "updatedFile16Contents": "unused"
            }

            You can include up to 16 files using the updatedFileXXName and updatedFileXXContents pairs (where XX is a number from 01 to 16)
            Where a file name and contents slot is not used, populate tha name with "unused" and the contents with "unused".
            Never truncate the files, when returning a file, always return the entire file content.

            Ensure valid JSON.
            `;

            const promptFilePath = 'prompt.txt';
            fs.writeFileSync(promptFilePath, chatGptPrompt);
            core.setOutput("promptFilePath", promptFilePath);
            core.info("promptFilePath: " + promptFilePath);

            const ResponseSchema = z.object({ 
              message: z.string(),
              updatedFile01Filepath: z.string().optional(),
              updatedFile01Contents: z.string().optional(),
              updatedFile02Filepath: z.string().optional(),
              updatedFile02Contents: z.string().optional(),
              updatedFile03Filepath: z.string().optional(),
              updatedFile03Contents: z.string().optional(),
              updatedFile04Filepath: z.string().optional(),
              updatedFile04Contents: z.string().optional(),
              updatedFile05Filepath: z.string().optional(),
              updatedFile05Contents: z.string().optional(),
              updatedFile06Filepath: z.string().optional(),
              updatedFile06Contents: z.string().optional(),
              updatedFile07Filepath: z.string().optional(),
              updatedFile07Contents: z.string().optional(),
              updatedFile08Filepath: z.string().optional(),
              updatedFile08Contents: z.string().optional(),
              updatedFile09Filepath: z.string().optional(),
              updatedFile09Contents: z.string().optional(),
              updatedFile10Filepath: z.string().optional(),
              updatedFile10Contents: z.string().optional(),
              updatedFile11Filepath: z.string().optional(),
              updatedFile11Contents: z.string().optional(),
              updatedFile12Filepath: z.string().optional(),
              updatedFile12Contents: z.string().optional(),
              updatedFile13Filepath: z.string().optional(),
              updatedFile13Contents: z.string().optional(),
              updatedFile14Filepath: z.string().optional(),
              updatedFile14Contents: z.string().optional(),
              updatedFile15Filepath: z.string().optional(),
              updatedFile15Contents: z.string().optional(),
              updatedFile16Filepath: z.string().optional(),
              updatedFile16Contents: z.string().optional()
            });

            // Define the function schema for functional calling
            const applyReadmeUpdate = [{
              type: "function",
              function: {
                name: "applyReadmeUpdate",
                description: "Return updated versions of README and documentation files along with a commit message. Use the provided file contents and supporting context to generate the updates.",
                parameters: {
                  type: "object",
                  properties: {
                    message: {
                      type: "string",
                      description: "A short sentence explaining the changes applied (or why no changes were applied) suitable for a commit message or PR text."
                    },
                    updatedFile01Filepath: {
                      type: "string",
                      description: "Path to the first file to update"
                    },
                    updatedFile01Contents: {
                      type: "string",
                      description: "The entire new content of the first file, with all necessary changes applied"
                    },
                    updatedFile02Filepath: {
                      type: "string",
                      description: "Path to the second file to update"
                    },
                    updatedFile02Contents: {
                      type: "string",
                      description: "The entire new content of the second file, with all necessary changes applied"
                    },
                    updatedFile03Filepath: {
                      type: "string",
                      description: "Path to the third file to update"
                    },
                    updatedFile03Contents: {
                      type: "string",
                      description: "The entire new content of the third file, with all necessary changes applied"
                    },
                    updatedFile04Filepath: {
                      type: "string",
                      description: "Path to the fourth file to update"
                    },
                    updatedFile04Contents: {
                      type: "string",
                      description: "The entire new content of the fourth file, with all necessary changes applied"
                    },
                    updatedFile05Filepath: {
                      type: "string",
                      description: "Path to the fifth file to update"
                    },
                    updatedFile05Contents: {
                      type: "string",
                      description: "The entire new content of the fifth file, with all necessary changes applied"
                    },
                    updatedFile06Filepath: {
                      type: "string",
                      description: "Path to the sixth file to update"
                    },
                    updatedFile06Contents: {
                      type: "string",
                      description: "The entire new content of the sixth file, with all necessary changes applied"
                    },
                    updatedFile07Filepath: {
                      type: "string",
                      description: "Path to the seventh file to update"
                    },
                    updatedFile07Contents: {
                      type: "string",
                      description: "The entire new content of the seventh file, with all necessary changes applied"
                    },
                    updatedFile08Filepath: {
                      type: "string",
                      description: "Path to the eighth file to update"
                    },
                    updatedFile08Contents: {
                      type: "string",
                      description: "The entire new content of the eighth file, with all necessary changes applied"
                    },
                    updatedFile09Filepath: {
                      type: "string",
                      description: "Path to the ninth file to update"
                    },
                    updatedFile09Contents: {
                      type: "string",
                      description: "The entire new content of the ninth file, with all necessary changes applied"
                    },
                    updatedFile10Filepath: {
                      type: "string",
                      description: "Path to the tenth file to update"
                    },
                    updatedFile10Contents: {
                      type: "string",
                      description: "The entire new content of the tenth file, with all necessary changes applied"
                    },
                    updatedFile11Filepath: {
                      type: "string",
                      description: "Path to the eleventh file to update"
                    },
                    updatedFile11Contents: {
                      type: "string",
                      description: "The entire new content of the eleventh file, with all necessary changes applied"
                    },
                    updatedFile12Filepath: {
                      type: "string",
                      description: "Path to the twelfth file to update"
                    },
                    updatedFile12Contents: {
                      type: "string",
                      description: "The entire new content of the twelfth file, with all necessary changes applied"
                    },
                    updatedFile13Filepath: {
                      type: "string",
                      description: "Path to the thirteenth file to update"
                    },
                    updatedFile13Contents: {
                      type: "string",
                      description: "The entire new content of the thirteenth file, with all necessary changes applied"
                    },
                    updatedFile14Filepath: {
                      type: "string",
                      description: "Path to the fourteenth file to update"
                    },
                    updatedFile14Contents: {
                      type: "string",
                      description: "The entire new content of the fourteenth file, with all necessary changes applied"
                    },
                    updatedFile15Filepath: {
                      type: "string",
                      description: "Path to the fifteenth file to update"
                    },
                    updatedFile15Contents: {
                      type: "string",
                      description: "The entire new content of the fifteenth file, with all necessary changes applied"
                    },
                    updatedFile16Filepath: {
                      type: "string",
                      description: "Path to the sixteenth file to update"
                    },
                    updatedFile16Contents: {
                      type: "string",
                      description: "The entire new content of the sixteenth file, with all necessary changes applied"
                    }
                  },
                  required: ["message", "updatedFile01Filepath", "updatedFile01Contents", "updatedFile02Filepath", "updatedFile02Contents", "updatedFile03Filepath", "updatedFile03Contents", "updatedFile04Filepath", "updatedFile04Contents", "updatedFile05Filepath", "updatedFile05Contents", "updatedFile06Filepath", "updatedFile06Contents", "updatedFile07Filepath", "updatedFile07Contents", "updatedFile08Filepath", "updatedFile08Contents", "updatedFile09Filepath", "updatedFile09Contents", "updatedFile10Filepath", "updatedFile10Contents", "updatedFile11Filepath", "updatedFile11Contents", "updatedFile12Filepath", "updatedFile12Contents", "updatedFile13Filepath", "updatedFile13Contents", "updatedFile14Filepath", "updatedFile14Contents", "updatedFile15Filepath", "updatedFile15Contents", "updatedFile16Filepath", "updatedFile16Contents"],
                  additionalProperties: false
                },
                strict: true
              }
            }];

            // Call OpenAI using the function calling format via the tools parameter
            const request = {
              model,
              messages: [
                { role: "system", content: "You are a documentation updater that returns updated README and documentation file contents to ensure they accurately reflect the current state of the codebase. You can update multiple files by specifying their paths and contents in the updatedFiles object. Answer strictly with a JSON object that adheres to the provided function schema." },
                { role: "user", content: chatGptPrompt }
              ],
              tools: applyReadmeUpdate
            };

            const requestFilePath = 'request.json';
            fs.writeFileSync(requestFilePath, JSON.stringify(request, null, 2));
            core.setOutput("requestFilePath", requestFilePath);
            core.info("requestFilePath: " + requestFilePath);
            const response = await openai.chat.completions.create(request);
            
            const responseFilePath = 'response.json';
            fs.writeFileSync(responseFilePath, JSON.stringify(response, null, 2));
            core.setOutput("responseFilePath", responseFilePath);
            core.info("responseFilePath: " + responseFilePath);

            let updateApplied;
            let result;
            // Check if the model made a function call; if so, parse its arguments.
            if (response.choices[0].message.tool_calls && response.choices[0].message.tool_calls.length > 0) {
              try {
                result = JSON.parse(response.choices[0].message.tool_calls[0].function.arguments);
              } catch (e) {
                updateApplied = false;
                core.setFailed(`Failed to parse function call arguments: ${e.message}`);
                return;
              }
            } else if (response.choices[0].message.content) {
              try {
                result = JSON.parse(response.choices[0].message.content);
              } catch (e) {
                updateApplied = false;
                core.setFailed(`Failed to parse response content: ${e.message}`);
                return;
              }
            } else {
              updateApplied = false;
              core.setFailed("No valid response received from OpenAI.");
              return;
            }

            try {
              let parsed;
              try {
                parsed = ResponseSchema.parse(result);
                const resultFilePath = 'result.json';
                fs.writeFileSync(resultFilePath, JSON.stringify(parsed, null, 2));
                core.setOutput("resultFilePath", resultFilePath);
                core.info("resultFilePath: " + resultFilePath);
              } catch (e) {
                core.setFailed(`Failed to parse ChatGPT response: ${e.message}`);
                return;
              }

              // Sanitize commit message: retain only alphanumerics, spaces, and basic URL-safe punctuation (-, _, ., ~)
              const sanitizedMessage = parsed.message.replace(/[^A-Za-z0-9 \-\_\.\~]/g, '').replace(/\s+/g, ' ').trim();
              core.setOutput("message", sanitizedMessage);
              core.info(`message: "${sanitizedMessage}"`);

              // Create a map to store all file updates
              const fileUpdates = {};

              // Handle updated files from the new format
              for (let i = 1; i <= 16; i++) {
                const numStr = i.toString().padStart(2, '0');
                const nameKey = `updatedFile${numStr}Filepath`;
                const contentKey = `updatedFile${numStr}Contents`;

                if (parsed[nameKey] && parsed[contentKey]) {
                  fileUpdates[parsed[nameKey]] = parsed[contentKey];
                }
              }
              core.info(`Updated files: "${JSON.stringify(fileUpdates)}"`);

              // Process all file updates
              for (const [filePath, fileContent] of Object.entries(fileUpdates)) {
                if (fileContent === "delete") {
                  if (isWriteable(filePath)) {
                    if (fs.existsSync(filePath)) {
                      fs.unlinkSync(filePath);
                      updateApplied = true;
                      core.info(`File '${filePath}' has been deleted.`);
                    } else {
                      core.warning(`File '${filePath}' does not exist, cannot delete.`);
                    }
                  } else {
                    core.warning(`File '${filePath}' is not in the allowed filepath patterns. Skipping deletion.`);
                  }
                } else if (fileContent && fileContent != "unused" && fileContent.length > 1) {
                  if (filePath && filePath != "unused" && isWriteable(filePath)) {
                    // Create directory if it doesn't exist
                    const fileDir = path.dirname(filePath);
                    if (!fs.existsSync(fileDir)) {
                      fs.mkdirSync(fileDir, { recursive: true });
                    }
                    fs.writeFileSync(filePath, fileContent, 'utf8');
                    updateApplied = true;
                    core.info(`File '${filePath}' has been updated (length ${fileContent.length}).`);
                  } else {
                    core.setFailed(`File '${filePath}' is not in the allowed filepath patterns. Skipping update.`);
                    return;
                  }
                }
              }

            } catch (e) {
              updateApplied = false;
              core.setFailed(`Failed to validate or process the response: ${e.message}`);
              return;
            }

            core.setOutput("updateApplied", updateApplied);
            core.setOutput("usage", JSON.stringify(response.usage));
            core.info(`updateApplied: "${updateApplied}"`);
            core.info(`usage: "${JSON.stringify(response.usage)}"`);

      - name: Examine the git working copy
        shell: bash
        run: |
          git config --local user.email '${{ env.gitUserEmail }}'
          git config --local user.name '${{ env.gitUserName }}'
          git status -v
          IFS=';' read -ra DOCS_FILES <<< "${{ env.documentationPath }}"
          for file in "${DOCS_FILES[@]}"; do
            echo "=== Git diff for docs file: $file ==="
            git diff "$file" || true
            echo ""
          done
          echo "=== Git diff for README file: ${{ env.readmeFilepath }} ==="
          git diff "${{ env.readmeFilepath }}" || true
          echo ""

      - name: install-after-update
        id: install-after-update
        shell: bash
        run: |
          set +e
          npm install
          exit 0

      - name: ci-after-update
        id: ci-after-update
        shell: bash
        run: |
          set +e
          npm ci
          exit 0

      - name: Test after update
        id: test-after-update
        shell: bash
        run: |
          set +e
          ${{ env.testScript }}
          exit 0

      - name: Run main after update
        id: main-after-update
        shell: bash
        run: |
          set +e
          timeout ${{ env.mainScriptTimeout }} ${{ env.mainScript }}
          exit 0

      - name: Collect git diff as a text output
        id: git-diff
        shell: bash
        run: |
          git config --local user.email '${{ env.gitUserEmail }}'
          git config --local user.name '${{ env.gitUserName }}'
          #output=$(git add --intent-to-add $(git ls-files -o --exclude-standard) ; git diff 2>&1)
          output=$(git diff 2>&1)
          # Get a list of the new files not added to the index and concatenate them to the output with a lable showing
          # the file name proceeding with "new-file: "
          newFiles=$(git ls-files -o --exclude-standard)
          for file in ${newFiles?}; do
            output+="\n\n// New [${file?}]:\n"
            output+=$(cat "${file?}")
          done
          echo "output<<EOF" >> "$GITHUB_OUTPUT"
          echo "$output" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          echo "output=${output}"

      - name: Commit changes
        id: commit
        continue-on-error: true
        run: |
          git config --local user.email '${{ env.gitUserEmail }}'
          git config --local user.name '${{ env.gitUserName }}'
          git status -v
          git add -v --all
          git diff
          git commit -m '${{ steps.update-readme.outputs.message }}'
          git status -v
          git push -v origin ${{ env.branch }}
          git status -v

      - name: Extract Results
        if: ${{ !cancelled() }}
        id: results
        uses: actions/github-script@v7
        env:
          updateApplied: ${{ steps.update-readme.outputs.updateApplied }}
          message: ${{ steps.update-readme.outputs.message }}
          installAfterUpdateOutcome: ${{ steps.install-after-update.outcome }}
          ciAfterUpdateOutcome: ${{ steps.ci-after-update.outcome }}
          testAfterUpdateOutcome: ${{ steps.test-after-update.outcome }}
          mainAfterUpdateOutcome: ${{ steps.main-after-update.outcome }}
          commitOutcome: ${{ steps.commit.outcome }}
        with:
          script: |
            const updateApplied = process.env.updateApplied;
            const message = process.env.message;
            const installAfterUpdateOutcome = process.env.installAfterUpdateOutcome;
            const ciAfterUpdateOutcome = process.env.ciAfterUpdateOutcome;
            const testAfterUpdateOutcome = process.env.testAfterUpdateOutcome;
            const mainAfterUpdateOutcome = process.env.mainAfterUpdateOutcome;
            const commitOutcome = process.env.commitOutcome;
            const allValidationStepsSuccessful = installAfterUpdateOutcome === "success" && ciAfterUpdateOutcome === "success" && testAfterUpdateOutcome === "success" && mainAfterUpdateOutcome === "success" && commitOutcome === "success";
            core.setOutput('updateApplied', updateApplied);
            core.setOutput('message', message);
            core.setOutput('installAfterUpdateOutcome', installAfterUpdateOutcome);
            core.setOutput('ciAfterUpdateOutcome', ciAfterUpdateOutcome);
            core.setOutput('testAfterUpdateOutcome', testAfterUpdateOutcome);
            core.setOutput('mainAfterUpdateOutcome', mainAfterUpdateOutcome);
            core.setOutput('commitOutcome', commitOutcome);
            core.setOutput('allValidationStepsSuccessful', allValidationStepsSuccessful);
            core.info(`updateApplied: "${updateApplied}"`);
            core.info(`message: "${message}"`);
            core.info(`installAfterUpdateOutcome: "${installAfterUpdateOutcome}"`);
            core.info(`ciAfterUpdateOutcome: "${ciAfterUpdateOutcome}"`);
            core.info(`testAfterUpdateOutcome: "${testAfterUpdateOutcome}"`);
            core.info(`mainAfterUpdateOutcome: "${mainAfterUpdateOutcome}"`);
            core.info(`commitOutcome: "${commitOutcome}"`);
            core.info(`allValidationStepsSuccessful: "${allValidationStepsSuccessful}"`);

      - name: Upload prompt file as an artifact
        if: ${{ !cancelled() }}
        uses: actions/upload-artifact@v4
        with:
          name: update-readme-prompt.txt
          path: ${{ steps.update-readme.outputs.promptFilePath }}
          retention-days: 7

      - name: Upload request file as an artifact
        if: ${{ !cancelled() }}
        uses: actions/upload-artifact@v4
        with:
          name: update-readme-request.json
          path: ${{ steps.update-readme.outputs.requestFilePath }}
          retention-days: 7

      - name: Upload response file as an artifact
        if: ${{ !cancelled() }}
        uses: actions/upload-artifact@v4
        with:
          name: update-readme-response.json
          path: ${{ steps.update-readme.outputs.responseFilePath }}
          retention-days: 7

      - name: Upload result file as an artifact
        if: ${{ !cancelled() }}
        uses: actions/upload-artifact@v4
        with:
          name: update-readme-result.json
          path: ${{ steps.update-readme.outputs.resultFilePath }}

    outputs:
      updateApplied: ${{ steps.results.outputs.updateApplied }}
      message: ${{ steps.results.outputs.message }}
      installAfterUpdateOutcome: ${{ steps.results.outputs.installAfterUpdateOutcome }}
      ciAfterUpdateOutcome: ${{ steps.results.outputs.ciAfterUpdateOutcome }}
      testAfterUpdateOutcome: ${{ steps.results.outputs.testAfterUpdateOutcome }}
      mainAfterUpdateOutcome: ${{ steps.results.outputs.mainAfterUpdateOutcome }}
      commitOutcome: ${{ steps.results.outputs.commitOutcome }}
      allValidationStepsSuccessful: ${{ steps.results.outputs.allValidationStepsSuccessful }}
      gitDiff: ${{ steps.git-diff.outputs.output }}
      usage: ${{ steps.update-readme.outputs.usage }}
