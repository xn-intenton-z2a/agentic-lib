# .github/workflows/wfr-review-issue.yml
name: âˆž Review issue

on:
  workflow_call:
    inputs:
      issueNumber:
        description: 'The issue number to review. e.g. "123"'
        type: string
        required: true
      target:
        description: 'The target file to review. e.g. "src/lib/main.js"'
        type: string
        required: false
        default: 'src/lib/main.js'
      buildScript:
        description: 'The script must be runnable as: `npm ci ; <script>` and succeed with a zero exit code. e.g. `npm run build`'
        type: string
        required: false
        default: 'echo "No build script specified."'
      testScript:
        description: 'The script must be runnable as: `npm ci ; <script>` and succeed with a zero exit code. e.g. `npm test`'
        type: string
        required: false
        default: 'npm test'
      mainScript:
        description: 'The script must be runnable as: `npm ci ; <script>` and succeed with a zero exit code. e.g. `node src/lib/main.js`'
        type: string
        required: false
        default: 'node src/lib/main.js'
      model:
        description: 'The OpenAI model to use. e.g. "o3-mini"'
        type: string
        required: false
        default: 'o3-mini'
    secrets:
      PERSONAL_ACCESS_TOKEN:
        required: true
      CHATGPT_API_SECRET_KEY:
        required: true
    outputs:
      fixed:
        value: ${{ jobs.review-issue.outputs.fixed }}

jobs:
  review-issue:
    runs-on: ubuntu-latest

    env:
      issueNumber: ${{ inputs.issueNumber }}
      target: ${{ inputs.target || 'src/lib/main.js' }}
      buildScript: ${{ inputs.buildScript || 'npm run build' }}
      testScript: ${{ inputs.testScript || 'npm test' }}
      mainScript: ${{ inputs.mainScript || 'node src/lib/main.js' }}
      model: ${{ inputs.model || 'o3-mini' }}
      chatgptApiSecretKey: ${{ secrets.CHATGPT_API_SECRET_KEY }}

    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Check GitHub authentication
        if: ${{ env.npmAuthOrganisation != '' }}
        shell: bash
        run: |
          curl --include --header "Authorization: token ${{ secrets.PERSONAL_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}" https://api.github.com/user

      - name: Set up .npmrc
        if: ${{ env.npmAuthOrganisation != '' }}
        shell: bash
        run: |
          echo "${{ env.npmAuthOrganisation }}:registry=https://npm.pkg.github.com" >> .npmrc
          echo "//npm.pkg.github.com/:_authToken=${{ secrets.PERSONAL_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}" >> .npmrc
          echo "always-auth=true" >> .npmrc

      - run: npm ci

      - name: Build project
        id: build
        shell: bash
        run: |
          output=$(${{ env.buildScript }} 2>&1)
          echo "output<<EOF" >> "$GITHUB_OUTPUT"
          echo "$output" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          echo "output=${output}"

      - name: Tear down .npmrc
        if: ${{ env.npmAuthOrganisation != '' }}
        shell: bash
        run: rm -f .npmrc

      - name: Run tests
        id: test
        shell: bash
        run: |
          output=$(${{ env.testScript }} 2>&1)
          echo "output<<EOF" >> "$GITHUB_OUTPUT"
          echo "$output" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          echo "output=${output}"

      - name: Run main
        id: main
        shell: bash
        run: |
          output=$(${{ env.mainScript }} 2>&1)
          echo "output<<EOF" >> "$GITHUB_OUTPUT"
          echo "$output" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          echo "output=${output}"

      - name: verify
        id: verify
        uses: actions/github-script@v7
        env:
          buildOutput: ${{ steps.build.outputs.output }}
          testOutput: ${{ steps.test.outputs.output }}
          mainOutput: ${{ steps.main.outputs.output }}
        with:
          github-token: ${{ secrets.PERSONAL_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}
          script: |
            const target = process.env.target;            
            const model = process.env.model;
            const apiKey = process.env.chatgptApiSecretKey;
            const issueNumber = parseInt(process.env.issueNumber);
            const buildScript = process.env.buildScript;
            const buildOutput = process.env.buildOutput;
            const testScript = process.env.testScript;
            const testOutput = process.env.testOutput;
            const mainScript = process.env.mainScript;
            const mainOutput = process.env.mainOutput;

            const fs = require('fs');
            const OpenAI = require('openai').default;
            const { z } = require('zod');
            require('dotenv').config();

            if (!apiKey) { 
              core.setFailed("Missing CHATGPT_API_SECRET_KEY"); 
            }
            const openai = new OpenAI({ apiKey });

            const sourceFileContent = fs.readFileSync(target, 'utf8');
            
            const issue = await github.rest.issues.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber
            });
            const issueTitle = issue.data.title;
            const issueDescription = issue.data.body;
            const issueComments = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber
            });
            const issueCommentsText = issueComments.data
              .map(comment => `Author:${comment.user.login}, Created:${comment.created_at}, Comment: ${comment.body}`)
              .join('\n');
            
            const prompt = `
            Does the following source file content reflect the resolution of the following issue?
            Consider the file content, issue, build output, test output, and main output.
            
            Source for file: ${target}
            SOURCE_FILE_START
            ${sourceFileContent}
            SOURCE_FILE_END
            
            Issue:
            ISSUE_START
            title: ${issueTitle}
            description:
            ${issueDescription}
            comments:
            ${issueCommentsText}
            ISSUE_END            

            Build output from command: ${buildScript}
            TEST_OUTPUT_START
            ${buildOutput}
            TEST_OUTPUT_END      
            
            Test output from command: ${testScript}
            TEST_OUTPUT_START
            ${testOutput}
            TEST_OUTPUT_END            

            Main output from command: ${mainScript}
            MAIN_OUTPUT_START
            ${mainOutput}
            MAIN_OUTPUT_END    
            
            Answer strictly with a JSON object following this schema:
            {
              "fixed": "true", // if the fix is present, or "false" otherwise.
              "message": "The issue has been resolved.", // if the fix is present, or an explanation otherwise.
              "refinement": "None" // if the fix is present, or a suggested refinement to resolve the issue otherwise.
            }
            Ensure valid JSON.
            `;
            
            const ResponseSchema = z.object({ fixed: z.string(), message: z.string(), refinement: z.string() });
            
            // Define the function schema for function calling
            const tools = [{
              type: "function",
              function: {
                name: "review_issue",
                description: "Evaluate whether the supplied source file content resolves the issue. Return an object with fixed (string: 'true' or 'false'), message (explanation), and refinement (suggested refinement).",
                parameters: {
                  type: "object",
                  properties: {
                    fixed: { type: "string", description: "true if the issue is resolved, false otherwise" },
                    message: { type: "string", description: "A message explaining the result" },
                    refinement: { type: "string", description: "A suggested refinement if the issue is not resolved" }
                  },
                  required: ["fixed", "message", "refinement"],
                  additionalProperties: false
                },
                strict: true
              }
            }];

            // Call OpenAI using function calling format
            const response = await openai.chat.completions.create({
              model,
              messages: [
                { role: "system", content: "You are evaluating whether an issue has been resolved in the supplied source code. Answer strictly with a JSON object following the provided function schema." },
                { role: "user", content: prompt }
              ],
              tools: tools
            });
            
            let result;
            if (response.choices[0].message.tool_calls && response.choices[0].message.tool_calls.length > 0) {
              try {
                result = JSON.parse(response.choices[0].message.tool_calls[0].function.arguments);
              } catch (e) {
                core.setFailed(`Failed to parse function call arguments: ${e.message}`);
              }
            } else if (response.choices[0].message.content) {
              try {
                result = JSON.parse(response.choices[0].message.content);
              } catch (e) {
                core.setFailed(`Failed to parse response content: ${e.message}`);
              }
            } else {
              core.setFailed("No valid response received from OpenAI.");
            }
            
            try {
              const parsed = ResponseSchema.parse(result);
              core.setOutput("fixed", parsed.fixed);
              core.setOutput("message", parsed.message);
              core.setOutput("refinement", parsed.refinement);
              core.info(`fixed: "${parsed.fixed}"`);
              core.info(`message: "${parsed.message}"`);
              core.info(`refinement: "${parsed.refinement}"`);
            
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber,
                body: parsed.message
              });
            
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber,
                body: parsed.refinement
              });
            } catch (e) {
              core.setFailed(`Failed to parse ChatGPT response: ${e.message}`);
            }
            
            core.setOutput("response", JSON.stringify(response));
            core.setOutput("usage", JSON.stringify(response.usage));
            core.info(`response: "${JSON.stringify(response)}"`);
            core.info(`usage: "${JSON.stringify(response.usage)}"`);
      - name: Close fixed issues
        if: steps.verify.outputs.fixed == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PERSONAL_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}
          script: |
            const issueNumber = parseInt("${{ env.issueNumber }}");
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber,
              body: "The issue has been automatically resolved and the fix has been merged."
            });
            await github.rest.issues.update({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber,
              state: "closed"
            });

    outputs:
      fixed: ${{ steps.verify.outputs.fixed }}
      message: ${{ steps.verify.outputs.message }}
      refinement: ${{ steps.verify.outputs.refinement }}
