# .github/workflows/wfr-completion-maintain-library.yml

#
# agentic-lib
# Copyright (C) 2025 Polycode Limited
#
# This file is part of agentic-lib.
#
# agentic-lib is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License v3.0 (GPL‑3).
# along with this program. If not, see <https://www.gnu.org/licenses/>.
#
# IMPORTANT: Any derived work must include the following attribution:
# "This work is derived from https://github.com/xn-intenton-z2a/agentic-lib"
#

name: ∞ maintain-library

on:
  workflow_call:
    inputs:
      document:
        description: 'Text to drive the library maintenance (if "house choice", the repository will be assessed and an action chosen). e.g. "Download something about agents."'
        type: string
        required: false
        default: 'house choice'
      libraryDir:
        description: 'The directory to create/update the documents in. e.g. "library/"'
        type: string
        required: false
        default: 'library/'
      documentsLimit:
        description: 'The maximum number of documents to have in the library to create. e.g. "3"'
        type: string
        required: false
        default: '3'
      target:
        description: 'The target file to create the issue to change. e.g. "src/lib/main.js"'
        type: string
        required: false
        default: 'src/lib/main.js'
      testFile:
        description: 'The test file. e.g. "tests/unit/main.test.js"'
        type: string
        required: false
        default: 'tests/unit/main.test.js'
      readmeFile:
        description: 'The README file. e.g. "README.md"'
        type: string
        required: false
        default: 'README.md'
      missionFile:
        description: 'The MISSION statement file. e.g. "MISSION.md"'
        type: string
        required: false
        default: 'MISSION.md'
      contributingFile:
        description: 'The CONTRIBUTING file. e.g. "CONTRIBUTING.md"'
        type: string
        required: false
        default: 'CONTRIBUTING.md'
      dependenciesFile:
        description: 'The dependencies file. e.g. "package.json"'
        type: string
        required: false
        default: 'package.json'
      buildScript:
        description: 'The script must be runnable as: `npm ci ; <script>` and succeed with a zero exit code. e.g. `npm run build`'
        type: string
        required: false
        default: 'echo "No build script specified."'
      testScript:
        description: 'The script must be runnable as: `npm ci ; <script>` and succeed with a zero exit code. e.g. `npm test`'
        type: string
        required: false
        default: 'npm test'
      mainScript:
        description: 'The script must be runnable as: `npm ci ; <script>` and succeed with a zero exit code. e.g. `npm run start`'
        type: string
        required: false
        default: 'npm run start'
      model:
        description: 'The OpenAI model to use. e.g. "o3-mini"'
        type: string
        required: false
        default: ${{ vars.CHATGPT_API_MODEL || 'o3-mini' }}
      npmAuthOrganisation:
        description: 'The GitHub organisation to authenticate with for npm. e.g. "xn-intenton-z2a"'
        type: string
        required: false
        default: ''
      gitUserEmail:
        description: 'The email to use for git commits. e.g. "action@github.com"'
        type: string
        required: false
        default: 'action@github.com'
      gitUserName:
        description: 'The name to use for git commits. e.g. "GitHub Actions[bot]"'
        type: string
        required: false
        default: 'GitHub Actions[bot]'
      s3BucketUrl:
        description: 'The S3 bucket URL with prefix to use. e.g. "s3://my-bucket/prefix"'
        type: string
        required: false
        default: ''
      iamRoleArn:
        description: 'The ARN of the IAM role to assume. e.g. "arn:aws:iam::123456789012:role/my-role"'
        type: string
        required: false
        default: ''
    secrets:
      PERSONAL_ACCESS_TOKEN:
        required: false
      CHATGPT_API_SECRET_KEY:
        required: true
    outputs:
      documentName:
        value: ${{ jobs.maintain-library.outputs.documentName }}
      documentSummary:
        value: ${{ jobs.maintain-library.outputs.documentSummary }}

jobs:
  maintain-library:
    runs-on: ubuntu-latest

    env:
      document: ${{ inputs.document || '' }}
      documentsDir: ${{ inputs.documentsDir || 'library/' }}
      documentsLimit: ${{ inputs.documentsLimit || '3' }}
      target: ${{ inputs.target || 'src/lib/main.js' }}
      testFile: ${{ inputs.testFile || 'tests/unit/main.test.js' }}
      readmeFile: ${{ inputs.readmeFile || 'README.md' }}
      missionFile: ${{ inputs.missionFile || 'MISSION.md' }}
      contributingFile: ${{ inputs.contributingFile || 'CONTRIBUTING.md' }}
      dependenciesFile: ${{ inputs.dependenciesFile || 'package.json' }}
      buildScript: ${{ inputs.buildScript || 'npm run build' }}
      testScript: ${{ inputs.testScript || 'npm test' }}
      mainScript: ${{ inputs.mainScript || 'npm run start' }}
      mainScriptTimeout: '5m'
      model: ${{ inputs.model || vars.CHATGPT_API_MODEL || 'o3-mini' }}
      npmAuthOrganisation: ${{ inputs.npmAuthOrganisation || '' }}
      gitUserEmail: ${{ inputs.gitUserEmail || 'action@github.com' }}
      gitUserName: ${{ inputs.gitUserName || 'GitHub Actions[bot]' }}
      chatgptApiSecretKey: ${{ secrets.CHATGPT_API_SECRET_KEY }}
      s3BucketUrl: ${{ inputs.s3BucketUrl || '' }}
      iamRoleArn: ${{ inputs.iamRoleArn || '' }}

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Check GitHub authentication
        if: ${{ env.npmAuthOrganisation != '' }}
        shell: bash
        run: |
          curl --include --header "Authorization: token ${{ secrets.PERSONAL_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}" https://api.github.com/user

      - name: Set up .npmrc
        if: ${{ env.npmAuthOrganisation != '' }}
        shell: bash
        run: |
          echo "${{ env.npmAuthOrganisation }}:registry=https://npm.pkg.github.com" >> .npmrc
          echo "//npm.pkg.github.com/:_authToken=${{ secrets.PERSONAL_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}" >> .npmrc
          echo "always-auth=true" >> .npmrc

      - run: npm ci

      - name: List current features
        id: features
        shell: bash
        run: |
          output=$(find "${{ env.featuresDir }}" -maxdepth 1 -type f -name '*.md' -print -exec echo "# {}" \; -exec cat {} \; 2>&1 || echo 'none')
          echo "output<<EOF" >> "$GITHUB_OUTPUT"
          echo "$output" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          echo "output=${output}"

      - name: List rejected feature named
        id: rejectedFeatures
        shell: bash
        run: |
          mkdir -p "${{ env.featuresDir }}/rejects"
          output=$(ls -1 "${{ env.featuresDir }}/rejects" | sed 's/\.md//' | xargs echo )
          echo "output<<EOF" >> "$GITHUB_OUTPUT"
          echo "$output" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          echo "output=${output}"

      - name: List dependencies
        id: list
        shell: bash
        run: |
          output=$(npm list 2>&1)
          echo "output<<EOF" >> "$GITHUB_OUTPUT"
          echo "$output" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          echo "output=${output}"

      - name: Build project
        id: build
        shell: bash
        run: |
          output=$(${{ env.buildScript }} 2>&1)
          echo "output<<EOF" >> "$GITHUB_OUTPUT"
          echo "$output" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          echo "output=${output}"

      - name: Tear down .npmrc
        if: ${{ env.npmAuthOrganisation != '' }}
        shell: bash
        run: rm -f .npmrc

      - name: Run tests
        id: test
        shell: bash
        run: |
          output=$(${{ env.testScript }} 2>&1)
          echo "output<<EOF" >> "$GITHUB_OUTPUT"
          echo "$output" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          echo "output=${output}"

      - name: Run main
        id: main
        shell: bash
        run: |
          output=$(timeout ${{ env.mainScriptTimeout }} ${{ env.mainScript }} 2>&1)
          echo "output<<EOF" >> "$GITHUB_OUTPUT"
          echo "$output" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          echo "output=${output}"

      - name: maintain-library
        id: maintain-library
        uses: actions/github-script@v7
        env:
          currentFeatures: ${{ steps.features.outputs.output }}
          rejectedFeatures: ${{ steps.rejectedFeatures.outputs.output }}
          dependenciesListOutput: ${{ steps.list.outputs.output }}
          buildOutput: ${{ steps.build.outputs.output }}
          testOutput: ${{ steps.test.outputs.output }}
          mainOutput: ${{ steps.main.outputs.output }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const document = process.env.document;
            const libraryDir = process.env.libraryDir;
            const documentsLimit = process.env.documentsLimit;
            const currentFeatures = process.env.currentFeatures;
            const rejectedFeatures = process.env.rejectedFeatures;
            const target = process.env.target;
            const testFile = process.env.testFile;
            const readmeFile = process.env.readmeFile;
            const missionFile = process.env.missionFile;
            const contributingFile = process.env.contributingFile;
            const dependenciesFile = process.env.dependenciesFile;
            const model = process.env.model;
            const apiKey = process.env.chatgptApiSecretKey;
            const dependenciesListOutput = process.env.dependenciesListOutput;
            const buildScript = process.env.buildScript;
            const buildOutput = process.env.buildOutput;
            const testScript = process.env.testScript;
            const testOutput = process.env.testOutput;
            const mainScript = process.env.mainScript;
            const mainOutput = process.env.mainOutput;

            const fs = require('fs');
            const path = require('path');
            const OpenAI = require('openai').default;
            const { z } = require('zod');
            require('dotenv').config();
  
            if (!apiKey) { 
              core.setFailed("Missing CHATGPT_API_SECRET_KEY"); 
            }
            const openai = new OpenAI({ apiKey });

            core.info(`document: "${document}"`);
            core.info(`libraryDir: "${libraryDir}"`);
            core.info(`currentFeatures: "${currentFeatures}"`);
            core.info(`target: "${target}"`);
            core.info(`testFile: "${testFile}"`);
            core.info(`readmeFile: "${readmeFile}"`);
            core.info(`missionFile: "${missionFile}"`);
            core.info(`contributingFile: "${contributingFile}"`);
            core.info(`dependenciesFile: "${dependenciesFile}"`);
            const sourceFileContent = fs.readFileSync(target, 'utf8');
            const testFileContent = fs.readFileSync(testFile, 'utf8');
            const readmeFileContent = fs.readFileSync(readmeFile, 'utf8');
            const missionFileContent = fs.readFileSync(missionFile, 'utf8');
            const contributingFileContent = fs.readFileSync(contributingFile, 'utf8');
            const dependenciesFileContent = fs.readFileSync(dependenciesFile, 'utf8');
            core.info(`Target file '${target}' has been loaded (length ${sourceFileContent.length}).`);
            core.info(`Test file '${testFile}' has been loaded (length ${testFileContent.length}).`);
            core.info(`Readme file '${readmeFile}' has been loaded (length ${readmeFileContent.length}).`);
            core.info(`Dependencies file '${dependenciesFile}' has been loaded (length ${dependenciesFileContent.length}).`);
            
            // generate the document prompt either by using the supplied document prompt or by reviewing the current features and full context
            let prompt = document;
            if (document === 'house choice') {
              prompt = `Please review the current features in the repository and either;
                * add a new document to the repository, or
                * extend an existing document to add a new aspect to it, or
                * update an existing document to bring it to a high standard matching other documents in the repository.
                The document name should either be a current document name or be supplied with a summary which is distinct from any other document in the repository.
              `;
            }
            
            const chatGptPrompt = `
            Please generate a document summary based on the supplied prompt and project files.
            Before adding a new document ensure that this document is distinct from any other document in the library, otherwise update an existing document.
            The document name should be one or two words in SCREAMING_SNAKECASE.
            Consider the following when refining your response:
            * Feature prompt details
            * Current feature names and specifications in the repository
            * Rejected feature names
            * Source file content
            * Test file content
            * README file content
            * MISSION file content
            * Contributing file content
            * Dependencies file content
            * Dependency list
            * Build output
            * Test output
            * Main execution output
            
            Feature prompt:
            FEATURE_PROMPT_START
            ${prompt}
            FEATURE_PROMPT_END            
            
            Current feature names and specifications:
            CURRENT_FEATURES_START
            ${currentFeatures}
            CURRENT_FEATURES_END
            
            Rejected feature names:
            REJECTED_FEATURES_START
            ${rejectedFeatures}
            REJECTED_FEATURES_END
            
            Source file: ${target}
            SOURCE_FILE_START
            ${sourceFileContent}
            SOURCE_FILE_END
            
            Test file: ${testFile}
            TEST_FILE_START
            ${testFileContent}
            TEST_FILE_END

            README file: ${readmeFile}
            README_FILE_START
            ${readmeFileContent}
            README_FILE_END
            
            MISSION file: ${missionFile}
            MISSION_FILE_START
            ${missionFileContent}
            MISSION_FILE_END

            Contributing file: ${contributingFile}
            CONTRIBUTING_FILE_START
            ${contributingFileContent}
            CONTRIBUTING_FILE_END
            
            Dependencies file: ${dependenciesFile}
            DEPENDENCIES_FILE_START
            ${dependenciesFileContent}
            DEPENDENCIES_FILE_END
            
            Dependencies list from command: npm list
            DEPENDENCIES_LIST_START
            ${dependenciesListOutput}
            DEPENDENCIES_LIST_END    
            
            Build output from command: ${buildScript}
            TEST_OUTPUT_START
            ${buildOutput}
            TEST_OUTPUT_END      
            
            Test output from command: ${testScript}
            TEST_OUTPUT_START
            ${testOutput}
            TEST_OUTPUT_END            

            Main output from command: ${mainScript}
            MAIN_OUTPUT_START
            ${mainOutput}
            MAIN_OUTPUT_END
            
            Answer strictly with a JSON object following this schema:
            {
              "documentName": "The document name as one or two words in SCREAMING_SNAKECASE.",
              "documentSummary": "The document summary as multiline markdown with a few level 1 headings.",
              "documentNamesToBeDeleted": "The comma separated list of document names to be deleted or 'none' if no document is to be deleted."
            }
            Ensure valid JSON.
            `;
            
            const ResponseSchema = z.object({ documentName: z.string(), documentSpec: z.string(), documentNamesToBeDeleted: z.string() });
            
            // Define the function schema for function calling
            const tools = [{
              type: "function",
              function: {
                name: "generate_document",
                description: "Elaborate on the supplied prompt and project files to create the documentName and documentSummary of a repository document, and the document names to be deleted. Return an object with documentName (string), documentSummary (string), and documentNamesToBeDeleted (string).",
                parameters: {
                  type: "object",
                  properties: {
                    documentName: { type: "string", description: "The document name as one or two words in SCREAMING_SNAKECASE." },
                    documentSummary: { type: "string", description: "The document summary as multiline markdown with a few level 1 headings." },
                    documentNamesToBeDeleted: { type: "string", description: "The comma separated list of document names to be deleted or 'none' if no document is to be deleted." }
                  },
                  required: ["documentName", "documentSummary", "documentNamesToBeDeleted"],
                  additionalProperties: false
                },
                strict: true
              }
            }];

            // Call OpenAI using function calling format
            const response = await openai.chat.completions.create({
              model,
              messages: [
                { role: "system", content: "You are maintaining a library set by providing expert contemporary insight into both the product market and you will perform a detailed analysis of the current state of the repository and current document set in search of value opportunities and unique selling points. Answer strictly with a JSON object following the provided function schema." },
                { role: "user", content: chatGptPrompt }
              ],
              tools: tools
            });
            
            let result;
            if (response.choices[0].message.tool_calls && response.choices[0].message.tool_calls.length > 0) {
              try {
                result = JSON.parse(response.choices[0].message.tool_calls[0].function.arguments);
              } catch (e) {
                core.setFailed(`Failed to parse function call arguments: ${e.message}`);
              }
            } else if (response.choices[0].message.content) {
              try {
                result = JSON.parse(response.choices[0].message.content);
              } catch (e) {
                core.setFailed(`Failed to parse response content: ${e.message}`);
              }
            } else {
              core.setFailed("No valid response received from OpenAI.");
            }
            
            try {
              const parsed = ResponseSchema.parse(result);
              core.setOutput("documentName", parsed.documentName);
              core.setOutput("documentSummary", parsed.documentSummary);
              core.setOutput("documentNamesToBeDeleted", parsed.documentNamesToBeDeleted);
              core.info(`documentName: "${parsed.documentName}"`);
              core.info(`documentSummary: "${parsed.documentSummary}"`);
              core.info(`documentNamesToBeDeleted: "${parsed.documentNamesToBeDeleted}"`);
            
              // Save the document summary to a file using the convention of <documentsDir> plus path SCREAMING_SNAKE_CASE(<document name>).md
              const documentName = parsed.documentName.replace(/ /g, "_").toUpperCase();
              const documentSummary = parsed.documentSummary;
              const libraryDir = process.env.libraryDir || 'library/';
              
              const documentFilePath = path.join(libraryDir, `${documentName}.md`);
              try {
                fs.mkdirSync(libraryDir, { recursive: true });
                fs.writeFileSync(documentFilePath, documentSummary);
                core.info(`Document summary saved to ${documentFilePath}`);
              } catch (e) {
                core.setFailed(`Failed to save document summary: ${e.message}`);
              }
            
              const documentFilepathsToBeDeleted = parsed.documentNamesToBeDeleted
                .split(',')
                .map(name => path.join(libraryDir, `${name.trim().replace(/.md^/, "").toUpperCase()}.md`));
              for (const filepath of documentFilepathsToBeDeleted) {
                try {
                  if( fs.existsSync(filepath) ) {
                    core.info(`Deleting document file: ${filepath}`);
                    fs.unlinkSync(filepath);
                  }
                } catch (e) {
                  core.info(`Could not delete ${filepath}: ${e.message}`);
                }
              }
            
            } catch (e) {
              core.setFailed(`Failed to parse ChatGPT response: ${e.message}`);
            }
              
            core.setOutput("response", JSON.stringify(response));
            core.setOutput("usage", JSON.stringify(response.usage));
            core.info(`response: "${JSON.stringify(response)}"`);
            core.info(`usage: "${JSON.stringify(response.usage)}"`);

      - name: Commit changes
        id: commit
        continue-on-error: true
        run: |
          git config --local user.email '${{ env.gitUserEmail }}'
          git config --local user.name '${{ env.gitUserName }}'
          git status -v
          git add -v --all '${{ env.libraryDir }}'
          git commit -m 'Maintain ${{ steps.maintain-documents.outputs.documentName }}'
          git status -v
          git push -v origin ${{ github.ref }}
          git status -v

    outputs:
      documentName: ${{ steps.maintain-documents.outputs.documentName }}
      documentSummary: ${{ steps.maintain-documents.outputs.documentSummary }}
