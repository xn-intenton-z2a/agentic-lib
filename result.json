{
  "message": "Add --agent CLI command with processAgent handler, tests, and README documentation",
  "updatedFile01Filepath": "sandbox/source/main.js",
  "updatedFile01Contents": "#!/usr/bin/env node\n// sandbox/source/main.js\n\n// Initialize global callCount to support test mocks that reference it\nif (typeof globalThis.callCount === \"undefined\") {\n  globalThis.callCount = 0;\n}\n\nimport { fileURLToPath } from \"url\";\nimport { z } from \"zod\";\nimport dotenv from \"dotenv\";\nimport { Configuration, OpenAIApi } from \"openai\";\n\n// ---------------------------------------------------------------------------------------------------------------------\n// Environment configuration from .env file or environment variables or test values.\n// ---------------------------------------------------------------------------------------------------------------------\n\ndotenv.config();\n\nif (process.env.VITEST || process.env.NODE_ENV === \"development\") {\n  process.env.GITHUB_API_BASE_URL =\n    process.env.GITHUB_API_BASE_URL || \"https://api.github.com.test/\";\n  process.env.OPENAI_API_KEY = process.env.OPENAI_API_KEY || \"key-test\";\n}\n\nconst configSchema = z.object({\n  GITHUB_API_BASE_URL: z.string().optional(),\n  OPENAI_API_KEY: z.string().optional(),\n});\n\nexport const config = configSchema.parse(process.env);\n\n// Global verbose mode flag\nconst VERBOSE_MODE = false;\n// Global verbose stats flag\nconst VERBOSE_STATS = false;\n\n// Helper function to format log entries\nfunction formatLogEntry(level, message, additionalData = {}) {\n  return {\n    level,\n    timestamp: new Date().toISOString(),\n    message,\n    ...additionalData,\n  };\n}\n\nexport function logConfig() {\n  const logObj = formatLogEntry(\"info\", \"Configuration loaded\", {\n    config: {\n      GITHUB_API_BASE_URL: config.GITHUB_API_BASE_URL,\n      OPENAI_API_KEY: config.OPENAI_API_KEY,\n    },\n  });\n  console.log(JSON.stringify(logObj));\n}\nlogConfig();\n\n// ---------------------------------------------------------------------------------------------------------------------\n// Utility functions\n// ---------------------------------------------------------------------------------------------------------------------\n\nexport function logInfo(message) {\n  const additionalData = VERBOSE_MODE ? { verbose: true } : {};\n  const logObj = formatLogEntry(\"info\", message, additionalData);\n  console.log(JSON.stringify(logObj));\n}\n\nexport function logError(message, error) {\n  const additionalData = { error: error ? error.toString() : undefined };\n  if (VERBOSE_MODE && error && error.stack) {\n    additionalData.stack = error.stack;\n  }\n  const logObj = formatLogEntry(\"error\", message, additionalData);\n  console.error(JSON.stringify(logObj));\n}\n\n// ---------------------------------------------------------------------------------------------------------------------\n// AWS Utility functions\n// ---------------------------------------------------------------------------------------------------------------------\n\nexport function createSQSEventFromDigest(digest) {\n  return {\n    Records: [\n      {\n        eventVersion: \"2.0\",\n        eventSource: \"aws:sqs\",\n        eventTime: new Date().toISOString(),\n        eventName: \"SendMessage\",\n        body: JSON.stringify(digest),\n      },\n    ],\n  };\n}\n\n// ---------------------------------------------------------------------------------------------------------------------\n// SQS Lambda Handlers\n// ---------------------------------------------------------------------------------------------------------------------\n\nexport async function digestLambdaHandler(sqsEvent) {\n  logInfo(`Digest Lambda received event: ${JSON.stringify(sqsEvent)}`);\n\n  // If event.Records is an array, use it. Otherwise, treat the event itself as one record.\n  const sqsEventRecords = Array.isArray(sqsEvent.Records)\n    ? sqsEvent.Records\n    : [sqsEvent];\n\n  // Array to collect the identifiers of the failed records\n  const batchItemFailures = [];\n\n  for (const [index, sqsEventRecord] of sqsEventRecords.entries()) {\n    try {\n      const digest = JSON.parse(sqsEventRecord.body);\n      logInfo(`Record ${index}: Received digest: ${JSON.stringify(digest)}`);\n    } catch (error) {\n      // If messageId is missing, generate a fallback identifier including record index\n      const recordId =\n        sqsEventRecord.messageId ||\n        `fallback-${index}-${Date.now()}-${Math.random()\n          .toString(36)\n          .substr(2, 9)}`;\n      logError(`Error processing record ${recordId} at index ${index}`, error);\n      logError(\n        `Invalid JSON payload. Error: ${error.message}. Raw message: ${sqsEventRecord.body}`\n      );\n      batchItemFailures.push({ itemIdentifier: recordId });\n    }\n  }\n\n  // Return the list of failed messages so that AWS SQS can attempt to reprocess them.\n  return {\n    batchItemFailures,\n    handler: \"sandbox/source/main.digestLambdaHandler\",\n  };\n}\n\n// ---------------------------------------------------------------------------------------------------------------------\n// CLI Helper Functions\n// ---------------------------------------------------------------------------------------------------------------------\n\n// Function to generate CLI usage instructions\nfunction generateUsage() {\n  return `\nUsage:\n  --help                     Show this help message and usage instructions.\n  --digest                   Run a full bucket replay simulating an SQS event.\n  --version                  Show version information with current timestamp.\n  --agent \"<prompt>\"          Send a prompt to OpenAI and receive JSON response.\n`;\n}\n\n// Process the --help flag\nfunction processHelp(args) {\n  if (args.includes(\"--help\")) {\n    console.log(generateUsage());\n    return true;\n  }\n  return false;\n}\n\n// Process the --version flag\nasync function processVersion(args) {\n  if (args.includes(\"--version\")) {\n    try {\n      const { readFileSync } = await import(\"fs\");\n      const packageJsonPath = new URL(\"../../package.json\", import.meta.url);\n      const packageJson = JSON.parse(readFileSync(packageJsonPath, \"utf8\"));\n      const versionInfo = {\n        version: packageJson.version,\n        timestamp: new Date().toISOString(),\n      };\n      console.log(JSON.stringify(versionInfo));\n    } catch (error) {\n      logError(\"Failed to retrieve version\", error);\n    }\n    return true;\n  }\n  return false;\n}\n\n// Process the --digest flag\nasync function processDigest(args) {\n  if (args.includes(\"--digest\")) {\n    const exampleDigest = {\n      key: \"events/1.json\",\n      value: \"12345\",\n      lastModified: new Date().toISOString(),\n    };\n    const sqsEvent = createSQSEventFromDigest(exampleDigest);\n    await digestLambdaHandler(sqsEvent);\n    return true;\n  }\n  return false;\n}\n\n// Process the --agent flag\nexport async function processAgent(args) {\n  const idx = args.indexOf(\"--agent\");\n  if (idx === -1) {\n    return false;\n  }\n  globalThis.callCount++;\n  const prompt = args[idx + 1] || \"\";\n  try {\n    const configuration = new Configuration({ apiKey: config.OPENAI_API_KEY });\n    const client = new OpenAIApi(configuration);\n    const response = await client.createChatCompletion({\n      model: \"gpt-4\",\n      messages: [\n        { role: \"system\", content: \"You are an intelligent assistant.\" },\n        { role: \"user\", content: prompt },\n      ],\n    });\n    const content = response.data.choices[0].message.content;\n    let parsed;\n    try {\n      parsed = JSON.parse(content);\n    } catch (parseError) {\n      throw new Error(\n        `Invalid JSON response from OpenAI: ${parseError.message}`\n      );\n    }\n    console.log(JSON.stringify(parsed));\n  } catch (error) {\n    logError(\"Agent CLI failed\", error);\n  }\n  return true;\n}\n\n// ---------------------------------------------------------------------------------------------------------------------\n// Main CLI\n// ---------------------------------------------------------------------------------------------------------------------\n\nexport async function main(args = process.argv.slice(2)) {\n  if (await processAgent(args)) {\n    if (VERBOSE_STATS) {\n      console.log(\n        JSON.stringify({ callCount: globalThis.callCount, uptime: process.uptime() })\n      );\n    }\n    return;\n  }\n  if (processHelp(args)) {\n    if (VERBOSE_STATS) {\n      console.log(\n        JSON.stringify({ callCount: globalThis.callCount, uptime: process.uptime() })\n      );\n    }\n    return;\n  }\n  if (await processVersion(args)) {\n    if (VERBOSE_STATS) {\n      console.log(\n        JSON.stringify({ callCount: globalThis.callCount, uptime: process.uptime() })\n      );\n    }\n    return;\n  }\n  if (await processDigest(args)) {\n    if (VERBOSE_STATS) {\n      console.log(\n        JSON.stringify({ callCount: globalThis.callCount, uptime: process.uptime() })\n      );\n    }\n    return;\n  }\n\n  console.log(\"No command argument supplied.\");\n  console.log(generateUsage());\n  if (VERBOSE_STATS) {\n    console.log(\n      JSON.stringify({ callCount: globalThis.callCount, uptime: process.uptime() })\n    );\n  }\n}\n\n// Execute when run directly\nif (process.argv[1] === fileURLToPath(import.meta.url)) {\n  main().catch((err) => {\n    logError(\"Fatal error in main execution\", err);\n    process.exit(1);\n  });\n}\n",
  "updatedFile02Filepath": "sandbox/tests/main.test.js",
  "updatedFile02Contents": "// sandbox/tests/main.test.js\nimport { describe, test, expect, vi, beforeEach, afterEach } from \"vitest\";\nimport { main } from \"../source/main.js\";\nimport { OpenAIApi } from \"openai\";\n\nbeforeEach(() => {\n  globalThis.callCount = 0;\n});\n\nafterEach(() => {\n  vi.restoreAllMocks();\n});\n\ndescribe(\"--agent CLI command\", () => {\n  test(\"should log parsed JSON and increment callCount on success\", async () => {\n    const mockResponse = {\n      data: {\n        choices: [\n          { message: { content: JSON.stringify({ foo: \"bar\" }) } },\n        ],\n      },\n    };\n    vi.spyOn(OpenAIApi.prototype, \"createChatCompletion\").mockResolvedValue(mockResponse);\n    const logSpy = vi.spyOn(console, \"log\").mockImplementation(() => {});\n\n    await main([\"--agent\", \"test prompt\"]);\n\n    expect(logSpy).toHaveBeenCalledWith(JSON.stringify({ foo: \"bar\" }));\n    expect(globalThis.callCount).toBe(1);\n  });\n\n  test(\"should log error JSON on failure and increment callCount\", async () => {\n    const error = new Error(\"API failure\");\n    vi.spyOn(OpenAIApi.prototype, \"createChatCompletion\").mockRejectedValue(error);\n    const errorSpy = vi.spyOn(console, \"error\").mockImplementation(() => {});\n\n    await main([\"--agent\", \"fails prompt\"]);\n\n    expect(globalThis.callCount).toBe(1);\n    expect(errorSpy).toHaveBeenCalled();\n    const firstCallArg = errorSpy.mock.calls[0][0];\n    let parsed;\n    try {\n      parsed = JSON.parse(firstCallArg);\n    } catch {\n      parsed = null;\n    }\n    expect(parsed).not.toBeNull();\n    expect(parsed.level).toBe(\"error\");\n    expect(parsed.message).toBe(\"Agent CLI failed\");\n    expect(parsed.error).toContain(\"Error: API failure\");\n  });\n});\n",
  "updatedFile03Filepath": "sandbox/README.md",
  "updatedFile03Contents": "# agentic-lib\n\nAgentic-lib is a JavaScript library designed to serve as a drop-in SDK for enabling autonomous workflows in GitHub Actions and other automation pipelines. It provides CLI commands, AWS Lambda handlers, and utilities to streamline CI/CD processes by communicating through issues, branches, and events.\n\nFor more details, see [MISSION.md](../../MISSION.md) and [CONTRIBUTING.md](../../CONTRIBUTING.md).\n\nRepository: [https://github.com/xn-intenton-z2a/agentic-lib](https://github.com/xn-intenton-z2a/agentic-lib)\n\n## CLI Usage\n\nThe CLI supports several flags to interact with your workflows:\n\n  --help\n    Show this help message and usage instructions.\n\n  --digest\n    Run a full bucket replay simulating an SQS event.\n\n  --version\n    Show version information with the current timestamp.\n\n  --agent \"<prompt>\"\n    Send a prompt to the OpenAI API and receive a structured JSON response. Useful for CI/CD, GitHub Actions, and local automation.\n\n### Example\n\n```bash\nnode src/lib/main.js --agent \"Summarize the repository mission\"\n```\n\n### Sample Output\n\n```json\n{\"summary\":\"agentic-lib is a JavaScript library designed to serve as a drop-in SDK for enabling autonomous workflows in GitHub Actions and other automation pipelines.\"}\n```\n",
  "updatedFile04Filepath": "unused",
  "updatedFile04Contents": "unused",
  "updatedFile05Filepath": "unused",
  "updatedFile05Contents": "unused",
  "updatedFile06Filepath": "unused",
  "updatedFile06Contents": "unused",
  "updatedFile07Filepath": "unused",
  "updatedFile07Contents": "unused",
  "updatedFile08Filepath": "unused",
  "updatedFile08Contents": "unused",
  "updatedFile09Filepath": "unused",
  "updatedFile09Contents": "unused",
  "updatedFile10Filepath": "unused",
  "updatedFile10Contents": "unused",
  "updatedFile11Filepath": "unused",
  "updatedFile11Contents": "unused",
  "updatedFile12Filepath": "unused",
  "updatedFile12Contents": "unused",
  "updatedFile13Filepath": "unused",
  "updatedFile13Contents": "unused",
  "updatedFile14Filepath": "unused",
  "updatedFile14Contents": "unused",
  "updatedFile15Filepath": "unused",
  "updatedFile15Contents": "unused",
  "updatedFile16Filepath": "unused",
  "updatedFile16Contents": "unused"
}