{
  "message": "Add readiness endpoint, request duration histogram, and environment validation in server",
  "updatedFile01Filepath": "sandbox/source/server.js",
  "updatedFile01Contents": "import http from \"http\";\nimport { URL } from \"url\";\nimport { z } from \"zod\";\nimport dotenv from \"dotenv\";\nimport MarkdownIt from \"markdown-it\";\nimport markdownItGithub from \"markdown-it-github\";\n\ndotenv.config();\n\n// Validate environment variables\nconst envSchema = z.object({\n  PORT: z\n    .preprocess((val) => (val === undefined ? undefined : String(val)), z.string().regex(/^\\d+$/).default(\"3000\").transform((s) => parseInt(s, 10))),\n  CORS_ALLOWED_ORIGINS: z.string().default(\"*\"),\n  RATE_LIMIT_REQUESTS: z\n    .preprocess((val) => (val === undefined ? undefined : String(val)), z.string().regex(/^\\d+$/).default(\"60\").transform((s) => parseInt(s, 10))),\n  METRICS_USER: z.string().optional(),\n  METRICS_PASS: z.string().optional(),\n  DOCS_USER: z.string().optional(),\n  DOCS_PASS: z.string().optional(),\n});\nlet env;\ntry {\n  env = envSchema.parse(process.env);\n} catch (err) {\n  console.error(\"Invalid or missing environment variables for server:\", err.errors);\n  process.exit(1);\n}\n\n// Configuration\nconst PORT = env.PORT;\nconst CORS_ALLOWED_ORIGINS = env.CORS_ALLOWED_ORIGINS;\nconst RATE_LIMIT_REQUESTS = env.RATE_LIMIT_REQUESTS;\nconst METRICS_USER = env.METRICS_USER;\nconst METRICS_PASS = env.METRICS_PASS;\nconst DOCS_USER = env.DOCS_USER;\nconst DOCS_PASS = env.DOCS_PASS;\n\n// Metrics storage\nconst metrics = {\n  http_requests_total: {},\n  http_request_failures_total: {},\n  http_request_duration_seconds: [],\n};\n\n// Rate limiter per IP\nconst rateLimiters = new Map();\n\n// Minimal OpenAPI spec for available endpoints\nconst openApiSpec = {\n  openapi: \"3.0.0\",\n  info: { title: \"Agentic-lib Server API\", version: \"1.0.0\" },\n  paths: {\n    \"/health\": { get: { responses: { \"200\": { description: \"OK\" } } } },\n    \"/ready\": { get: { responses: { \"200\": { description: \"Ready\" } } } },\n    \"/metrics\": {\n      get: { responses: { \"200\": { description: \"Prometheus metrics including http_request_duration_seconds histogram\" } } },\n    },\n    \"/openapi.json\": { get: { responses: { \"200\": { description: \"OpenAPI JSON\" } } } },\n    \"/docs\": { get: { responses: { \"200\": { description: \"Interactive Docs\" } } } },\n  },\n};\n\n// Utility functions\nfunction recordRequest(method, route, status) {\n  const key = `${method}_${route}_${status}`;\n  metrics.http_requests_total[key] = (metrics.http_requests_total[key] || 0) + 1;\n}\n\nfunction recordFailure(route) {\n  metrics.http_request_failures_total[route] =\n    (metrics.http_request_failures_total[route] || 0) + 1;\n}\n\nfunction recordDuration(method, route, status, duration) {\n  metrics.http_request_duration_seconds.push({ method, route, status, duration });\n}\n\nfunction checkRateLimit(ip) {\n  const now = Date.now();\n  const windowMs = 60000;\n  const limit = RATE_LIMIT_REQUESTS;\n  let entry = rateLimiters.get(ip);\n  if (!entry) {\n    entry = { tokens: limit - 1, last: now };\n    rateLimiters.set(ip, entry);\n    return true;\n  }\n  const elapsed = now - entry.last;\n  const refill = Math.floor(elapsed / windowMs) * limit;\n  if (refill > 0) {\n    entry.tokens = Math.min(entry.tokens + refill, limit);\n    entry.last = now;\n  }\n  if (entry.tokens > 0) {\n    entry.tokens -= 1;\n    return true;\n  }\n  return false;\n}\n\nfunction basicAuth(req, user, pass) {\n  const auth = req.headers.authorization;\n  if (!auth || !auth.startsWith(\"Basic \")) return false;\n  const creds = Buffer.from(auth.slice(6), \"base64\").toString(\"utf8\");\n  const [u, p] = creds.split(\":\");\n  return u === user && p === pass;\n}\n\nfunction sendJson(res, statusCode, data) {\n  const body = JSON.stringify(data);\n  res.writeHead(statusCode, {\n    \"Content-Type\": \"application/json\",\n    \"Access-Control-Allow-Origin\": CORS_ALLOWED_ORIGINS,\n  });\n  res.end(body);\n}\n\nfunction sendText(res, statusCode, data) {\n  res.writeHead(statusCode, {\n    \"Content-Type\": \"text/plain\",\n    \"Access-Control-Allow-Origin\": CORS_ALLOWED_ORIGINS,\n  });\n  res.end(data);\n}\n\nasync function handler(req, res) {\n  const ip = req.socket.remoteAddress || \"unknown\";\n  const method = req.method;\n  const parsedUrl = new URL(req.url || \"\", `http://${req.headers.host}`);\n  const route = parsedUrl.pathname;\n  const start = process.hrtime();\n  let status = 200;\n\n  if (!checkRateLimit(ip)) {\n    status = 429;\n    recordFailure(\"rate_limit\");\n    res.writeHead(429);\n    res.end(\"Too Many Requests\");\n  } else {\n    try {\n      if (method === \"GET\" && route === \"/health\") {\n        const data = { status: \"ok\", uptime: process.uptime(), timestamp: new Date().toISOString() };\n        sendJson(res, 200, data);\n        status = 200;\n        recordRequest(method, \"health\", status);\n      } else if (method === \"GET\" && route === \"/ready\") {\n        const data = { status: \"ready\", timestamp: new Date().toISOString() };\n        sendJson(res, 200, data);\n        status = 200;\n        recordRequest(method, \"ready\", status);\n      } else if (method === \"GET\" && route === \"/metrics\") {\n        if (METRICS_USER && METRICS_PASS && !basicAuth(req, METRICS_USER, METRICS_PASS)) {\n          status = 401;\n          recordFailure(\"metrics_auth\");\n          res.writeHead(401, { \"WWW-Authenticate\": \"Basic realm=\\\"Metrics\\\"\" });\n          return res.end(\"Unauthorized\");\n        }\n        let out = \"\";\n        for (const key in metrics.http_requests_total) {\n          const [m, r, s] = key.split(\"_\");\n          out += `http_requests_total{method=\\\"${m}\\\",route=\\\"${r}\\\",status=\\\"${s}\\\"} ${metrics.http_requests_total[key]}\\n`;\n        }\n        for (const r in metrics.http_request_failures_total) {\n          out += `http_request_failures_total{route=\\\"${r}\\\"} ${metrics.http_request_failures_total[r]}\\n`;\n        }\n        for (const entry of metrics.http_request_duration_seconds) {\n          out += `http_request_duration_seconds{method=\\\"${entry.method}\\\",route=\\\"${entry.route}\\\",status=\\\"${entry.status}\\\"} ${entry.duration}\\n`;\n        }\n        sendText(res, 200, out);\n        status = 200;\n        recordRequest(method, \"metrics\", status);\n      } else if (method === \"GET\" && route === \"/openapi.json\") {\n        sendJson(res, 200, openApiSpec);\n        status = 200;\n        recordRequest(method, \"openapi\", status);\n      } else if (method === \"GET\" && route === \"/docs\") {\n        if (DOCS_USER && DOCS_PASS && !basicAuth(req, DOCS_USER, DOCS_PASS)) {\n          status = 401;\n          recordFailure(\"docs_auth\");\n          res.writeHead(401, { \"WWW-Authenticate\": \"Basic realm=\\\"Docs\\\"\" });\n          return res.end(\"Unauthorized\");\n        }\n        const md = new MarkdownIt().use(markdownItGithub);\n        const mdContent = \"```json\\n\" + JSON.stringify(openApiSpec, null, 2) + \"\\n```\";\n        const html = md.render(mdContent);\n        res.writeHead(200, {\n          \"Content-Type\": \"text/html\",\n          \"Access-Control-Allow-Origin\": CORS_ALLOWED_ORIGINS,\n        });\n        res.end(html);\n        status = 200;\n        recordRequest(method, \"docs\", status);\n      } else {\n        status = 404;\n        recordFailure(route);\n        res.writeHead(404);\n        res.end(\"Not Found\");\n      }\n    } catch (err) {\n      status = 500;\n      recordFailure(route);\n      res.writeHead(500);\n      res.end(\"Internal Server Error\");\n    }\n  }\n\n  // Record duration for each request\n  const [sec, nanosec] = process.hrtime(start);\n  const duration = sec + nanosec / 1e9;\n  recordDuration(method, route, status, duration);\n}\n\nexport function startServer(options = {}) {\n  const port = options.port || PORT;\n  const server = http.createServer(handler);\n  server.listen(port);\n  console.log(`Server started on port ${port}`);\n  return server;\n}\n",
  "updatedFile02Filepath": "sandbox/tests/server.test.js",
  "updatedFile02Contents": "import { describe, test, expect, beforeAll, afterAll } from 'vitest';\nimport http from 'http';\nimport { startServer } from '../source/server.js';\n\nlet server;\nlet base;\n\nbeforeAll(() => {\n  server = startServer({ port: 0 });\n  const addr = server.address();\n  const port = typeof addr === 'object' && addr !== null ? addr.port : 3000;\n  base = `http://127.0.0.1:${port}`;\n});\n\nafterAll(() => {\n  server.close();\n});\n\nfunction request(path) {\n  return new Promise((resolve, reject) => {\n    http\n      .get(base + path, (res) => {\n        let data = '';\n        res.on('data', (chunk) => (data += chunk));\n        res.on('end', () => resolve({ statusCode: res.statusCode, body: data }));\n      })\n      .on('error', reject);\n  });\n}\n\ndescribe('Server', () => {\n  test('/health returns status ok', async () => {\n    const { statusCode, body } = await request('/health');\n    expect(statusCode).toBe(200);\n    const json = JSON.parse(body);\n    expect(json.status).toBe('ok');\n    expect(typeof json.uptime).toBe('number');\n    expect(typeof json.timestamp).toBe('string');\n  });\n\n  test('/metrics returns metrics without auth when not configured', async () => {\n    const { statusCode, body } = await request('/metrics');\n    expect(statusCode).toBe(200);\n    expect(body).toContain('http_requests_total');\n  });\n\n  test('/ready returns status ready', async () => {\n    const { statusCode, body } = await request('/ready');\n    expect(statusCode).toBe(200);\n    const json = JSON.parse(body);\n    expect(json.status).toBe('ready');\n    expect(typeof json.timestamp).toBe('string');\n    expect(new Date(json.timestamp).toString()).not.toBe('Invalid Date');\n  });\n\n  test('metrics includes http_request_duration_seconds after calls', async () => {\n    await request('/health');\n    await request('/ready');\n    const { statusCode, body } = await request('/metrics');\n    expect(statusCode).toBe(200);\n    const lines = body.split('\\n');\n    const durationLines = lines.filter((line) =>\n      line.startsWith('http_request_duration_seconds'),\n    );\n    expect(durationLines.length).toBeGreaterThanOrEqual(2);\n    durationLines.forEach((line) => {\n      expect(line).toMatch(\n        /^http_request_duration_seconds\\{method=\"GET\",route=\"\\/(health|ready)\",status=\"200\"\\} \\d+\\.?\\d*$/,\n      );\n    });\n  });\n});\n",
  "updatedFile03Filepath": "sandbox/docs/SERVER.md",
  "updatedFile03Contents": "# HTTP Server Feature\n\n## Mission Alignment\n\nThe HTTP server provides critical observability endpoints (health, readiness, metrics, OpenAPI schema, docs) to support continuous monitoring and self-hosted documentation in line with our mission to enable autonomous, agentic workflows. For mission details, see [Mission Statement](../MISSION.md).\n\nThis document describes how to launch the built-in HTTP server provided by agentic-lib, exposing key endpoints.\n\n## Programmatic Usage\n\nImport the `startServer` function and call it in your Node.js application:\n\n```js\nimport { startServer } from \"@xn-intenton-z2a/agentic-lib\";\n\n// Optionally, pass configuration options:\nconst options = {\n  port: process.env.PORT || 3000,\n  // CORS_ALLOWED_ORIGINS, RATE_LIMIT_REQUESTS, METRICS_USER, METRICS_PASS, DOCS_USER, DOCS_PASS\n};\n\nstartServer(options);\n```\n\n## Endpoints\n\n- **GET /health**  \n  Liveness probe. Returns JSON:\n  ```json\n  { \"status\": \"ok\", \"uptime\": <seconds>, \"timestamp\": \"<ISO>\" }\n  ```\n\n- **GET /ready**  \n  Readiness probe. Returns JSON:\n  ```json\n  { \"status\": \"ready\", \"timestamp\": \"<ISO>\" }\n  ```\n\n- **GET /metrics**  \n  Prometheus-formatted metrics. Exposes:\n  - `http_requests_total{method,route,status}`\n  - `http_request_failures_total{route}`\n  - `http_request_duration_seconds{method,route,status}` (request duration histogram)\n  Protected by Basic Auth if `METRICS_USER`/`METRICS_PASS` are set.\n\n- **GET /openapi.json**  \n  Returns the OpenAPI 3.0 schema for all endpoints.\n\n- **GET /docs**  \n  Renders the OpenAPI schema as HTML via Markdown. Protected by Basic Auth if `DOCS_USER`/`DOCS_PASS` are set.\n\n## Configuration\n\nEnvironment variables:\n\n- `PORT` (default `3000`)\n- `CORS_ALLOWED_ORIGINS` (default `*`)\n- `RATE_LIMIT_REQUESTS` (requests per minute, default `60`)\n- `METRICS_USER`, `METRICS_PASS` (for `/metrics` Basic Auth)\n- `DOCS_USER`, `DOCS_PASS` (for `/docs` Basic Auth)\n\n## Rate Limiting\n\nIP-based token bucket with the following behavior:\n\n- Each IP has a token bucket of `RATE_LIMIT_REQUESTS` tokens per minute.\n- Exceeding the limit returns `429 Too Many Requests`.\n",
  "updatedFile04Filepath": "sandbox/README.md",
  "updatedFile04Contents": "## Mission Statement\n\nThis project is guided by the core mission of agentic-lib to enable autonomous, continuous agentic interactions through issues, branches, and pull requests. For full mission details, see [Mission Statement](../MISSION.md).\n\n# agentic-lib\n\n`agentic-lib` is a drop-in JavaScript SDK for autonomous GitHub workflows. Inspired by our mission to enable continuous, agentic interactions through issues, branches, and pull requests, this library provides core utilities to configure environments, handle AWS SQS events, power CLI-driven workflows, and optionally launch a self-hosted HTTP server for health, readiness, metrics, and documentation.\n\nWith `agentic-lib`, you can seamlessly integrate environment validation, structured logging, AWS utilities, Lambda handlers, CLI and programmatic workflows into your Node.js projects, ensuring reproducible, testable, and maintainable automation.\n\n## Key Features\n\n- **Environment configuration** (dotenv + Zod)  \n  Mission Alignment: Validates and loads environment variables to ensure consistent, reproducible conditions essential for autonomous workflows.\n- **Logging helpers** (logInfo, logError)  \n  Mission Alignment: Provides structured, consistent logs to enable transparent audit trails for agentic operations.\n- **AWS utilities** (createSQSEventFromDigest)  \n  Mission Alignment: Simplifies SQS event creation for seamless integration into continuous, event-driven workflows.\n- **Lambda handler** (digestLambdaHandler)  \n  Mission Alignment: Automates message processing and error handling to maintain continuous, autonomous system reliability.\n- **HTTP Server** (startServer function with `/health`, `/ready`, `/metrics`, `/openapi.json`, `/docs` endpoints, with configurable rate limiting and Basic Auth support)  \n  Mission Alignment: Exposes self-hosted endpoints for observability, readiness checks, metrics (including request duration histogram), and interactive documentation, supporting ongoing, autonomous monitoring.\n- **Request duration histogram** (`http_request_duration_seconds{method,route,status}`)  \n  Mission Alignment: Exposes request duration metrics for performance monitoring.\n- **CLI flags**: `--help`, `--version`, `--digest`  \n  Mission Alignment: Offers intuitive CLI interfaces to drive agentic workflows directly from the command line.\n",
  "updatedFile05Filepath": "unused",
  "updatedFile05Contents": "unused",
  "updatedFile06Filepath": "unused",
  "updatedFile06Contents": "unused",
  "updatedFile07Filepath": "unused",
  "updatedFile07Contents": "unused",
  "updatedFile08Filepath": "unused",
  "updatedFile08Contents": "unused",
  "updatedFile09Filepath": "unused",
  "updatedFile09Contents": "unused",
  "updatedFile10Filepath": "unused",
  "updatedFile10Contents": "unused",
  "updatedFile11Filepath": "unused",
  "updatedFile11Contents": "unused",
  "updatedFile12Filepath": "unused",
  "updatedFile12Contents": "unused",
  "updatedFile13Filepath": "unused",
  "updatedFile13Contents": "unused",
  "updatedFile14Filepath": "unused",
  "updatedFile14Contents": "unused",
  "updatedFile15Filepath": "unused",
  "updatedFile15Contents": "unused",
  "updatedFile16Filepath": "unused",
  "updatedFile16Contents": "unused"
}