sandbox/tests/unit/metrics.test.js
# sandbox/tests/unit/metrics.test.js
import { describe, test, expect, vi, beforeEach } from "vitest";
import * as fs from "fs";
import path from "path";
import {
  loadMetrics,
  saveMetrics,
  digestLambdaHandler,
  main,
  createSQSEventFromDigest,
} from "../../../src/lib/main.js";

describe("Metrics Tracking and Persistence", () => {
  const metricsPath = path.join(process.cwd(), ".agentic_metrics.json");

  beforeEach(() => {
    vi.restoreAllMocks();
  });

  test("loadMetrics returns defaults when metrics file is missing", () => {
    vi.spyOn(fs, "existsSync").mockReturnValue(false);
    const metrics = loadMetrics();
    expect(metrics).toEqual({ totalIssues: 0, successfulCommits: 0 });
  });

  test("loadMetrics returns parsed metrics when file exists", () => {
    vi.spyOn(fs, "existsSync").mockReturnValue(true);
    vi.spyOn(fs, "readFileSync").mockReturnValue(
      JSON.stringify({ totalIssues: 3, successfulCommits: 1 })
    );
    const metrics = loadMetrics();
    expect(metrics).toEqual({ totalIssues: 3, successfulCommits: 1 });
  });

  test("saveMetrics writes metrics JSON to file", () => {
    const writeSpy = vi.spyOn(fs, "writeFileSync").mockImplementation(() => {});
    const metricsObj = { totalIssues: 5, successfulCommits: 2 };
    saveMetrics(metricsObj);
    expect(writeSpy).toHaveBeenCalledWith(metricsPath, JSON.stringify(metricsObj));
  });

  test("digestLambdaHandler increments metrics and persists once", async () => {
    // initial metrics
    vi.spyOn(fs, "existsSync").mockReturnValue(true);
    vi.spyOn(fs, "readFileSync").mockReturnValue(
      JSON.stringify({ totalIssues: 0, successfulCommits: 0 })
    );
    const writeSpy = vi.spyOn(fs, "writeFileSync").mockImplementation(() => {});
    const digest = { key: "x", value: "y", lastModified: new Date().toISOString() };
    const sqsEvent = createSQSEventFromDigest(digest);

    const result = await digestLambdaHandler(sqsEvent);

    expect(result).toHaveProperty("batchItemFailures");
    expect(writeSpy).toHaveBeenCalledTimes(1);
    expect(writeSpy).toHaveBeenCalledWith(
      metricsPath,
      JSON.stringify({ totalIssues: 1, successfulCommits: 1 })
    );
  });
});

describe("CLI Reporting", () => {
  beforeEach(() => {
    vi.restoreAllMocks();
  });

  test("main --stats prints zeroed metrics", async () => {
    vi.spyOn(fs, "existsSync").mockReturnValue(false);
    const logSpy = vi.spyOn(console, "log").mockImplementation(() => {});
    await main(["--stats"]);
    expect(logSpy).toHaveBeenCalledWith(
      JSON.stringify({ totalIssues: 0, successfulCommits: 0, conversionRate: 0 })
    );
  });

  test("main --digest --stats increments and prints metrics", async () => {
    // initial metrics
    vi.spyOn(fs, "existsSync").mockReturnValue(true);
    vi.spyOn(fs, "readFileSync").mockReturnValue(
      JSON.stringify({ totalIssues: 1, successfulCommits: 1 })
    );
    const writeSpy = vi.spyOn(fs, "writeFileSync").mockImplementation(() => {});
    const logSpy = vi.spyOn(console, "log").mockImplementation(() => {});

    await main(["--digest", "--stats"]);

    // Expect digest processed -> write metrics, then print stats
    const calls = logSpy.mock.calls;
    const lastCall = calls[calls.length - 1][0];
    expect(lastCall).toBe(JSON.stringify({ totalIssues: 2, successfulCommits: 2, conversionRate: 1 }));
    expect(writeSpy).toHaveBeenCalledWith(
      metricsPath,
      JSON.stringify({ totalIssues: 2, successfulCommits: 2 })
    );
  });

  test("main --help --verbose-stats appends metrics after help", async () => {
    vi.spyOn(fs, "existsSync").mockReturnValue(false);
    const logSpy = vi.spyOn(console, "log").mockImplementation(() => {});
    await main(["--help", "--verbose-stats"]);
    // First call is usage, second is stats
    expect(logSpy).toHaveBeenCalledTimes(2);
    expect(logSpy).toHaveBeenCalledWith(expect.stringContaining("Usage:"));
    expect(logSpy).toHaveBeenCalledWith(JSON.stringify({ totalIssues: 0, successfulCommits: 0, conversionRate: 0 }));
  });
});