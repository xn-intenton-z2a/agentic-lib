Apps/Creating GitHub Apps/Authenticate with a GitHub App/About authenticationAbout authentication with a GitHub AppYour GitHub App can authenticate as itself, as an app installation, or on behalf of a user.In this articleAuthentication as a GitHub AppAuthentication as an app installationAuthentication on behalf of a userAuthentication as a GitHub App
To authenticate as itself, your app will use a JSON Web Token (JWT). Your app should authenticate as itself when it needs to generate an installation access token. An installation access token is required to authenticate as an app installation. Your app should also authenticate as itself when it needs to make API requests to manage resources related to the app. For example, when it needs to list the accounts where it is installed. For more information, see Authenticating as a GitHub App and Generating a JSON Web Token (JWT) for a GitHub App.
Authentication as an app installation
To authenticate as an installation, your app will use an installation access token. Your app should authenticate as an app installation when you want to attribute app activity to the app. Authenticating as an app installation lets your app access resources that are owned by the user or organization that installed the app. Authenticating as an app installation is ideal for automation workflows that don't involve user input. For more information, see Authenticating as a GitHub App installation and Generating an installation access token for a GitHub App.
Authentication on behalf of a user
To authenticate on behalf of a user, your app will use a user access token. Your app should authenticate on behalf of a user when you want to attribute app activity to a user. Similar to authenticating as an app installation, your app can access resources that are owned by the user or organization that installed the app. Authenticating on behalf of a user is ideal when you want to ensure that your app only takes actions that could be performed by a specific user. For more information, see Authenticating with a GitHub App on behalf of a user and Generating a user access token for a GitHub App.\n\n\n\nApps/Creating GitHub Apps/Authenticate with a GitHub App/About authenticationAbout authentication with a GitHub AppYour GitHub App can authenticate as itself, as an app installation, or on behalf of a user.In this articleAuthentication as a GitHub AppAuthentication as an app installationAuthentication on behalf of a userAuthentication as a GitHub App
To authenticate as itself, your app will use a JSON Web Token (JWT). Your app should authenticate as itself when it needs to generate an installation access token. An installation access token is required to authenticate as an app installation. Your app should also authenticate as itself when it needs to make API requests to manage resources related to the app. For example, when it needs to list the accounts where it is installed. For more information, see Authenticating as a GitHub App and Generating a JSON Web Token (JWT) for a GitHub App.
Authentication as an app installation
To authenticate as an installation, your app will use an installation access token. Your app should authenticate as an app installation when you want to attribute app activity to the app. Authenticating as an app installation lets your app access resources that are owned by the user or organization that installed the app. Authenticating as an app installation is ideal for automation workflows that don't involve user input. For more information, see Authenticating as a GitHub App installation and Generating an installation access token for a GitHub App.
Authentication on behalf of a user
To authenticate on behalf of a user, your app will use a user access token. Your app should authenticate on behalf of a user when you want to attribute app activity to a user. Similar to authenticating as an app installation, your app can access resources that are owned by the user or organization that installed the app. Authenticating on behalf of a user is ideal when you want to ensure that your app only takes actions that could be performed by a specific user. For more information, see Authenticating with a GitHub App on behalf of a user and Generating a user access token for a GitHub App.\n\n\n\nGitHub DocsHelp for wherever you are on your GitHub journey.Get startedGet startedMigrationsAccount and profileAuthenticationBilling and paymentsSite policyCollaborative codingCodespacesRepositoriesPull requestsGitHub DiscussionsGitHub CopilotGitHub CopilotGet code suggestionsPrompt engineeringChat in GitHubCopilot Chat CookbookExtensions quickstartCI/CD and DevOpsGitHub ActionsGitHub PackagesGitHub PagesSecuritySecure codingSecret scanningSupply chain securityDependabotCode scanningSecurity advisoriesClient appsGitHub CLIGitHub MobileGitHub DesktopProject managementGitHub IssuesProjectsSearch on GitHubEnterprise and TeamsOrganizationsSecure your organizationEnterprise onboardingEnterprise administratorsGitHub Well-ArchitectedDevelopersAppsREST APIGraphQL APIWebhooksBuild Copilot ExtensionsGitHub ModelsCommunityBuilding communitiesGitHub SponsorsGitHub EducationGitHub for NonprofitsGitHub SupportContribute to GitHub DocsMore docsCodeQL query writingElectronnpmGetting startedSet up GitAt the heart of GitHub is an open-source version control system (VCS) called Git. Git is responsible for everything GitHub-related that happens locally on your computer.Connecting to GitHub with SSHYou can connect to GitHub using the Secure Shell Protocol (SSH), which provides a secure channel over an unsecured network.Creating and managing repositoriesYou can create a repository on GitHub to store and collaborate on your project's files, then manage the repository's name and location.Basic writing and formatting syntaxCreate sophisticated formatting for your prose and code on GitHub with simple syntax.PopularAbout pull requestsLearn about pull requests and draft pull requests on GitHub. Pull requests communicate changes to a branch in a repository. Once a pull request is opened, you can review changes with collaborators and add follow-up commits.Authentication documentationKeep your account and data secure with features like two-factor authentication, SSH, and commit signature verification.Getting code suggestions in your IDE with GitHub CopilotUse GitHub Copilot to get code suggestions in your editor.Managing remote repositoriesLearn to work with your local repositories on your computer and remote repositories hosted on GitHub.\n\n\n\nGitHub Apps documentation Go deeper with GitHub by integrating with our APIs and webhooks, customizing your GitHub workflow, and building and sharing apps with the community.Overview Quickstart Start hereAbout using GitHub AppsLearn about what a GitHub App is and why you would use a GitHub App.About creating GitHub AppsGitHub Apps let you build integrations to automate processes and extend GitHub's functionality.Differences between GitHub Apps and OAuth appsIn general, GitHub Apps are preferred to OAuth apps because they use fine-grained permissions, give more control over which repositories the app can access, and use short-lived tokens.About authentication with a GitHub AppYour GitHub App can authenticate as itself, as an app installation, or on behalf of a user.PopularRegistering a GitHub AppYou can register a GitHub App under your personal account or under any organization you own.Authorizing GitHub AppsYou can authorize a GitHub App to retrieve information about your GitHub account and to make changes on your behalf.Building a GitHub App that responds to webhook eventsLearn how to build a GitHub App that makes an API request in response to a webhook event.Building a "Login with GitHub" button with a GitHub AppFollow this tutorial to write Ruby code to generate a user access token via the web application flow for your GitHub App.What's newView all Updated GitHub App visibility for Enterprise Managed UsersMarch 29You can pick your account during device flow loginJanuary 05X-Accepted-GitHub-Permissions header for fine-grained permission actorsAugust 10GuidesBuilding a GitHub App that responds to webhook eventsLearn how to build a GitHub App that makes an API request in response to a webhook event.@GitHubBuilding a "Login with GitHub" button with a GitHub AppFollow this tutorial to write Ruby code to generate a user access token via the web application flow for your GitHub App.@GitHubBuilding a CLI with a GitHub AppFollow this tutorial to write a CLI in Ruby that generates a user access token for a GitHub App via the device flow.@GitHubMaking authenticated API requests with a GitHub App in a GitHub Actions workflowYou can use an installation access token from a GitHub App to make authenticated API requests in a GitHub Actions workflow. You can also pass the token to a custom action to enable the action to make authenticated API requests.@GitHubAll Apps docsUsing GitHub AppsAbout using GitHub AppsInstalling a GitHub App from GitHub Marketplace for your personal accountInstalling a GitHub App from GitHub Marketplace for your organizationsInstalling a GitHub App from a third partyInstalling your own GitHub AppRequesting a GitHub App from your organization ownerAuthorizing GitHub AppsApproving updated permissions for a GitHub AppReviewing and revoking authorization of GitHub AppsReviewing and modifying installed GitHub AppsPrivileged GitHub AppsCreating GitHub AppsAbout creating GitHub Apps • 4 articlesRegistering a GitHub App • 8 articlesAuthenticating with a GitHub App • 10 articlesWriting code for a GitHub App • 6 articlesSharing GitHub AppsSharing your GitHub AppMaking your GitHub App available for GitHub Enterprise ServerRegistering a GitHub App from a manifestRegistering a GitHub App using URL parametersMaintaining GitHub AppsModifying a GitHub App registrationActivating optional features for GitHub AppsAbout GitHub App managersManaging allowed IP addresses for a GitHub AppSuspending a GitHub App installationTransferring ownership of a GitHub AppDeleting a GitHub AppGitHub MarketplaceGitHub Marketplace Overview • 3 articlesCreating apps for GitHub Marketplace • 5 articlesUsing the GitHub Marketplace API in your app • 6 articlesListing an app on GitHub Marketplace • 6 articlesSelling your app on GitHub Marketplace • 3 articlesOAuth appsUsing OAuth apps • 6 articlesBuilding OAuth apps • 8 articlesMaintaining OAuth apps • 6 articles\n\n\n\nApps/Creating GitHub AppsCreating GitHub AppsYou can build GitHub Apps for yourself or others to use.About creating GitHub AppsAbout creating GitHub AppsDeciding when to build a GitHub AppBest practices for creating a GitHub AppMigrating OAuth apps to GitHub AppsRegistering a GitHub AppRegistering a GitHub AppAbout the user authorization callback URLAbout the setup URLChoosing permissions for a GitHub AppUsing webhooks with GitHub AppsMaking a GitHub App public or privateRate limits for GitHub AppsCreating a custom badge for your GitHub AppAuthenticating with a GitHub AppAbout authentication with a GitHub AppAuthenticating as a GitHub AppAuthenticating as a GitHub App installationAuthenticating with a GitHub App on behalf of a userManaging private keys for GitHub AppsGenerating a JSON Web Token (JWT) for a GitHub AppGenerating an installation access token for a GitHub AppGenerating a user access token for a GitHub AppRefreshing user access tokensMaking authenticated API requests with a GitHub App in a GitHub Actions workflowWriting code for a GitHub AppAbout writing code for a GitHub AppQuickstart for building GitHub AppsBuilding a GitHub App that responds to webhook eventsBuilding a "Login with GitHub" button with a GitHub AppBuilding a CLI with a GitHub AppBuilding CI checks with a GitHub App\n\n\n\nApps/Creating GitHub Apps/Authenticate with a GitHub AppAuthenticating with a GitHub AppLearn how to authenticate with GitHub Apps.About authentication with a GitHub AppYour GitHub App can authenticate as itself, as an app installation, or on behalf of a user.Authenticating as a GitHub AppYou can authenticate as a GitHub App in order to generate an installation access token or manage your app.Authenticating as a GitHub App installationYou can make your GitHub App authenticate as an installation in order to make API requests that affect resources owned by the account where the app is installed.Authenticating with a GitHub App on behalf of a userYour GitHub App can perform actions on behalf of a user, like creating an issue, posting a comment, or creating a deployment.Managing private keys for GitHub AppsYou can manage private keys to authenticate with your GitHub App.Generating a JSON Web Token (JWT) for a GitHub AppLearn how to create a JSON Web Token (JWT) to authenticate to certain REST API endpoints with your GitHub App.Generating an installation access token for a GitHub AppLearn how to generate an installation access token for your GitHub App.Generating a user access token for a GitHub AppYou can generate a user access token for your GitHub App in order to attribute app activity to a user.Refreshing user access tokensTo enforce regular token rotation and reduce the impact of a compromised token, you can configure your GitHub App to use user access tokens that expire.Making authenticated API requests with a GitHub App in a GitHub Actions workflowYou can use an installation access token from a GitHub App to make authenticated API requests in a GitHub Actions workflow. You can also pass the token to a custom action to enable the action to make authenticated API requests.\n\n\n\nApps/Creating GitHub Apps/Authenticate with a GitHub App/About authenticationAbout authentication with a GitHub AppYour GitHub App can authenticate as itself, as an app installation, or on behalf of a user.In this articleAuthentication as a GitHub AppAuthentication as an app installationAuthentication on behalf of a userAuthentication as a GitHub App
To authenticate as itself, your app will use a JSON Web Token (JWT). Your app should authenticate as itself when it needs to generate an installation access token. An installation access token is required to authenticate as an app installation. Your app should also authenticate as itself when it needs to make API requests to manage resources related to the app. For example, when it needs to list the accounts where it is installed. For more information, see Authenticating as a GitHub App and Generating a JSON Web Token (JWT) for a GitHub App.
Authentication as an app installation
To authenticate as an installation, your app will use an installation access token. Your app should authenticate as an app installation when you want to attribute app activity to the app. Authenticating as an app installation lets your app access resources that are owned by the user or organization that installed the app. Authenticating as an app installation is ideal for automation workflows that don't involve user input. For more information, see Authenticating as a GitHub App installation and Generating an installation access token for a GitHub App.
Authentication on behalf of a user
To authenticate on behalf of a user, your app will use a user access token. Your app should authenticate on behalf of a user when you want to attribute app activity to a user. Similar to authenticating as an app installation, your app can access resources that are owned by the user or organization that installed the app. Authenticating on behalf of a user is ideal when you want to ensure that your app only takes actions that could be performed by a specific user. For more information, see Authenticating with a GitHub App on behalf of a user and Generating a user access token for a GitHub App.\n\n\n\nApps/OverviewGitHub Apps overviewYou can use GitHub Apps to extend the functionality of GitHub.In this articleAbout GitHub AppsGitHub Apps and OAuth appsAbout GitHub Apps
GitHub Apps are tools that extend GitHub's functionality. GitHub Apps can do things on GitHub like open issues, comment on pull requests, and manage projects. They can also do things outside of GitHub based on events that happen on GitHub. For example, a GitHub App can post on Slack when an issue is opened on GitHub.
For more information about using GitHub Apps, see About using GitHub Apps.
For more information about building GitHub Apps, see About creating GitHub Apps.
GitHub Apps and OAuth apps
GitHub also supports OAuth apps. In general, GitHub Apps are preferred over OAuth apps. GitHub Apps use fine-grained permissions, give the user more control over which repositories the app can access, and use short-lived tokens. These properties can harden the security of the app by limiting the damage that could be done if the app's credentials were leaked. For more information, see Differences between GitHub Apps and OAuth apps.\n\n\n\nApps/Using GitHub Apps/About using appsAbout using GitHub AppsLearn about what a GitHub App is and why you would use a GitHub App.In this articleAbout GitHub AppsFinding GitHub AppsUsing GitHub AppsGitHub Apps and OAuth appsAbout GitHub Apps
GitHub Apps are tools that extend GitHub's functionality. GitHub Apps can do things on GitHub like open issues, comment on pull requests, and manage projects. They can also do things outside of GitHub based on events that happen on GitHub. For example, a GitHub App can post on Slack when an issue is opened on GitHub.
Finding GitHub Apps
You can discover GitHub Apps on GitHub Marketplace.
You can also build your own GitHub App. For more information, see About creating GitHub Apps.
Using GitHub Apps
In order to use a GitHub App, you must install the app on your user or organization account. When you install the app, you grant the app permission to read or modify your repository and organization data. The specific permissions depends on the app, and GitHub will tell you what permissions the app requested before you install the app. When you install the app, you will also specify what repositories the app can access. If the app requires any additional configuration, the app will direct you to do so. For more information, see Installing a GitHub App from GitHub Marketplace for your personal account, Installing a GitHub App from GitHub Marketplace for your organizations, Installing a GitHub App from a third party and Installing your own GitHub App.
You may also need to authorize a GitHub App to verify your identity, know what resources you can access, or take actions on your behalf. If you need to authorize the app, the app will prompt you to do so. For more information, see Authorizing GitHub Apps.
Occasionally, the GitHub App will request updated permissions. GitHub will notify you when this occurs. In order for the app to continue to function, you will need to review and approve the updated permissions. For more information, see Approving updated permissions for a GitHub App.
Before you install or authorize a GitHub App, you should make sure that you trust the app developer. If you no longer use the app, you should suspend or uninstall the app and/or revoke your authorization of the app. For more information, see Reviewing and modifying installed GitHub Apps and Reviewing and revoking authorization of GitHub Apps.
GitHub Apps and OAuth apps
GitHub also supports OAuth apps. Unlike GitHub Apps, you do not install an OAuth app or control what repositories it can access.
Both OAuth apps and GitHub Apps use OAuth 2.0.
OAuth apps can only act on behalf of a user, while GitHub Apps can either act on behalf of a user or independently of a user.
For more information, see Differences between GitHub Apps and OAuth apps and Authorizing OAuth apps.\n\n\n\nApps/Using GitHub Apps/Install from Marketplace for userInstalling a GitHub App from GitHub Marketplace for your personal accountYou can install GitHub Apps from GitHub Marketplace to use on your personal account.In this articleAbout GitHub MarketplaceAbout installing GitHub AppsInstalling a GitHub App in your personal accountFurther readingAbout GitHub Marketplace
This article applies to installing and purchasing GitHub Apps from GitHub Marketplace. For more information on installing GitHub Apps from a source other than GitHub Marketplace, see Installing a GitHub App from a third party.
If you install a GitHub App on your personal account and you choose a paid plan, you will pay for your app subscription on your personal account's current billing date using your existing payment method.
If you choose a paid plan with a free trial, you can cancel at any time during your trial period without being charged, but you will automatically lose access to the app. Your paid subscription will start at the end of the 14-day trial. For more information, see About billing for GitHub Marketplace.
For more information about installing an OAuth app instead of a GitHub App from GitHub Marketplace, see Installing an OAuth app in your personal account.
About installing GitHub Apps
In order to use a GitHub App on your repositories or organization, you must install the app on your organization or personal account. You can install the same GitHub App on multiple accounts. For example, if you install the app on your personal account and on a few organizations that you own, you'll be able to use the app on your personal repositories, on the organizations where you installed the app, and on repositories owned by those organizations.
When you install an app, you grant the app permission to access the organization and repository resources that it requested. During the installation process, GitHub will tell you which permissions the GitHub App requested. For more information about the REST API requests the GitHub App can make with those permissions, see Permissions required for GitHub Apps.
When you install an app, you will also choose which repositories to grant the GitHub App access to.
Before installing a GitHub App, you should ensure you trust the owner of the GitHub App. You should also review the permissions that the GitHub App is requesting and make sure you are comfortable granting those permissions. For more information about the REST API requests the GitHub App can make with those permissions, see Permissions required for GitHub Apps.
There is no limit to how many apps you can install.
Difference between installation and authorization
After you install a GitHub App, you may also be asked to authorize the app.
When you install a GitHub App on your account or organization, you grant the app permission to access the organization and repository resources that it requested. You also specify which repositories the app can access. During the installation process, the GitHub App will indicate which repository and organization permissions you are granting. For more information about what different permissions enable a GitHub App to do, see Choosing permissions for a GitHub App.
For example, you might grant the GitHub App permission to read repository metadata and write issues, and you might grant the GitHub App access to all of your repositories.

When you authorize a GitHub App, you grant the app access to your GitHub account, based on the account permissions the app requested. During the authorization process, the app will indicate which resources the app can access on your account. When you authorize a GitHub App, you also grant the app permission to act on your behalf.
For example, you might grant the GitHub App permission to read your email addresses and write gists.

You can install a GitHub App without authorizing the app. Similarly, you can authorize the app without installing the app.
For more information about authorizing GitHub Apps, see Authorizing GitHub Apps.
Installing a GitHub App in your personal account


To open GitHub Marketplace, in the top-left corner of GitHub, select , then click  Marketplace.



Browse to the app you'd like to install, then click on the app's name.


On the app's page, under "Pricing and setup," click the pricing plan you'd like to use.


Click Install it for free, Buy with GitHub, or Try free for 14 days.


Under "Review your order," in the Account dropdown menu, confirm that you're installing the app for your personal account.


If you chose a paid plan, in the "Payment Method" section, review your payment method.

To change the existing payment method on file for your personal account, click Edit, then complete the form to add a new payment method.
If there isn't a payment method on file for your personal account, complete the form to add a credit card or PayPal account.



Click Complete order and begin installation.


If the app requires access to repositories, select All repositories or Only select repositories.
If the app creates any repositories, the app will automatically be granted access to those repositories as well.


If you chose to give the app access to limited repositories instead of all of your repositories, type the name of each repository you'd like to give the app access to, then click on the repository name to select it.


Review the app's access permissions, then click Install.


Further reading

Managing your payment and billing information
Installing a GitHub App from GitHub Marketplace for your organizations\n\n\n\nApps/Using GitHub Apps/Install from Marketplace for orgInstalling a GitHub App from GitHub Marketplace for your organizationsYou can install GitHub Apps from GitHub Marketplace to use on your organizations.In this articleAbout GitHub MarketplaceAbout installing GitHub AppsRequirements to install a GitHub App on an organizationInstalling a GitHub App in your organizationFurther readingAbout GitHub Marketplace
This article applies to installing and purchasing GitHub Apps from GitHub Marketplace. For more information on installing GitHub Apps from a source other than GitHub Marketplace, see Installing a GitHub App from a third party.
If you install a GitHub App on your organization account and you choose a paid plan, you will pay for your app subscription on your organization's current billing date using your organization's existing payment method.
If you choose a paid plan with a free trial, you can cancel at any time during your trial period without being charged, but you will automatically lose access to the app. Your paid subscription will start at the end of the 14-day trial. For more information, see About billing for GitHub Marketplace.
For more information about installing an OAuth app instead of a GitHub App from GitHub Marketplace, see Installing an OAuth app in your organization.
About installing GitHub Apps
In order to use a GitHub App on your repositories or organization, you must install the app on your organization or personal account. You can install the same GitHub App on multiple accounts. For example, if you install the app on your personal account and on a few organizations that you own, you'll be able to use the app on your personal repositories, on the organizations where you installed the app, and on repositories owned by those organizations.
When you install an app, you grant the app permission to access the organization and repository resources that it requested. During the installation process, GitHub will tell you which permissions the GitHub App requested. For more information about the REST API requests the GitHub App can make with those permissions, see Permissions required for GitHub Apps.
When you install an app, you will also choose which repositories to grant the GitHub App access to.
Before installing a GitHub App, you should ensure you trust the owner of the GitHub App. You should also review the permissions that the GitHub App is requesting and make sure you are comfortable granting those permissions. For more information about the REST API requests the GitHub App can make with those permissions, see Permissions required for GitHub Apps.
There is no limit to how many apps you can install.
Difference between installation and authorization
After you install a GitHub App, you may also be asked to authorize the app.
When you install a GitHub App on your account or organization, you grant the app permission to access the organization and repository resources that it requested. You also specify which repositories the app can access. During the installation process, the GitHub App will indicate which repository and organization permissions you are granting. For more information about what different permissions enable a GitHub App to do, see Choosing permissions for a GitHub App.
For example, you might grant the GitHub App permission to read repository metadata and write issues, and you might grant the GitHub App access to all of your repositories.

When you authorize a GitHub App, you grant the app access to your GitHub account, based on the account permissions the app requested. During the authorization process, the app will indicate which resources the app can access on your account. When you authorize a GitHub App, you also grant the app permission to act on your behalf.
For example, you might grant the GitHub App permission to read your email addresses and write gists.

You can install a GitHub App without authorizing the app. Similarly, you can authorize the app without installing the app.
For more information about authorizing GitHub Apps, see Authorizing GitHub Apps.
Requirements to install a GitHub App on an organization
Organization owners can install GitHub Apps on their organization.
For enterprises that pay by credit card, enterprise owners who are also organization owners can install GitHub Apps on organizations within their enterprise.
Admins of repositories that are owned by an organization can also install GitHub Apps on the organization if they only grant the app access to repositories that they are an admin of and if the app does not request any organization permissions or the "repository administration" permission. Organization owners can prevent outside collaborators who are repository admins from installing GitHub Apps.
The "app manager" role in an organization does not give a person the ability to install a GitHub App in the organization. For more information, see About GitHub App managers.
Installing a GitHub App in your organization


To open GitHub Marketplace, in the top-left corner of GitHub, select , then click  Marketplace.



Browse to the app you'd like to install, then click on the app's name.


On the app's page, under "Pricing and setup," click the pricing plan you'd like to use.


Click Install it for free, Buy with GitHub, or Try free for 14 days.


Choose an installation organization for the app. Depending on your organization's terms of service, this process will be slightly different.

If you have given GitHub permission to collect name and address information for your organization, in the "Billing information" section, select the Switch billing account  dropdown menu, then click the organization in which you'd like to install the app.



Otherwise, under "Review your order," select the Account dropdown menu, then click the organization in which you'd like to install the app.




If you chose a paid plan, review your payment method.

To change the existing payment method on file for the organization, click Edit, then complete the form to add a new payment method.
If there isn't a payment method on file for the organization, click Add a Payment Method, then complete the form to add a credit card or PayPal account.



Click Complete order and begin installation.


If the app requires access to repositories, select All repositories or Only select repositories.
If the app creates any repositories, the app will automatically be granted access to those repositories as well.


If you chose to give the app access to limited repositories instead of all of your repositories, type the name of each repository you'd like to give the app access to, then click on the repository name to select it.


Review the app's access permissions, then click Install.


Further reading

Managing your payment and billing information
Installing a GitHub App from GitHub Marketplace for your personal account\n\n\n\nApps/Using GitHub Apps/Install from third partyInstalling a GitHub App from a third partyYou can install GitHub Apps directly from the app owner to use on your personal account or organizations.In this articleAbout installing GitHub AppsRequirements to install a GitHub AppInstalling a GitHub AppAbout installing GitHub Apps
This article describes how to install a GitHub App directly from the app owner instead of from GitHub Marketplace. For more information on installing GitHub Apps from GitHub Marketplace, see Installing a GitHub App from GitHub Marketplace for your personal account and Installing a GitHub App from GitHub Marketplace for your organizations. For more information about installing GitHub Apps that you own, see Installing your own GitHub App.
In order to use a GitHub App on your repositories or organization, you must install the app on your organization or personal account. You can install the same GitHub App on multiple accounts. For example, if you install the app on your personal account and on a few organizations that you own, you'll be able to use the app on your personal repositories, on the organizations where you installed the app, and on repositories owned by those organizations.
When you install an app, you grant the app permission to access the organization and repository resources that it requested. During the installation process, GitHub will tell you which permissions the GitHub App requested. For more information about the REST API requests the GitHub App can make with those permissions, see Permissions required for GitHub Apps.
When you install an app, you will also choose which repositories to grant the GitHub App access to.
Before installing a GitHub App, you should ensure you trust the owner of the GitHub App. You should also review the permissions that the GitHub App is requesting and make sure you are comfortable granting those permissions. For more information about the REST API requests the GitHub App can make with those permissions, see Permissions required for GitHub Apps.
There is no limit to how many apps you can install.
Difference between installation and authorization
After you install a GitHub App, you may also be asked to authorize the app.
When you install a GitHub App on your account or organization, you grant the app permission to access the organization and repository resources that it requested. You also specify which repositories the app can access. During the installation process, the GitHub App will indicate which repository and organization permissions you are granting. For more information about what different permissions enable a GitHub App to do, see Choosing permissions for a GitHub App.
For example, you might grant the GitHub App permission to read repository metadata and write issues, and you might grant the GitHub App access to all of your repositories.

When you authorize a GitHub App, you grant the app access to your GitHub account, based on the account permissions the app requested. During the authorization process, the app will indicate which resources the app can access on your account. When you authorize a GitHub App, you also grant the app permission to act on your behalf.
For example, you might grant the GitHub App permission to read your email addresses and write gists.

You can install a GitHub App without authorizing the app. Similarly, you can authorize the app without installing the app.
For more information about authorizing GitHub Apps, see Authorizing GitHub Apps.
Requirements to install a GitHub App
Anyone can install GitHub Apps on their personal account.
Organization owners can install GitHub Apps on their organization.
Admins of repositories that are owned by an organization can also install GitHub Apps on the organization if they only grant the app access to repositories that they are an admin of and if the app does not request any organization permissions or the "repository administration" permission. Organization owners can prevent outside collaborators who are repository admins from installing GitHub Apps.
Organization members who are not organization owners or repository admins can still select the organization during the install process. Instead of installing the app, GitHub will send a notification to the organization owner to request the organization owner to install the app.
The "app manager" role in an organization does not give a person the ability to install a GitHub App in the organization. See About GitHub App managers.
Installing a GitHub App
During the installation process, the app owner will direct you to a GitHub URL to install the GitHub App. The URL will look something like https://github.com/apps/APP-NAME/installations/new, where APP-NAME is the name of the GitHub App.


Select the location where you want to install the GitHub App. You can select your personal account or an organization that you are a member of.


If the app requires repository permissions, select All repositories or Only select repositories. The app will always have at least read-only access to all public repositories on GitHub.
If the app does not require repository permissions, these options will be omitted.


If you selected Only select repositories in the previous step, under the Select repositories dropdown, select the repositories that you want the app to access.
If the app creates any repositories, the app will automatically be granted access to those repositories as well.


Review the permissions that the app is requesting. For more information about the REST API requests the GitHub App can make with those permissions, see Permissions required for GitHub Apps.


Click Install, Install and request, or Request. The button that is presented depends on whether your organization owner must approve none, some, or all of the requested access for the app. For more information, see Requirements to install a GitHub App.\n\n\n\nApps/Using GitHub Apps/Install your own appInstalling your own GitHub AppYou can install a GitHub App that you created on the personal or organization account that owns the app. If your app is public, the GitHub App can also be installed on other accounts.In this articleAbout installing your own GitHub AppInstalling your own GitHub AppAbout installing your own GitHub App
After creating a GitHub App, you can install it based on its visibility.

Only on this account: The GitHub App can only be installed on the organization or user account that created it.
Any account: You can install this GitHub App on your user account or any organization account where you are an organization owner.

Installing your own GitHub App


In the upper-right corner of any page on GitHub, click your profile photo.


Navigate to your account settings.

For an app owned by a personal account, click Settings.
For an app owned by an organization:

Click Your organizations.
To the right of the organization, click Settings.





In the left sidebar, click  Developer settings.


In the left sidebar, click GitHub Apps.


Next to the GitHub App that you want to install, click Edit.


Click Install App.


Click Install next to the location where you want to install the GitHub App.


If the app requires repository permissions, select All repositories or Only select repositories. The app will always have at least read-only access to all public repositories on GitHub.
If the app does not require repository permissions, these options will be omitted.


If you selected Only select repositories in the previous step, under the Select repositories dropdown, select the repositories that you want the app to access.
If the app creates any repositories, the app will automatically be granted access to those repositories as well.


Click Install.\n\n\n\nApps/Using GitHub Apps/Request for orgRequesting a GitHub App from your organization ownerOrganization members can request installation of a GitHub App for their organization.Note

Currently, you can only request a GitHub App from your organization owner when installing the GitHub App directly from the GitHub App owner, not when installing a GitHub App from GitHub Marketplace.
If you find a GitHub App on GitHub Marketplace that you want your organization owner to install, you must make the request from the GitHub App's public installation page. The URL for a GitHub App public installation page is https://github.com/apps/APP-NAME/installations/new, where APP-NAME is the name of the GitHub App.

Organization members can send a request for their organization owner to install a GitHub App on the organization. To do so, follow the steps outlined in Installing a GitHub App from a third party. If you don't have permission to install the GitHub App on the organization, GitHub will send an email to the organization owner to notify them of the request. The organization owner can modify the repositories that you selected and choose whether to install the GitHub App.\n\n\n\nApps/Using GitHub Apps/AuthorizeAuthorizing GitHub AppsYou can authorize a GitHub App to retrieve information about your GitHub account and to make changes on your behalf.In this articleAbout authorizing GitHub AppsAbout GitHub Apps acting on your behalfDifference between authorization and installationAbout authorizing GitHub Apps
Applications that are not owned by you, your organization, or GitHub Marketplace may need to verify your GitHub identity or interact with GitHub on your behalf. These applications can request authorization for a GitHub App to perform these actions. If an application requests authorization, it will redirect you to a GitHub page prompting you to authorize the app.
When authorizing the GitHub App, you should ensure you trust the application owner and review the information that the application wants to access. During authorization, you'll be prompted to grant the GitHub App permission to do all of the following:

Verify your GitHub identity: When authorized, the GitHub App will be able to retrieve your public GitHub profile. The app may also be able to retrieve some private account information. During the authorization process, GitHub will tell you which account information the GitHub App will be able to access.
Know which resources you can access: When authorized, the GitHub App will be able to determine which resources you can access that the app can also access. The app may use this, for example, so that it can show you an appropriate list of repositories.
Act on your behalf: When authorized, the application may perform tasks on GitHub on your behalf. This might include creating an issue or commenting on a pull request. For more information, see About GitHub Apps acting on your behalf.

You can review and revoke your authorization at any time. For more information, see Reviewing and revoking authorization of GitHub Apps.
About GitHub Apps acting on your behalf
Once you authorize a GitHub App, the app can act on your behalf. The situations in which a GitHub App acts on your behalf vary according to the purpose of the GitHub App and the context in which it is being used. For example, an integrated development environment (IDE) may use a GitHub App to interact on your behalf in order to push changes you have authored through the IDE back to repositories on GitHub.
The GitHub App can only do things that both you and the app have permission to do. For example, if you have write access to a repository but the GitHub App only has read access, then the app can only read the contents of the repository even when it is acting on your behalf. Similarly, if you have access to repositories A and B, and the GitHub App has access to repositories B and C, then the app can only access repository B when acting on your behalf. For more information about the permissions granted to a GitHub App, see Difference between authorization and installation.
When an app acts on your behalf, it will attribute the activity to you in conjunction with the app. For example, if the app posts a comment on your behalf, the GitHub UI will show your avatar photo along with the app's identicon badge as the author of the issue.

Similarly, if the activity triggers a corresponding entry in the audit logs and security logs, the logs will list you as the actor but will state that the "programmatic_access_type" is "GitHub App user-to-server token".
Difference between authorization and installation
When you install a GitHub App on your account or organization, you grant the app permission to access the organization and repository resources that it requested. You also specify which repositories the app can access. During the installation process, the GitHub App will indicate which repository and organization permissions you are granting. For more information about what different permissions enable a GitHub App to do, see Choosing permissions for a GitHub App.
For example, you might grant the GitHub App permission to read repository metadata and write issues, and you might grant the GitHub App access to all of your repositories.

When you authorize a GitHub App, you grant the app access to your GitHub account, based on the account permissions the app requested. During the authorization process, the app will indicate which resources the app can access on your account. When you authorize a GitHub App, you also grant the app permission to act on your behalf.
For example, you might grant the GitHub App permission to read your email addresses and write gists.

You can install a GitHub App without authorizing the app. Similarly, you can authorize the app without installing the app.
For more information about installation, see Installing a GitHub App from a third party, Installing a GitHub App from GitHub Marketplace for your personal account and Installing a GitHub App from GitHub Marketplace for your organizations.\n\n\n\nApps/Using GitHub Apps/Approve new permissionsApproving updated permissions for a GitHub AppWhen a GitHub App requests additional permissions, you can review what behavior the permissions will enable and decide whether to approve the permissions.Occasionally, a GitHub App that you have installed will request additional permissions. This may happen if the GitHub App owner wants the app to make additional API requests or respond to additional webhook events. For more information about what different permissions enable a GitHub App to do, see Choosing permissions for a GitHub App.
When a GitHub App requests additional organization or repository permissions, GitHub will notify you if the app is installed on your personal account or on an organization that you own.
You can choose whether to accept the additional permissions. If you do not approve the additional permissions, the GitHub App will still retain its current permissions. The GitHub App may not function as expected if you do not approve the additional permissions.
If the app is authorized but not installed or if the GitHub App only requested additional account permissions, GitHub will not notify you. Instead, the GitHub App will prompt you to reauthorize the app in order to enable the new account permissions. For more information, see Authorizing GitHub Apps.\n\n\n\nApps/Using GitHub Apps/Review your authorizationsReviewing and revoking authorization of GitHub AppsYou can review the GitHub Apps that you have authorized, and you can revoke your authorization.In this articleAbout authorized GitHub AppsReviewing your authorized GitHub AppsFurther readingAbout authorized GitHub Apps
You may authorize a GitHub App to give the app permission to access information on your GitHub account and to act on your behalf. For more information, see Authorizing GitHub Apps.
You should periodically review the GitHub Apps that you have authorized. If you no longer use an app, consider revoking your authorization for that app.
The authorization can only be revoked by the person who authorized the GitHub App. Organization owners cannot revoke GitHub App authorizations for their organization members. However, organization owners can uninstall the GitHub App from their organization, which will prevent the app from accessing organization-owned resources. For more information, see Reviewing and modifying installed GitHub Apps.
Reviewing your authorized GitHub Apps


In the upper-right corner of any page on GitHub, click your profile photo, then click  Settings.


In the "Integrations" section of the sidebar, click  Applications.


Click the Authorized GitHub Apps tab.


Review the GitHub Apps that have access to your account. For those that you don't recognize or that have not been used recently, click Revoke. To revoke your authorization for all GitHub Apps, click Revoke all.



Further reading

Reviewing and modifying installed GitHub Apps
Reviewing your authorized OAuth apps
Privileged GitHub Apps\n\n\n\nApps/Using GitHub Apps/Review installationsReviewing and modifying installed GitHub AppsYou can review the permissions and change the repository access for GitHub Apps that you have installed. You can also temporarily or permanently prevent a GitHub App from accessing resources owned by your account or organization.In this articleAbout installed GitHub AppsNavigating to the GitHub App you want to review or modifyReviewing permissionsModifying repository accessBlocking accessFurther readingAbout installed GitHub Apps
GitHub users can install GitHub Apps on their personal account or organizations. When you install a GitHub App, you grant the app the organization-level and repository-level permissions that it requested. You also specify which repositories the GitHub App can access.
You should periodically review the GitHub Apps that you have installed. You can review the permissions that you granted and change the repositories that the GitHub App can access. If you no longer use an app, consider suspending or deleting the GitHub App to block its access to resources owned by the account where it is installed.
In addition to reviewing GitHub Apps that you have installed, you can review GitHub Apps that you have authorized to act on your behalf. For more information, see Reviewing and revoking authorization of GitHub Apps.
Navigating to the GitHub App you want to review or modify


For a GitHub App installed on an organization:

In the top right corner of GitHub, click your profile photo, then click Your organizations.
Next to your organization name, click Settings.
In the side bar, under "Third-party Access," click GitHub Apps. A list of the GitHub Apps installed on your organization will be displayed.
Next to the GitHub App you want to review or modify, click Configure.



For a GitHub App installed on your personal account:

In the upper-right corner of any page, click your profile photo, then click Settings.
Under "Integrations," click Applications.
Click Installed GitHub Apps. A list of the GitHub Apps installed on your personal account will be displayed.
Next to the GitHub App you want to review or modify, click Configure.



For a repository where a GitHub App was granted access:
Note

In the following steps, you will be taken to the account settings for the organization or personal account where the GitHub App is installed. The settings will affect all repositories where the app is installed under that account, not just the repository where you navigated from.



Navigate to the main page of the organization or repository.


Click  Settings.


Under "Integrations," click GitHub Apps. A list of the GitHub Apps that have been granted access to your repository will be displayed.


Next to the GitHub App you want to review or modify, click Configure.




Reviewing permissions

Navigate to the GitHub App you want to modify. For more information, see Navigating to the GitHub App you want to review or modify.
Under "Permissions," review the permissions that the GitHub App has. For more information about what different permissions enable a GitHub App to do, see Choosing permissions for a GitHub App.

Modifying repository access


Navigate to the GitHub App you want to modify. For more information, see Navigating to the GitHub App you want to review or modify.


Under "Repository access," select All repositories or Only select repositories.


If you selected Only select repositories in the previous step, under the Select repositories dropdown, select the repositories that you want the GitHub App to access.
If the GitHub App creates any repositories later, the app will automatically be granted access to those repositories as well.


Click Save.


Blocking access


Navigate to the GitHub App you want to modify. For more information, see Navigating to the GitHub App you want to review or modify.


To keep the GitHub App installed for future use but temporarily block it from accessing resources owned by your account, click Suspend.
When you suspend a GitHub App, your authorization of the app (if the app is installed on your personal account) or the authorization of the app by members of your organization (if the app is installed on an organization) will not be affected. For more information, see Authorizing GitHub Apps.
If the GitHub App was previously suspended, you can unsuspend the app by clicking Unsuspend. If the GitHub App was suspended by the GitHub App owner, then you cannot unsuspend the app.


To uninstall a GitHub App and block it from accessing resources owned by your account, click Uninstall.
When you uninstall a GitHub App from an account, the app will lose access to the resources in that account. The app might still be authorized to access organizations on your behalf, if it has installations in those organizations.
If you want to stop an app from acting on your behalf anywhere on GitHub, also de-authorize the app in the "Authorized GitHub Apps" tab of your user account. This will fully deactivate any tokens issued to the app on your behalf. For more information, see Authorizing GitHub Apps.


Further reading

Reviewing and revoking authorization of GitHub Apps
Privileged GitHub Apps\n\n\n\nApps/Using GitHub Apps/Privileged appsPrivileged GitHub AppsSome GitHub Apps are privileged apps, owned by GitHub, that are granted special capabilities.Some GitHub Apps are privileged apps. These apps are owned by GitHub and are granted special capabilities. For example, users can authorize these apps and use them to access data from an organization without requiring approval by the organization.
Some of these privileged apps are automatically included with GitHub and do not require user authorization. These apps will not appear in your list of authorized GitHub Apps or in your list of installed GitHub Apps.
These privileged apps will appear in the user security log, but will not appear in organization audit logs. For more information, see Reviewing your security log and Reviewing the audit log for your organization.
These GitHub Apps are:

Actions
Dependabot
Git Src Migrator
GitHub Advanced Security
GitHub Classroom
GitHub Codespaces
GitHub Copilot Plugin
GitHub Merge Queue
GitHub Pages
GitHub Project Automation
GitHub Team Synchronization
Microsoft Teams for GitHub
OpenGraph (custom-og-image)
Slack\n\n\n\nApps/Creating GitHub Apps/About creating GitHub Apps/About creating appsAbout creating GitHub AppsGitHub Apps let you build integrations to automate processes and extend GitHub's functionality.In this articleAbout GitHub AppsBuilding a GitHub AppUnderstanding what type of GitHub App to buildAbout GitHub Apps
A GitHub App is a type of integration that you can build to interact with and extend the functionality of GitHub. You can build a GitHub App to provide flexibility and reduce friction in your processes, without needing to sign in a user or create a service account.
Common use cases for GitHub Apps include:

Automating tasks or background processes
Supporting "Sign in with GitHub," which allows users to sign in with their GitHub account to provide their identity in your ecosystem
As a developer tool, allowing users to work with GitHub by signing into your GitHub App, which can then act on their behalf
Integrating your tool or external service with GitHub

Like OAuth apps, GitHub Apps use OAuth 2.0 and can act on behalf of a user. Unlike OAuth apps, GitHub Apps can also act independently of a user.
GitHub Apps can be installed directly on organizations and personal accounts and granted access to specific repositories. They come with built-in webhooks and narrow, specific permissions.
By default, only organization owners can manage the settings of GitHub Apps in an organization. To allow additional users to change the developer settings of GitHub Apps owned by the organization, an owner can grant them GitHub App manager permissions. GitHub App Managers can't manage third-party applications. For more information about adding and removing GitHub App managers in your organization, see Roles in an organization.
Building a GitHub App
In order to build a GitHub App, you first need to register a GitHub App. For more information, see Registering a GitHub App.
Then, you need to write code to add functionality to your GitHub App. You can use the credentials from your GitHub App registration to make authenticated requests to GitHub's APIs. For more information about writing code for your GitHub App, see About writing code for a GitHub App. For more information about making authenticated requests, see About authentication with a GitHub App.
Once you have written the code for your GitHub App, your app needs to run somewhere. If your app is a website or web app, you might host your app on a server like Azure App Service. If your app is a client-side app, it might run on a user's device.
To use your GitHub App, you need to install it on your organization or personal account.

If your GitHub App is private, you can only install it on the account that owns the app.
If your GitHub App is public, other users and organizations can also install it.

For more information, see Installing your own GitHub App and Sharing your GitHub App.
Understanding what type of GitHub App to build
There are multiple ways to design a GitHub App that you will want to consider, based on the functionality you want the app to have.
GitHub Apps that act on behalf of a user
If you want your app to take actions on behalf of a user, you should use a user access token for authentication. This type of request is sometimes called "user-to-server," and it means that the app will be limited by the permissions that have been given to the app as well as the user's permission. With this pattern, the user must authorize the app before the app can take action. For more information, see Authenticating with a GitHub App on behalf of a user.
Some examples of automations you could create with a GitHub App, where the app acts on a user's behalf, include:

A GitHub App that uses GitHub as an identity provider for your ecosystem.
A GitHub App that adds a service on top of GitHub that might be useful to a GitHub user. You can share the app with other developers via GitHub Marketplace or by making the app public.

GitHub Apps that act on their own behalf
If you want your app to take actions on behalf of itself, rather than a user, you should use an installation access token for authentication. This type of request is sometimes called "server-to-server," and it means that the app will be limited by the permissions that have been given to the app. For more information, see Authenticating as a GitHub App installation.
Some examples of automations you could create with a GitHub App, where the app acts on its own behalf, include:

A GitHub App that uses webhooks to react to an event given a certain set of criteria. For example, you could create an automation around the REST API endpoints for reviewing requests for fine-grained personal access token that approves a request given a certain policy.
A GitHub App that helps repository contributors. For example, the app could post helpful resources after a contributor creates a pull request or makes a comment.
A GitHub App that generates short-lived tokens to give to other CI/CD tools, or to pull information from a repository.

GitHub Apps that respond to webhooks
If you want your app to respond to events on GitHub, your app should subscribe to webhooks. For example, you may want your app to leave a comment when a pull request is opened. For more information, see Using webhooks with GitHub Apps.
GitHub Apps that can take certain actions
When you set up your GitHub App, you can select specific permissions for the app. These permissions determine what the app can do via the GitHub API, what they can do on behalf of a signed in user, and what webhooks the app can receive. For more information, see Choosing permissions for a GitHub App.\n\n\n\nApps/Creating GitHub Apps/About creating GitHub Apps/GitHub App versus other optionsDeciding when to build a GitHub AppWhen building an integration, you should consider using a GitHub App in the following scenarios, instead of an OAuth app, personal access token, or GitHub Actions.In this articleUsing a GitHub App instead of an OAuth appChoosing between a GitHub App or a personal access tokenChoosing between a GitHub App or GitHub ActionsUsing a GitHub App instead of an OAuth app
In general, GitHub Apps are preferred over OAuth apps.
Both OAuth apps and GitHub Apps use OAuth 2.0.
OAuth apps can only act on behalf of a user while GitHub Apps can either act on behalf of a user or independently of a user.
For more information, see Differences between GitHub Apps and OAuth apps.
For information on how to migrate an existing OAuth app to a GitHub App, see Migrating OAuth apps to GitHub Apps.
GitHub Apps offer enhanced security
GitHub Apps provide more control over what the app can do. Instead of the broad scopes that OAuth apps use, GitHub Apps use fine-grained permissions. For example, if your app needs to read the contents of a repository, an OAuth app would require the repo scope, which would also let the app edit the repository contents and settings. A GitHub App can request read-only access to repository contents, which will not let the app take more privileged actions like editing the repository contents or settings.
GitHub Apps also offer more control over repository access. With a GitHub App, the user or organization owner who installed the app can decide what repositories the app can access. Conversely, an OAuth app can access every repository that the user who authorized the app can access.
GitHub Apps use short lived tokens. If the token is leaked, the token will be valid for a shorter amount of time, which reduces the damage that can be done. Conversely, OAuth app tokens do not expire until the person who authorized the OAuth app revokes the token.
These security features help harden your GitHub App's security by limiting the damage that could be done if your app's credentials were leaked. Additionally, this lets organizations with stricter security policies use your app.
GitHub Apps can act independently of or on behalf of a user
GitHub Apps can act independently of a user. This is beneficial for automations that do not require user input.
Similar to OAuth apps, GitHub Apps can still take actions on behalf of a user. Unlike OAuth apps, which don't indicate that the action was performed by the app, GitHub Apps indicate that the action was performed by the app on behalf of the user.
GitHub Apps are not tied to a user account and do not consume a seat. GitHub Apps remain installed even when the person who initially installed the app leaves the organization. This lets your integrations continue to work even if people leave your team.
GitHub Apps have scalable rate limits
The rate limit for GitHub Apps using an installation access token scales with the number of repositories and number of organization users. Conversely, OAuth apps have lower rate limits and do not scale. For more information, see Rate limits for GitHub Apps.
GitHub Apps have built in webhooks
GitHub Apps have built-in, centralized webhooks. GitHub Apps can receive webhook events for all repositories and organizations the app can access. Conversely, OAuth apps must configure webhooks individually for each repository and organization.
API access differs slightly
In general, GitHub Apps and OAuth apps can make the same API requests. However, there are some differences:

The REST API to manage check runs and check suites is only available to GitHub Apps.
Enterprise-level resources such as the enterprise object itself are not available to GitHub Apps. This means that GitHub Apps cannot call endpoints like GET /enterprise/settings/license. However, enterprise-owned organization and repository resources are available.
Some requests may return incomplete data depending on the permissions and repository access that was granted to an GitHub App. For example, if your app makes a request to get all repositories that a user can access, the response will only include the repositories that the app was also granted access to.

For more information about the REST API endpoints that are available to GitHub Apps, see Endpoints available for GitHub App installation access tokens.
Choosing between a GitHub App or a personal access token
If you want to access GitHub resources on behalf of a user or in an organization, or you anticipate a long-lived integration, we recommend building a GitHub App.
You can use personal access tokens for API testing or short-lived scripts. Since a personal access token is associated with a user, your automation could break if the user no longer has access to the resources you need. A GitHub App installed in an organization is not dependent on a user. Additionally, unlike a user, a GitHub App does not consume a GitHub seat.
GitHub supports two types of personal access tokens, but recommends that you use fine-grained personal access tokens instead of personal access tokens (classic) whenever possible. For more information about personal access tokens, see Managing your personal access tokens.
Choosing between a GitHub App or GitHub Actions
GitHub Apps and GitHub Actions both provide ways to build automation and workflow tools.
GitHub Actions provide automation that can perform jobs like continuous integration, deployment tasks, and project management in a repository. They run directly on GitHub-hosted runner machines or self-hosted runners that your administrator sets up. GitHub Actions do not run persistently. GitHub Actions workflows run in response to events that occur in their repository, and only have access to the resources of the repository that they are set up for. However, custom actions can be shared across repositories and organizations, allowing developers to reuse and modify existing actions to meet their needs. GitHub Actions also come with built-in secret management, which you can use to securely interact with third-party services and manage deploy keys safely.
GitHub Apps run persistently on a server or compute infrastructure that you provide or run on a user device. They can react to GitHub webhook events as well as events from outside the GitHub ecosystem. They are a good option for operations that span multiple repositories or organizations, or for providing hosted services to other organizations. A GitHub App is the best choice when building a tool with functions that occur primarily outside of GitHub or require more execution time or permissions than what a GitHub Actions workflow is allotted.
For more information about comparing GitHub Actions to GitHub Apps, see About custom actions.
You can use a GitHub App to authenticate in a GitHub Actions
workflow if the built in GITHUB_TOKEN does not have sufficient permissions. For more information, see Making authenticated API requests with a GitHub App in a GitHub Actions workflow.\n\n\n\nApps/Creating GitHub Apps/About creating GitHub Apps/Best practicesBest practices for creating a GitHub AppFollow these best practices to improve the security and performance of your GitHub App.In this articleSelect the minimum permissions requiredStay under the rate limitSecure your app's credentialsUse the appropriate token typeCheck authorization thoroughly, durably, and oftenExpire tokensCache tokensMake a plan for handling security breachesConduct regular vulnerability scansChoose an appropriate environmentSubscribe to the minimum webhooksUse a webhook secretAllow time for users to accept new permissionsUse services in a secure mannerAdd logging and monitoringEnable data deletionFurther readingSelect the minimum permissions required
When you register a GitHub App, select the minimum permissions that your GitHub App needs. If any keys or tokens for your app become compromised, this will limit the amount of damage that can occur. For more information about how to choose permissions, see Choosing permissions for a GitHub App.
When your GitHub App creates an installation access token or user access token, you can further limit the repositories that the app can access and the permissions that the token has. For more information, see Generating an installation access token for a GitHub App and Generating a user access token for a GitHub App.
Stay under the rate limit
Subscribe to webhook events instead of polling the API for data. This will help your GitHub App stay within the API rate limit. For more information, see Using webhooks with GitHub Apps and Building a GitHub App that responds to webhook events.
Consider using conditional requests to help you stay within the rate limit. For more information about conditional requests, see Best practices for using the REST API.
If possible, consider using consolidated GraphQL queries instead of REST API requests to help you stay within rate limits. For more information, see Comparing GitHub's REST API and GraphQL API and GitHub GraphQL API documentation.
If you do hit a rate limit and need to retry an API request, use the x-ratelimit-reset or Retry-After response headers. If these headers are not available, wait for an exponentially increasing amount of time between retries, and throw an error after a specific number of retries. For more information, see Best practices for using the REST API.
Secure your app's credentials
You can generate a private key and client secret for your GitHub App. With these credentials, your app can generate installation access tokens, user access tokens, and refresh tokens. These tokens can be used to make API requests on behalf of an app installation or user.
You must store these credentials securely. The storage mechanism depends on your integrations architecture and the platform that it runs on. In general, you should use a storage mechanism that is intended to store sensitive data on the platform that you are using.
Private keys
The private key for your GitHub App grants access to every account that the app is installed on.
Consider storing your GitHub App's private key in a key vault, such as Azure Key Vault, and making it sign-only.
Alternatively, you can store the key as an environment variable. However, this not as strong as storing the key in a key vault. If an attacker gains access to the environment, they can read the private key and gain persistent authentication as the GitHub App.
You should never hard code your private key in your app, even if your code is stored in a private repository. If your app is a native client, client-side app, or runs on a user device (as opposed to running on your servers), you should never ship your private key with your app.
You should not generate more private keys than you need. You should delete private keys that you no longer need. For more information, see Managing private keys for GitHub Apps.
Client secrets
Client secrets are used to generate user access tokens for your app, unless your app uses device flow. For more information, see Generating a user access token for a GitHub App.
If your app is a website or web app, consider storing your client secret in a key vault, such as Azure Key Vault, or as an encrypted environment variable or secret on your server.
If your app is a native client, client-side app, or runs on a user device (as opposed to running on your servers), you cannot secure your client secret. You should use caution if you plan to gate access to your own services based on tokens generated by your app because anyone can access the client secret to generate a token.
Installation access tokens, user access tokens, and refresh tokens
Installation access tokens are used to make API requests on behalf of an app installation. User access tokens are used to make API requests on behalf of a user. Refresh tokens are used to regenerate user access tokens. Your app can use its private key to generate an installation access token. Your app can use its client secret to generate a user access token and refresh token.
If your app is a website or web app, you should encrypt the tokens on your back end and ensure there is security around the systems that can access the tokens. Consider storing refresh tokens in a separate place from active access tokens.
If your app is a native client, client-side app, or runs on a user device (as opposed to running on your servers), you may not be able to secure tokens as well as an app that runs on your servers. You should not generate installation access tokens since doing so requires a private key. Instead, you should generate user access tokens. You should store tokens via the mechanism recommended for your app's platform, and keep in mind that the storage mechanism may not be fully secure.
Use the appropriate token type
GitHub Apps can generate installation access tokens or user access tokens in order to make authenticated API requests.
Installation access tokens will attribute activity to your app. These are useful for automations that act independently of users.
User access tokens will attribute activity to a user and to your app. These are useful for taking actions based on user input or on behalf of a user.
An installation access token is restricted based on the GitHub App's permissions and access. A user access token is restricted based on both the GitHub App's permission and access and the user's permission and access. Therefore, if your GitHub App takes an action on behalf of a user, it should always use a user access token instead of an installation access token. Otherwise, your app might allow a user to see or do things that they shouldn't be able to see or do.
Your app should never use a personal access token or GitHub password to authenticate.
Check authorization thoroughly, durably, and often
After signing in a user, app developers must take additional steps to ensure that the user is meant to have access to the data in your system. You must routinely check that their memberships, access, and their current SSO status all allow access to your application and the resources it protects.
Use the durable, unique id to store the user
When a user signs in and performs actions in your application, you have to remember which user took that action in order to grant them access to the same resources the next time they sign in.
To store users in your database correctly, always use the id of the user. This value will never change for the user or be used to point to a different user, so it ensures you are providing access to the user you intend. You can find a user's id with the GET /user REST API endpoint. See REST API endpoints for users.
If you store references to repositories, organizations, and enterprises, use their id as well to ensure your links to them remain accurate.
Never use identifiers that can change over time, including user handles, organization slugs, or email addresses.
Validate organization access for every new authentication
When you sign in a user, you should track which organizations the user's token is authorized for. This can change over time after sign in as users are removed from organizations. If an organization uses SAML SSO and a user has not performed SAML SSO, the user access token will not have access to that organization. You should use the GET /user/installations REST API endpoint regularly to verify which organizations a user access token has access to. If the user is not authorized to access an organization, you should prevent their access to organization owned data within your own application until they perform SAML SSO or rejoin the organization. For more information, see REST API endpoints for GitHub App installations.
Store user data with organizational and enterprise contexts
Beyond tracking user identity via the id field, you should retain data for the organization or enterprise each user is operating under. This will help ensure you don't leak sensitive information if a user switches roles.
For example:

A user is in the Mona organization, which requires SAML SSO, and signs into your app after performing SSO. Your app now has access to whatever the user does within Mona.
The user pulls a bunch of code out of a repository in Mona and saves it in your app for analysis.
Later, the user switches jobs, and is removed from the Mona organization.

When the user accesses your app, can they still see the code and analysis from the Mona organization in their user account?
This is why it's critical to track the source of the data that your app is saving. Otherwise, your app is a data protection threat for organizations, and they're likely to ban your app if they can't trust that your app correctly protects their data.
Expire tokens
GitHub strongly encourages you to use user access tokens that expire. If you previously opted out of using user access tokens that expire but want to re-enable this feature, see Activating optional features for GitHub Apps.
Installation access tokens expire after one hour, expiring user access tokens expire after eight hours, and refresh tokens expire after six months. However, you can also revoke tokens as soon as you no longer need them. For more information, see DELETE /installation/token to revoke an installation access token and DELETE /applications/{client_id}/token to revoke a user access token.
Cache tokens
User access tokens and installation access tokens are meant to be used until they expire. You should cache tokens that you create. Before you create a new token, check your cache to see if you already have a valid token. Reusing tokens will make your app faster since it will make fewer requests to generate tokens.
Make a plan for handling security breaches
You should have a plan in place so that you can handle any security breaches in a timely manner.
In the event that your app's private key or secret is compromised, you will need to generate a new key or secret, update your app to use the new key or secret, and delete your old key or secret.
In the event that installation access tokens, user access tokens, or refresh tokens are compromised, you should immediately revoke these tokens. For more information, see DELETE /installation/token to revoke an installation access token and DELETE /applications/{client_id}/token to revoke a user access token.
Conduct regular vulnerability scans
You should conduct regular vulnerability scans for your app. For example, you might set up code scanning and secret scanning for the repository that hosts your app's code. For more information, see About code scanning and About secret scanning.
Choose an appropriate environment
If your app runs on a server, verify that your server environment is secure and that it can handle the volume of traffic that you expect for your app.
Subscribe to the minimum webhooks
Only subscribe to the webhook events that your app needs. This will help reduce latency since your app won't be receiving payloads that it doesn't need.
Use a webhook secret
You should set a webhook secret for your GitHub App and verify that the signature of incoming webhook events match the secret. This helps to ensure that the incoming webhook event is a valid GitHub event.
For more information, see Using webhooks with GitHub Apps. For an example, see Building a GitHub App that responds to webhook events.
Allow time for users to accept new permissions
When you add repository or organization permissions to your GitHub App, users who have the app installed on their personal account or organization will receive an email prompting them to review the new permissions. Until the user approves the new permissions, their app installation will only receive the old permissions.
When you update permissions, you should consider making your app backwards compatible to give your users time to accept the new permissions. You can use the installation webhook with the new_permissions_accepted action property to learn when users accept new permissions for your app.
Use services in a secure manner
If your app uses third-party services, they should be used in a secure manner:

Any services used by your app should have a unique login and password.
Apps should not share service accounts such as email or database services to manage your SaaS service.
Only employees with administrative duties should have admin access to the infrastructure that hosts your app.

Add logging and monitoring
Consider adding logging and monitoring capabilities for your app. A security log could include:

Authentication and authorization events
Service configuration changes
Object reads and writes
User and group permission changes
Elevation of role to admin

Your logs should use consistent timestamping for each event and should record the users, IP addresses, or hostnames for all logged events.
Enable data deletion
If your GitHub App is available to other users or organizations, you should give users and organization owners a way to delete their data. Users should not need to email or call a support person in order to delete their data.
Further reading


Security best practices for apps on GitHub Marketplace


Customer experience best practices for apps


Best practices for using webhooks


Best practices for using the REST API\n\n\n\nApps/Creating GitHub Apps/About creating GitHub Apps/Migrate from OAuth appsMigrating OAuth apps to GitHub AppsLearn about the advantages of migrating your OAuth app to a GitHub App, and learn how to migrate your OAuth app.In this articleBenefits of migrating from OAuth apps to GitHub AppsConverting an OAuth app to a GitHub AppBenefits of migrating from OAuth apps to GitHub Apps
GitHub Apps are the recommended way to integrate with GitHub. GitHub Apps offer many advantages over OAuth apps, including:

Enhanced security features, like fine-grained permissions, choice over repository access, and short lived tokens
The ability to act independently of or on behalf of a user
Scalable rate limits
Built-in webhooks

For more information, see About creating GitHub Apps.
Converting an OAuth app to a GitHub App
The following steps provide an overview of how to migrate from an OAuth app to a GitHub App. The specific steps depend on your app.
1. Review your OAuth app
Re-familiarize yourself with the code for your OAuth app. The API requests that your OAuth app makes will help you decide what permissions to select for your GitHub App.
Additionally, there are a few REST API endpoints that are not available for OAuth apps. Verify that any REST endpoints that you use are available for GitHub Apps by reviewing Endpoints available for GitHub App installation access tokens.
2. Register a GitHub App
Register a new GitHub App. For more information, see Registering a GitHub App.
Compared to an OAuth app, you have more control over GitHub App settings. Some key additions are:


Unlike an OAuth app, which always acts on behalf of a user, you can make your GitHub App take actions as itself or on behalf of a user. If you do not want your new GitHub App to take actions on behalf of a user, you can skip the "Identifying and authorizing users" settings. For more information, see About authentication with a GitHub App.


You can use webhooks to notify your GitHub App when specific events occur. Unlike webhooks for OAuth apps, which you must configure via the API for each repository or organization, webhooks are built into GitHub Apps. When you register your GitHub App, you can select the webhook events that you want to receive. Additionally, if your OAuth app currently uses polling to determine if an event had occurred, consider subscribing to webhooks instead to help your GitHub App stay within the rate limit. For more information, see Using webhooks with GitHub Apps.


With an OAuth app, you request scopes when a user authorizes your app. With a GitHub App, you specify permissions in the app settings. These permissions are more granular than scopes and enable you to only select the permissions that your app needs. Additionally, these permissions are mapped to REST API endpoints and webhook events, so you can easily determine what permissions your GitHub App needs in order to access a specific REST API endpoint or subscribe to a specific webhook. Permissions are not currently documented for GraphQL requests. For more information, see Choosing permissions for a GitHub App.


3. Modify the code for your app
Once you have registered a GitHub App, adapt the code from your old OAuth app to work with your new GitHub App.
Update authentication
You will need to update your app's code to handle API authentication for your GitHub App. A GitHub App can authenticate in three ways:

As the app itself, in order to get or modify details about the GitHub App registration or to create an installation access token. For more information, see Authenticating as a GitHub App.
As an app installation, in order to take actions on behalf of itself. For more information, see Authenticating as a GitHub App installation.
On behalf of a user, in order to attribute actions to a user. For more information, see Authenticating with a GitHub App on behalf of a user.

If you are using GitHub's official Octokit.js library, you can use the built-in App object to authenticate. For examples, see Scripting with the REST API and JavaScript and Building a GitHub App that responds to webhook events.
Review rate limits
Review the differences in rate limits between OAuth apps and GitHub Apps. GitHub Apps use sliding rules for rate limits, which can increase based on the number of repositories and number of users in the organization. For more information, see Rate limits for GitHub Apps.
If possible, consider using conditional requests and subscribing to webhooks instead of polling to help you stay within rate limits. For more information about conditional requests, see Best practices for using the REST API. For more information about using webhooks with your GitHub App, see Using webhooks with GitHub Apps and Building a GitHub App that responds to webhook events.
Test your code
Test your new GitHub App to make sure that your code works as expected.
4. Publicize your new GitHub App
If you want other accounts to be able to use your new GitHub App, make sure that your app is public. If you want to make your GitHub App more discoverable, list your app in GitHub Marketplace. For more information, see About GitHub Marketplace for apps and Making a GitHub App public or private.
5. Instruct your users to migrate
Once your new GitHub App is ready, instruct users of your old OAuth app to migrate to your new GitHub App. There is not a way to automatically migrate your users. Each user must install and/or authorize your GitHub App on their own.
As the app owner, you should include calls to action to encourage your users to install/authorize the new GitHub App and revoke authorization for the old OAuth app. You should also update any documentation or user interface elements.
Prompt users to install your GitHub App
If you want your GitHub App to make API requests on behalf of itself or access organization or repository resources, the user must install your GitHub App. When a user installs a GitHub App on their account or organization, they choose which repositories the app can access, and they grant the app the organization and repository permissions that it requested.
To help your users install your GitHub App, you can add a link to your app's webpage that users can click to install the GitHub App. The format of the install URL is https://github.com/apps/YOUR_APP_NAME/installations/new. Replace YOUR_APP_NAME with the sluggified name of your GitHub App, which you can find in the "Public link" field on the settings page for your GitHub App.
To pre-select any repositories your OAuth app had access to, you can append /permissions and query parameters to the install URL. This helps users grant your GitHub App access to repositories that your OAuth app already has access to. The query parameters are:

suggested_target_id: The ID of the user or organization that is installing your GitHub App. This parameter is required.
repository_ids[]: The repository IDs to select for the installation. If omitted, all repositories are selected. The maximum number of repositories that can be pre-selected is 100. To get a list of repositories that your OAuth app has access to, use the List repositories for the authenticated user and List organization repositories endpoints.

For example: https://github.com/apps/YOUR_APP_NAME/installations/new/permissions?suggested_target_id=ID_OF_USER_OR_ORG&repository_ids[]=REPO_A_ID&repository_ids[]=REPO_B_ID.
For more information about installing GitHub Apps, see Installing a GitHub App from GitHub Marketplace for your personal account, Installing a GitHub App from GitHub Marketplace for your organizations, Installing a GitHub App from a third party and Installing your own GitHub App.
Prompt users to authorize your app
If you want your GitHub App to make API requests on behalf of a user, the user must authorize the app. When a user authorizes an app, they grant the app permission to act on their behalf, and they grant the account permissions that the app requested. If the app is installed on an organization account, each user within that organization must authorize the app in order for the app to act on their behalf.
To prompt users to authorize your app, you will lead them through the web application flow or device flow. For more information, see Generating a user access token for a GitHub App.
For more information about authorizing GitHub Apps, see Authorizing GitHub Apps.
Encourage your users to revoke OAuth app access
You should also encourage your users to revoke access for your old OAuth app. This will help you fully transition away from your OAuth app and will help keep your users' data secure. For more information, see Reviewing your authorized OAuth apps.
Update any interfaces or documentation
You should update any user interface or documentation related to your app to reflect the change from an OAuth app to GitHub App.
6. Remove webhooks for your old OAuth app
When a user installs your GitHub App and grants access to a repository, you should remove any webhooks for your old OAuth app. If your new GitHub App and your old OAuth app respond to webhooks for the same event, the user may observe duplicate behavior.
To remove repository webhooks, you can listen for the installation_repositories webhook with the added action. When your GitHub App receives that event, you can use the REST API to delete the webhook on those repositories for your OAuth app. For more information, see Webhook events and payloads and REST API endpoints for repository webhooks.
Similarly, to remove organization webhooks, you can listen for the installation webhook with the created action. When your GitHub App receives that event for an organization, you can use the REST API to delete the webhook on that organization and corresponding repositories for your OAuth app. For more information, see Webhook events and payloads, REST API endpoints for organization webhooks, and REST API endpoints for repository webhooks.
7. Delete your old OAuth app
Once your users have migrated to your new GitHub App, you should delete your old OAuth app. This will help avoid abuse of the OAuth app's credentials. This action will also revoke all of the OAuth app's remaining authorizations. For more information, see Deleting an OAuth app. If your OAuth app is listed on GitHub Marketplace, you may need to contact GitHub Support to remove your app from the marketplace first.\n\n\n\nApps/Creating GitHub Apps/Registering a GitHub App/Register a GitHub AppRegistering a GitHub AppYou can register a GitHub App under your personal account or under any organization you own.In this articleAbout registering GitHub AppsRegistering a GitHub AppNext stepsAbout registering GitHub Apps
You can register a GitHub App in a few different ways.

Under your personal account.
Under an organization you own.
Under an organization that has granted you permission to manage all its apps. See Adding and removing GitHub App managers in your organization.

A user or organization can register up to 100 GitHub Apps, but there is no limit to how many GitHub Apps can be installed on an account.
Registering a GitHub App


In the upper-right corner of any page on GitHub, click your profile photo.


Navigate to your account settings.

For an app owned by a personal account, click Settings.
For an app owned by an organization:

Click Your organizations.
To the right of the organization, click Settings.





In the left sidebar, click  Developer settings.


In the left sidebar, click GitHub Apps.


Click New GitHub App.


Under "GitHub App name", enter a name for your app. You should choose a clear and short name. The name cannot be longer than 34 characters. Your app's name (converted to lowercase, with spaces replaced by -, and with special characters replaced) will be shown in the user interface when your app takes an action. For example, My APp Näme would display as my-app-name.
The name must be unique across GitHub. You cannot use the same name as an existing GitHub account, unless it is your own user or organization name.


Optionally, under "Description", type a description of your app. Users and organizations will see this description when they install your app.


Under "Homepage URL", type the full URL to your app's website. If you don’t have a dedicated URL and your app's code is stored in a public repository, you can use that repository URL. Or, you can use the URL of the organization or user that owns the app.


Optionally, under "Callback URL", enter the full URL to redirect to after a user authorizes the installation.
You can enter up to 10 callback URLs. To add additional callback URLs, click Add callback URL.
If your app does not need to act on behalf of a user (does not need to generate a user access token), this field will be ignored. If your app uses device flow instead of web application flow to generate a user access token, this field will be ignored.
For more information about the callback URL, see About the user authorization callback URL. For more information about generating a user access token to act on behalf of a user, see Authenticating with a GitHub App on behalf of a user and Generating a user access token for a GitHub App.


Optionally, to prevent user access tokens from expiring, deselect Expire user authorization tokens. GitHub strongly recommends that you leave this option selected. For more information about refreshing expired tokens and the benefits of user access tokens that expire, see Refreshing user access tokens. If your app does not need to generate a user access token, this field will be ignored.


Optionally, to prompt users to authorize your app when they install it, select Request user authorization (OAuth) during installation. If a user authorizes your app, your app can generate a user access token to make API requests on the user's behalf and attribute app activity to the user. For more information, see Authenticating with a GitHub App on behalf of a user and Generating a user access token for a GitHub App.


Optionally, if you want to use device flow to generate a user access token, select Enable Device Flow. For more information, see Generating a user access token for a GitHub App.


Optionally, under "Setup URL", enter the URL to redirect users to after they install your app. If additional setup is required after installation, you can use this URL to tell users what steps to take after installation. For more information, see About the setup URL.
If you selected Request user authorization (OAuth) during installation in an earlier step, you will not be able to enter a URL here. Users will instead be redirected to the Callback URL as part of the authorization flow, where you can describe additional setup.


Optionally, if you want to redirect users to the setup URL after they update an installation, select Redirect on update. An update includes adding or removing a repository for an installation. If "Setup URL" is blank, this will be ignored.


Optionally, if you do not want your app to receive webhook events, deselect Active. For example, if your app will only be used for authentication or does not need to respond to webhooks, deselect this option. For more information, see Using webhooks with GitHub Apps.


If you selected Active in the previous step, under "Webhook URL", enter the URL that GitHub should send webhook events to. For more information, see Using webhooks with GitHub Apps.


Optionally, if you selected Active in the previous step, under "Webhook secret", enter a secret token to secure your webhooks. GitHub highly recommends that you set a webhook secret. For more information, see Using webhooks with GitHub Apps.


If you entered a webhook URL, under "SSL verification", select whether to enable SSL verification. GitHub highly recommends that you enable SSL verification.


Under "Permissions", choose the permissions that your app needs. For each permission, select the dropdown menu and click Read-only, Read & write, or No access. You should select the minimum permissions necessary for your app. For more information, see Choosing permissions for a GitHub App.


If you selected Active in the earlier step to indicate that your app should receive webhook events, under "Subscribe to events", select the webhook events that you want your app to receive. The permissions that you selected in the previous step determine what webhook events are available. For more information about each webhook event, see Webhook events and payloads.


Under "Where can this GitHub App be installed?", select Only on this account or Any account. For more information on installation options, see Making a GitHub App public or private.


Click Create GitHub App.


Next steps
After registering a GitHub App, you will want to write code to make your GitHub App do something. For examples of how to write code, see:

Quickstart for building GitHub Apps
Building a GitHub App that responds to webhook events
Building a "Login with GitHub" button with a GitHub App
Building a CLI with a GitHub App
Making authenticated API requests with a GitHub App in a GitHub Actions workflow

You should aim to follow best practices. For more information, see Best practices for creating a GitHub App.
Once your GitHub App is fully built, you can install your GitHub App and share your GitHub App with others. For more information, see Installing your own GitHub App and Sharing your GitHub App.
You can always make changes to the settings for your GitHub App. For more information, see Modifying a GitHub App registration.\n\n\n\nApps/Creating GitHub Apps/Registering a GitHub App/Callback URLAbout the user authorization callback URLYou can specify a URL that users will be redirected to after they authorize a GitHub App.When you register a GitHub App, you can specify a callback URL. When you use the web application flow to generate a user access token in order to act on behalf of a user, users will be redirected to the callback URL after they authorize the GitHub App.
You can specify up to 10 callback URLs. If you specify multiple callback URLs, you can use the redirect_uri parameter when you prompt the user to authorize your GitHub App, to indicate which callback URL the user should be redirected to. If you do not specify redirect_uri, the first callback URL will be used. For more information about using the redirect_uri parameter, see Generating a user access token for a GitHub App.
The callback URL is different from the setup URL. Users are redirected to the setup URL after they install a GitHub App. Users are redirected to the callback URL when they authorize a GitHub App via the web application flow. For more information, see About the setup URL.
For more information about generating user access tokens, see Generating a user access token for a GitHub App. For more information about registering a GitHub App, see Registering a GitHub App. For more information about modifying a GitHub App registration, see Modifying a GitHub App registration.\n\n\n\nApps/Creating GitHub Apps/Registering a GitHub App/Setup URLAbout the setup URLYou can specify a URL that users will be redirected to after they install a GitHub App.When you register a GitHub App, you can specify a setup URL. When users install your GitHub App, they are redirected to the setup URL. If additional setup is required after installation, you can use this URL to tell users what steps to take next.
If you specify a setup URL, you can also select Redirect on update to specify that users should be redirected to the setup URL after they update an installation. An update includes adding or removing access to a repository for an installation.
Warning

When GitHub redirects users to the setup URL, it includes an installation_id query parameter. Bad actors can hit this URL with a spoofed installation_id. Therefore, you should not rely on the validity of the installation_id parameter. Instead, you should generate a user access token for the user who installed the GitHub App and then check that the installation is associated with that user. For more information, see Generating a user access token for a GitHub App.

Although the setup URL is optional during GitHub App registration, it is required if you want to allow users to purchase your app in GitHub Marketplace. For more information, see Handling new purchases and free trials.
The setup URL is different from the callback URL. Users are redirected to the setup URL after they install a GitHub App. Users are redirected to the callback URL when they authorize a GitHub App via the web application flow. For more information, see About the user authorization callback URL.
For more information about registering a GitHub App, see Registering a GitHub App. For more information about modifying a GitHub App registration, see Modifying a GitHub App registration.\n\n\n\nApps/Creating GitHub Apps/Registering a GitHub App/PermissionsChoosing permissions for a GitHub AppThe permissions of a GitHub App determine what the app can do with GitHub's APIs and what webhooks the app can receive.In this articleAbout GitHub App permissionsAbout changes to permissionsChoosing permissions for webhook accessChoosing permissions for REST API accessChoosing permissions for GraphQL API accessChoosing permissions for Git accessAbout GitHub App permissions
GitHub Apps don't have any permissions by default. When you register a GitHub App, you can select permissions for the app. The permissions that you select determine what the app can do with GitHub's APIs and what webhooks the app can subscribe to. You should select the minimum permissions required for the app.
Although GitHub Apps don't have any permissions by default, they do have implicit permissions to read public resources when acting on behalf of a user. When a user authorizes the app to act on their behalf, the GitHub App can use the resulting user access token to make requests to the REST API and the GraphQL API to read public resources. To learn more about acting on behalf of a user, see Authenticating with a GitHub App on behalf of a user.
App permissions are classified as repository, organization, or account permissions. Repository permissions allow your app to access resources related to repositories that are owned by the account where the app is installed. Organization permissions allow your app to access resources related to the organization where the app is installed, if it is installed on an organization account. Account permissions allow your app to access resources related to a user if the user has also authorized your app. For more information about user authorization of apps, see Authenticating with a GitHub App on behalf of a user.
When a user installs an app on their account or organization, they see and grant the repository and organization permissions that the app requested. They will also see a list of account permissions that the app can request for individual users. When a user authorizes an app to act on their behalf, they will see and grant the account permissions that the app requested.
The success of an API request with a user access token depends on the user's permissions as well as the app's permissions. For example, if the app was granted permission to write the contents of a repository, but the user can only read the contents, then the user access token can only read the contents. The success of an API request with an installation access token only depends on the app's permissions.
For more information about specifying permissions during GitHub App registration, see Registering a GitHub App.
Some webhooks and API access requires "Administration" permissions. If your app requires "Administration" permissions, consider explaining this requirement on your app's homepage. This will help users understand why your app needs a high level permission.
About changes to permissions
You can modify the permissions for apps you own or manage at any time. When you do so, the owner of each account where the app was installed will be prompted to approve the new permissions. If the account owner does not approve the new permissions, their installation will continue to use the old permissions.
For more information about modifying permissions, see Modifying a GitHub App registration.
Choosing permissions for webhook access
The webhook documentation indicates whether each webhook is available to GitHub Apps. For each webhook that you want to subscribe to, refer to the webhook documentation to see what permissions a GitHub App needs to subscribe to that webhook. For more information, see Webhook events and payloads.
For example, if you want your app to subscribe to team events, your app must have the "Members" organization permission.
On your GitHub App registration page, the available webhook events will change as you change your app's permissions. If you did not select sufficient permissions for your GitHub App to subscribe to an event, the event will not appear as an option on your app registration page.
Choosing permissions for REST API access
The REST API reference documentation for each endpoint states whether the endpoint works with GitHub Apps and states what permissions are required in order for the app to use the endpoint. Some endpoints may require multiple permissions, and some endpoints may require one of multiple permissions. For an overview of which REST API endpoints a GitHub App can access with each permission, see Permissions required for GitHub Apps.
For example, to use the GET /orgs/{org}/dependabot/secrets endpoint, your app must have at least read-level permission for the "organization dependabot secrets" permission.
If your app makes a REST API request with insufficient permissions, the API will return a 403 response.
To help you choose the correct permissions, you will receive the X-Accepted-GitHub-Permissions header in the REST API response. The header will tell you what permissions are required in order to access the endpoint. For more information, see Troubleshooting the REST API.
Choosing permissions for GraphQL API access
For GraphQL requests, you should test your app to ensure that it has the required permissions for the GraphQL queries and mutations that you want to make.
If your app makes a GraphQL API query or mutation with insufficient permissions, the API will return a 401 response.
Choosing permissions for Git access
If you want your app to use an installation or user access token to authenticate for HTTP-based Git access, you should request the "Contents" repository permission. If your app specifically needs to access or edit Actions files in the .github/workflows directory, request the "Workflows" repository permission.
You can then use the access token as the HTTP password. Replace TOKEN with the access token:
git clone https://x-access-token:TOKEN@github.com/owner/repo.git\n\n\n\nApps/Creating GitHub Apps/Registering a GitHub App/WebhooksUsing webhooks with GitHub AppsYour GitHub App can subscribe to webhook events to receive notifications whenever certain activity occurs.In this articleAbout webhooks and GitHub AppsChoosing a webhook URLSecuring your webhooks with a webhook secretSubscribing to webhook eventsAbout webhooks and GitHub Apps
Webhooks enable your GitHub App to receive real-time notifications when events happen on GitHub, such as when someone pushes a commit or opens a pull request in a repository that your app can access. For more information about webhooks, see About webhooks. For a tutorial that demonstrates how to use webhooks with a GitHub App, see Building a GitHub App that responds to webhook events.
You can configure your GitHub App to receive webhooks for specific events on GitHub and automatically take action on them. For more information about the types of webhooks you can receive, see Webhook events and payloads.
To receive webhook events in your GitHub App, you must enable webhooks for your GitHub App registration and specify a webhook URL where GitHub will send the webhook payloads.
If your GitHub App does not need to respond to webhooks or will only be used for authentication, you can turn off the webhook function for your GitHub App registration. You do not need to specify a webhook URL.
For more information about registering a GitHub App, see Registering a GitHub App. For more information about changing the webhooks that a GitHub App registration subscribes to, see Modifying a GitHub App registration.
Choosing a webhook URL
When you activate webhooks for your GitHub App registration, you will need to specify a webhook URL. The webhook URL is the address of a web server that will receive the webhook event payloads sent to your GitHub App. The server can then take action based on the content of the payload. You should choose a web server that's appropriate for the volume of webhook traffic that your GitHub App will encounter.
Choosing a webhook URL for development and testing
While you develop and test your app, you can use a webhook payload delivery service like Smee to capture and forward webhook payloads to your local development environment. Never use Smee for an application in production, because Smee channels are not authenticated or secure. Alternatively, you can use a tool like ngrok, localtunnel, or the Hookdeck Console that exposes your local machine to the internet to receive the payloads.
Creating a webhook URL with Smee
You can use Smee to create a unique domain where GitHub can send webhook payloads, without exposing your local development to the internet. Smee calls this unique domain a "Webhook Proxy URL." You can use Smee's Webhook Proxy URL as the webhook URL for your GitHub App.

To use Smee to create a unique domain, go to https://smee.io and click Start a new channel.
On the Smee channel page, follow the instructions under "Use the CLI" to install and run the Smee client.
To connect your Smee webhook URL to your GitHub App, enter your unique Smee domain in the "Webhook URL" field on your GitHub App registration page. For more information, see Registering a GitHub App and Modifying a GitHub App registration.

Choosing a webhook URL for production
For an application in production that receives a low volume of webhook traffic, you can host it on any dynamic application server. The server-side code for handling the webhook can receive the event, deserialize its JSON payload, and decide what action to take, such as storing the data in a database or calling the GitHub API.
To handle a higher volume of webhook traffic for a large app in production, consider using asynchronous webhook handling on a dedicated server. You can achieve this by employing a queue, where the webhook handler pushes data to the queue, and separate processes perform subsequent actions based on the events. Additionally, you can use cloud functions such as Azure Functions, AWS Lambda, or Hookdeck to help scale the app for handling large volumes of webhook events.
Securing your webhooks with a webhook secret
Once you've configured your server to receive payloads, it will listen for any payload sent to the server. For security reasons, you should limit incoming requests to only those originating from GitHub. You can do that by creating a webhook secret for your app.
To create a webhook secret for your GitHub App, type a secret token under "Webhook secret" on your GitHub App registration page. You should choose a random string of text with high entropy. For more information, see Registering a GitHub App and Modifying a GitHub App registration.
After creating a webhook secret for your app, you will need to configure your server to securely store and validate the webhook secret token. For more information, see Validating webhook deliveries.
Subscribing to webhook events
You can subscribe your GitHub App to receive webhook payloads for specific events. The specific webhook events that you can select for your GitHub App registration are determined by the type of permissions you selected for your app. You will first need to select the permissions you would like your app to have, and then you can subscribe your app to webhook events that are related to that set of permissions. For more information, see Choosing permissions for a GitHub App.
For example, if you would like your app to receive a webhook event payload whenever a new issue is opened in your repository, you would first need to give your app permission to access "Issues" under "Repository permissions." Then under "Subscribe to events" you can select "Issues."
For more information about the permissions that are required for each webhook event, see Webhook events and payloads.\n\n\n\nApps/Creating GitHub Apps/Registering a GitHub App/VisibilityMaking a GitHub App public or privateWhen registering a GitHub App, you can make it public so that other GitHub users or organizations can install the app, or private so that you can only install it on the account that owns the app.About visibility for GitHub Apps
A GitHub App can be public or private. If you set your GitHub App registration to public, any user on GitHub can install it. If you set your GitHub App registration to private, it can only be installed on the account that owns the app.
If you want your GitHub App to be available to organizations in a GitHub Enterprise Server instance that you are not part of, then you need to take additional steps. For more information, see Making your GitHub App available for GitHub Enterprise Server.
If it is important for GitHub Enterprise Server users to be able to use your tool, consider using GitHub Actions instead of a GitHub App. Public actions are available on GitHub Enterprise Server instances with GitHub Connect. For more information, see Enabling automatic access to GitHub.com actions using GitHub Connect and About GitHub Actions for enterprises in the GitHub Enterprise Server documentation.
For information about changing the visibility of a GitHub App registration, see Modifying a GitHub App registration.
Public installation flow
Public GitHub Apps have a landing page with an Install button, so that other people can install the app in their repositories. If your GitHub App is public to all users on GitHub, you can also choose to publish it to GitHub Marketplace. For more information, see About GitHub Marketplace for apps.
Private installation flow
Private GitHub Apps can only be installed on the user or organization account of the app owner. Limited information about the app will exist on a landing page for the app, but the Install button will only be available to organization owners and app managers for the organization that owns the app, or the personal account if the GitHub App is owned by an individual account.\n\n\n\nApps/Creating GitHub Apps/Registering a GitHub App/Rate limitsRate limits for GitHub AppsRate limits restrict the rate of traffic to GitHub.com, to help ensure consistent access for all users.GitHub sets a limit on the number of requests a GitHub App can make to the REST API within a specific time period. It also sets a limit on the point value of queries that a GitHub App can make to the GraphQL API within a specific time period. In addition to these primary rate limits, GitHub may also apply secondary rate limits. These limits help to prevent abuse and denial-of-service attacks, and ensure that the system remains available for all users.
The rate limit for GitHub Apps depends on whether the app authenticates with a user access token or an installation access token. It also depends on where the app is owned by or installed on a GitHub Enterprise Cloud organization.
For more information, see Rate limits for the REST API and Rate limits and node limits for the GraphQL API.\n\n\n\nApps/Creating GitHub Apps/Registering a GitHub App/Custom badgeCreating a custom badge for your GitHub AppYou can replace the default badge on your GitHub App by uploading your own logo image and customizing the background.In this articleAbout badgesCreating a custom badgeNext stepsAbout badges
Every GitHub App has a badge. A badge is a square image inside a circular background.
By default, a new GitHub App will use an automatically generated identicon as a badge. An identicon badge looks something like this:

After you register a GitHub App, you can customize your app's badge by uploading a logo and selecting a background color. Your logo should be a PNG, JPG, or GIF file under 1 MB in size. For the best quality rendering, we recommend an image dimension of 200 pixels by 200 pixels.
For more information about badges for GitHub Apps in GitHub Marketplace, see Writing a listing description for your app. You can change a custom badge for a GitHub App that already has an approved Marketplace listing by navigating to https://github.com/marketplace/manage.
Creating a custom badge


In the upper-right corner of any page on GitHub, click your profile photo.


Navigate to your account settings.

For an app owned by a personal account, click Settings.
For an app owned by an organization:

Click Your organizations.
To the right of the organization, click Settings.





In the left sidebar, click  Developer settings.


In the left sidebar, click GitHub Apps.


To the right of the GitHub App you want to modify, click Edit.


Under "Display information", drag and drop an image from a local folder or click Upload a logo to select an image from your computer.


Optionally, crop your image.


Click Set new avatar.


Under "Badge background color", type the hexadecimal color code of the background color for your badge.
Note

The "Badge background color" input field will only appear after you upload a logo.



Next steps
For more information about listing your GitHub App in GitHub Marketplace, see Listing an app on GitHub Marketplace.\n\n\n\nApps/Creating GitHub Apps/Authenticate with a GitHub App/Authenticate as an appAuthenticating as a GitHub AppYou can authenticate as a GitHub App in order to generate an installation access token or manage your app.In this articleAbout authentication as a GitHub AppUsing a JSON Web Token (JWT) to authenticate as a GitHub AppUsing the Octokit.js SDK to authenticate as a GitHub AppAbout authentication as a GitHub App
You must authenticate as a GitHub App in order to make REST API requests as the application. For example, if you want to use the API to generate an installation access token for accessing organization resources, list installations across organizations for your app, or suspend an app installation, you must authenticate as an app.
If a REST API endpoint requires you to authenticate as an app, the documentation for that endpoint will indicate that you must use a JWT to access the endpoint. The GraphQL API does not support any queries or mutations that require you to authenticate as an app.
Using a JSON Web Token (JWT) to authenticate as a GitHub App


Generate a JSON Web Token (JWT) for your app. For more information, see Generating a JSON Web Token (JWT) for a GitHub App.


Include the JWT in the Authorization header of your request. In the following example, replace YOUR_JWT with your JWT.
curl --request GET \
--url "https://api.github.com/app/installations" \
--header "Accept: application/vnd.github+json" \
--header "Authorization: Bearer YOUR_JWT" \
--header "X-GitHub-Api-Version: 2022-11-28"



Using the Octokit.js SDK to authenticate as a GitHub App
You can use GitHub's Octokit.js SDK to authenticate as a GitHub App. One advantage of using the SDK to authenticate is that you do not need to generate a JSON web token (JWT) yourself. Additionally, the SDK will take care of regenerating the JWT when it expires.
Note

You must install and import octokit in order to use the Octokit.js library. The following example uses import statements in accordance with ES6. For more information about different installation and import methods, see Usage in the octokit/octokit repository.



Get the ID of your app. You can find your app's ID on the settings page for your GitHub App. For more information about navigating to the settings page for your GitHub App, see Modifying a GitHub App registration.


Generate a private key. For more information, see Managing private keys for GitHub Apps.


Import App from octokit.
JavaScriptimport { App } from "octokit";
import { App } from "octokit";



Create a new instance of App. In the following example, replace APP_ID with a reference to your app's ID. Replace PRIVATE_KEY with a reference to the value of your app's private key.
JavaScript const app = new App({
  appId: APP_ID,
  privateKey: PRIVATE_KEY,
});
 const app = new App({
  appId: APP_ID,
  privateKey: PRIVATE_KEY,
});



Use an octokit method to make a request to a REST API endpoint that requires a JWT. For example:
JavaScriptawait app.octokit.request("/app")
await app.octokit.request("/app")\n\n\n\nApps/Creating GitHub Apps/Authenticate with a GitHub App/Authenticate as an installationAuthenticating as a GitHub App installationYou can make your GitHub App authenticate as an installation in order to make API requests that affect resources owned by the account where the app is installed.In this articleAbout authentication as a GitHub App installationUsing an installation access token to authenticate as an app installationUsing the Octokit.js SDK to authenticate as an app installationAbout authentication as a GitHub App installation
Once your GitHub App is installed on an account, you can make it authenticate as an app installation for API requests. This allows the app to access resources owned by that installation, as long as the app was granted the necessary repository access and permissions. API requests made by an app installation are attributed to the app. For more information about installing GitHub Apps, see Installing GitHub Apps.
For example, if you want your app to change the Status field of an issue on a project owned by an organization called "octo-org," then you would authenticate as the octo-org installation of your app. The timeline of the issue would state that your app updated the status.
To make an API request as an installation, you must first generate an installation access token. Then, you will send the installation access token in the Authorization header of your subsequent API requests. You can also use GitHub's Octokit SDKs, which can generate an installation access token for you.
Some REST API endpoints do not accept installation access tokens, and most REST API endpoints require your app to have certain permissions to use an endpoint. To see whether a REST API endpoint accepts installation access tokens and to see what permissions are required, refer to the documentation for the endpoint.
App installations can also use the GraphQL API. Similar to the REST API, the app must have certain permissions to access objects in the GraphQL API. For GraphQL requests, you should test that your app has the required permissions for the GraphQL queries and mutations that you want to make.
You can also use an installation access token to authenticate for HTTP-based Git access. Your app must have the "Contents" repository permission. You can then use the installation access token as the HTTP password. Replace TOKEN with the installation access token: git clone https://x-access-token:TOKEN@github.com/owner/repo.git.
Requests made with an installation access token are sometimes called "server-to-server" requests.
For more information about authenticating as an app on behalf of a user instead of as an app installation, see Authenticating with a GitHub App on behalf of a user.
Using an installation access token to authenticate as an app installation
To authenticate as an installation with an installation access token, first use the REST API to generate an installation access token. Then, use that installation access token in the Authorization header of a REST API or GraphQL API request. The installation access token will expire after 1 hour.
Generating an installation access token


Generate a JSON web token (JWT) for your app. For more information, see Generating a JSON Web Token (JWT) for a GitHub App.


Get the ID of the installation that you want to authenticate as.
If you are responding to a webhook event, the webhook payload will include the installation ID.
You can also use the REST API to find the ID for an installation of your app. For example, you can get an installation ID with the GET /users/{username}/installation, GET /repos/{owner}/{repo}/installation, GET /orgs/{org}/installation, or GET /app/installations endpoints. For more information, see REST API endpoints for GitHub Apps.
You can also find the app ID on the settings page for your app. The app ID is different from the client ID. For more information about navigating to the settings page for your GitHub App, see Modifying a GitHub App registration.


Send a REST API POST request to /app/installations/INSTALLATION_ID/access_tokens. Include your JSON web token in the Authorization header of your request. Replace INSTALLATION_ID with the ID of the installation that you want to authenticate as.
For example, send this curl request. Replace INSTALLATION_ID with the ID of the installation and JWT with your JSON web token:
curl --request POST \
--url "https://api.github.com/app/installations/INSTALLATION_ID/access_tokens" \
--header "Accept: application/vnd.github+json" \
--header "Authorization: Bearer JWT" \
--header "X-GitHub-Api-Version: 2022-11-28"

Optionally, you can use the repositories or repository_ids body parameters to specify individual repositories that the installation access token can access. If you don't use repositories or repository_ids to grant access to specific repositories, the installation access token will have access to all repositories that the installation was granted access to. The installation access token cannot be granted access to repositories that the installation was not granted access to. You can list up to 500 repositories.
Optionally, use the permissions body parameter to specify the permissions that the installation access token should have. If permissions is not specified, the installation access token will have all of the permissions that were granted to the app. The installation access token cannot be granted permissions that the app was not granted.
The response will include an installation access token, the time that the token expires, the permissions that the token has, and the repositories that the token can access. The installation access token will expire after 1 hour.
For more information about this endpoint, see REST API endpoints for GitHub Apps.
Note

In most cases, you can use Authorization: Bearer or Authorization: token to pass a token. However, if you are passing a JSON web token (JWT), you must use Authorization: Bearer.



Authenticating with an installation access token
To authenticate with an installation access token, include it in the Authorization header of an API request. The access token will work with both the GraphQL API and the REST API.
Your app must have the required permissions to use the endpoint. For more information, see Choosing permissions for a GitHub App.
In the following example, replace INSTALLATION_ACCESS_TOKEN with an installation access token:
curl --request GET \
--url "https://api.github.com/meta" \
--header "Accept: application/vnd.github+json" \
--header "Authorization: Bearer INSTALLATION_ACCESS_TOKEN" \
--header "X-GitHub-Api-Version: 2022-11-28"

Using the Octokit.js SDK to authenticate as an app installation
You can use GitHub's Octokit.js SDK to authenticate as an app installation. One advantage of using the SDK to authenticate is that you do not need to generate a JSON web token (JWT) yourself. Additionally, the SDK will take care of regenerating an installation access token for you so you don't need to worry about the one hour expiration.
Note

You must install and import octokit in order to use the Octokit.js library. The following example uses import statements in accordance with ES6. For more information about different installation and import methods, see the Octokit.js README's Usage section.

Using Octokit.js to authenticate with an installation ID


Get the ID of your GitHub App. You can find your app's ID on the settings page for your GitHub App. For more information about navigating to the settings page for your GitHub App, see Modifying a GitHub App registration.


Generate a private key. For more information, see Managing private keys for GitHub Apps.


Get the ID of the installation that you want to authenticate as.
If you are responding to a webhook event, the webhook payload will include the installation ID.
You can also use the REST API to find the ID for an installation of your app. For example, you can get an installation ID with the GET /users/{username}/installation, GET /repos/{owner}/{repo}/installation, GET /orgs/{org}/installation, or GET /app/installations endpoints. For more information, see REST API endpoints for GitHub Apps.


Import App from octokit. Create a new instance of App. In the following example, replace APP_ID with a reference to your app's ID. Replace PRIVATE_KEY with a reference to your app's private key.
JavaScriptimport { App } from "octokit";

const app = new App({
  appId: APP_ID,
  privateKey: PRIVATE_KEY,
});
import { App } from "octokit";

const app = new App({
  appId: APP_ID,
  privateKey: PRIVATE_KEY,
});



Use the getInstallationOctokit method to create an authenticated octokit instance. In the following example, replace INSTALLATION_ID with the ID of the installation of your app that you want to authenticate on behalf of.
JavaScriptconst octokit = await app.getInstallationOctokit(INSTALLATION_ID);
const octokit = await app.getInstallationOctokit(INSTALLATION_ID);



Use an octokit method to make a request to the API.
Your app must have the required permissions to use the endpoint. For more information, see Choosing permissions for a GitHub App.
For example, to make a request to the GraphQL API:
JavaScriptawait octokit.graphql(`
  query {
    viewer {
      login
    }
  }
  `)
await octokit.graphql(`
  query {
    viewer {
      login
    }
  }
  `)

For example, to make a request to the REST API:
JavaScriptawait octokit.request("GET /meta")
await octokit.request("GET /meta")



Using Octokit.js to authenticate in response to a webhook event
The Octokit.js SDK also passes a pre-authenticated octokit instance to webhook event handlers.


Get the ID of your GitHub App. You can find your app's ID on the settings page for your GitHub App. For more information about navigating to the settings page for your GitHub App, see Modifying a GitHub App registration.


Generate a private key. For more information, see Managing private keys for GitHub Apps.


Get the webhook secret that you specified in your app's settings. For more information about webhook secrets, see Using webhooks with GitHub Apps.


Import App from octokit. Create a new instance of App. In the following example, replace APP_ID with a reference to your app's ID. Replace PRIVATE_KEY with a reference to your app's private key. Replace WEBHOOK_SECRET with the your app's webhook secret.
JavaScriptimport { App } from "octokit";

const app = new App({
  appId: APP_ID,
  privateKey: PRIVATE_KEY,
  webhooks: { WEBHOOK_SECRET },
});
import { App } from "octokit";

const app = new App({
  appId: APP_ID,
  privateKey: PRIVATE_KEY,
  webhooks: { WEBHOOK_SECRET },
});



Use an app.webhooks.* method to handle webhook events. For more information, see the Octokit.js README's Webhooks section. For example, to create a comment on an issue when the issue is opened:
app.webhooks.on("issues.opened", ({ octokit, payload }) => {
  await octokit.request("POST /repos/{owner}/{repo}/issues/{issue_number}/comments", {
      owner: payload.repository.owner.login,
      repo: payload.repository.name,
      issue_number: payload.issue.number,
      body: `This is a bot post in response to this issue being opened.`,
      headers: {
        "x-github-api-version": "2022-11-28",
      },
    }
  )
});\n\n\n\nApps/Creating GitHub Apps/Authenticate with a GitHub App/Authenticate on behalf of usersAuthenticating with a GitHub App on behalf of a userYour GitHub App can perform actions on behalf of a user, like creating an issue, posting a comment, or creating a deployment.Your app can make API requests on behalf of a user. API requests made by an app on behalf of a user will be attributed to that user. For example, if your app posts a comment on behalf of a user, the GitHub UI will show the user's avatar photo along with the app's identicon badge as the author of the issue.

Similarly, if the request triggers a corresponding entry in the audit logs and security logs, the logs will list the user as the actor but will state that the "programmatic_access_type" is "GitHub App user-to-server token".
To make an API request on behalf of a user, the user must authorize your app. If an app is installed on an organization that includes multiple members, each member will need to authorize the app before the app can act on their behalf. An app does not need to be installed in order for a user to authorize the app.
When a user installs an app on their account or organization, they grant the app permission to access the organization and repository resources that it requested. During the installation process, they will also see a list of account permissions that the app can request for individual users. When a user authorizes an app, they grant the app permission to act on their behalf, and they grant the account permissions that the app requested.
Once a user has authorized your app, you can generate a user access token, which is a type of OAuth token. You should send the user access token in the Authorization header of your subsequent API requests. For more information about prompting a user to authorize your app and generating a user access token, see Generating a user access token for a GitHub App.
Requests made with a user access token are sometimes called "user-to-server" requests.
A token has the same capabilities to access resources and perform actions on those resources that the owner of the token has, and is further limited by any scopes or permissions granted to the token. A token cannot grant additional access capabilities to a user.
If you want to attribute app activity to the app instead of to a user, you should authenticate as an app installation instead. For more information, see Authenticating as a GitHub App installation.
Note

If a user reports that they cannot see resources owned by their organization after authorizing your GitHub App and the organization uses SAML SSO, instruct the user to start an active SAML session for their organization before reauthorizing. For more information, see SAML and GitHub Apps in the GitHub Enterprise Cloud documentation.\n\n\n\nApps/Creating GitHub Apps/Authenticate with a GitHub App/Manage private keysManaging private keys for GitHub AppsYou can manage private keys to authenticate with your GitHub App.In this articleAbout private keys for GitHub AppsGenerating private keysVerifying private keysDeleting private keysStoring private keysAbout private keys for GitHub Apps
After you create a GitHub App, you'll need to generate a private key in order to make requests to the GitHub API as the application itself. For example, you need a private key to sign a JSON Web Token (JWT) in order to request an installation access token. For more information, see Generating a JSON Web Token (JWT) for a GitHub App
You can create up to 25 private keys for an app. You should use multiple keys in order to rotate keys without downtime in the event of a key compromise. If your application has 25 or more keys, you must delete some before you can create more.
Private keys do not expire and instead need to be manually revoked. For more information about how to revoke or delete a private key, see Deleting private keys.
You must keep private keys for GitHub Apps secure. For more information, see Storing private keys.
To verify that a private key matches a public key, see Verifying private keys.
Generating private keys
To generate a private key:


In the upper-right corner of any page on GitHub, click your profile photo.


Navigate to your account settings.

For an app owned by a personal account, click Settings.
For an app owned by an organization:

Click Your organizations.
To the right of the organization, click Settings.





In the left sidebar, click  Developer settings.


In the left sidebar, click GitHub Apps.


Next to the GitHub App that you want to generate a private key for, click Edit.


Under "Private keys", click Generate a private key.


You will see a private key in PEM format downloaded to your computer. Make sure to store this file because GitHub only stores the public portion of the key. For more information about securely storing your key, see Storing private keys.


Note

If you're using a library that requires a specific file format, the PEM file you download will be in PKCS#1 RSAPrivateKey format.

Verifying private keys
GitHub generates a fingerprint for each private and public key pair using the SHA-256 hash function. You can verify that your private key matches the public key stored on GitHub by generating the fingerprint of your private key and comparing it to the fingerprint shown on GitHub.
To verify a private key:


Find the fingerprint for the private and public key pair you want to verify in the "Private keys" section of the settings page for your GitHub App. For more information, see Generating private keys.



Generate the fingerprint of your private key (PEM) locally by using the following command:
openssl rsa -in PATH_TO_PEM_FILE -pubout -outform DER | openssl sha256 -binary | openssl base64



Compare the results of the locally generated fingerprint to the fingerprint you see in GitHub.


Deleting private keys
You can remove a lost or compromised private key by deleting it, but you must regenerate a new key before you can delete the existing key.

In the upper-right corner of any page on GitHub, click your profile photo.
Navigate to your account settings.

For an app owned by a personal account, click Settings.
For an app owned by an organization:

Click Your organizations.
To the right of the organization, click Settings.




In the left sidebar, click  Developer settings.
In the left sidebar, click GitHub Apps.
Next to the GitHub App that you want to delete a private key for, click Edit.
Under "Private keys", to the right of the private key you want to delete, click Delete.
When prompted, confirm you want to delete the private key by clicking Delete. If your GitHub App has only one key, you will need to generate a new key before deleting the old key. For more information, see Generating private keys.

Storing private keys
The private key is the single most valuable secret for a GitHub App. Consider storing the key in a key vault, such as Azure Key Vault, and making it sign-only. This helps ensure that you can't lose the private key. Once the private key is uploaded to the key vault, it can never be read from there. It can only be used to sign things, and access to the private key is determined by your infrastructure rules.
Alternatively, you can store the key as an environment variable. This is not as strong as storing the key in a key vault. If an attacker gains access to the environment, they can read the private key and gain persistent authentication as the GitHub App.
You should not hard-code your private key in your app, even if your code is stored in a private repository.
For more information, see Best practices for creating a GitHub App.\n\n\n\nApps/Creating GitHub Apps/Authenticate with a GitHub App/Generate a JWTGenerating a JSON Web Token (JWT) for a GitHub AppLearn how to create a JSON Web Token (JWT) to authenticate to certain REST API endpoints with your GitHub App.In this articleAbout JSON Web Tokens (JWTs)Generating a JSON Web Token (JWT)About JSON Web Tokens (JWTs)
In order to authenticate as an app or generate an installation access token, you must generate a JSON Web Token (JWT). If a REST API endpoint requires a JWT, the documentation for that endpoint will indicate that you must use a JWT to access the endpoint.
Your JWT must be signed using the RS256 algorithm and must contain the following claims.






























ClaimMeaningDetailsiatIssued AtThe time that the JWT was created. To protect against clock drift, we recommend that you set this 60 seconds in the past and ensure that your server's date and time is set accurately (for example, by using the Network Time Protocol).expExpires AtThe expiration time of the JWT, after which it can't be used to request an installation token. The time must be no more than 10 minutes into the future.issIssuerThe client ID or application ID of your GitHub App. This value is used to find the right public key to verify the signature of the JWT. You can find your app's IDs on the settings page for your GitHub App. Use of the client ID is recommended. For more information about navigating to the settings page for your GitHub App, see Modifying a GitHub App registration.algMessage authentication code algorithmThis should be RS256 since your JWT must be signed using the RS256 algorithm.
To use a JWT, pass it in the Authorization header of an API request. For example:
curl --request GET \
--url "https://api.github.com/app" \
--header "Accept: application/vnd.github+json" \
--header "Authorization: Bearer YOUR_JWT" \
--header "X-GitHub-Api-Version: 2022-11-28"

In most cases, you can use Authorization: Bearer or Authorization: token to pass a token. However, if you are passing a JSON web token (JWT), you must use Authorization: Bearer.
Generating a JSON Web Token (JWT)
Most programming languages have a package that can generate a JWT. In all cases, you must have a private key and the ID of your GitHub App. For more information about generating a private key, see Managing private keys for GitHub Apps. You can find your app's ID with the GET /app REST API endpoint. For more information, see Apps in the REST API documentation.
Note

Instead of creating a JWT, you can use GitHub's Octokit SDKs to authenticate as an app. The SDK will take care of generating a JWT for you and will regenerate the JWT once the token expires. For more information, see Scripting with the REST API and JavaScript.

Example: Using Ruby to generate a JWT
Note

You must run gem install jwt to install the jwt package in order to use this script.

In the following example, replace YOUR_PATH_TO_PEM with the file path where your private key is stored. Replace YOUR_CLIENT_ID with the ID of your app. Make sure to enclose the values for YOUR_PATH_TO_PEM and YOUR_CLIENT_ID in double quotes.
require 'openssl'
require 'jwt'  # https://rubygems.org/gems/jwt

# Private key contents
private_pem = File.read("YOUR_PATH_TO_PEM")
private_key = OpenSSL::PKey::RSA.new(private_pem)

# Generate the JWT
payload = {
  # issued at time, 60 seconds in the past to allow for clock drift
  iat: Time.now.to_i - 60,
  # JWT expiration time (10 minute maximum)
  exp: Time.now.to_i + (10 * 60),
  
# GitHub App's client ID
  iss: "YOUR_CLIENT_ID"
}

jwt = JWT.encode(payload, private_key, "RS256")
puts jwt

Example: Using Python to generate a JWT
Note

You must run pip install PyJWT cryptography to install the PyJWT and the cryptography packages in order to use this script.

Python#!/usr/bin/env python3
import sys
import time

import jwt

# Get PEM file path
if len(sys.argv) > 1:
    pem = sys.argv[1]
else:
    pem = input("Enter path of private PEM file: ")

# Get the Client ID
if len(sys.argv) > 2:
    client_id = sys.argv[2]
else:
    client_id = input("Enter your Client ID: ")

# Open PEM
with open(pem, 'rb') as pem_file:
    signing_key = pem_file.read()

payload = {
    # Issued at time
    'iat': int(time.time()),
    # JWT expiration time (10 minutes maximum)
    'exp': int(time.time()) + 600,
    
    # GitHub App's client ID
    'iss': client_id
}

# Create JWT
encoded_jwt = jwt.encode(payload, signing_key, algorithm='RS256')

print(f"JWT: {encoded_jwt}")
#!/usr/bin/env python3
import sys
import time

import jwt

# Get PEM file path
if len(sys.argv) > 1:
    pem = sys.argv[1]
else:
    pem = input("Enter path of private PEM file: ")

# Get the Client ID
if len(sys.argv) > 2:
    client_id = sys.argv[2]
else:
    client_id = input("Enter your Client ID: ")

# Open PEM
with open(pem, 'rb') as pem_file:
    signing_key = pem_file.read()

payload = {
    # Issued at time
    'iat': int(time.time()),
    # JWT expiration time (10 minutes maximum)
    'exp': int(time.time()) + 600,
    
    # GitHub App's client ID
    'iss': client_id
}

# Create JWT
encoded_jwt = jwt.encode(payload, signing_key, algorithm='RS256')

print(f"JWT: {encoded_jwt}")

This script will prompt you for the file path where your private key is stored and for the ID of your app. Alternatively, you can pass those values as inline arguments when you execute the script.
Example: Using Bash to generate a JWT
Note

You must pass your Client ID and the file path where your private key is stored as arguments when running this script.

Bash#!/usr/bin/env bash

set -o pipefail

client_id=$1 # Client ID as first argument

pem=$( cat $2 ) # file path of the private key as second argument

now=$(date +%s)
iat=$((${now} - 60)) # Issues 60 seconds in the past
exp=$((${now} + 600)) # Expires 10 minutes in the future

b64enc() { openssl base64 | tr -d '=' | tr '/+' '_-' | tr -d '\n'; }

header_json='{
    "typ":"JWT",
    "alg":"RS256"
}'
# Header encode
header=$( echo -n "${header_json}" | b64enc )

payload_json="{
    \"iat\":${iat},
    \"exp\":${exp},
    \"iss\":\"${client_id}\"
}"
# Payload encode
payload=$( echo -n "${payload_json}" | b64enc )

# Signature
header_payload="${header}"."${payload}"
signature=$(
    openssl dgst -sha256 -sign <(echo -n "${pem}") \
    <(echo -n "${header_payload}") | b64enc
)

# Create JWT
JWT="${header_payload}"."${signature}"
printf '%s\n' "JWT: $JWT"
#!/usr/bin/env bash

set -o pipefail

client_id=$1 # Client ID as first argument

pem=$( cat $2 ) # file path of the private key as second argument

now=$(date +%s)
iat=$((${now} - 60)) # Issues 60 seconds in the past
exp=$((${now} + 600)) # Expires 10 minutes in the future

b64enc() { openssl base64 | tr -d '=' | tr '/+' '_-' | tr -d '\n'; }

header_json='{
    "typ":"JWT",
    "alg":"RS256"
}'
# Header encode
header=$( echo -n "${header_json}" | b64enc )

payload_json="{
    \"iat\":${iat},
    \"exp\":${exp},
    \"iss\":\"${client_id}\"
}"
# Payload encode
payload=$( echo -n "${payload_json}" | b64enc )

# Signature
header_payload="${header}"."${payload}"
signature=$(
    openssl dgst -sha256 -sign <(echo -n "${pem}") \
    <(echo -n "${header_payload}") | b64enc
)

# Create JWT
JWT="${header_payload}"."${signature}"
printf '%s\n' "JWT: $JWT"

Example: Using PowerShell to generate a JWT
In the following example, replace YOUR_PATH_TO_PEM with the file path where your private key is stored. Replace YOUR_CLIENT_ID with the ID of your app. Make sure to enclose the values for YOUR_PATH_TO_PEM in double quotes.
PowerShell#!/usr/bin/env pwsh

$client_id = YOUR_CLIENT_ID

$private_key_path = "YOUR_PATH_TO_PEM"

$header = [Convert]::ToBase64String([System.Text.Encoding]::UTF8.GetBytes((ConvertTo-Json -InputObject @{
  alg = "RS256"
  typ = "JWT"
}))).TrimEnd('=').Replace('+', '-').Replace('/', '_');

$payload = [Convert]::ToBase64String([System.Text.Encoding]::UTF8.GetBytes((ConvertTo-Json -InputObject @{
  iat = [System.DateTimeOffset]::UtcNow.AddSeconds(-10).ToUnixTimeSeconds()
  exp = [System.DateTimeOffset]::UtcNow.AddMinutes(10).ToUnixTimeSeconds()
   iss = $client_id 
}))).TrimEnd('=').Replace('+', '-').Replace('/', '_');

$rsa = [System.Security.Cryptography.RSA]::Create()
$rsa.ImportFromPem((Get-Content $private_key_path -Raw))

$signature = [Convert]::ToBase64String($rsa.SignData([System.Text.Encoding]::UTF8.GetBytes("$header.$payload"), [System.Security.Cryptography.HashAlgorithmName]::SHA256, [System.Security.Cryptography.RSASignaturePadding]::Pkcs1)).TrimEnd('=').Replace('+', '-').Replace('/', '_')
$jwt = "$header.$payload.$signature"
Write-Host $jwt
#!/usr/bin/env pwsh

$client_id = YOUR_CLIENT_ID

$private_key_path = "YOUR_PATH_TO_PEM"

$header = [Convert]::ToBase64String([System.Text.Encoding]::UTF8.GetBytes((ConvertTo-Json -InputObject @{
  alg = "RS256"
  typ = "JWT"
}))).TrimEnd('=').Replace('+', '-').Replace('/', '_');

$payload = [Convert]::ToBase64String([System.Text.Encoding]::UTF8.GetBytes((ConvertTo-Json -InputObject @{
  iat = [System.DateTimeOffset]::UtcNow.AddSeconds(-10).ToUnixTimeSeconds()
  exp = [System.DateTimeOffset]::UtcNow.AddMinutes(10).ToUnixTimeSeconds()
   iss = $client_id 
}))).TrimEnd('=').Replace('+', '-').Replace('/', '_');

$rsa = [System.Security.Cryptography.RSA]::Create()
$rsa.ImportFromPem((Get-Content $private_key_path -Raw))

$signature = [Convert]::ToBase64String($rsa.SignData([System.Text.Encoding]::UTF8.GetBytes("$header.$payload"), [System.Security.Cryptography.HashAlgorithmName]::SHA256, [System.Security.Cryptography.RSASignaturePadding]::Pkcs1)).TrimEnd('=').Replace('+', '-').Replace('/', '_')
$jwt = "$header.$payload.$signature"
Write-Host $jwt\n\n\n\nApps/Creating GitHub Apps/Authenticate with a GitHub App/Generate an installation access tokenGenerating an installation access token for a GitHub AppLearn how to generate an installation access token for your GitHub App.In this articleAbout installation access tokensGenerating an installation access tokenAbout installation access tokens
In order to authenticate as an app installation, you must generate an installation access token. For more information about authenticating as an app installation, see Authenticating as a GitHub App installation.
Note

Instead of generating an installation access token, you can use GitHub's Octokit SDKs to authenticate as an app. The SDK will take care of generating an installation access token for you and will regenerate the token once it expires. For more information about authenticating as an app installation, see Authenticating as a GitHub App installation.

You should keep your installation access token secure. For more information, see Best practices for creating a GitHub App.
Generating an installation access token


Generate a JSON web token (JWT) for your app. For more information, see Generating a JSON Web Token (JWT) for a GitHub App.


Get the ID of the installation that you want to authenticate as.
If you are responding to a webhook event, the webhook payload will include the installation ID.
You can also use the REST API to find the ID for an installation of your app. For example, you can get an installation ID with the GET /users/{username}/installation, GET /repos/{owner}/{repo}/installation, GET /orgs/{org}/installation, or GET /app/installations endpoints. For more information, see REST API endpoints for GitHub Apps.
You can also find the app ID on the settings page for your app. The app ID is different from the client ID. For more information about navigating to the settings page for your GitHub App, see Modifying a GitHub App registration.


Send a REST API POST request to /app/installations/INSTALLATION_ID/access_tokens. Include your JSON web token in the Authorization header of your request. Replace INSTALLATION_ID with the ID of the installation that you want to authenticate as.
For example, send this curl request. Replace INSTALLATION_ID with the ID of the installation and JWT with your JSON web token:
curl --request POST \
--url "https://api.github.com/app/installations/INSTALLATION_ID/access_tokens" \
--header "Accept: application/vnd.github+json" \
--header "Authorization: Bearer JWT" \
--header "X-GitHub-Api-Version: 2022-11-28"

Optionally, you can use the repositories or repository_ids body parameters to specify individual repositories that the installation access token can access. If you don't use repositories or repository_ids to grant access to specific repositories, the installation access token will have access to all repositories that the installation was granted access to. The installation access token cannot be granted access to repositories that the installation was not granted access to. You can list up to 500 repositories.
Optionally, use the permissions body parameter to specify the permissions that the installation access token should have. If permissions is not specified, the installation access token will have all of the permissions that were granted to the app. The installation access token cannot be granted permissions that the app was not granted.
The response will include an installation access token, the time that the token expires, the permissions that the token has, and the repositories that the token can access. The installation access token will expire after 1 hour.
For more information about this endpoint, see REST API endpoints for GitHub Apps.
Note

In most cases, you can use Authorization: Bearer or Authorization: token to pass a token. However, if you are passing a JSON web token (JWT), you must use Authorization: Bearer.\n\n\n\nApps/Creating GitHub Apps/Authenticate with a GitHub App/Generate a user access tokenGenerating a user access token for a GitHub AppYou can generate a user access token for your GitHub App in order to attribute app activity to a user.In this articleAbout user access tokensUsing the web application flow to generate a user access tokenUsing the device flow to generate a user access tokenGenerating a user access token when a user installs your appUsing a refresh token to generate a user access tokenTroubleshootingAbout user access tokens
Note
 User access tokens that expire are currently an optional feature and are subject to change. To opt in or out of the token expiration feature, see Activating optional features for GitHub Apps. For more information, see Expiring user-to-server access tokens for GitHub Apps.
If a user reports that they cannot see resources owned by their organization after authorizing your GitHub App and the organization uses SAML SSO, instruct the user to start an active SAML session for their organization before reauthorizing. For more information, see SAML and GitHub Apps in the GitHub Enterprise Cloud documentation.

A user access token is a type of OAuth token. Unlike a traditional OAuth token, the user access token does not use scopes. Instead, it uses fine-grained permissions. A user access token only has permissions that both the user and the app have. For example, if the app was granted permission to write the contents of a repository, but the user can only read the contents, then the user access token can only read the contents.
Similarly, a user access token can only access resources that both the user and app can access. For example, if an app is granted access to repository A and B, and the user can access repository B and C, the user access token can access repository B but not A or C. You can use the REST API to check which installations and which repositories within an installation a user access token can access. For more information, see GET /user/installations and GET /user/installations/{installation_id}/repositories in REST API endpoints for GitHub App installations.
When you make API requests with a user access token, the rate limits for user access tokens apply. For more information, see Rate limits for GitHub Apps.
By default, the user access token expires after 8 hours. You can use a refresh token to regenerate a user access token. For more information, see Refreshing user access tokens.
Users can revoke their authorization of a GitHub App. For more information, see Token expiration and revocation. If a user revokes their authorization of a GitHub App, the app will receive the github_app_authorization webhook. GitHub Apps cannot unsubscribe from this event. If your app receives this webhook, you should stop calling the API on behalf of the user who revoked the token. If your app continues to use a revoked access token, it will receive the 401 Bad Credentials error. For more information about this webhook, see Webhook events and payloads.
You should keep user access tokens and refresh tokens secure. For more information, see Best practices for creating a GitHub App.
Using the web application flow to generate a user access token
If your app runs in the browser, you should use the web application flow to generate a user access token. For a tutorial about using the web application flow, see Building a "Login with GitHub" button with a GitHub App.


Direct the user to this URL, and add any necessary query parameters from the following list of parameters: https://github.com/login/oauth/authorize. For example, this URL specifies the client_id and state parameters: https://github.com/login/oauth/authorize?client_id=12345&state=abcdefg.















































Query parameterTypeRequired?Descriptionclient_idstringRequiredThe client ID for your GitHub App. The client ID is different from the app ID. You can find the client ID on the settings page for your app. For more information about navigating to the settings page for your GitHub App, see Modifying a GitHub App registration.redirect_uristringStrongly recommendedThe URL in your application where users will be sent after authorization. This must be an exact match to one of the URLs you provided as a "Callback URL" in your app's settings and can't contain any additional parameters.statestringStrongly recommendedWhen specified, the value should contain a random string to protect against forgery attacks, and it can also contain any other arbitrary data.loginstringOptionalWhen specified, the web application flow will prompt users with a specific account they can use for signing in and authorizing your app.allow_signupbooleanOptionalWhether unauthenticated users will be offered an option to sign up for GitHub during the OAuth flow. The default is true. Use false when a policy prohibits signups.promptstringOptionalForces the account picker to appear if set to select_account. The account picker will also appear if the application has a non-HTTP redirect URI or if the user has multiple accounts signed in.


If the user accepts your authorization request, GitHub will redirect the user to one of the callback URLs in your app settings, and provide a code query parameter you can use in the next step to create a user access token. If you specified redirect_uri in the previous step, that callback URL will be used. Otherwise, the first callback URL on your app's settings page will be used.
If you specified the state parameter in the previous step, GitHub will also include a state parameter. If the state parameter does not match the state parameter that you sent in the previous step, the request cannot be trusted, and the web application flow should be aborted.


Exchange the code from the previous step for a user access token by making a POST request to this URL, along with the following query parameters: https://github.com/login/oauth/access_token



































Query parameterTypeDescriptionclient_idstringRequired. The client ID for your GitHub App. The client ID is different from the app ID. You can find the client ID on the settings page for your app. For more information about navigating to the settings page for your GitHub App, see Modifying a GitHub App registration.client_secretstringRequired. The client secret for your GitHub App. You can generate a client secret on the settings page for your app.codestringRequired. The code you received in the previous step.redirect_uristringThe URL in your application where users will be sent after authorization. This must be an exact match to one of the URLs you provided as a "Callback URL" when setting up your GitHub App and can't contain any additional parameters.repository_idstringThe ID of a single repository that the user access token can access. If the GitHub App or user cannot access the repository, this will be ignored. Use this parameter to restrict the access of the user access token further.


GitHub will give a response that includes the following parameters:








































Response parameterTypeDescriptionaccess_tokenstringThe user access token. The token starts with ghu_.expires_inintegerThe number of seconds until access_token expires. If you disabled expiration of user access tokens, this parameter will be omitted. The value will always be 28800 (8 hours).refresh_tokenstringThe refresh token. If you disabled expiration of user access tokens, this parameter will be omitted. The token starts with ghr_.refresh_token_expires_inintegerThe number of seconds until refresh_token expires. If you disabled expiration of user access tokens, this parameter will be omitted. The value will always be 15897600 (6 months).scopestringThe scopes that the token has. This value will always be an empty string. Unlike a traditional OAuth token, the user access token is limited to the permissions that both your app and the user have.token_typestringThe type of token. The value will always be bearer.


Use the user access token from the previous step to make API requests on behalf of the user. Include the user access token in the Authorization header of an API request. For example:
curl --request GET \
--url "https://api.github.com/user" \
--header "Accept: application/vnd.github+json" \
--header "Authorization: Bearer USER_ACCESS_TOKEN" \
--header "X-GitHub-Api-Version: 2022-11-28"



Using the device flow to generate a user access token
Note

The device flow is in public preview and subject to change.

If your app is headless or does not have access to a browser, you should use the device flow to generate a user access token. For example, CLI tools, simple Raspberry Pis, and desktop applications should use the device flow. For a tutorial that uses device flow, see Building a CLI with a GitHub App.
Before you can use the device flow, you must first enable it in your app's settings. For more information on enabling device flow, see Modifying a GitHub App registration.
The device flow uses the OAuth 2.0 Device Authorization Grant.


Send a POST request to https://github.com/login/device/code along with a client_id query parameter. The client ID is different from the app ID. You can find the client ID on the settings page for your app. For more information about navigating to the settings page for your GitHub App, see Modifying a GitHub App registration.


GitHub will give a response that includes the following query parameters:



































Response parameterTypeDescriptiondevice_codestringA verification code that is used to verify the device. This code is 40 characters long.user_codestringA verification code that your application should display so that the user can enter the code in a browser. This code is 8 characters with a hyphen in the middle. For example, WDJB-MJHT.verification_uristringThe URL where users need to enter their user_code. The URL is:  https://github.com/login/device.expires_inintegerThe number of seconds before the device_code and user_code expire. The default is 900 seconds (15 minutes).intervalintegerThe minimum number of seconds that must pass before you can make a new access token request (POST https://github.com/login/oauth/access_token) to complete the device authorization. If you make a request before this interval passes, then you will hit the rate limit and receive a slow_down error. The default is 5 seconds.


Prompt the user to enter the user_code from the previous step at  https://github.com/login/device.
If the user does not enter the code before the expires_in time passes, the code will be invalid. In this case, you should restart the device flow.


Poll POST https://github.com/login/oauth/access_token along with the client_id, device_code, and grant_type query parameters (described below) until the device and user codes expire or the user has successfully authorized the app by entering the user_code.






























Query parameterTypeDescriptionclient_idstringRequired. The client ID for your GitHub App.device_codestringRequired. The device verification code you received in the previous step.grant_typestringRequired. The grant type must be urn:ietf:params:oauth:grant-type:device_code.repository_idstringThe ID of a single repository that the user access token can access. If the GitHub App or user cannot access the repository, this will be ignored. Use this parameter to restrict the access of the user access token further.
Do not poll this endpoint at a higher frequency than the frequency indicated by interval. If you do, you will hit the rate limit and receive a slow_down error. The slow_down error response adds 5 seconds to the last interval.
Until the user enters the code, GitHub will respond with a 200 status and an error response query parameter.









































Error nameDescriptionauthorization_pendingThis error occurs when the authorization request is pending and the user hasn't entered the user code yet. The app is expected to keep polling the POST https://github.com/login/oauth/access_token at a frequency no faster than the frequency specified by interval.slow_downWhen you receive the slow_down error, 5 extra seconds are added to the minimum interval or timeframe required between your requests using POST https://github.com/login/oauth/access_token. For example, if the starting interval required at least 5 seconds between requests and you get a slow_down error response, you must now wait a minimum of 10 seconds before making a new request for a token. The error response includes the new interval that you must use.expired_tokenIf the device code expired, then you will see the token_expired error. You must make a new request for a device code.unsupported_grant_typeThe grant type must be urn:ietf:params:oauth:grant-type:device_code and included as an input parameter when you poll the OAuth token request POST https://github.com/login/oauth/access_token.incorrect_client_credentialsFor the device flow, you must pass your app's client ID, which you can find on your app settings page. The client ID is different from the app ID and client secret.incorrect_device_codeThe device_code provided is not valid.access_deniedWhen a user clicks cancel during the authorization process, you'll receive an access_denied error, and the user won't be able to use the verification code again.device_flow_disabledDevice flow has not been enabled in the app's settings. For more information on enabling device flow, see Modifying a GitHub App registration.


Once the user has entered the user_code, GitHub will give a response that includes the following query parameters:








































Response parameterTypeDescriptionaccess_tokenstringThe user access token. The token starts with ghu_.expires_inintegerThe number of seconds until access_token expires. If you disabled expiration of user access tokens, this parameter will be omitted. The value will always be 28800 (8 hours).refresh_tokenstringThe refresh token. If you disabled expiration of user access tokens, this parameter will be omitted. The token starts with ghr_.refresh_token_expires_inintegerThe number of seconds until refresh_token expires. If you disabled expiration of user access tokens, this parameter will be omitted. The value will always be 15897600 (6 months).scopestringThe scopes that the token has. This value will always be an empty string. Unlike a traditional OAuth token, the user access token is limited to the permissions that both your app and the user have.token_typestringThe type of token. The value will always be bearer.


Use the user access token from the previous step to make API requests on behalf of the user. Include the user access token in the Authorization header of an API request. For example:
curl --request GET \
--url "https://api.github.com/user" \
--header "Accept: application/vnd.github+json" \
--header "Authorization: Bearer USER_ACCESS_TOKEN" \
--header "X-GitHub-Api-Version: 2022-11-28"



Generating a user access token when a user installs your app
If you select Request user authorization (OAuth) during installation in your app settings, GitHub will start the web application flow immediately after a user installs your app.
You can generate a user access token with this method regardless of whether the app is installed on a user account or an organization account. However, if the app was installed on an organization account, you will need to use the web application flow or device flow to generate a user access token for other users in the organization.


When a user installs your app, GitHub will redirect the user to https://github.com/login/oauth/authorize?client_id=CLIENT_ID, where CLIENT_ID is the client ID of your app.


If the user accepts your authorization request, GitHub will redirect the user to the first callback URL in your app settings, and provide a code query parameter.
If you want to control which callback URL is used, do not select Request user authorization (OAuth) during installation. Instead, direct users through the full web application flow and specify the redirect_uri parameter.


Exchange the code from the previous step for a user access token by making a POST request to this URL, along with the following query parameters: https://github.com/login/oauth/access_token



































Query parameterTypeDescriptionclient_idstringRequired. The client ID for your GitHub App. The client ID is different from the app ID. You can find the client ID on the settings page for your app. For more information about navigating to the settings page for your GitHub App, see Modifying a GitHub App registration.client_secretstringRequired. The client secret for your GitHub App. You can generate a client secret on the settings page for your app.codestringRequired. The code you received in the previous step.redirect_uristringThe URL in your application where users will be sent after authorization. This must be an exact match to one of the URLs you provided as a "Callback URL" when setting up your GitHub App and can't contain any additional parameters.repository_idstringThe ID of a single repository that the user access token can access. If the GitHub App or user cannot access the repository, this will be ignored. Use this parameter to restrict the access of the user access token further.


GitHub will give a response that includes the following parameters:








































Response parameterTypeDescriptionaccess_tokenstringThe user access token. The token starts with ghu_.expires_inintegerThe number of seconds until access_token expires. If you disabled expiration of user access tokens, this parameter will be omitted. The value will always be 28800 (8 hours).refresh_tokenstringThe refresh token. If you disabled expiration of user access tokens, this parameter will be omitted. The token starts with ghr_.refresh_token_expires_inintegerThe number of seconds until refresh_token expires. If you disabled expiration of user access tokens, this parameter will be omitted. The value will always be 15897600 (6 months).scopestringThe scopes that the token has. This value will always be an empty string. Unlike a traditional OAuth token, the user access token is limited to the permissions that both your app and the user have.token_typestringThe type of token. The value will always be bearer.


Use the user access token from the previous step to make API requests on behalf of the user. Include the user access token in the Authorization header of an API request. For example:
curl --request GET \
--url "https://api.github.com/user" \
--header "Accept: application/vnd.github+json" \
--header "Authorization: Bearer USER_ACCESS_TOKEN" \
--header "X-GitHub-Api-Version: 2022-11-28"



Using a refresh token to generate a user access token
By default, user access tokens expires after 8 hours. If you receive a user access token with an expiration, you will also receive a refresh token. The refresh token expire after 6 months. You can use this refresh token to regenerate a user access token. For more information, see Refreshing user access tokens.
GitHub strongly encourages you to use user access tokens that expire. If you previously opted out of using user access tokens that expire but want to re-enable this feature, see Activating optional features for GitHub Apps.
Troubleshooting
The following sections outline some errors you may receive when generating a user access token.
Incorrect client credentials
If the client_id or client_secret that you specify are incorrect, you will receive an incorrect_client_credentials error.
To resolve this error, make sure to use the correct credentials for your GitHub App. You can find the client ID and client secret on the settings page for your GitHub App. For more information about navigating to your GitHub App settings page, see Modifying a GitHub App registration.
Redirect URI mismatch
If you specify a redirect_uri that doesn't match one of the callback URLs in your GitHub App registration, you will receive a redirect_uri_mismatch error.
To resolve this error, either provide a redirect_uri that matches one of the callback URLs for your GitHub App registration, or omit this parameter to default to the first callback URL that is listed on your GitHub App registration. For more information, see About the user authorization callback URL.
Bad verification code
If you are using device flow and the verification code (device_code) that you specified is incorrect, expired, or doesn't
match the value that you received from the initial request to https://github.com/login/device/code, you will receive a bad_verification_code error.
To resolve this error, you should start the device flow again to get a new code. For more information, see Using the device flow to generate a user access token.
Bad refresh token
If the refresh token that you specified is invalid or expired, you will receive a bad_refresh_token error.
To resolve this error, you must restart the web application flow or device flow to get a new user access token and refresh token. You will only receive a refresh token if your GitHub App has opted in to expiring user access tokens. For more information, see Refreshing user access tokens.
Unsupported grant type
When you request a user access token via the device flow, the grant_type parameter must be urn:ietf:params:oauth:grant-type:device_code. When you refresh a user access token by using a refresh token, the grant_type parameter must be refresh_token. If you don't use the correct grant type, you will receive an unsupported_grant_type error.
Unverified user email
If the user for whom you are trying to generate a user access token has not verified their primary email address with GitHub, you will receive an unverified_user_email error.
To resolve this error, prompt the user to verify the primary email address on their GitHub account. For more information, see Verifying your email address.\n\n\n\nApps/Creating GitHub Apps/Authenticate with a GitHub App/Refresh user access tokensRefreshing user access tokensTo enforce regular token rotation and reduce the impact of a compromised token, you can configure your GitHub App to use user access tokens that expire.In this articleAbout user access tokens that expireConfiguring your app to use user access tokens that expireRefreshing a user access token with a refresh tokenAbout user access tokens that expire
Note

User access tokens that expire are currently an optional feature and are subject to change. For more information, see Expiring user-to-server access tokens for GitHub Apps.

To enforce regular token rotation and reduce the impact of a compromised token, you can configure your GitHub App to use user access tokens that expire. If your app uses user access tokens that expire, then you will receive a refresh token when you generate a user access token. The user access token expires after eight hours, and the refresh token expires after six months. For more information, see Generating a user access token for a GitHub App.
You can use the refresh token to generate a new user access token and a new refresh token. Once you use a refresh token, that refresh token and the old user access token will no longer work.
If your refresh token expires before you use it, you can regenerate a user access token and refresh token by sending users through the web application flow or device flow. For more information, see Generating a user access token for a GitHub App.
Configuring your app to use user access tokens that expire
When you create your app, expiration of user access tokens is enabled unless you opt out. For more information, see Registering a GitHub App. You can also configure this setting after your app has been created.


In the upper-right corner of any page on GitHub, click your profile photo.


Navigate to your account settings.

For an app owned by a personal account, click Settings.
For an app owned by an organization:

Click Your organizations.
To the right of the organization, click Settings.





In the left sidebar, click  Developer settings.


In the left sidebar, click GitHub Apps.


Next to the GitHub App that you want to modify, click Edit.


In the GitHub Apps settings sidebar, click Optional Features.


Next to "User-to-server token expiration", click Opt-in or Opt-out. This setting may take a couple of seconds to apply.
GitHub recommends that you opt in to this feature for improved security.


If you opt into user access tokens that expire after you have already generated user access tokens, the previously generated user access tokens will not expire. You can delete these tokens by using the DELETE /applications/CLIENT_ID/token endpoint. For more information, see REST API endpoints for OAuth authorizations.
Refreshing a user access token with a refresh token


Make a POST request to this URL, along with the following query parameters: https://github.com/login/oauth/access_token






























Query parameterTypeDescriptionclient_idstringRequired. The client ID for your GitHub App. The client ID is different from the app ID. You can find the client ID on the settings page for your app.client_secretstringRequired unless the user access token was generated using the device flow. The client secret for your GitHub App.grant_typestringRequired. The value must be "refresh_token".refresh_tokenstringRequired. The refresh token that you received when you generated a user access token.


GitHub will give a response that includes the following parameters:








































Response parameterTypeDescriptionaccess_tokenstringThe user access token. The token starts with ghu_.expires_inintegerThe number of seconds until access_token expires. If you disabled expiration of user access tokens, this parameter will be omitted. The value will always be 28800 (8 hours).refresh_tokenstringThe refresh token. If you disabled expiration of user access tokens, this parameter will be omitted. The token starts with ghr_.refresh_token_expires_inintegerThe number of seconds until refresh_token expires. If you disabled expiration of user access tokens, this parameter will be omitted. The value will always be 15897600 (6 months).scopestringThe scopes that the token has. This value will always be an empty string. Unlike a traditional OAuth token, the user access token is limited to the permissions that both your app and the user have.token_typestringThe type of token. The value will always be bearer.\n\n\n\nApps/Creating GitHub Apps/Authenticate with a GitHub App/Authenticate in Actions workflowMaking authenticated API requests with a GitHub App in a GitHub Actions workflowYou can use an installation access token from a GitHub App to make authenticated API requests in a GitHub Actions workflow. You can also pass the token to a custom action to enable the action to make authenticated API requests.In this articleAbout GitHub Actions authenticationAuthenticating with a GitHub AppAbout GitHub Actions authentication
If you need to make authenticated API requests in a GitHub Actions workflow or need to execute a custom action that requires a token, you should use the built-in GITHUB_TOKEN if possible. However, the GITHUB_TOKEN can only access resources within the workflow's repository. If you need to access additional resources, such as resources in an organization or in another repository, you can use a GitHub App. For more information about why you might use a GitHub App over a personal access token, see About creating GitHub Apps.
Authenticating with a GitHub App
In order to use a GitHub App to make authenticated API requests, you must register a GitHub App, store your app's credentials, and install your app. Once this is done, you can use your app to create an installation access token, which can be used to make authenticated API requests in a GitHub Actions workflow. You can also pass the installation access token to a custom action that requires a token.


Register a GitHub App. Give your GitHub App registration the necessary permissions to access the desired resources. For more information, see Registering a GitHub App and Choosing permissions for a GitHub App.


Store the app ID of your GitHub App as a GitHub Actions configuration variable. You can find the app ID on the settings page for your app. The app ID is different from the client ID. For more information about navigating to the settings page for your GitHub App, see Modifying a GitHub App registration. For more information about storing configuration variables, see Store information in variables.


Generate a private key for your app. Store the contents of the resulting file as a secret. (Store the entire contents of the file, including -----BEGIN RSA PRIVATE KEY----- and -----END RSA PRIVATE KEY-----.) For more information, see Managing private keys for GitHub Apps. For more information about storing secrets, see Using secrets in GitHub Actions.


Install the GitHub App on your user account or organization and grant it access to any repositories that you want your workflow to access. For more information, see Installing your own GitHub App.


In your GitHub Actions workflow, create an installation access token, which you can use to make API requests.
To do this, you can use a GitHub-owned action as demonstrated in the following example. If you prefer to not use this action, you can fork and modify the actions/create-github-app-token action, or you can write a script to make your workflow create an installation token manually. For more information, see Authenticating as a GitHub App installation.
The following example workflow uses the actions/create-github-app-token action to generate an installation access token. Then, the workflow uses the token to make an API request via the GitHub CLI.
In the following workflow, replace APP_ID with the name of the configuration variable where you stored your app ID. Replace APP_PRIVATE_KEY with the name of the secret where you stored your app private key.


YAMLon:
  workflow_dispatch:
jobs:
  demo_app_authentication:
    runs-on: ubuntu-latest
    steps:
      - name: Generate a token
        id: generate-token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ vars.APP_ID }}
          private-key: ${{ secrets.APP_PRIVATE_KEY }}

      - name: Use the token
        env:
          GH_TOKEN: ${{ steps.generate-token.outputs.token }}
        run: |
          gh api octocat
on:
  workflow_dispatch:
jobs:
  demo_app_authentication:
    runs-on: ubuntu-latest
    steps:
      - name: Generate a token
        id: generate-token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ vars.APP_ID }}
          private-key: ${{ secrets.APP_PRIVATE_KEY }}

      - name: Use the token
        env:
          GH_TOKEN: ${{ steps.generate-token.outputs.token }}
        run: |
          gh api octocat\n\n\n\nApps/Creating GitHub Apps/Writing code for a GitHub App/About writing GitHub App codeAbout writing code for a GitHub AppYou need to write code to add functionality to your GitHub App.In this articlePrerequisitesWriting code for a GitHub AppNext stepsPrerequisites
Before you write code for a GitHub App, you should register a GitHub App. When you register a GitHub App, you select permissions for the app. These permissions dictate what the GitHub App can do. When you register an app, you also specify other settings, including which webhook events your GitHub App should receive. You can always change the settings for your GitHub App registration. For more information, see Registering a GitHub App and Modifying a GitHub App registration.
If you want your GitHub App to access repository and/or organization data, you need to install your GitHub App. For more information, see Installing your own GitHub App.
Writing code for a GitHub App
In order for your GitHub App to do something, you need to write code to add functionality to your GitHub App.
For tutorials about how to write code for a GitHub App, see:

Quickstart for building GitHub Apps
Building a GitHub App that responds to webhook events
Building a "Login with GitHub" button with a GitHub App
Building a CLI with a GitHub App

You can use the credentials from your GitHub App registration to make authenticated requests to GitHub's APIs. For more information, see About authentication with a GitHub App.
During development, you will likely use your personal computer or codespace to run your GitHub App. You may need to make some modifications to your GitHub App registration during development:


If your app receives webhooks, you may want to use a webhook proxy URL to forward webhooks from GitHub to your computer or codespace. You will need to update the "Webhook URL" setting in your GitHub App registration to use your webhook proxy URL. For an example, see Building a GitHub App that responds to webhook events.


If your app uses the web application flow to authorize a user, you may want to update the "Callback URL" setting in your GitHub App registration to use a local callback URL. For an example, see Building a "Login with GitHub" button with a GitHub App.


Next steps
Once you write the code for your GitHub App, you should ensure that it follows best practices. If necessary, remember to update your GitHub App registration. If your GitHub App needs to run on a server instead of a user's device, deploy your app to your server. Finally, you can share your GitHub App with other users and organizations.
Follow best practices
Before deploying your GitHub App, make sure you follow best practices. For example, make sure that your GitHub App's credentials are secure. For more information, see Best practices for creating a GitHub App.
Update your GitHub App registration
If you changed the GitHub App registration for development, make sure you update the registration to use production-ready values. For example, if you used a webhook proxy URL for development, you should update the "Webhook URL" field to use the URL where you want your GitHub App to receive webhooks during production.
Deploy your GitHub App
Once you have written the code for your GitHub App, your code needs to run somewhere. If your app is a website or web app, you might host your app on a server like Azure App Service. If your app is a client-side app, it might run on a user's device.
Share your GitHub App
If you want to share your GitHub App with other users and organizations, you should make your GitHub App public. To make your GitHub App more discoverable, you can list it on GitHub Marketplace. For more information, see Sharing your GitHub App.\n\n\n\nApps/Creating GitHub Apps/Writing code for a GitHub App/QuickstartQuickstart for building GitHub AppsQuickly build a GitHub App that comments on pull requests.In this articleIntroductionPrerequisitesStep 1: Clone the app codeStep 2: Get a webhook proxy URLStep 3: Register a GitHub AppStep 4: Store identifying information and credentialsStep 5: Install your appStep 6: Start your serverStep 7: Test your appNext stepsIntroduction
GitHub Apps let you automate processes or integrate other platforms with GitHub. For more info, see About creating GitHub Apps.
This quickstart describes how to quickly create a GitHub App. When a pull request is opened in a repository that the app was granted access to, the app will add a comment to the pull request.
This quickstart uses pre-written code to help you get started quickly. For a more detailed tutorial that helps you write the code, see Building a GitHub App that responds to webhook events.
Prerequisites
Your computer or codespace should use Node.js version 12 or greater. For more information, see Node.js.
Step 1: Clone the app code
To help you get started quickly, we wrote code that you can use. If you want to learn how to write the code yourself, see Building a GitHub App that responds to webhook events.

Clone the github/github-app-js-sample repository. For more information, see Cloning a repository. You may use a local clone or GitHub Codespaces.
In a terminal window, navigate to the directory where your clone is stored.
Run npm install to install the dependencies.

Step 2: Get a webhook proxy URL
In order to develop your app locally, you can use a webhook proxy URL to forward webhooks from GitHub to your computer or codespace. This quickstart uses Smee.io to provide a webhook proxy URL and forward webhooks.

In your browser, navigate to https://smee.io/.
Click Start a new channel.
Copy the full URL under "Webhook Proxy URL". You will use this URL in a later step.

Step 3: Register a GitHub App
The following steps will guide you through configuring the app settings that are required for this quickstart. For more information about the settings, see Registering a GitHub App.

In the upper-right corner of any page on GitHub, click your profile photo.
Navigate to your account settings.

For an app owned by a personal account, click Settings.
For an app owned by an organization:

Click Your organizations.
To the right of the organization, click Settings.




In the left sidebar, click  Developer settings.
In the left sidebar, click GitHub Apps.
Click New GitHub App.
Under "GitHub App name", enter a name for your app. For example, USERNAME-quickstart-app where USERNAME is your GitHub username.
Under "Homepage URL", enter https://github.com/github/github-app-js-sample#readme.
Skip the "Identifying and authorizing users" and "Post installation" sections for this quickstart. For more information about these settings, see Registering a GitHub App.
Make sure that Active is selected under "Webhooks."
Under "Webhook URL", enter your webhook proxy URL from earlier. For more information, see Step 2: Get a webhook proxy URL.
Under "Webhook secret", enter a random string. You will use this string later.
Under "Repository permissions", next to "Pull requests," select Read & write.
Under "Subscribe to events", select Pull request.
Under "Where can this GitHub App be installed?", select Only on this account.
Click Create GitHub App.

Step 4: Store identifying information and credentials
In this quickstart, you will store your app's credentials and identifying information as environment variables in a .env file. When you deploy your app, you will want to change how you store the credentials. For more information, see Deploy your app.
Make sure that you are on a secure machine before performing these steps since you will store your credentials locally.
Create a .env file
Your cloned repository includes .env in the .gitignore file. This will prevent you from accidentally committing your app's credentials. For more information about .gitignore files, see Ignoring files.


Navigate to the directory where your clone of github/github-app-js-sample is stored.


Create a file called .env at the top level of this directory.


Add the following contents to your .env file. You will update the values in a later step.
TextAPP_ID="YOUR_APP_ID"
WEBHOOK_SECRET="YOUR_WEBHOOK_SECRET"
PRIVATE_KEY_PATH="YOUR_PRIVATE_KEY_PATH"
APP_ID="YOUR_APP_ID"
WEBHOOK_SECRET="YOUR_WEBHOOK_SECRET"
PRIVATE_KEY_PATH="YOUR_PRIVATE_KEY_PATH"



Navigate to your app settings
If you navigated away from your app settings after creating your app, navigate to the settings page for your app:

In the upper-right corner of any page on GitHub, click your profile photo.
Navigate to your account settings.

For an app owned by a personal account, click Settings.
For an app owned by an organization:

Click Your organizations.
To the right of the organization, click Settings.




In the left sidebar, click  Developer settings.
In the left sidebar, click GitHub Apps.
Next to your app's name, click Edit.

Get your app credentials and identifying information

On your app's settings page, next to "App ID", find the app ID for your app.
In your .env file, replace YOUR_APP_ID with the app ID of your app.
On your app's settings page, under "Private keys", click Generate a private key. You will see a private key in PEM format downloaded to your computer. For more information, see Managing private keys for GitHub Apps.
If you are using a codespace, move the downloaded PEM file into your codespace so that your codespace can access the file.
In your .env file, replace YOUR_PRIVATE_KEY_PATH with the full path to your private key, including the .pem extension.
In your .env file, replace YOUR_WEBHOOK_SECRET with the webhook secret for your app. If you have forgotten your webhook secret, under "Webhook secret (optional)", click Change secret. Enter a new secret, then click Save changes.

Step 5: Install your app
In order for your app to leave a comment on pull requests in a repository, it must be installed on the account that owns the repository and granted access to that repository. Since your app is private, it can only be installed on the account that owns the app.

In the account that owns the app you created, create a new repository to install the app on. For more information, see Creating a new repository.
If you navigated away from your app settings after creating your app, navigate to the settings page for your app. For more information, see Navigate to your app settings.
Click Public page.
Click Install.
Select Only select repositories.
Select the Select repositories dropdown menu and click the repository that you chose at the start of this section.
Click Install.

Step 6: Start your server
For testing, you will use your computer or codespace as a server. Your app will only be active when your server is running.


In a terminal window, navigate to the directory where your clone of github/github-app-js-sample is stored.


To receive forwarded webhooks from Smee.io, run npx smee -u WEBHOOK_PROXY_URL -t http://localhost:3000/api/webhook. Replace WEBHOOK_PROXY_URL with your webhook proxy URL. If you forgot your URL, you can find it in the "webhook URL" field on your app's settings page.
You should see output that looks like this, where WEBHOOK_PROXY_URL is your webhook proxy URL:
Forwarding WEBHOOK_PROXY_URL to http://localhost:3000/api/webhook
Connected WEBHOOK_PROXY_URL



In a second terminal window, navigate to the directory where your clone of github/github-app-js-sample is stored.


Run npm run server. Your terminal should say, Server is listening for events at: http://localhost:3000/api/webhook.


Step 7: Test your app
Now that your server is running and receiving forwarded webhooks events, test your app by opening a pull request.

Open a pull request on the repository you created in Step 5: Install your app. For more information, see Creating a pull request.
Navigate to your webhook proxy URL on smee.io. You should see a pull_request event. This indicates that GitHub successfully sent a pull request event when you created a pull request.
In the terminal where you ran npm run server, you should see something like "Received a pull request event for #1" where the integer after the # is the number of the pull request that you opened.
In the timeline of your pull request, you should see a comment from your app. The comment uses the contents of the message.md file in your cloned repository.
In both terminal windows, enter Ctrl+C to stop your server and stop listening for forwarded webhooks.

Next steps
Now that you have an app, you might want to expand your app's code, deploy your app, and make your app public.
Modify the app code
Fork the github/github-app-js-sample repository and modify the code to respond to different webhook events or to make different API requests. For more information about the code, see Building a GitHub App that responds to webhook events.
Remember to update your app's permissions if your app needs additional permissions for the API requests that you want to make or the webhook events you want to receive. For more information, see Choosing permissions for a GitHub App.
Deploy your app
This tutorial used your computer or codespace as a server. Once the app is ready for production use, you should deploy your app to a dedicated server. For example, you can use Azure App Service.
Once you have a server, update the webhook URL in your app settings. You should not use Smee.io to forward your webhooks in production.
You will also need to update the port and host constants in the code. For more information, see Building a GitHub App that responds to webhook events.
You should never publicize your app's private key or webhook secret. This tutorial stored your app's credentials in a gitignored .env file. When you deploy your app, you should choose a secure way to store the credentials and update your code to get the value accordingly. For example, you can store the credentials in an environment variable on the server where your app is deployed. You can also use a secret management service like Azure Key Vault.
Share your app
If you want to share your app with other users and organizations, make your app public. For more information, see Making a GitHub App public or private.
Follow best practices
You should aim to follow best practices with your GitHub App. For more information, see Best practices for creating a GitHub App.\n\n\n\nApps/Creating GitHub Apps/Writing code for a GitHub App/Respond to webhooksBuilding a GitHub App that responds to webhook eventsLearn how to build a GitHub App that makes an API request in response to a webhook event.In this articleIntroductionPrerequisitesSetupWrite code for your appTestingNext stepsIntroduction
This tutorial demonstrates how to write code to create a GitHub App that makes an API request in response to a webhook event. Specifically, when a pull request is opened in a repository that the app was granted access to, the app will receive a pull request webhook event. Then, the app will use GitHub's API to add a comment to the pull request.
In this tutorial, you will use your computer or codespace as a server while you develop your app. Once the app is ready for production use, you should deploy your app to a dedicated server.
This tutorial uses JavaScript, but you can use any programming language that you can run on your server.
About webhooks
When you register a GitHub App, you can specify a webhook URL and subscribe to webhook events. When activity on GitHub triggers an event that your app is subscribed to, GitHub will send a webhook event to your app's webhook URL.
For example, you can subscribe your GitHub App to the pull request webhook event. When a pull request is opened in a repository that the app was granted access to, GitHub will send a pull request webhook event to your app's webhook URL. If multiple actions can trigger the event, the event payload will include an action field to indicate what type of action triggered the event. In this example, the value of action would be opened since the event was triggered because a pull request was opened.
If your app is running on a server that is listening for these webhook events, then your app can take an action when it receives a webhook event. For example, your app can use the GitHub API to post a comment to the pull request when it receives a pull request webhook event.
For more information, see Using webhooks with GitHub Apps. For information about the possible webhook events and actions, see Webhook events and payloads.
Prerequisites
This tutorial requires your computer or codespace to run Node.js version 20 or greater and npm version 6.12.0 or greater. For more information, see Node.js.
This tutorial assumes you have a basic understanding of JavaScript and ES6 syntax.
Setup
The following sections will lead you through setting up the following components:

A repository to store the code for your app
A way to receive webhooks locally
A GitHub App registration that is subscribed to "pull request" webhook events, has permission to add comments to pull requests, and uses a webhook URL that you can receive locally

Create a repository to store code for your app

Create a repository to store the code for your app. For more information, see Creating a new repository.
Clone your repository from the previous step. For more information, see Cloning a repository. You may use a local clone or GitHub Codespaces.
In a terminal, navigate to the directory where your clone is stored.
If the directory doesn't already include a .gitignore file, add a .gitignore file. You will add content to this file later. For more information about .gitignore files, see Ignoring files.

You will add more code to this repository in later steps.
Get a webhook proxy URL
In order to develop your app locally, you can use a webhook proxy URL to forward webhooks from GitHub to your computer or codespace. This tutorial uses Smee.io to provide a webhook proxy URL and forward webhooks.

In your browser, navigate to https://smee.io/.
Click Start a new channel.
Copy the full URL under "Webhook Proxy URL". You will use this URL in a later step.

Register a GitHub App
For this tutorial, you must have a GitHub App registration that:

Has webhooks active
Uses a webhook URL that you can receive locally
Has the "Pull request" repository permission
Subscribes to the "Pull request" webhook event

The following steps will guide you through registering a GitHub App with these settings. For more information about GitHub App settings, see Registering a GitHub App.


In the upper-right corner of any page on GitHub, click your profile photo.


Navigate to your account settings.

For an app owned by a personal account, click Settings.
For an app owned by an organization:

Click Your organizations.
To the right of the organization, click Settings.





In the left sidebar, click  Developer settings.


In the left sidebar, click GitHub Apps.


Click New GitHub App.


Under "GitHub App name", enter a name for your app. For example, USERNAME-webhook-test-app where USERNAME is your GitHub username.


Under "Homepage URL", enter a URL for your app. For example, you can use the URL of the repository that you created to store the code for your app.


Skip the "Identifying and authorizing users" and "Post installation" sections for this tutorial. For more information about these settings, see Registering a GitHub App.


Make sure that Active is selected under "Webhooks."


Under "Webhook URL", enter your webhook proxy URL from earlier. For more information, see Get a webhook proxy URL.


Under "Webhook secret", enter a random string. You will use this string later.


Under "Repository permissions", next to "Pull requests," select Read & write.


Under "Subscribe to events", select Pull request.


Under "Where can this GitHub App be installed?", select Only on this account. You can change this later if you want to publish your app.


Click Create GitHub App.


Write code for your app
The following sections will lead you through writing code to make your app respond to webhook events.
Install dependencies
This tutorial uses GitHub's octokit module to handle webhook events and make API requests. For more information about Octokit.js, see Scripting with the REST API and JavaScript and the Octokit.js README.
This tutorial uses the dotenv module to read information about your app from a .env file. For more information, see dotenv.
This tutorial uses Smee.io to forward webhooks from GitHub to your local server. For more information, see smee-client.

In a terminal, navigate to the directory where your clone is stored.
Run npm init --yes to create a package.json file using the npm defaults.
Run npm install octokit.
Run npm install dotenv.
Run npm install smee-client --save-dev. Since you will only use Smee.io to forward webhooks while you are developing your app, this is a dev dependency.
Add node_modules to your .gitignore file.

Store your app's identifying information and credentials
This tutorial will show you how to store your app's credentials and identifying information as environment variables in a .env file. When you deploy your app, you will want to change how you store the credentials. For more information, see Deploy your app.
Make sure that you are on a secure machine before performing these steps since you will store your credentials locally.


In your terminal, navigate to the directory where your clone is stored.


Create a file called .env at the top level of this directory.


Add .env to your .gitignore file. This will prevent you from accidentally committing your app's credentials.


Add the following contents to your .env file. You will update the values in a later step.
TextAPP_ID="YOUR_APP_ID"
WEBHOOK_SECRET="YOUR_WEBHOOK_SECRET"
PRIVATE_KEY_PATH="YOUR_PRIVATE_KEY_PATH"
APP_ID="YOUR_APP_ID"
WEBHOOK_SECRET="YOUR_WEBHOOK_SECRET"
PRIVATE_KEY_PATH="YOUR_PRIVATE_KEY_PATH"



Navigate to the settings page for your app:


In the upper-right corner of any page on GitHub, click your profile photo.


Navigate to your account settings.

For an app owned by a personal account, click Settings.
For an app owned by an organization:

Click Your organizations.
To the right of the organization, click Settings.





In the left sidebar, click  Developer settings.


In the left sidebar, click GitHub Apps.


Next to your app's name, click Edit.




On your app's settings page, next to "App ID", find the app ID for your app.


In your .env file, replace YOUR_APP_ID with the app ID of your app.


On your app's settings page, under "Private keys", click Generate a private key. You will see a private key in PEM format downloaded to your computer. For more information, see Managing private keys for GitHub Apps.


If you are using a codespace, move the downloaded PEM file into your codespace so that your codespace can access the file.


In your .env file, replace YOUR_PRIVATE_KEY_PATH with the full path to your private key, including the .pem extension.


In your .env file, replace YOUR_WEBHOOK_SECRET with the webhook secret for your app. If you have forgotten your webhook secret, under "Webhook secret (optional)", click Change secret. Enter a new secret, then click Save changes.


Add code to respond to webhook events
At the top level of the directory where your clone is stored, create a JavaScript file to hold the code for your app. This tutorial will name the file app.js.
Add the following code to app.js. The code includes annotations that explain each part.
JavaScriptBesideInline// These are the dependencies for this file.
//
// You installed the `dotenv` and `octokit` modules earlier. The `@octokit/webhooks` is a dependency of the `octokit` module, so you don't need to install it separately. The `fs` and `http` dependencies are built-in Node.js modules.
import dotenv from "dotenv";
import {App} from "octokit";
import {createNodeMiddleware} from "@octokit/webhooks";
import fs from "fs";
import http from "http";

// This reads your `.env` file and adds the variables from that file to the `process.env` object in Node.js.
dotenv.config();

// This assigns the values of your environment variables to local variables.
const appId = process.env.APP_ID;
const webhookSecret = process.env.WEBHOOK_SECRET;
const privateKeyPath = process.env.PRIVATE_KEY_PATH;

// This reads the contents of your private key file.
const privateKey = fs.readFileSync(privateKeyPath, "utf8");

// This creates a new instance of the Octokit App class.
const app = new App({
  appId: appId,
  privateKey: privateKey,
  webhooks: {
    secret: webhookSecret
  },
});

// This defines the message that your app will post to pull requests.
const messageForNewPRs = "Thanks for opening a new PR! Please follow our contributing guidelines to make your PR easier to review.";

// This adds an event handler that your code will call later. When this event handler is called, it will log the event to the console. Then, it will use GitHub's REST API to add a comment to the pull request that triggered the event.
async function handlePullRequestOpened({octokit, payload}) {
  console.log(`Received a pull request event for #${payload.pull_request.number}`);

  try {
    await octokit.request("POST /repos/{owner}/{repo}/issues/{issue_number}/comments", {
      owner: payload.repository.owner.login,
      repo: payload.repository.name,
      issue_number: payload.pull_request.number,
      body: messageForNewPRs,
      headers: {
        "x-github-api-version": "2022-11-28",
      },
    });
  } catch (error) {
    if (error.response) {
      console.error(`Error! Status: ${error.response.status}. Message: ${error.response.data.message}`)
    }
    console.error(error)
  }
};

// This sets up a webhook event listener. When your app receives a webhook event from GitHub with a `X-GitHub-Event` header value of `pull_request` and an `action` payload value of `opened`, it calls the `handlePullRequestOpened` event handler that is defined above.
app.webhooks.on("pull_request.opened", handlePullRequestOpened);

// This logs any errors that occur.
app.webhooks.onError((error) => {
  if (error.name === "AggregateError") {
    console.error(`Error processing request: ${error.event}`);
  } else {
    console.error(error);
  }
});

// This determines where your server will listen.
//
// For local development, your server will listen to port 3000 on `localhost`. When you deploy your app, you will change these values. For more information, see [Deploy your app](#deploy-your-app).
const port = 3000;
const host = 'localhost';
const path = "/api/webhook";
const localWebhookUrl = `http://${host}:${port}${path}`;

// This sets up a middleware function to handle incoming webhook events.
//
// Octokit's `createNodeMiddleware` function takes care of generating this middleware function for you. The resulting middleware function will:
//
//    - Check the signature of the incoming webhook event to make sure that it matches your webhook secret. This verifies that the incoming webhook event is a valid GitHub event.
//    - Parse the webhook event payload and identify the type of event.
//    - Trigger the corresponding webhook event handler.
const middleware = createNodeMiddleware(app.webhooks, {path});

// This creates a Node.js server that listens for incoming HTTP requests (including webhook payloads from GitHub) on the specified port. When the server receives a request, it executes the `middleware` function that you defined earlier. Once the server is running, it logs messages to the console to indicate that it is listening.
http.createServer(middleware).listen(port, () => {
  console.log(`Server is listening for events at: ${localWebhookUrl}`);
  console.log('Press Ctrl + C to quit.')
});
import dotenv from "dotenv";
import {App} from "octokit";
import {createNodeMiddleware} from "@octokit/webhooks";
import fs from "fs";
import http from "http";These are the dependencies for this file.
You installed the dotenv and octokit modules earlier. The @octokit/webhooks is a dependency of the octokit module, so you don't need to install it separately. The fs and http dependencies are built-in Node.js modules.dotenv.config();This reads your .env file and adds the variables from that file to the process.env object in Node.js.const appId = process.env.APP_ID;
const webhookSecret = process.env.WEBHOOK_SECRET;
const privateKeyPath = process.env.PRIVATE_KEY_PATH;This assigns the values of your environment variables to local variables.const privateKey = fs.readFileSync(privateKeyPath, "utf8");This reads the contents of your private key file.const app = new App({
  appId: appId,
  privateKey: privateKey,
  webhooks: {
    secret: webhookSecret
  },
});This creates a new instance of the Octokit App class.const messageForNewPRs = "Thanks for opening a new PR! Please follow our contributing guidelines to make your PR easier to review.";This defines the message that your app will post to pull requests.async function handlePullRequestOpened({octokit, payload}) {
  console.log(`Received a pull request event for #${payload.pull_request.number}`);
  try {
    await octokit.request("POST /repos/{owner}/{repo}/issues/{issue_number}/comments", {
      owner: payload.repository.owner.login,
      repo: payload.repository.name,
      issue_number: payload.pull_request.number,
      body: messageForNewPRs,
      headers: {
        "x-github-api-version": "2022-11-28",
      },
    });
  } catch (error) {
    if (error.response) {
      console.error(`Error! Status: ${error.response.status}. Message: ${error.response.data.message}`)
    }
    console.error(error)
  }
};This adds an event handler that your code will call later. When this event handler is called, it will log the event to the console. Then, it will use GitHub's REST API to add a comment to the pull request that triggered the event.app.webhooks.on("pull_request.opened", handlePullRequestOpened);This sets up a webhook event listener. When your app receives a webhook event from GitHub with a X-GitHub-Event header value of pull_request and an action payload value of opened, it calls the handlePullRequestOpened event handler that is defined above.app.webhooks.onError((error) => {
  if (error.name === "AggregateError") {
    console.error(`Error processing request: ${error.event}`);
  } else {
    console.error(error);
  }
});This logs any errors that occur.const port = 3000;
const host = 'localhost';
const path = "/api/webhook";
const localWebhookUrl = `http://${host}:${port}${path}`;This determines where your server will listen.
For local development, your server will listen to port 3000 on localhost. When you deploy your app, you will change these values. For more information, see Deploy your app.const middleware = createNodeMiddleware(app.webhooks, {path});This sets up a middleware function to handle incoming webhook events.
Octokit's createNodeMiddleware function takes care of generating this middleware function for you. The resulting middleware function will:

Check the signature of the incoming webhook event to make sure that it matches your webhook secret. This verifies that the incoming webhook event is a valid GitHub event.
Parse the webhook event payload and identify the type of event.
Trigger the corresponding webhook event handler.
http.createServer(middleware).listen(port, () => {
  console.log(`Server is listening for events at: ${localWebhookUrl}`);
  console.log('Press Ctrl + C to quit.')
});This creates a Node.js server that listens for incoming HTTP requests (including webhook payloads from GitHub) on the specified port. When the server receives a request, it executes the middleware function that you defined earlier. Once the server is running, it logs messages to the console to indicate that it is listening.// These are the dependencies for this file.
//
// You installed the `dotenv` and `octokit` modules earlier. The `@octokit/webhooks` is a dependency of the `octokit` module, so you don't need to install it separately. The `fs` and `http` dependencies are built-in Node.js modules.
import dotenv from "dotenv";
import {App} from "octokit";
import {createNodeMiddleware} from "@octokit/webhooks";
import fs from "fs";
import http from "http";

// This reads your `.env` file and adds the variables from that file to the `process.env` object in Node.js.
dotenv.config();

// This assigns the values of your environment variables to local variables.
const appId = process.env.APP_ID;
const webhookSecret = process.env.WEBHOOK_SECRET;
const privateKeyPath = process.env.PRIVATE_KEY_PATH;

// This reads the contents of your private key file.
const privateKey = fs.readFileSync(privateKeyPath, "utf8");

// This creates a new instance of the Octokit App class.
const app = new App({
  appId: appId,
  privateKey: privateKey,
  webhooks: {
    secret: webhookSecret
  },
});

// This defines the message that your app will post to pull requests.
const messageForNewPRs = "Thanks for opening a new PR! Please follow our contributing guidelines to make your PR easier to review.";

// This adds an event handler that your code will call later. When this event handler is called, it will log the event to the console. Then, it will use GitHub's REST API to add a comment to the pull request that triggered the event.
async function handlePullRequestOpened({octokit, payload}) {
  console.log(`Received a pull request event for #${payload.pull_request.number}`);

  try {
    await octokit.request("POST /repos/{owner}/{repo}/issues/{issue_number}/comments", {
      owner: payload.repository.owner.login,
      repo: payload.repository.name,
      issue_number: payload.pull_request.number,
      body: messageForNewPRs,
      headers: {
        "x-github-api-version": "2022-11-28",
      },
    });
  } catch (error) {
    if (error.response) {
      console.error(`Error! Status: ${error.response.status}. Message: ${error.response.data.message}`)
    }
    console.error(error)
  }
};

// This sets up a webhook event listener. When your app receives a webhook event from GitHub with a `X-GitHub-Event` header value of `pull_request` and an `action` payload value of `opened`, it calls the `handlePullRequestOpened` event handler that is defined above.
app.webhooks.on("pull_request.opened", handlePullRequestOpened);

// This logs any errors that occur.
app.webhooks.onError((error) => {
  if (error.name === "AggregateError") {
    console.error(`Error processing request: ${error.event}`);
  } else {
    console.error(error);
  }
});

// This determines where your server will listen.
//
// For local development, your server will listen to port 3000 on `localhost`. When you deploy your app, you will change these values. For more information, see [Deploy your app](#deploy-your-app).
const port = 3000;
const host = 'localhost';
const path = "/api/webhook";
const localWebhookUrl = `http://${host}:${port}${path}`;

// This sets up a middleware function to handle incoming webhook events.
//
// Octokit's `createNodeMiddleware` function takes care of generating this middleware function for you. The resulting middleware function will:
//
//    - Check the signature of the incoming webhook event to make sure that it matches your webhook secret. This verifies that the incoming webhook event is a valid GitHub event.
//    - Parse the webhook event payload and identify the type of event.
//    - Trigger the corresponding webhook event handler.
const middleware = createNodeMiddleware(app.webhooks, {path});

// This creates a Node.js server that listens for incoming HTTP requests (including webhook payloads from GitHub) on the specified port. When the server receives a request, it executes the `middleware` function that you defined earlier. Once the server is running, it logs messages to the console to indicate that it is listening.
http.createServer(middleware).listen(port, () => {
  console.log(`Server is listening for events at: ${localWebhookUrl}`);
  console.log('Press Ctrl + C to quit.')
});

Add a script to run the code for your app


To the scripts object in your package.json file, add a script called server that runs node app.js. For example:
JSON"scripts": {
  "server": "node app.js"
}
"scripts": {
  "server": "node app.js"
}

If you called the file that holds your app's code something other than app.js, replace app.js with the relative path to the file that holds your app's code.


In your package.json file, add a top level key type with the value module. For example:
   {
    // rest of the JSON object,
    "version": "1.0.0",
    "description": "",
    "type": "module",
    // rest of the JSON object,
  }



Your package.json file should look something like this. The name value and the version numbers under dependencies and devDependencies may differ for you.
  {
  "name": "github-app-webhook-tutorial",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "type": "module",
  "scripts": {
    "server": "node app.js"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "dotenv": "^16.0.3",
    "octokit": "^2.0.14"
  },
  "devDependencies": {
    "smee-client": "^1.2.3"
  }
}

Testing
Follow these steps to test the app that you created above.
Install your app
In order for your app to leave a comment on pull requests in a repository, it must be installed on the account that owns the repository and granted access to that repository. Since your app is private, it can only be installed on the account that owns the app.


In the account that owns the app you created, create a new repository to install the app on. For more information, see Creating a new repository.


Navigate to the settings page for your app:


In the upper-right corner of any page on GitHub, click your profile photo.


Navigate to your account settings.

For an app owned by a personal account, click Settings.
For an app owned by an organization:

Click Your organizations.
To the right of the organization, click Settings.





In the left sidebar, click  Developer settings.


In the left sidebar, click GitHub Apps.


Next to your app's name, click Edit.




Click Public page.


Click Install.


Select Only select repositories.


Select the Select repositories dropdown menu and click the repository that you chose at the start of this section.


Click Install.


Start your server
For testing, you will use your computer or codespace as a server. Your app will only respond to webhooks when your server is running.


In a terminal, navigate to the directory where your app's code is stored.


To receive forwarded webhooks from Smee.io, run npx smee -u WEBHOOK_PROXY_URL -t http://localhost:3000/api/webhook. Replace WEBHOOK_PROXY_URL with your webhook proxy URL from earlier. If you forgot your URL, you can find it in the "webhook URL" field on your app's settings page.
You should see output that looks like this, where WEBHOOK_PROXY_URL is your webhook proxy URL:
Forwarding WEBHOOK_PROXY_URL to http://localhost:3000/api/webhook
Connected WEBHOOK_PROXY_URL



In a second terminal window, navigate to the directory where your app's code is stored.


Run npm run server. Your terminal should say, Server is listening for events at: http://localhost:3000/api/webhook.


Test your app
Now that your server is running and receiving forwarded webhooks events, test your app by opening a pull request on the repository that you selected when you installed your app.


Open a pull request on the repository that you selected when you installed your app. For more information, see Creating a pull request.
Make sure to use the repository that you selected when you installed your app, not the repository where your app's code is stored. For more information, see Install your app.


Navigate to your webhook proxy URL on smee.io. You should see a pull_request event. This indicates that GitHub successfully sent a pull request event when you created a pull request.


In the terminal where you ran npm run server, you should see something like "Received a pull request event for #1" where the integer after the # is the number of the pull request that you opened.


In the timeline of your pull request, you should see a comment from your app.


In both terminal windows, enter Ctrl+C to stop your server and stop listening for forwarded webhooks.


Next steps
Now that you have an app that responds to webhook events, you might want to expand your app's code, deploy your app, and make your app public.
Modify the app code
This tutorial demonstrated how to post a comment on a pull request in when a pull request was opened. You can update the code to respond to different types of webhook events or to do something different in response to the webhook event.
Remember to update your app's permissions if your app needs additional permissions for the API requests that you want to make or the webhook events you want to receive. For more information, see Choosing permissions for a GitHub App.
This tutorial stored all of the code into a single file, but you may want to move functions and components into separate files.
Deploy your app
This tutorial demonstrated how to develop your app locally. When you are ready to deploy your app, you need to make changes to serve your app and keep your app's credential secure. The steps you take depend on the server that you use, but the following sections offer general guidance.
Host your app on a server
This tutorial used your computer or codespace as a server. Once the app is ready for production use, you should deploy your app to a dedicated server. For example, you can use Azure App Service.
Update the webhook URL
Once you have a server that is set up to receive webhook traffic from GitHub, update the webhook URL in your app settings. You should not use Smee.io to forward your webhooks in production.
Update the port and host constants
When you deploy your app, you will want to change the host and port where your server is listening.
For example, you can set a PORT environment variable on your server to indicate the port where your server should listen. You can set a NODE_ENV environment variable on your server to production. Then, you can update the place where your code defines the port and host constants so that your server listens to all available network interfaces (0.0.0.0) instead of the local network interface (localhost) on your deployment port:
JavaScriptconst port = process.env.PORT || 3000;
const host = process.env.NODE_ENV === 'production' ? '0.0.0.0' : 'localhost';
const port = process.env.PORT || 3000;
const host = process.env.NODE_ENV === 'production' ? '0.0.0.0' : 'localhost';

Secure your app's credentials
You should never publicize your app's private key or webhook secret. This tutorial stored your app's credentials in a gitignored .env file. When you deploy your app, you should choose a secure way to store the credentials and update your code to get the value accordingly. For example, you can store the credentials with a secret management service like Azure Key Vault. When your app runs, it can retrieve the credentials and store them in environment variables on the server where your app is deployed.
For more information, see Best practices for creating a GitHub App.
Share your app
If you want to share your app with other users and organizations, make your app public. For more information, see Making a GitHub App public or private.
Follow best practices
You should aim to follow best practices with your GitHub App. For more information, see Best practices for creating a GitHub App.\n\n\n\nApps/Creating GitHub Apps/Writing code for a GitHub App/Build a "Login" buttonBuilding a "Login with GitHub" button with a GitHub AppFollow this tutorial to write Ruby code to generate a user access token via the web application flow for your GitHub App.In this articleIntroductionPrerequisitesInstall dependenciesStore the client ID and client secretAdd code to generate a user access tokenFull code exampleTestingNext stepsIntroduction
This tutorial demonstrates how to build a "Login with GitHub" button for a website. The website will use a GitHub App to generate a user access token via the web application flow. Then, the website uses the user access token to make API requests on behalf of the authenticated user.
This tutorial uses Ruby, but you can use the web application flow with any programming language that is used for web development.
About web application flow and user access tokens
Your app should use a user access token if you want to attribute the app's actions to a user. For more information, see Authenticating with a GitHub App on behalf of a user.
There are two ways to generate a user access token for a GitHub App: web application flow and device flow. If your app has access to a web interface, you should use web application flow. If your app does not have access to a web interface, you should use device flow instead. For more information, see Generating a user access token for a GitHub App and Building a CLI with a GitHub App.
Prerequisites
This tutorial assumes that you have already registered a GitHub App. For more information about registering a GitHub App, see Registering a GitHub App.
Before following this tutorial, you must set a callback URL for your app. This tutorial uses a local Sinatra server with the default URL of http://localhost:4567. For example, to work with the default URL for a local Sinatra application, your callback URL can be http://localhost:4567/github/callback. Once you are ready to deploy your app, you can change the callback URL to use your live server address. For more information about updating the callback URL for your app, see Modifying a GitHub App registration and About the user authorization callback URL.
This tutorial assumes that you have a basic understanding of Ruby and of the Ruby template system, ERB. For more information, see Ruby and ERB.
Install dependencies
This tutorial uses the Ruby gem, Sinatra, to create a web application with Ruby. For more information, see the Sinatra README.
This tutorial uses the Ruby gem, dotenv, to access values stored in a .env file. For more information, see the dotenv README.
To follow this tutorial, you must install the Sinatra and dotenv gems in your Ruby project. For example, you can do this with Bundler:


If you don't already have Bundler installed, run the following command in your terminal:
gem install bundler



If you don't already have a Gemfile for your app, run the following command in your terminal:
bundle init



If you don't already have a Gemfile.lock for your app, run the following command in your terminal:
bundle install



Install the gems by running the following commands in your terminal:
bundle add sinatra

bundle add dotenv



Store the client ID and client secret
This tutorial will show you how to store the client ID and client secret in environment variables and access them with ENV.fetch. When you deploy your app, you will want to change how you store the client ID and client secret. For more information, see Securely store your client secret.


In the upper-right corner of any page on GitHub, click your profile photo.


Navigate to your account settings.

For an app owned by a personal account, click Settings.
For an app owned by an organization:

Click Your organizations.
To the right of the organization, click Settings.





In the left sidebar, click  Developer settings.


In the left sidebar, click GitHub Apps.


Next to the GitHub App that you want to work with, click Edit.


On the app's settings page, find the client ID for your app. You will add it to a .env file in a following step. Note that the client ID is different from the app ID.


On the app's settings page, click Generate a new client secret. You will add the client secret to a .env file in a following step.


Create a file called .env at the same level as your Gemfile.


If your project doesn't already have a .gitignore file, create a .gitignore file at the same level as your Gemfile.


Add .env to your .gitignore file. This will prevent you from accidentally committing your client secret. For more information about .gitignore files, see Ignoring files.


Add the following contents to your .env file. Replace YOUR_CLIENT_ID with the client ID of your app. Replace YOUR_CLIENT_SECRET with the client secret for your app.
CLIENT_ID="YOUR_CLIENT_ID"
CLIENT_SECRET="YOUR_CLIENT_SECRET"



Add code to generate a user access token
To get a user access token, you first need to prompt the user to authorize your app. When a user authorizes your app, they are redirected to the callback URL for your app. The request to the callback URL includes a code query parameter. When your app gets a request to serve that callback URL, you can exchange the code parameter for a user access token.
These steps lead you through writing code to generate a user access token. To skip ahead to the final code, see Full code example.


In the same directory as your .env file, create a Ruby file to hold the code that will generate a user access token. This tutorial will name the file app.rb.


At the top of app.rb, add these dependencies:
Rubyrequire "sinatra"
require "dotenv/load"
require "net/http"
require "json"
require "sinatra"
require "dotenv/load"
require "net/http"
require "json"

The sinatra and dotenv/load dependencies use the gems that you installed earlier. net/http and json are part of the Ruby standard library.


Add the following code to app.rb, to get your app's client ID and client secret from your .env file.
RubyCLIENT_ID = ENV.fetch("CLIENT_ID")
CLIENT_SECRET = ENV.fetch("CLIENT_SECRET")
CLIENT_ID = ENV.fetch("CLIENT_ID")
CLIENT_SECRET = ENV.fetch("CLIENT_SECRET")



Add the following code to app.rb to display a link that will prompt users to authenticate your app.
Rubyget "/" do
  link = '<a href="https://github.com/login/oauth/authorize?client_id=<%= CLIENT_ID %>">Login with GitHub</a>'
  erb link
end
get "/" do
  link = '<a href="https://github.com/login/oauth/authorize?client_id=<%= CLIENT_ID %>">Login with GitHub</a>'
  erb link
end



Add the following code to app.rb to handle requests to your app's callback URL and get the code parameter from the request. Replace CALLBACK_URL with the callback URL for your app, minus the domain. For example, if your callback URL is http://localhost:4567/github/callback, replace CALLBACK_URL with /github/callback.
Rubyget "CALLBACK_URL" do
  code = params["code"]
  render = "Successfully authorized! Got code #{code}."
  erb render
end
get "CALLBACK_URL" do
  code = params["code"]
  render = "Successfully authorized! Got code #{code}."
  erb render
end

Currently, the code just renders a message along with the code parameter. The following steps will expand this code block.


Optionally, check your progress:
app.rb now looks like this, where CALLBACK_URL is the callback URL for your app, minus the domain:
Rubyrequire "sinatra"
require "dotenv/load"
require "net/http"
require "json"

CLIENT_ID = ENV.fetch("CLIENT_ID")
CLIENT_SECRET = ENV.fetch("CLIENT_SECRET")

get "/" do
  link = '<a href="https://github.com/login/oauth/authorize?client_id=<%= CLIENT_ID %>">Login with GitHub</a>'
  erb link
end

get "CALLBACK_URL" do
  code = params["code"]
  render = "Successfully authorized! Got code #{code}."
  erb render
end
require "sinatra"
require "dotenv/load"
require "net/http"
require "json"

CLIENT_ID = ENV.fetch("CLIENT_ID")
CLIENT_SECRET = ENV.fetch("CLIENT_SECRET")

get "/" do
  link = '<a href="https://github.com/login/oauth/authorize?client_id=<%= CLIENT_ID %>">Login with GitHub</a>'
  erb link
end

get "CALLBACK_URL" do
  code = params["code"]
  render = "Successfully authorized! Got code #{code}."
  erb render
end



In your terminal, from the directory where app.rb is stored, run ruby app.rb. A local Sinatra server should start.


In your browser, navigate to http://localhost:4567. You should see a link with the text "Login with GitHub".


Click on the "Login with GitHub" link.
If you have not authorized the app, clicking on the link should take you to https://github.com/login/oauth/authorize?client_id=CLIENT_ID, where CLIENT_ID is the client ID of your app. This is a GitHub page that prompts users to authorize your app. If you click the button to authorize your app, you will go to the callback URL for your app.
If you previously authorized your app and the authorization has not been revoked, you will skip the authorization prompt and go directly to the callback URL instead. You can revoke your previous authorization if you want to see the authorization prompt. For more information, see Reviewing and revoking authorization of GitHub Apps.


The callback URL page, reached by clicking the "Login with GitHub" link and then authorizing the app if prompted to do so, should display the text similar to "Successfully authorized! Got code agc622abb6135be5d1f2."


In your terminal where Sinatra is running, stop the server by entering Ctrl+C.




Replace the content of app.rb with the following code, where CALLBACK_URL is the callback URL for your app, minus the domain.
This code adds logic to exchange the code parameter for a user access token:

The parse_response function parses the response from the GitHub API.
The exchange_code function exchanges the code parameter for a user access token.
The handler for the callback URL request now calls exchange_code to exchange the code parameter for a user access token.
The callback page now shows text to indicate that a token was generated. If the token generation was not successful, the page will indicate that failure.

Rubyrequire "sinatra"
require "dotenv/load"
require "net/http"
require "json"

CLIENT_ID = ENV.fetch("CLIENT_ID")
CLIENT_SECRET = ENV.fetch("CLIENT_SECRET")

def parse_response(response)
  case response
  when Net::HTTPOK
    JSON.parse(response.body)
  else
    puts response
    puts response.body
    {}
  end
end

def exchange_code(code)
  params = {
    "client_id" => CLIENT_ID,
    "client_secret" => CLIENT_SECRET,
    "code" => code
  }
  result = Net::HTTP.post(
    URI("https://github.com/login/oauth/access_token"),
    URI.encode_www_form(params),
    {"Accept" => "application/json"}
  )

  parse_response(result)
end

get "/" do
  link = '<a href="https://github.com/login/oauth/authorize?client_id=<%= CLIENT_ID %>">Login with GitHub</a>'
  erb link
end

get "CALLBACK_URL" do
  code = params["code"]

  token_data = exchange_code(code)

  if token_data.key?("access_token")
    token = token_data["access_token"]

    render = "Successfully authorized! Got code #{code} and exchanged it for a user access token ending in #{token[-9..-1]}."
    erb render
  else
    render = "Authorized, but unable to exchange code #{code} for token."
    erb render
  end
end
require "sinatra"
require "dotenv/load"
require "net/http"
require "json"

CLIENT_ID = ENV.fetch("CLIENT_ID")
CLIENT_SECRET = ENV.fetch("CLIENT_SECRET")

def parse_response(response)
  case response
  when Net::HTTPOK
    JSON.parse(response.body)
  else
    puts response
    puts response.body
    {}
  end
end

def exchange_code(code)
  params = {
    "client_id" => CLIENT_ID,
    "client_secret" => CLIENT_SECRET,
    "code" => code
  }
  result = Net::HTTP.post(
    URI("https://github.com/login/oauth/access_token"),
    URI.encode_www_form(params),
    {"Accept" => "application/json"}
  )

  parse_response(result)
end

get "/" do
  link = '<a href="https://github.com/login/oauth/authorize?client_id=<%= CLIENT_ID %>">Login with GitHub</a>'
  erb link
end

get "CALLBACK_URL" do
  code = params["code"]

  token_data = exchange_code(code)

  if token_data.key?("access_token")
    token = token_data["access_token"]

    render = "Successfully authorized! Got code #{code} and exchanged it for a user access token ending in #{token[-9..-1]}."
    erb render
  else
    render = "Authorized, but unable to exchange code #{code} for token."
    erb render
  end
end



Optionally, check your progress:

In your terminal, from the directory where app.rb is stored, run ruby app.rb. A local Sinatra server should start.
In your browser, navigate to http://localhost:4567. You should see a link with the text "Login with GitHub".
Click on the "Login with GitHub" link.
If prompted to do so, authorize your app.
The callback URL page, reached by clicking the "Login with GitHub" link and then authorizing the app if prompted to do so, should display the text similar to "Successfully authorized! Got code 4acd44861aeda86dacce and exchanged it for a user access token ending in 2zU5kQziE."
In your terminal where Sinatra is running, stop the server by entering Ctrl+C.



Now that you have a user access token, you can use the token to make API requests on behalf of the user. For example:
Add this function to app.rb to get information about the user with the /user REST API endpoint:
Rubydef user_info(token)
  uri = URI("https://api.github.com/user")

  result = Net::HTTP.start(uri.host, uri.port, use_ssl: true) do |http|
    auth = "Bearer #{token}"
    headers = {"Accept" => "application/json", "Content-Type" => "application/json", "Authorization" => auth}

    http.send_request("GET", uri.path, nil, headers)
  end

  parse_response(result)
end
def user_info(token)
  uri = URI("https://api.github.com/user")

  result = Net::HTTP.start(uri.host, uri.port, use_ssl: true) do |http|
    auth = "Bearer #{token}"
    headers = {"Accept" => "application/json", "Content-Type" => "application/json", "Authorization" => auth}

    http.send_request("GET", uri.path, nil, headers)
  end

  parse_response(result)
end

Update the callback handler to call the user_info function and to display the user's name and GitHub login. Remember to replace CALLBACK_URL with the callback URL for your app, minus the domain.
Rubyget "CALLBACK_URL" do
  code = params["code"]

  token_data = exchange_code(code)

  if token_data.key?("access_token")
    token = token_data["access_token"]

    user_info = user_info(token)
    handle = user_info["login"]
    name = user_info["name"]

    render = "Successfully authorized! Welcome, #{name} (#{handle})."
    erb render
  else
    render = "Authorized, but unable to exchange code #{code} for token."
    erb render
  end
end
get "CALLBACK_URL" do
  code = params["code"]

  token_data = exchange_code(code)

  if token_data.key?("access_token")
    token = token_data["access_token"]

    user_info = user_info(token)
    handle = user_info["login"]
    name = user_info["name"]

    render = "Successfully authorized! Welcome, #{name} (#{handle})."
    erb render
  else
    render = "Authorized, but unable to exchange code #{code} for token."
    erb render
  end
end



Check your code against the full code example in the next section. You can test your code by following the steps outlined in the Testing section below the full code example.


Full code example
This is the full code example that was outlined in the previous section.
Replace CALLBACK_URL with the callback URL for your app, minus the domain. For example, if your callback URL is http://localhost:4567/github/callback, replace CALLBACK_URL with /github/callback.
Rubyrequire "sinatra"
require "dotenv/load"
require "net/http"
require "json"

CLIENT_ID = ENV.fetch("CLIENT_ID")
CLIENT_SECRET = ENV.fetch("CLIENT_SECRET")

def parse_response(response)
  case response
  when Net::HTTPOK
    JSON.parse(response.body)
  else
    puts response
    puts response.body
    {}
  end
end

def exchange_code(code)
  params = {
    "client_id" => CLIENT_ID,
    "client_secret" => CLIENT_SECRET,
    "code" => code
  }
  result = Net::HTTP.post(
    URI("https://github.com/login/oauth/access_token"),
    URI.encode_www_form(params),
    {"Accept" => "application/json"}
  )

  parse_response(result)
end

def user_info(token)
  uri = URI("https://api.github.com/user")

  result = Net::HTTP.start(uri.host, uri.port, use_ssl: true) do |http|
    auth = "Bearer #{token}"
    headers = {"Accept" => "application/json", "Content-Type" => "application/json", "Authorization" => auth}

    http.send_request("GET", uri.path, nil, headers)
  end

  parse_response(result)
end

get "/" do
  link = '<a href="https://github.com/login/oauth/authorize?client_id=<%= CLIENT_ID %>">Login with GitHub</a>'
  erb link
end

get "CALLBACK_URL" do
  code = params["code"]

  token_data = exchange_code(code)

  if token_data.key?("access_token")
    token = token_data["access_token"]

    user_info = user_info(token)
    handle = user_info["login"]
    name = user_info["name"]

    render = "Successfully authorized! Welcome, #{name} (#{handle})."
    erb render
  else
    render = "Authorized, but unable to exchange code #{code} for token."
    erb render
  end
end
require "sinatra"
require "dotenv/load"
require "net/http"
require "json"

CLIENT_ID = ENV.fetch("CLIENT_ID")
CLIENT_SECRET = ENV.fetch("CLIENT_SECRET")

def parse_response(response)
  case response
  when Net::HTTPOK
    JSON.parse(response.body)
  else
    puts response
    puts response.body
    {}
  end
end

def exchange_code(code)
  params = {
    "client_id" => CLIENT_ID,
    "client_secret" => CLIENT_SECRET,
    "code" => code
  }
  result = Net::HTTP.post(
    URI("https://github.com/login/oauth/access_token"),
    URI.encode_www_form(params),
    {"Accept" => "application/json"}
  )

  parse_response(result)
end

def user_info(token)
  uri = URI("https://api.github.com/user")

  result = Net::HTTP.start(uri.host, uri.port, use_ssl: true) do |http|
    auth = "Bearer #{token}"
    headers = {"Accept" => "application/json", "Content-Type" => "application/json", "Authorization" => auth}

    http.send_request("GET", uri.path, nil, headers)
  end

  parse_response(result)
end

get "/" do
  link = '<a href="https://github.com/login/oauth/authorize?client_id=<%= CLIENT_ID %>">Login with GitHub</a>'
  erb link
end

get "CALLBACK_URL" do
  code = params["code"]

  token_data = exchange_code(code)

  if token_data.key?("access_token")
    token = token_data["access_token"]

    user_info = user_info(token)
    handle = user_info["login"]
    name = user_info["name"]

    render = "Successfully authorized! Welcome, #{name} (#{handle})."
    erb render
  else
    render = "Authorized, but unable to exchange code #{code} for token."
    erb render
  end
end

Testing
This tutorial assumes that your app code is stored in a file named app.rb and that you are using the default URL for a local Sinatra application, http://localhost:4567.


In your terminal, from the directory where app.rb is stored, run ruby app.rb. A local Sinatra server should start.


In your browser, navigate to http://localhost:4567. You should see a link with the text "Login with GitHub".


Click on the "Login with GitHub" link.
If you have not authorized the app, clicking on the link should take you to https://github.com/login/oauth/authorize?client_id=CLIENT_ID, where CLIENT_ID is the client ID of your app. This is a GitHub page that prompts users to authorize your app. If you click the button to authorize your app, you will go to the callback URL for your app.
If you previously authorized your app and the authorization has not been revoked, you will skip the authorization prompt and go directly to the callback URL instead. You can revoke your previous authorization if you want to see the authorization prompt. For more information, see Reviewing and revoking authorization of GitHub Apps.


The callback URL page, reached by clicking the "Login with GitHub" link and then authorizing the app if prompted to do so, should display the text similar to "Successfully authorized! Welcome, Mona Lisa (octocat)."


In your terminal where Sinatra is running, stop the server by entering Ctrl+C.


Next steps
Securely store your client secret
You should never publicize your app's client secret. This tutorial stored the client secret in a gitignored .env file and accessed the value with ENV.fetch. When you deploy your app, you should choose a secure way to store the client secret and update your code to get the value accordingly.
For example, you can store the secret in an environment variable on the server where your application is deployed. You can also use a secret management service like Azure Key Vault.
Update the callback URL for deployment
This tutorial used a callback URL starting with http://localhost:4567. However, http://localhost:4567 is only available locally to your computer when you start the Sinatra server. Before you deploy your app, you should update the callback URL to use the callback URL that you use in production. For more information about updating the callback URL for your app, see Modifying a GitHub App registration and About the user authorization callback URL.
Handle multiple callback URLs
This tutorial used a single callback URL, but your app can have up to 10 callback URLs. If you want to use multiple callback URLs:

Add the additional callback URLs to your app. For more information about adding callback URLs, see Modifying a GitHub App registration.
When you link to https://github.com/login/oauth/authorize, use the redirect_uri query parameter to redirect users to the desired callback URL. For more information, see Generating a user access token for a GitHub App.
In your app code, handle each callback URL, similar to the code block starting in get "CALLBACK_URL" do.

Specify additional parameters
When you link to https://github.com/login/oauth/authorize, you can pass additional query parameters. For more information, see Generating a user access token for a GitHub App.
Unlike a traditional OAuth token, the user access token does not use scopes so you cannot specify scopes via the scope parameter. Instead, it uses fine-grained permissions. A user access token only has permissions that both the user and the app have.
Adjust the code to meet your app's needs
This tutorial demonstrated how to display information about the authenticated user, but you can adjust this code to take other actions. Remember to update your app's permissions if your app needs additional permissions for the API requests that you want to make. For more information, see Choosing permissions for a GitHub App.
This tutorial stored all of the code into a single file, but you may want to move functions and components into separate files.
Securely store tokens
This tutorial generates a user access token. Unless you opted out of expiration for user access tokens, the user access token will expire after eight hours. You will also receive a refresh token that can regenerate a user access token. For more information, see Refreshing user access tokens.
If you plan on interacting further with GitHub's APIs, you should store the token for future use. If you choose to store the user access token or refresh token, you must store it securely. You should never publicize the token.
For more information, see Best practices for creating a GitHub App.
Follow best practices
You should aim to follow best practices with your GitHub App. For more information, see Best practices for creating a GitHub App.\n\n\n\nApps/Creating GitHub Apps/Writing code for a GitHub App/Build a CLIBuilding a CLI with a GitHub AppFollow this tutorial to write a CLI in Ruby that generates a user access token for a GitHub App via the device flow.In this articleIntroductionPrerequisitesGet the client IDWrite the CLIFull code exampleTestingNext stepsIntroduction
This tutorial demonstrates how to build a command line interface (CLI) backed by a GitHub App, and how to use the device flow to generate a user access token for the app.
The CLI will have three commands:

help: Outputs the usage instructions.
login: Generates a user access token that the app can use to make API requests on behalf of the user.
whoami: Returns information about the logged in user.

This tutorial uses Ruby, but you can write a CLI and use the device flow to generate a user access token with any programming language.
About device flow and user access tokens
The CLI will use the device flow to authenticate a user and generate a user access token. Then, the CLI can use the user access token to make API requests on behalf of the authenticated user.
Your app should use a user access token if you want to attribute the app's actions to a user. For more information, see Authenticating with a GitHub App on behalf of a user.
There are two ways to generate a user access token for a GitHub App: web application flow and device flow. You should use the device flow to generate a user access token if your app is headless or does not have access to a web interface. For example, CLI tools, simple Raspberry Pis, and desktop applications should use the device flow. If your app has access to a web interface, you should use web application flow instead. For more information, see Generating a user access token for a GitHub App and Building a "Login with GitHub" button with a GitHub App.
Prerequisites
This tutorial assumes that you have already registered a GitHub App. For more information about registering a GitHub App, see Registering a GitHub App.
Before following this tutorial, you must enable device flow for your app. For more information about enabling device flow for your app, see Modifying a GitHub App registration.
This tutorial assumes that you have a basic understanding of Ruby. For more information, see Ruby.
Get the client ID
You will need your app's client ID in order to generate a user access token via the device flow.


In the upper-right corner of any page on GitHub, click your profile photo.


Navigate to your account settings.

For an app owned by a personal account, click Settings.
For an app owned by an organization:

Click Your organizations.
To the right of the organization, click Settings.





In the left sidebar, click  Developer settings.


In the left sidebar, click GitHub Apps.


Next to the GitHub App that you want to work with, click Edit.


On the app's settings page, find the client ID for your app. You will use it later in this tutorial. Note that the client ID is different from the app ID.


Write the CLI
These steps lead you through building a CLI and using device flow to get a user access token. To skip ahead to the final code, see Full code example.
Setup


Create a Ruby file to hold the code that will generate a user access token. This tutorial will name the file app_cli.rb.


In your terminal, from the directory where app_cli.rb is stored, run the following command to make app_cli.rb executable:
Textchmod +x app_cli.rb
chmod +x app_cli.rb



Add this line to the top of app_cli.rb to indicate that the Ruby interpreter should be used to run the script:
Ruby#!/usr/bin/env ruby
#!/usr/bin/env ruby



Add these dependencies to the top of app_cli.rb, following #!/usr/bin/env ruby:
Rubyrequire "net/http"
require "json"
require "uri"
require "fileutils"
require "net/http"
require "json"
require "uri"
require "fileutils"

These are all part of the Ruby standard library, so you don't need to install any gems.


Add the following main function that will serve as an entry point. The function includes a case statement to take different actions depending on which command is specified. You will expand this case statement later.
Rubydef main
  case ARGV[0]
  when "help"
    puts "`help` is not yet defined"
  when "login"
    puts "`login` is not yet defined"
  when "whoami"
    puts "`whoami` is not yet defined"
  else
    puts "Unknown command `#{ARGV[0]}`"
  end
end
def main
  case ARGV[0]
  when "help"
    puts "`help` is not yet defined"
  when "login"
    puts "`login` is not yet defined"
  when "whoami"
    puts "`whoami` is not yet defined"
  else
    puts "Unknown command `#{ARGV[0]}`"
  end
end



At the bottom of the file, add the following line to call the entry point function. This function call should remain at the bottom of your file as you add more functions to this file later in the tutorial.
Rubymain
main



Optionally, check your progress:
app_cli.rb now looks like this:
Ruby#!/usr/bin/env ruby

require "net/http"
require "json"
require "uri"
require "fileutils"

def main
  case ARGV[0]
  when "help"
    puts "`help` is not yet defined"
  when "login"
    puts "`login` is not yet defined"
  when "whoami"
    puts "`whoami` is not yet defined"
  else
    puts "Unknown command `#{ARGV[0]}`"
  end
end

main
#!/usr/bin/env ruby

require "net/http"
require "json"
require "uri"
require "fileutils"

def main
  case ARGV[0]
  when "help"
    puts "`help` is not yet defined"
  when "login"
    puts "`login` is not yet defined"
  when "whoami"
    puts "`whoami` is not yet defined"
  else
    puts "Unknown command `#{ARGV[0]}`"
  end
end

main

In your terminal, from the directory where app_cli.rb is stored, run ./app_cli.rb help. You should see this output:
`help` is not yet defined

You can also test your script without a command or with an unhandled command. For example, ./app_cli.rb create-issue should output:
Unknown command `create-issue`



Add a help command


Add the following help function to app_cli.rb. Currently, the help function prints a line to tell users that this CLI takes one command, "help". You will expand this help function later.
Rubydef help
  puts "usage: app_cli <help>"
end
def help
  puts "usage: app_cli <help>"
end



Update the main function to call the help function when the help command is given:
Rubydef main
  case ARGV[0]
  when "help"
    help
  when "login"
    puts "`login` is not yet defined"
  when "whoami"
    puts "`whoami` is not yet defined"
  else
    puts "Unknown command #{ARGV[0]}"
  end
end
def main
  case ARGV[0]
  when "help"
    help
  when "login"
    puts "`login` is not yet defined"
  when "whoami"
    puts "`whoami` is not yet defined"
  else
    puts "Unknown command #{ARGV[0]}"
  end
end



Optionally, check your progress:
app_cli.rb now looks like this. The order of the functions doesn't matter as long as the main function call is at the end of the file.
Ruby#!/usr/bin/env ruby

require "net/http"
require "json"
require "uri"
require "fileutils"

def help
  puts "usage: app_cli <help>"
end

def main
  case ARGV[0]
  when "help"
    help
  when "login"
    puts "`login` is not yet defined"
  when "whoami"
    puts "`whoami` is not yet defined"
  else
    puts "Unknown command #{ARGV[0]}"
  end
end

main
#!/usr/bin/env ruby

require "net/http"
require "json"
require "uri"
require "fileutils"

def help
  puts "usage: app_cli <help>"
end

def main
  case ARGV[0]
  when "help"
    help
  when "login"
    puts "`login` is not yet defined"
  when "whoami"
    puts "`whoami` is not yet defined"
  else
    puts "Unknown command #{ARGV[0]}"
  end
end

main

In your terminal, from the directory where app_cli.rb is stored, run ./app_cli.rb help. You should see this output:
usage: app_cli <help>



Add a login command
The login command will run the device flow to get a user access token. For more information, see Generating a user access token for a GitHub App.


Near the top of your file, after the require statements, add the CLIENT_ID of your GitHub App as a constant in app_cli.rb. For more information about finding your app's client ID, see Get the client ID. Replace YOUR_CLIENT_ID with the client ID of your app:
RubyCLIENT_ID="YOUR_CLIENT_ID"
CLIENT_ID="YOUR_CLIENT_ID"



Add the following parse_response function to app_cli.rb. This function parses a response from the GitHub REST API. When the response status is 200 OK or 201 Created, the function returns the parsed response body. Otherwise, the function prints the response and body and exits the program.
Rubydef parse_response(response)
  case response
  when Net::HTTPOK, Net::HTTPCreated
    JSON.parse(response.body)
  else
    puts response
    puts response.body
    exit 1
  end
end
def parse_response(response)
  case response
  when Net::HTTPOK, Net::HTTPCreated
    JSON.parse(response.body)
  else
    puts response
    puts response.body
    exit 1
  end
end



Add the following request_device_code function to app_cli.rb. This function makes a POST request to https://github.com/login/device/code and returns the response.
Rubydef request_device_code
  uri = URI("https://github.com/login/device/code")
  parameters = URI.encode_www_form("client_id" => CLIENT_ID)
  headers = {"Accept" => "application/json"}

  response = Net::HTTP.post(uri, parameters, headers)
  parse_response(response)
end
def request_device_code
  uri = URI("https://github.com/login/device/code")
  parameters = URI.encode_www_form("client_id" => CLIENT_ID)
  headers = {"Accept" => "application/json"}

  response = Net::HTTP.post(uri, parameters, headers)
  parse_response(response)
end



Add the following request_token function to app_cli.rb. This function makes a POST request to https://github.com/login/oauth/access_token and returns the response.
Rubydef request_token(device_code)
  uri = URI("https://github.com/login/oauth/access_token")
  parameters = URI.encode_www_form({
    "client_id" => CLIENT_ID,
    "device_code" => device_code,
    "grant_type" => "urn:ietf:params:oauth:grant-type:device_code"
  })
  headers = {"Accept" => "application/json"}
  response = Net::HTTP.post(uri, parameters, headers)
  parse_response(response)
end
def request_token(device_code)
  uri = URI("https://github.com/login/oauth/access_token")
  parameters = URI.encode_www_form({
    "client_id" => CLIENT_ID,
    "device_code" => device_code,
    "grant_type" => "urn:ietf:params:oauth:grant-type:device_code"
  })
  headers = {"Accept" => "application/json"}
  response = Net::HTTP.post(uri, parameters, headers)
  parse_response(response)
end



Add the following poll_for_token function to app_cli.rb. This function polls https://github.com/login/oauth/access_token at the specified interval until GitHub responds with an access_token parameter instead of an error parameter. Then, it writes the user access token to a file and restricts the permissions on the file.
Rubydef poll_for_token(device_code, interval)

  loop do
    response = request_token(device_code)
    error, access_token = response.values_at("error", "access_token")

    if error
      case error
      when "authorization_pending"
        # The user has not yet entered the code.
        # Wait, then poll again.
        sleep interval
        next
      when "slow_down"
        # The app polled too fast.
        # Wait for the interval plus 5 seconds, then poll again.
        sleep interval + 5
        next
      when "expired_token"
        # The `device_code` expired, and the process needs to restart.
        puts "The device code has expired. Please run `login` again."
        exit 1
      when "access_denied"
        # The user cancelled the process. Stop polling.
        puts "Login cancelled by user."
        exit 1
      else
        puts response
        exit 1
      end
    end

    File.write("./.token", access_token)

    # Set the file permissions so that only the file owner can read or modify the file
    FileUtils.chmod(0600, "./.token")

    break
  end
end
def poll_for_token(device_code, interval)

  loop do
    response = request_token(device_code)
    error, access_token = response.values_at("error", "access_token")

    if error
      case error
      when "authorization_pending"
        # The user has not yet entered the code.
        # Wait, then poll again.
        sleep interval
        next
      when "slow_down"
        # The app polled too fast.
        # Wait for the interval plus 5 seconds, then poll again.
        sleep interval + 5
        next
      when "expired_token"
        # The `device_code` expired, and the process needs to restart.
        puts "The device code has expired. Please run `login` again."
        exit 1
      when "access_denied"
        # The user cancelled the process. Stop polling.
        puts "Login cancelled by user."
        exit 1
      else
        puts response
        exit 1
      end
    end

    File.write("./.token", access_token)

    # Set the file permissions so that only the file owner can read or modify the file
    FileUtils.chmod(0600, "./.token")

    break
  end
end



Add the following login function.
This function:

Calls the request_device_code function and gets the verification_uri, user_code, device_code, and interval parameters from the response.
Prompts users to enter the user_code from the previous step.
Calls the poll_for_token to poll GitHub for an access token.
Lets the user know that authentication was successful.

Rubydef login
  verification_uri, user_code, device_code, interval = request_device_code.values_at("verification_uri", "user_code", "device_code", "interval")

  puts "Please visit: #{verification_uri}"
  puts "and enter code: #{user_code}"

  poll_for_token(device_code, interval)

  puts "Successfully authenticated!"
end
def login
  verification_uri, user_code, device_code, interval = request_device_code.values_at("verification_uri", "user_code", "device_code", "interval")

  puts "Please visit: #{verification_uri}"
  puts "and enter code: #{user_code}"

  poll_for_token(device_code, interval)

  puts "Successfully authenticated!"
end



Update the main function to call the login function when the login command is given:
Rubydef main
  case ARGV[0]
  when "help"
    help
  when "login"
    login
  when "whoami"
    puts "`whoami` is not yet defined"
  else
    puts "Unknown command #{ARGV[0]}"
  end
end
def main
  case ARGV[0]
  when "help"
    help
  when "login"
    login
  when "whoami"
    puts "`whoami` is not yet defined"
  else
    puts "Unknown command #{ARGV[0]}"
  end
end



Update the help function to include the login command:
Rubydef help
  puts "usage: app_cli <login | help>"
end
def help
  puts "usage: app_cli <login | help>"
end



Optionally, check your progress:
app_cli.rb now looks something like this, where YOUR_CLIENT_ID is the client ID of your app. The order of the functions doesn't matter as long as the main function call is at the end of the file.
Ruby#!/usr/bin/env ruby

require "net/http"
require "json"
require "uri"
require "fileutils"

CLIENT_ID="YOUR_CLIENT_ID"

def help
  puts "usage: app_cli <login | help>"
end

def main
  case ARGV[0]
  when "help"
    help
  when "login"
    login
  when "whoami"
    puts "`whoami` is not yet defined"
  else
    puts "Unknown command #{ARGV[0]}"
  end
end

def parse_response(response)
  case response
  when Net::HTTPOK, Net::HTTPCreated
    JSON.parse(response.body)
  else
    puts response
    puts response.body
    exit 1
  end
end

def request_device_code
  uri = URI("https://github.com/login/device/code")
  parameters = URI.encode_www_form("client_id" => CLIENT_ID)
  headers = {"Accept" => "application/json"}

  response = Net::HTTP.post(uri, parameters, headers)
  parse_response(response)
end

def request_token(device_code)
  uri = URI("https://github.com/login/oauth/access_token")
  parameters = URI.encode_www_form({
    "client_id" => CLIENT_ID,
    "device_code" => device_code,
    "grant_type" => "urn:ietf:params:oauth:grant-type:device_code"
  })
  headers = {"Accept" => "application/json"}
  response = Net::HTTP.post(uri, parameters, headers)
  parse_response(response)
end

def poll_for_token(device_code, interval)

  loop do
    response = request_token(device_code)
    error, access_token = response.values_at("error", "access_token")

    if error
      case error
      when "authorization_pending"
        # The user has not yet entered the code.
        # Wait, then poll again.
        sleep interval
        next
      when "slow_down"
        # The app polled too fast.
        # Wait for the interval plus 5 seconds, then poll again.
        sleep interval + 5
        next
      when "expired_token"
        # The `device_code` expired, and the process needs to restart.
        puts "The device code has expired. Please run `login` again."
        exit 1
      when "access_denied"
        # The user cancelled the process. Stop polling.
        puts "Login cancelled by user."
        exit 1
      else
        puts response
        exit 1
      end
    end

    File.write("./.token", access_token)

    # Set the file permissions so that only the file owner can read or modify the file
    FileUtils.chmod(0600, "./.token")

    break
  end
end

def login
  verification_uri, user_code, device_code, interval = request_device_code.values_at("verification_uri", "user_code", "device_code", "interval")

  puts "Please visit: #{verification_uri}"
  puts "and enter code: #{user_code}"

  poll_for_token(device_code, interval)

  puts "Successfully authenticated!"
end

main
#!/usr/bin/env ruby

require "net/http"
require "json"
require "uri"
require "fileutils"

CLIENT_ID="YOUR_CLIENT_ID"

def help
  puts "usage: app_cli <login | help>"
end

def main
  case ARGV[0]
  when "help"
    help
  when "login"
    login
  when "whoami"
    puts "`whoami` is not yet defined"
  else
    puts "Unknown command #{ARGV[0]}"
  end
end

def parse_response(response)
  case response
  when Net::HTTPOK, Net::HTTPCreated
    JSON.parse(response.body)
  else
    puts response
    puts response.body
    exit 1
  end
end

def request_device_code
  uri = URI("https://github.com/login/device/code")
  parameters = URI.encode_www_form("client_id" => CLIENT_ID)
  headers = {"Accept" => "application/json"}

  response = Net::HTTP.post(uri, parameters, headers)
  parse_response(response)
end

def request_token(device_code)
  uri = URI("https://github.com/login/oauth/access_token")
  parameters = URI.encode_www_form({
    "client_id" => CLIENT_ID,
    "device_code" => device_code,
    "grant_type" => "urn:ietf:params:oauth:grant-type:device_code"
  })
  headers = {"Accept" => "application/json"}
  response = Net::HTTP.post(uri, parameters, headers)
  parse_response(response)
end

def poll_for_token(device_code, interval)

  loop do
    response = request_token(device_code)
    error, access_token = response.values_at("error", "access_token")

    if error
      case error
      when "authorization_pending"
        # The user has not yet entered the code.
        # Wait, then poll again.
        sleep interval
        next
      when "slow_down"
        # The app polled too fast.
        # Wait for the interval plus 5 seconds, then poll again.
        sleep interval + 5
        next
      when "expired_token"
        # The `device_code` expired, and the process needs to restart.
        puts "The device code has expired. Please run `login` again."
        exit 1
      when "access_denied"
        # The user cancelled the process. Stop polling.
        puts "Login cancelled by user."
        exit 1
      else
        puts response
        exit 1
      end
    end

    File.write("./.token", access_token)

    # Set the file permissions so that only the file owner can read or modify the file
    FileUtils.chmod(0600, "./.token")

    break
  end
end

def login
  verification_uri, user_code, device_code, interval = request_device_code.values_at("verification_uri", "user_code", "device_code", "interval")

  puts "Please visit: #{verification_uri}"
  puts "and enter code: #{user_code}"

  poll_for_token(device_code, interval)

  puts "Successfully authenticated!"
end

main



In your terminal, from the directory where app_cli.rb is stored, run ./app_cli.rb login. You should see output that looks like this. The code will differ every time:
Please visit: https://github.com/login/device
and enter code: CA86-8D94



Navigate to https://github.com/login/device in your browser and enter the code from the previous step, then click Continue.


GitHub should display a page that prompts you to authorize your app. Click the "Authorize" button.


Your terminal should now say "Successfully authenticated!".




Add a whoami command
Now that your app can generate a user access token, you can make API requests on behalf of the user. Add a whoami command to get the username of the authenticated user.


Add the following whoami function to app_cli.rb. This function gets information about the user with the /user REST API endpoint. It outputs the username that corresponds to the user access token. If the .token file was not found, it prompts the user to run the login function.
Rubydef whoami
  uri = URI("https://api.github.com/user")

  begin
    token = File.read("./.token").strip
  rescue Errno::ENOENT => e
    puts "You are not authorized. Run the `login` command."
    exit 1
  end

  response = Net::HTTP.start(uri.host, uri.port, use_ssl: true) do |http|
    body = {"access_token" => token}.to_json
    headers = {"Accept" => "application/vnd.github+json", "Authorization" => "Bearer #{token}"}

    http.send_request("GET", uri.path, body, headers)
  end

  parsed_response = parse_response(response)
  puts "You are #{parsed_response["login"]}"
end
def whoami
  uri = URI("https://api.github.com/user")

  begin
    token = File.read("./.token").strip
  rescue Errno::ENOENT => e
    puts "You are not authorized. Run the `login` command."
    exit 1
  end

  response = Net::HTTP.start(uri.host, uri.port, use_ssl: true) do |http|
    body = {"access_token" => token}.to_json
    headers = {"Accept" => "application/vnd.github+json", "Authorization" => "Bearer #{token}"}

    http.send_request("GET", uri.path, body, headers)
  end

  parsed_response = parse_response(response)
  puts "You are #{parsed_response["login"]}"
end



Update the parse_response function to handle the case where the token has expired or been revoked. Now, if you get a 401 Unauthorized response, the CLI will prompt the user to run the login command.
Rubydef parse_response(response)
  case response
  when Net::HTTPOK, Net::HTTPCreated
    JSON.parse(response.body)
  when Net::HTTPUnauthorized
    puts "You are not authorized. Run the `login` command."
    exit 1
  else
    puts response
    puts response.body
    exit 1
  end
end
def parse_response(response)
  case response
  when Net::HTTPOK, Net::HTTPCreated
    JSON.parse(response.body)
  when Net::HTTPUnauthorized
    puts "You are not authorized. Run the `login` command."
    exit 1
  else
    puts response
    puts response.body
    exit 1
  end
end



Update the main function to call the whoami function when the whoami command is given:
Rubydef main
  case ARGV[0]
  when "help"
    help
  when "login"
    login
  when "whoami"
    whoami
  else
    puts "Unknown command #{ARGV[0]}"
  end
end
def main
  case ARGV[0]
  when "help"
    help
  when "login"
    login
  when "whoami"
    whoami
  else
    puts "Unknown command #{ARGV[0]}"
  end
end



Update the help function to include the whoami command:
Rubydef help
  puts "usage: app_cli <login | whoami | help>"
end
def help
  puts "usage: app_cli <login | whoami | help>"
end



Check your code against the full code example in the next section. You can test your code by following the steps outlined in the Testing section below the full code example.


Full code example
This is the full code example that was outlined in the previous section. Replace YOUR_CLIENT_ID with the client ID of your app.
Ruby#!/usr/bin/env ruby

require "net/http"
require "json"
require "uri"
require "fileutils"

CLIENT_ID="YOUR_CLIENT_ID"

def help
  puts "usage: app_cli <login | whoami | help>"
end

def main
  case ARGV[0]
  when "help"
    help
  when "login"
    login
  when "whoami"
    whoami
  else
    puts "Unknown command #{ARGV[0]}"
  end
end

def parse_response(response)
  case response
  when Net::HTTPOK, Net::HTTPCreated
    JSON.parse(response.body)
  when Net::HTTPUnauthorized
    puts "You are not authorized. Run the `login` command."
    exit 1
  else
    puts response
    puts response.body
    exit 1
  end
end

def request_device_code
  uri = URI("https://github.com/login/device/code")
  parameters = URI.encode_www_form("client_id" => CLIENT_ID)
  headers = {"Accept" => "application/json"}

  response = Net::HTTP.post(uri, parameters, headers)
  parse_response(response)
end

def request_token(device_code)
  uri = URI("https://github.com/login/oauth/access_token")
  parameters = URI.encode_www_form({
    "client_id" => CLIENT_ID,
    "device_code" => device_code,
    "grant_type" => "urn:ietf:params:oauth:grant-type:device_code"
  })
  headers = {"Accept" => "application/json"}
  response = Net::HTTP.post(uri, parameters, headers)
  parse_response(response)
end

def poll_for_token(device_code, interval)

  loop do
    response = request_token(device_code)
    error, access_token = response.values_at("error", "access_token")

    if error
      case error
      when "authorization_pending"
        # The user has not yet entered the code.
        # Wait, then poll again.
        sleep interval
        next
      when "slow_down"
        # The app polled too fast.
        # Wait for the interval plus 5 seconds, then poll again.
        sleep interval + 5
        next
      when "expired_token"
        # The `device_code` expired, and the process needs to restart.
        puts "The device code has expired. Please run `login` again."
        exit 1
      when "access_denied"
        # The user cancelled the process. Stop polling.
        puts "Login cancelled by user."
        exit 1
      else
        puts response
        exit 1
      end
    end

    File.write("./.token", access_token)

    # Set the file permissions so that only the file owner can read or modify the file
    FileUtils.chmod(0600, "./.token")

    break
  end
end

def login
  verification_uri, user_code, device_code, interval = request_device_code.values_at("verification_uri", "user_code", "device_code", "interval")

  puts "Please visit: #{verification_uri}"
  puts "and enter code: #{user_code}"

  poll_for_token(device_code, interval)

  puts "Successfully authenticated!"
end

def whoami
  uri = URI("https://api.github.com/user")

  begin
    token = File.read("./.token").strip
  rescue Errno::ENOENT => e
    puts "You are not authorized. Run the `login` command."
    exit 1
  end

  response = Net::HTTP.start(uri.host, uri.port, use_ssl: true) do |http|
    body = {"access_token" => token}.to_json
    headers = {"Accept" => "application/vnd.github+json", "Authorization" => "Bearer #{token}"}

    http.send_request("GET", uri.path, body, headers)
  end

  parsed_response = parse_response(response)
  puts "You are #{parsed_response["login"]}"
end

main
#!/usr/bin/env ruby

require "net/http"
require "json"
require "uri"
require "fileutils"

CLIENT_ID="YOUR_CLIENT_ID"

def help
  puts "usage: app_cli <login | whoami | help>"
end

def main
  case ARGV[0]
  when "help"
    help
  when "login"
    login
  when "whoami"
    whoami
  else
    puts "Unknown command #{ARGV[0]}"
  end
end

def parse_response(response)
  case response
  when Net::HTTPOK, Net::HTTPCreated
    JSON.parse(response.body)
  when Net::HTTPUnauthorized
    puts "You are not authorized. Run the `login` command."
    exit 1
  else
    puts response
    puts response.body
    exit 1
  end
end

def request_device_code
  uri = URI("https://github.com/login/device/code")
  parameters = URI.encode_www_form("client_id" => CLIENT_ID)
  headers = {"Accept" => "application/json"}

  response = Net::HTTP.post(uri, parameters, headers)
  parse_response(response)
end

def request_token(device_code)
  uri = URI("https://github.com/login/oauth/access_token")
  parameters = URI.encode_www_form({
    "client_id" => CLIENT_ID,
    "device_code" => device_code,
    "grant_type" => "urn:ietf:params:oauth:grant-type:device_code"
  })
  headers = {"Accept" => "application/json"}
  response = Net::HTTP.post(uri, parameters, headers)
  parse_response(response)
end

def poll_for_token(device_code, interval)

  loop do
    response = request_token(device_code)
    error, access_token = response.values_at("error", "access_token")

    if error
      case error
      when "authorization_pending"
        # The user has not yet entered the code.
        # Wait, then poll again.
        sleep interval
        next
      when "slow_down"
        # The app polled too fast.
        # Wait for the interval plus 5 seconds, then poll again.
        sleep interval + 5
        next
      when "expired_token"
        # The `device_code` expired, and the process needs to restart.
        puts "The device code has expired. Please run `login` again."
        exit 1
      when "access_denied"
        # The user cancelled the process. Stop polling.
        puts "Login cancelled by user."
        exit 1
      else
        puts response
        exit 1
      end
    end

    File.write("./.token", access_token)

    # Set the file permissions so that only the file owner can read or modify the file
    FileUtils.chmod(0600, "./.token")

    break
  end
end

def login
  verification_uri, user_code, device_code, interval = request_device_code.values_at("verification_uri", "user_code", "device_code", "interval")

  puts "Please visit: #{verification_uri}"
  puts "and enter code: #{user_code}"

  poll_for_token(device_code, interval)

  puts "Successfully authenticated!"
end

def whoami
  uri = URI("https://api.github.com/user")

  begin
    token = File.read("./.token").strip
  rescue Errno::ENOENT => e
    puts "You are not authorized. Run the `login` command."
    exit 1
  end

  response = Net::HTTP.start(uri.host, uri.port, use_ssl: true) do |http|
    body = {"access_token" => token}.to_json
    headers = {"Accept" => "application/vnd.github+json", "Authorization" => "Bearer #{token}"}

    http.send_request("GET", uri.path, body, headers)
  end

  parsed_response = parse_response(response)
  puts "You are #{parsed_response["login"]}"
end

main

Testing
This tutorial assumes that your app code is stored in a file named app_cli.rb.


In your terminal, from the directory where app_cli.rb is stored, run ./app_cli.rb help. You should see output that looks like this.
usage: app_cli <login | whoami | help>



In your terminal, from the directory where app_cli.rb is stored, run ./app_cli.rb login. You should see output that looks like this. The code will differ every time:
Please visit: https://github.com/login/device
and enter code: CA86-8D94



Navigate to https://github.com/login/device in your browser and enter the code from the previous step, then click Continue.


GitHub should display a page that prompts you to authorize your app. Click the "Authorize" button.


Your terminal should now say "Successfully authenticated!".


In your terminal, from the directory where app_cli.rb is stored, run ./app_cli.rb whoami. You should see output that looks like this, where octocat is your username.
You are octocat



Open the .token file in your editor, and modify the token. Now, the token is invalid.


In your terminal, from the directory where app_cli.rb is stored, run ./app_cli.rb whoami. You should see output that looks like this:
You are not authorized. Run the `login` command.



Delete the .token file.


In your terminal, from the directory where app_cli.rb is stored, run ./app_cli.rb whoami. You should see output that looks like this:
You are not authorized. Run the `login` command.



Next steps
Adjust the code to meet your app's needs
This tutorial demonstrated how to write a CLI that uses the device flow to generate a user access token. You can expand this CLI to accept additional commands. For example, you can add a create-issue command that opens an issue. Remember to update your app's permissions if your app needs additional permissions for the API requests that you want to make. For more information, see Choosing permissions for a GitHub App.
Securely store tokens
This tutorial generates a user access token and saves it in a local file. You should never commit this file or publicize the token.
Depending on your device, you may choose different ways to store the token. You should check the best practices for storing tokens on your device.
For more information, see Best practices for creating a GitHub App.
Follow best practices
You should aim to follow best practices with your GitHub App. For more information, see Best practices for creating a GitHub App.\n\n\n\nApps/Creating GitHub Apps/Writing code for a GitHub App/Build CI checksBuilding CI checks with a GitHub AppBuild a continuous integration server to run tests using a GitHub App and checks.In this articleIntroductionPrerequisitesSetupAdd code for your GitHub AppStart the serverTest that the server is listening to your appPart 1. Creating the Checks API interfaceStep 1.1. Add event handlingStep 1.2. Create a check runStep 1.3. Update a check runPart 2. Creating a CI testStep 2.1. Add a Ruby fileStep 2.2. Allow RuboCop to clone the test repositoryStep 2.3. Run RuboCopStep 2.4. Collect RuboCop errorsStep 2.5. Update the check run with CI test resultsStep 2.6. Automatically fix RuboCop errorsFull code exampleNext stepsIntroduction
This tutorial demonstrates how to build a continuous integration (CI) server that runs tests on new code that's pushed to a repository. The tutorial shows how to build and configure a GitHub App to act as a server that receives and responds to check_run and check_suite webhook events using GitHub's REST API.
In this tutorial, you will use your computer or codespace as a server while you develop your app. Once the app is ready for production use, you should deploy your app to a dedicated server.
This tutorial uses Ruby, but you can use any programming language that you can run on your server.
This tutorial is broken into two parts:

In part one, you'll learn how to set up the framework for a CI server using GitHub's REST API, create new check runs for CI tests when a repository receives newly pushed commits, and re-run check runs when a user requests that action on GitHub.
In part two, you'll add functionality to your CI test, by adding a linter test to your CI server. You'll also create annotations that are displayed in the Checks and Files Changed tab of a pull request, and automatically fix linter recommendations by exposing a "Fix this" button in the Checks tab of the pull request.

About continuous integration (CI)
CI is a software practice that requires frequently committing code to a shared repository. Committing code more often raises errors sooner and reduces the amount of code a developer needs to debug when finding the source of an error. Frequent code updates also make it easier to merge changes from different members of a software development team. This is great for developers, who can spend more time writing code and less time debugging errors or resolving merge conflicts.
A CI server hosts code that runs CI tests such as code linters (which check style formatting), security checks, code coverage, and other checks against new code commits in a repository. CI servers can even build and deploy code to staging or production servers. For examples of the types of CI tests you can create with a GitHub App, see the continuous integration apps that are available in GitHub Marketplace.
About checks
GitHub's REST API allows you to set up CI tests (checks) that are automatically run against each code commit in a repository. The API reports detailed information about each check in the pull request's Checks tab on GitHub. You can use checks in a repository to determine when a code commit introduces errors.
Checks include check runs, check suites, and commit statuses.

A check run is an individual CI test that runs on a commit.
A check suite is a group of check runs.
A commit status marks the state of a commit, for example error, failure, pending, or success, and is visible in a pull request on GitHub. Both check suites and check runs contain commit statuses.

GitHub automatically creates check_suite events for new code commits in a repository using the default flow, although you can change the default settings. For more information, see REST API endpoints for check suites. Here's how the default flow works:

When someone pushes code to the repository, GitHub automatically sends the check_suite event with an action of requested to all GitHub Apps installed on the repository that have the checks:write permission. This event lets the apps know that code was pushed to the repository, and that GitHub has automatically created a new check suite.
When your app receives this event, it can add check runs to that suite.
Your check runs can include annotations that are displayed on specific lines of code. Annotations are visible in the Checks tab. When you create an annotation for a file that is part of the pull request, the annotations are also shown in the Files changed tab. For more information, see the annotations object in REST API endpoints for check runs.

For more information about checks, see REST API endpoints for checks and Using the REST API to interact with checks.
Prerequisites
This tutorial assumes you have a basic understanding of the Ruby programming language.
Before you get started, you may want to familiarize yourself with the following concepts:

GitHub Apps
Webhooks
REST API checks endpoints

Checks are also available to use with the GraphQL API, but this tutorial focuses on the REST API. For more information about the GraphQL objects, see Check Suite and Check Run in the GraphQL documentation.
Setup
The following sections will lead you through setting up the following components:

A repository to store the code for your app.
A way to receive webhooks locally.
A GitHub App that is subscribed to "Check suite" and "Check run" webhook events, has write permission for checks, and uses a webhook URL that you can receive locally.

Create a repository to store code for your GitHub App


Create a repository to store the code for your app. For more information, see Creating a new repository.


Clone your repository from the previous step. For more information, see Cloning a repository. You may use a local clone or GitHub Codespaces.


In a terminal, navigate to the directory where your clone is stored.


Create a Ruby file named server.rb. This file will contain all the code for your app. You will add content to this file later.


If the directory doesn't already include a .gitignore file, add a .gitignore file. You will add content to this file later. For more information about .gitignore files, see Ignoring files.


Create a file named Gemfile. This file will describe the gem dependencies that your Ruby code needs. Add the following contents to your Gemfile:
Rubysource 'http://rubygems.org'

gem 'sinatra', '~> 2.0'
gem 'jwt', '~> 2.1'
gem 'octokit', '~> 4.0'
gem 'puma'
gem 'rubocop'
gem 'dotenv'
gem 'git'
source 'http://rubygems.org'

gem 'sinatra', '~> 2.0'
gem 'jwt', '~> 2.1'
gem 'octokit', '~> 4.0'
gem 'puma'
gem 'rubocop'
gem 'dotenv'
gem 'git'



Create a file named config.ru. This file will configure your Sinatra server to run. Add the following contents to your config.ru file:
Rubyrequire './server'
run GHAapp
require './server'
run GHAapp



Get a webhook proxy URL
In order to develop your app locally, you can use a webhook proxy URL to forward webhook events from GitHub to your computer or codespace. This tutorial uses Smee.io to provide a webhook proxy URL and forward events.


In a terminal, run the following command to install the Smee client:
Shellnpm install --global smee-client
npm install --global smee-client



In your browser, navigate to https://smee.io/.


Click Start a new channel.


Copy the full URL under "Webhook Proxy URL".


In the terminal, run the following command to start the Smee client. Replace YOUR_DOMAIN with the Webhook Proxy URL you copied in the previous step.
Shellsmee --url YOUR_DOMAIN --path /event_handler --port 3000
smee --url YOUR_DOMAIN --path /event_handler --port 3000

You should see output like the following:
Forwarding https://smee.io/YOUR_DOMAIN to http://127.0.0.1:3000/event_handler
Connected https://smee.io/YOUR_DOMAIN



The smee --url https://smee.io/YOUR_DOMAIN command tells Smee to forward all webhook events received by the Smee channel to the Smee client running on your computer. The --path /event_handler option forwards events to the /event_handler route. The --port 3000 option specifies port 3000, which is the port you will tell your server to listen to, when you add more code later in the tutorial. Using Smee, your machine does not need to be open to the public internet to receive webhooks from GitHub. You can also open that Smee URL in your browser to inspect webhook payloads as they come in.
We recommend leaving this terminal window open and keeping Smee connected while you complete the rest of the steps in this guide. Although you can disconnect and reconnect the Smee client without losing your unique domain, you may find it easier to leave it connected and do other command-line tasks in a different terminal window.
Register a GitHub App
For this tutorial, you must register a GitHub App that:

Has webhooks active
Uses a webhook URL that you can receive locally
Has the "Checks" repository permission
Subscribes to the "Check suite" and "Check run" webhook events

The following steps will guide you through configuring a GitHub App with these settings. For more information about GitHub App settings, see Registering a GitHub App.


In the upper-right corner of any page on GitHub, click your profile photo.


Navigate to your account settings.

For an app owned by a personal account, click Settings.
For an app owned by an organization:

Click Your organizations.
To the right of the organization, click Settings.





In the left sidebar, click  Developer settings.


In the left sidebar, click GitHub Apps.


Click New GitHub App.


Under "GitHub App name", enter a name for your app. For example, USERNAME-ci-test-app where USERNAME is your GitHub username.


Under "Homepage URL", enter a URL for your app. For example, you can use the URL of the repository that you created to store the code for your app.


Skip the "Identifying and authorizing users" and "Post installation" sections for this tutorial.


Make sure that Active is selected under "Webhooks".


Under "Webhook URL", enter your webhook proxy URL from earlier. For more information, see Get a webhook proxy URL.


Under "Webhook secret", enter a random string. This secret is used to verify that webhooks are sent by GitHub. Save this string; you will use it later.


Under "Repository permissions", next to "Checks", select Read & write.


Under "Subscribe to events", select Check suite and Check run.


Under "Where can this GitHub App be installed?", select Only on this account. You can change this later if you want to publish your app.


Click Create GitHub App.


Store your app's identifying information and credentials
This tutorial will show you how to store your app's credentials and identifying information as environment variables in a .env file. When you deploy your app, you should change how you store the credentials. For more information, see Deploy your app.
Make sure that you are on a secure machine before performing these steps, since you will store your credentials locally.


In your terminal, navigate to the directory where your clone is stored.


Create a file called .env at the top level of this directory.


Add .env to your .gitignore file. This will prevent you from accidentally committing your app's credentials.


Add the following contents to your .env file. You will update the values in a later step.
ShellGITHUB_APP_IDENTIFIER="YOUR_APP_ID"
GITHUB_WEBHOOK_SECRET="YOUR_WEBHOOK_SECRET"
GITHUB_PRIVATE_KEY="YOUR_PRIVATE_KEY"
GITHUB_APP_IDENTIFIER="YOUR_APP_ID"
GITHUB_WEBHOOK_SECRET="YOUR_WEBHOOK_SECRET"
GITHUB_PRIVATE_KEY="YOUR_PRIVATE_KEY"



Navigate to the settings page for your app:


In the upper-right corner of any page on GitHub, click your profile photo.


Navigate to your account settings.

For an app owned by a personal account, click Settings.
For an app owned by an organization:

Click Your organizations.
To the right of the organization, click Settings.





In the left sidebar, click  Developer settings.


In the left sidebar, click GitHub Apps.


Next to your app's name, click Edit.




On your app's settings page, next to "App ID", find the app ID for your app.


In your .env file, replace YOUR_APP_ID with the app ID of your app.


In your .env file, replace YOUR_WEBHOOK_SECRET with the webhook secret for your app. If you have forgotten your webhook secret, under "Webhook secret (optional)", click Change secret. Enter a new secret, then click Save changes.


On your app's settings page, under "Private keys", click Generate a private key. You will see a private key .pem file downloaded to your computer.


Open the .pem file with a text editor, or use the following command on the command line to display the contents of the file: cat PATH/TO/YOUR/private-key.pem.


Copy and paste the entire contents of the file into your .env file as the value of GITHUB_PRIVATE_KEY, and add double quotes around the entire value.
Here is an example .env file:
GITHUB_APP_IDENTIFIER=12345
GITHUB_WEBHOOK_SECRET=your webhook secret
GITHUB_PRIVATE_KEY="-----BEGIN RSA PRIVATE KEY-----
...
HkVN9...
...
-----END RSA PRIVATE KEY-----"



Add code for your GitHub App
This section will show you how to add some basic template code for your GitHub App, and it will explain what the code does. Later in the tutorial, you will learn how to modify and add to this code, to build out your app's functionality.
Add the following template code to your server.rb file:
Rubyrequire 'sinatra/base'  # Use the Sinatra web framework
require 'octokit'       # Use the Octokit Ruby library to interact with GitHub's REST API
require 'dotenv/load'   # Manages environment variables
require 'json'          # Allows your app to manipulate JSON data
require 'openssl'       # Verifies the webhook signature
require 'jwt'           # Authenticates a GitHub App
require 'time'          # Gets ISO 8601 representation of a Time object
require 'logger'        # Logs debug statements

# This code is a Sinatra app, for two reasons:
#   1. Because the app will require a landing page for installation.
#   2. To easily handle webhook events.

class GHAapp < Sinatra::Application

  # Sets the port that's used when starting the web server.
  set :port, 3000
  set :bind, '0.0.0.0'

  # Expects the private key in PEM format. Converts the newlines.
  PRIVATE_KEY = OpenSSL::PKey::RSA.new(ENV['GITHUB_PRIVATE_KEY'].gsub('\n', "\n"))

  # Your registered app must have a webhook secret.
  # The secret is used to verify that webhooks are sent by GitHub.
  WEBHOOK_SECRET = ENV['GITHUB_WEBHOOK_SECRET']

  # The GitHub App's identifier (type integer).
  APP_IDENTIFIER = ENV['GITHUB_APP_IDENTIFIER']

  # Turn on Sinatra's verbose logging during development
  configure :development do
    set :logging, Logger::DEBUG
  end

  # Executed before each request to the `/event_handler` route
  before '/event_handler' do
    get_payload_request(request)
    verify_webhook_signature

    # If a repository name is provided in the webhook, validate that
    # it consists only of latin alphabetic characters, `-`, and `_`.
    unless @payload['repository'].nil?
      halt 400 if (@payload['repository']['name'] =~ /[0-9A-Za-z\-\_]+/).nil?
    end

    authenticate_app
    # Authenticate the app installation in order to run API operations
    authenticate_installation(@payload)
  end

  post '/event_handler' do

    # ADD EVENT HANDLING HERE #

    200 # success status
  end

  helpers do

    # ADD CREATE_CHECK_RUN HELPER METHOD HERE #

    # ADD INITIATE_CHECK_RUN HELPER METHOD HERE #

    # ADD CLONE_REPOSITORY HELPER METHOD HERE #

    # ADD TAKE_REQUESTED_ACTION HELPER METHOD HERE #

    # Saves the raw payload and converts the payload to JSON format
    def get_payload_request(request)
      # request.body is an IO or StringIO object
      # Rewind in case someone already read it
      request.body.rewind
      # The raw text of the body is required for webhook signature verification
      @payload_raw = request.body.read
      begin
        @payload = JSON.parse @payload_raw
      rescue => e
        fail 'Invalid JSON (#{e}): #{@payload_raw}'
      end
    end

    # Instantiate an Octokit client authenticated as a GitHub App.
    # GitHub App authentication requires that you construct a
    # JWT (https://jwt.io/introduction/) signed with the app's private key,
    # so GitHub can be sure that it came from the app and not altered by
    # a malicious third party.
    def authenticate_app
      payload = {
          # The time that this JWT was issued, _i.e._ now.
          iat: Time.now.to_i,

          # JWT expiration time (10 minute maximum)
          exp: Time.now.to_i + (10 * 60),

          # Your GitHub App's identifier number
          iss: APP_IDENTIFIER
      }

      # Cryptographically sign the JWT.
      jwt = JWT.encode(payload, PRIVATE_KEY, 'RS256')

      # Create the Octokit client, using the JWT as the auth token.
      @app_client ||= Octokit::Client.new(bearer_token: jwt)
    end

    # Instantiate an Octokit client, authenticated as an installation of a
    # GitHub App, to run API operations.
    def authenticate_installation(payload)
      @installation_id = payload['installation']['id']
      @installation_token = @app_client.create_app_installation_access_token(@installation_id)[:token]
      @installation_client = Octokit::Client.new(bearer_token: @installation_token)
    end

    # Check X-Hub-Signature to confirm that this webhook was generated by
    # GitHub, and not a malicious third party.
    #
    # GitHub uses the WEBHOOK_SECRET, registered to the GitHub App, to
    # create the hash signature sent in the `X-HUB-Signature` header of each
    # webhook. This code computes the expected hash signature and compares it to
    # the signature sent in the `X-HUB-Signature` header. If they don't match,
    # this request is an attack, and you should reject it. GitHub uses the HMAC
    # hexdigest to compute the signature. The `X-HUB-Signature` looks something
    # like this: 'sha1=123456'.
    def verify_webhook_signature
      their_signature_header = request.env['HTTP_X_HUB_SIGNATURE'] || 'sha1='
      method, their_digest = their_signature_header.split('=')
      our_digest = OpenSSL::HMAC.hexdigest(method, WEBHOOK_SECRET, @payload_raw)
      halt 401 unless their_digest == our_digest

      # The X-GITHUB-EVENT header provides the name of the event.
      # The action value indicates the which action triggered the event.
      logger.debug "---- received event #{request.env['HTTP_X_GITHUB_EVENT']}"
      logger.debug "----    action #{@payload['action']}" unless @payload['action'].nil?
    end

  end

  # Finally some logic to let us run this server directly from the command line,
  # or with Rack. Don't worry too much about this code. But, for the curious:
  # $0 is the executed file
  # __FILE__ is the current file
  # If they are the same—that is, we are running this file directly, call the
  # Sinatra run method
  run! if __FILE__ == $0
end
require 'sinatra/base'  # Use the Sinatra web framework
require 'octokit'       # Use the Octokit Ruby library to interact with GitHub's REST API
require 'dotenv/load'   # Manages environment variables
require 'json'          # Allows your app to manipulate JSON data
require 'openssl'       # Verifies the webhook signature
require 'jwt'           # Authenticates a GitHub App
require 'time'          # Gets ISO 8601 representation of a Time object
require 'logger'        # Logs debug statements

# This code is a Sinatra app, for two reasons:
#   1. Because the app will require a landing page for installation.
#   2. To easily handle webhook events.

class GHAapp < Sinatra::Application

  # Sets the port that's used when starting the web server.
  set :port, 3000
  set :bind, '0.0.0.0'

  # Expects the private key in PEM format. Converts the newlines.
  PRIVATE_KEY = OpenSSL::PKey::RSA.new(ENV['GITHUB_PRIVATE_KEY'].gsub('\n', "\n"))

  # Your registered app must have a webhook secret.
  # The secret is used to verify that webhooks are sent by GitHub.
  WEBHOOK_SECRET = ENV['GITHUB_WEBHOOK_SECRET']

  # The GitHub App's identifier (type integer).
  APP_IDENTIFIER = ENV['GITHUB_APP_IDENTIFIER']

  # Turn on Sinatra's verbose logging during development
  configure :development do
    set :logging, Logger::DEBUG
  end

  # Executed before each request to the `/event_handler` route
  before '/event_handler' do
    get_payload_request(request)
    verify_webhook_signature

    # If a repository name is provided in the webhook, validate that
    # it consists only of latin alphabetic characters, `-`, and `_`.
    unless @payload['repository'].nil?
      halt 400 if (@payload['repository']['name'] =~ /[0-9A-Za-z\-\_]+/).nil?
    end

    authenticate_app
    # Authenticate the app installation in order to run API operations
    authenticate_installation(@payload)
  end

  post '/event_handler' do

    # ADD EVENT HANDLING HERE #

    200 # success status
  end

  helpers do

    # ADD CREATE_CHECK_RUN HELPER METHOD HERE #

    # ADD INITIATE_CHECK_RUN HELPER METHOD HERE #

    # ADD CLONE_REPOSITORY HELPER METHOD HERE #

    # ADD TAKE_REQUESTED_ACTION HELPER METHOD HERE #

    # Saves the raw payload and converts the payload to JSON format
    def get_payload_request(request)
      # request.body is an IO or StringIO object
      # Rewind in case someone already read it
      request.body.rewind
      # The raw text of the body is required for webhook signature verification
      @payload_raw = request.body.read
      begin
        @payload = JSON.parse @payload_raw
      rescue => e
        fail 'Invalid JSON (#{e}): #{@payload_raw}'
      end
    end

    # Instantiate an Octokit client authenticated as a GitHub App.
    # GitHub App authentication requires that you construct a
    # JWT (https://jwt.io/introduction/) signed with the app's private key,
    # so GitHub can be sure that it came from the app and not altered by
    # a malicious third party.
    def authenticate_app
      payload = {
          # The time that this JWT was issued, _i.e._ now.
          iat: Time.now.to_i,

          # JWT expiration time (10 minute maximum)
          exp: Time.now.to_i + (10 * 60),

          # Your GitHub App's identifier number
          iss: APP_IDENTIFIER
      }

      # Cryptographically sign the JWT.
      jwt = JWT.encode(payload, PRIVATE_KEY, 'RS256')

      # Create the Octokit client, using the JWT as the auth token.
      @app_client ||= Octokit::Client.new(bearer_token: jwt)
    end

    # Instantiate an Octokit client, authenticated as an installation of a
    # GitHub App, to run API operations.
    def authenticate_installation(payload)
      @installation_id = payload['installation']['id']
      @installation_token = @app_client.create_app_installation_access_token(@installation_id)[:token]
      @installation_client = Octokit::Client.new(bearer_token: @installation_token)
    end

    # Check X-Hub-Signature to confirm that this webhook was generated by
    # GitHub, and not a malicious third party.
    #
    # GitHub uses the WEBHOOK_SECRET, registered to the GitHub App, to
    # create the hash signature sent in the `X-HUB-Signature` header of each
    # webhook. This code computes the expected hash signature and compares it to
    # the signature sent in the `X-HUB-Signature` header. If they don't match,
    # this request is an attack, and you should reject it. GitHub uses the HMAC
    # hexdigest to compute the signature. The `X-HUB-Signature` looks something
    # like this: 'sha1=123456'.
    def verify_webhook_signature
      their_signature_header = request.env['HTTP_X_HUB_SIGNATURE'] || 'sha1='
      method, their_digest = their_signature_header.split('=')
      our_digest = OpenSSL::HMAC.hexdigest(method, WEBHOOK_SECRET, @payload_raw)
      halt 401 unless their_digest == our_digest

      # The X-GITHUB-EVENT header provides the name of the event.
      # The action value indicates the which action triggered the event.
      logger.debug "---- received event #{request.env['HTTP_X_GITHUB_EVENT']}"
      logger.debug "----    action #{@payload['action']}" unless @payload['action'].nil?
    end

  end

  # Finally some logic to let us run this server directly from the command line,
  # or with Rack. Don't worry too much about this code. But, for the curious:
  # $0 is the executed file
  # __FILE__ is the current file
  # If they are the same—that is, we are running this file directly, call the
  # Sinatra run method
  run! if __FILE__ == $0
end

The rest of this section will explain what the template code does. There aren't any steps that you need to complete in this section. If you're already familiar with the template code, you can skip ahead to Start the server.
Understand the template code
Open the server.rb file in a text editor. You'll see comments throughout the file that provide additional context for the template code. We recommend reading those comments carefully and even adding your own comments to accompany new code you write.
Below the list of required files, the first code you'll see is the class GHApp < Sinatra::Application declaration. You'll write all of the code for your GitHub App inside this class. The following sections explain in detail what the code does inside this class.

Set the port
Read the environment variables
Turn on logging
Define a before filter
Define the route handler
Define the helper methods

Set the port
The first thing you'll see inside the class GHApp < Sinatra::Application declaration is set :port 3000. This sets the port used when starting the web server, to match the port you redirected your webhook payloads to in Get a Webhook Proxy URL.
  # Sets the port that's used when starting the web server.
  set :port, 3000
  set :bind, '0.0.0.0'

Read the environment variables
Next, this class reads the three environment variables you set in Store your app's identifying information and credentials, and stores them in variables to use later.
# Expects the private key in PEM format. Converts the newlines.
PRIVATE_KEY = OpenSSL::PKey::RSA.new(ENV['GITHUB_PRIVATE_KEY'].gsub('\n', "\n"))

# Your registered app must have a webhook secret.
# The secret is used to verify that webhooks are sent by GitHub.
WEBHOOK_SECRET = ENV['GITHUB_WEBHOOK_SECRET']

# The GitHub App's identifier (type integer).
APP_IDENTIFIER = ENV['GITHUB_APP_IDENTIFIER']

Turn on logging
Next is a code block that enables logging during development, which is the default environment in Sinatra. This code turns on logging at the DEBUG level to show useful output in the terminal while you are developing the app.
# Turn on Sinatra's verbose logging during development
configure :development do
  set :logging, Logger::DEBUG
end

Define a before filter
Sinatra uses before filters that allow you to execute code before the route handler. The before block in the template calls four helper methods: get_payload_request, verify_webhook_signature, authenticate_app, and authenticate_installation. For more information, see Filters and Helpers in the Sinatra documentation.
  # Executed before each request to the `/event_handler` route
  before '/event_handler' do
    get_payload_request(request)
    verify_webhook_signature

    # If a repository name is provided in the webhook, validate that
    # it consists only of latin alphabetic characters, `-`, and `_`.
    unless @payload['repository'].nil?
      halt 400 if (@payload['repository']['name'] =~ /[0-9A-Za-z\-\_]+/).nil?
    end

    authenticate_app
    # Authenticate the app installation in order to run API operations
    authenticate_installation(@payload)
  end

Each of these helper methods are defined later in the code, in the code block that starts with helpers do. For more information, see Define the helper methods.
Under verify_webhook_signature, the code that starts with unless @payload is a security measure. If a repository name is provided with a webhook payload, this code validates that the repository name contains only Latin alphabetic characters, hyphens, and underscores. This helps ensure that a bad actor isn't attempting to execute arbitrary commands or inject false repository names. Later, in the code block that starts with helpers do, the verify_webhook_signature helper method also validates incoming webhook payloads as an additional security measure.
Define a route handler
An empty route is included in the template code. This code handles all POST requests to the /event_handler route. You will add more code to this later.
post '/event_handler' do

end

Define the helper methods
Four helper methods are called in the before block of the template code. The helpers do code block defines each of these helper methods.
Handling the webhook payload
The first helper method get_payload_request captures the webhook payload and converts it to JSON format, which makes accessing the payload's data much easier.
Verifying the webhook signature
The second helper method verify_webhook_signature performs verification of the webhook signature to ensure that GitHub generated the event. To learn more about the code in the verify_webhook_signature helper method, see Validating webhook deliveries. If the webhooks are secure, this method will log all incoming payloads to your terminal. The logger code is helpful in verifying your web server is working.
Authenticating as a GitHub App
The third helper method authenticate_app allows your GitHub App to authenticate, so it can request an installation token.
To make API calls, you'll be using the Octokit library. Doing anything interesting with this library will require your GitHub App to authenticate. For more information about the Octokit library, see the Octokit documentation.
GitHub Apps have three methods of authentication:

Authenticating as a GitHub App using a JSON Web Token (JWT).
Authenticating as a specific installation of a GitHub App using an installation access token.
Authenticating on behalf of a user. This tutorial won't use this method of authentication.

You'll learn about authenticating as an installation in the next section, Authenticating as an installation.
Authenticating as a GitHub App lets you do a couple of things:

You can retrieve high-level management information about your GitHub App.
You can request access tokens for an installation of the app.

For example, you would authenticate as a GitHub App to retrieve a list of the accounts (organization and personal) that have installed your app. But this authentication method doesn't allow you to do much with the API. To access a repository's data and perform operations on behalf of the installation, you need to authenticate as an installation. To do that, you'll need to authenticate as a GitHub App first to request an installation access token. For more information, see About authentication with a GitHub App.
Before you can use the Octokit.rb library to make API calls, you'll need to initialize an Octokit client authenticated as a GitHub App, using the authenticate_app helper method.
# Instantiate an Octokit client authenticated as a GitHub App.
# GitHub App authentication requires that you construct a
# JWT (https://jwt.io/introduction/) signed with the app's private key,
# so GitHub can be sure that it came from the app an not altered by
# a malicious third party.
def authenticate_app
  payload = {
      # The time that this JWT was issued, _i.e._ now.
      iat: Time.now.to_i,

      # JWT expiration time (10 minute maximum)
      exp: Time.now.to_i + (10 * 60),

      # Your GitHub App's identifier number
      iss: APP_IDENTIFIER
  }

  # Cryptographically sign the JWT
  jwt = JWT.encode(payload, PRIVATE_KEY, 'RS256')

  # Create the Octokit client, using the JWT as the auth token.
  @app_client ||= Octokit::Client.new(bearer_token: jwt)
end

The code above generates a JSON Web Token (JWT) and uses it (along with your app's private key) to initialize the Octokit client. GitHub checks a request's authentication by verifying the token with the app's stored public key. To learn more about how this code works, see Generating a JSON Web Token (JWT) for a GitHub App.
Authenticating as an installation
The fourth and final helper method, authenticate_installation, initializes an Octokit client authenticated as an installation, which you can use to make authenticated calls to the API.
An installation refers to any user or organization account that has installed the app. Even if someone grants the app access to more than one repository on that account, it only counts as one installation because it's within the same account.
# Instantiate an Octokit client authenticated as an installation of a
# GitHub App to run API operations.
def authenticate_installation(payload)
  installation_id = payload['installation']['id']
  installation_token = @app_client.create_app_installation_access_token(installation_id)[:token]
  @installation_client = Octokit::Client.new(bearer_token: installation_token)
end

The create_app_installation_access_token Octokit method creates an installation token. For more information, see create_installation_access_token in the Octokit documentation.
This method accepts two arguments:

Installation (integer): The ID of a GitHub App installation
Options (hash, defaults to {}): A customizable set of options

Any time a GitHub App receives a webhook, it includes an installation object with an id. Using the client authenticated as a GitHub App, you pass this ID to the create_app_installation_access_token method to generate an access token for each installation. Since you're not passing any options to the method, the options default to an empty hash. The response for create_app_installation_access_token includes two fields: token and expired_at. The template code selects the token in the response and initializes an installation client.
With this method in place, each time your app receives a new webhook payload, it creates a client for the installation that triggered the event. This authentication process enables your GitHub App to work for all installations on any account.
Start the server
Your app doesn't do anything yet, but at this point, you can get it running on the server.


In your terminal, make sure that Smee is still running. For more information, see Get a webhook proxy URL.


Open a new tab in your terminal, and cd into the directory where you cloned the repository that you created earlier in the tutorial. For more information, see Create a repository to store code for your GitHub App. The Ruby code in this repository will start up a Sinatra web server.


Install the dependencies by running the following two commands one after the other:
Shellgem install bundler
gem install bundler

Shellbundle install
bundle install



After installing the dependencies, start the server by running this command:
Shellbundle exec ruby server.rb
bundle exec ruby server.rb

You should see a response like this:
> == Sinatra (v2.2.3) has taken the stage on 3000 for development with backup from Puma
> Puma starting in single mode...
> * Puma version: 6.3.0 (ruby 3.1.2-p20) ("Mugi No Toki Itaru")
> *  Min threads: 0
> *  Max threads: 5
> *  Environment: development
> *          PID: 14915
> * Listening on http://0.0.0.0:3000
> Use Ctrl-C to stop

If you see an error, make sure you've created the .env file in the directory that contains server.rb.


To test the server, navigate in your browser to http://localhost:3000.
If you see an error page that says "Sinatra doesn't know this ditty," the app is working as expected. Even though it's an error page, it's a Sinatra error page, which means your app is connected to the server as expected. You're seeing this message because you haven't given the app anything else to show.


Test that the server is listening to your app
You can test that the server is listening to your app by triggering an event for it to receive. You'll do that by installing the app on a test repository, which will send the installation event to your app. If the app receives it, you should see output in the terminal tab where you're running server.rb.


Create a new repository to use for testing your tutorial code. For more information, see Creating a new repository.


Install the GitHub App on the repository you just created. For more information, see Installing your own GitHub App. During the installation process, choose Only select repositories, and select the repository you created in the previous step.


After you click Install, look at the output in the terminal tab where you're running server.rb. You should see something like this:
> D, [2023-06-08T15:45:43.773077 #30488] DEBUG -- : ---- received event installation
> D, [2023-06-08T15:45:43.773141 #30488]] DEBUG -- : ----    action created
> 192.30.252.44 - - [08/Jun/2023:15:45:43 -0400] "POST /event_handler HTTP/1.1" 200 - 0.5390

If you see output like this, it means your app received a notification that it was installed on your GitHub account. The app is running on the server as expected.
If you don't see this output, make sure Smee is running correctly in another terminal tab. If you need to restart Smee, note that you'll also need to uninstall and reinstall the app to send the installation event to your app again and see the output in terminal.


If you're wondering where the terminal output above is coming from, it's written in the app template code you added to server.rb in Add code for your GitHub App.
Part 1. Creating the Checks API interface
In this part, you will add the code necessary to receive check_suite webhook events, and create and update check runs. You'll also learn how to create check runs when a check was re-requested on GitHub. At the end of this section, you'll be able to view the check run you created in a GitHub pull request.
Your check run will not perform any checks on the code in this section. You'll add that functionality in Part 2: Creating a CI test.
You should already have a Smee channel configured that is forwarding webhook payloads to your local server. Your server should be running and connected to the GitHub App you registered and installed on a test repository.
These are the steps you'll complete in Part 1:

Add event handling
Create a check run
Update a check run

Step 1.1. Add event handling
Because your app is subscribed to the Check suite and Check run events, it will receive the check_suite and check_run webhooks. GitHub sends webhook payloads as POST requests. Because you forwarded your Smee webhook payloads to http://localhost:3000/event_handler, your server will receive the POST request payloads at the post '/event_handler' route.
Open the server.rb file that you created in Add code for your GitHub App, and look for the following code. An empty post '/event_handler' route is already included in the template code. The empty route looks like this:
  post '/event_handler' do

    # ADD EVENT HANDLING HERE #

    200 # success status
  end

In the code block that starts with post '/event_handler' do, where it says # ADD EVENT HANDLING HERE #, add the following code. This route will handle the check_suite event.
Ruby    # Get the event type from the HTTP_X_GITHUB_EVENT header
    case request.env['HTTP_X_GITHUB_EVENT']
    when 'check_suite'
      # A new check_suite has been created. Create a new check run with status queued
      if @payload['action'] == 'requested' || @payload['action'] == 'rerequested'
        create_check_run
      end
      # ADD CHECK_RUN METHOD HERE #
    end
    # Get the event type from the HTTP_X_GITHUB_EVENT header
    case request.env['HTTP_X_GITHUB_EVENT']
    when 'check_suite'
      # A new check_suite has been created. Create a new check run with status queued
      if @payload['action'] == 'requested' || @payload['action'] == 'rerequested'
        create_check_run
      end
      # ADD CHECK_RUN METHOD HERE #
    end

Every event that GitHub sends includes a request header called HTTP_X_GITHUB_EVENT, which indicates the type of event in the POST request. Right now, you're only interested in events of type check_suite, which are emitted when a new check suite is created. Each event has an additional action field that indicates the type of action that triggered the events. For check_suite, the action field can be requested, rerequested, or completed.
The requested action requests a check run each time code is pushed to the repository, while the rerequested action requests that you re-run a check for code that already exists in the repository. Because both the requested and rerequested actions require creating a check run, you'll call a helper called create_check_run. Let's write that method now.
Step 1.2. Create a check run
You'll add this new method as a Sinatra helper in case you want other routes to use it too.
In the code block that starts with helpers do, where it says # ADD CREATE_CHECK_RUN HELPER METHOD HERE #, add the following code:
Ruby    # Create a new check run with status "queued"
    def create_check_run
      @installation_client.create_check_run(
        # [String, Integer, Hash, Octokit Repository object] A GitHub repository.
        @payload['repository']['full_name'],
        # [String] The name of your check run.
        'Octo RuboCop',
        # [String] The SHA of the commit to check
        # The payload structure differs depending on whether a check run or a check suite event occurred.
        @payload['check_run'].nil? ? @payload['check_suite']['head_sha'] : @payload['check_run']['head_sha'],
        # [Hash] 'Accept' header option, to avoid a warning about the API not being ready for production use.
        accept: 'application/vnd.github+json'
      )
    end
    # Create a new check run with status "queued"
    def create_check_run
      @installation_client.create_check_run(
        # [String, Integer, Hash, Octokit Repository object] A GitHub repository.
        @payload['repository']['full_name'],
        # [String] The name of your check run.
        'Octo RuboCop',
        # [String] The SHA of the commit to check
        # The payload structure differs depending on whether a check run or a check suite event occurred.
        @payload['check_run'].nil? ? @payload['check_suite']['head_sha'] : @payload['check_run']['head_sha'],
        # [Hash] 'Accept' header option, to avoid a warning about the API not being ready for production use.
        accept: 'application/vnd.github+json'
      )
    end

This code calls the POST /repos/{owner}/{repo}/check-runs endpoint using the Octokit create_check_run method. For more information about the endpoint, see REST API endpoints for check runs.
To create a check run, only two input parameters are required: name and head_sha. In this code, we name the check run "Octo RuboCop," because we'll use RuboCop to implement the CI test later in the tutorial. But you can choose any name you'd like for the check run. For more information about RuboCop, see the RuboCop documentation.
You're only supplying the required parameters now to get the basic functionality working, but you'll update the check run later as you collect more information about the check run. By default, GitHub sets the status to queued.
GitHub creates a check run for a specific commit SHA, which is why head_sha is a required parameter. You can find the commit SHA in the webhook payload. Although you're only creating a check run for the check_suite event right now, it's good to know that the head_sha is included in both the check_suite and check_run objects in the event payloads.
The code above uses a ternary operator, which works like an if/else statement, to check if the payload contains a check_run object. If it does, you read the head_sha from the check_run object, otherwise you read it from the check_suite object.
Test the code
The following steps will show you how to test that the code works, and that it successfully creates a new check run.


Run the following command to restart the server from your terminal. If the server is already running, first enter Ctrl-C in your terminal to stop the server, and then run the following command to start the server again.
Shellruby server.rb
ruby server.rb



Create a pull request in the test repository you created in Test that the server is listening to your app. This is the repository that you granted the app access to.


In the pull request you just created, navigate to the Checks tab. You should see a check run with the name "Octo RuboCop," or whichever name you chose earlier for the check run.


If you see other apps in the Checks tab, it means you have other apps installed on your repository that have Read & write access to checks and are subscribed to Check suite and Check run events. It may also mean that you have GitHub Actions workflows on the repository that are triggered by the pull_request or pull_request_target event.
So far you've told GitHub to create a check run. The check run status in the pull request is set to queued with a yellow icon. In the next step, you will wait for GitHub to create the check run and update its status.
Step 1.3. Update a check run
When your create_check_run method runs, it asks GitHub to create a new check run. When GitHub finishes creating the check run, you'll receive the check_run webhook event with the created action. That event is your signal to begin running the check.
You'll update your event handler to look for the created action. While you're updating the event handler, you can add a conditional for the rerequested action. When someone re-runs a single test on GitHub by clicking the "Re-run" button, GitHub sends the rerequested check run event to your app. When a check run is rerequested, you'll start the process all over and create a new check run. To do that, you'll include a condition for the check_run event in the post '/event_handler' route.
In the code block that starts with post '/event_handler' do, where it says # ADD CHECK_RUN METHOD HERE #, add the following code:
Ruby    when 'check_run'
      # Check that the event is being sent to this app
      if @payload['check_run']['app']['id'].to_s === APP_IDENTIFIER
        case @payload['action']
        when 'created'
          initiate_check_run
        when 'rerequested'
          create_check_run
        # ADD REQUESTED_ACTION METHOD HERE #
        end
      end
    when 'check_run'
      # Check that the event is being sent to this app
      if @payload['check_run']['app']['id'].to_s === APP_IDENTIFIER
        case @payload['action']
        when 'created'
          initiate_check_run
        when 'rerequested'
          create_check_run
        # ADD REQUESTED_ACTION METHOD HERE #
        end
      end

GitHub sends all events for created check runs to every app installed on a repository that has the necessary checks permissions. That means that your app will receive check runs created by other apps. A created check run is a little different from a requested or rerequested check suite, which GitHub sends only to apps that are being requested to run a check. The code above looks for the check run's application ID. This filters out all check runs for other apps on the repository.
Next you'll write the initiate_check_run method, which is where you'll update the check run status and prepare to kick off your CI test.
In this section, you're not going to kick off the CI test yet, but you'll walk through how to update the status of the check run from queued to pending and then from pending to completed to see the overall flow of a check run. In Part 2: Creating a CI test, you'll add the code that actually performs the CI test.
Let's create the initiate_check_run method and update the status of the check run.
In the code block that starts with helpers do, where it says # ADD INITIATE_CHECK_RUN HELPER METHOD HERE #, add the following code:
Ruby    # Start the CI process
    def initiate_check_run
      # Once the check run is created, you'll update the status of the check run
      # to 'in_progress' and run the CI process. When the CI finishes, you'll
      # update the check run status to 'completed' and add the CI results.

      @installation_client.update_check_run(
        @payload['repository']['full_name'],
        @payload['check_run']['id'],
        status: 'in_progress',
        accept: 'application/vnd.github+json'
      )

      # ***** RUN A CI TEST *****

      # Mark the check run as complete!
      @installation_client.update_check_run(
        @payload['repository']['full_name'],
        @payload['check_run']['id'],
        status: 'completed',
        conclusion: 'success',
        accept: 'application/vnd.github+json'
      )

    end
    # Start the CI process
    def initiate_check_run
      # Once the check run is created, you'll update the status of the check run
      # to 'in_progress' and run the CI process. When the CI finishes, you'll
      # update the check run status to 'completed' and add the CI results.

      @installation_client.update_check_run(
        @payload['repository']['full_name'],
        @payload['check_run']['id'],
        status: 'in_progress',
        accept: 'application/vnd.github+json'
      )

      # ***** RUN A CI TEST *****

      # Mark the check run as complete!
      @installation_client.update_check_run(
        @payload['repository']['full_name'],
        @payload['check_run']['id'],
        status: 'completed',
        conclusion: 'success',
        accept: 'application/vnd.github+json'
      )

    end

The code above calls the PATCH /repos/{owner}/{repo}/check-runs/{check_run_id} endpoint using the update_check_run Octokit method, and updates the check run that you already created. For more information about the endpoint, see REST API endpoints for check runs.
Here's what this code is doing. First, it updates the check run's status to in_progress and implicitly sets the started_at time to the current time. In Part 2 of this tutorial, you'll add code that kicks off a real CI test under ***** RUN A CI TEST *****. For now, you'll leave that section as a placeholder, so the code that follows it will just simulate that the CI process succeeds and all tests pass. Finally, the code updates the status of the check run again to completed.
When you use the REST API to provide a check run status of completed, the conclusion and completed_at parameters are required. The conclusion summarizes the outcome of a check run and can be success, failure, neutral, cancelled, timed_out, skipped, or action_required. You'll set the conclusion to success, the completed_at time to the current time, and the status to completed.
You could also provide more details about what your check is doing, but you'll get to that in the next section.
Test the code
The following steps will show you how to test that the code works, and that the new "Re-run all" button you created works.


Run the following command to restart the server from your terminal. If the server is already running, first enter Ctrl-C in your terminal to stop the server, and then run the following command to start the server again.
Shellruby server.rb
ruby server.rb



Create a pull request in the test repository you created in Test that the server is listening to your app. This is the repository that you granted the app access to.


In the pull request you just created, navigate to the Checks tab. You should see a "Re-run all" button.


Click the "Re-run all" button in the upper right corner. The test should run again, and end with success.


Part 2. Creating a CI test
Now that you've got the interface created to receive API events and create check runs, you can create a check run that implements a CI test.
RuboCop is a Ruby code linter and formatter. It checks Ruby code to ensure that it complies with the Ruby Style Guide. For more information, see the RuboCop documentation.
RuboCop has three primary functions:

Linting to check code style
Code formatting
Replaces the native Ruby linting capabilities using ruby -w

Your app will run RuboCop on the CI server, and create check runs (CI tests in this case) that report the results that RuboCop reports to GitHub.
The REST API allows you to report rich details about each check run, including statuses, images, summaries, annotations, and requested actions.
Annotations are information about specific lines of code in a repository. An annotation allows you to pinpoint and visualize the exact parts of the code you'd like to show additional information for. For example, you could show that information as a comment, error, or warning on a specific line of code. This tutorial uses annotations to visualize RuboCop errors.
To take advantage of requested actions, app developers can create buttons in the Checks tab of pull requests. When someone clicks one of these buttons, the click sends a requested_action check_run event to the GitHub App. The action that the app takes is completely configurable by the app developer. This tutorial will walk you through adding a button that allows users to request that RuboCop fix the errors it finds. RuboCop supports automatically fixing errors using a command-line option, and you'll configure the requested_action to take advantage of this option.
These are the steps you'll complete in this section:

Add a Ruby file
Allow RuboCop to clone the test repository
Run RuboCop
Collect RuboCop errors
Update the check run with CI test results
Automatically fix RuboCop errors

Step 2.1. Add a Ruby file
You can pass specific files or entire directories for RuboCop to check. In this tutorial, you'll run RuboCop on an entire directory. RuboCop only checks Ruby code. To test your GitHub App, you'll need to add a Ruby file in your repository that contains errors for RuboCop to find. After adding the following Ruby file to your repository, you will update your CI check to run RuboCop on the code.


Navigate to the test repository you created in Test that the server is listening to your app. This is the repository that you granted the app access to.


Create a new file named myfile.rb. For more information, see Creating new files.


Add the following content to myfile.rb:
Ruby# frozen_string_literal: true

# The Octocat class tells you about different breeds of Octocat
class Octocat
  def initialize(name, *breeds)
    # Instance variables
    @name = name
    @breeds = breeds
  end

  def display
    breed = @breeds.join("-")

    puts "I am of #{breed} breed, and my name is #{@name}."
  end
end

m = Octocat.new("Mona", "cat", "octopus")
m.display
# frozen_string_literal: true

# The Octocat class tells you about different breeds of Octocat
class Octocat
  def initialize(name, *breeds)
    # Instance variables
    @name = name
    @breeds = breeds
  end

  def display
    breed = @breeds.join("-")

    puts "I am of #{breed} breed, and my name is #{@name}."
  end
end

m = Octocat.new("Mona", "cat", "octopus")
m.display



If you created the file locally, make sure you commit and push the file to your repository on GitHub.


Step 2.2. Allow RuboCop to clone the test repository
RuboCop is available as a command-line utility. That means, if you want to run RuboCop on a repository, your GitHub App will need to clone a local copy of the repository on the CI server so RuboCop can parse the files. To do that, your code will need to be able to run Git operations, and your GitHub App will need to have the correct permissions to clone a repository.
Allow Git operations
To run Git operations in your Ruby app, you can use the ruby-git gem. The Gemfile you created in Setup already includes the ruby-git gem, and you installed it when you ran bundle install in Start the server.
Now, at the top of your server.rb file, below the other require items, add the following code:
Rubyrequire 'git'
require 'git'

Update your app permissions
Next you'll need to update your GitHub App's permissions. Your app will need read permission for "Contents" to clone a repository. And later in this tutorial, it will need write permission to push contents to GitHub. To update your app's permissions:

Select your app from the app settings page, and click Permissions & events in the sidebar.
Under "Repository permissions", next to "Contents", select Read & write.
Click Save changes at the bottom of the page.
If you've installed the app on your account, check your email and follow the link to accept the new permissions. Any time you change your app's permissions or webhooks, users who have installed the app (including yourself) will need to accept the new permissions before the changes take effect. You can also accept the new permissions by navigating to your installations page. You'll see a link under the app name, letting you know that the app is requesting different permissions. Click Review request, and then click Accept new permissions.

Add code to clone a repository
To clone a repository, the code will use your GitHub App's permissions and the Octokit SDK to create an installation token for your app (x-access-token:TOKEN) and use it in the following clone command:
git clone https://x-access-token:TOKEN@github.com/OWNER/REPO.git

The command above clones a repository over HTTPS. It requires the full repository name, which includes the repository owner (user or organization) and the repository name. For example, the octocat Hello-World repository has a full name of octocat/hello-world.
Open your server.rb file. In the code block that starts with helpers do, where it says # ADD CLONE_REPOSITORY HELPER METHOD HERE #, add the following code:
Ruby    # Clones the repository to the current working directory, updates the
    # contents using Git pull, and checks out the ref.
    #
    # full_repo_name  - The owner and repo. Ex: octocat/hello-world
    # repository      - The repository name
    # ref             - The branch, commit SHA, or tag to check out
    def clone_repository(full_repo_name, repository, ref)
      @git = Git.clone("https://x-access-token:#{@installation_token.to_s}@github.com/#{full_repo_name}.git", repository)
      pwd = Dir.getwd()
      Dir.chdir(repository)
      @git.pull
      @git.checkout(ref)
      Dir.chdir(pwd)
    end
    # Clones the repository to the current working directory, updates the
    # contents using Git pull, and checks out the ref.
    #
    # full_repo_name  - The owner and repo. Ex: octocat/hello-world
    # repository      - The repository name
    # ref             - The branch, commit SHA, or tag to check out
    def clone_repository(full_repo_name, repository, ref)
      @git = Git.clone("https://x-access-token:#{@installation_token.to_s}@github.com/#{full_repo_name}.git", repository)
      pwd = Dir.getwd()
      Dir.chdir(repository)
      @git.pull
      @git.checkout(ref)
      Dir.chdir(pwd)
    end

The code above uses the ruby-git gem to clone the repository using the app's installation token. It clones the code in the same directory as server.rb. To run Git commands in the repository, the code needs to change into the repository directory. Before changing directories, the code stores the current working directory in a variable (pwd) to remember where to return before exiting the clone_repository method.
From the repository directory, this code fetches and merges the latest changes (@git.pull), and checks out the specific Git ref (@git.checkout(ref)). The code to do all of this fits nicely into its own method. To perform these operations, the method needs the name and full name of the repository and the ref to checkout. The ref can be a commit SHA, branch, or tag. When it's done, the code changes the directory back to the original working directory (pwd).
Now you've got a method that clones a repository and checks out a ref. Next, you need to add code to get the required input parameters and call the new clone_repository method.
In the code block that starts with helpers do, in the initiate_check_run helper method where it says # ***** RUN A CI TEST *****, add the following code:
Ruby    full_repo_name = @payload['repository']['full_name']
    repository     = @payload['repository']['name']
    head_sha       = @payload['check_run']['head_sha']

    clone_repository(full_repo_name, repository, head_sha)

    # ADD CODE HERE TO RUN RUBOCOP #
    full_repo_name = @payload['repository']['full_name']
    repository     = @payload['repository']['name']
    head_sha       = @payload['check_run']['head_sha']

    clone_repository(full_repo_name, repository, head_sha)

    # ADD CODE HERE TO RUN RUBOCOP #

The code above gets the full repository name and the head SHA of the commit from the check_run webhook payload.
Step 2.3. Run RuboCop
So far, your code clones the repository and creates check runs using your CI server. Now you'll get into the details of the RuboCop linter and checks annotations.
First, you'll add code to run RuboCop and save the style code errors in JSON format.
In the code block that starts with helpers do, find the initiate_check_run helper method. Inside that helper method, under clone_repository(full_repo_name, repository, head_sha), where it says # ADD CODE HERE TO RUN RUBOCOP #, add the following code:
Ruby        # Run RuboCop on all files in the repository
        @report = `rubocop '#{repository}' --format json`
        logger.debug @report
        `rm -rf #{repository}`
        @output = JSON.parse @report

        # ADD ANNOTATIONS CODE HERE #
        # Run RuboCop on all files in the repository
        @report = `rubocop '#{repository}' --format json`
        logger.debug @report
        `rm -rf #{repository}`
        @output = JSON.parse @report

        # ADD ANNOTATIONS CODE HERE #

The code above runs RuboCop on all files in the repository's directory. The option --format json saves a copy of the linting results in a machine-parsable format. For more information, and an example of the JSON format, see JSON Formatter in the RuboCop docs. This code also parses the JSON so you can easily access the keys and values in your GitHub App using the @output variable.
After running RuboCop and saving the linting results, this code runs the command rm -rf to remove the checkout of the repository. Because the code stores the RuboCop results in a @report variable, it can safely remove the checkout of the repository.
The rm -rf command cannot be undone. To keep your app secure, the code in this tutorial checks incoming webhooks for injected malicious commands that could be used to remove a different directory than intended by your app. For example, if a bad actor sent a webhook with the repository name ./, your app would remove the root directory. The verify_webhook_signature method validates the sender of the webhook. The verify_webhook_signature event handler also checks that the repository name is valid. For more information, see Define a before filter.
Test the code
The following steps will show you how to test that the code works and view the errors reported by RuboCop.


Run the following command to restart the server from your terminal. If the server is already running, first enter Ctrl-C in your terminal to stop the server, and then run the following command to start the server again.
Shellruby server.rb
ruby server.rb



In the repository where you added the myfile.rb file, create a new pull request.


In your terminal tab where the server is running, you should see debug output that contains linting errors. The linting errors are printed without any formatting. You can copy and paste your debug output into a web tool like JSON formatter, to format your JSON output like the following example:
{
  "metadata": {
    "rubocop_version": "0.60.0",
    "ruby_engine": "ruby",
    "ruby_version": "2.3.7",
    "ruby_patchlevel": "456",
    "ruby_platform": "universal.x86_64-darwin18"
  },
  "files": [
    {
      "path": "Octocat-breeds/octocat.rb",
      "offenses": [
        {
          "severity": "convention",
          "message": "Style/StringLiterals: Prefer single-quoted strings when you don't need string interpolation or special symbols.",
          "cop_name": "Style/StringLiterals",
          "corrected": false,
          "location": {
            "start_line": 17,
            "start_column": 17,
            "last_line": 17,
            "last_column": 22,
            "length": 6,
            "line": 17,
            "column": 17
          }
        },
        {
          "severity": "convention",
          "message": "Style/StringLiterals: Prefer single-quoted strings when you don't need string interpolation or special symbols.",
          "cop_name": "Style/StringLiterals",
          "corrected": false,
          "location": {
            "start_line": 17,
            "start_column": 25,
            "last_line": 17,
            "last_column": 29,
            "length": 5,
            "line": 17,
            "column": 25
          }
        }
      ]
    }
  ],
  "summary": {
    "offense_count": 2,
    "target_file_count": 1,
    "inspected_file_count": 1
  }
}



Step 2.4. Collect RuboCop errors
The @output variable contains the parsed JSON results of the RuboCop report. As shown in the example output in the previous step, the results contain a summary section that your code can use to quickly determine if there are any errors. The following code will set the check run conclusion to success when there are no reported errors. RuboCop reports errors for each file in the files array, so if there are errors, you'll need to extract some data from the file object.
The REST API endpoints to manage check runs allow you to create annotations for specific lines of code. When you create or update a check run, you can add annotations. In this tutorial you will update the check run with annotations, using the PATCH /repos/{owner}/{repo}/check-runs/{check_run_id} endpoint. For more information about the endpoint, see REST API endpoints for check runs.
The API limits the number of annotations to a maximum of 50 per request. To create more than 50 annotations, you will have to make multiple requests to the "Update a check run" endpoint. For example, to create 105 annotations you would need to make three separate requests to the API. The first two requests would each have 50 annotations, and the third request would include the five remaining annotations. Each time you update the check run, annotations are appended to the list of annotations that already exist for the check run.
A check run expects annotations as an array of objects. Each annotation object must include the path, start_line, end_line, annotation_level, and message. RuboCop provides the start_column and end_column too, so you can include those optional parameters in the annotation. Annotations only support start_column and end_column on the same line. For more information, see the annotations object in REST API endpoints for check runs.
Now you'll add code to extract the required information from RuboCop that's needed to create each annotation.
Under the code you added in the previous step, where it says # ADD ANNOTATIONS CODE HERE #, add the following code:
Ruby    annotations = []
    # You can create a maximum of 50 annotations per request to the Checks
    # API. To add more than 50 annotations, use the "Update a check run" API
    # endpoint. This example code limits the number of annotations to 50.
    # See /rest/reference/checks#update-a-check-run
    # for details.
    max_annotations = 50

    # RuboCop reports the number of errors found in "offense_count"
    if @output['summary']['offense_count'] == 0
      conclusion = 'success'
    else
      conclusion = 'neutral'
      @output['files'].each do |file|

        # Only parse offenses for files in this app's repository
        file_path = file['path'].gsub(/#{repository}\//,'')
        annotation_level = 'notice'

        # Parse each offense to get details and location
        file['offenses'].each do |offense|
          # Limit the number of annotations to 50
          next if max_annotations == 0
          max_annotations -= 1

          start_line   = offense['location']['start_line']
          end_line     = offense['location']['last_line']
          start_column = offense['location']['start_column']
          end_column   = offense['location']['last_column']
          message      = offense['message']

          # Create a new annotation for each error
          annotation = {
            path: file_path,
            start_line: start_line,
            end_line: end_line,
            start_column: start_column,
            end_column: end_column,
            annotation_level: annotation_level,
            message: message
          }
          # Annotations only support start and end columns on the same line
          if start_line == end_line
            annotation.merge({start_column: start_column, end_column: end_column})
          end

          annotations.push(annotation)
        end
      end
    end

    # ADD CODE HERE TO UPDATE CHECK RUN SUMMARY #
    annotations = []
    # You can create a maximum of 50 annotations per request to the Checks
    # API. To add more than 50 annotations, use the "Update a check run" API
    # endpoint. This example code limits the number of annotations to 50.
    # See /rest/reference/checks#update-a-check-run
    # for details.
    max_annotations = 50

    # RuboCop reports the number of errors found in "offense_count"
    if @output['summary']['offense_count'] == 0
      conclusion = 'success'
    else
      conclusion = 'neutral'
      @output['files'].each do |file|

        # Only parse offenses for files in this app's repository
        file_path = file['path'].gsub(/#{repository}\//,'')
        annotation_level = 'notice'

        # Parse each offense to get details and location
        file['offenses'].each do |offense|
          # Limit the number of annotations to 50
          next if max_annotations == 0
          max_annotations -= 1

          start_line   = offense['location']['start_line']
          end_line     = offense['location']['last_line']
          start_column = offense['location']['start_column']
          end_column   = offense['location']['last_column']
          message      = offense['message']

          # Create a new annotation for each error
          annotation = {
            path: file_path,
            start_line: start_line,
            end_line: end_line,
            start_column: start_column,
            end_column: end_column,
            annotation_level: annotation_level,
            message: message
          }
          # Annotations only support start and end columns on the same line
          if start_line == end_line
            annotation.merge({start_column: start_column, end_column: end_column})
          end

          annotations.push(annotation)
        end
      end
    end

    # ADD CODE HERE TO UPDATE CHECK RUN SUMMARY #

This code limits the total number of annotations to 50. But you can modify this code to update the check run for each batch of 50 annotations. The code above includes the variable max_annotations that sets the limit to 50, which is used in the loop that iterates through the offenses.
When the offense_count is zero, the CI test is a success. If there are errors, this code sets the conclusion to neutral in order to prevent strictly enforcing errors from code linters. But you can change the conclusion to failure if you would like to ensure that the check suite fails when there are linting errors.
When errors are reported, the code above iterates through the files array in the RuboCop report. For each file, it extracts the file path and sets the annotation level to notice. You could go even further and set specific warning levels for each type of RuboCop Cop, but to keep things simpler in this tutorial, all errors are set to a level of notice.
This code also iterates through each error in the offenses array and collects the location of the offense and error message. After extracting the information needed, the code creates an annotation for each error and stores it in the annotations array. Because annotations only support start and end columns on the same line, start_column and end_column are only added to the annotation object if the start and end line values are the same.
This code doesn't yet create an annotation for the check run. You'll add that code in the next section.
Step 2.5. Update the check run with CI test results
Each check run from GitHub contains an output object that includes a title, summary, text, annotations, and images. The summary and title are the only required parameters for the output, but those alone don't offer much detail, so this tutorial also adds text and annotations.
For the summary, this example uses the summary information from RuboCop and adds newlines (\n) to format the output. You can customize what you add to the text parameter, but this example sets the text parameter to the RuboCop version. The following code sets the summary and text.
Under the code you added in the previous step, where it says # ADD CODE HERE TO UPDATE CHECK RUN SUMMARY #, add the following code:
Ruby        # Updated check run summary and text parameters
        summary = "Octo RuboCop summary\n-Offense count: #{@output['summary']['offense_count']}\n-File count: #{@output['summary']['target_file_count']}\n-Target file count: #{@output['summary']['inspected_file_count']}"
        text = "Octo RuboCop version: #{@output['metadata']['rubocop_version']}"
        # Updated check run summary and text parameters
        summary = "Octo RuboCop summary\n-Offense count: #{@output['summary']['offense_count']}\n-File count: #{@output['summary']['target_file_count']}\n-Target file count: #{@output['summary']['inspected_file_count']}"
        text = "Octo RuboCop version: #{@output['metadata']['rubocop_version']}"

Now your code should have all the information it needs to update your check run. In Step 1.3. Update a check run, you added code to set the status of the check run to success. You'll need to update that code to use the conclusion variable you set based on the RuboCop results (to success or neutral). Here's the code you added previously to your server.rb file:
# Mark the check run as complete!
@installation_client.update_check_run(
  @payload['repository']['full_name'],
  @payload['check_run']['id'],
  status: 'completed',
  conclusion: 'success',
  accept: 'application/vnd.github+json'
)

Replace that code with the following code:
Ruby        # Mark the check run as complete! And if there are warnings, share them.
        @installation_client.update_check_run(
          @payload['repository']['full_name'],
          @payload['check_run']['id'],
          status: 'completed',
          conclusion: conclusion,
          output: {
            title: 'Octo RuboCop',
            summary: summary,
            text: text,
            annotations: annotations
          },
          actions: [{
            label: 'Fix this',
            description: 'Automatically fix all linter notices.',
            identifier: 'fix_rubocop_notices'
          }],
          accept: 'application/vnd.github+json'
        )
        # Mark the check run as complete! And if there are warnings, share them.
        @installation_client.update_check_run(
          @payload['repository']['full_name'],
          @payload['check_run']['id'],
          status: 'completed',
          conclusion: conclusion,
          output: {
            title: 'Octo RuboCop',
            summary: summary,
            text: text,
            annotations: annotations
          },
          actions: [{
            label: 'Fix this',
            description: 'Automatically fix all linter notices.',
            identifier: 'fix_rubocop_notices'
          }],
          accept: 'application/vnd.github+json'
        )

Now that your code sets a conclusion based on the status of the CI test, and adds the output from the RuboCop results, you've created a CI test.
The code above also adds a feature called requested actions to your CI server, via the actions object. (Note this is not related to GitHub Actions.) For more information, see Request further actions from a check run. Requested actions add a button in the Checks tab on GitHub that allows someone to request the check run to take additional action. The additional action is completely configurable by your app. For example, because RuboCop has a feature to automatically fix the errors it finds in Ruby code, your CI server can use a requested actions button to allow people to request automatic error fixes. When someone clicks the button, the app receives the check_run event with a requested_action action. Each requested action has an identifier that the app uses to determine which button was clicked.
The code above doesn't have RuboCop automatically fix errors yet. You'll add that later in the tutorial.
Test the code
The following steps will show you how to test that the code works and view the CI test that you just created.


Run the following command to restart the server from your terminal. If the server is already running, first enter Ctrl-C in your terminal to stop the server, and then run the following command to start the server again.
Shellruby server.rb
ruby server.rb



In the repository where you added the myfile.rb file, create a new pull request.


In the pull request you just created, navigate to the Checks tab. You should see annotations for each of the errors that RuboCop found. Also notice the "Fix this" button that you created by adding a requested action.


Step 2.6. Automatically fix RuboCop errors
So far you've created a CI test. In this section, you'll add one more feature that uses RuboCop to automatically fix the errors it finds. You already added the "Fix this" button in Step 2.5. Update the check run with CI test results. Now you'll add the code to handle the requested_action check run event that's triggered when someone clicks the "Fix this" button.
The RuboCop tool offers the --auto-correct command-line option to automatically fix the errors it finds. For more information, see Autocorrecting offenses in the RuboCop documentation. When you use the --auto-correct feature, the updates are applied to the local files on the server. You'll need to push the changes to GitHub after RuboCop makes the fixes.
To push to a repository, your app must have write permissions for "Contents" in a repository. You already set that permission to Read & write back in Step 2.2. Allow RuboCop to clone the test repository.
To commit files, Git must know which username and email address to associate with the commit. Next you'll add environment variables to store the name and email address that your app will use when it makes Git commits.


Open the .env file you created earlier in this tutorial.


Add the following environment variables to your .env file. Replace APP_NAME with the name of your app, and EMAIL_ADDRESS with any email you'd like to use for this example.
ShellGITHUB_APP_USER_NAME="APP_NAME"
GITHUB_APP_USER_EMAIL="EMAIL_ADDRESS"
GITHUB_APP_USER_NAME="APP_NAME"
GITHUB_APP_USER_EMAIL="EMAIL_ADDRESS"



Next you'll need to add code to read the environment variables and set the Git configuration. You'll add that code soon.
When someone clicks the "Fix this" button, your app receives the check run webhook with the requested_action action type.
In Step 1.3. Update a check run you updated the event_handler in your server.rb file to look for actions in the check_run event. You already have a case statement to handle the created and rerequested action types:
when 'check_run'
  # Check that the event is being sent to this app
  if @payload['check_run']['app']['id'].to_s === APP_IDENTIFIER
    case @payload['action']
    when 'created'
      initiate_check_run
    when 'rerequested'
      create_check_run
    # ADD REQUESTED_ACTION METHOD HERE #
  end
end

After the rerequested case, where it says # ADD REQUESTED_ACTION METHOD HERE #, add the following code:
Ruby    when 'requested_action'
      take_requested_action
    when 'requested_action'
      take_requested_action

This code calls a new method that will handle all requested_action events for your app.
In the code block that starts with helpers do, where it says # ADD TAKE_REQUESTED_ACTION HELPER METHOD HERE #, add the following helper method:
Ruby    # Handles the check run `requested_action` event
    # See /webhooks/event-payloads/#check_run
    def take_requested_action
      full_repo_name = @payload['repository']['full_name']
      repository     = @payload['repository']['name']
      head_branch    = @payload['check_run']['check_suite']['head_branch']

      if (@payload['requested_action']['identifier'] == 'fix_rubocop_notices')
        clone_repository(full_repo_name, repository, head_branch)

        # Sets your commit username and email address
        @git.config('user.name', ENV['GITHUB_APP_USER_NAME'])
        @git.config('user.email', ENV['GITHUB_APP_USER_EMAIL'])

        # Automatically correct RuboCop style errors
        @report = `rubocop '#{repository}/*' --format json --auto-correct`

        pwd = Dir.getwd()
        Dir.chdir(repository)
        begin
          @git.commit_all('Automatically fix Octo RuboCop notices.')
          @git.push("https://x-access-token:#{@installation_token.to_s}@github.com/#{full_repo_name}.git", head_branch)
        rescue
          # Nothing to commit!
          puts 'Nothing to commit'
        end
        Dir.chdir(pwd)
        `rm -rf '#{repository}'`
      end
    end
    # Handles the check run `requested_action` event
    # See /webhooks/event-payloads/#check_run
    def take_requested_action
      full_repo_name = @payload['repository']['full_name']
      repository     = @payload['repository']['name']
      head_branch    = @payload['check_run']['check_suite']['head_branch']

      if (@payload['requested_action']['identifier'] == 'fix_rubocop_notices')
        clone_repository(full_repo_name, repository, head_branch)

        # Sets your commit username and email address
        @git.config('user.name', ENV['GITHUB_APP_USER_NAME'])
        @git.config('user.email', ENV['GITHUB_APP_USER_EMAIL'])

        # Automatically correct RuboCop style errors
        @report = `rubocop '#{repository}/*' --format json --auto-correct`

        pwd = Dir.getwd()
        Dir.chdir(repository)
        begin
          @git.commit_all('Automatically fix Octo RuboCop notices.')
          @git.push("https://x-access-token:#{@installation_token.to_s}@github.com/#{full_repo_name}.git", head_branch)
        rescue
          # Nothing to commit!
          puts 'Nothing to commit'
        end
        Dir.chdir(pwd)
        `rm -rf '#{repository}'`
      end
    end

The code above clones a repository, just like the code you added in Step 2.2. Allow RuboCop to clone the test repository. An if statement checks that the requested action's identifier matches the RuboCop button identifier (fix_rubocop_notices). When they match, the code clones the repository, sets the Git username and email, and runs RuboCop with the option --auto-correct. The --auto-correct option applies the changes to the local CI server files automatically.
The files are changed locally, but you'll still need to push them to GitHub. You'll use the ruby-git gem to commit all of the files. Git has a single command that stages all modified or deleted files and commits them: git commit -a. To do the same thing using ruby-git, the code above uses the commit_all method. Then the code pushes the committed files to GitHub using the installation token, using the same authentication method as the Git clone command. Finally, it removes the repository directory to ensure the working directory is prepared for the next event.
The code you have written now completes your continuous integration server that you built using a GitHub App and checks. To see the full final code for your app, see Full code example.
Test the code
The following steps will show you how to test that the code works, and that RuboCop can automatically fix the errors it finds.


Run the following command to restart the server from your terminal. If the server is already running, first enter Ctrl-C in your terminal to stop the server, and then run the following command to start the server again.
Shellruby server.rb
ruby server.rb



In the repository where you added the myfile.rb file, create a new pull request.


In the new pull request you created, navigate to the Checks tab, and click the "Fix this" button to automatically fix the errors RuboCop found.


Navigate to the Commits tab. You should see a new commit by the username you set in your Git configuration. You may need to refresh your browser to see the update.


Navigate to the Checks tab. You should see a new check suite for Octo RuboCop. But this time there should be no errors, because RuboCop fixed them all.


Full code example
This is what the final code in server.rb should look like, after you've followed all of the steps in this tutorial. There are also comments throughout the code that provide additional context.
Rubyrequire 'sinatra/base'  # Use the Sinatra web framework
require 'octokit'       # Use the Octokit Ruby library to interact with GitHub's REST API
require 'dotenv/load'   # Manages environment variables
require 'json'          # Allows your app to manipulate JSON data
require 'openssl'       # Verifies the webhook signature
require 'jwt'           # Authenticates a GitHub App
require 'time'          # Gets ISO 8601 representation of a Time object
require 'logger'        # Logs debug statements

# This code is a Sinatra app, for two reasons:
#   1. Because the app will require a landing page for installation.
#   2. To easily handle webhook events.

class GHAapp < Sinatra::Application

  # Sets the port that's used when starting the web server.
  set :port, 3000
  set :bind, '0.0.0.0'

  # Expects the private key in PEM format. Converts the newlines.
  PRIVATE_KEY = OpenSSL::PKey::RSA.new(ENV['GITHUB_PRIVATE_KEY'].gsub('\n', "\n"))

  # Your registered app must have a webhook secret.
  # The secret is used to verify that webhooks are sent by GitHub.
  WEBHOOK_SECRET = ENV['GITHUB_WEBHOOK_SECRET']

  # The GitHub App's identifier (type integer).
  APP_IDENTIFIER = ENV['GITHUB_APP_IDENTIFIER']

  # Turn on Sinatra's verbose logging during development
  configure :development do
    set :logging, Logger::DEBUG
  end

  # Executed before each request to the `/event_handler` route
  before '/event_handler' do
    get_payload_request(request)
    verify_webhook_signature

    # If a repository name is provided in the webhook, validate that
    # it consists only of latin alphabetic characters, `-`, and `_`.
    unless @payload['repository'].nil?
      halt 400 if (@payload['repository']['name'] =~ /[0-9A-Za-z\-\_]+/).nil?
    end

    authenticate_app
    # Authenticate the app installation in order to run API operations
    authenticate_installation(@payload)
  end

  post '/event_handler' do

    # Get the event type from the HTTP_X_GITHUB_EVENT header
    case request.env['HTTP_X_GITHUB_EVENT']

    when 'check_suite'
      # A new check_suite has been created. Create a new check run with status queued
      if @payload['action'] == 'requested' || @payload['action'] == 'rerequested'
        create_check_run
      end

    when 'check_run'
      # Check that the event is being sent to this app
      if @payload['check_run']['app']['id'].to_s === APP_IDENTIFIER
        case @payload['action']
        when 'created'
          initiate_check_run
        when 'rerequested'
          create_check_run
        when 'requested_action'
          take_requested_action
        end
      end
    end

    200 # success status
  end

  helpers do

    # Create a new check run with status "queued"
    def create_check_run
      @installation_client.create_check_run(
        # [String, Integer, Hash, Octokit Repository object] A GitHub repository.
        @payload['repository']['full_name'],
        # [String] The name of your check run.
        'Octo RuboCop',
        # [String] The SHA of the commit to check
        # The payload structure differs depending on whether a check run or a check suite event occurred.
        @payload['check_run'].nil? ? @payload['check_suite']['head_sha'] : @payload['check_run']['head_sha'],
        # [Hash] 'Accept' header option, to avoid a warning about the API not being ready for production use.
        accept: 'application/vnd.github+json'
      )
    end

    # Start the CI process
    def initiate_check_run
      # Once the check run is created, you'll update the status of the check run
      # to 'in_progress' and run the CI process. When the CI finishes, you'll
      # update the check run status to 'completed' and add the CI results.

      @installation_client.update_check_run(
        @payload['repository']['full_name'],
        @payload['check_run']['id'],
        status: 'in_progress',
        accept: 'application/vnd.github+json'
      )

      full_repo_name = @payload['repository']['full_name']
      repository     = @payload['repository']['name']
      head_sha       = @payload['check_run']['head_sha']

      clone_repository(full_repo_name, repository, head_sha)

      # Run RuboCop on all files in the repository
      @report = `rubocop '#{repository}' --format json`
      logger.debug @report
      `rm -rf #{repository}`
      @output = JSON.parse @report

      annotations = []
      # You can create a maximum of 50 annotations per request to the Checks
      # API. To add more than 50 annotations, use the "Update a check run" API
      # endpoint. This example code limits the number of annotations to 50.
      # See /rest/reference/checks#update-a-check-run
      # for details.
      max_annotations = 50

      # RuboCop reports the number of errors found in "offense_count"
      if @output['summary']['offense_count'] == 0
        conclusion = 'success'
      else
        conclusion = 'neutral'
        @output['files'].each do |file|

          # Only parse offenses for files in this app's repository
          file_path = file['path'].gsub(/#{repository}\//,'')
          annotation_level = 'notice'

          # Parse each offense to get details and location
          file['offenses'].each do |offense|
            # Limit the number of annotations to 50
            next if max_annotations == 0
            max_annotations -= 1

            start_line   = offense['location']['start_line']
            end_line     = offense['location']['last_line']
            start_column = offense['location']['start_column']
            end_column   = offense['location']['last_column']
            message      = offense['message']

            # Create a new annotation for each error
            annotation = {
              path: file_path,
              start_line: start_line,
              end_line: end_line,
              start_column: start_column,
              end_column: end_column,
              annotation_level: annotation_level,
              message: message
            }
            # Annotations only support start and end columns on the same line
            if start_line == end_line
              annotation.merge({start_column: start_column, end_column: end_column})
            end

            annotations.push(annotation)
          end
        end
      end

      # Updated check run summary and text parameters
      summary = "Octo RuboCop summary\n-Offense count: #{@output['summary']['offense_count']}\n-File count: #{@output['summary']['target_file_count']}\n-Target file count: #{@output['summary']['inspected_file_count']}"
      text = "Octo RuboCop version: #{@output['metadata']['rubocop_version']}"

      # Mark the check run as complete! And if there are warnings, share them.
      @installation_client.update_check_run(
        @payload['repository']['full_name'],
        @payload['check_run']['id'],
        status: 'completed',
        conclusion: conclusion,
        output: {
          title: 'Octo RuboCop',
          summary: summary,
          text: text,
          annotations: annotations
        },
        actions: [{
          label: 'Fix this',
          description: 'Automatically fix all linter notices.',
          identifier: 'fix_rubocop_notices'
        }],
        accept: 'application/vnd.github+json'
      )
    end

    # Clones the repository to the current working directory, updates the
    # contents using Git pull, and checks out the ref.
    #
    # full_repo_name  - The owner and repo. Ex: octocat/hello-world
    # repository      - The repository name
    # ref             - The branch, commit SHA, or tag to check out
    def clone_repository(full_repo_name, repository, ref)
      @git = Git.clone("https://x-access-token:#{@installation_token.to_s}@github.com/#{full_repo_name}.git", repository)
      pwd = Dir.getwd()
      Dir.chdir(repository)
      @git.pull
      @git.checkout(ref)
      Dir.chdir(pwd)
    end

    # Handles the check run `requested_action` event
    # See /webhooks/event-payloads/#check_run
    def take_requested_action
      full_repo_name = @payload['repository']['full_name']
      repository     = @payload['repository']['name']
      head_branch    = @payload['check_run']['check_suite']['head_branch']

      if (@payload['requested_action']['identifier'] == 'fix_rubocop_notices')
        clone_repository(full_repo_name, repository, head_branch)

        # Sets your commit username and email address
        @git.config('user.name', ENV['GITHUB_APP_USER_NAME'])
        @git.config('user.email', ENV['GITHUB_APP_USER_EMAIL'])

        # Automatically correct RuboCop style errors
        @report = `rubocop '#{repository}/*' --format json --auto-correct`

        pwd = Dir.getwd()
        Dir.chdir(repository)
        begin
          @git.commit_all('Automatically fix Octo RuboCop notices.')
          @git.push("https://x-access-token:#{@installation_token.to_s}@github.com/#{full_repo_name}.git", head_branch)
        rescue
          # Nothing to commit!
          puts 'Nothing to commit'
        end
        Dir.chdir(pwd)
        `rm -rf '#{repository}'`
      end
    end

    # Saves the raw payload and converts the payload to JSON format
    def get_payload_request(request)
      # request.body is an IO or StringIO object
      # Rewind in case someone already read it
      request.body.rewind
      # The raw text of the body is required for webhook signature verification
      @payload_raw = request.body.read
      begin
        @payload = JSON.parse @payload_raw
      rescue => e
        fail 'Invalid JSON (#{e}): #{@payload_raw}'
      end
    end

    # Instantiate an Octokit client authenticated as a GitHub App.
    # GitHub App authentication requires that you construct a
    # JWT (https://jwt.io/introduction/) signed with the app's private key,
    # so GitHub can be sure that it came from the app and not altered by
    # a malicious third party.
    def authenticate_app
      payload = {
          # The time that this JWT was issued, _i.e._ now.
          iat: Time.now.to_i,

          # JWT expiration time (10 minute maximum)
          exp: Time.now.to_i + (10 * 60),

          # Your GitHub App's identifier number
          iss: APP_IDENTIFIER
      }

      # Cryptographically sign the JWT.
      jwt = JWT.encode(payload, PRIVATE_KEY, 'RS256')

      # Create the Octokit client, using the JWT as the auth token.
      @app_client ||= Octokit::Client.new(bearer_token: jwt)
    end

    # Instantiate an Octokit client, authenticated as an installation of a
    # GitHub App, to run API operations.
    def authenticate_installation(payload)
      @installation_id = payload['installation']['id']
      @installation_token = @app_client.create_app_installation_access_token(@installation_id)[:token]
      @installation_client = Octokit::Client.new(bearer_token: @installation_token)
    end

    # Check X-Hub-Signature to confirm that this webhook was generated by
    # GitHub, and not a malicious third party.
    #
    # GitHub uses the WEBHOOK_SECRET, registered to the GitHub App, to
    # create the hash signature sent in the `X-HUB-Signature` header of each
    # webhook. This code computes the expected hash signature and compares it to
    # the signature sent in the `X-HUB-Signature` header. If they don't match,
    # this request is an attack, and you should reject it. GitHub uses the HMAC
    # hexdigest to compute the signature. The `X-HUB-Signature` looks something
    # like this: 'sha1=123456'.
    def verify_webhook_signature
      their_signature_header = request.env['HTTP_X_HUB_SIGNATURE'] || 'sha1='
      method, their_digest = their_signature_header.split('=')
      our_digest = OpenSSL::HMAC.hexdigest(method, WEBHOOK_SECRET, @payload_raw)
      halt 401 unless their_digest == our_digest

      # The X-GITHUB-EVENT header provides the name of the event.
      # The action value indicates the which action triggered the event.
      logger.debug "---- received event #{request.env['HTTP_X_GITHUB_EVENT']}"
      logger.debug "----    action #{@payload['action']}" unless @payload['action'].nil?
    end

  end

  # Finally some logic to let us run this server directly from the command line,
  # or with Rack. Don't worry too much about this code. But, for the curious:
  # $0 is the executed file
  # __FILE__ is the current file
  # If they are the same—that is, we are running this file directly, call the
  # Sinatra run method
  run! if __FILE__ == $0
end
require 'sinatra/base'  # Use the Sinatra web framework
require 'octokit'       # Use the Octokit Ruby library to interact with GitHub's REST API
require 'dotenv/load'   # Manages environment variables
require 'json'          # Allows your app to manipulate JSON data
require 'openssl'       # Verifies the webhook signature
require 'jwt'           # Authenticates a GitHub App
require 'time'          # Gets ISO 8601 representation of a Time object
require 'logger'        # Logs debug statements

# This code is a Sinatra app, for two reasons:
#   1. Because the app will require a landing page for installation.
#   2. To easily handle webhook events.

class GHAapp < Sinatra::Application

  # Sets the port that's used when starting the web server.
  set :port, 3000
  set :bind, '0.0.0.0'

  # Expects the private key in PEM format. Converts the newlines.
  PRIVATE_KEY = OpenSSL::PKey::RSA.new(ENV['GITHUB_PRIVATE_KEY'].gsub('\n', "\n"))

  # Your registered app must have a webhook secret.
  # The secret is used to verify that webhooks are sent by GitHub.
  WEBHOOK_SECRET = ENV['GITHUB_WEBHOOK_SECRET']

  # The GitHub App's identifier (type integer).
  APP_IDENTIFIER = ENV['GITHUB_APP_IDENTIFIER']

  # Turn on Sinatra's verbose logging during development
  configure :development do
    set :logging, Logger::DEBUG
  end

  # Executed before each request to the `/event_handler` route
  before '/event_handler' do
    get_payload_request(request)
    verify_webhook_signature

    # If a repository name is provided in the webhook, validate that
    # it consists only of latin alphabetic characters, `-`, and `_`.
    unless @payload['repository'].nil?
      halt 400 if (@payload['repository']['name'] =~ /[0-9A-Za-z\-\_]+/).nil?
    end

    authenticate_app
    # Authenticate the app installation in order to run API operations
    authenticate_installation(@payload)
  end

  post '/event_handler' do

    # Get the event type from the HTTP_X_GITHUB_EVENT header
    case request.env['HTTP_X_GITHUB_EVENT']

    when 'check_suite'
      # A new check_suite has been created. Create a new check run with status queued
      if @payload['action'] == 'requested' || @payload['action'] == 'rerequested'
        create_check_run
      end

    when 'check_run'
      # Check that the event is being sent to this app
      if @payload['check_run']['app']['id'].to_s === APP_IDENTIFIER
        case @payload['action']
        when 'created'
          initiate_check_run
        when 'rerequested'
          create_check_run
        when 'requested_action'
          take_requested_action
        end
      end
    end

    200 # success status
  end

  helpers do

    # Create a new check run with status "queued"
    def create_check_run
      @installation_client.create_check_run(
        # [String, Integer, Hash, Octokit Repository object] A GitHub repository.
        @payload['repository']['full_name'],
        # [String] The name of your check run.
        'Octo RuboCop',
        # [String] The SHA of the commit to check
        # The payload structure differs depending on whether a check run or a check suite event occurred.
        @payload['check_run'].nil? ? @payload['check_suite']['head_sha'] : @payload['check_run']['head_sha'],
        # [Hash] 'Accept' header option, to avoid a warning about the API not being ready for production use.
        accept: 'application/vnd.github+json'
      )
    end

    # Start the CI process
    def initiate_check_run
      # Once the check run is created, you'll update the status of the check run
      # to 'in_progress' and run the CI process. When the CI finishes, you'll
      # update the check run status to 'completed' and add the CI results.

      @installation_client.update_check_run(
        @payload['repository']['full_name'],
        @payload['check_run']['id'],
        status: 'in_progress',
        accept: 'application/vnd.github+json'
      )

      full_repo_name = @payload['repository']['full_name']
      repository     = @payload['repository']['name']
      head_sha       = @payload['check_run']['head_sha']

      clone_repository(full_repo_name, repository, head_sha)

      # Run RuboCop on all files in the repository
      @report = `rubocop '#{repository}' --format json`
      logger.debug @report
      `rm -rf #{repository}`
      @output = JSON.parse @report

      annotations = []
      # You can create a maximum of 50 annotations per request to the Checks
      # API. To add more than 50 annotations, use the "Update a check run" API
      # endpoint. This example code limits the number of annotations to 50.
      # See /rest/reference/checks#update-a-check-run
      # for details.
      max_annotations = 50

      # RuboCop reports the number of errors found in "offense_count"
      if @output['summary']['offense_count'] == 0
        conclusion = 'success'
      else
        conclusion = 'neutral'
        @output['files'].each do |file|

          # Only parse offenses for files in this app's repository
          file_path = file['path'].gsub(/#{repository}\//,'')
          annotation_level = 'notice'

          # Parse each offense to get details and location
          file['offenses'].each do |offense|
            # Limit the number of annotations to 50
            next if max_annotations == 0
            max_annotations -= 1

            start_line   = offense['location']['start_line']
            end_line     = offense['location']['last_line']
            start_column = offense['location']['start_column']
            end_column   = offense['location']['last_column']
            message      = offense['message']

            # Create a new annotation for each error
            annotation = {
              path: file_path,
              start_line: start_line,
              end_line: end_line,
              start_column: start_column,
              end_column: end_column,
              annotation_level: annotation_level,
              message: message
            }
            # Annotations only support start and end columns on the same line
            if start_line == end_line
              annotation.merge({start_column: start_column, end_column: end_column})
            end

            annotations.push(annotation)
          end
        end
      end

      # Updated check run summary and text parameters
      summary = "Octo RuboCop summary\n-Offense count: #{@output['summary']['offense_count']}\n-File count: #{@output['summary']['target_file_count']}\n-Target file count: #{@output['summary']['inspected_file_count']}"
      text = "Octo RuboCop version: #{@output['metadata']['rubocop_version']}"

      # Mark the check run as complete! And if there are warnings, share them.
      @installation_client.update_check_run(
        @payload['repository']['full_name'],
        @payload['check_run']['id'],
        status: 'completed',
        conclusion: conclusion,
        output: {
          title: 'Octo RuboCop',
          summary: summary,
          text: text,
          annotations: annotations
        },
        actions: [{
          label: 'Fix this',
          description: 'Automatically fix all linter notices.',
          identifier: 'fix_rubocop_notices'
        }],
        accept: 'application/vnd.github+json'
      )
    end

    # Clones the repository to the current working directory, updates the
    # contents using Git pull, and checks out the ref.
    #
    # full_repo_name  - The owner and repo. Ex: octocat/hello-world
    # repository      - The repository name
    # ref             - The branch, commit SHA, or tag to check out
    def clone_repository(full_repo_name, repository, ref)
      @git = Git.clone("https://x-access-token:#{@installation_token.to_s}@github.com/#{full_repo_name}.git", repository)
      pwd = Dir.getwd()
      Dir.chdir(repository)
      @git.pull
      @git.checkout(ref)
      Dir.chdir(pwd)
    end

    # Handles the check run `requested_action` event
    # See /webhooks/event-payloads/#check_run
    def take_requested_action
      full_repo_name = @payload['repository']['full_name']
      repository     = @payload['repository']['name']
      head_branch    = @payload['check_run']['check_suite']['head_branch']

      if (@payload['requested_action']['identifier'] == 'fix_rubocop_notices')
        clone_repository(full_repo_name, repository, head_branch)

        # Sets your commit username and email address
        @git.config('user.name', ENV['GITHUB_APP_USER_NAME'])
        @git.config('user.email', ENV['GITHUB_APP_USER_EMAIL'])

        # Automatically correct RuboCop style errors
        @report = `rubocop '#{repository}/*' --format json --auto-correct`

        pwd = Dir.getwd()
        Dir.chdir(repository)
        begin
          @git.commit_all('Automatically fix Octo RuboCop notices.')
          @git.push("https://x-access-token:#{@installation_token.to_s}@github.com/#{full_repo_name}.git", head_branch)
        rescue
          # Nothing to commit!
          puts 'Nothing to commit'
        end
        Dir.chdir(pwd)
        `rm -rf '#{repository}'`
      end
    end

    # Saves the raw payload and converts the payload to JSON format
    def get_payload_request(request)
      # request.body is an IO or StringIO object
      # Rewind in case someone already read it
      request.body.rewind
      # The raw text of the body is required for webhook signature verification
      @payload_raw = request.body.read
      begin
        @payload = JSON.parse @payload_raw
      rescue => e
        fail 'Invalid JSON (#{e}): #{@payload_raw}'
      end
    end

    # Instantiate an Octokit client authenticated as a GitHub App.
    # GitHub App authentication requires that you construct a
    # JWT (https://jwt.io/introduction/) signed with the app's private key,
    # so GitHub can be sure that it came from the app and not altered by
    # a malicious third party.
    def authenticate_app
      payload = {
          # The time that this JWT was issued, _i.e._ now.
          iat: Time.now.to_i,

          # JWT expiration time (10 minute maximum)
          exp: Time.now.to_i + (10 * 60),

          # Your GitHub App's identifier number
          iss: APP_IDENTIFIER
      }

      # Cryptographically sign the JWT.
      jwt = JWT.encode(payload, PRIVATE_KEY, 'RS256')

      # Create the Octokit client, using the JWT as the auth token.
      @app_client ||= Octokit::Client.new(bearer_token: jwt)
    end

    # Instantiate an Octokit client, authenticated as an installation of a
    # GitHub App, to run API operations.
    def authenticate_installation(payload)
      @installation_id = payload['installation']['id']
      @installation_token = @app_client.create_app_installation_access_token(@installation_id)[:token]
      @installation_client = Octokit::Client.new(bearer_token: @installation_token)
    end

    # Check X-Hub-Signature to confirm that this webhook was generated by
    # GitHub, and not a malicious third party.
    #
    # GitHub uses the WEBHOOK_SECRET, registered to the GitHub App, to
    # create the hash signature sent in the `X-HUB-Signature` header of each
    # webhook. This code computes the expected hash signature and compares it to
    # the signature sent in the `X-HUB-Signature` header. If they don't match,
    # this request is an attack, and you should reject it. GitHub uses the HMAC
    # hexdigest to compute the signature. The `X-HUB-Signature` looks something
    # like this: 'sha1=123456'.
    def verify_webhook_signature
      their_signature_header = request.env['HTTP_X_HUB_SIGNATURE'] || 'sha1='
      method, their_digest = their_signature_header.split('=')
      our_digest = OpenSSL::HMAC.hexdigest(method, WEBHOOK_SECRET, @payload_raw)
      halt 401 unless their_digest == our_digest

      # The X-GITHUB-EVENT header provides the name of the event.
      # The action value indicates the which action triggered the event.
      logger.debug "---- received event #{request.env['HTTP_X_GITHUB_EVENT']}"
      logger.debug "----    action #{@payload['action']}" unless @payload['action'].nil?
    end

  end

  # Finally some logic to let us run this server directly from the command line,
  # or with Rack. Don't worry too much about this code. But, for the curious:
  # $0 is the executed file
  # __FILE__ is the current file
  # If they are the same—that is, we are running this file directly, call the
  # Sinatra run method
  run! if __FILE__ == $0
end

Next steps
You should now have an app that receives API events, creates check runs, uses RuboCop to find Ruby errors, creates annotations in a pull request, and automatically fixes linter errors. Next you might want to expand your app's code, deploy your app, and make your app public.
If you have any questions, start a GitHub Community discussion in the API and Webhooks category.
Modify the app code
This tutorial demonstrated how to create a "Fix this" button that is always displayed in pull requests in the repository. Try updating the code to display the "Fix this" button only when RuboCop finds errors.
If you'd prefer that RuboCop doesn't commit files directly to the head branch, update the code to instead create a pull request with a new branch that's based on the head branch.
Deploy your app
This tutorial demonstrated how to develop your app locally. When you are ready to deploy your app, you need to make changes to serve your app and keep your app's credential secure. The steps you take depend on the server that you use, but the following sections offer general guidance.
Host your app on a server
This tutorial used your computer or codespace as a server. Once the app is ready for production use, you should deploy your app to a dedicated server. For example, you can use Azure App Service.
Update the webhook URL
Once you have a server that is set up to receive webhook traffic from GitHub, update the webhook URL in your app settings. You should not use Smee.io to forward your webhooks in production.
Update the :port setting
When you deploy your app, you will want to change the port where your server is listening. The code already tells your server to listen to all available network interfaces by setting :bind to 0.0.0.0.
For example, you can set a PORT variable in your .env file on your server to indicate the port where your server should listen. Then, you can update the place where your code sets :port so that your server listens on your deployment port:
Rubyset :port, ENV['PORT']
set :port, ENV['PORT']

Secure your app's credentials
You should never publicize your app's private key or webhook secret. This tutorial stored your app's credentials in a gitignored .env file. When you deploy your app, you should choose a secure way to store the credentials and update your code to get the value accordingly. For example, you can store the credentials with a secret management service like Azure Key Vault. When your app runs, it can retrieve the credentials and store them in environment variables on the server where your app is deployed.
For more information, see Best practices for creating a GitHub App.
Share your app
If you want to share your app with other users and organizations, make your app public. For more information, see Making a GitHub App public or private.
Follow best practices
You should aim to follow best practices with your GitHub App. For more information, see Best practices for creating a GitHub App.\n\n\n\nApps/Sharing GitHub Apps/Share your appSharing your GitHub AppYou can share your GitHub App with other users.In this articleSharing your GitHub App on GitHub MarketplaceSharing your GitHub App via an install linkSharing your GitHub App with GitHub Enterprise Server instancesSharing your GitHub App on GitHub Marketplace
If your GitHub App is public, you can choose to publish it to GitHub Marketplace. For more information, see About GitHub Marketplace for apps.
For more information about how users can install your app from GitHub Marketplace, see Installing a GitHub App from GitHub Marketplace for your organizations and Installing a GitHub App from GitHub Marketplace for your personal account.
Sharing your GitHub App via an install link
If your GitHub App is public, other users and organizations can install your app. For more information about making your app public, see Making a GitHub App public or private.


In the upper-right corner of any page on GitHub, click your profile photo.


Navigate to your account settings.

For an app owned by a personal account, click Settings.
For an app owned by an organization:

Click Your organizations.
To the right of the organization, click Settings.





In the left sidebar, click  Developer settings.


In the left sidebar, click GitHub Apps.


Next to the GitHub App that you want to share, click Edit.


Click Public page. GitHub will bring you to the public page for your GitHub App.


Click Install. GitHub will bring you to the installation URL for your GitHub App. The URL will look something like https://github.com/apps/APP-NAME/installations/new, where APP-NAME is the name of the GitHub App.


Share the installation URL with other users. For more information about how users can install your app from this URL, see Installing a GitHub App from a third party.
When you share the URL, you can include a state query parameter in the installation URL to preserve the state of the application page and return people back to that state after they install, authenticate, or accept updates to your GitHub App. For example, you could use the state to correlate an installation to a user or account.
To preserve a state, add it to the installation URL: https://github.com/apps/<app name>/installations/new?state=AB12t


Sharing your GitHub App with GitHub Enterprise Server instances
If you want to share your GitHub App with GitHub Enterprise Server instances that you are not part of, you need to take additional steps. For more information, see Making your GitHub App available for GitHub Enterprise Server.\n\n\n\nApps/Sharing GitHub Apps/Share with GHESMaking your GitHub App available for GitHub Enterprise ServerIn order for GitHub Enterprise Server instances to use your GitHub App, you must take some additional steps.In this articleAbout developing GitHub Apps for GitHub Enterprise ServerEach GitHub Enterprise Server instance must register their own GitHub AppThe app code must be able to access the GitHub App credentials for the instanceThe app code must use the correct URLsThe app code must be aware of feature differencesEach GitHub Enterprise Server instance can configure rate limitsAbout developing GitHub Apps for GitHub Enterprise Server
If you want your GitHub App to be available to organizations in a GitHub Enterprise Server instance that you are not part of, you must take the following steps.
If GitHub Enterprise Server access is important, consider whether a custom action for GitHub Actions will suit your needs instead. Public actions are available on GitHub Enterprise Server instances with GitHub Connect. For more information, see Enabling automatic access to GitHub.com actions using GitHub Connect in the GitHub Enterprise Server documentation.
Each GitHub Enterprise Server instance must register their own GitHub App
Organizations owned by a GitHub Enterprise Server instance cannot install GitHub Apps registered on GitHub.com or on another GitHub Enterprise Server instance. Instead, they must register and install their own GitHub App for use on that instance.


The app developer creates a manifest or URL parameters. For more information, see Registering a GitHub App from a manifest and Registering a GitHub App using URL parameters.


The app developer shares the manifest or URL parameters with the GitHub Enterprise Server administrator that wants to use the app. The same manifest or URL parameters can be shared with multiple GitHub Enterprise Server instances.


An organization owner in the instance uses the manifest or URL parameters to register a GitHub App.


The organization installs the GitHub App that they registered.
Optionally, if the organization made the GitHub App public, other organizations within the instance can install the GitHub App as well. There is not a way to install a GitHub App on an entire instance, only on organizations within an instance.


The app code must be able to access the GitHub App credentials for the instance
Your app's code will need the credentials of the GitHub App that the GitHub Enterprise Server instance registered. It will also need the hostname of the instance. You have two options: get the credentials and hostname from the instance, or have the GitHub Enterprise Server customer host and manage a self-hostable version of the app.
Get the credentials from the GitHub Enterprise Server instance
The instance can share their GitHub App credentials and hostname with the app developer. The site administrator should only do this if they trust the app developer. Then, the app code can use the appropriate credentials depending on what actions it is taking. The app developer must take precautions to use the appropriate set of credentials and to not leak data.
Advantages:

The app developer controls the infrastructure that the app runs on.
The app developer has more control over app updates.
The app developer may have more insight into app performance.

Disadvantages:

The app developer must take precautions to avoid leaking data from the instance.
The site administrator may need to open firewall exceptions for your application to reach the instance, and they may be reluctant to do so.

Have the GitHub Enterprise Server customer host and manage a self-hostable version of the app
The app developer can provide a self-hostable version of their app. Then, the site administrator can host the app according to app developer's setup and installation instructions.
The method by which the self-hostable version of the app is created and shared is up to the app developer and depends on technology that the app uses.
Advantages:

The instance remains more secure because they aren't sharing their app credentials.
The app developer doesn't need to worry about leaking data from the instance.

Disadvantages:

The app developer relies on the site administrator to provide infrastructure for the app and set things up correctly.
Releasing updates to the app code may be more complex.
The app developer may lose visibility about app performance.

The app code must use the correct URLs
GitHub Enterprise Server uses different URLs than GitHub Free, GitHub Pro, GitHub Team, and GitHub Enterprise Cloud. You should update your app code to use the appropriate URL depending on whether it is working with a GitHub Enterprise Server instance. Replace HOSTNAME with the hostname of the GitHub Enterprise Server instance.

























GitHub FreeGitHub ProGitHub TeamGitHub Enterprise CloudGitHub Enterprise Serverhttps://api.github.comhttps://HOSTNAME/api/v3https://api.github.com/graphqlhttps://HOSTNAME/api/v3/graphqlhttps://github.com/login/oauth/authorizehttps://HOSTNAME/login/oauth/authorizehttps://github.com/login/oauth/access_tokenhttps://HOSTNAME/login/oauth/access_token
The app code must be aware of feature differences
New REST API endpoints, GraphQL objects, and webhooks are released to GitHub Enterprise Server at a later date than GitHub Free, GitHub Pro, GitHub Team, and GitHub Enterprise Cloud. Additionally, there are multiple versions of GitHub Enterprise Server, and older versions may have different REST API endpoints, GraphQL objects, and webhooks.
Therefore, the app code needs to be aware of these differences. API responses and webhook payloads include a x-github-enterprise-version header for GitHub Enterprise Server payloads to help you determine what version you are handling.
Each GitHub Enterprise Server instance can configure rate limits
Each GitHub Enterprise Server instance can configure its own rate limits. If your app is hitting a rate limit and is already taking precautions to stay under the rate limit, you should talk to the admin of the GitHub Enterprise Server instance.\n\n\n\nApps/Sharing GitHub Apps/App manifestRegistering a GitHub App from a manifestA GitHub App manifest is a way to share a preconfigured GitHub App registration with other users. The manifest flow allows someone to quickly register a GitHub App.In this articleAbout GitHub App ManifestsImplementing the GitHub App Manifest flowUsing Probot to implement the GitHub App Manifest flowAbout GitHub App Manifests
When someone registers a GitHub App from a manifest, they only need to follow a URL and name the app. The manifest includes the permissions, events, and webhook URL needed to automatically register the app. The manifest flow creates the GitHub App registration and generates the app's webhook secret, private key (PEM file), client secret, and GitHub App ID. The person who creates the GitHub App registration from the manifest will own the GitHub App registration and can choose to edit the registration's settings, delete it, or transfer it to another person on GitHub.
You can use Probot to get started with GitHub App Manifests or see an example implementation. See Using Probot to implement the GitHub App Manifest flow to learn more.
Here are some scenarios where you might use GitHub App Manifests to register pre-configured apps:

Help new team members come up-to-speed quickly when developing GitHub Apps.
Allow others to extend a GitHub App using the GitHub APIs without requiring them to configure an app.
Create GitHub App reference designs to share with the GitHub community.
Ensure you deploy GitHub Apps to development and production environments using the same configuration.
Track revisions to a GitHub App configuration.

Implementing the GitHub App Manifest flow
The GitHub App Manifest flow uses a handshaking process similar to the OAuth flow. The flow uses a manifest to register a GitHub App and receives a temporary code used to retrieve the app's private key, webhook secret, and ID.
Note
 You must complete all three steps in the GitHub App Manifest flow within one hour.

Follow these steps to implement the GitHub App Manifest flow:

You redirect people to GitHub to register a new GitHub App.
GitHub redirects people back to your site.
You exchange the temporary code to retrieve the app configuration.

1. You redirect people to GitHub to register a new GitHub App
To redirect people to register a new GitHub App, provide a link for them to click that sends a POST request to https://github.com/settings/apps/new for a personal account or https://github.com/organizations/ORGANIZATION/settings/apps/new for an organization account, replacing ORGANIZATION with the name of the organization account where the app will be registered.
You must include the GitHub App Manifest parameters as a JSON-encoded string in a parameter called manifest. You can also include a state parameter for additional security.
The person registering the app will be redirected to a GitHub page with an input field where they can edit the name of the app you included in the manifest parameter. If you do not include a name in the manifest, they can set their own name for the app in this field.
GitHub App Manifest parameters






































































NameTypeDescriptionnamestringThe name of the GitHub App.urlstringRequired. The homepage of your GitHub App.hook_attributesobjectThe configuration of the GitHub App's webhook.redirect_urlstringThe full URL to redirect to after a user initiates the registration of a GitHub App from a manifest.callback_urlsarray of stringsA full URL to redirect to after someone authorizes an installation. You can provide up to 10 callback URLs.setup_urlstringA full URL to redirect users to after they install your GitHub App if additional setup is required.descriptionstringA description of the GitHub App.publicbooleanSet to true when your GitHub App is available to the public or false when it is only accessible to the owner of the app.default_eventsarrayThe list of events the GitHub App subscribes to.default_permissionsobjectThe set of permissions needed by the GitHub App. The format of the object uses the permission name for the key (for example, issues) and the access type for the value (for example, write). For more information, see Choosing permissions for a GitHub App.request_oauth_on_installbooleanSet to true to request the user to authorize the GitHub App, after the GitHub App is installed.setup_on_updatebooleanSet to true to redirect users to the setup_url after they update your GitHub App installation.
The hook_attributes object has the following keys.




















NameTypeDescriptionurlstringRequired. The URL of the server that will receive the webhook POST requests.activebooleanDeliver event details when this hook is triggered, defaults to true.
Parameters















NameTypeDescriptionstatestringAn unguessable random string. It is used to protect against cross-site request forgery attacks.
Examples
This example uses a form on a web page with a button that triggers the POST request for a personal account:
<form action="https://github.com/settings/apps/new?state=abc123" method="post">
 Register a GitHub App Manifest: <input type="text" name="manifest" id="manifest"><br>
 <input type="submit" value="Submit">
</form>

<script>
 input = document.getElementById("manifest")
 input.value = JSON.stringify({
   "name": "Octoapp",
   "url": "https://www.example.com",
   "hook_attributes": {
     "url": "https://example.com/github/events",
   },
   "redirect_url": "https://example.com/redirect",
   "callback_urls": [
     "https://example.com/callback"
   ],
   "public": true,
   "default_permissions": {
     "issues": "write",
     "checks": "write"
   },
   "default_events": [
     "issues",
     "issue_comment",
     "check_suite",
     "check_run"
   ]
 })
</script>

This example uses a form on a web page with a button that triggers the POST request for an organization account. Replace ORGANIZATION with the name of the organization account where you want to register the app.
<form action="https://github.com/organizations/ORGANIZATION/settings/apps/new?state=abc123" method="post">
 register a GitHub App Manifest: <input type="text" name="manifest" id="manifest"><br>
 <input type="submit" value="Submit">
</form>

<script>
 input = document.getElementById("manifest")
 input.value = JSON.stringify({
   "name": "Octoapp",
   "url": "https://www.example.com",
   "hook_attributes": {
     "url": "https://example.com/github/events",
   },
   "redirect_url": "https://example.com/redirect",
   "callback_urls": [
     "https://example.com/callback"
   ],
   "public": true,
   "default_permissions": {
     "issues": "write",
     "checks": "write"
   },
   "default_events": [
     "issues",
     "issue_comment",
     "check_suite",
     "check_run"
   ]
 })
</script>

2. GitHub redirects people back to your site
When the person clicks Create GitHub App, GitHub redirects back to the redirect_url with a temporary code in a code parameter. For example:
https://example.com/redirect?code=a180b1a3d263c81bc6441d7b990bae27d4c10679

If you provided a state parameter, you will also see that parameter in the redirect_url. For example:
https://example.com/redirect?code=a180b1a3d263c81bc6441d7b990bae27d4c10679&state=abc123

3. You exchange the temporary code to retrieve the app configuration
To complete the handshake, send the temporary code in a POST request to the Create a GitHub App from a manifest endpoint. The response will include the id (GitHub App ID), pem (private key), and webhook_secret. GitHub creates a webhook secret for the app automatically. You can store these values in environment variables on the app's server. For example, if your app uses dotenv to store environment variables, you would store the variables in your app's .env file.
You must complete this step of the GitHub App Manifest flow within one hour.
Note

This endpoint is rate limited. See Rate limits to learn how to get your current rate limit status.

POST /app-manifests/{code}/conversions

For more information about the endpoint's response, see Create a GitHub App from a manifest.
When the final step in the manifest flow is completed, the person registering the app from the flow will be an owner of a registered GitHub App that they can install on any of their personal repositories. They can choose to extend the app using the GitHub APIs, transfer ownership to someone else, or delete it at any time.
Using Probot to implement the GitHub App Manifest flow
Probot is a framework built with Node.js that performs many of the tasks needed by all GitHub Apps, like validating webhooks and performing authentication. Probot implements the GitHub App manifest flow, making it easy to create and share GitHub App reference designs with the GitHub community.
To create a Probot App that you can share, follow these steps:

Generate a new GitHub App.
Open the project you created, and customize the settings in the app.yml file. Probot uses the settings in app.yml as the GitHub App Manifest parameters.
Add your application's custom code.
Run the GitHub App locally or host it anywhere you'd like. When you navigate to the hosted app's URL, you'll find a web page with a Register GitHub App button that people can click to register a preconfigured app.

Using dotenv, Probot creates a .env file and sets the APP_ID, PRIVATE_KEY, and WEBHOOK_SECRET environment variables with the values retrieved from the app configuration.
Hosting your app with Glitch
You can see an example Probot app that uses Glitch to host and share the app. The example uses the Checks API and selects the necessary Checks API events and permissions in the app.yml file. Glitch is a tool that allows you to "Remix your own" apps. Remixing an app creates a copy of the app that Glitch hosts and deploys. See About Glitch to learn about remixing Glitch apps.\n\n\n\nApps/Sharing GitHub Apps/App query parametersRegistering a GitHub App using URL parametersYou can use URL query parameters to help other people quickly set up a new GitHub App with a specific configuration you have preselected.In this articleAbout URL parameters for registering GitHub AppsCreating a custom configuration URL with query parametersGitHub App configuration parametersGitHub App permissionsGitHub App webhook eventsAbout URL parameters for registering GitHub Apps
You can use URL parameters to preselect the configuration settings of a new GitHub App registration and share a custom link with other people. The link will take people to a GitHub App registration page, where the app settings will be pre-filled according to the URL parameters you included in the URL.
This approach is useful for integrators who want customers to set up an app on their personal account or organization with certain specifications, or for customers using GitHub Enterprise Server who aren't able to install apps from the GitHub Marketplace.
Alternatively, you can create a GitHub App manifest. For more information, see Registering a GitHub App from a manifest.
Creating a custom configuration URL with query parameters
To create a custom configuration URL for a GitHub App on a personal or organization account, add query parameters after the following base URLs.

To register an app on a personal account, add URL parameters to: https://github.com/settings/apps/new
To register an app on an organization account, add URL parameters to: https://github.com/organizations/ORGANIZATION/settings/apps/new. Replace ORGANIZATION with the name of the organization where you'd like the customer to register the app.

On the app registration page, the person registering the app can edit the preselected values before submitting the app. If you do not include parameters for required values (like name) in the URL query string, the person registering the app will need to input a value before they can register the app.
For example, the following URL registers a new public app named octocat-github-app on a personal account. Using query parameters, the URL preconfigures a description and a callback URL. It also selects read and write permissions for checks, activates webhooks using the webhook_active parameter, subscribes to the check_run and check_suite webhook events, and selects the option to request user authorization (OAuth) during installation:
https://github.com/settings/apps/new?name=octocat-github-app&description=An%20Octocat%20App&callback_urls[]=https://example.com&request_oauth_on_install=true&public=true&checks=write&webhook_active=true&events[]=check_run&events[]=check_suite

GitHub App configuration parameters
You can use the following query parameters to select a specific configuration for the GitHub App registration. For example, to name the app "octocat-github-app", your query string would include name=octocat-github-app.











































































Parameter nameTypeDescriptionnamestringThe name of the GitHub App. Give your app a clear and succinct name. Your app cannot have the same name as an existing GitHub user, unless it is your own user or organization name. A slugged version of your app's name will be shown in the user interface when your integration takes an action.descriptionstringA description of the GitHub App.urlstringThe full URL of your GitHub App's website homepage.callback_urlsarray of stringsA full URL to redirect to after someone authorizes an installation. You can provide up to 10 callback URLs. These URLs are used if your app needs to generate a user access token. For example, callback_urls[]=https://example.com&callback_urls[]=https://example-2.com. For more information, see About the user authorization callback URL.request_oauth_on_installbooleanIf your app authorizes users using the OAuth flow, you can set this option to true to allow people to authorize the app when they install it, saving a step. If you select this option, the setup_url becomes unavailable and users will be redirected to your callback_url after installing the app.setup_urlstringThe full URL to redirect to after someone installs the GitHub App if the app requires additional setup after installation. For more information, see About the setup URL.setup_on_updatebooleanSet to true to redirect people to the setup URL when installations have been updated, for example, after repositories are added or removed.publicbooleanSet to true when your GitHub App is available to the public or false when it is only accessible to the owner of the app. This parameter does not apply to apps owned by enterprises.webhook_activebooleanSet to true to enable webhook. Webhook is disabled by default.webhook_urlstringThe full URL that you would like to send webhook event payloads to.eventsarray of stringsWebhook events. Some webhook events require read or write permissions for a resource before you can select the event when registering a new GitHub App. For more information, see the GitHub App webhook events section. You can select multiple events in a query string. For example, events[]=public&events[]=label.single_file_namestringThis is a narrowly-scoped permission that allows the app to access a single file in any repository. When you set the single_file permission to read or write, this field provides the path to the single file your GitHub App will manage. If you need to manage multiple files, see single_file_paths below.single_file_pathsarray of stringsThis allows the app to access up ten specified files in a repository. When you set the single_file permission to read or write, this array can store the paths for up to ten files that your GitHub App will manage. These files all receive the same permission set by single_file, and do not have separate individual permissions. When two or more files are configured, the API returns multiple_single_files=true, otherwise it returns multiple_single_files=false.
GitHub App permissions
You can use query parameters to select the permissions for the GitHub App registration. For the URL query parameter, use the permission name as the query parameter name, and set the query value to one of the possible values for that permission set.
For example, to select "Read & write" permissions in the user interface for contents, your query string would include contents=write. To select "Read-only" permissions in the user interface for blocking, your query string would include blocking=read. To select "No access" in the user interface for checks, your query string would not include the checks permission.
For more information about permissions and GitHub Apps, see Choosing permissions for a GitHub App.
GitHub App webhook events
You can use query parameters to enable the GitHub App webhook, designate a webhook URL, and subscribe the app to receive webhook payloads for specific events.
To enable the GitHub App webhook, use webhook_active=true in your query string. To designate a full URL that you would like to send webhook event payloads to, use webhook_url in your query string. To subscribe the app to specific webhook payload events, use events[] as the query parameter name, and set the query value to the name of the webhook event. For more information about the possible webhook events and the GitHub App permissions required to subscribe to each event, see Webhook events and payloads.
For example, to subscribe a GitHub App to receive webhook payloads for activity relating to commit comments, the query string would include &webhook_active=true&webhook_url=https://example.com&events[]=commit_comment. Note that the commit_comment webhook event requires the GitHub App to have at least read-level access for the "Contents" repository permission. So your query string should also include a parameter to set the contents permission to read or write. For more information, see GitHub app permissions.
You cannot use query parameters to set the value of a webhook secret. If an app requires a secret to secure its webhook, the value of the secret must be set in the GitHub UI by the person registering the app.
For more information about webhooks and GitHub Apps, see Using webhooks with GitHub Apps.\n\n\n\nApps/Maintaining GitHub Apps/Modify app settingsModifying a GitHub App registrationAfter registering a GitHub App, you can make changes to it.In this articleAbout GitHub App modificationsNavigating to your GitHub App settingsChanging the basic information of a GitHub AppRequesting user authorization (OAuth) during installationEnabling or disabling the device flowAdding or updating a setup URLChanging the permissions of a GitHub AppActivating or deactivating the GitHub App webhookChanging the webhook event subscriptions of a GitHub AppChanging the visibility of a GitHub AppAbout GitHub App modifications
You can modify your GitHub App registration to change any of the settings that were selected when the app was initially registered. For more information about the settings you can select while registering a GitHub App, see Registering a GitHub App.
For example, you can change the name and description of your app, the permissions granted to your app, the webhooks your app subscribes to, or the visibility of your app.
You can also choose to test new optional features for your GitHub App. See Activating optional features for GitHub Apps.

Navigating to your GitHub App settings
To modify a GitHub App, first navigate to the app settings page.


In the upper-right corner of any page on GitHub, click your profile photo.


Navigate to your account settings.

For an app owned by a personal account, click Settings.
For an app owned by an organization:

Click Your organizations.
To the right of the organization, click Settings.





In the left sidebar, click  Developer settings.


In the left sidebar, click GitHub Apps.


To the right of the GitHub App you want to modify, click Edit.


Changing the basic information of a GitHub App
You can change the basic information of your GitHub App, like the name of the app, the description of the app, and the homepage URL of the app.

Navigate to the settings page for the app you'd like to modify. For more information, see Navigating to your GitHub App settings in this article.
Under "Basic information," modify the GitHub App information that you'd like to change.
Click Save changes.

Requesting user authorization (OAuth) during installation
You can prompt users to authorize your GitHub App when they install it and generate a user access token. When you request user authorization (OAuth) during installation, you must also provide a callback URL where the user will be redirected after they authorize the installation. See Generating a user access token for a GitHub App.

Navigate to the settings page for the app you'd like to modify. For more information, see Navigating to your GitHub App settings in this article.
Under "Identifying and authorizing users," select or deselect Request user authorization (OAuth) during installation.
Under "Callback URL," enter the full URL to redirect to after a user authorizes the installation.

Enabling or disabling the device flow
You can use the device flow to authorize users for a headless app like a CLI tool or Git credential manager. For more information about using the device flow with GitHub Apps, see Generating a user access token for a GitHub App.

Navigate to the settings page for the app you'd like to modify. For more information, see Navigating to your GitHub App settings in this article.
Under "Identifying and authorizing users," select or deselect Enable Device Flow.

Adding or updating a setup URL
You can redirect people to a specific URL after they install your app. See Registering a GitHub App.
If you select Request user authorization (OAuth) during installation, you will not be able to enter a setup URL. Users will instead be redirected to the Callback URL as part of the authorization flow, where you can describe additional setup. See About the user authorization callback URL.

Navigate to the settings page for the app you'd like to modify. For more information, see Navigating to your GitHub App settings in this article.
Under "Post installation," in the "Setup URL" field, enter the URL where you'd like to redirect users after they install your app.
Optionally, if you want to redirect users to the setup URL after they update an installation, select Redirect on update. An update includes adding or removing a repository for an installation. If "Setup URL" is blank, this will be ignored.

Changing the permissions of a GitHub App
You can change the access permissions that are granted to your GitHub App using the following steps.
When you change the repository or organization permissions of an app, each account where the app is installed will need to approve the new permissions. When you change the account permissions of an app, each user that has authorized the app will need to approve the permission changes. In both cases, GitHub will send an email to each organization owner or user, notifying them of the request to update the app's permissions. Updated permissions won't take effect on an installation or user authorization until the new permissions are approved. You can use the installation webhook to find out when people accept new permissions for your app.
Changing the permissions of an app may also change the webhooks that your app can subscribe to and the actions that your app can take with the API. See Choosing permissions for a GitHub App.

Navigate to the settings page for the app you'd like to modify. For more information, see Navigating to your GitHub App settings in this article.
In the GitHub Apps settings sidebar, click Permissions & events.
Under the sections "Repository permissions," "Organization permissions," and "Account permissions," modify the permissions you'd like to change. For each type of permission, select either "Read-only," "Read and write," or "No access" from the dropdown. See Choosing permissions for a GitHub App.
Optionally, under "Add a note to users," add a note telling your users why you are changing the permissions that your GitHub App requests.
Click Save changes.

Activating or deactivating the GitHub App webhook
You can configure your GitHub App to receive webhooks for specific events on GitHub and automatically take action on them. See Using webhooks with GitHub Apps.

Navigate to the settings page for the app you'd like to modify. For more information, see Navigating to your GitHub App settings in this article.
Under "Webhook," to enable or disable the webhook, select or deselect Active.
If you selected Active in the previous step, under "Webhook URL," enter the URL that GitHub should send webhook events to.
Optionally, if you selected Active in the previous step, under "Webhook secret," enter a secret token to secure your webhooks. GitHub highly recommends that you set a webhook secret.

Changing the webhook event subscriptions of a GitHub App
You can change the webhook events that a GitHub App subscribes to using the following steps.
The specific webhook events that you can select for your GitHub App registration are determined by the type of permissions you selected for your app. You will first need to select the permissions you would like your app to have, and then you can subscribe your app to webhook events that are related to that set of permissions. See Using webhooks with GitHub Apps.

Navigate to the settings page for the app you'd like to modify. For more information, see Navigating to your GitHub App settings in this article.
Activate the GitHub App webhook. See Activating or deactivating the GitHub App webhook in this article.
In the GitHub Apps settings sidebar, click Permissions & events.
Under the sections "Repository permissions," "Organization permissions," and "Account permissions," select the permissions that are required for the events your app will subscribe to. See Changing the permissions of a GitHub App.
Under "Subscribe to Events," select the webhook events you would like your GitHub App to receive.
Click Save changes.

Changing the visibility of a GitHub App
You can change the visibility settings of your GitHub App to control who can install it. Public apps cannot be made private if they're installed on other accounts. See Making a GitHub App public or private.

Navigate to the settings page for the app you'd like to modify. For more information, see Navigating to your GitHub App settings in this article.
In the left sidebar, click Advanced.
Under "Danger zone," depending on the current visibility of your GitHub App, click either Make public or Make private.\n\n\n\nApps/Maintaining GitHub Apps/Activate optional featuresActivating optional features for GitHub AppsYou can test new optional features for your GitHub Apps.In this articleActivating optional features for GitHub AppsFurther readingWarning

Optional features are subject to change.

Activating optional features for GitHub Apps

In the upper-right corner of any page on GitHub, click your profile photo.
Navigate to your account settings.

For an app owned by a personal account, click Settings.
For an app owned by an organization:

Click Your organizations.
To the right of the organization, click Settings.




In the left sidebar, click  Developer settings.
Click Edit next to the GitHub App you want to enable an optional feature for.
In the settings sidebar, click Optional features.
Next to the optional feature you want to enable for your app, click Opt-in.

Further reading

Modifying a GitHub App registration\n\n\n\nApps/Maintaining GitHub Apps/GitHub App managersAbout GitHub App managersOrganization owners can grant or revoke access for a user to manage some or all of the GitHub App registrations owned by the organization.Organization owners can designate other users in their organization as GitHub App managers. GitHub App managers can manage the settings of some or all of the GitHub App registrations that are owned by the organization. The GitHub App manager role does not grant users access to install and uninstall GitHub Apps on an organization. For more information about the specific app settings that a GitHub App manager can control, see Modifying a GitHub App registration.
For more information about GitHub App manager permissions, see Roles in an organization. For more information about how to designate someone as a GitHub App manager, see Adding and removing GitHub App managers in your organization.\n\n\n\nApps/Maintaining GitHub Apps/Manage allowed IP addressesManaging allowed IP addresses for a GitHub AppYou can add an IP allow list to your GitHub App registration to prevent your app from being blocked by an organization's own allow list.In this articleAbout IP address allow lists for GitHub AppsAdding an IP address allow list to a GitHub App registrationAbout IP address allow lists for GitHub Apps
Enterprise and organization owners can restrict access to assets by configuring an IP address allow list. This list specifies the IP addresses that are allowed to connect. For more information, see Enforcing policies for security settings in your enterprise.
When an organization has an allow list, third-party applications that connect via a GitHub App will be denied access unless either of the following condition sets are true:

The creator of the GitHub App has configured an allow list for the application that specifies the IP addresses at which their application runs. See below for details of how to do this, and
The organization owner has chosen to permit the addresses in the GitHub App's allow list to be added to their own allow list. For more information, see Managing allowed IP addresses for your organization in the GitHub Enterprise Cloud documentation.

or

The organization owner has added an IP allow list entry for the IP addresses from which the application runs. See Adding an allowed IP address in the GitHub Enterprise Cloud documentation.

Note

The addresses in the IP allow list of a GitHub App only affect requests made by installations of the GitHub App. The automatic addition of a GitHub App's IP address to an organization's allow list does not allow access to a GitHub user who connects from that IP address.

Adding an IP address allow list to a GitHub App registration
Note

GitHub is gradually rolling out support for IPv6. As GitHub services continue to add IPv6 support, we will start recognizing IPv6 addresses of GitHub users. To prevent possible access interruptions, please ensure you have added any necessary IPv6 addresses to your IP allow list.

Note

Due to caching, adding or removing IP addresses can take a few minutes to fully take effect.



In the upper-right corner of any page on GitHub, click your profile photo.


Navigate to your account settings.

For an app owned by a personal account, click Settings.
For an app owned by an organization:

Click Your organizations.
To the right of the organization, click Settings.





In the left sidebar, click  Developer settings.


In the left sidebar, click GitHub Apps.


To the right of the GitHub App you want to modify, click Edit.


At the bottom of the "IP allow list" section, in the "IP address or range in CIDR notation" field, type an IP address, or a range of addresses in CIDR notation.



Optionally, in the "Short description of IP address or range" field, enter a description of the allowed IP address or range.
The description is for your reference and is not used in the allow list of organizations where the GitHub App is installed. Instead, organization allow lists will include "Managed by the NAME GitHub App" as the description.


Click  Add.\n\n\n\nApps/Maintaining GitHub Apps/Suspend an installationSuspending a GitHub App installationYou can temporarily block your GitHub App from accessing resources owned by the accounts that installed the GitHub App.Note

If you want to suspend a GitHub App that you use but do not own, see Reviewing and modifying installed GitHub Apps instead.

When a GitHub App is suspended for an installation, the GitHub App cannot access resources owned by that installation account. For example, you might want to suspend your GitHub App if you are worried that your app's credentials were leaked.
The owner of a GitHub App can suspend the GitHub App for a specific installation. If an organization has designated any app managers for an app owned by the organization, the app managers can also suspend the GitHub App for a specific installation. GitHub App owners and managers can only use the API to suspend their app, and they must suspend the app individually for each installation. For more information, see REST API endpoints for GitHub Apps.
Users who installed a GitHub App on their personal account or organization can also suspend a GitHub App from accessing resources owned by their account. People who have installed a GitHub App can only use the GitHub web interface to suspend their app. For more information, see Reviewing and modifying installed GitHub Apps.
A GitHub App must be unsuspended in the same way it was suspended. If an owner or manager of a GitHub App suspended the app, they can also unsuspend it, but the owner of an account where the app is installed cannot unsuspend it. Similarly, if the owner of an account where a GitHub App is installed suspended the app, they can also unsuspend it, but an owner or manager of the app cannot unsuspend it.\n\n\n\nApps/Maintaining GitHub Apps/Transfer ownershipTransferring ownership of a GitHub AppYou can transfer ownership of a GitHub App registration to another user or organization.In this articleAbout transferring GitHub AppsTransferring a GitHub App registrationAbout transferring GitHub Apps
The owner of a GitHub App registration can transfer ownership of the GitHub App registration to another account. If an organization has designated any app managers for an app owned by the organization, the app managers can also transfer ownership of the GitHub App registration. For more information about app managers, see Adding and removing GitHub App managers in your organization.
You can transfer apps from a user or organization to another account. You cannot transfer ownership to a team.
Transferring a GitHub App registration

In the upper-right corner of any page on GitHub, click your profile photo.
Navigate to your account settings.

For an app owned by a personal account, click Settings.
For an app owned by an organization:

Click Your organizations.
To the right of the organization, click Settings.




In the left sidebar, click  Developer settings.
In the left sidebar, click GitHub Apps.
Select the GitHub App whose ownership you want to transfer.
In the left sidebar, click Advanced.
Click Transfer ownership.
Under "New owner's GitHub username, organization, or enterprise name", type the name of the account you want to transfer the GitHub App to.
Select the account from the dropdown that you wish to transfer to. Be aware that enterprises and organizations can have the same name, so check that you are transferring to the correct account type.
If transferring the app would uninstall it from your account, a warning will appear.
Click Transfer this GitHub App.\n\n\n\nApps/Maintaining GitHub Apps/Delete your appDeleting a GitHub AppYou can delete GitHub Apps that you own if you no longer want to use or maintain the app.In this articleAbout deleting GitHub AppsDeleting a GitHub AppNote

If you want to remove a GitHub App that you use but do not own, see Reviewing and modifying installed GitHub Apps instead.

About deleting GitHub Apps
If you own a GitHub App or are an app manager for a GitHub App, you can delete the GitHub App registration. For more information about GitHub App managers, see About GitHub App managers.
When you delete a GitHub App registration, the app will be uninstalled from all accounts that the app is installed on.
Note

If your GitHub App is published on GitHub Marketplace, you must remove your app from GitHub Marketplace before you can delete your app. For more information, see Deleting your app listing from GitHub Marketplace.

Deleting a GitHub App


In the upper-right corner of any page on GitHub, click your profile photo.


Navigate to your account settings.

For an app owned by a personal account, click Settings.
For an app owned by an organization:

Click Your organizations.
To the right of the organization, click Settings.





In the left sidebar, click  Developer settings.


In the left sidebar, click GitHub Apps.


Select the GitHub App you want to delete.


In the left sidebar, click Advanced.


Click Delete GitHub App.


In the confirmation box, type the name of the GitHub App to confirm you want to delete it.


Click I understand the consequences, delete this GitHub App.


These steps only delete your GitHub App registration, and all of the organization and account installations it may have. They do not delete any code that you wrote for your app. However, any code that relies on your GitHub App's credentials will no longer function.\n\n\n\nApps/GitHub Marketplace/Overview/About GitHub Marketplace for appsAbout GitHub Marketplace for appsLearn about GitHub Marketplace where you can share your apps with everyone.In this articleGitHub ActionsAppsPublishing an app to GitHub Marketplace overviewSeeing how your app is performingContacting SupportGitHub Marketplace connects you to developers who want to extend and improve their GitHub workflows. You can list free and paid tools for developers to use in GitHub Marketplace. GitHub Marketplace offers developers two types of tools: GitHub Actions and Apps, and each tool requires different steps for adding it to GitHub Marketplace.
GitHub Actions
Anyone can publish an action in GitHub Marketplace. GitHub verifies some partner organizations and these are shown as verified creators.
To learn about publishing GitHub Actions in GitHub Marketplace, see Publishing actions in GitHub Marketplace.
Apps
Anyone can share their apps with other users for free on GitHub Marketplace but only apps owned by organizations can sell their app.
To publish paid plans for your app and display a marketplace badge, you must complete the publisher verification process. For more information, see Applying for publisher verification for your organization or Requirements for listing an app.
Once the organization meets the requirements, someone with owner permissions in the organization can publish paid plans for any of their apps. Each app with a paid plan also goes through a financial onboarding process to enable payments.
To publish apps with free plans, you only need to meet the general requirements for listing any app. For more information, see Requirements for listing an app.
New to apps?
If you're interested in creating an app for GitHub Marketplace, but you're new to GitHub Apps or OAuth apps, see About creating GitHub Apps or Building OAuth apps.
GitHub Apps vs. OAuth apps
GitHub Apps are the officially recommended way to integrate with GitHub because they offer much more granular permissions to access data, although you can list both OAuth and GitHub Apps in GitHub Marketplace. For more information, see Differences between GitHub Apps and OAuth apps and Migrating OAuth apps to GitHub Apps.
GitHub Copilot Extensions
GitHub Copilot Extensions are a type of GitHub App that integrates the power of external tools into GitHub Copilot Chat. Copilot Extensions can be developed by anyone, for private or public use, and can be shared with others through the GitHub Marketplace.
To learn more about Copilot Extensions, see Using extensions to integrate external tools with Copilot Chat.
Publishing an app to GitHub Marketplace overview
When you have finished creating your app, you can share it with other users by publishing it to GitHub Marketplace. In summary, the process is:


Review your app carefully to ensure that it will behave as expected in other repositories and that it follows best practice guidelines. For more information, see Security best practices for apps on GitHub Marketplace and Requirements for listing an app.


Add webhook events to the app to track user billing requests. For more information about the GitHub Marketplace API, webhook events, and billing requests, see Using the GitHub Marketplace API in your app.


Create a draft GitHub Marketplace listing. For more information, see Drafting a listing for your app.


Add a pricing plan. For more information, see Setting pricing plans for your listing.


Read and accept the terms of the GitHub Marketplace Developer Agreement.


Submit your listing for publication in GitHub Marketplace. For more information, see Submitting your listing for publication.


Seeing how your app is performing
You can access metrics and transactions for your listing. For more information, see:

Viewing metrics for your listing
Viewing transactions for your listing

Contacting Support
If you have questions about GitHub Marketplace, please contact us through the GitHub Support portal.\n\n\n\nApps/GitHub Marketplace/Overview/About marketplace badgesAbout marketplace badgesLearn about the badges that you may see for some apps listings on GitHub Marketplace.Note

This article applies to publishing apps in GitHub Marketplace only. For more information about publishing GitHub Actions in GitHub Marketplace, see Publishing actions in GitHub Marketplace.

Certain apps on the GitHub Marketplace have the  badge and a tooltip that says "Publisher domain and email verified". This means that the app is owned by an organization that has:

Verified ownership of their domain and has a verified badge on their profile
Confirmed their email address so GitHub Support can reach the organization
Required two-factor authentication for their organization. For more information, see Requiring two-factor authentication in your organization.


Warning

GitHub does not analyze or inspect third party code. GitHub Marketplace publishers are responsible for the upkeep and maintenance of any third-party apps. The marketplace badge  only confirms that the publisher meets the requirements listed above.

To learn how you can add this badge to your app, see Applying for publisher verification for your organization.
Some apps on the GitHub Marketplace have the  badge and a tooltip that says "App meets the requirements for listing" instead of, "Publisher domain and email verified." This means that the app meets the listing requirements described in Requirements for listing an app, but the publisher has not been verified, as described in Applying for publisher verification for your organization. Apps with this badge cannot change their pricing plan until the publisher successfully applies for verification.

For more information about the requirements for listing an app on GitHub Marketplace, see Requirements for listing an app.
For information on finding apps to use, see Searching GitHub Marketplace.\n\n\n\nApps/GitHub Marketplace/Overview/Publisher verificationApplying for publisher verification for your organizationTo offer paid plans for your app or to include a marketplace badge in your app listing, you must complete the publisher verification process for your organization.In this articleRequesting publisher verificationFurther readingNote

This article applies to publishing apps in GitHub Marketplace only. For more information about publishing GitHub Actions in GitHub Marketplace, see Publishing actions in GitHub Marketplace.

Publisher verification ensures that GitHub has a way to contact you, that you've enabled two-factor authentication for your organization, and that your organization's domain has been verified.
Once your organization has been verified, you can publish paid plans for your app. For information, see Setting pricing plans for your listing.
To offer paid plans for your app, the app must be owned by an organization and you must have owner permissions in the organization. If your app is currently owned by a personal account, you'll need to transfer the ownership of the app to an organization. For more information, see Transferring ownership of a GitHub App or Transferring ownership of an OAuth app.
Requesting publisher verification


In the upper-right corner of GitHub, select your profile photo, then click  Your organizations.


Next to the organization, click Settings.


At the bottom of the left sidebar, click Developer settings.


Under "Developer settings", click Publisher Verification.


Under "Publisher Verification", complete the information in the checklist:

Ensure that your basic profile information is present and accurate. Also, make sure that you've included the best email address for support and updates from GitHub.
Ensure that Two-factor authentication is enabled for your organization. For more information, see Requiring two-factor authentication in your organization.
Submit a verified domain and ensure that a "Verified" badge displays on your organization's profile page. For related information, see Verifying or approving a domain for your organization.



Click Request Verification. GitHub will review your details and let you know once your publisher verification is complete.


Further reading
For information about the process of publishing apps, see About GitHub Marketplace for apps.\n\n\n\nApps/GitHub Marketplace/Create Marketplace apps/Listing requirementsRequirements for listing an appApps on GitHub Marketplace must meet the requirements outlined on this page before the listing can be published.In this articleRequirements for all GitHub Marketplace listingsConsiderations for free appsRequirements for GitHub Copilot ExtensionsRequirements for paid appsBilling requirements for paid appsNote

This article applies to publishing apps in GitHub Marketplace only. For more information about publishing GitHub Actions in GitHub Marketplace, see Publishing actions in GitHub Marketplace.

The requirements for listing an app on GitHub Marketplace vary according to whether you want to offer a free or a paid app.
Requirements for all GitHub Marketplace listings
All listings on GitHub Marketplace should be for tools that provide value to the GitHub community. When you submit your listing for publication, you must read and accept the terms of the GitHub Marketplace Developer Agreement.
User experience requirements for all apps
All listings should meet the following requirements, regardless of whether they are for a free or paid app.

Listings must not actively persuade users away from GitHub.
Listings must include valid contact information for the publisher.
Listings must have a relevant description of the application.
Listings must specify a pricing plan.
Apps must provide value to customers and integrate with the platform in some way beyond authentication.
Apps must be publicly available in GitHub Marketplace and cannot be in public preview or available by invite only, with the exception of Copilot Extensions.
Apps must have webhook events set up to notify the publisher of any plan changes or cancellations using the GitHub Marketplace API. For more information, see Using the GitHub Marketplace API in your app.

For more information on providing a good customer experience, see Customer experience best practices for apps.
Brand and listing requirements for all apps

Apps that use GitHub logos must follow the GitHub guidelines. For more information, see GitHub Logos and Usage.
Apps must have a logo, feature card, and screenshots images that meet the recommendations provided in Writing a listing description for your app.
Listings must include descriptions that are well written and free of grammatical errors. For guidance in writing your listing, see Writing a listing description for your app.

To protect your customers, we recommend that you also follow security best practices. For more information, see Security best practices for apps on GitHub Marketplace.
Considerations for free apps
Free apps are encouraged in GitHub Marketplace and are a great way to offer open source services. If you list a paid version of your app outside of GitHub Marketplace, you must offer at least one paid plan when listing the app in GitHub Marketplace.
Requirements for GitHub Copilot Extensions
Copilot Extensions are essentially GitHub Apps with additional read access to Copilot Chat, integration with the Copilot API, and optional integration into other LLMs.
To publish an extension, it must be owned by an organization account with Verified Creator status. For more information about the verification process or transferring ownership of your app, see Applying for publisher verification for your organization.
The requirements to publish a Copilot Extension are the same as the requirements for free apps, with the following exceptions:


Your extension must provide a clear and descriptive response to a prompt like "What can you do?" or "List your capabilities".


Your extension can be in public preview as long as that is clearly communicated in the listing description. If you are using a waitlist, you must also include a link to sign up at the top of the description. Someone from the GitHub review team will join the waitlist and email your technical lead requesting access for testing.


You must include links to two videos that demonstrate the following:

A few example prompts and responses from your extension
A net new user installing, authenticating, and sending their first prompt to your extension

These videos are private to GitHub and are used solely for reviewing your listing submission. The videos can be brief, and you don't need to edit them.


Your extension must provide a stable and reliable user experience, and be able to perform the capabilities listed in the description.


You must provide a pathway for new users to install, set up, and authorize your extension with minimal friction. If the GitHub review team is not able to successfully test your extension, it will not be approved for publishing.


Requirements for paid apps
To publish a paid plan for your app on the GitHub Marketplace, your app must be owned by an organization that is a verified publisher. For more information about the verification process or transferring ownership of your app, see Applying for publisher verification for your organization.
If your app is already published and you're a verified publisher, then you can publish a new paid plan from the pricing plan editor. For more information, see Setting pricing plans for your listing.
To publish a paid app (or an app that offers a paid plan), you must also meet the following requirements:

GitHub Apps should have a minimum of 100 installations.
OAuth apps should have a minimum of 200 users.
All paid apps must handle GitHub Marketplace purchase events for new purchases, upgrades, downgrades, cancellations, and free trials. For more information, see Billing requirements for paid apps below.

When you are ready to publish the app on GitHub Marketplace you must request verification for the app listing.
Note

If you want to sell an app that's owned by your personal account, first you'll need to transfer the app to an organization, and then request verification for a listing created by the organization. For information on how to transfer an app to an organization, see: Submitting your listing for publication.

Billing requirements for paid apps
Your app does not need to handle payments but does need to use GitHub Marketplace purchase events to manage new purchases, upgrades, downgrades, cancellations, and free trials. For information about how to integrate these events into your app, see Using the GitHub Marketplace API in your app.
Using GitHub's billing API allows customers to purchase an app without leaving GitHub and to pay for the service with the payment method already attached to their account on GitHub.

Apps must support both monthly and annual billing for paid subscriptions purchases.
Listings may offer any combination of free and paid plans. Free plans are optional but encouraged. For more information, see Setting pricing plans for your listing.\n\n\n\nApps/GitHub Marketplace/Create Marketplace apps/Security best practiceSecurity best practices for apps on GitHub MarketplaceGuidelines for preparing a secure app to share on GitHub Marketplace.Note

This article applies to publishing apps in GitHub Marketplace only. For more information about publishing GitHub Actions in GitHub Marketplace, see Publishing actions in GitHub Marketplace.

Before listing an app on GitHub Marketplace, you should follow the best practices for the type of app that you are listing:

Best practices for creating a GitHub App
Best practices for creating an OAuth app

Additionally, you should have the capability to notify GitHub within 24 hours of a confirmed security incident.
In addition to following security best practices, you should also follow customer experience best practices. For more information, see Customer experience best practices for apps.\n\n\n\nApps/GitHub Marketplace/Create Marketplace apps/Customer experience best practiceCustomer experience best practices for appsGuidelines for creating an app that will be easy to use and understand.In this articleCustomer communicationPlan managementFurther readingNote

This article applies to publishing apps in GitHub Marketplace only. For more information about publishing GitHub Actions in GitHub Marketplace, see Publishing actions in GitHub Marketplace.

If you follow these best practices it will help you to provide a good customer experience.
Customer communication

Marketing materials for the app should accurately represent the app's behavior.
Apps should include links to user-facing documentation that describe how to set up and use the app.
Customers should be able to see what type of plan they have in the billing, profile, or account settings section of the app.
Customers should be able to install and use your app on both a personal account and an organization account. They should be able to view and manage the app on those accounts separately.
Apps should provide customers with a way to delete their account, without having to email or call a support person. Apps should delete all GitHub user data within 30 days of receiving a request from the user, or within 30 days of the end of the user's legal relationship with GitHub.

Plan management

Customers who cancel a paid plan purchased from GitHub Marketplace should be automatically downgraded to the app's free plan if it exists. When a customer cancels a GitHub Marketplace subscription, GitHub does not automatically uninstall the app, so the customer can expect that free features will continue to function. It's highly recommended to allow customers to re-enable their previous plan.
Customers should be able to upgrade from your app's user interface if you provide an upgrade URL in this format: https://www.github.com/marketplace/<LISTING_NAME>/upgrade/<LISTING_PLAN_NUMBER>/<CUSTOMER_ACCOUNT_ID>
Customers should be able to modify which users have access to your app from your app's website if they purchased seats (per-unit pricing plan) or the plan offers unlimited collaborators.
Customers should be able to see the following changes to their account immediately in the billing, profile, or account settings section of the app's website:

Current plan and price.
New plans purchased.
Upgrades, downgrades, cancellations, and the number of remaining days in a free trial.
Changes to billing cycles (monthly or yearly).
Usage and remaining resources for flat-rate and per-unit plans. For example, if the pricing plan is per-unit, your app's site should show units used and units available.



Further reading

Best practices for creating a GitHub App
Best practices for creating an OAuth app
Security best practices for apps on GitHub Marketplace\n\n\n\nApps/GitHub Marketplace/Create Marketplace apps/View listing metricsViewing metrics for your listingThe GitHub Marketplace Insights page displays metrics for your GitHub App. You can use the metrics to track your GitHub App's performance and make more informed decisions about pricing, plans, free trials, and how to visualize the effects of marketing campaigns.Note

This article applies to publishing apps in GitHub Marketplace only. For more information about publishing GitHub Actions in GitHub Marketplace, see Publishing actions in GitHub Marketplace.

You can view metrics for the past day (24 hours), week, month, or for the entire duration of time that your GitHub App has been listed.
Note

Because it takes time to aggregate data, you'll notice a slight delay in the dates shown. When you select a time period, you can see exact dates for the metrics at the top of the page.

Performance metrics
The Insights page displays these performance metrics, for the selected time period:

Subscription value: Total possible revenue (in US dollars) for subscriptions. This value represents the possible revenue if no plans or free trials are cancelled and all credit transactions are successful. The subscription value includes the full value for plans that begin with a free trial in the selected time period, even when there are no financial transactions in that time period. The subscription value also includes the full value of upgraded plans in the selected time period but does not include the prorated amount. To see and download individual transactions, see Viewing transactions for your listing.
Visitors: Number of people that have viewed a page in your GitHub Apps listing. This number includes both logged in and logged out visitors.
Pageviews: Number of views the pages in your GitHub App's listing received. A single visitor can generate more than one page view.

Note

Your estimated subscription value could be much higher than the transactions processed for this period.

Conversion performance

Unique visitors to landing page: Number of people who viewed your GitHub App's landing page.
Unique visitors to checkout page: Number of people who viewed one of your GitHub App's checkout pages.
Checkout page to new subscriptions: Total number of paid subscriptions, free trials, and free subscriptions. See the "Breakdown of total subscriptions" for the specific number of each type of subscription.


To access GitHub Marketplace Insights:


In the upper-right corner of any page on GitHub, click your profile photo, then click  Settings.


In the left sidebar, click  Developer settings.


In the left sidebar, click either OAuth Apps or GitHub Apps depending on the GitHub Marketplace listing you'd like to manage.
Note

You can also manage your listing by navigating to https://github.com/marketplace/manage.




To select the GitHub App that you'd like to view Insights for, click Edit.


On the app settings landing page, scroll down to the Marketplace section and click List in Marketplace. If you already have a Marketplace draft listing, click Edit Marketplace listing. The Marketplace section is only visible if you allowed your app to be installed by any user or organization when registering the app. For more information, see the list of Marketplace requirements.


Click the Insights tab.


Optionally, select a different time period by clicking the Period dropdown in the upper-right corner of the Insights page.\n\n\n\nApps/GitHub Marketplace/Create Marketplace apps/View listing transactionsViewing transactions for your listingThe GitHub Marketplace transactions page allows you to download and view all transactions for your GitHub Marketplace listing. You can view transactions for the past day (24 hours), week, month, or for the entire duration of time that your GitHub App has been listed.In this articleTransaction data fieldsAccessing GitHub Marketplace transactionsNote

This article applies to publishing apps in GitHub Marketplace only. For more information about publishing GitHub Actions in GitHub Marketplace, see Publishing actions in GitHub Marketplace.

Note

Because it takes time to aggregate data, you'll notice a slight delay in the dates shown. When you select a time period, you can see exact dates for the metrics at the top of the page.

You can view or download the transaction data to keep track of your subscription activity. Click the Export CSV button to download a .csv file. You can also select a period of time to view and search within the transaction page.
Transaction data fields

date: The date of the transaction in yyyy-mm-dd format.
app_name: The app name.
user_login: The login of the user with the subscription.
user_id: The id of the user with the subscription.
user_type: The type of GitHub account, either User or Organization.
country: The three letter country code.
amount_in_cents: The amount of the transaction in cents. When a value is less the plan amount, the user upgraded and the new plan is prorated. A value of zero indicates the user canceled their plan.
renewal_frequency: The subscription renewal frequency, either Monthly or Yearly.
marketplace_listing_plan_id: The id of the subscription plan.
region: The name of the region present in billing address.
postal_code: The postal code value present in billing address.


Accessing GitHub Marketplace transactions
To access GitHub Marketplace transactions:


In the upper-right corner of any page on GitHub, click your profile photo, then click  Settings.


In the left sidebar, click  Developer settings.


In the left sidebar, click either OAuth Apps or GitHub Apps depending on the GitHub Marketplace listing you'd like to manage.
Note

You can also manage your listing by navigating to https://github.com/marketplace/manage.




Select the GitHub App that you'd like to view transactions for.


On the app settings landing page, scroll down to the Marketplace section and click List in Marketplace. If you already have a Marketplace draft listing, click Edit Marketplace listing. The Marketplace section is only visible if you allowed your app to be installed by any user or organization when registering the app. For more information, see the list of Marketplace requirements.


Click the Transactions tab.


Optionally, select a different time period by clicking the Period dropdown in the upper-right corner of the Transactions page.\n\n\n\nApps/GitHub Marketplace/Marketplace API usage/REST APIREST endpoints for the GitHub Marketplace APITo help manage your app on GitHub Marketplace, use these GitHub Marketplace API endpoints.Note

This article applies to publishing apps in GitHub Marketplace only. For more information about publishing GitHub Actions in GitHub Marketplace, see Publishing actions in GitHub Marketplace.

Here are some useful endpoints available for Marketplace listings:

List plans
List accounts for a plan
Get a subscription plan for an account
List subscriptions for the authenticated user

See these pages for details on how to authenticate when using the GitHub Marketplace API:

Authorization options for OAuth apps
Authentication options for GitHub Apps

Note

Rate limits for the REST API apply to all GitHub Marketplace API endpoints.\n\n\n\nApps/GitHub Marketplace/Marketplace API usage/Webhook eventsWebhook events for the GitHub Marketplace APIA GitHub Marketplace app receives information about changes to a user's plan from the Marketplace purchase event webhook. A Marketplace purchase event is triggered when a user purchases, cancels, or changes their payment plan.Note

This article applies to publishing apps in GitHub Marketplace only. For more information about publishing GitHub Actions in GitHub Marketplace, see Publishing actions in GitHub Marketplace.

For more information about the GitHub Marketplace webhook payload, see Webhook events and payloads.
Webhooks POST requests have special headers. See Webhook events and payloads for more details. GitHub doesn't resend failed delivery attempts. Ensure your app can receive all webhook payloads sent by GitHub. For information about how to create and disable GitHub Marketplace webhooks, see Creating webhooks and Disabling webhooks.
Cancellations and downgrades take effect on the first day of the next billing cycle. Events for downgrades and cancellations are sent when the new plan takes effect at the beginning of the next billing cycle. Events for new purchases and upgrades begin immediately. Use the effective_date in the webhook payload to determine when a change will begin.
Note

If you notice any spammy GitHub Marketplace purchases or other malicious behavior, please complete the report abuse form with more information on the user.\n\n\n\nApps/GitHub Marketplace/Marketplace API usage/Testing your appTesting your appGitHub recommends testing your app with APIs and webhooks before submitting your listing to GitHub Marketplace so you can provide an ideal experience for customers. Before an onboarding expert approves your app, it must adequately handle the billing flows.In this articleTesting appsTesting APIsTesting webhooksNote

This article applies to publishing apps in GitHub Marketplace only. For more information about publishing GitHub Actions in GitHub Marketplace, see Publishing actions in GitHub Marketplace.

Testing apps
You can use a draft GitHub Marketplace listing to simulate each of the billing flows. A listing in the draft state means that it has not been submitted for approval. Any purchases you make using a draft GitHub Marketplace listing will not create real transactions, and GitHub will not charge your credit card. Note that you can only simulate purchases for plans published in the draft listing and not for draft plans. For more information, see Drafting a listing for your app and Using the GitHub Marketplace API in your app.
Using a development app with a draft listing to test changes
A GitHub Marketplace listing can only be associated with a single app registration, and each app can only access its own GitHub Marketplace listing. For these reasons, we recommend configuring a separate development app, with the same configuration as your production app, and creating a draft GitHub Marketplace listing that you can use for testing. The draft GitHub Marketplace listing allows you to test changes without affecting the active users of your production app. You will never have to submit your development GitHub Marketplace listing, since you will only use it for testing.
Because you can only create draft GitHub Marketplace listings for public apps, you must make your development app public. Public apps are not discoverable outside of published GitHub Marketplace listings as long as you don't share the app's URL. A Marketplace listing in the draft state is only visible to the app's owner.
Once you have a development app with a draft listing, you can use it to test changes you make to your app while integrating with the GitHub Marketplace API and webhooks.
Warning

Do not make test purchases with an app that is live in GitHub Marketplace.

Simulating Marketplace purchase events
Your testing scenarios may require setting up listing plans that offer free trials and switching between free and paid subscriptions. Because downgrades and cancellations don't take effect until the next billing cycle, GitHub provides a developer-only feature to "Apply Pending Change" to force changed and cancelled plan actions to take effect immediately. You can access Apply Pending Change for apps with draft Marketplace listings in https://github.com/settings/billing#pending-cycle:
Testing APIs
For most GitHub Marketplace API endpoints, we also provide stubbed API endpoints that return hard-coded, fake data you can use for testing. To receive stubbed data, you must specify stubbed URLs, which include /stubbed in the route (for example, /user/marketplace_purchases/stubbed). For a list of endpoints that support this stubbed-data approach, see GitHub Marketplace endpoints.
Testing webhooks
GitHub provides tools for testing your deployed payloads. For more information, see Testing webhooks.\n\n\n\nApps/GitHub Marketplace/Marketplace API usage/New purchases & free trialsHandling new purchases and free trialsWhen a customer purchases a paid plan, free trial, or the free version of your GitHub Marketplace app, you'll receive the marketplace_purchase event webhook with the purchased action, which kicks off the purchasing flow.In this articleStep 1. Initial purchase and webhook eventStep 2. InstallationStep 3. AuthorizationStep 4. Provisioning customer accountsNote

This article applies to publishing apps in GitHub Marketplace only. For more information about publishing GitHub Actions in GitHub Marketplace, see Publishing actions in GitHub Marketplace.

Warning

If you offer a GitHub App in GitHub Marketplace, your app must identify users following the OAuth authorization flow. You don't need to set up a separate OAuth app to support this flow. See Authenticating with a GitHub App on behalf of a user for more information.

Step 1. Initial purchase and webhook event
Before a customer purchases your GitHub Marketplace app, they select a listing plan. They also choose whether to purchase the app from their personal account or an organization account.
The customer completes the purchase by clicking Complete order and begin installation.
GitHub then sends the marketplace_purchase webhook with the purchased action to your app.
Read the effective_date and marketplace_purchase object from the marketplace_purchase webhook to determine which plan the customer purchased, when the billing cycle starts, and when the next billing cycle begins.
If your app offers a free trial, read the marketplace_purchase[on_free_trial] attribute from the webhook. If the value is true, your app will need to track the free trial start date (effective_date) and the date the free trial ends (free_trial_ends_on). Use the free_trial_ends_on date to display the remaining days left in a free trial in your app's UI. You can do this in either a banner or in your billing UI. To learn how to handle cancellations before a free trial ends, see Handling plan cancellations. See Handling plan changes to find out how to transition a free trial to a paid plan when a free trial expires.
See Webhook events for the GitHub Marketplace API for an example of the marketplace_purchase event payload.
Step 2. Installation
If your app is a GitHub App, GitHub prompts the customer to select which repositories the app can access when they purchase it. GitHub then installs the app on the account the customer selected and grants access to the selected repositories.
At this point, if you specified a Setup URL in your GitHub App settings, GitHub will redirect the customer to that URL. If you do not specify a setup URL, you will not be able to handle purchases of your GitHub App.
Note

The Setup URL is described as optional in GitHub App settings, but it is a required field if you want to offer your app in GitHub Marketplace. For more information, see About the setup URL.

If your app is an OAuth app, GitHub does not install it anywhere. Instead, GitHub redirects the customer to the Installation URL you specified in your GitHub Marketplace listing.
When a customer purchases an OAuth app, GitHub redirects the customer to the URL you choose (either Setup URL or Installation URL) and the URL includes the customer's selected pricing plan as a query parameter: marketplace_listing_plan_id.
Step 3. Authorization
When a customer purchases your app, you must send the customer through the OAuth authorization flow:


If your app is a GitHub App, begin the authorization flow as soon as GitHub redirects the customer to the Setup URL. Follow the steps in Authenticating with a GitHub App on behalf of a user.


If your app is an OAuth app, begin the authorization flow as soon as GitHub redirects the customer to the Installation URL. Follow the steps in Authorizing OAuth apps.


For either type of app, the first step is to redirect the customer to https://github.com/login/oauth/authorize.
After the customer completes the authorization, your app receives an OAuth access token for the customer. You'll need this token for the next step.
Note

When authorizing a customer on a free trial, grant them the same access they would have on the paid plan. You'll move them to the paid plan after the trial period ends.

Step 4. Provisioning customer accounts
Your app must provision a customer account for all new purchases. Using the access token you received for the customer in Step 3. Authorization, call the GET /user/marketplace_purchases endpoint. The response will include the customer's account information and show whether they are on a free trial (on_free_trial). Use this information to complete setup and provisioning.
Note

In the current version of GitHub Marketplace, it's possible for a customer to purchase your app through GitHub Marketplace when they already have an existing account purchased from your app's website. If you find that you already have an account set up for the customer who purchased your app, please report the "double" purchases to GitHub Support.

If the purchase is for an organization and per-user, you can prompt the customer to choose which organization members will have access to the purchased app.
You can customize the way that organization members receive access to your app. Here are a few suggestions:
Flat-rate pricing: If the purchase is made for an organization using flat-rate pricing, your app can get all the organization’s members via the API and prompt the organization owner to choose which members will have paid users on the integrator side.
Per-unit pricing: One method of provisioning per-unit seats is to allow users to occupy a seat as they log in to the app. Once the customer hits the seat count threshold, your app can alert the user that they need to upgrade through GitHub Marketplace.\n\n\n\nApps/GitHub Marketplace/Marketplace API usage/Handling plan changesHandling plan changesUpgrading or downgrading a GitHub Marketplace app triggers the marketplace_purchase event webhook with the changed action, which kicks off the upgrade or downgrade flow.In this articleStep 1. Pricing plan change eventStep 2. Updating customer accountsFailed upgrade paymentsAbout upgrade URLsNote

This article applies to publishing apps in GitHub Marketplace only. For more information about publishing GitHub Actions in GitHub Marketplace, see Publishing actions in GitHub Marketplace.

For more information about upgrading and downgrading as it relates to billing, see Using the GitHub Marketplace API in your app.
Step 1. Pricing plan change event
GitHub send the marketplace_purchase webhook with the changed action to your app, when a customer makes any of these changes to their GitHub Marketplace order:

Upgrades to a more expensive pricing plan or downgrades to a lower priced plan.
Adds or removes seats to their existing plan.
Changes the billing cycle.

GitHub will send the webhook when the change takes effect. For example, when a customer downgrades a plan, GitHub sends the webhook at the end of the customer's billing cycle. GitHub sends a webhook to your app immediately when a customer upgrades their plan to allow them access to the new service right away. If a customer switches from a monthly to a yearly billing cycle, it's considered an upgrade. See Billing customers to learn more about what actions are considered an upgrade or downgrade.
Read the effective_date, marketplace_purchase, and previous_marketplace_purchase from the marketplace_purchase webhook to update the plan's start date and make changes to the customer's billing cycle and pricing plan. See Webhook events for the GitHub Marketplace API for an example of the marketplace_purchase event payload.
If your app offers free trials, you'll receive the marketplace_purchase webhook with the changed action when the free trial expires. If the customer's free trial expires, upgrade the customer to the paid version of the free-trial plan.
Step 2. Updating customer accounts
You'll need to update the customer's account information to reflect the billing cycle and pricing plan changes the customer made to their GitHub Marketplace order. Display upgrades to the pricing plan, seat_count (for per-unit pricing plans), and billing cycle on your Marketplace app's website or your app's UI when you receive the changed action webhook.
When a customer downgrades a plan, it's recommended to review whether a customer has exceeded their plan limits and engage with them directly in your UI or by reaching out to them by phone or email.
To encourage people to upgrade you can display an upgrade URL in your app's UI. See About upgrade URLs for more details.
Note

We recommend performing a periodic synchronization using GET /marketplace_listing/plans/:id/accounts to ensure your app has the correct plan, billing cycle information, and unit count (for per-unit pricing) for each account.

Failed upgrade payments
In the case where a customer upgrades their plan and the payment fails, GitHub reverts their GitHub Marketplace subscription to its previous state. GitHub also sends an email to the customer to inform them of the failure and allow them to re-attempt their purchase. You will receive a webhook with the changed action requesting you to revert to the previous plan.
About upgrade URLs
You can redirect users from your app's UI to upgrade on GitHub using an upgrade URL:
https://www.github.com/marketplace/<LISTING_NAME>/upgrade/<LISTING_PLAN_NUMBER>/<CUSTOMER_ACCOUNT_ID>

For example, if you notice that a customer is on a 5 person plan and needs to move to a 10 person plan, you could display a button in your app's UI that says "Here's how to upgrade" or show a banner with a link to the upgrade URL. The upgrade URL takes the customer to your listing plan's upgrade confirmation page.
Use the LISTING_PLAN_NUMBER for the plan the customer would like to purchase. When you create new pricing plans they receive a LISTING_PLAN_NUMBER, which is unique to each plan across your listing, and a LISTING_PLAN_ID, which is unique to each plan in the GitHub Marketplace. You can find these numbers when you List plans, which identifies your listing's pricing plans. Use the LISTING_PLAN_ID and the GET /marketplace_listing/plans/{plan_id}/accounts endpoint to get the CUSTOMER_ACCOUNT_ID.
Note

If your customer upgrades to additional units (such as seats), you can still send them to the appropriate plan for their purchase, but we are unable to support unit_count parameters at this time.\n\n\n\nApps/GitHub Marketplace/Marketplace API usage/Plan cancellationsHandling plan cancellationsCancelling a GitHub Marketplace app triggers the marketplace_purchase event webhook with the cancelled action, which kicks off the cancellation flow.In this articleStep 1. Cancellation eventStep 2. Deactivating customer accountsNote

This article applies to publishing apps in GitHub Marketplace only. For more information about publishing GitHub Actions in GitHub Marketplace, see Publishing actions in GitHub Marketplace.

For more information about cancelling as it relates to billing, see Billing customers.
Step 1. Cancellation event
If a customer chooses to cancel a GitHub Marketplace order, GitHub sends a marketplace_purchase webhook with the action cancelled to your app when the cancellation takes effect. If the customer cancels during a free trial, your app will receive the event immediately. When a customer cancels a paid plan, the cancellation will occur at the end of the customer's billing cycle.
Step 2. Deactivating customer accounts
When a customer cancels a free or paid plan, your app must perform these steps to complete cancellation:

Deactivate the account of the customer who canceled their plan.
Revoke the OAuth token your app received for the customer.
If your app is an OAuth app, remove all webhooks your app created for repositories.
Remove all customer data within 30 days of receiving the cancelled event.

Note

We recommend using the marketplace_purchase webhook's effective_date to determine when a plan change will occur and periodically synchronizing the List accounts for a plan. For more information on webhooks, see Webhook events for the GitHub Marketplace API.\n\n\n\nApps/GitHub Marketplace/List an app on the Marketplace/Draft an app listingDrafting a listing for your appWhen you create a GitHub Marketplace listing, GitHub saves it in draft mode until you submit the app for approval. Your listing shows customers how they can use your app.In this articleCreate a new draft GitHub Marketplace listingEditing your listingSubmitting your appNote

This article applies to publishing apps in GitHub Marketplace only. For more information about publishing GitHub Actions in GitHub Marketplace, see Publishing actions in GitHub Marketplace.

Create a new draft GitHub Marketplace listing
You can only create draft listings for apps that are public. Before creating your draft listing, you can read the following guidelines for writing and configuring settings in your GitHub Marketplace listing:

Writing GitHub Marketplace listing descriptions
Setting pricing plans for your listing
Configuring the GitHub Marketplace Webhook

To create a GitHub Marketplace listing:


In the upper-right corner of any page on GitHub, click your profile photo, then click  Settings.


In the left sidebar, click  Developer settings.


In the left sidebar, click either OAuth Apps or GitHub Apps depending on the app you're adding to GitHub Marketplace.
Note

You can also add a listing by navigating to https://github.com/marketplace/new, viewing your available apps, and clicking Create draft listing.




Select the app you'd like to add to GitHub Marketplace.


On the app settings landing page, scroll down to the Marketplace section and click List in Marketplace. If you already have a Marketplace draft listing, click Edit Marketplace listing. The Marketplace section is only visible if you allowed your app to be installed by any user or organization when registering the app. For more information, see the list of Marketplace requirements.


Once you've created a new draft listing, you'll see an overview of the sections that you'll need to visit before your GitHub Marketplace listing will be complete.



Note

In the "Contact info" section of your listing, we recommend using individual email addresses, rather than group emails addresses like support@domain.com. GitHub will use these email addresses to contact you about updates to GitHub Marketplace that might affect your listing, new feature releases, marketing opportunities, payouts, and information on conferences and sponsorships.

Editing your listing
Once you've created a GitHub Marketplace draft listing, you can come back to modify information in your listing anytime. If your app is already approved and in GitHub Marketplace, you can edit the information and images in your listing, but you will not be able to change existing published pricing plans. See Setting pricing plans for your listing.
Submitting your app
Once you've completed your GitHub Marketplace listing, you can submit your listing for review from the Overview page. You'll need to read and accept the GitHub Marketplace Developer Agreement, and then you can click Submit for review. After you submit your app for review, an onboarding expert will contact you with additional information about the onboarding process.\n\n\n\nApps/GitHub Marketplace/List an app on the Marketplace/Write listing descriptionsWriting a listing description for your appTo list your app in the GitHub Marketplace, you'll need to write descriptions of your app and provide images that follow GitHub's guidelines.In this articleNaming and linksLogo and feature cardListing detailsProduct screenshotsNote

This article applies to publishing apps in GitHub Marketplace only. For more information about publishing GitHub Actions in GitHub Marketplace, see Publishing actions in GitHub Marketplace.

Here are guidelines about the fields you'll need to fill out in the Listing description section of your draft listing.
Naming and links
Listing name
Your listing's name will appear on the GitHub Marketplace homepage. The name is limited to 255 characters and can be different from your app's name. Your listing cannot have the same name as an existing account on GitHub, unless the name is your own user or organization name.
Very short description of listing
The community will see the "very short" description under your app's name on the GitHub Marketplace homepage.

Length of "Very short description"
We recommend keeping short descriptions to 40-80 characters. Although you are allowed to use more characters, concise descriptions are easier for customers to read and understand quickly.
Content of "Very short description"


Describe the app’s functionality. Don't use this space for a call to action. For example:
DO: Lightweight project management for GitHub issues
DON'T: Manage your projects and issues on GitHub
Tip: Add an "s" to the end of the verb in a call to action to turn it into an acceptable description: Manages your projects and issues on GitHub


Don’t repeat the app’s name in the description.
DO: A container-native continuous integration tool
DON'T: Skycap is a container-native continuous integration tool


Formatting of "Very short description"


Always use sentence-case capitalization. Only capitalize the first letter and proper nouns.


Don't use punctuation at the end of your short description. Short descriptions should not include complete sentences, and definitely should not include more than one sentence.


Only capitalize proper nouns. For example:
DO: One-click delivery automation for web developers
DON'T: One-click delivery automation for Web Developers


Always use a serial comma in lists.


Avoid referring to the GitHub community as "users."
DO: Create issues automatically for people in your organization
DON'T: Create issues automatically for an organization's users


Avoid acronyms unless they’re well established (such as API). For example:
DO: Agile task boards, estimates, and reports without leaving GitHub
DON'T: Agile task boards, estimates, and reports without leaving GitHub's UI


Categories
Apps in GitHub Marketplace can be displayed by category. Select the category that best describes the main functionality of your app in the Primary category dropdown, and optionally select a Secondary category that fits your app.
Supported languages
If your app only works with specific languages, select up to 10 programming languages that your app supports. These languages are displayed on your app's GitHub Marketplace listing page. This field is optional.
Listing URLs
Required URLs

Customer support URL: The URL of a web page that your customers will go to when they have technical support, product, or account inquiries.
Privacy policy URL: The web page that displays your app's privacy policy.
Installation URL: This field is shown for OAuth apps only. (GitHub Apps don't use this URL because they use the optional Setup URL from the GitHub App's settings page instead.) When a customer purchases your OAuth app, GitHub will redirect customers to the installation URL after they install the app. You will need to redirect customers to https://github.com/login/oauth/authorize to begin the OAuth authorization flow. See Handling new purchases and free trials for more details. Skip this field if you're listing a GitHub App.

Optional URLs

Company URL: A link to your company's website.
Status URL: A link to a web page that displays the status of your app. Status pages can include current and historical incident reports, web application uptime status, and scheduled maintenance.
Documentation URL: A link to documentation that teaches customers how to use your app.

Logo and feature card
GitHub Marketplace displays all listings with a square logo image inside a circular badge to visually distinguish apps.

A feature card consists of your app's logo, name, and a custom background image that captures your brand personality. GitHub Marketplace displays this card if your app is one of the four randomly featured apps at the top of the homepage. Each app's very short description is displayed below its feature card.

As you upload images and select colors, your GitHub Marketplace draft listing will display a preview of your logo and feature card.
Guidelines for logos
You must upload a custom image for the logo. For the badge, choose a background color.

Upload a logo image that is at least 200 pixels x 200 pixels so your logo won't have to be upscaled when your listing is published.
Logos will be cropped to a square. We recommend uploading a square image file with your logo in the center.
For best results, upload a logo image with a transparent background.
To give the appearance of a seamless badge, choose a badge background color that matches the background color (or transparency) of your logo image.
Avoid using logo images with words or text in them. Logos with text do not scale well on small screens.

Guidelines for feature cards
You must upload a custom background image for the feature card. For the app's name, choose a text color.

Use a pattern or texture in your background image to give your card a visual identity and help it stand out against the dark background of the GitHub Marketplace homepage. Feature cards should capture your app's brand personality.
Background image measures 965 pixels x 482 pixels (width x height).
Choose a text color for your app's name that shows up clearly over the background image.

Listing details
To get to your app's landing page, click your app's name from the GitHub Marketplace homepage or category page. The landing page displays a longer description of the app, which includes two parts: an "Introductory description" and a "Detailed description."
Your "Introductory description" is displayed at the top of your app's GitHub Marketplace landing page.

Clicking Read more..., displays the "Detailed description."
Follow these guidelines for writing these descriptions.
Length of "Introductory description" and "Detailed description"
We recommend writing a 1-2 sentence high-level summary between 150-250 characters in the required "Introductory description" field when listing your app. Although you are allowed to use more characters, concise summaries are easier for customers to read and understand quickly.
You can add more information in the optional "Detailed description" field. You see this description when you click Read more... below the introductory description on your app's landing page. A detailed description consists of 3-5 value propositions, with 1-2 sentences describing each one. You can use up to 1,000 characters for this description.
Content of "Introductory description" and "Detailed description"


Always begin introductory descriptions with your app's name.


Always write descriptions and value propositions using the active voice.


Formatting of "Introductory description" and "Detailed description"


Always use sentence-case capitalization in value proposition titles. Only capitalize the first letter and proper nouns.


Use periods in your descriptions. Avoid exclamation marks.


Don't use punctuation at the end of your value proposition titles. Value proposition titles should not include complete sentences, and should not include more than one sentence.


For each value proposition, include a title followed by a paragraph of description. Format the title as a level-three header using Markdown. For example:


Learn the skills you need
GitHub Skills can help you learn how to use GitHub, communicate more effectively with Markdown, handle merge conflicts, and more.


Only capitalize proper nouns.


Always use the serial comma in lists.


Avoid referring to the GitHub community as "users."
DO: Create issues automatically for people in your organization
DON'T: Create issues automatically for an organization's users


Avoid acronyms unless they’re well established (such as API).


Product screenshots
You can upload up to five screenshot images of your app to display on your app's landing page. Add an optional caption to each screenshot to provide context. After you upload your screenshots, you can drag them into the order you want them to be displayed on the landing page.
Guidelines for screenshots

Images must be of high resolution (at least 1200px wide).
All images must be the same height and width (aspect ratio) to avoid page jumps when people click from one image to the next.
Show as much of the user interface as possible so people can see what your app does.
When taking screenshots of your app in a browser, only include the content in the display window. Avoid including the address bar, title bar, or toolbar icons, which do not scale well to smaller screen sizes.
GitHub displays the screenshots you upload in a box on your app's landing page, so you don't need to add boxes or borders around your screenshots.
Captions are most effective when they are short and snappy.\n\n\n\nApps/GitHub Marketplace/List an app on the Marketplace/Set listing pricing plansSetting pricing plans for your listingWhen you list your app on GitHub Marketplace, you can choose to provide your app as a free service or sell your app. If you plan to sell your app, you can create different pricing plans for different feature tiers.In this articleAbout setting pricing plansAbout saving pricing plansCreating pricing plansChanging a GitHub Marketplace listing's pricing planNote

This article applies to publishing apps in GitHub Marketplace only. For more information about publishing GitHub Actions in GitHub Marketplace, see Publishing actions in GitHub Marketplace.

About setting pricing plans
GitHub Marketplace offers several different types of pricing plans. For detailed information, see Pricing plans for GitHub Marketplace apps.
To offer a paid plan for your app, your app must be owned by an organization that has completed the publisher verification process and met certain criteria. For more information, see Applying for publisher verification for your organization and Requirements for listing an app.
If your app is already published with a paid plan and you're a verified publisher, then you can publish a new paid plan from the "Edit a pricing plan" page in your Marketplace app listing settings.
If your app is already published with a paid plan and but you are not a verified publisher, then you can cannot publish a new paid plan until you are a verified publisher. For more information about becoming a verified publisher, see Applying for publisher verification for your organization.
About saving pricing plans
You can save pricing plans in a draft or published state. If you haven't submitted your GitHub Marketplace listing for approval, a published plan will function in the same way as a draft plan until your listing is approved and shown on GitHub Marketplace. Draft plans allow you to create and save new pricing plans without making them available on your GitHub Marketplace listing page. Once you publish a pricing plan on a published listing, it's available for customers to purchase immediately. You can publish up to 10 pricing plans.
For guidelines on billing customers, see Billing customers.
Creating pricing plans
To create a pricing plan for your GitHub Marketplace listing, click Plans and pricing in the left sidebar of your GitHub Marketplace listing page. For more information, see Drafting a listing for your app.
When you click New draft plan, you'll see a form that allows you to customize your pricing plan. You'll need to configure the following fields to create a pricing plan:


Plan name - Your pricing plan's name will appear on your GitHub Marketplace app's landing page. You can customize the name of your pricing plan to align with the plan's resources, the size of the company that will use the plan, or anything you'd like.


Pricing models - There are three types of pricing plan: free, flat-rate, and per-unit. All plans require you to process new purchase and cancellation events from the marketplace API. In addition, for paid plans:

You must set a price for both monthly and yearly subscriptions in US dollars.
Your app must process plan change events.
You must request verification to publish a listing with a paid plan.
You can offer your app for free for 14 days as a free trial. Free trials automatically convert to a paid subscription after 14 days, unless the customer cancels before the free trial expires. Select "Enable 14 day free trial for this plan" to offer a free trial.

For detailed information, see Pricing plans for GitHub Marketplace apps and Using the GitHub Marketplace API in your app.


Available for - GitHub Marketplace pricing plans can apply to Personal accounts and organizations, Personal accounts only, or Organizations only. For example, if your pricing plan is per-unit and provides multiple seats, you would select Organizations only because there is no way to assign seats to people in an organization from a personal account.


Short description - Write a brief summary of the details of the pricing plan. The description might include the type of customer the plan is intended for or the resources the plan includes.


Bullets - You can write up to four bullets that include more details about your pricing plan. The bullets might include the use cases of your app or list more detailed information about the resources or features included in the plan.


Note

If you're listing an app on GitHub Marketplace, you can't list your app with a free pricing plan if you offer a paid service outside of GitHub Marketplace.

Changing a GitHub Marketplace listing's pricing plan
If a pricing plan for your GitHub Marketplace listing is no longer needed, or if you need to adjust pricing details, you can remove it by clicking Delete at the bottom of the edit page of the plan.
Once you publish a pricing plan for an app that is already listed in GitHub Marketplace, you can't make changes to the plan. Instead, you'll need to remove the pricing plan and create a new plan. Customers who already purchased the removed pricing plan will continue to use it until they opt out and move onto a new pricing plan. For more on pricing plans, see Pricing plans for GitHub Marketplace apps.
Once you remove a pricing plan, users won't be able to purchase your app using that plan. Existing users on the removed pricing plan will continue to stay on the plan until they cancel their plan subscription.
Note

GitHub can't remove users from a removed pricing plan. You can run a campaign to encourage users to upgrade or downgrade from the removed pricing plan onto a new pricing plan.

You can disable GitHub Marketplace free trials without retiring the pricing plan, but this prevents you from initiating future free trials for that plan. If you choose to disable free trials for a pricing plan, users already signed up can complete their free trial.
After retiring a pricing plan, you can create a new pricing plan with the same name as the removed pricing plan. For instance, if you have a "Pro" pricing plan but need to change the flat rate price, you can remove the "Pro" pricing plan and create a new "Pro" pricing plan with an updated price. Users will be able to purchase the new pricing plan immediately.
If you are not a verified publisher, then you cannot change a pricing plan for your app. For more information about becoming a verified publisher, see Applying for publisher verification for your organization.\n\n\n\nApps/GitHub Marketplace/List an app on the Marketplace/Webhooks for plan changesConfiguring a webhook to notify you of plan changesAfter creating a draft GitHub Marketplace listing, you can configure a webhook that notifies you when changes to customer account plans occur. After you configure the webhook, you can handle the marketplace_purchase event types in your app.In this articleCreating a webhookViewing webhook deliveriesNote

This article applies to publishing apps in GitHub Marketplace only. For more information about publishing GitHub Actions in GitHub Marketplace, see Publishing actions in GitHub Marketplace.

The GitHub Marketplace event webhook can only be set up from your application's GitHub Marketplace listing page. You can configure all other events from your application's developer settings page. If you haven't created a GitHub Marketplace listing, read Drafting a listing for your app to learn how.
Creating a webhook
To create a webhook for your GitHub Marketplace listing, click Webhook in the left sidebar of your GitHub Marketplace listing page. You'll see the following webhook configuration options needed to configure your webhook:
Payload URL
The payload URL is the URL of the server that will receive the webhook POST requests.
Content type
Webhooks can be delivered using different content types:

The application/json content type will deliver the JSON payload directly as the body of the POST request.
The application/x-www-form-urlencoded content type will send the JSON payload as a form parameter
called payload.

Choose the one that best fits your needs. GitHub recommends using the application/json content type.
Secret
Setting a webhook secret allows you to ensure that POST requests sent to the payload URL are from GitHub. When you set a secret, you'll receive the X-Hub-Signature and X-Hub-Signature-256 headers in the webhook POST request. For more information on how to use a secret with a signature header to secure your webhook payloads, see Validating webhook deliveries.
Active
By default, webhook deliveries are "Active." You can choose to disable the delivery of webhook payloads during development by deselecting "Active." If you've disabled webhook deliveries, you will need to select "Active" before you submit your app for review.
Viewing webhook deliveries
Once you've configured your GitHub Marketplace webhook, you'll be able to inspect POST request payloads from the Webhook page of your application's GitHub Marketplace listing. GitHub doesn't resend failed delivery attempts. Ensure your app can receive all webhook payloads sent by GitHub.\n\n\n\nApps/GitHub Marketplace/List an app on the Marketplace/Submit your listingSubmitting your listing for publicationTo finish your app listing submission, you can request a review by an onboarding expert.Note

This article applies to publishing apps in GitHub Marketplace only. For more information about publishing GitHub Actions in GitHub Marketplace, see Publishing actions in GitHub Marketplace.

Once your app listing meets the GitHub Marketplace requirements, you can submit your app. For an overview of the app listing requirements, see Requirements for listing an app.


In the left sidebar on the app listing page, click Overview. For information on finding your app listing page, see Drafting a listing for your app.



To submit your completed app listing, click Request publish.


An onboarding expert will reach out to you with additional information.
If you want to delete your GitHub App, you must first delete the listing from GitHub Marketplace. For more information, see Deleting your app listing from GitHub Marketplace.\n\n\n\nApps/GitHub Marketplace/List an app on the Marketplace/Delete your listingDeleting your app listing from GitHub MarketplaceFollow these steps to delete your app listing from GitHub Marketplace.Note

This article applies to publishing apps in GitHub Marketplace only. For more information about publishing GitHub Actions in GitHub Marketplace, see Publishing actions in GitHub Marketplace.

You can follow these steps to remove your app from GitHub Marketplace. The listing will be removed from GitHub Marketplace immediately. Existing subscriptions will be canceled at the end of the current billing cycle. Although the app will be removed from GitHub Marketplace, you will not be able to delete your app until the current billing cycle ends.


In the upper-right corner of any page on GitHub, click your profile photo.


Navigate to your account settings.

For an app owned by a personal account, click Settings.
For an app owned by an organization:

Click Your organizations.
To the right of the organization, click Settings.





In the left sidebar, click  Developer settings.


In the left sidebar, click GitHub Apps or OAuth apps.


Click on the app that you want to remove from GitHub Marketplace.


On the app settings landing page, click Edit Marketplace listing.


In the left sidebar on the app listing page, click Overview.



Under "Remove your listing from GitHub Marketplace", click Delist this Listing\n\n\n\nApps/GitHub Marketplace/Sell apps on the Marketplace/Pricing plans for appsPricing plans for GitHub Marketplace appsPricing plans allow you to provide your app with different levels of service or resources. You can offer up to 10 pricing plans in your GitHub Marketplace listing.In this articleTypes of pricing plansFree trialsNote

This article applies to publishing apps in GitHub Marketplace only. For more information about publishing GitHub Actions in GitHub Marketplace, see Publishing actions in GitHub Marketplace.

GitHub Marketplace pricing plans can be free, flat rate, or per-unit. Prices are set, displayed, and processed in US dollars. Paid plans are restricted to apps published by verified publishers. For more information about becoming a verified publisher, see Applying for publisher verification for your organization.
Customers purchase your app using a payment method attached to their account on GitHub. You don't have to write code to perform billing transactions, but you will have to handle events from the GitHub Marketplace API. For more information, see Using the GitHub Marketplace API in your app.
If the app you're listing on GitHub Marketplace has multiple plan options, you can set up corresponding pricing plans. For example, if your app has two plan options, an open source plan and a pro plan, you can set up a free pricing plan for your open source plan and a flat pricing plan for your pro plan. Each GitHub Marketplace listing must have an annual and a monthly price for every plan that's listed.
For more information on how to create a pricing plan, see Setting pricing plans for your listing.
Note

If you're listing an app on GitHub Marketplace, you can't list your app with a free pricing plan if you offer a paid service outside of GitHub Marketplace.

Types of pricing plans
Free pricing plans
Free apps are encouraged in GitHub Marketplace and are a great way to offer open source services. If you list a paid version of your app outside of GitHub Marketplace, you must offer at least one paid plan when listing the app in GitHub Marketplace.
Free plans are completely free for users. If you set up a free pricing plan, you cannot charge users that choose the free pricing plan for the use of your app. You can create both free and paid plans for your listing.
All apps need to handle events for new purchases and cancellations. Apps that only have free plans do not need to handle events for free trials, upgrades, and downgrades. For more information, see: Using the GitHub Marketplace API in your app.
If you add a paid plan to an app that you've already listed in GitHub Marketplace as a free service, you'll need to request verification for the app and go through financial onboarding.
Paid pricing plans
There are two types of paid pricing plan:


Flat rate pricing plans charge a set fee on a monthly and yearly basis.


Per-unit pricing plans charge a set fee on either a monthly or yearly basis for each user in an organization.


You may also want to offer free trials. These provide free, 14-day trials of OAuth or GitHub Apps to customers. When you set up a Marketplace pricing plan, you can select the option to provide a free trial for flat-rate or per-unit pricing plans.
Free trials
Customers can start a free trial for any paid plan on a Marketplace listing that includes free trials. However, customers cannot create more than one free trial per marketplace product.
Free trials have a fixed length of 14 days. Customers are notified 4 days before the end of their trial period (on day 11 of the free trial) that their plan will be upgraded. At the end of a free trial, customers will be auto-enrolled into the plan they are trialing if they do not cancel.
For more information, see: Handling new purchases and free trials.
Note

GitHub expects you to delete any private customer data within 30 days of a canceled trial, beginning at the receipt of the cancellation event.\n\n\n\nApps/GitHub Marketplace/Sell apps on the Marketplace/Billing customersBilling customersApps on GitHub Marketplace should adhere to GitHub's billing guidelines and support recommended services. Following our guidelines helps customers navigate the billing process without any surprises.In this articleUnderstanding the billing cycleProviding billing services in your app's UIBilling services for upgrades, downgrades, and cancellationsNote

This article applies to publishing apps in GitHub Marketplace only. For more information about publishing GitHub Actions in GitHub Marketplace, see Publishing actions in GitHub Marketplace.

Understanding the billing cycle
Customers can choose a monthly or yearly billing cycle when they purchase your app. All changes customers make to the billing cycle and plan selection will trigger a marketplace_purchase event. You can refer to the marketplace_purchase webhook payload to see which billing cycle a customer selects and when the next billing date begins (effective_date). For more information about webhook payloads, see Webhook events for the GitHub Marketplace API.
Providing billing services in your app's UI
Customers should be able to perform the following actions from your app's website:

Customers should be able to modify or cancel their GitHub Marketplace plans for personal and organizational accounts separately.
Customers who cancel a paid plan purchased from GitHub Marketplace should be automatically downgraded to the app's free plan if it exists. When a customer cancels a GitHub Marketplace subscription, GitHub does not automatically uninstall the app, so the customer can expect that free features will continue to function. It's highly recommended to allow customers to re-enable their previous plan.
Customers should be able to upgrade from your app's user interface if you provide an upgrade URL in this format: https://www.github.com/marketplace/<LISTING_NAME>/upgrade/<LISTING_PLAN_NUMBER>/<CUSTOMER_ACCOUNT_ID>
Customers should be able to modify which users have access to your app from your app's website if they purchased seats (per-unit pricing plan) or the plan offers unlimited collaborators.
Customers should be able to see the following changes to their account immediately in the billing, profile, or account settings section of the app's website:

Current plan and price.
New plans purchased.
Upgrades, downgrades, cancellations, and the number of remaining days in a free trial.
Changes to billing cycles (monthly or yearly).
Usage and remaining resources for flat-rate and per-unit plans. For example, if the pricing plan is per-unit, your app's site should show units used and units available.



Billing services for upgrades, downgrades, and cancellations
Follow these guidelines for upgrades, downgrades, and cancellations to maintain a clear and consistent billing process. For more detailed instructions about the GitHub Marketplace purchase events, see Using the GitHub Marketplace API in your app.
You can use the marketplace_purchase webhook's effective_date key to determine when a plan change will occur and periodically synchronize the List accounts for a plan.
Upgrades
When a customer upgrades their pricing plan or changes their billing cycle from monthly to yearly, you should make the change effective for them immediately. You need to apply a pro-rated discount to the new plan and change the billing cycle.
In the case where a customer upgrades their plan and the payment fails, GitHub reverts their GitHub Marketplace subscription to its previous state. GitHub also sends an email to the customer to inform them of the failure and allow them to re-attempt their purchase. You will receive a webhook with the changed action requesting you to revert to the previous plan.
For information about building upgrade and downgrade workflows into your app, see Handling plan changes.
Downgrades and cancellations
Downgrades occur when a customer moves to a free plan from a paid plan, selects a plan with a lower cost than their current plan, or changes their billing cycle from yearly to monthly. When downgrades or cancellations occur, you don't need to provide a refund. Instead, the current plan will remain active until the last day of the current billing cycle. The marketplace_purchase event will be sent when the new plan takes effect at the beginning of the customer's next billing cycle.
When a customer cancels a plan, you must:


Automatically downgrade them to the free plan, if it exists.
When a customer cancels a GitHub Marketplace subscription, GitHub does not automatically uninstall the app, so the customer can expect that free features will continue to function.


Enable them to upgrade the plan through GitHub if they would like to continue the plan at a later time.


For information about building cancellation workflows into your app, see Handling plan cancellations.\n\n\n\nApps/GitHub Marketplace/Sell apps on the Marketplace/Receive paymentReceiving payment for app purchasesAt the end of each month, you'll receive payment for your GitHub Marketplace listing.Note

This article applies to publishing apps in GitHub Marketplace only. For more information about publishing GitHub Actions in GitHub Marketplace, see Publishing actions in GitHub Marketplace.

After your GitHub Marketplace listing for an app with a paid plan is created and approved, you'll provide payment details to GitHub as part of the financial onboarding process.
Once your revenue reaches a minimum of 500 US dollars for the month, you'll receive an electronic payment from GitHub at the end of the following month. This will be the income from marketplace transactions minus the amount charged by GitHub to cover their running costs.
For transactions made before January 1, 2021, GitHub retains 25% of transaction income. For transactions made after that date, only 5% is retained by GitHub. This change will be reflected in payments received from the end of January 2021 onward.
Note

For details of the current pricing and payment terms, see GitHub Marketplace Developer Agreement.\n\n\n\nApps/OAuth apps/Using OAuth apps/Install app personal accountInstalling an OAuth app in your personal accountYou can install OAuth apps from GitHub Marketplace to use in your personal account.In this articleAbout installing OAuth apps in your personal accountInstalling an OAuth app in your personal accountFurther readingAbout installing OAuth apps in your personal account
Note

This article applies to installing and purchasing apps from GitHub Marketplace only. For more information on apps purchased from integrators, see About using integrations.

If you choose a paid plan, you'll pay for your app subscription on your personal account's current billing date using your existing payment method.
If you choose a paid plan with a free trial, you can cancel at any time during your trial period without being charged, but you will automatically lose access to the app. Your paid subscription will start at the end of the 14-day trial. For more information, see About billing for GitHub Marketplace.
For more information about installing a GitHub App, see Installing a GitHub App from GitHub Marketplace for your personal account.
Installing an OAuth app in your personal account
If you belong to any organizations that enforce SAML single sign-on, you may be prompted to authenticate through your identity provider before you can authorize an OAuth app. For more information about SAML, see About authentication with SAML single sign-on" in the GitHub Enterprise Cloud documentation.


To open GitHub Marketplace, in the top-left corner of GitHub, select , then click  Marketplace.



Browse to the app you'd like to install, then click on the app's name.


On the app's page, under "Pricing and setup," click the pricing plan you'd like to use.


Click Install it for free, Buy with GitHub, or Try free for 14 days.


Under "Review your order," in the Account dropdown menu, confirm that you're installing the app for your personal account.


If you chose a paid plan, in the "Payment Method" section, review your payment method.

To change the existing payment method on file for your personal account, click Edit, then complete the form to add a new payment method.
If there isn't a payment method on file for your personal account, complete the form to add a credit card or PayPal account.



Click Complete order and begin installation.


Review the information about the app's access to your personal account and data, then click Authorize application.


Further reading

Managing your payment and billing information
Installing an OAuth app in your organization\n\n\n\nApps/OAuth apps/Using OAuth apps/Install app organizationInstalling an OAuth app in your organizationYou can install OAuth apps from GitHub Marketplace to use in your organization.In this articleAbout installing OAuth apps in your organizationInstalling an OAuth app in your organizationFurther readingAbout installing OAuth apps in your organization
Note

This article applies to installing and purchasing apps from GitHub Marketplace only. For more information on apps purchased from integrators, see About using integrations.

Tip

If an app requires organization-level access, then only an organization owner can purchase, install, or cancel the app, and manage app billing for the organization. If the app doesn't require organization-level access, then a repository administrator can install and uninstall the app.

If you choose a paid plan, you'll pay for your app subscription on your organization's current billing date using your organization's existing payment method.
If you choose a paid plan with a free trial, you can cancel at any time during your trial period without being charged, but you will automatically lose access to the app. Your paid subscription will start at the end of the 14-day trial. For more information, see About billing for GitHub Marketplace.
For more information about installing a GitHub App, see Installing a GitHub App from GitHub Marketplace for your organizations.
Installing an OAuth app in your organization
If you belong to any organizations that enforce SAML single sign-on, you may be prompted to authenticate through your identity provider before you can authorize an OAuth app. For more information about SAML, see About authentication with SAML single sign-on" in the GitHub Enterprise Cloud documentation.


To open GitHub Marketplace, in the top-left corner of GitHub, select , then click  Marketplace.



Browse to the app you'd like to install, then click on the app's name.


On the app's page, under "Pricing and setup," click the pricing plan you'd like to use.


Click Install it for free, Buy with GitHub, or Try free for 14 days.


Choose an installation organization for the app. Depending on your organization's terms of service, this process will be slightly different.

If you have given GitHub permission to collect name and address information for your organization, in the "Billing information" section, select the Switch billing account  dropdown menu, then click the organization in which you'd like to install the app.



Otherwise, under "Review your order," select the Account dropdown menu, then click the organization in which you'd like to install the app.




If you chose a paid plan, review your payment method.

To change the existing payment method on file for the organization, click Edit, then complete the form to add a new payment method.
If there isn't a payment method on file for the organization, click Add a Payment Method, then complete the form to add a credit card or PayPal account.



Click Complete order and begin installation.


Review the information about the app's access to your personal account, organizations, and data, then click Authorize application.


Further reading

Managing your payment and billing information
Installing an OAuth app in your personal account\n\n\n\nApps/OAuth apps/Using OAuth apps/Authorizing OAuth appsAuthorizing OAuth appsYou can connect your GitHub identity to third-party applications using OAuth. When authorizing an OAuth app, you should ensure you trust the application, review who it's developed by, and review the kinds of information the application wants to access.In this articleOAuth app accessRequesting updated permissionsOAuth apps and organizationsFurther readingWhen an OAuth app wants to identify you by your account on GitHub, you'll see a page with the app's developer contact information and a list of the specific data that's being requested.
Tip

You must verify your email address before you can authorize an OAuth app.

OAuth app access
OAuth apps can have read or write access to your GitHub data.

Read access only allows an app to look at your data.
Write access allows an app to change your data.

Tip

We recommend that you regularly review your authorized integrations. Remove any applications and tokens that haven't been used in a while. For more information, see Reviewing your authorized OAuth apps.

About OAuth scopes
Scopes are named groups of permissions that an OAuth app can request to access both public and non-public data.
When you want to use an OAuth app that integrates with GitHub, that app lets you know what type of access to your data will be required. If you grant access to the app, then the app will be able to perform actions on your behalf, such as reading or modifying data. For example, if you want to use an app that requests user:email scope, the app will have read-only access to your private email addresses. For more information, see Scopes for OAuth apps.
Note

Currently, you can't scope source code access to read-only.

A token has the same capabilities to access resources and perform actions on those resources that the owner of the token has, and is further limited by any scopes or permissions granted to the token. A token cannot grant additional access capabilities to a user. For example, an application can create an access token that is configured with an admin:org scope, but if the user of the application is not an organization owner, the application will not be granted administrative access to the organization.
There is a limit of ten tokens that are issued per user/application/scope combination, and a rate limit of ten tokens created per hour. If an application creates more than ten tokens for the same user and the same scopes, the oldest tokens with the same user/application/scope combination are revoked. However, hitting the hourly rate limit will not revoke your oldest token. Instead, it will trigger a re-authorization prompt within the browser, asking the user to double check the permissions they're granting your app. This prompt is intended to give a break to any potential infinite loop the app is stuck in, since there's little to no reason for an app to request ten tokens from the user within an hour.
Types of requested data
OAuth apps can request several types of data.

























































Type of dataDescriptionCommit statusYou can grant access for an app to report your commit status. Commit status access allows apps to determine if a build is a successful against a specific commit. Apps won't have access to your code, but they can read and write status information against a specific commit.DeploymentsDeployment status access allows apps to determine if a deployment is successful against a specific commit for public and private repositories. Apps won't have access to your code.GistsGist access allows apps to read or write to both your public and secret Gists.HooksWebhooks access allows apps to read or write hook configurations on repositories you manage.NotificationsNotification access allows apps to read your GitHub notifications, such as comments on issues and pull requests. However, apps remain unable to access anything in your repositories.Organizations and teamsOrganization and teams access allows apps to access and manage organization and team membership.Personal user dataUser data includes information found in your user profile, like your name, e-mail address, and location.RepositoriesRepository information includes the names of contributors, the branches you've created, and the actual files within your repository. Apps can request access for either public or private repositories on a user-wide level.Repository deleteApps can request to delete repositories that you administer, but they won't have access to your code.ProjectsAccess to user and organization projects. Apps can request either read/write or read only access.
Requesting updated permissions
When OAuth apps request new access permissions, they will notify you of the differences between their current permissions and the new permissions.
OAuth apps and organizations
When you authorize an OAuth app for your personal account, you'll also see how the authorization will affect each organization you're a member of.


For organizations with OAuth app access restrictions, you can request that organization owners approve the application for use in that organization. If the organization does not approve the application, then the application will only be able to access the organization's public resources. If you're an organization owner, you can approve the application yourself.


For organizations without OAuth app access restrictions, the application will automatically be authorized for access to that organization's resources. For this reason, you should be careful about which OAuth apps you approve for access to your personal account resources as well as any organization resources.


If you belong to any organizations with SAML single sign-on (SSO) enabled, and you have created a linked identity for that organization by authenticating via SAML in the past, you must have an active SAML session for each organization each time you authorize an OAuth app.
Note

If you're encountering issues with an authorized OAuth app or GitHub App accessing an organization that is protected by SAML, you may need to revoke the app from your Authorized GitHub Apps or Authorized OAuth apps page, visit the organization to authenticate and establish an active SAML session, and then attempt to reauthorize the app by accessing it.

Further reading

About OAuth app access restrictions
Authorizing GitHub Apps
GitHub Marketplace support\n\n\n\nApps/OAuth apps/Using OAuth apps/Review OAuth appsReviewing your authorized OAuth appsYou should review your authorized applications to verify that no new applications with expansive permissions are authorized, such as those that have access to your private repositories.

In the upper-right corner of any page on GitHub, click your profile photo, then click  Settings.


In the "Integrations" section of the sidebar, click  Applications.


Click the Authorized OAuth Apps tab.



Review the tokens that have access to your account. For those that you don't recognize or that are out-of-date, click , then click Revoke. To revoke all tokens, click Revoke all.



Further reading

About using integrations
Reviewing and revoking authorization of GitHub Apps
Privileged OAuth apps\n\n\n\nApps/OAuth apps/Using OAuth apps/Third-party applicationsConnecting with third-party applicationsYou can connect your GitHub identity to third-party applications using OAuth. When authorizing one of these applications, you should ensure you trust the application, review who it's developed by, and review the kinds of information the application wants to access.In this articleContacting the application developerTypes of application access and dataWhen a third-party application wants to identify you by your GitHub login, you'll see a page with the developer contact information and a list of the specific data that's being requested.
Contacting the application developer
Because an application is developed by a third-party who isn't GitHub, we don't know exactly how an application uses the data it's requesting access to. If you have questions or concerns about an application, you should contact the application developer. To find contact information for an application, you can click the account name of the developer at the top of the app's authorization page.
If the developer has chosen to supply further information, the right-hand side of the authorization page may also provide a detailed description of the application, as well as its associated website.
Types of application access and data
Applications can have read or write access to your GitHub data.

Read access only allows an application to look at your data.
Write access allows an application to change your data.

About OAuth scopes
Scopes are named groups of permissions that an application can request to access both public and non-public data.
When you want to use a third-party application that integrates with GitHub, that application lets you know what type of access to your data will be required. If you grant access to the application, then the application will be able to perform actions on your behalf, such as reading or modifying data. For example, if you want to use an app that requests user:email scope, the app will have read-only access to your private email addresses. For more information, see Scopes for OAuth apps.
Note

Currently, you can't scope source code access to read-only.

Tip

We recommend that you regularly review your authorized integrations. Remove any applications and tokens that haven't been used in a while. For more information, see Reviewing your authorized OAuth apps.

Types of requested data
There are several types of data that applications can request.













































Type of dataDescriptionCommit statusYou can grant access for a third-party application to report your commit status. Commit status access allows applications to determine if a build is a successful against a specific commit. Applications won't have access to your code, but they can read and write status information against a specific commit.DeploymentsDeployment status access allows applications to determine if a deployment is successful against a specific commit for a repository. Applications won't have access to your code.GistsGist access allows applications to read or write to both your public and secret Gists.HooksWebhooks access allows applications to read or write hook configurations on repositories you manage.NotificationsNotification access allows applications to read your GitHub notifications, such as comments on issues and pull requests. However, applications remain unable to access anything in your repositories.Organizations and teamsOrganization and teams access allows apps to access and manage organization and team membership.Personal user dataUser data includes information found in your user profile, like your name, e-mail address, and location.RepositoriesRepository information includes the names of contributors, the branches you've created, and the actual files within your repository. An application can request access to all of your repositories of any visibility level. For more information, see About repositories.Repository deleteApplications can request to delete repositories that you administer, but they won't have access to your code.\n\n\n\nApps/OAuth apps/Using OAuth apps/Privileged appsPrivileged OAuth appsSome OAuth apps are privileged apps, owned by GitHub, that are granted special capabilities.Some OAuth apps are privileged apps. These apps are owned by GitHub and are granted special capabilities. For example, even if an organization owner has restricted access by OAuth apps to the organization's data, users can still authorize these apps and use them to access data from the organization.
Some of these privileged apps are automatically included with GitHub and do not require user authorization. These apps will not appear in your list of authorized OAuth apps.
These privileged apps will appear in the user security log, but will not appear in organization audit logs. For more information, see Reviewing your security log and Reviewing the audit log for your organization.
These OAuth apps are :

Gist
Git Credential Manager
GitHub for Android
GitHub CLI
GitHub Codespaces for JetBrains
GitHub Desktop
GitHub Education
github-importer-production 
GitHub for iOS
GitHub Support
JetBrains IDE Integration
Visual Studio
Visual Studio Code\n\n\n\nApps/OAuth apps/Building OAuth apps/GitHub Apps & OAuth appsDifferences between GitHub Apps and OAuth appsIn general, GitHub Apps are preferred to OAuth apps because they use fine-grained permissions, give more control over which repositories the app can access, and use short-lived tokens.In this articleAbout GitHub Apps and OAuth appsWho can install GitHub Apps and authorize OAuth apps?What can GitHub Apps and OAuth apps access?Token-based identificationRequesting permission levels for resourcesRepository discoveryWebhooksGit accessMachine vs. bot accountsAbout GitHub Apps and OAuth apps
In general, GitHub Apps are preferred over OAuth apps. GitHub Apps use fine-grained permissions, give the user more control over which repositories the app can access, and use short-lived tokens. These properties can harden the security of your app by limiting the damage that could be done if your app's credentials were leaked.
Similar to OAuth apps, GitHub Apps can still use OAuth 2.0 and generate a type of OAuth token (called a user access token) and take actions on behalf of a user. However, GitHub Apps can also act independently of a user. This is beneficial for automations that do not require user input. The app will continue to work even if the person who installed the app on an organization leaves the organization.
GitHub Apps have built-in, centralized webhooks. GitHub Apps can receive webhook events for all repositories and organizations the app can access. Conversely, OAuth apps must configure webhooks individually for each repository and organization.
The rate limit for GitHub Apps using an installation access token scales with the number of repositories and number of organization users. Conversely, OAuth apps have lower rate limits and do not scale.
There is one case where an OAuth app is preferred over a GitHub App. If your app needs to access enterprise-level resources such as the enterprise object itself, you should use an OAuth app because a GitHub App cannot yet be given permissions against an enterprise. GitHub Apps can still access enterprise-owned organization and repository resources.
For more information about GitHub Apps, see About creating GitHub Apps.
For more information about migrating an existing OAuth app to a GitHub App, see Migrating OAuth apps to GitHub Apps.
Who can install GitHub Apps and authorize OAuth apps?
You can install GitHub Apps in your personal account or organizations you own. If you have admin permissions in a repository, you can install GitHub Apps on organization accounts. If a GitHub App is installed in a repository and requires organization permissions, the organization owner must approve the application.
By default, only organization owners can manage the settings of GitHub Apps in an organization. To allow additional users to change the developer settings of GitHub Apps owned by the organization, an owner can grant them GitHub App manager permissions. GitHub App Managers can't manage third-party applications. For more information about adding and removing GitHub App managers in your organization, see Roles in an organization.
By contrast, users authorize OAuth apps, which gives the app the ability to act as the authenticated user. For example, you can authorize an OAuth app that finds all notifications for the authenticated user. You can always revoke permissions from an OAuth app.
Organization owners can choose whether to allow outside collaborators to request access for unapproved OAuth apps and GitHub Apps. For more information, see Limiting OAuth app and GitHub App access requests.
Warning

Revoking all permission from an OAuth app deletes any SSH keys the application generated on behalf of the user, including deploy keys.


























GitHub AppsOAuth appsYou must be an organization owner or have admin permissions in a repository to install a GitHub App on an organization. If a GitHub App is installed in a repository and requires organization permissions, the organization owner must approve the application.You can authorize an OAuth app to have access to resources.You can install a GitHub App on your personal repository.You can authorize an OAuth app to have access to resources.You must be an organization owner, personal repository owner, or have admin permissions in a repository to uninstall a GitHub App and remove its access.You can delete an OAuth access token to remove access.You must be an organization owner or have admin permissions in a repository to request a GitHub App installation.If an organization application policy is active, any organization member can request to install an OAuth app on an organization. An organization owner must approve or deny the request.
What can GitHub Apps and OAuth apps access?
Account owners can use a GitHub App in one account without granting access to another. For example, you can install a third-party build service on your employer's organization, but decide not to grant that build service access to repositories in your personal account. A GitHub App remains installed if the person who set it up leaves the organization.
An authorized OAuth app has access to all of the user's or organization owner's accessible resources.

































GitHub AppsOAuth appsInstalling a GitHub App grants the app access to a user or organization account's chosen repositories.Authorizing an OAuth app grants the app access to the user's accessible resources. For example, repositories they can access.The installation token from a GitHub App loses access to resources if an admin removes repositories from the installation.An OAuth access token loses access to resources when the user loses access, such as when they lose write access to a repository.Installation access tokens are limited to specified repositories with the permissions chosen by the creator of the app.An OAuth access token is limited via scopes.GitHub Apps can request separate access to issues and pull requests without accessing the actual contents of the repository.OAuth apps need to request the repo scope to get access to issues, pull requests, or anything owned by the repository.GitHub Apps aren't subject to organization application policies. A GitHub App only has access to the repositories an organization owner has granted.If an organization application policy is active, only an organization owner can authorize the installation of an OAuth app. If installed, the OAuth app gains access to anything visible to the token the organization owner has within the approved organization.A GitHub App receives a webhook event when an installation is changed or removed. This tells the app creator when they've received more or less access to an organization's resources.OAuth apps can lose access to an organization or repository at any time based on the granting user's changing access. The OAuth app will not inform you when it loses access to a resource.
Token-based identification
Note

GitHub Apps can also use a user-based token. For more information, see Authenticating with a GitHub App on behalf of a user.


































GitHub AppsOAuth appsA GitHub App can request an installation access token by using a private key with a JSON web token format out-of-band.An OAuth app can exchange a request token for an access token after a redirect via a web request.An installation token identifies the app as the GitHub Apps bot, such as @jenkins-bot.An access token identifies the app as the user who granted the token to the app, such as @octocat.Installation access tokens expire after a predefined amount of time (currently 1 hour).OAuth tokens remain active until they're revoked by the customer.GitHub Apps installed on organizations or repositories are subject to rate limits that scale with the number of installations. For more information, see Rate limits for GitHub Apps.OAuth tokens use the user's rate limit of 5,000 requests per hour.Rate limit increases can be granted both at the GitHub Apps level (affecting all installations) and at the individual installation level.Rate limit increases are granted per OAuth app. Every token granted to that OAuth app gets the increased limit.GitHub Apps can authenticate on behalf of the user. The flow to authorize is the same as the OAuth app authorization flow. User access tokens can expire and be renewed with a refresh token. For more information, see Refreshing user access tokens and Authenticating with a GitHub App on behalf of a user.The OAuth flow used by OAuth apps authorizes an OAuth app on behalf of the user. This is the same flow used to generate a GitHub App user access token.
Requesting permission levels for resources
Unlike OAuth apps, GitHub Apps have targeted permissions that allow them to request access only to what they need. For example, a Continuous Integration (CI) GitHub App can request read access to repository content and write access to the status API. Another GitHub App can have no read or write access to code but still have the ability to manage issues, labels, and milestones. OAuth apps can't use granular permissions.














































AccessGitHub Apps (read or write permissions)OAuth appsFor access to public repositoriesPublic repository needs to be chosen during installation.public_repo scope.For access to repository code/contentsRepository contentsrepo scope.For access to issues, labels, and milestonesIssuesrepo scope.For access to pull requests, labels, and milestonesPull requestsrepo scope.For access to commit statuses (for CI builds)Commit statusesrepo:status scope.For access to deployments and deployment statusesDeploymentsrepo_deployment scope.To receive events via a webhookA GitHub App includes a webhook by default.write:repo_hook or write:org_hook scope.

Repository discovery

















GitHub AppsOAuth appsGitHub Apps can look at /installation/repositories to see repositories the installation can access.OAuth apps can look at /user/repos for a user view or /orgs/:org/repos for an organization view of accessible repositories.GitHub Apps receive webhooks when repositories are added or removed from the installation.OAuth apps create organization webhooks for notifications when a new repository is created within an organization.
Webhooks





















GitHub AppsOAuth appsBy default, GitHub Apps have a single webhook that receives the events they are configured to receive for every repository they have access to.OAuth apps request the webhook scope to create a repository webhook for each repository they need to receive events from.GitHub Apps receive certain organization-level events with the organization member's permission.OAuth apps request the organization webhook scope to create an organization webhook for each organization they need to receive organization-level events from.Webhooks are automatically disabled when the GitHub App is uninstalled.Webhooks are not automatically disabled if an OAuth app's access token is deleted, and there is no way to clean them up automatically. You will have to ask users to do this manually.
Git access

















GitHub AppsOAuth appsGitHub Apps ask for repository contents permission and use your installation access token to authenticate via HTTP-based Git. For more information, see Generating an installation access token for a GitHub AppOAuth apps ask for write:public_key scope and Create a deploy key via the API. You can then use that key to perform Git commands.The token is used as the HTTP password.The token is used as the HTTP username.
Machine vs. bot accounts
Machine user accounts are OAuth-based personal accounts that segregate automated systems using GitHub's user system.
Bot accounts are specific to GitHub Apps and are built into every GitHub App.

















GitHub AppsOAuth appsGitHub App bots do not consume a GitHub Enterprise seat.A machine user account consumes a GitHub Enterprise seat.Because a GitHub App bot is never granted a password, a customer can't sign into it directly.A machine user account is granted a username and password to be managed and secured by the customer.\n\n\n\nApps/OAuth apps/Building OAuth apps/Rate limitsRate limits for OAuth appsRate limits restrict the rate of traffic to GitHub.com, to help ensure consistent access for all users.In this articleAbout rate limits for OAuth appsRate limits for signing in usersRate limits for the APIFurther readingNote

Consider building a GitHub App instead of an OAuth app. The rate limit for GitHub Apps using an installation access token scales with the number of repositories and number of organization users. Conversely, OAuth apps have lower rate limits and do not scale. For more information, see Differences between GitHub Apps and OAuth apps and About creating GitHub Apps.

About rate limits for OAuth apps
OAuth apps act on behalf of a user, by making requests with a user access token after the user authorizes the app. For more information, see Authorizing OAuth apps.
The generation of these user access tokens is subject to a rate limit. Additionally, API requests made with these user access tokens are subject to rate limits.
Rate limits for signing in users
OAuth apps should always cache their tokens, and only rarely need to sign in a user. Repeatedly signing in a user can indicate a bug, most frequently seen as an infinite loop between the app and GitHub. If an app signs the user in ten times within one hour, the next sign in within the same hour will require re-authorization of the application. This ensures the user is aware that the app is minting so many tokens, and provides a break in what may be an infinite loop otherwise. This ten sign in rate limit is distinct from the ten token limit also enforced for OAuth apps. For information about the ten token limit, see Authorizing OAuth apps.
Rate limits for the API
GitHub sets a limit on the number of requests a OAuth app can make to the REST API within a specific time period. It also sets a limit on the point value of queries that a OAuth app can make to the GraphQL API within a specific time period. In addition to these primary rate limits, GitHub may also apply secondary rate limits. These limits help to prevent abuse and denial-of-service attacks, and ensure that the system remains available for all users.
For more information, see Rate limits for the REST API and Rate limits and node limits for the GraphQL API.
Further reading

Rate limits for the REST API
Rate limits and node limits for the GraphQL API
Rate limits for GitHub Apps\n\n\n\nApps/OAuth apps/Building OAuth apps/Creating an OAuth appCreating an OAuth appYou can create and register an OAuth app under your personal account or under any organization you have administrative access to. While creating your OAuth app, remember to protect your privacy by only using information you consider public.Note

Consider building a GitHub App instead of an OAuth app.
Both OAuth apps and GitHub Apps use OAuth 2.0.
OAuth apps can only act on behalf of a user while GitHub Apps can either act on behalf of a user or independently of a user.
GitHub Apps use fine-grained permissions, give the user more control over which repositories the app can access, and use short-lived tokens.
For more information, see Differences between GitHub Apps and OAuth apps and About creating GitHub Apps.

Note

A user or organization can own up to 100 OAuth apps.



In the upper-right corner of any page on GitHub, click your profile photo, then click  Settings.


In the left sidebar, click  Developer settings.


In the left sidebar, click OAuth apps.


Click New OAuth App.
Note

If you haven't created an app before, this button will say, Register a new application.



In "Application name", type the name of your app.
Warning

Only use information in your OAuth app that you consider public. Avoid using sensitive data, such as internal URLs, when creating an OAuth app.



In "Homepage URL", type the full URL to your app's website.


Optionally, in "Application description", type a description of your app that users will see.


In "Authorization callback URL", type the callback URL of your app.
Note

OAuth apps cannot have multiple callback URLs, unlike GitHub Apps.



If your OAuth app will use the device flow to identify and authorize users, click Enable Device Flow. For more information about the device flow, see Authorizing OAuth apps.


Click Register application.


Further reading

Modifying an OAuth app\n\n\n\nApps/OAuth apps/Building OAuth apps/Authenticate with an OAuth appAuthenticating to the REST API with an OAuth appLearn about the different ways to authenticate with some examples.In this articleRegistering your appAccepting user authorizationImplementing "persistent" authenticationIn this section, we're going to focus on the basics of authentication. Specifically,
we're going to create a Ruby server (using Sinatra) that implements
the web flow of an application in several different ways.
Tip

You can download the complete source code for this project from the platform-samples repo.

Registering your app
First, you'll need to register your application. Every
registered OAuth app is assigned a unique Client ID and Client Secret.
The client secret is used to get an access token for the signed-in user. You must
include the client secret in your native application, however web applications should not leak this value.
You can fill out every other piece of information however you like, except the
Authorization callback URL. This is the most important piece to securely setting
up your application. It's the callback URL that GitHub
returns the user to after successful authentication. Ownership of that URL is what ensures
that users sign into your app, instead of leaking tokens to an attacker.
Since we're running a regular Sinatra server, the location of the local instance
is set to http://127.0.0.1:4567. Let's fill in the callback URL as http://127.0.0.1:4567/callback.
Accepting user authorization
Warning

Retired Notice: Authenticating to the GitHub API is no longer accessible using query parameters. Authenticating to the API should be done with HTTP basic authentication. For more information, including scheduled brownouts, see the blog post.

Now, let's start filling out our simple server. Create a file called server.rb and paste this into it:
require 'sinatra'
require 'rest-client'
require 'json'

CLIENT_ID = ENV['GH_BASIC_CLIENT_ID']
CLIENT_SECRET = ENV['GH_BASIC_SECRET_ID']

get '/' do
  erb :index, :locals => {:client_id => CLIENT_ID}
end

Your client ID and client secret come from your application's configuration
page. We recommend storing these values as
environment variables for ease of replacement and use --
which is exactly what we've done here.
Next, in views/index.erb, paste this content:
<html>
  <head>
  </head>
  <body>
    <p>
      Well, hello there!
    </p>
    <p>
      We're going to now talk to the GitHub API. Ready?
      <a href="https://github.com/login/oauth/authorize?scope=user:email&client_id=<%= client_id %>">Click here</a> to begin!
    </p>
    <p>
      If that link doesn't work, remember to provide your own <a href="/apps/building-oauth-apps/authorizing-oauth-apps/">Client ID</a>!
    </p>
  </body>
</html>

(If you're unfamiliar with how Sinatra works, we recommend reading the Sinatra guide.)
Also, notice that the URL uses the scope query parameter to define the
scopes requested by the application. For our application, we're
requesting user:email scope for reading private email addresses.
Navigate your browser to http://127.0.0.1:4567. After clicking on the link, you should be taken to GitHub, and presented with an "Authorize application" dialog.
If you trust yourself, click Authorize App. Wuh-oh! Sinatra spits out a
404 error. What gives?!
Well, remember when we specified a Callback URL to be callback? We didn't provide
a route for it, so GitHub doesn't know where to drop the user after they authorize
the app. Let's fix that now!
Providing a callback
In server.rb, add a route to specify what the callback should do:
get '/callback' do
  # get temporary GitHub code...
  session_code = request.env['rack.request.query_hash']['code']

  # ... and POST it back to GitHub
  result = RestClient.post('https://github.com/login/oauth/access_token',
                          {:client_id => CLIENT_ID,
                           :client_secret => CLIENT_SECRET,
                           :code => session_code},
                           :accept => :json)

  # extract the token and granted scopes
  access_token = JSON.parse(result)['access_token']
end

After a successful app authentication, GitHub provides a temporary code value.
You'll need to POST this code back to GitHub with your client secret
in exchange for an access_token.
To simplify our GET and POST HTTP requests, we're using the rest-client.
Note that you'll probably never access the API through REST. For a more serious
application, you should probably use a library written in the language of your choice.
Checking granted scopes
Users can edit the scopes you requested by directly changing the URL. This can grant your application less access than you originally asked for. Before making any requests with the token, check the scopes that were granted for the token by the user. For more information about requested and granted scopes, see Scopes for OAuth apps.
The scopes that were granted are returned as a part of the response from
exchanging a token.
get '/callback' do
  # ...
  # Get the access_token using the code sample above
  # ...

  # check if we were granted user:email scope
  scopes = JSON.parse(result)['scope'].split(',')
  has_user_email_scope = scopes.include? 'user:email' || scopes.include? 'user'
end

In our application, we're using scopes.include? to check if we were granted
the user:email scope needed for fetching the authenticated user's private
email addresses. Had the application asked for other scopes, we would have
checked for those as well.
Also, since there's a hierarchical relationship between scopes, you should
check if you were granted any higher levels of the required scope. For example,
if the application had asked for user scope, it won't have been granted explicitly the
user:email scope. In that case, it would receive a token with the user scope, which
would work for requesting the user's email address, even though it doesn't explicitly include
user:email on the token. Checking for both user and user:email ensures that you
check for both scenarios.
Checking for scopes only before making requests is not enough since it's possible
that users will change the scopes in between your check and the actual request.
In case that happens, API calls you expected to succeed might fail with a 404
or 401 status, or return a different subset of information.
To help you gracefully handle these situations, all API responses for requests
made with valid OAuth app tokens also contain an X-OAuth-Scopes header.
This header contains the list of scopes of the token that was used to make the
request. In addition to that, the REST API provides an endpoint to
check a token for validity.
Use this information to detect changes in token scopes, and inform your users of
changes in available application functionality.
Making authenticated requests
At last, with this access token, you'll be able to make authenticated requests as
the logged in user:
# fetch user information
auth_result = JSON.parse(RestClient.get('https://api.github.com/user',
                                        {:params => {:access_token => access_token}}))

# if the user authorized it, fetch private emails
if has_user_email_scope
  auth_result['private_emails'] =
    JSON.parse(RestClient.get('https://api.github.com/user/emails',
                              {:params => {:access_token => access_token}}))
end

erb :basic, :locals => auth_result

We can do whatever we want with our results. In this case, we'll just dump them straight into basic.erb:
<p>Hello, <%= login %>!</p>
<p>
  <% if !email.nil? && !email.empty? %> It looks like your public email address is <%= email %>.
  <% else %> It looks like you don't have a public email. That's cool.
  <% end %>
</p>
<p>
  <% if defined? private_emails %>
  With your permission, we were also able to dig up your private email addresses:
  <%= private_emails.map{ |private_email_address| private_email_address["email"] }.join(', ') %>
  <% else %>
  Also, you're a bit secretive about your private email addresses.
  <% end %>
</p>

Implementing "persistent" authentication
It'd be a pretty bad model if we required users to log into the app every single
time they needed to access the web page. For example, try navigating directly to
http://127.0.0.1:4567/basic. You'll get an error.
What if we could circumvent the entire
"click here" process, and just remember that, as long as the user's logged into
GitHub, they should be able to access this application? Hold on to your hat,
because that's exactly what we're going to do.
Our little server above is rather simple. In order to wedge in some intelligent
authentication, we're going to switch over to using sessions for storing tokens.
This will make authentication transparent to the user.
Also, since we're persisting scopes within the session, we'll need to
handle cases when the user updates the scopes after we checked them, or revokes
the token. To do that, we'll use a rescue block and check that the first API
call succeeded, which verifies that the token is still valid. After that, we'll
check the X-OAuth-Scopes response header to verify that the user hasn't revoked
the user:email scope.
Create a file called advanced_server.rb, and paste these lines into it:
require 'sinatra'
require 'rest_client'
require 'json'

# Don't use hard-coded values in your app
# Instead, set and test environment variables, like below
# if ENV['GITHUB_CLIENT_ID'] && ENV['GITHUB_CLIENT_SECRET']
#  CLIENT_ID        = ENV['GITHUB_CLIENT_ID']
#  CLIENT_SECRET    = ENV['GITHUB_CLIENT_SECRET']
# end

CLIENT_ID = ENV['GH_BASIC_CLIENT_ID']
CLIENT_SECRET = ENV['GH_BASIC_SECRET_ID']

use Rack::Session::Pool, :cookie_only => false

def authenticated?
  session[:access_token]
end

def authenticate!
  erb :index, :locals => {:client_id => CLIENT_ID}
end

get '/' do
  if !authenticated?
    authenticate!
  else
    access_token = session[:access_token]
    scopes = []

    begin
      auth_result = RestClient.get('https://api.github.com/user',
                                   {:params => {:access_token => access_token},
                                    :accept => :json})
    rescue => e
      # request didn't succeed because the token was revoked so we
      # invalidate the token stored in the session and render the
      # index page so that the user can start the OAuth flow again

      session[:access_token] = nil
      return authenticate!
    end

    # the request succeeded, so we check the list of current scopes
    if auth_result.headers.include? :x_oauth_scopes
      scopes = auth_result.headers[:x_oauth_scopes].split(', ')
    end

    auth_result = JSON.parse(auth_result)

    if scopes.include? 'user:email'
      auth_result['private_emails'] =
        JSON.parse(RestClient.get('https://api.github.com/user/emails',
                       {:params => {:access_token => access_token},
                        :accept => :json}))
    end

    erb :advanced, :locals => auth_result
  end
end

get '/callback' do
  session_code = request.env['rack.request.query_hash']['code']

  result = RestClient.post('https://github.com/login/oauth/access_token',
                          {:client_id => CLIENT_ID,
                           :client_secret => CLIENT_SECRET,
                           :code => session_code},
                           :accept => :json)

  session[:access_token] = JSON.parse(result)['access_token']

  redirect '/'
end

Much of the code should look familiar. For example, we're still using RestClient.get
to call out to the GitHub API, and we're still passing our results to be rendered
in an ERB template (this time, it's called advanced.erb).
Also, we now have the authenticated? method which checks if the user is already
authenticated. If not, the authenticate! method is called, which performs the
OAuth flow and updates the session with the granted token and scopes.
Next, create a file in views called advanced.erb, and paste this markup into it:
<html>
  <head>
  </head>
  <body>
    <p>Well, well, well, <%= login %>!</p>
    <p>
      <% if !email.empty? %> It looks like your public email address is <%= email %>.
      <% else %> It looks like you don't have a public email. That's cool.
      <% end %>
    </p>
    <p>
      <% if defined? private_emails %>
      With your permission, we were also able to dig up your private email addresses:
      <%= private_emails.map{ |private_email_address| private_email_address["email"] }.join(', ') %>
      <% else %>
      Also, you're a bit secretive about your private email addresses.
      <% end %>
    </p>
  </body>
</html>

From the command line, call ruby advanced_server.rb, which starts up your
server on port 4567 -- the same port we used when we had a simple Sinatra app.
When you navigate to http://127.0.0.1:4567, the app calls authenticate!
which redirects you to /callback. /callback then sends us back to /,
and since we've been authenticated, renders advanced.erb.
We could completely simplify this roundtrip routing by simply changing our callback
URL in GitHub to /. But, since both server.rb and advanced.rb are relying on
the same callback URL, we've got to do a little bit of wonkiness to make it work.
Also, if we had never authorized this application to access our GitHub data,
we would've seen the same confirmation dialog from earlier pop-up and warn us.\n\n\n\nApps/OAuth apps/Building OAuth apps/Authorizing OAuth appsAuthorizing OAuth appsYou can enable other users to authorize your OAuth app.In this articleWeb application flowDevice flowNon-Web application flowRedirect URLsCreating multiple tokens for OAuth appsDirecting users to review their accessTroubleshootingFurther readingNote

Consider building a GitHub App instead of an OAuth app.
Both OAuth apps and GitHub Apps use OAuth 2.0.
GitHub Apps can act on behalf of a user, similar to an OAuth app, or as themselves, which is beneficial for automations that do not require user input. Additionally, GitHub Apps use fine-grained permissions, give the user more control over which repositories the app can access, and use short-lived tokens. For more information, see Differences between GitHub Apps and OAuth apps and About creating GitHub Apps.

GitHub's OAuth implementation supports the standard authorization code grant type and the OAuth 2.0 Device Authorization Grant for apps that don't have access to a web browser.
If you want to skip authorizing your app in the standard way, such as when testing your app, you can use the non-web application flow.
To authorize your OAuth app, consider which authorization flow best fits your app.

web application flow: Used to authorize users for standard OAuth apps that run in the browser. (The implicit grant type is not supported.)
device flow: Used for headless apps, such as CLI tools.

Web application flow
Note

If you are building a GitHub App, you can still use the OAuth web application flow, but the setup has some important differences. See Authenticating with a GitHub App on behalf of a user for more information.

The web application flow to authorize users for your app is:

Users are redirected to request their GitHub identity
Users are redirected back to your site by GitHub
Your app accesses the API with the user's access token

1. Request a user's GitHub identity
GET https://github.com/login/oauth/authorize

This endpoint takes the following input parameters.

































































Query parameterTypeRequired?Descriptionclient_idstringRequiredThe client ID you received from GitHub when you registered.redirect_uristringStrongly recommendedThe URL in your application where users will be sent after authorization. See details below about redirect urls.loginstringOptionalSuggests a specific account to use for signing in and authorizing the app.scopestringContext dependentA space-delimited list of scopes. If not provided, scope defaults to an empty list for users that have not authorized any scopes for the application. For users who have authorized scopes for the application, the user won't be shown the OAuth authorization page with the list of scopes. Instead, this step of the flow will automatically complete with the set of scopes the user has authorized for the application. For example, if a user has already performed the web flow twice and has authorized one token with user scope and another token with repo scope, a third web flow that does not provide a scope will receive a token with user and repo scope.statestringStrongly recommendedAn unguessable random string. It is used to protect against cross-site request forgery attacks.allow_signupstringOptionalWhether or not unauthenticated users will be offered an option to sign up for GitHub during the OAuth flow. The default is true. Use false when a policy prohibits signups.promptstringOptionalForces the account picker to appear if set to select_account. The account picker will also appear if the application has a non-HTTP redirect URI or if the user has multiple accounts signed in.
The PKCE (Proof Key for Code Exchange) parameters code_challenge and code_challenge_method are not supported at this time. CORS pre-flight requests (OPTIONS) are not supported at this time.
2. Users are redirected back to your site by GitHub
If the user accepts your request, GitHub redirects back to your site with a temporary code in a code parameter as well as the state you provided in the previous step in a state parameter. The temporary code will expire after 10 minutes. If the states don't match, then a third party created the request, and you should abort the process.
Exchange this code for an access token:
POST https://github.com/login/oauth/access_token

This endpoint takes the following input parameters.



































Parameter nameTypeRequired?Descriptionclient_idstringRequiredThe client ID you received from GitHub for your OAuth app.client_secretstringRequiredThe client secret you received from GitHub for your OAuth app.codestringRequiredThe code you received as a response to Step 1.redirect_uristringStrongly recommendedThe URL in your application where users are sent after authorization. We can use this to match against the URI originally provided when the code was issued, to prevent attacks against your service.
By default, the response takes the following form:
access_token=gho_16C7e42F292c6912E7710c838347Ae178B4a&scope=repo%2Cgist&token_type=bearer

You can also receive the response in different formats if you provide the format in the Accept header. For example, Accept: application/json or Accept: application/xml:
Accept: application/json
{
  "access_token":"gho_16C7e42F292c6912E7710c838347Ae178B4a",
  "scope":"repo,gist",
  "token_type":"bearer"
}

Accept: application/xml
<OAuth>
  <token_type>bearer</token_type>
  <scope>repo,gist</scope>
  <access_token>gho_16C7e42F292c6912E7710c838347Ae178B4a</access_token>
</OAuth>

3. Use the access token to access the API
The access token allows you to make requests to the API on a behalf of a user.
Authorization: Bearer OAUTH-TOKEN
GET https://api.github.com/user

For example, in curl you can set the Authorization header like this:
curl -H "Authorization: Bearer OAUTH-TOKEN" https://api.github.com/user

Every time you receive an access token, you should use the token to revalidate the user's identity. A user can change which account they are signed into when you send them to authorize your app, and you risk mixing user data if you do not validate the user's identity after every sign in.
Device flow
The device flow allows you to authorize users for a headless application, such as a CLI tool or the Git Credential Manager.
Before you can use the device flow to authorize and identify users, you must first enable it in your app's settings. For more information about enabling the device flow in your app, see Modifying a GitHub App registration for GitHub Apps and Modifying an OAuth app for OAuth apps.
Overview of the device flow

Your app requests device and user verification codes and gets the authorization URL where the user will enter the user verification code.
The app prompts the user to enter a user verification code at  https://github.com/login/device.
The app polls for the user authentication status. Once the user has authorized the device, the app will be able to make API calls with a new access token.

Step 1: App requests the device and user verification codes from GitHub
POST https://github.com/login/device/code

Your app must request a user verification code and verification URL that the app will use to prompt the user to authenticate in the next step. This request also returns a device verification code that the app must use to receive an access token and check the status of user authentication.
The endpoint takes the following input parameters.




















Parameter nameTypeDescriptionclient_idstringRequired. The client ID you received from GitHub for your app.scopestringA space-delimited list of the scopes that your app is requesting access to. For more information, see Scopes for OAuth apps.
By default, the response takes the following form:
device_code=3584d83530557fdd1f46af8289938c8ef79f9dc5&expires_in=900&interval=5&user_code=WDJB-MJHT&verification_uri=https%3A%2F%2Fgithub.com%2Flogin%2Fdevice




































Parameter nameTypeDescriptiondevice_codestringThe device verification code is 40 characters and used to verify the device.user_codestringThe user verification code is displayed on the device so the user can enter the code in a browser. This code is 8 characters with a hyphen in the middle.verification_uristringThe verification URL where users need to enter the user_code:  https://github.com/login/device.expires_inintegerThe number of seconds before the device_code and user_code expire. The default is 900 seconds or 15 minutes.intervalintegerThe minimum number of seconds that must pass before you can make a new access token request (POST https://github.com/login/oauth/access_token) to complete the device authorization. For example, if the interval is 5, then you cannot make a new request until 5 seconds pass. If you make more than one request over 5 seconds, then you will hit the rate limit and receive a slow_down error.
You can also receive the response in different formats if you provide the format in the Accept header. For example, Accept: application/json or Accept: application/xml:
Accept: application/json
{
  "device_code": "3584d83530557fdd1f46af8289938c8ef79f9dc5",
  "user_code": "WDJB-MJHT",
  "verification_uri": "https://github.com/login/device",
  "expires_in": 900,
  "interval": 5
}

Accept: application/xml
<OAuth>
  <device_code>3584d83530557fdd1f46af8289938c8ef79f9dc5</device_code>
  <user_code>WDJB-MJHT</user_code>
  <verification_uri>https://github.com/login/device</verification_uri>
  <expires_in>900</expires_in>
  <interval>5</interval>
</OAuth>

Step 2: Prompt the user to enter the user code in a browser
Your device will show the user verification code and prompt the user to enter the code at  https://github.com/login/device.
Step 3: App polls GitHub to check if the user authorized the device
POST https://github.com/login/oauth/access_token

Your app will make device authorization requests that poll POST https://github.com/login/oauth/access_token, until the device and user codes expire or the user has successfully authorized the app with a valid user code. The app must use the minimum polling interval retrieved in step 1 to avoid rate limit errors. For more information, see Rate limits for the device flow.
The user must enter a valid code within 15 minutes (or 900 seconds). After 15 minutes, you will need to request a new device authorization code with POST https://github.com/login/device/code.
Once the user has authorized, the app will receive an access token that can be used to make requests to the API on behalf of a user.
The endpoint takes the following input parameters.

























Parameter nameTypeDescriptionclient_idstringRequired. The client ID you received from GitHub for your OAuth app.device_codestringRequired. The device_code you received from the POST https://github.com/login/device/code request.grant_typestringRequired. The grant type must be urn:ietf:params:oauth:grant-type:device_code.
By default, the response takes the following form:
access_token=gho_16C7e42F292c6912E7710c838347Ae178B4a&token_type=bearer&scope=repo%2Cgist

You can also receive the response in different formats if you provide the format in the Accept header. For example, Accept: application/json or Accept: application/xml:
Accept: application/json
{
 "access_token": "gho_16C7e42F292c6912E7710c838347Ae178B4a",
  "token_type": "bearer",
  "scope": "repo,gist"
}

Accept: application/xml
<OAuth>
  <access_token>gho_16C7e42F292c6912E7710c838347Ae178B4a</access_token>
  <token_type>bearer</token_type>
  <scope>gist,repo</scope>
</OAuth>

Rate limits for the device flow
When a user submits the verification code on the browser, there is a rate limit of 50 submissions in an hour per application.
If you make more than one access token request (POST https://github.com/login/oauth/access_token) within the required minimum timeframe between requests (or interval), you'll hit the rate limit and receive a slow_down error response. The slow_down error response adds 5 seconds to the last interval. For more information, see the Error codes for the device flow.
Error codes for the device flow









































Error codeDescriptionauthorization_pendingThis error occurs when the authorization request is pending and the user hasn't entered the user code yet. The app is expected to keep polling the POST https://github.com/login/oauth/access_token request without exceeding the interval, which requires a minimum number of seconds between each request.slow_downWhen you receive the slow_down error, 5 extra seconds are added to the minimum interval or timeframe required between your requests using POST https://github.com/login/oauth/access_token. For example, if the starting interval required at least 5 seconds between requests and you get a slow_down error response, you must now wait a minimum of 10 seconds before making a new request for an OAuth access token. The error response includes the new interval that you must use.expired_tokenIf the device code expired, then you will see the token_expired error. You must make a new request for a device code.unsupported_grant_typeThe grant type must be urn:ietf:params:oauth:grant-type:device_code and included as an input parameter when you poll the OAuth token request POST https://github.com/login/oauth/access_token.incorrect_client_credentialsFor the device flow, you must pass your app's client ID, which you can find on your app settings page. The client_secret is not needed for the device flow.incorrect_device_codeThe device_code provided is not valid.access_deniedWhen a user clicks cancel during the authorization process, you'll receive a access_denied error and the user won't be able to use the verification code again.device_flow_disabledDevice flow has not been enabled in the app's settings. For more information, see Device flow.
For more information, see the OAuth 2.0 Device Authorization Grant.
Non-Web application flow
Non-web authentication is available for limited situations like testing. If you need to, you can use Basic Authentication to create a personal access token using your personal access tokens settings page. This technique enables the user to revoke access at any time.
Redirect URLs
The redirect_uri parameter is optional. If left out, GitHub will
redirect users to the callback URL configured in the OAuth app
settings. If provided, the redirect URL's host (excluding sub-domains) and port must exactly
match the callback URL. The redirect URL's path must reference a
subdirectory of the callback URL.
CALLBACK: http://example.com/path

GOOD: http://example.com/path
GOOD: http://example.com/path/subdir/other
GOOD: http://oauth.example.com/path
GOOD: http://oauth.example.com/path/subdir/other
BAD:  http://example.com/bar
BAD:  http://example.com/
BAD:  http://example.com:8080/path
BAD:  http://oauth.example.com:8080/path
BAD:  http://example.org

Loopback redirect urls
The optional redirect_uri parameter can also be used for loopback URLs, which is useful for native applications running on a desktop computer. If the application specifies a loopback URL and a port, then after authorizing the application users will be redirected to the provided URL and port. The redirect_uri does not need to match the port specified in the callback URL for the app.
For the http://127.0.0.1/path callback URL, you can use this redirect_uri if your application is listening on port 1234:
http://127.0.0.1:1234/path

Note that OAuth RFC recommends not to use localhost, but instead to use loopback literal 127.0.0.1 or IPv6 ::1.
Creating multiple tokens for OAuth apps
You can create multiple tokens for a user/application/scope combination to create tokens for specific use cases.
This is useful if your OAuth app supports one workflow that uses GitHub for sign-in and only requires basic user information. Another workflow may require access to a user's private repositories. Using multiple tokens, your OAuth app can perform the web flow for each use case, requesting only the scopes needed. If a user only uses your application to sign in, they are never required to grant your OAuth app access to their private repositories.
There is a limit of ten tokens that are issued per user/application/scope combination, and a rate limit of ten tokens created per hour. If an application creates more than ten tokens for the same user and the same scopes, the oldest tokens with the same user/application/scope combination are revoked. However, hitting the hourly rate limit will not revoke your oldest token. Instead, it will trigger a re-authorization prompt within the browser, asking the user to double check the permissions they're granting your app. This prompt is intended to give a break to any potential infinite loop the app is stuck in, since there's little to no reason for an app to request ten tokens from the user within an hour.
Warning

Revoking all permission from an OAuth app deletes any SSH keys the application generated on behalf of the user, including deploy keys.

Directing users to review their access
You can link to authorization information for an OAuth app so that users can review and revoke their application authorizations.
To build this link, you'll need your OAuth app's client_id that you received from GitHub when you registered the application.
https://github.com/settings/connections/applications/:client_id

Tip

To learn more about the resources that your OAuth app can access for a user, see Discovering resources for a user.

Troubleshooting

Troubleshooting authorization request errors
Troubleshooting OAuth app access token request errors
Device flow errors
Token expiration and revocation

Further reading

About authentication to GitHub\n\n\n\nApps/OAuth apps/Building OAuth apps/Scopes for OAuth appsScopes for OAuth appsScopes let you specify exactly what type of access you need. Scopes limit access for OAuth tokens. They do not grant any additional permission beyond that which the user already has.In this articleAvailable scopesRequested scopes and granted scopesNormalized scopesNote

Consider building a GitHub App instead of an OAuth app. GitHub Apps use fine-grained permissions instead of scopes, which give you more control over what your app can do. For more information, see Differences between GitHub Apps and OAuth apps and About creating GitHub Apps.

When setting up an OAuth app on GitHub, requested scopes are displayed to the user on the authorization form.
Note

If you're building a GitHub App, you don’t need to provide scopes in your authorization request. For more on this, see Authenticating with a GitHub App on behalf of a user.

If your OAuth app doesn't have access to a browser, such as a CLI tool, then you don't need to specify a scope for users to authenticate to your app. For more information, see Authorizing OAuth apps.
Check headers to see what OAuth scopes you have, and what the API action accepts:
$ curl -H "Authorization: Bearer OAUTH-TOKEN" https://api.github.com/users/codertocat -I
HTTP/2 200
X-OAuth-Scopes: repo, user
X-Accepted-OAuth-Scopes: user


X-OAuth-Scopes lists the scopes your token has authorized.
X-Accepted-OAuth-Scopes lists the scopes that the action checks for.

Available scopes





















































































































































NameDescription(no scope)Grants read-only access to public information (including user profile info, repository info, and gists)repoGrants full access to public and private repositories including read and write access to code, commit statuses, repository invitations, collaborators, deployment statuses, and repository webhooks. Note: In addition to repository related resources, the repo scope also grants access to manage organization-owned resources including projects, invitations, team memberships and webhooks. This scope also grants the ability to manage projects owned by users. repo:statusGrants read/write access to commit statuses in public and private repositories. This scope is only necessary to grant other users or services access to private repository commit statuses without granting access to the code. repo_deploymentGrants access to deployment statuses for public and private repositories. This scope is only necessary to grant other users or services access to deployment statuses, without granting access to the code. public_repoLimits access to public repositories. That includes read/write access to code, commit statuses, repository projects, collaborators, and deployment statuses for public repositories and organizations. Also required for starring public repositories. repo:inviteGrants accept/decline abilities for invitations to collaborate on a repository. This scope is only necessary to grant other users or services access to invites without granting access to the code. security_eventsGrants:  read and write access to security events in the code scanning API  This scope is only necessary to grant other users or services access to security events without granting access to the code.admin:repo_hookGrants read, write, ping, and delete access to repository hooks in public or private repositories. The repo and public_repo scopes grant full access to repositories, including repository hooks. Use the admin:repo_hook scope to limit access to only repository hooks. write:repo_hookGrants read, write, and ping access to hooks in public or private repositories. read:repo_hookGrants read and ping access to hooks in public or private repositories.admin:orgFully manage the organization and its teams, projects, and memberships. write:orgRead and write access to organization membership and organization projects. read:orgRead-only access to organization membership, organization projects, and team membership.admin:public_keyFully manage public keys. write:public_keyCreate, list, and view details for public keys. read:public_keyList and view details for public keys.admin:org_hookGrants read, write, ping, and delete access to organization hooks. Note: OAuth tokens will only be able to perform these actions on organization hooks which were created by the OAuth app. Personal access tokens will only be able to perform these actions on organization hooks created by a user.gistGrants write access to gists.notificationsGrants: read access to a user's notifications mark as read access to threads watch and unwatch access to a repository, and read, write, and delete access to thread subscriptions.userGrants read/write access to profile info only. Note that this scope includes user:email and user:follow. read:userGrants access to read a user's profile data. user:emailGrants read access to a user's email addresses. user:followGrants access to follow or unfollow other users.projectGrants read/write access to user and organization projects. read:projectGrants read only access to user and organization projects.delete_repoGrants access to delete adminable repositories.write:packagesGrants access to upload or publish a package in GitHub Packages. For more information, see Publishing a package.read:packagesGrants access to download or install packages from GitHub Packages. For more information, see Installing a package.delete:packagesGrants access to delete packages from GitHub Packages. For more information, see Deleting and restoring a package.admin:gpg_keyFully manage GPG keys. write:gpg_keyCreate, list, and view details for GPG keys. read:gpg_keyList and view details for GPG keys.codespaceGrants the ability to create and manage codespaces. Codespaces can expose a GITHUB_TOKEN which may have a different set of scopes. For more information, see Security in GitHub Codespaces.workflowGrants the ability to add and update GitHub Actions workflow files. Workflow files can be committed without this scope if the same file (with both the same path and contents) exists on another branch in the same repository. Workflow files can expose GITHUB_TOKEN which may have a different set of scopes. For more information, see Automatic token authentication.read:audit_logRead audit log data.
Note

Your OAuth app can request the scopes in the initial redirection. You can specify multiple scopes by separating them with a space using %20:
https://github.com/login/oauth/authorize?
  client_id=...&
  scope=user%20repo_deployment


Requested scopes and granted scopes
The scope attribute lists scopes attached to the token that were granted by
the user. Normally, these scopes will be identical to what you requested.
However, users can edit their scopes, effectively
granting your application less access than you originally requested. Also, users
can edit token scopes after the OAuth flow is completed.
You should be aware of this possibility and adjust your application's behavior
accordingly.
It's important to handle error cases where a user chooses to grant you
less access than you originally requested. For example, applications can warn
or otherwise communicate with their users that they will see reduced
functionality or be unable to perform some actions.
Also, applications can always send users back through the flow again to get
additional permission, but don’t forget that users can always say no.
Check out the Basics of Authentication guide, which
provides tips on handling modifiable token scopes.
Normalized scopes
When requesting multiple scopes, the token is saved with a normalized list
of scopes, discarding those that are implicitly included by another requested
scope. For example, requesting user,gist,user:email will result in a
token with user and gist scopes only since the access granted with
user:email scope is included in the user scope.\n\n\n\nApps/OAuth apps/Building OAuth apps/Create custom badgesCreating a custom badge for your OAuth appYou can replace the default badge on your OAuth app by uploading your own logo image and customizing the background.By default, a new OAuth app will have an automatically generated identicon.
An identicon badge looks something like this:

After you create an OAuth app, you can customize the app's badge by uploading a logo and selecting a background color. A badge is a square logo image inside of a circular badge. You can choose a background color for the badge, which can be used to visually distinguish your app.
Your logo should be a PNG, JPG, or GIF file under 1 MB in size. For the best quality rendering, we recommend an image size of at least 200px x 200px. See Writing a listing description for your app for more guidance on customizing badges.
You can change a custom badge for a GitHub App that already has an approved Marketplace listing by navigating to https://github.com/marketplace/manage.
To create a custom badge:

In the upper-right corner of any page on GitHub, click your profile photo, then click  Settings.
In the left sidebar, click  Developer settings.
In the left sidebar, click OAuth apps.
Select the OAuth app you want to modify.
In "Application logo", drag-and-drop an image from a local folder or click Upload new logo to select an image from your computer.
Crop your picture. When you're done, click Set new application logo.
In "Badge background color", type the hexadecimal color code of the background color for your badge. Note: The "Badge background color" input field will be visible after an application logo has been uploaded.
Click Update application.

Next steps
For more information about creating a Marketplace listing for this app, see Listing an app on GitHub Marketplace.\n\n\n\nApps/OAuth apps/Building OAuth apps/Best practicesBest practices for creating an OAuth appFollow these best practices to improve the security and performance of your OAuth app.In this articleUse a GitHub App insteadUse minimal scopesAuthorize thoroughly and durablySecure your app's credentialsUse the appropriate token typeMake a plan for handling security breachesConduct regular vulnerability scansChoose an appropriate environmentUse services in a secure mannerAdd logging and monitoringEnable data deletionFurther readingUse a GitHub App instead
If possible, consider using a GitHub App instead of an OAuth app. In general, GitHub Apps are preferred over OAuth apps. GitHub Apps use fine-grained permissions, give the user more control over which repositories the app can access, and use short-lived tokens. These properties can harden the security of your app by limiting the damage that could be done if your app's credentials are leaked.
Similar to OAuth apps, GitHub Apps can still use OAuth 2.0 and generate a type of OAuth token (called a user access token) and take actions on behalf of a user. However, GitHub Apps can also act independently of a user.
For more information about GitHub Apps, see About creating GitHub Apps.
For more information about migrating an existing OAuth app to a GitHub App, see Migrating OAuth apps to GitHub Apps.
Use minimal scopes
Your OAuth app should only request the scopes that the app needs to perform its intended functionality. If any tokens for your app become compromised, this will limit the amount of damage that can occur. For more information, see Authorizing OAuth apps.
Authorize thoroughly and durably
After signing in a user, app developers must take additional steps to ensure that the user is meant to have access to the data in your system. Each sign in requires fresh checks around their memberships, access, and their current SSO status.
Use the durable, unique id to store the user
When a user signs in and performs actions in your application, you have to remember which user took that action in order to grant them access to the same resources the next time they sign in.
To store users in your database correctly, always use the id of the user. This value will never change for the user or be used to point to a different user, so it ensures you are providing access to the user you intend. You can find a user's id with the GET /user REST API endpoint. See REST API endpoints for users.
If you store references to repositories, organizations, and enterprises, use their id as well to ensure your links to them remain accurate.
Never use identifiers that can change over time, including user handles, organization slugs, or email addresses.
Validate organization access for every new authentication
When you sign in a user, you should track which organizations the user's token is authorized for. This can change over time after sign in as users are removed from organizations. If an organization uses SAML SSO and a user has not performed SAML SSO, the user access token will not have access to that organization. You should use the GET /user/installations REST API endpoint regularly to verify which organizations a user access token has access to. If the user is not authorized to access an organization, you should prevent their access to organization owned data within your own application until they perform SAML SSO or rejoin the organization. For more information, see REST API endpoints for GitHub App installations.
Store user data with organizational and enterprise contexts
Beyond tracking user identity via the id field, you should retain data for the organization or enterprise each user is operating under. This will help ensure you don't leak sensitive information if a user switches roles.
For example:

A user is in the Mona organization, which requires SAML SSO, and signs into your app after performing SSO. Your app now has access to whatever the user does within Mona.
The user pulls a bunch of code out of a repository in Mona and saves it in your app for analysis.
Later, the user switches jobs, and is removed from the Mona organization.

When the user accesses your app, can they still see the code and analysis from the Mona organization in their user account?
This is why it's critical to track the source of the data that your app is saving. Otherwise, your app is a data protection threat for organizations, and they're likely to ban your app if they can't trust that your app correctly protects their data.
Verify a user's access to your app
Your OAuth app can be accessed by users outside your organization or enterprise. If you intend an app to be used only by members of your organization or enterprise, you should check the user's membership status when the user signs in to your app.
To find the list of organizations a user is a member of, you can use the "List organizations for the authenticated user" endpoint. Then you can validate this list against a list of approved organizations for your app. For more information, see REST API endpoints for organizations.
Secure your app's credentials
With a client secret, your app can authorize a user and generate user access tokens. These tokens can be used to make API requests on behalf of a user.
You must store your app's client secret and any generated tokens securely. The storage mechanism depends on your integrations architecture and the platform that it runs on. In general, you should use a storage mechanism that is intended to store sensitive data on the platform that you are using.
Client secrets
If your app is a website or web app, consider storing your client secret in a key vault, such as Azure Key Vault, or as an encrypted environment variable or secret on your server.
If your app is a native client, client-side app, or runs on a user device (as opposed to running on your servers), you cannot secure your client secret. You should use caution if you plan to gate access to your own services based on tokens generated by your app, because anyone can access the client secret to generate a token.
User access tokens
If your app is a website or web app, you should encrypt the tokens on your back end and ensure there is security around the systems that can access the tokens. Consider storing refresh tokens in a separate place from active access tokens.
If your app is a native client, client-side app, or runs on a user device (as opposed to running on your servers), you may not be able to secure tokens as well as an app that runs on your servers. You should store tokens via the mechanism recommended for your app's platform, and keep in mind that the storage mechanism may not be fully secure.
Use the appropriate token type
OAuth apps can generate user access tokens in order to make authenticated API requests. Your app should never use a personal access token or GitHub password to authenticate.
Make a plan for handling security breaches
You should have a plan in place so that you can handle any security breaches in a timely manner.
In the event that your app's client secret is compromised, you will need to generate a new secret, update your app to use the new secret, and delete your old secret.
In the event that user access tokens are compromised, you should immediately revoke these tokens. For more information, see REST API endpoints for OAuth authorizations.
Conduct regular vulnerability scans
You should conduct regular vulnerability scans for your app. For example, you might set up code scanning and secret scanning for the repository that hosts your app's code. For more information, see About code scanning and About secret scanning.
Choose an appropriate environment
If your app runs on a server, verify that your server environment is secure and that it can handle the volume of traffic that you expect for your app.
Use services in a secure manner
If your app uses third-party services, they should be used in a secure manner:

Any services used by your app should have a unique login and password.
Apps should not share service accounts such as email or database services to manage your SaaS service.
Only employees with administrative duties should have admin access to the infrastructure that hosts your app.

Add logging and monitoring
Consider adding logging and monitoring capabilities for your app. A security log could include:

Authentication and authorization events
Service configuration changes
Object reads and writes
User and group permission changes
Elevation of role to admin

Your logs should use consistent timestamping for each event and should record the users, IP addresses, or hostnames for all logged events.
Enable data deletion
If your app is available to other users, you should give users a way to delete their data. Users should not need to email or call a support person in order to delete their data.
Further reading

Security best practices for apps on GitHub Marketplace
Customer experience best practices for apps\n\n\n\nApps/OAuth apps/Maintaining OAuth apps/Modifying an OAuth appModifying an OAuth appAfter creating and registering an OAuth app, you can make changes to it.
In the upper-right corner of any page on GitHub, click your profile photo, then click  Settings.
In the left sidebar, click  Developer settings.
In the left sidebar, click OAuth apps.
Select the OAuth app you want to modify.
Modify the OAuth app information that you'd like to change.
Click Update application.\n\n\n\nApps/OAuth apps/Maintaining OAuth apps/Activate optional featuresActivating optional features for OAuth appsYou can test new optional features for your OAuth apps.Warning

Optional features are subject to change.

Activating optional features for OAuth apps

In the upper-right corner of any page on GitHub, click your profile photo.
Navigate to your account settings.

For an app owned by a personal account, click Settings.
For an app owned by an organization:

Click Your organizations.
To the right of the organization, click Settings.




In the left sidebar, click  Developer settings.
In the left sidebar, click OAuth apps.
Select the OAuth app you want to enable an optional feature for.
In the settings sidebar, click Optional features.
Next to the optional feature you want to enable for your app, click Opt-in.\n\n\n\nApps/OAuth apps/Maintaining OAuth apps/Transfer ownershipTransferring ownership of an OAuth appYou can transfer ownership of an OAuth app to another user or organization.
In the upper-right corner of any page on GitHub, click your profile photo, then click  Settings.
In the left sidebar, click  Developer settings.
In the left sidebar, click OAuth apps.
Select the OAuth app you want to modify.
Click Transfer ownership.
To confirm the transfer, in the text field, type the name of the OAuth app you want to transfer.
Under "New owner's GitHub username or organization name," type the name of the user or organization you want to transfer the OAuth app to.
Click Transfer this application.

Once you initiate the transfer, the new owner needs to navigate to their OAuth apps page. From there, they should see the app listed under "Pending transfer requests". They need to click on the app name and then click Complete transfer.\n\n\n\nApps/OAuth apps/Maintaining OAuth apps/Troubleshoot authorizationTroubleshooting authorization request errorsWhen obtaining an OAuth token for a user, some errors may occur during the initial authorization request phase.In this articleApplication suspendedRedirect URI mismatchApplication suspended
If the OAuth app you set up has been suspended (due to reported abuse, spam, or a mis-use of the API), GitHub will redirect to the registered callback URL using the following parameters to summarize the error:
http://your-application.com/callback?error=application_suspended
  &error_description=Your+application+has+been+suspended.+Contact+support@github.com.
  &error_uri=/apps/building-integrations/setting-up-and-registering-oauth-apps/troubleshooting-authorization-request-errors/%23application-suspended
  &state=xyz

To solve issues with suspended applications, please contact us through the GitHub Support portal.
Redirect URI mismatch
If you provide a redirect_uri that doesn't match what you've registered with your application, GitHub will redirect to the registered callback URL with the following parameters summarizing the error:
http://your-application.com/callback?error=redirect_uri_mismatch
  &error_description=The+redirect_uri+MUST+match+the+registered+callback+URL+for+this+application.
  &error_uri=/apps/building-integrations/setting-up-and-registering-oauth-apps/troubleshooting-authorization-request-errors/%23redirect-uri-mismatch
  &state=xyz

To correct this error, either provide a redirect_uri that matches what you registered or leave out this parameter to use the default one registered with your application.
Access denied
If the user rejects access to your application, GitHub will redirect to
the registered callback URL with the following parameters summarizing
the error:
http://your-application.com/callback?error=access_denied
  &error_description=The+user+has+denied+your+application+access.
  &error_uri=/apps/building-integrations/setting-up-and-registering-oauth-apps/troubleshooting-authorization-request-errors/%23access-denied
  &state=xyz

There's nothing you can do here as users are free to choose not to use
your application. More often than not, users will just close the window
or press back in their browser, so it is likely that you'll never see
this error.\n\n\n\n