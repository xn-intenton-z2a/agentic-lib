Thanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideSet up your projectExample functionHandler naming conventionsInput event objectValid handler patternsUsing the SDK for JavaScriptAccessing environment variablesUsing global stateBest practicesDefine Lambda function handler in Node.jsThe Lambda function handler is the method in your function code that processes events. When your function is
  invoked, Lambda runs the handler method. Your function runs until the handler returns a response, exits, or times out.This page describes how to work with Lambda function handlers in Node.js, including options for project
    setup, naming conventions, and best practices. This page also includes an example of a Node.js Lambda
    function that takes in information about an order, produces a text file receipt, and puts this file
    in an Amazon Simple Storage Service (Amazon S3) bucket. For information about how to deploy your function after writing it, see
    Deploy Node.js Lambda functions with .zip file archives or Deploy Node.js Lambda functions with container images.TopicsSetting up your Node.js handler projectExample Node.js Lambda function codeHandler naming conventionsDefining and accessing the input event objectValid handler patterns for Node.js functionsUsing the SDK for JavaScript v3 in your handlerAccessing environment variablesUsing global stateCode best practices for Node.js Lambda functions
    Setting up your Node.js handler project
    There are multiple ways to initialize a Node.js Lambda project. For example, you can create a standard Node.js project using npm, create an AWS SAM application, or create an AWS CDK application.
    To create the project using npm:
    npm init
    This command initializes your project and generates a package.json file that manages your project's metadata and dependencies.
    Your function code lives in a .js or .mjs JavaScript file. In the following example, we name this file index.mjs because it uses an ES module handler. Lambda supports both ES module and CommonJS handlers. For more information, see Designating a function handler as an ES module.
    A typical Node.js Lambda function project follows this general structure:
    /project-root
  ├── index.mjs — Contains main handler
  ├── package.json — Project metadata and dependencies
  ├── package-lock.json — Dependency lock file
  └── node_modules/ — Installed dependencies
   
    Example Node.js Lambda function code
    The following example Lambda function code takes in information about an order,
      produces a text file receipt, and puts this file in an Amazon S3 bucket.
    NoteThis example uses an ES module handler. Lambda supports both ES module and CommonJS handlers. For more information, see Designating a function handler as an ES module.
    Example index.mjs Lambda functionimport { S3Client, PutObjectCommand } from '@aws-sdk/client-s3';

// Initialize the S3 client outside the handler for reuse
const s3Client = new S3Client();

/**
 * Lambda handler for processing orders and storing receipts in S3.
 * @param {Object} event - Input event containing order details
 * @param {string} event.order_id - The unique identifier for the order
 * @param {number} event.amount - The order amount
 * @param {string} event.item - The item purchased
 * @returns {Promise<string>} Success message
 */
export const handler = async(event) => {
    try {
        // Access environment variables
        const bucketName = process.env.RECEIPT_BUCKET;
        if (!bucketName) {
            throw new Error('RECEIPT_BUCKET environment variable is not set');
        }

        // Create the receipt content and key destination
        const receiptContent = `OrderID: ${event.order_id}\nAmount: $${event.amount.toFixed(2)}\nItem: ${event.item}`;
        const key = `receipts/${event.order_id}.txt`;

        // Upload the receipt to S3
        await uploadReceiptToS3(bucketName, key, receiptContent);

        console.log(`Successfully processed order ${event.order_id} and stored receipt in S3 bucket ${bucketName}`);
        return 'Success';
    } catch (error) {
        console.error(`Failed to process order: ${error.message}`);
        throw error;
    }
};

/**
 * Helper function to upload receipt to S3
 * @param {string} bucketName - The S3 bucket name
 * @param {string} key - The S3 object key
 * @param {string} receiptContent - The content to upload
 * @returns {Promise<void>}
 */
async function uploadReceiptToS3(bucketName, key, receiptContent) {
    try {
        const command = new PutObjectCommand({
            Bucket: bucketName,
            Key: key,
            Body: receiptContent
        });

        await s3Client.send(command);
    } catch (error) {
        throw new Error(`Failed to upload receipt to S3: ${error.message}`);
    }
}
    This index.mjs file contains the following sections of code:
    
       
       
       
       
       
    
        import block: Use this block to include libraries that your Lambda function requires, such as AWS SDK clients.
      
        const s3Client declaration: This initializes an Amazon S3 client outside of the handler function. This causes Lambda to run this code during the initialization phase, and the client is preserved for reuse across multiple invocations.
      
        JSDoc comment block: Define the input and output types for your handler using JSDoc annotations.
      
        export const handler: This is the main handler function that Lambda invokes. When deploying your function, specify index.handler for the Handler property. The value of the Handler property is the file name and the name of the exported handler method, separated by a dot.
      
        uploadReceiptToS3 function: This is a helper function that's referenced by the main handler function.
      
    
    For this function to work properly, its  execution role must allow the s3:PutObject action. Also, ensure that you define the RECEIPT_BUCKET environment variable. After a successful invocation, the Amazon S3 bucket should contain a receipt file.
   
    Handler naming conventions
    When you configure a function, the value of the Handler setting is
      the file name and the name of the exported handler method, separated by a dot. The default for functions created in the console and for
      examples in this guide is index.handler. This indicates the handler method that's exported
      from the index.js or index.mjs file.
    If you create a function in the console using a different file name or function handler name, you must edit 
      the default handler name.
    To change the function handler name (console)
        Open the Functions page of the Lambda console and choose your function.
      
        Choose the Code tab.
      
        Scroll down to the Runtime settings pane and choose Edit.
      
        In Handler, enter the new name for your function handler.
      
        Choose Save.
      

   
    Defining and accessing the input event object
    
    JSON is the most common and standard input format for Lambda functions. In this example,
      the function expects an input similar to the following:
    {
    "order_id": "12345",
    "amount": 199.99,
    "item": "Wireless Headphones"
}
    When working with Lambda functions in Node.js, you can define the expected shape of the input event using JSDoc annotations. In this example, we define the input structure in the handler's JSDoc comment:
    /**
 * Lambda handler for processing orders and storing receipts in S3.
 * @param {Object} event - Input event containing order details
 * @param {string} event.order_id - The unique identifier for the order
 * @param {number} event.amount - The order amount
 * @param {string} event.item - The item purchased
 * @returns {Promise<string>} Success message
 */
    After you define these types in your JSDoc comment, you can access the fields of the event object directly in your code. For example, event.order_id retrieves the value of order_id from the original input.
   
    Valid handler patterns for Node.js functions
    We recommend that you use async/await to declare the function handler instead of using callbacks. Async/await is a concise and readable way to write asynchronous code, without the need for nested callbacks or chaining promises. With async/await, you can write code that reads like synchronous code, while still being asynchronous and non-blocking.
     
      Using async/await (recommended)
      
      The async keyword marks a function as asynchronous, and the await keyword pauses the execution of the function until a Promise is resolved. The handler accepts the following arguments:
      
         
         
      
          event: Contains the input data passed to your function.
        
          context: Contains information about the invocation, function, and execution environment. For more information, see Using the Lambda context object to retrieve Node.js function information.
        
      Here are the valid signatures for the async/await pattern:
       
          
          
       export const handler = async (event) => { };export const handler = async (event, context) => { };
      NoteUse a local integrated development environment (IDE) or text editor to write your TypeScript function code. You can’t create TypeScript code on the Lambda console.
     
     
      Using callbacks
      Callback handlers must use the event, context, and callback arguments. Example:
      export const handler = (event, context, callback) => { };
      The callback function expects an Error and a response, which must be JSON-serializable. The function continues to execute until the event loop is empty or the function times out. The response isn't sent to the invoker until all event loop tasks are finished. If the function times out, an error is returned instead. You can configure the runtime to send the response immediately by setting context.callbackWaitsForEmptyEventLoop to false.
      Example  – HTTP request with callbackThe following example function checks a URL and returns the status code to the invoker.import https from "https";
let url = "https://aws.amazon.com/";

export const handler = (event, context, callback) => {
  https.get(url, (res) => {
    callback(null, res.statusCode);
  }).on("error", (e) => {
    callback(Error(e));
  });
};
     
   
    Using the SDK for JavaScript v3 in your handler
    Often, you’ll use Lambda functions to interact with or make updates to other AWS resources. The simplest way to interface with these resources is to use the AWS SDK for JavaScript. All supported Lambda Node.js runtimes include the SDK for JavaScript version 3. However, we strongly recommend that you include the AWS SDK clients that you need in your deployment package. This maximizes backward compatibility during future Lambda runtime updates. Only rely on the runtime-provided SDK when you can't include additional packages (for example, when using the Lambda console code editor or inline code in an AWS CloudFormation template).
    To add SDK dependencies to your function, use the npm install command for the specific SDK clients that you need. In the example code, we used the Amazon S3 client. Add this dependency by running the following command in the directory that contains your package.json file:
npm install @aws-sdk/client-s3
    In the function code, import the client and commands that you need, as the example function demonstrates:
    import { S3Client, PutObjectCommand } from '@aws-sdk/client-s3';
    Then, initialize an Amazon S3 client:
    const s3Client = new S3Client();
    
    In this example, we initialized our Amazon S3 client outside of the main handler function to avoid having to initialize it every time we invoke our function. After you initialize your SDK client, you can then use it to make API calls for that AWS service. The example code calls the Amazon S3 PutObject API action as follows:
    const command = new PutObjectCommand({
    Bucket: bucketName,
    Key: key,
    Body: receiptContent
});
   
    Accessing environment variables
    In your handler code, you can reference any environment variables by using process.env. In this example, we reference the defined RECEIPT_BUCKET environment variable using the following lines of code:
    // Access environment variables
const bucketName = process.env.RECEIPT_BUCKET;
if (!bucketName) {
    throw new Error('RECEIPT_BUCKET environment variable is not set');
}
   
    Using global state
    Lambda runs your static code during the initialization phase before invoking your function for the first time. Resources created during initialization stay in memory between invocations, so you can avoid having to create them every time you invoke your function.
In the example code, the S3 client initialization code is outside the handler. The runtime initializes the client before the function handles its first event, and the client remains available for reuse across all invocations.
   
    Code best practices for Node.js Lambda functions
    
    Follow these guidelines when building Lambda functions:
    
       
       
       
       
    
        Separate the Lambda handler from your core logic. This allows you to make a more unit-testable function.
      
        Control the dependencies in your function's deployment package.  The AWS Lambda execution environment contains a number of libraries. For the Node.js and Python runtimes, these include the AWS SDKs. To enable the latest set of features and security updates, Lambda will periodically update these libraries. These updates may introduce subtle changes to the behavior of your Lambda function. To have full control of the dependencies your function uses, package all of your dependencies with your deployment package. 
      
        Minimize the complexity of your dependencies. Prefer simpler frameworks that load quickly on execution environment startup.
      
        Minimize your deployment package size to its runtime necessities.  This will reduce the amount of time that it takes for your deployment package to be downloaded and unpacked ahead of invocation.
      
    
 
 
 
     
     
     

      Take advantage of execution environment reuse to improve the performance of your
        function. Initialize SDK clients and database connections outside of the function handler, and
        cache static assets locally in the /tmp directory. Subsequent invocations processed by
        the same instance of your function can reuse these resources. This saves cost by reducing function run time.
      To avoid potential data leaks across invocations, don’t use the execution environment to store user data,
        events, or other information with security implications. If your function relies on a mutable state that can’t
        be stored in memory within the handler, consider creating a separate function or separate versions of a
        function for each user.
    
Use a keep-alive directive to maintain persistent connections. Lambda purges idle connections over time. 
Attempting to reuse an idle connection when invoking a function will result in a connection error. To maintain your persistent connection, use the 
keep-alive directive associated with your runtime. 
For an example, see Reusing Connections with Keep-Alive in Node.js.

Use environment variables to pass operational parameters to your function. For example, if
        you are writing to an Amazon S3 bucket, instead of hard-coding the bucket name you are writing to, configure the
        bucket name as an environment variable.

      Avoid using recursive invocations in your Lambda function, where the function
        invokes itself or initiates a process that may invoke the function again. This could lead to unintended volume of
        function invocations and escalated costs. If you see an unintended volume of invocations, set the function reserved concurrency
        to 0 immediately to throttle all invocations to the function, while you update the
        code.
    
      Do not use non-documented, non-public APIs in your Lambda function code.
        For AWS Lambda managed runtimes, Lambda periodically applies security and functional updates to Lambda's internal APIs.
        These internal API updates may be backwards-incompatible, leading to unintended consequences such as invocation
        failures if your function has a dependency on these non-public APIs. See
        the API reference for a list of
        publicly available APIs.
    
      Write idempotent code. Writing idempotent code for your functions ensures that
        duplicate events are handled the same way. Your code should properly validate events and gracefully handle
        duplicate events. For more information, see
        How do I make
          my Lambda function idempotent?.
    
  Document ConventionsBuilding with Node.jsDeploy .zip file archivesDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\n\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideWhen to use LambdaKey featuresWhat is AWS Lambda?You can use AWS Lambda to run code without provisioning or managing servers. Lambda runs your code
    on a high-availability compute infrastructure and performs all of the administration of the compute resources,
    including server and operating system maintenance, capacity provisioning and automatic scaling, and
    logging. With Lambda, all you need to do is supply your code in one of the language runtimes that Lambda supports.You organize your code into Lambda functions. The Lambda service runs your function only when needed and scales automatically. You only pay for the compute time that you consume—there is no charge when your code is not running. For more information, see AWS Lambda Pricing.TipTo learn how to build serverless solutions, check out the Serverless Developer Guide.
    When to use Lambda
    Lambda is an ideal compute service for application scenarios that need to scale up rapidly, and scale down to
      zero when not in demand. For example, you can use Lambda for:
  
     
     
     
     
     
  
      File processing: Use Amazon Simple Storage Service (Amazon S3) to trigger Lambda data processing in real time after an upload.
    
      Stream processing: Use Lambda and Amazon Kinesis to process real-time streaming data for application activity tracking, transaction order processing, clickstream analysis, data cleansing, log filtering, indexing, social media analysis, Internet of Things (IoT) device data telemetry, and metering.
    
      Web applications: Combine Lambda with other AWS services to build powerful web applications that automatically scale up and down and run in a highly available configuration across multiple data centers.
    
      IoT backends: Build serverless backends using Lambda to handle web, mobile, IoT, and third-party API requests.
    
      Mobile backends: Build backends using Lambda and Amazon API Gateway  to authenticate and process API requests. Use AWS Amplify to easily integrate with your iOS, Android, Web, and React Native frontends.
    
    When using Lambda, you are responsible only for your code. Lambda manages the compute fleet that offers a
      balance of memory, CPU, network, and other resources to run your code. Because Lambda manages these resources, you
      cannot log in to compute instances or customize the operating system on provided
        runtimes. Lambda performs operational and administrative activities on your behalf, including managing
      capacity, monitoring, and logging your Lambda functions.
   
    Key features
    The following key features help you develop Lambda applications that are scalable, secure, and easily
      extensible:

    
    
       

       
      
       
      
       
      
       
  
       
      
       
           
       

       
      
       

       

       
      
    
        Environment variables
        
          Use environment variables to adjust your function's behavior without updating code.
        
      
        Versions
        
          Manage the deployment of your functions with versions, so that, for example, a new function can be used for beta testing without affecting users of the stable production version.
        
      
        Container images
        
          Create a container image for a Lambda function by using an AWS provided base image or an alternative base
            image so that you can reuse your existing container tooling or deploy larger workloads that rely on sizable dependencies, such as machine learning.
        
      
        Lambda layers
        
          Package libraries and other dependencies to reduce the size of deployment archives and makes it faster to deploy your code.
        
      
        Lambda extensions
        
          Augment your Lambda functions with tools for monitoring, observability, security, and governance.
        
      
        Function URLs
        
          Add a dedicated HTTP(S) endpoint to your Lambda function.
        
      
        Response streaming
        
          Configure your Lambda function URLs to stream response payloads back to clients from Node.js functions, to improve time to first byte (TTFB) performance or to return larger payloads.
        
      
        Concurrency and scaling controls
        
          Apply fine-grained control over the scaling and responsiveness of your production applications.
        
      
        Code signing
        
          Verify that only approved developers publish unaltered, trusted code in your Lambda functions 
        
      
        Private networking
        
          Create a private network for resources such as databases, cache instances, or internal services.
        
      
        File system
        
          Configure a function to mount an Amazon Elastic File System (Amazon EFS) to a local directory, so that your function code can access and modify shared resources safely and at high concurrency.
        
      
        Lambda SnapStart
        
          Lambda SnapStart can provide as low as sub-second startup performance, typically with no changes to your function code.
        
      
  Document ConventionsCreate your first functionDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideSet up your projectExample functionHandler naming conventionsInput event objectValid handler patternsUsing the SDK for JavaScriptAccessing environment variablesUsing global stateBest practicesDefine Lambda function handler in Node.jsThe Lambda function handler is the method in your function code that processes events. When your function is
  invoked, Lambda runs the handler method. Your function runs until the handler returns a response, exits, or times out.This page describes how to work with Lambda function handlers in Node.js, including options for project
    setup, naming conventions, and best practices. This page also includes an example of a Node.js Lambda
    function that takes in information about an order, produces a text file receipt, and puts this file
    in an Amazon Simple Storage Service (Amazon S3) bucket. For information about how to deploy your function after writing it, see
    Deploy Node.js Lambda functions with .zip file archives or Deploy Node.js Lambda functions with container images.TopicsSetting up your Node.js handler projectExample Node.js Lambda function codeHandler naming conventionsDefining and accessing the input event objectValid handler patterns for Node.js functionsUsing the SDK for JavaScript v3 in your handlerAccessing environment variablesUsing global stateCode best practices for Node.js Lambda functions
    Setting up your Node.js handler project
    There are multiple ways to initialize a Node.js Lambda project. For example, you can create a standard Node.js project using npm, create an AWS SAM application, or create an AWS CDK application.
    To create the project using npm:
    npm init
    This command initializes your project and generates a package.json file that manages your project's metadata and dependencies.
    Your function code lives in a .js or .mjs JavaScript file. In the following example, we name this file index.mjs because it uses an ES module handler. Lambda supports both ES module and CommonJS handlers. For more information, see Designating a function handler as an ES module.
    A typical Node.js Lambda function project follows this general structure:
    /project-root
  ├── index.mjs — Contains main handler
  ├── package.json — Project metadata and dependencies
  ├── package-lock.json — Dependency lock file
  └── node_modules/ — Installed dependencies
   
    Example Node.js Lambda function code
    The following example Lambda function code takes in information about an order,
      produces a text file receipt, and puts this file in an Amazon S3 bucket.
    NoteThis example uses an ES module handler. Lambda supports both ES module and CommonJS handlers. For more information, see Designating a function handler as an ES module.
    Example index.mjs Lambda functionimport { S3Client, PutObjectCommand } from '@aws-sdk/client-s3';

// Initialize the S3 client outside the handler for reuse
const s3Client = new S3Client();

/**
 * Lambda handler for processing orders and storing receipts in S3.
 * @param {Object} event - Input event containing order details
 * @param {string} event.order_id - The unique identifier for the order
 * @param {number} event.amount - The order amount
 * @param {string} event.item - The item purchased
 * @returns {Promise<string>} Success message
 */
export const handler = async(event) => {
    try {
        // Access environment variables
        const bucketName = process.env.RECEIPT_BUCKET;
        if (!bucketName) {
            throw new Error('RECEIPT_BUCKET environment variable is not set');
        }

        // Create the receipt content and key destination
        const receiptContent = `OrderID: ${event.order_id}\nAmount: $${event.amount.toFixed(2)}\nItem: ${event.item}`;
        const key = `receipts/${event.order_id}.txt`;

        // Upload the receipt to S3
        await uploadReceiptToS3(bucketName, key, receiptContent);

        console.log(`Successfully processed order ${event.order_id} and stored receipt in S3 bucket ${bucketName}`);
        return 'Success';
    } catch (error) {
        console.error(`Failed to process order: ${error.message}`);
        throw error;
    }
};

/**
 * Helper function to upload receipt to S3
 * @param {string} bucketName - The S3 bucket name
 * @param {string} key - The S3 object key
 * @param {string} receiptContent - The content to upload
 * @returns {Promise<void>}
 */
async function uploadReceiptToS3(bucketName, key, receiptContent) {
    try {
        const command = new PutObjectCommand({
            Bucket: bucketName,
            Key: key,
            Body: receiptContent
        });

        await s3Client.send(command);
    } catch (error) {
        throw new Error(`Failed to upload receipt to S3: ${error.message}`);
    }
}
    This index.mjs file contains the following sections of code:
    
       
       
       
       
       
    
        import block: Use this block to include libraries that your Lambda function requires, such as AWS SDK clients.
      
        const s3Client declaration: This initializes an Amazon S3 client outside of the handler function. This causes Lambda to run this code during the initialization phase, and the client is preserved for reuse across multiple invocations.
      
        JSDoc comment block: Define the input and output types for your handler using JSDoc annotations.
      
        export const handler: This is the main handler function that Lambda invokes. When deploying your function, specify index.handler for the Handler property. The value of the Handler property is the file name and the name of the exported handler method, separated by a dot.
      
        uploadReceiptToS3 function: This is a helper function that's referenced by the main handler function.
      
    
    For this function to work properly, its  execution role must allow the s3:PutObject action. Also, ensure that you define the RECEIPT_BUCKET environment variable. After a successful invocation, the Amazon S3 bucket should contain a receipt file.
   
    Handler naming conventions
    When you configure a function, the value of the Handler setting is
      the file name and the name of the exported handler method, separated by a dot. The default for functions created in the console and for
      examples in this guide is index.handler. This indicates the handler method that's exported
      from the index.js or index.mjs file.
    If you create a function in the console using a different file name or function handler name, you must edit 
      the default handler name.
    To change the function handler name (console)
        Open the Functions page of the Lambda console and choose your function.
      
        Choose the Code tab.
      
        Scroll down to the Runtime settings pane and choose Edit.
      
        In Handler, enter the new name for your function handler.
      
        Choose Save.
      

   
    Defining and accessing the input event object
    
    JSON is the most common and standard input format for Lambda functions. In this example,
      the function expects an input similar to the following:
    {
    "order_id": "12345",
    "amount": 199.99,
    "item": "Wireless Headphones"
}
    When working with Lambda functions in Node.js, you can define the expected shape of the input event using JSDoc annotations. In this example, we define the input structure in the handler's JSDoc comment:
    /**
 * Lambda handler for processing orders and storing receipts in S3.
 * @param {Object} event - Input event containing order details
 * @param {string} event.order_id - The unique identifier for the order
 * @param {number} event.amount - The order amount
 * @param {string} event.item - The item purchased
 * @returns {Promise<string>} Success message
 */
    After you define these types in your JSDoc comment, you can access the fields of the event object directly in your code. For example, event.order_id retrieves the value of order_id from the original input.
   
    Valid handler patterns for Node.js functions
    We recommend that you use async/await to declare the function handler instead of using callbacks. Async/await is a concise and readable way to write asynchronous code, without the need for nested callbacks or chaining promises. With async/await, you can write code that reads like synchronous code, while still being asynchronous and non-blocking.
     
      Using async/await (recommended)
      
      The async keyword marks a function as asynchronous, and the await keyword pauses the execution of the function until a Promise is resolved. The handler accepts the following arguments:
      
         
         
      
          event: Contains the input data passed to your function.
        
          context: Contains information about the invocation, function, and execution environment. For more information, see Using the Lambda context object to retrieve Node.js function information.
        
      Here are the valid signatures for the async/await pattern:
       
          
          
       export const handler = async (event) => { };export const handler = async (event, context) => { };
      NoteUse a local integrated development environment (IDE) or text editor to write your TypeScript function code. You can’t create TypeScript code on the Lambda console.
     
     
      Using callbacks
      Callback handlers must use the event, context, and callback arguments. Example:
      export const handler = (event, context, callback) => { };
      The callback function expects an Error and a response, which must be JSON-serializable. The function continues to execute until the event loop is empty or the function times out. The response isn't sent to the invoker until all event loop tasks are finished. If the function times out, an error is returned instead. You can configure the runtime to send the response immediately by setting context.callbackWaitsForEmptyEventLoop to false.
      Example  – HTTP request with callbackThe following example function checks a URL and returns the status code to the invoker.import https from "https";
let url = "https://aws.amazon.com/";

export const handler = (event, context, callback) => {
  https.get(url, (res) => {
    callback(null, res.statusCode);
  }).on("error", (e) => {
    callback(Error(e));
  });
};
     
   
    Using the SDK for JavaScript v3 in your handler
    Often, you’ll use Lambda functions to interact with or make updates to other AWS resources. The simplest way to interface with these resources is to use the AWS SDK for JavaScript. All supported Lambda Node.js runtimes include the SDK for JavaScript version 3. However, we strongly recommend that you include the AWS SDK clients that you need in your deployment package. This maximizes backward compatibility during future Lambda runtime updates. Only rely on the runtime-provided SDK when you can't include additional packages (for example, when using the Lambda console code editor or inline code in an AWS CloudFormation template).
    To add SDK dependencies to your function, use the npm install command for the specific SDK clients that you need. In the example code, we used the Amazon S3 client. Add this dependency by running the following command in the directory that contains your package.json file:
npm install @aws-sdk/client-s3
    In the function code, import the client and commands that you need, as the example function demonstrates:
    import { S3Client, PutObjectCommand } from '@aws-sdk/client-s3';
    Then, initialize an Amazon S3 client:
    const s3Client = new S3Client();
    
    In this example, we initialized our Amazon S3 client outside of the main handler function to avoid having to initialize it every time we invoke our function. After you initialize your SDK client, you can then use it to make API calls for that AWS service. The example code calls the Amazon S3 PutObject API action as follows:
    const command = new PutObjectCommand({
    Bucket: bucketName,
    Key: key,
    Body: receiptContent
});
   
    Accessing environment variables
    In your handler code, you can reference any environment variables by using process.env. In this example, we reference the defined RECEIPT_BUCKET environment variable using the following lines of code:
    // Access environment variables
const bucketName = process.env.RECEIPT_BUCKET;
if (!bucketName) {
    throw new Error('RECEIPT_BUCKET environment variable is not set');
}
   
    Using global state
    Lambda runs your static code during the initialization phase before invoking your function for the first time. Resources created during initialization stay in memory between invocations, so you can avoid having to create them every time you invoke your function.
In the example code, the S3 client initialization code is outside the handler. The runtime initializes the client before the function handles its first event, and the client remains available for reuse across all invocations.
   
    Code best practices for Node.js Lambda functions
    
    Follow these guidelines when building Lambda functions:
    
       
       
       
       
    
        Separate the Lambda handler from your core logic. This allows you to make a more unit-testable function.
      
        Control the dependencies in your function's deployment package.  The AWS Lambda execution environment contains a number of libraries. For the Node.js and Python runtimes, these include the AWS SDKs. To enable the latest set of features and security updates, Lambda will periodically update these libraries. These updates may introduce subtle changes to the behavior of your Lambda function. To have full control of the dependencies your function uses, package all of your dependencies with your deployment package. 
      
        Minimize the complexity of your dependencies. Prefer simpler frameworks that load quickly on execution environment startup.
      
        Minimize your deployment package size to its runtime necessities.  This will reduce the amount of time that it takes for your deployment package to be downloaded and unpacked ahead of invocation.
      
    
 
 
 
     
     
     

      Take advantage of execution environment reuse to improve the performance of your
        function. Initialize SDK clients and database connections outside of the function handler, and
        cache static assets locally in the /tmp directory. Subsequent invocations processed by
        the same instance of your function can reuse these resources. This saves cost by reducing function run time.
      To avoid potential data leaks across invocations, don’t use the execution environment to store user data,
        events, or other information with security implications. If your function relies on a mutable state that can’t
        be stored in memory within the handler, consider creating a separate function or separate versions of a
        function for each user.
    
Use a keep-alive directive to maintain persistent connections. Lambda purges idle connections over time. 
Attempting to reuse an idle connection when invoking a function will result in a connection error. To maintain your persistent connection, use the 
keep-alive directive associated with your runtime. 
For an example, see Reusing Connections with Keep-Alive in Node.js.

Use environment variables to pass operational parameters to your function. For example, if
        you are writing to an Amazon S3 bucket, instead of hard-coding the bucket name you are writing to, configure the
        bucket name as an environment variable.

      Avoid using recursive invocations in your Lambda function, where the function
        invokes itself or initiates a process that may invoke the function again. This could lead to unintended volume of
        function invocations and escalated costs. If you see an unintended volume of invocations, set the function reserved concurrency
        to 0 immediately to throttle all invocations to the function, while you update the
        code.
    
      Do not use non-documented, non-public APIs in your Lambda function code.
        For AWS Lambda managed runtimes, Lambda periodically applies security and functional updates to Lambda's internal APIs.
        These internal API updates may be backwards-incompatible, leading to unintended consequences such as invocation
        failures if your function has a dependency on these non-public APIs. See
        the API reference for a list of
        publicly available APIs.
    
      Write idempotent code. Writing idempotent code for your functions ensures that
        duplicate events are handled the same way. Your code should properly validate events and gracefully handle
        duplicate events. For more information, see
        How do I make
          my Lambda function idempotent?.
    
  Document ConventionsBuilding with Node.jsDeploy .zip file archivesDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideSet up your projectExample functionHandler naming conventionsInput event objectValid handler patternsUsing the SDK for JavaScriptAccessing environment variablesUsing global stateBest practicesDefine Lambda function handler in Node.jsThe Lambda function handler is the method in your function code that processes events. When your function is
  invoked, Lambda runs the handler method. Your function runs until the handler returns a response, exits, or times out.This page describes how to work with Lambda function handlers in Node.js, including options for project
    setup, naming conventions, and best practices. This page also includes an example of a Node.js Lambda
    function that takes in information about an order, produces a text file receipt, and puts this file
    in an Amazon Simple Storage Service (Amazon S3) bucket. For information about how to deploy your function after writing it, see
    Deploy Node.js Lambda functions with .zip file archives or Deploy Node.js Lambda functions with container images.TopicsSetting up your Node.js handler projectExample Node.js Lambda function codeHandler naming conventionsDefining and accessing the input event objectValid handler patterns for Node.js functionsUsing the SDK for JavaScript v3 in your handlerAccessing environment variablesUsing global stateCode best practices for Node.js Lambda functions
    Setting up your Node.js handler project
    There are multiple ways to initialize a Node.js Lambda project. For example, you can create a standard Node.js project using npm, create an AWS SAM application, or create an AWS CDK application.
    To create the project using npm:
    npm init
    This command initializes your project and generates a package.json file that manages your project's metadata and dependencies.
    Your function code lives in a .js or .mjs JavaScript file. In the following example, we name this file index.mjs because it uses an ES module handler. Lambda supports both ES module and CommonJS handlers. For more information, see Designating a function handler as an ES module.
    A typical Node.js Lambda function project follows this general structure:
    /project-root
  ├── index.mjs — Contains main handler
  ├── package.json — Project metadata and dependencies
  ├── package-lock.json — Dependency lock file
  └── node_modules/ — Installed dependencies
   
    Example Node.js Lambda function code
    The following example Lambda function code takes in information about an order,
      produces a text file receipt, and puts this file in an Amazon S3 bucket.
    NoteThis example uses an ES module handler. Lambda supports both ES module and CommonJS handlers. For more information, see Designating a function handler as an ES module.
    Example index.mjs Lambda functionimport { S3Client, PutObjectCommand } from '@aws-sdk/client-s3';

// Initialize the S3 client outside the handler for reuse
const s3Client = new S3Client();

/**
 * Lambda handler for processing orders and storing receipts in S3.
 * @param {Object} event - Input event containing order details
 * @param {string} event.order_id - The unique identifier for the order
 * @param {number} event.amount - The order amount
 * @param {string} event.item - The item purchased
 * @returns {Promise<string>} Success message
 */
export const handler = async(event) => {
    try {
        // Access environment variables
        const bucketName = process.env.RECEIPT_BUCKET;
        if (!bucketName) {
            throw new Error('RECEIPT_BUCKET environment variable is not set');
        }

        // Create the receipt content and key destination
        const receiptContent = `OrderID: ${event.order_id}\nAmount: $${event.amount.toFixed(2)}\nItem: ${event.item}`;
        const key = `receipts/${event.order_id}.txt`;

        // Upload the receipt to S3
        await uploadReceiptToS3(bucketName, key, receiptContent);

        console.log(`Successfully processed order ${event.order_id} and stored receipt in S3 bucket ${bucketName}`);
        return 'Success';
    } catch (error) {
        console.error(`Failed to process order: ${error.message}`);
        throw error;
    }
};

/**
 * Helper function to upload receipt to S3
 * @param {string} bucketName - The S3 bucket name
 * @param {string} key - The S3 object key
 * @param {string} receiptContent - The content to upload
 * @returns {Promise<void>}
 */
async function uploadReceiptToS3(bucketName, key, receiptContent) {
    try {
        const command = new PutObjectCommand({
            Bucket: bucketName,
            Key: key,
            Body: receiptContent
        });

        await s3Client.send(command);
    } catch (error) {
        throw new Error(`Failed to upload receipt to S3: ${error.message}`);
    }
}
    This index.mjs file contains the following sections of code:
    
       
       
       
       
       
    
        import block: Use this block to include libraries that your Lambda function requires, such as AWS SDK clients.
      
        const s3Client declaration: This initializes an Amazon S3 client outside of the handler function. This causes Lambda to run this code during the initialization phase, and the client is preserved for reuse across multiple invocations.
      
        JSDoc comment block: Define the input and output types for your handler using JSDoc annotations.
      
        export const handler: This is the main handler function that Lambda invokes. When deploying your function, specify index.handler for the Handler property. The value of the Handler property is the file name and the name of the exported handler method, separated by a dot.
      
        uploadReceiptToS3 function: This is a helper function that's referenced by the main handler function.
      
    
    For this function to work properly, its  execution role must allow the s3:PutObject action. Also, ensure that you define the RECEIPT_BUCKET environment variable. After a successful invocation, the Amazon S3 bucket should contain a receipt file.
   
    Handler naming conventions
    When you configure a function, the value of the Handler setting is
      the file name and the name of the exported handler method, separated by a dot. The default for functions created in the console and for
      examples in this guide is index.handler. This indicates the handler method that's exported
      from the index.js or index.mjs file.
    If you create a function in the console using a different file name or function handler name, you must edit 
      the default handler name.
    To change the function handler name (console)
        Open the Functions page of the Lambda console and choose your function.
      
        Choose the Code tab.
      
        Scroll down to the Runtime settings pane and choose Edit.
      
        In Handler, enter the new name for your function handler.
      
        Choose Save.
      

   
    Defining and accessing the input event object
    
    JSON is the most common and standard input format for Lambda functions. In this example,
      the function expects an input similar to the following:
    {
    "order_id": "12345",
    "amount": 199.99,
    "item": "Wireless Headphones"
}
    When working with Lambda functions in Node.js, you can define the expected shape of the input event using JSDoc annotations. In this example, we define the input structure in the handler's JSDoc comment:
    /**
 * Lambda handler for processing orders and storing receipts in S3.
 * @param {Object} event - Input event containing order details
 * @param {string} event.order_id - The unique identifier for the order
 * @param {number} event.amount - The order amount
 * @param {string} event.item - The item purchased
 * @returns {Promise<string>} Success message
 */
    After you define these types in your JSDoc comment, you can access the fields of the event object directly in your code. For example, event.order_id retrieves the value of order_id from the original input.
   
    Valid handler patterns for Node.js functions
    We recommend that you use async/await to declare the function handler instead of using callbacks. Async/await is a concise and readable way to write asynchronous code, without the need for nested callbacks or chaining promises. With async/await, you can write code that reads like synchronous code, while still being asynchronous and non-blocking.
     
      Using async/await (recommended)
      
      The async keyword marks a function as asynchronous, and the await keyword pauses the execution of the function until a Promise is resolved. The handler accepts the following arguments:
      
         
         
      
          event: Contains the input data passed to your function.
        
          context: Contains information about the invocation, function, and execution environment. For more information, see Using the Lambda context object to retrieve Node.js function information.
        
      Here are the valid signatures for the async/await pattern:
       
          
          
       export const handler = async (event) => { };export const handler = async (event, context) => { };
      NoteUse a local integrated development environment (IDE) or text editor to write your TypeScript function code. You can’t create TypeScript code on the Lambda console.
     
     
      Using callbacks
      Callback handlers must use the event, context, and callback arguments. Example:
      export const handler = (event, context, callback) => { };
      The callback function expects an Error and a response, which must be JSON-serializable. The function continues to execute until the event loop is empty or the function times out. The response isn't sent to the invoker until all event loop tasks are finished. If the function times out, an error is returned instead. You can configure the runtime to send the response immediately by setting context.callbackWaitsForEmptyEventLoop to false.
      Example  – HTTP request with callbackThe following example function checks a URL and returns the status code to the invoker.import https from "https";
let url = "https://aws.amazon.com/";

export const handler = (event, context, callback) => {
  https.get(url, (res) => {
    callback(null, res.statusCode);
  }).on("error", (e) => {
    callback(Error(e));
  });
};
     
   
    Using the SDK for JavaScript v3 in your handler
    Often, you’ll use Lambda functions to interact with or make updates to other AWS resources. The simplest way to interface with these resources is to use the AWS SDK for JavaScript. All supported Lambda Node.js runtimes include the SDK for JavaScript version 3. However, we strongly recommend that you include the AWS SDK clients that you need in your deployment package. This maximizes backward compatibility during future Lambda runtime updates. Only rely on the runtime-provided SDK when you can't include additional packages (for example, when using the Lambda console code editor or inline code in an AWS CloudFormation template).
    To add SDK dependencies to your function, use the npm install command for the specific SDK clients that you need. In the example code, we used the Amazon S3 client. Add this dependency by running the following command in the directory that contains your package.json file:
npm install @aws-sdk/client-s3
    In the function code, import the client and commands that you need, as the example function demonstrates:
    import { S3Client, PutObjectCommand } from '@aws-sdk/client-s3';
    Then, initialize an Amazon S3 client:
    const s3Client = new S3Client();
    
    In this example, we initialized our Amazon S3 client outside of the main handler function to avoid having to initialize it every time we invoke our function. After you initialize your SDK client, you can then use it to make API calls for that AWS service. The example code calls the Amazon S3 PutObject API action as follows:
    const command = new PutObjectCommand({
    Bucket: bucketName,
    Key: key,
    Body: receiptContent
});
   
    Accessing environment variables
    In your handler code, you can reference any environment variables by using process.env. In this example, we reference the defined RECEIPT_BUCKET environment variable using the following lines of code:
    // Access environment variables
const bucketName = process.env.RECEIPT_BUCKET;
if (!bucketName) {
    throw new Error('RECEIPT_BUCKET environment variable is not set');
}
   
    Using global state
    Lambda runs your static code during the initialization phase before invoking your function for the first time. Resources created during initialization stay in memory between invocations, so you can avoid having to create them every time you invoke your function.
In the example code, the S3 client initialization code is outside the handler. The runtime initializes the client before the function handles its first event, and the client remains available for reuse across all invocations.
   
    Code best practices for Node.js Lambda functions
    
    Follow these guidelines when building Lambda functions:
    
       
       
       
       
    
        Separate the Lambda handler from your core logic. This allows you to make a more unit-testable function.
      
        Control the dependencies in your function's deployment package.  The AWS Lambda execution environment contains a number of libraries. For the Node.js and Python runtimes, these include the AWS SDKs. To enable the latest set of features and security updates, Lambda will periodically update these libraries. These updates may introduce subtle changes to the behavior of your Lambda function. To have full control of the dependencies your function uses, package all of your dependencies with your deployment package. 
      
        Minimize the complexity of your dependencies. Prefer simpler frameworks that load quickly on execution environment startup.
      
        Minimize your deployment package size to its runtime necessities.  This will reduce the amount of time that it takes for your deployment package to be downloaded and unpacked ahead of invocation.
      
    
 
 
 
     
     
     

      Take advantage of execution environment reuse to improve the performance of your
        function. Initialize SDK clients and database connections outside of the function handler, and
        cache static assets locally in the /tmp directory. Subsequent invocations processed by
        the same instance of your function can reuse these resources. This saves cost by reducing function run time.
      To avoid potential data leaks across invocations, don’t use the execution environment to store user data,
        events, or other information with security implications. If your function relies on a mutable state that can’t
        be stored in memory within the handler, consider creating a separate function or separate versions of a
        function for each user.
    
Use a keep-alive directive to maintain persistent connections. Lambda purges idle connections over time. 
Attempting to reuse an idle connection when invoking a function will result in a connection error. To maintain your persistent connection, use the 
keep-alive directive associated with your runtime. 
For an example, see Reusing Connections with Keep-Alive in Node.js.

Use environment variables to pass operational parameters to your function. For example, if
        you are writing to an Amazon S3 bucket, instead of hard-coding the bucket name you are writing to, configure the
        bucket name as an environment variable.

      Avoid using recursive invocations in your Lambda function, where the function
        invokes itself or initiates a process that may invoke the function again. This could lead to unintended volume of
        function invocations and escalated costs. If you see an unintended volume of invocations, set the function reserved concurrency
        to 0 immediately to throttle all invocations to the function, while you update the
        code.
    
      Do not use non-documented, non-public APIs in your Lambda function code.
        For AWS Lambda managed runtimes, Lambda periodically applies security and functional updates to Lambda's internal APIs.
        These internal API updates may be backwards-incompatible, leading to unintended consequences such as invocation
        failures if your function has a dependency on these non-public APIs. See
        the API reference for a list of
        publicly available APIs.
    
      Write idempotent code. Writing idempotent code for your functions ensures that
        duplicate events are handled the same way. Your code should properly validate events and gracefully handle
        duplicate events. For more information, see
        How do I make
          my Lambda function idempotent?.
    
  Document ConventionsBuilding with Node.jsDeploy .zip file archivesDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideSet up your projectExample functionHandler naming conventionsInput event objectValid handler patternsUsing the SDK for JavaScriptAccessing environment variablesUsing global stateBest practicesDefine Lambda function handler in Node.jsThe Lambda function handler is the method in your function code that processes events. When your function is
  invoked, Lambda runs the handler method. Your function runs until the handler returns a response, exits, or times out.This page describes how to work with Lambda function handlers in Node.js, including options for project
    setup, naming conventions, and best practices. This page also includes an example of a Node.js Lambda
    function that takes in information about an order, produces a text file receipt, and puts this file
    in an Amazon Simple Storage Service (Amazon S3) bucket. For information about how to deploy your function after writing it, see
    Deploy Node.js Lambda functions with .zip file archives or Deploy Node.js Lambda functions with container images.TopicsSetting up your Node.js handler projectExample Node.js Lambda function codeHandler naming conventionsDefining and accessing the input event objectValid handler patterns for Node.js functionsUsing the SDK for JavaScript v3 in your handlerAccessing environment variablesUsing global stateCode best practices for Node.js Lambda functions
    Setting up your Node.js handler project
    There are multiple ways to initialize a Node.js Lambda project. For example, you can create a standard Node.js project using npm, create an AWS SAM application, or create an AWS CDK application.
    To create the project using npm:
    npm init
    This command initializes your project and generates a package.json file that manages your project's metadata and dependencies.
    Your function code lives in a .js or .mjs JavaScript file. In the following example, we name this file index.mjs because it uses an ES module handler. Lambda supports both ES module and CommonJS handlers. For more information, see Designating a function handler as an ES module.
    A typical Node.js Lambda function project follows this general structure:
    /project-root
  ├── index.mjs — Contains main handler
  ├── package.json — Project metadata and dependencies
  ├── package-lock.json — Dependency lock file
  └── node_modules/ — Installed dependencies
   
    Example Node.js Lambda function code
    The following example Lambda function code takes in information about an order,
      produces a text file receipt, and puts this file in an Amazon S3 bucket.
    NoteThis example uses an ES module handler. Lambda supports both ES module and CommonJS handlers. For more information, see Designating a function handler as an ES module.
    Example index.mjs Lambda functionimport { S3Client, PutObjectCommand } from '@aws-sdk/client-s3';

// Initialize the S3 client outside the handler for reuse
const s3Client = new S3Client();

/**
 * Lambda handler for processing orders and storing receipts in S3.
 * @param {Object} event - Input event containing order details
 * @param {string} event.order_id - The unique identifier for the order
 * @param {number} event.amount - The order amount
 * @param {string} event.item - The item purchased
 * @returns {Promise<string>} Success message
 */
export const handler = async(event) => {
    try {
        // Access environment variables
        const bucketName = process.env.RECEIPT_BUCKET;
        if (!bucketName) {
            throw new Error('RECEIPT_BUCKET environment variable is not set');
        }

        // Create the receipt content and key destination
        const receiptContent = `OrderID: ${event.order_id}\nAmount: $${event.amount.toFixed(2)}\nItem: ${event.item}`;
        const key = `receipts/${event.order_id}.txt`;

        // Upload the receipt to S3
        await uploadReceiptToS3(bucketName, key, receiptContent);

        console.log(`Successfully processed order ${event.order_id} and stored receipt in S3 bucket ${bucketName}`);
        return 'Success';
    } catch (error) {
        console.error(`Failed to process order: ${error.message}`);
        throw error;
    }
};

/**
 * Helper function to upload receipt to S3
 * @param {string} bucketName - The S3 bucket name
 * @param {string} key - The S3 object key
 * @param {string} receiptContent - The content to upload
 * @returns {Promise<void>}
 */
async function uploadReceiptToS3(bucketName, key, receiptContent) {
    try {
        const command = new PutObjectCommand({
            Bucket: bucketName,
            Key: key,
            Body: receiptContent
        });

        await s3Client.send(command);
    } catch (error) {
        throw new Error(`Failed to upload receipt to S3: ${error.message}`);
    }
}
    This index.mjs file contains the following sections of code:
    
       
       
       
       
       
    
        import block: Use this block to include libraries that your Lambda function requires, such as AWS SDK clients.
      
        const s3Client declaration: This initializes an Amazon S3 client outside of the handler function. This causes Lambda to run this code during the initialization phase, and the client is preserved for reuse across multiple invocations.
      
        JSDoc comment block: Define the input and output types for your handler using JSDoc annotations.
      
        export const handler: This is the main handler function that Lambda invokes. When deploying your function, specify index.handler for the Handler property. The value of the Handler property is the file name and the name of the exported handler method, separated by a dot.
      
        uploadReceiptToS3 function: This is a helper function that's referenced by the main handler function.
      
    
    For this function to work properly, its  execution role must allow the s3:PutObject action. Also, ensure that you define the RECEIPT_BUCKET environment variable. After a successful invocation, the Amazon S3 bucket should contain a receipt file.
   
    Handler naming conventions
    When you configure a function, the value of the Handler setting is
      the file name and the name of the exported handler method, separated by a dot. The default for functions created in the console and for
      examples in this guide is index.handler. This indicates the handler method that's exported
      from the index.js or index.mjs file.
    If you create a function in the console using a different file name or function handler name, you must edit 
      the default handler name.
    To change the function handler name (console)
        Open the Functions page of the Lambda console and choose your function.
      
        Choose the Code tab.
      
        Scroll down to the Runtime settings pane and choose Edit.
      
        In Handler, enter the new name for your function handler.
      
        Choose Save.
      

   
    Defining and accessing the input event object
    
    JSON is the most common and standard input format for Lambda functions. In this example,
      the function expects an input similar to the following:
    {
    "order_id": "12345",
    "amount": 199.99,
    "item": "Wireless Headphones"
}
    When working with Lambda functions in Node.js, you can define the expected shape of the input event using JSDoc annotations. In this example, we define the input structure in the handler's JSDoc comment:
    /**
 * Lambda handler for processing orders and storing receipts in S3.
 * @param {Object} event - Input event containing order details
 * @param {string} event.order_id - The unique identifier for the order
 * @param {number} event.amount - The order amount
 * @param {string} event.item - The item purchased
 * @returns {Promise<string>} Success message
 */
    After you define these types in your JSDoc comment, you can access the fields of the event object directly in your code. For example, event.order_id retrieves the value of order_id from the original input.
   
    Valid handler patterns for Node.js functions
    We recommend that you use async/await to declare the function handler instead of using callbacks. Async/await is a concise and readable way to write asynchronous code, without the need for nested callbacks or chaining promises. With async/await, you can write code that reads like synchronous code, while still being asynchronous and non-blocking.
     
      Using async/await (recommended)
      
      The async keyword marks a function as asynchronous, and the await keyword pauses the execution of the function until a Promise is resolved. The handler accepts the following arguments:
      
         
         
      
          event: Contains the input data passed to your function.
        
          context: Contains information about the invocation, function, and execution environment. For more information, see Using the Lambda context object to retrieve Node.js function information.
        
      Here are the valid signatures for the async/await pattern:
       
          
          
       export const handler = async (event) => { };export const handler = async (event, context) => { };
      NoteUse a local integrated development environment (IDE) or text editor to write your TypeScript function code. You can’t create TypeScript code on the Lambda console.
     
     
      Using callbacks
      Callback handlers must use the event, context, and callback arguments. Example:
      export const handler = (event, context, callback) => { };
      The callback function expects an Error and a response, which must be JSON-serializable. The function continues to execute until the event loop is empty or the function times out. The response isn't sent to the invoker until all event loop tasks are finished. If the function times out, an error is returned instead. You can configure the runtime to send the response immediately by setting context.callbackWaitsForEmptyEventLoop to false.
      Example  – HTTP request with callbackThe following example function checks a URL and returns the status code to the invoker.import https from "https";
let url = "https://aws.amazon.com/";

export const handler = (event, context, callback) => {
  https.get(url, (res) => {
    callback(null, res.statusCode);
  }).on("error", (e) => {
    callback(Error(e));
  });
};
     
   
    Using the SDK for JavaScript v3 in your handler
    Often, you’ll use Lambda functions to interact with or make updates to other AWS resources. The simplest way to interface with these resources is to use the AWS SDK for JavaScript. All supported Lambda Node.js runtimes include the SDK for JavaScript version 3. However, we strongly recommend that you include the AWS SDK clients that you need in your deployment package. This maximizes backward compatibility during future Lambda runtime updates. Only rely on the runtime-provided SDK when you can't include additional packages (for example, when using the Lambda console code editor or inline code in an AWS CloudFormation template).
    To add SDK dependencies to your function, use the npm install command for the specific SDK clients that you need. In the example code, we used the Amazon S3 client. Add this dependency by running the following command in the directory that contains your package.json file:
npm install @aws-sdk/client-s3
    In the function code, import the client and commands that you need, as the example function demonstrates:
    import { S3Client, PutObjectCommand } from '@aws-sdk/client-s3';
    Then, initialize an Amazon S3 client:
    const s3Client = new S3Client();
    
    In this example, we initialized our Amazon S3 client outside of the main handler function to avoid having to initialize it every time we invoke our function. After you initialize your SDK client, you can then use it to make API calls for that AWS service. The example code calls the Amazon S3 PutObject API action as follows:
    const command = new PutObjectCommand({
    Bucket: bucketName,
    Key: key,
    Body: receiptContent
});
   
    Accessing environment variables
    In your handler code, you can reference any environment variables by using process.env. In this example, we reference the defined RECEIPT_BUCKET environment variable using the following lines of code:
    // Access environment variables
const bucketName = process.env.RECEIPT_BUCKET;
if (!bucketName) {
    throw new Error('RECEIPT_BUCKET environment variable is not set');
}
   
    Using global state
    Lambda runs your static code during the initialization phase before invoking your function for the first time. Resources created during initialization stay in memory between invocations, so you can avoid having to create them every time you invoke your function.
In the example code, the S3 client initialization code is outside the handler. The runtime initializes the client before the function handles its first event, and the client remains available for reuse across all invocations.
   
    Code best practices for Node.js Lambda functions
    
    Follow these guidelines when building Lambda functions:
    
       
       
       
       
    
        Separate the Lambda handler from your core logic. This allows you to make a more unit-testable function.
      
        Control the dependencies in your function's deployment package.  The AWS Lambda execution environment contains a number of libraries. For the Node.js and Python runtimes, these include the AWS SDKs. To enable the latest set of features and security updates, Lambda will periodically update these libraries. These updates may introduce subtle changes to the behavior of your Lambda function. To have full control of the dependencies your function uses, package all of your dependencies with your deployment package. 
      
        Minimize the complexity of your dependencies. Prefer simpler frameworks that load quickly on execution environment startup.
      
        Minimize your deployment package size to its runtime necessities.  This will reduce the amount of time that it takes for your deployment package to be downloaded and unpacked ahead of invocation.
      
    
 
 
 
     
     
     

      Take advantage of execution environment reuse to improve the performance of your
        function. Initialize SDK clients and database connections outside of the function handler, and
        cache static assets locally in the /tmp directory. Subsequent invocations processed by
        the same instance of your function can reuse these resources. This saves cost by reducing function run time.
      To avoid potential data leaks across invocations, don’t use the execution environment to store user data,
        events, or other information with security implications. If your function relies on a mutable state that can’t
        be stored in memory within the handler, consider creating a separate function or separate versions of a
        function for each user.
    
Use a keep-alive directive to maintain persistent connections. Lambda purges idle connections over time. 
Attempting to reuse an idle connection when invoking a function will result in a connection error. To maintain your persistent connection, use the 
keep-alive directive associated with your runtime. 
For an example, see Reusing Connections with Keep-Alive in Node.js.

Use environment variables to pass operational parameters to your function. For example, if
        you are writing to an Amazon S3 bucket, instead of hard-coding the bucket name you are writing to, configure the
        bucket name as an environment variable.

      Avoid using recursive invocations in your Lambda function, where the function
        invokes itself or initiates a process that may invoke the function again. This could lead to unintended volume of
        function invocations and escalated costs. If you see an unintended volume of invocations, set the function reserved concurrency
        to 0 immediately to throttle all invocations to the function, while you update the
        code.
    
      Do not use non-documented, non-public APIs in your Lambda function code.
        For AWS Lambda managed runtimes, Lambda periodically applies security and functional updates to Lambda's internal APIs.
        These internal API updates may be backwards-incompatible, leading to unintended consequences such as invocation
        failures if your function has a dependency on these non-public APIs. See
        the API reference for a list of
        publicly available APIs.
    
      Write idempotent code. Writing idempotent code for your functions ensures that
        duplicate events are handled the same way. Your code should properly validate events and gracefully handle
        duplicate events. For more information, see
        How do I make
          my Lambda function idempotent?.
    
  Document ConventionsBuilding with Node.jsDeploy .zip file archivesDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideSet up your projectExample functionHandler naming conventionsInput event objectValid handler patternsUsing the SDK for JavaScriptAccessing environment variablesUsing global stateBest practicesDefine Lambda function handler in Node.jsThe Lambda function handler is the method in your function code that processes events. When your function is
  invoked, Lambda runs the handler method. Your function runs until the handler returns a response, exits, or times out.This page describes how to work with Lambda function handlers in Node.js, including options for project
    setup, naming conventions, and best practices. This page also includes an example of a Node.js Lambda
    function that takes in information about an order, produces a text file receipt, and puts this file
    in an Amazon Simple Storage Service (Amazon S3) bucket. For information about how to deploy your function after writing it, see
    Deploy Node.js Lambda functions with .zip file archives or Deploy Node.js Lambda functions with container images.TopicsSetting up your Node.js handler projectExample Node.js Lambda function codeHandler naming conventionsDefining and accessing the input event objectValid handler patterns for Node.js functionsUsing the SDK for JavaScript v3 in your handlerAccessing environment variablesUsing global stateCode best practices for Node.js Lambda functions
    Setting up your Node.js handler project
    There are multiple ways to initialize a Node.js Lambda project. For example, you can create a standard Node.js project using npm, create an AWS SAM application, or create an AWS CDK application.
    To create the project using npm:
    npm init
    This command initializes your project and generates a package.json file that manages your project's metadata and dependencies.
    Your function code lives in a .js or .mjs JavaScript file. In the following example, we name this file index.mjs because it uses an ES module handler. Lambda supports both ES module and CommonJS handlers. For more information, see Designating a function handler as an ES module.
    A typical Node.js Lambda function project follows this general structure:
    /project-root
  ├── index.mjs — Contains main handler
  ├── package.json — Project metadata and dependencies
  ├── package-lock.json — Dependency lock file
  └── node_modules/ — Installed dependencies
   
    Example Node.js Lambda function code
    The following example Lambda function code takes in information about an order,
      produces a text file receipt, and puts this file in an Amazon S3 bucket.
    NoteThis example uses an ES module handler. Lambda supports both ES module and CommonJS handlers. For more information, see Designating a function handler as an ES module.
    Example index.mjs Lambda functionimport { S3Client, PutObjectCommand } from '@aws-sdk/client-s3';

// Initialize the S3 client outside the handler for reuse
const s3Client = new S3Client();

/**
 * Lambda handler for processing orders and storing receipts in S3.
 * @param {Object} event - Input event containing order details
 * @param {string} event.order_id - The unique identifier for the order
 * @param {number} event.amount - The order amount
 * @param {string} event.item - The item purchased
 * @returns {Promise<string>} Success message
 */
export const handler = async(event) => {
    try {
        // Access environment variables
        const bucketName = process.env.RECEIPT_BUCKET;
        if (!bucketName) {
            throw new Error('RECEIPT_BUCKET environment variable is not set');
        }

        // Create the receipt content and key destination
        const receiptContent = `OrderID: ${event.order_id}\nAmount: $${event.amount.toFixed(2)}\nItem: ${event.item}`;
        const key = `receipts/${event.order_id}.txt`;

        // Upload the receipt to S3
        await uploadReceiptToS3(bucketName, key, receiptContent);

        console.log(`Successfully processed order ${event.order_id} and stored receipt in S3 bucket ${bucketName}`);
        return 'Success';
    } catch (error) {
        console.error(`Failed to process order: ${error.message}`);
        throw error;
    }
};

/**
 * Helper function to upload receipt to S3
 * @param {string} bucketName - The S3 bucket name
 * @param {string} key - The S3 object key
 * @param {string} receiptContent - The content to upload
 * @returns {Promise<void>}
 */
async function uploadReceiptToS3(bucketName, key, receiptContent) {
    try {
        const command = new PutObjectCommand({
            Bucket: bucketName,
            Key: key,
            Body: receiptContent
        });

        await s3Client.send(command);
    } catch (error) {
        throw new Error(`Failed to upload receipt to S3: ${error.message}`);
    }
}
    This index.mjs file contains the following sections of code:
    
       
       
       
       
       
    
        import block: Use this block to include libraries that your Lambda function requires, such as AWS SDK clients.
      
        const s3Client declaration: This initializes an Amazon S3 client outside of the handler function. This causes Lambda to run this code during the initialization phase, and the client is preserved for reuse across multiple invocations.
      
        JSDoc comment block: Define the input and output types for your handler using JSDoc annotations.
      
        export const handler: This is the main handler function that Lambda invokes. When deploying your function, specify index.handler for the Handler property. The value of the Handler property is the file name and the name of the exported handler method, separated by a dot.
      
        uploadReceiptToS3 function: This is a helper function that's referenced by the main handler function.
      
    
    For this function to work properly, its  execution role must allow the s3:PutObject action. Also, ensure that you define the RECEIPT_BUCKET environment variable. After a successful invocation, the Amazon S3 bucket should contain a receipt file.
   
    Handler naming conventions
    When you configure a function, the value of the Handler setting is
      the file name and the name of the exported handler method, separated by a dot. The default for functions created in the console and for
      examples in this guide is index.handler. This indicates the handler method that's exported
      from the index.js or index.mjs file.
    If you create a function in the console using a different file name or function handler name, you must edit 
      the default handler name.
    To change the function handler name (console)
        Open the Functions page of the Lambda console and choose your function.
      
        Choose the Code tab.
      
        Scroll down to the Runtime settings pane and choose Edit.
      
        In Handler, enter the new name for your function handler.
      
        Choose Save.
      

   
    Defining and accessing the input event object
    
    JSON is the most common and standard input format for Lambda functions. In this example,
      the function expects an input similar to the following:
    {
    "order_id": "12345",
    "amount": 199.99,
    "item": "Wireless Headphones"
}
    When working with Lambda functions in Node.js, you can define the expected shape of the input event using JSDoc annotations. In this example, we define the input structure in the handler's JSDoc comment:
    /**
 * Lambda handler for processing orders and storing receipts in S3.
 * @param {Object} event - Input event containing order details
 * @param {string} event.order_id - The unique identifier for the order
 * @param {number} event.amount - The order amount
 * @param {string} event.item - The item purchased
 * @returns {Promise<string>} Success message
 */
    After you define these types in your JSDoc comment, you can access the fields of the event object directly in your code. For example, event.order_id retrieves the value of order_id from the original input.
   
    Valid handler patterns for Node.js functions
    We recommend that you use async/await to declare the function handler instead of using callbacks. Async/await is a concise and readable way to write asynchronous code, without the need for nested callbacks or chaining promises. With async/await, you can write code that reads like synchronous code, while still being asynchronous and non-blocking.
     
      Using async/await (recommended)
      
      The async keyword marks a function as asynchronous, and the await keyword pauses the execution of the function until a Promise is resolved. The handler accepts the following arguments:
      
         
         
      
          event: Contains the input data passed to your function.
        
          context: Contains information about the invocation, function, and execution environment. For more information, see Using the Lambda context object to retrieve Node.js function information.
        
      Here are the valid signatures for the async/await pattern:
       
          
          
       export const handler = async (event) => { };export const handler = async (event, context) => { };
      NoteUse a local integrated development environment (IDE) or text editor to write your TypeScript function code. You can’t create TypeScript code on the Lambda console.
     
     
      Using callbacks
      Callback handlers must use the event, context, and callback arguments. Example:
      export const handler = (event, context, callback) => { };
      The callback function expects an Error and a response, which must be JSON-serializable. The function continues to execute until the event loop is empty or the function times out. The response isn't sent to the invoker until all event loop tasks are finished. If the function times out, an error is returned instead. You can configure the runtime to send the response immediately by setting context.callbackWaitsForEmptyEventLoop to false.
      Example  – HTTP request with callbackThe following example function checks a URL and returns the status code to the invoker.import https from "https";
let url = "https://aws.amazon.com/";

export const handler = (event, context, callback) => {
  https.get(url, (res) => {
    callback(null, res.statusCode);
  }).on("error", (e) => {
    callback(Error(e));
  });
};
     
   
    Using the SDK for JavaScript v3 in your handler
    Often, you’ll use Lambda functions to interact with or make updates to other AWS resources. The simplest way to interface with these resources is to use the AWS SDK for JavaScript. All supported Lambda Node.js runtimes include the SDK for JavaScript version 3. However, we strongly recommend that you include the AWS SDK clients that you need in your deployment package. This maximizes backward compatibility during future Lambda runtime updates. Only rely on the runtime-provided SDK when you can't include additional packages (for example, when using the Lambda console code editor or inline code in an AWS CloudFormation template).
    To add SDK dependencies to your function, use the npm install command for the specific SDK clients that you need. In the example code, we used the Amazon S3 client. Add this dependency by running the following command in the directory that contains your package.json file:
npm install @aws-sdk/client-s3
    In the function code, import the client and commands that you need, as the example function demonstrates:
    import { S3Client, PutObjectCommand } from '@aws-sdk/client-s3';
    Then, initialize an Amazon S3 client:
    const s3Client = new S3Client();
    
    In this example, we initialized our Amazon S3 client outside of the main handler function to avoid having to initialize it every time we invoke our function. After you initialize your SDK client, you can then use it to make API calls for that AWS service. The example code calls the Amazon S3 PutObject API action as follows:
    const command = new PutObjectCommand({
    Bucket: bucketName,
    Key: key,
    Body: receiptContent
});
   
    Accessing environment variables
    In your handler code, you can reference any environment variables by using process.env. In this example, we reference the defined RECEIPT_BUCKET environment variable using the following lines of code:
    // Access environment variables
const bucketName = process.env.RECEIPT_BUCKET;
if (!bucketName) {
    throw new Error('RECEIPT_BUCKET environment variable is not set');
}
   
    Using global state
    Lambda runs your static code during the initialization phase before invoking your function for the first time. Resources created during initialization stay in memory between invocations, so you can avoid having to create them every time you invoke your function.
In the example code, the S3 client initialization code is outside the handler. The runtime initializes the client before the function handles its first event, and the client remains available for reuse across all invocations.
   
    Code best practices for Node.js Lambda functions
    
    Follow these guidelines when building Lambda functions:
    
       
       
       
       
    
        Separate the Lambda handler from your core logic. This allows you to make a more unit-testable function.
      
        Control the dependencies in your function's deployment package.  The AWS Lambda execution environment contains a number of libraries. For the Node.js and Python runtimes, these include the AWS SDKs. To enable the latest set of features and security updates, Lambda will periodically update these libraries. These updates may introduce subtle changes to the behavior of your Lambda function. To have full control of the dependencies your function uses, package all of your dependencies with your deployment package. 
      
        Minimize the complexity of your dependencies. Prefer simpler frameworks that load quickly on execution environment startup.
      
        Minimize your deployment package size to its runtime necessities.  This will reduce the amount of time that it takes for your deployment package to be downloaded and unpacked ahead of invocation.
      
    
 
 
 
     
     
     

      Take advantage of execution environment reuse to improve the performance of your
        function. Initialize SDK clients and database connections outside of the function handler, and
        cache static assets locally in the /tmp directory. Subsequent invocations processed by
        the same instance of your function can reuse these resources. This saves cost by reducing function run time.
      To avoid potential data leaks across invocations, don’t use the execution environment to store user data,
        events, or other information with security implications. If your function relies on a mutable state that can’t
        be stored in memory within the handler, consider creating a separate function or separate versions of a
        function for each user.
    
Use a keep-alive directive to maintain persistent connections. Lambda purges idle connections over time. 
Attempting to reuse an idle connection when invoking a function will result in a connection error. To maintain your persistent connection, use the 
keep-alive directive associated with your runtime. 
For an example, see Reusing Connections with Keep-Alive in Node.js.

Use environment variables to pass operational parameters to your function. For example, if
        you are writing to an Amazon S3 bucket, instead of hard-coding the bucket name you are writing to, configure the
        bucket name as an environment variable.

      Avoid using recursive invocations in your Lambda function, where the function
        invokes itself or initiates a process that may invoke the function again. This could lead to unintended volume of
        function invocations and escalated costs. If you see an unintended volume of invocations, set the function reserved concurrency
        to 0 immediately to throttle all invocations to the function, while you update the
        code.
    
      Do not use non-documented, non-public APIs in your Lambda function code.
        For AWS Lambda managed runtimes, Lambda periodically applies security and functional updates to Lambda's internal APIs.
        These internal API updates may be backwards-incompatible, leading to unintended consequences such as invocation
        failures if your function has a dependency on these non-public APIs. See
        the API reference for a list of
        publicly available APIs.
    
      Write idempotent code. Writing idempotent code for your functions ensures that
        duplicate events are handled the same way. Your code should properly validate events and gracefully handle
        duplicate events. For more information, see
        How do I make
          my Lambda function idempotent?.
    
  Document ConventionsBuilding with Node.jsDeploy .zip file archivesDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideSet up your projectExample functionHandler naming conventionsInput event objectValid handler patternsUsing the SDK for JavaScriptAccessing environment variablesUsing global stateBest practicesDefine Lambda function handler in Node.jsThe Lambda function handler is the method in your function code that processes events. When your function is
  invoked, Lambda runs the handler method. Your function runs until the handler returns a response, exits, or times out.This page describes how to work with Lambda function handlers in Node.js, including options for project
    setup, naming conventions, and best practices. This page also includes an example of a Node.js Lambda
    function that takes in information about an order, produces a text file receipt, and puts this file
    in an Amazon Simple Storage Service (Amazon S3) bucket. For information about how to deploy your function after writing it, see
    Deploy Node.js Lambda functions with .zip file archives or Deploy Node.js Lambda functions with container images.TopicsSetting up your Node.js handler projectExample Node.js Lambda function codeHandler naming conventionsDefining and accessing the input event objectValid handler patterns for Node.js functionsUsing the SDK for JavaScript v3 in your handlerAccessing environment variablesUsing global stateCode best practices for Node.js Lambda functions
    Setting up your Node.js handler project
    There are multiple ways to initialize a Node.js Lambda project. For example, you can create a standard Node.js project using npm, create an AWS SAM application, or create an AWS CDK application.
    To create the project using npm:
    npm init
    This command initializes your project and generates a package.json file that manages your project's metadata and dependencies.
    Your function code lives in a .js or .mjs JavaScript file. In the following example, we name this file index.mjs because it uses an ES module handler. Lambda supports both ES module and CommonJS handlers. For more information, see Designating a function handler as an ES module.
    A typical Node.js Lambda function project follows this general structure:
    /project-root
  ├── index.mjs — Contains main handler
  ├── package.json — Project metadata and dependencies
  ├── package-lock.json — Dependency lock file
  └── node_modules/ — Installed dependencies
   
    Example Node.js Lambda function code
    The following example Lambda function code takes in information about an order,
      produces a text file receipt, and puts this file in an Amazon S3 bucket.
    NoteThis example uses an ES module handler. Lambda supports both ES module and CommonJS handlers. For more information, see Designating a function handler as an ES module.
    Example index.mjs Lambda functionimport { S3Client, PutObjectCommand } from '@aws-sdk/client-s3';

// Initialize the S3 client outside the handler for reuse
const s3Client = new S3Client();

/**
 * Lambda handler for processing orders and storing receipts in S3.
 * @param {Object} event - Input event containing order details
 * @param {string} event.order_id - The unique identifier for the order
 * @param {number} event.amount - The order amount
 * @param {string} event.item - The item purchased
 * @returns {Promise<string>} Success message
 */
export const handler = async(event) => {
    try {
        // Access environment variables
        const bucketName = process.env.RECEIPT_BUCKET;
        if (!bucketName) {
            throw new Error('RECEIPT_BUCKET environment variable is not set');
        }

        // Create the receipt content and key destination
        const receiptContent = `OrderID: ${event.order_id}\nAmount: $${event.amount.toFixed(2)}\nItem: ${event.item}`;
        const key = `receipts/${event.order_id}.txt`;

        // Upload the receipt to S3
        await uploadReceiptToS3(bucketName, key, receiptContent);

        console.log(`Successfully processed order ${event.order_id} and stored receipt in S3 bucket ${bucketName}`);
        return 'Success';
    } catch (error) {
        console.error(`Failed to process order: ${error.message}`);
        throw error;
    }
};

/**
 * Helper function to upload receipt to S3
 * @param {string} bucketName - The S3 bucket name
 * @param {string} key - The S3 object key
 * @param {string} receiptContent - The content to upload
 * @returns {Promise<void>}
 */
async function uploadReceiptToS3(bucketName, key, receiptContent) {
    try {
        const command = new PutObjectCommand({
            Bucket: bucketName,
            Key: key,
            Body: receiptContent
        });

        await s3Client.send(command);
    } catch (error) {
        throw new Error(`Failed to upload receipt to S3: ${error.message}`);
    }
}
    This index.mjs file contains the following sections of code:
    
       
       
       
       
       
    
        import block: Use this block to include libraries that your Lambda function requires, such as AWS SDK clients.
      
        const s3Client declaration: This initializes an Amazon S3 client outside of the handler function. This causes Lambda to run this code during the initialization phase, and the client is preserved for reuse across multiple invocations.
      
        JSDoc comment block: Define the input and output types for your handler using JSDoc annotations.
      
        export const handler: This is the main handler function that Lambda invokes. When deploying your function, specify index.handler for the Handler property. The value of the Handler property is the file name and the name of the exported handler method, separated by a dot.
      
        uploadReceiptToS3 function: This is a helper function that's referenced by the main handler function.
      
    
    For this function to work properly, its  execution role must allow the s3:PutObject action. Also, ensure that you define the RECEIPT_BUCKET environment variable. After a successful invocation, the Amazon S3 bucket should contain a receipt file.
   
    Handler naming conventions
    When you configure a function, the value of the Handler setting is
      the file name and the name of the exported handler method, separated by a dot. The default for functions created in the console and for
      examples in this guide is index.handler. This indicates the handler method that's exported
      from the index.js or index.mjs file.
    If you create a function in the console using a different file name or function handler name, you must edit 
      the default handler name.
    To change the function handler name (console)
        Open the Functions page of the Lambda console and choose your function.
      
        Choose the Code tab.
      
        Scroll down to the Runtime settings pane and choose Edit.
      
        In Handler, enter the new name for your function handler.
      
        Choose Save.
      

   
    Defining and accessing the input event object
    
    JSON is the most common and standard input format for Lambda functions. In this example,
      the function expects an input similar to the following:
    {
    "order_id": "12345",
    "amount": 199.99,
    "item": "Wireless Headphones"
}
    When working with Lambda functions in Node.js, you can define the expected shape of the input event using JSDoc annotations. In this example, we define the input structure in the handler's JSDoc comment:
    /**
 * Lambda handler for processing orders and storing receipts in S3.
 * @param {Object} event - Input event containing order details
 * @param {string} event.order_id - The unique identifier for the order
 * @param {number} event.amount - The order amount
 * @param {string} event.item - The item purchased
 * @returns {Promise<string>} Success message
 */
    After you define these types in your JSDoc comment, you can access the fields of the event object directly in your code. For example, event.order_id retrieves the value of order_id from the original input.
   
    Valid handler patterns for Node.js functions
    We recommend that you use async/await to declare the function handler instead of using callbacks. Async/await is a concise and readable way to write asynchronous code, without the need for nested callbacks or chaining promises. With async/await, you can write code that reads like synchronous code, while still being asynchronous and non-blocking.
     
      Using async/await (recommended)
      
      The async keyword marks a function as asynchronous, and the await keyword pauses the execution of the function until a Promise is resolved. The handler accepts the following arguments:
      
         
         
      
          event: Contains the input data passed to your function.
        
          context: Contains information about the invocation, function, and execution environment. For more information, see Using the Lambda context object to retrieve Node.js function information.
        
      Here are the valid signatures for the async/await pattern:
       
          
          
       export const handler = async (event) => { };export const handler = async (event, context) => { };
      NoteUse a local integrated development environment (IDE) or text editor to write your TypeScript function code. You can’t create TypeScript code on the Lambda console.
     
     
      Using callbacks
      Callback handlers must use the event, context, and callback arguments. Example:
      export const handler = (event, context, callback) => { };
      The callback function expects an Error and a response, which must be JSON-serializable. The function continues to execute until the event loop is empty or the function times out. The response isn't sent to the invoker until all event loop tasks are finished. If the function times out, an error is returned instead. You can configure the runtime to send the response immediately by setting context.callbackWaitsForEmptyEventLoop to false.
      Example  – HTTP request with callbackThe following example function checks a URL and returns the status code to the invoker.import https from "https";
let url = "https://aws.amazon.com/";

export const handler = (event, context, callback) => {
  https.get(url, (res) => {
    callback(null, res.statusCode);
  }).on("error", (e) => {
    callback(Error(e));
  });
};
     
   
    Using the SDK for JavaScript v3 in your handler
    Often, you’ll use Lambda functions to interact with or make updates to other AWS resources. The simplest way to interface with these resources is to use the AWS SDK for JavaScript. All supported Lambda Node.js runtimes include the SDK for JavaScript version 3. However, we strongly recommend that you include the AWS SDK clients that you need in your deployment package. This maximizes backward compatibility during future Lambda runtime updates. Only rely on the runtime-provided SDK when you can't include additional packages (for example, when using the Lambda console code editor or inline code in an AWS CloudFormation template).
    To add SDK dependencies to your function, use the npm install command for the specific SDK clients that you need. In the example code, we used the Amazon S3 client. Add this dependency by running the following command in the directory that contains your package.json file:
npm install @aws-sdk/client-s3
    In the function code, import the client and commands that you need, as the example function demonstrates:
    import { S3Client, PutObjectCommand } from '@aws-sdk/client-s3';
    Then, initialize an Amazon S3 client:
    const s3Client = new S3Client();
    
    In this example, we initialized our Amazon S3 client outside of the main handler function to avoid having to initialize it every time we invoke our function. After you initialize your SDK client, you can then use it to make API calls for that AWS service. The example code calls the Amazon S3 PutObject API action as follows:
    const command = new PutObjectCommand({
    Bucket: bucketName,
    Key: key,
    Body: receiptContent
});
   
    Accessing environment variables
    In your handler code, you can reference any environment variables by using process.env. In this example, we reference the defined RECEIPT_BUCKET environment variable using the following lines of code:
    // Access environment variables
const bucketName = process.env.RECEIPT_BUCKET;
if (!bucketName) {
    throw new Error('RECEIPT_BUCKET environment variable is not set');
}
   
    Using global state
    Lambda runs your static code during the initialization phase before invoking your function for the first time. Resources created during initialization stay in memory between invocations, so you can avoid having to create them every time you invoke your function.
In the example code, the S3 client initialization code is outside the handler. The runtime initializes the client before the function handles its first event, and the client remains available for reuse across all invocations.
   
    Code best practices for Node.js Lambda functions
    
    Follow these guidelines when building Lambda functions:
    
       
       
       
       
    
        Separate the Lambda handler from your core logic. This allows you to make a more unit-testable function.
      
        Control the dependencies in your function's deployment package.  The AWS Lambda execution environment contains a number of libraries. For the Node.js and Python runtimes, these include the AWS SDKs. To enable the latest set of features and security updates, Lambda will periodically update these libraries. These updates may introduce subtle changes to the behavior of your Lambda function. To have full control of the dependencies your function uses, package all of your dependencies with your deployment package. 
      
        Minimize the complexity of your dependencies. Prefer simpler frameworks that load quickly on execution environment startup.
      
        Minimize your deployment package size to its runtime necessities.  This will reduce the amount of time that it takes for your deployment package to be downloaded and unpacked ahead of invocation.
      
    
 
 
 
     
     
     

      Take advantage of execution environment reuse to improve the performance of your
        function. Initialize SDK clients and database connections outside of the function handler, and
        cache static assets locally in the /tmp directory. Subsequent invocations processed by
        the same instance of your function can reuse these resources. This saves cost by reducing function run time.
      To avoid potential data leaks across invocations, don’t use the execution environment to store user data,
        events, or other information with security implications. If your function relies on a mutable state that can’t
        be stored in memory within the handler, consider creating a separate function or separate versions of a
        function for each user.
    
Use a keep-alive directive to maintain persistent connections. Lambda purges idle connections over time. 
Attempting to reuse an idle connection when invoking a function will result in a connection error. To maintain your persistent connection, use the 
keep-alive directive associated with your runtime. 
For an example, see Reusing Connections with Keep-Alive in Node.js.

Use environment variables to pass operational parameters to your function. For example, if
        you are writing to an Amazon S3 bucket, instead of hard-coding the bucket name you are writing to, configure the
        bucket name as an environment variable.

      Avoid using recursive invocations in your Lambda function, where the function
        invokes itself or initiates a process that may invoke the function again. This could lead to unintended volume of
        function invocations and escalated costs. If you see an unintended volume of invocations, set the function reserved concurrency
        to 0 immediately to throttle all invocations to the function, while you update the
        code.
    
      Do not use non-documented, non-public APIs in your Lambda function code.
        For AWS Lambda managed runtimes, Lambda periodically applies security and functional updates to Lambda's internal APIs.
        These internal API updates may be backwards-incompatible, leading to unintended consequences such as invocation
        failures if your function has a dependency on these non-public APIs. See
        the API reference for a list of
        publicly available APIs.
    
      Write idempotent code. Writing idempotent code for your functions ensures that
        duplicate events are handled the same way. Your code should properly validate events and gracefully handle
        duplicate events. For more information, see
        How do I make
          my Lambda function idempotent?.
    
  Document ConventionsBuilding with Node.jsDeploy .zip file archivesDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideSet up your projectExample functionHandler naming conventionsInput event objectValid handler patternsUsing the SDK for JavaScriptAccessing environment variablesUsing global stateBest practicesDefine Lambda function handler in Node.jsThe Lambda function handler is the method in your function code that processes events. When your function is
  invoked, Lambda runs the handler method. Your function runs until the handler returns a response, exits, or times out.This page describes how to work with Lambda function handlers in Node.js, including options for project
    setup, naming conventions, and best practices. This page also includes an example of a Node.js Lambda
    function that takes in information about an order, produces a text file receipt, and puts this file
    in an Amazon Simple Storage Service (Amazon S3) bucket. For information about how to deploy your function after writing it, see
    Deploy Node.js Lambda functions with .zip file archives or Deploy Node.js Lambda functions with container images.TopicsSetting up your Node.js handler projectExample Node.js Lambda function codeHandler naming conventionsDefining and accessing the input event objectValid handler patterns for Node.js functionsUsing the SDK for JavaScript v3 in your handlerAccessing environment variablesUsing global stateCode best practices for Node.js Lambda functions
    Setting up your Node.js handler project
    There are multiple ways to initialize a Node.js Lambda project. For example, you can create a standard Node.js project using npm, create an AWS SAM application, or create an AWS CDK application.
    To create the project using npm:
    npm init
    This command initializes your project and generates a package.json file that manages your project's metadata and dependencies.
    Your function code lives in a .js or .mjs JavaScript file. In the following example, we name this file index.mjs because it uses an ES module handler. Lambda supports both ES module and CommonJS handlers. For more information, see Designating a function handler as an ES module.
    A typical Node.js Lambda function project follows this general structure:
    /project-root
  ├── index.mjs — Contains main handler
  ├── package.json — Project metadata and dependencies
  ├── package-lock.json — Dependency lock file
  └── node_modules/ — Installed dependencies
   
    Example Node.js Lambda function code
    The following example Lambda function code takes in information about an order,
      produces a text file receipt, and puts this file in an Amazon S3 bucket.
    NoteThis example uses an ES module handler. Lambda supports both ES module and CommonJS handlers. For more information, see Designating a function handler as an ES module.
    Example index.mjs Lambda functionimport { S3Client, PutObjectCommand } from '@aws-sdk/client-s3';

// Initialize the S3 client outside the handler for reuse
const s3Client = new S3Client();

/**
 * Lambda handler for processing orders and storing receipts in S3.
 * @param {Object} event - Input event containing order details
 * @param {string} event.order_id - The unique identifier for the order
 * @param {number} event.amount - The order amount
 * @param {string} event.item - The item purchased
 * @returns {Promise<string>} Success message
 */
export const handler = async(event) => {
    try {
        // Access environment variables
        const bucketName = process.env.RECEIPT_BUCKET;
        if (!bucketName) {
            throw new Error('RECEIPT_BUCKET environment variable is not set');
        }

        // Create the receipt content and key destination
        const receiptContent = `OrderID: ${event.order_id}\nAmount: $${event.amount.toFixed(2)}\nItem: ${event.item}`;
        const key = `receipts/${event.order_id}.txt`;

        // Upload the receipt to S3
        await uploadReceiptToS3(bucketName, key, receiptContent);

        console.log(`Successfully processed order ${event.order_id} and stored receipt in S3 bucket ${bucketName}`);
        return 'Success';
    } catch (error) {
        console.error(`Failed to process order: ${error.message}`);
        throw error;
    }
};

/**
 * Helper function to upload receipt to S3
 * @param {string} bucketName - The S3 bucket name
 * @param {string} key - The S3 object key
 * @param {string} receiptContent - The content to upload
 * @returns {Promise<void>}
 */
async function uploadReceiptToS3(bucketName, key, receiptContent) {
    try {
        const command = new PutObjectCommand({
            Bucket: bucketName,
            Key: key,
            Body: receiptContent
        });

        await s3Client.send(command);
    } catch (error) {
        throw new Error(`Failed to upload receipt to S3: ${error.message}`);
    }
}
    This index.mjs file contains the following sections of code:
    
       
       
       
       
       
    
        import block: Use this block to include libraries that your Lambda function requires, such as AWS SDK clients.
      
        const s3Client declaration: This initializes an Amazon S3 client outside of the handler function. This causes Lambda to run this code during the initialization phase, and the client is preserved for reuse across multiple invocations.
      
        JSDoc comment block: Define the input and output types for your handler using JSDoc annotations.
      
        export const handler: This is the main handler function that Lambda invokes. When deploying your function, specify index.handler for the Handler property. The value of the Handler property is the file name and the name of the exported handler method, separated by a dot.
      
        uploadReceiptToS3 function: This is a helper function that's referenced by the main handler function.
      
    
    For this function to work properly, its  execution role must allow the s3:PutObject action. Also, ensure that you define the RECEIPT_BUCKET environment variable. After a successful invocation, the Amazon S3 bucket should contain a receipt file.
   
    Handler naming conventions
    When you configure a function, the value of the Handler setting is
      the file name and the name of the exported handler method, separated by a dot. The default for functions created in the console and for
      examples in this guide is index.handler. This indicates the handler method that's exported
      from the index.js or index.mjs file.
    If you create a function in the console using a different file name or function handler name, you must edit 
      the default handler name.
    To change the function handler name (console)
        Open the Functions page of the Lambda console and choose your function.
      
        Choose the Code tab.
      
        Scroll down to the Runtime settings pane and choose Edit.
      
        In Handler, enter the new name for your function handler.
      
        Choose Save.
      

   
    Defining and accessing the input event object
    
    JSON is the most common and standard input format for Lambda functions. In this example,
      the function expects an input similar to the following:
    {
    "order_id": "12345",
    "amount": 199.99,
    "item": "Wireless Headphones"
}
    When working with Lambda functions in Node.js, you can define the expected shape of the input event using JSDoc annotations. In this example, we define the input structure in the handler's JSDoc comment:
    /**
 * Lambda handler for processing orders and storing receipts in S3.
 * @param {Object} event - Input event containing order details
 * @param {string} event.order_id - The unique identifier for the order
 * @param {number} event.amount - The order amount
 * @param {string} event.item - The item purchased
 * @returns {Promise<string>} Success message
 */
    After you define these types in your JSDoc comment, you can access the fields of the event object directly in your code. For example, event.order_id retrieves the value of order_id from the original input.
   
    Valid handler patterns for Node.js functions
    We recommend that you use async/await to declare the function handler instead of using callbacks. Async/await is a concise and readable way to write asynchronous code, without the need for nested callbacks or chaining promises. With async/await, you can write code that reads like synchronous code, while still being asynchronous and non-blocking.
     
      Using async/await (recommended)
      
      The async keyword marks a function as asynchronous, and the await keyword pauses the execution of the function until a Promise is resolved. The handler accepts the following arguments:
      
         
         
      
          event: Contains the input data passed to your function.
        
          context: Contains information about the invocation, function, and execution environment. For more information, see Using the Lambda context object to retrieve Node.js function information.
        
      Here are the valid signatures for the async/await pattern:
       
          
          
       export const handler = async (event) => { };export const handler = async (event, context) => { };
      NoteUse a local integrated development environment (IDE) or text editor to write your TypeScript function code. You can’t create TypeScript code on the Lambda console.
     
     
      Using callbacks
      Callback handlers must use the event, context, and callback arguments. Example:
      export const handler = (event, context, callback) => { };
      The callback function expects an Error and a response, which must be JSON-serializable. The function continues to execute until the event loop is empty or the function times out. The response isn't sent to the invoker until all event loop tasks are finished. If the function times out, an error is returned instead. You can configure the runtime to send the response immediately by setting context.callbackWaitsForEmptyEventLoop to false.
      Example  – HTTP request with callbackThe following example function checks a URL and returns the status code to the invoker.import https from "https";
let url = "https://aws.amazon.com/";

export const handler = (event, context, callback) => {
  https.get(url, (res) => {
    callback(null, res.statusCode);
  }).on("error", (e) => {
    callback(Error(e));
  });
};
     
   
    Using the SDK for JavaScript v3 in your handler
    Often, you’ll use Lambda functions to interact with or make updates to other AWS resources. The simplest way to interface with these resources is to use the AWS SDK for JavaScript. All supported Lambda Node.js runtimes include the SDK for JavaScript version 3. However, we strongly recommend that you include the AWS SDK clients that you need in your deployment package. This maximizes backward compatibility during future Lambda runtime updates. Only rely on the runtime-provided SDK when you can't include additional packages (for example, when using the Lambda console code editor or inline code in an AWS CloudFormation template).
    To add SDK dependencies to your function, use the npm install command for the specific SDK clients that you need. In the example code, we used the Amazon S3 client. Add this dependency by running the following command in the directory that contains your package.json file:
npm install @aws-sdk/client-s3
    In the function code, import the client and commands that you need, as the example function demonstrates:
    import { S3Client, PutObjectCommand } from '@aws-sdk/client-s3';
    Then, initialize an Amazon S3 client:
    const s3Client = new S3Client();
    
    In this example, we initialized our Amazon S3 client outside of the main handler function to avoid having to initialize it every time we invoke our function. After you initialize your SDK client, you can then use it to make API calls for that AWS service. The example code calls the Amazon S3 PutObject API action as follows:
    const command = new PutObjectCommand({
    Bucket: bucketName,
    Key: key,
    Body: receiptContent
});
   
    Accessing environment variables
    In your handler code, you can reference any environment variables by using process.env. In this example, we reference the defined RECEIPT_BUCKET environment variable using the following lines of code:
    // Access environment variables
const bucketName = process.env.RECEIPT_BUCKET;
if (!bucketName) {
    throw new Error('RECEIPT_BUCKET environment variable is not set');
}
   
    Using global state
    Lambda runs your static code during the initialization phase before invoking your function for the first time. Resources created during initialization stay in memory between invocations, so you can avoid having to create them every time you invoke your function.
In the example code, the S3 client initialization code is outside the handler. The runtime initializes the client before the function handles its first event, and the client remains available for reuse across all invocations.
   
    Code best practices for Node.js Lambda functions
    
    Follow these guidelines when building Lambda functions:
    
       
       
       
       
    
        Separate the Lambda handler from your core logic. This allows you to make a more unit-testable function.
      
        Control the dependencies in your function's deployment package.  The AWS Lambda execution environment contains a number of libraries. For the Node.js and Python runtimes, these include the AWS SDKs. To enable the latest set of features and security updates, Lambda will periodically update these libraries. These updates may introduce subtle changes to the behavior of your Lambda function. To have full control of the dependencies your function uses, package all of your dependencies with your deployment package. 
      
        Minimize the complexity of your dependencies. Prefer simpler frameworks that load quickly on execution environment startup.
      
        Minimize your deployment package size to its runtime necessities.  This will reduce the amount of time that it takes for your deployment package to be downloaded and unpacked ahead of invocation.
      
    
 
 
 
     
     
     

      Take advantage of execution environment reuse to improve the performance of your
        function. Initialize SDK clients and database connections outside of the function handler, and
        cache static assets locally in the /tmp directory. Subsequent invocations processed by
        the same instance of your function can reuse these resources. This saves cost by reducing function run time.
      To avoid potential data leaks across invocations, don’t use the execution environment to store user data,
        events, or other information with security implications. If your function relies on a mutable state that can’t
        be stored in memory within the handler, consider creating a separate function or separate versions of a
        function for each user.
    
Use a keep-alive directive to maintain persistent connections. Lambda purges idle connections over time. 
Attempting to reuse an idle connection when invoking a function will result in a connection error. To maintain your persistent connection, use the 
keep-alive directive associated with your runtime. 
For an example, see Reusing Connections with Keep-Alive in Node.js.

Use environment variables to pass operational parameters to your function. For example, if
        you are writing to an Amazon S3 bucket, instead of hard-coding the bucket name you are writing to, configure the
        bucket name as an environment variable.

      Avoid using recursive invocations in your Lambda function, where the function
        invokes itself or initiates a process that may invoke the function again. This could lead to unintended volume of
        function invocations and escalated costs. If you see an unintended volume of invocations, set the function reserved concurrency
        to 0 immediately to throttle all invocations to the function, while you update the
        code.
    
      Do not use non-documented, non-public APIs in your Lambda function code.
        For AWS Lambda managed runtimes, Lambda periodically applies security and functional updates to Lambda's internal APIs.
        These internal API updates may be backwards-incompatible, leading to unintended consequences such as invocation
        failures if your function has a dependency on these non-public APIs. See
        the API reference for a list of
        publicly available APIs.
    
      Write idempotent code. Writing idempotent code for your functions ensures that
        duplicate events are handled the same way. Your code should properly validate events and gracefully handle
        duplicate events. For more information, see
        How do I make
          my Lambda function idempotent?.
    
  Document ConventionsBuilding with Node.jsDeploy .zip file archivesDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideSet up your projectExample functionHandler naming conventionsInput event objectValid handler patternsUsing the SDK for JavaScriptAccessing environment variablesUsing global stateBest practicesDefine Lambda function handler in Node.jsThe Lambda function handler is the method in your function code that processes events. When your function is
  invoked, Lambda runs the handler method. Your function runs until the handler returns a response, exits, or times out.This page describes how to work with Lambda function handlers in Node.js, including options for project
    setup, naming conventions, and best practices. This page also includes an example of a Node.js Lambda
    function that takes in information about an order, produces a text file receipt, and puts this file
    in an Amazon Simple Storage Service (Amazon S3) bucket. For information about how to deploy your function after writing it, see
    Deploy Node.js Lambda functions with .zip file archives or Deploy Node.js Lambda functions with container images.TopicsSetting up your Node.js handler projectExample Node.js Lambda function codeHandler naming conventionsDefining and accessing the input event objectValid handler patterns for Node.js functionsUsing the SDK for JavaScript v3 in your handlerAccessing environment variablesUsing global stateCode best practices for Node.js Lambda functions
    Setting up your Node.js handler project
    There are multiple ways to initialize a Node.js Lambda project. For example, you can create a standard Node.js project using npm, create an AWS SAM application, or create an AWS CDK application.
    To create the project using npm:
    npm init
    This command initializes your project and generates a package.json file that manages your project's metadata and dependencies.
    Your function code lives in a .js or .mjs JavaScript file. In the following example, we name this file index.mjs because it uses an ES module handler. Lambda supports both ES module and CommonJS handlers. For more information, see Designating a function handler as an ES module.
    A typical Node.js Lambda function project follows this general structure:
    /project-root
  ├── index.mjs — Contains main handler
  ├── package.json — Project metadata and dependencies
  ├── package-lock.json — Dependency lock file
  └── node_modules/ — Installed dependencies
   
    Example Node.js Lambda function code
    The following example Lambda function code takes in information about an order,
      produces a text file receipt, and puts this file in an Amazon S3 bucket.
    NoteThis example uses an ES module handler. Lambda supports both ES module and CommonJS handlers. For more information, see Designating a function handler as an ES module.
    Example index.mjs Lambda functionimport { S3Client, PutObjectCommand } from '@aws-sdk/client-s3';

// Initialize the S3 client outside the handler for reuse
const s3Client = new S3Client();

/**
 * Lambda handler for processing orders and storing receipts in S3.
 * @param {Object} event - Input event containing order details
 * @param {string} event.order_id - The unique identifier for the order
 * @param {number} event.amount - The order amount
 * @param {string} event.item - The item purchased
 * @returns {Promise<string>} Success message
 */
export const handler = async(event) => {
    try {
        // Access environment variables
        const bucketName = process.env.RECEIPT_BUCKET;
        if (!bucketName) {
            throw new Error('RECEIPT_BUCKET environment variable is not set');
        }

        // Create the receipt content and key destination
        const receiptContent = `OrderID: ${event.order_id}\nAmount: $${event.amount.toFixed(2)}\nItem: ${event.item}`;
        const key = `receipts/${event.order_id}.txt`;

        // Upload the receipt to S3
        await uploadReceiptToS3(bucketName, key, receiptContent);

        console.log(`Successfully processed order ${event.order_id} and stored receipt in S3 bucket ${bucketName}`);
        return 'Success';
    } catch (error) {
        console.error(`Failed to process order: ${error.message}`);
        throw error;
    }
};

/**
 * Helper function to upload receipt to S3
 * @param {string} bucketName - The S3 bucket name
 * @param {string} key - The S3 object key
 * @param {string} receiptContent - The content to upload
 * @returns {Promise<void>}
 */
async function uploadReceiptToS3(bucketName, key, receiptContent) {
    try {
        const command = new PutObjectCommand({
            Bucket: bucketName,
            Key: key,
            Body: receiptContent
        });

        await s3Client.send(command);
    } catch (error) {
        throw new Error(`Failed to upload receipt to S3: ${error.message}`);
    }
}
    This index.mjs file contains the following sections of code:
    
       
       
       
       
       
    
        import block: Use this block to include libraries that your Lambda function requires, such as AWS SDK clients.
      
        const s3Client declaration: This initializes an Amazon S3 client outside of the handler function. This causes Lambda to run this code during the initialization phase, and the client is preserved for reuse across multiple invocations.
      
        JSDoc comment block: Define the input and output types for your handler using JSDoc annotations.
      
        export const handler: This is the main handler function that Lambda invokes. When deploying your function, specify index.handler for the Handler property. The value of the Handler property is the file name and the name of the exported handler method, separated by a dot.
      
        uploadReceiptToS3 function: This is a helper function that's referenced by the main handler function.
      
    
    For this function to work properly, its  execution role must allow the s3:PutObject action. Also, ensure that you define the RECEIPT_BUCKET environment variable. After a successful invocation, the Amazon S3 bucket should contain a receipt file.
   
    Handler naming conventions
    When you configure a function, the value of the Handler setting is
      the file name and the name of the exported handler method, separated by a dot. The default for functions created in the console and for
      examples in this guide is index.handler. This indicates the handler method that's exported
      from the index.js or index.mjs file.
    If you create a function in the console using a different file name or function handler name, you must edit 
      the default handler name.
    To change the function handler name (console)
        Open the Functions page of the Lambda console and choose your function.
      
        Choose the Code tab.
      
        Scroll down to the Runtime settings pane and choose Edit.
      
        In Handler, enter the new name for your function handler.
      
        Choose Save.
      

   
    Defining and accessing the input event object
    
    JSON is the most common and standard input format for Lambda functions. In this example,
      the function expects an input similar to the following:
    {
    "order_id": "12345",
    "amount": 199.99,
    "item": "Wireless Headphones"
}
    When working with Lambda functions in Node.js, you can define the expected shape of the input event using JSDoc annotations. In this example, we define the input structure in the handler's JSDoc comment:
    /**
 * Lambda handler for processing orders and storing receipts in S3.
 * @param {Object} event - Input event containing order details
 * @param {string} event.order_id - The unique identifier for the order
 * @param {number} event.amount - The order amount
 * @param {string} event.item - The item purchased
 * @returns {Promise<string>} Success message
 */
    After you define these types in your JSDoc comment, you can access the fields of the event object directly in your code. For example, event.order_id retrieves the value of order_id from the original input.
   
    Valid handler patterns for Node.js functions
    We recommend that you use async/await to declare the function handler instead of using callbacks. Async/await is a concise and readable way to write asynchronous code, without the need for nested callbacks or chaining promises. With async/await, you can write code that reads like synchronous code, while still being asynchronous and non-blocking.
     
      Using async/await (recommended)
      
      The async keyword marks a function as asynchronous, and the await keyword pauses the execution of the function until a Promise is resolved. The handler accepts the following arguments:
      
         
         
      
          event: Contains the input data passed to your function.
        
          context: Contains information about the invocation, function, and execution environment. For more information, see Using the Lambda context object to retrieve Node.js function information.
        
      Here are the valid signatures for the async/await pattern:
       
          
          
       export const handler = async (event) => { };export const handler = async (event, context) => { };
      NoteUse a local integrated development environment (IDE) or text editor to write your TypeScript function code. You can’t create TypeScript code on the Lambda console.
     
     
      Using callbacks
      Callback handlers must use the event, context, and callback arguments. Example:
      export const handler = (event, context, callback) => { };
      The callback function expects an Error and a response, which must be JSON-serializable. The function continues to execute until the event loop is empty or the function times out. The response isn't sent to the invoker until all event loop tasks are finished. If the function times out, an error is returned instead. You can configure the runtime to send the response immediately by setting context.callbackWaitsForEmptyEventLoop to false.
      Example  – HTTP request with callbackThe following example function checks a URL and returns the status code to the invoker.import https from "https";
let url = "https://aws.amazon.com/";

export const handler = (event, context, callback) => {
  https.get(url, (res) => {
    callback(null, res.statusCode);
  }).on("error", (e) => {
    callback(Error(e));
  });
};
     
   
    Using the SDK for JavaScript v3 in your handler
    Often, you’ll use Lambda functions to interact with or make updates to other AWS resources. The simplest way to interface with these resources is to use the AWS SDK for JavaScript. All supported Lambda Node.js runtimes include the SDK for JavaScript version 3. However, we strongly recommend that you include the AWS SDK clients that you need in your deployment package. This maximizes backward compatibility during future Lambda runtime updates. Only rely on the runtime-provided SDK when you can't include additional packages (for example, when using the Lambda console code editor or inline code in an AWS CloudFormation template).
    To add SDK dependencies to your function, use the npm install command for the specific SDK clients that you need. In the example code, we used the Amazon S3 client. Add this dependency by running the following command in the directory that contains your package.json file:
npm install @aws-sdk/client-s3
    In the function code, import the client and commands that you need, as the example function demonstrates:
    import { S3Client, PutObjectCommand } from '@aws-sdk/client-s3';
    Then, initialize an Amazon S3 client:
    const s3Client = new S3Client();
    
    In this example, we initialized our Amazon S3 client outside of the main handler function to avoid having to initialize it every time we invoke our function. After you initialize your SDK client, you can then use it to make API calls for that AWS service. The example code calls the Amazon S3 PutObject API action as follows:
    const command = new PutObjectCommand({
    Bucket: bucketName,
    Key: key,
    Body: receiptContent
});
   
    Accessing environment variables
    In your handler code, you can reference any environment variables by using process.env. In this example, we reference the defined RECEIPT_BUCKET environment variable using the following lines of code:
    // Access environment variables
const bucketName = process.env.RECEIPT_BUCKET;
if (!bucketName) {
    throw new Error('RECEIPT_BUCKET environment variable is not set');
}
   
    Using global state
    Lambda runs your static code during the initialization phase before invoking your function for the first time. Resources created during initialization stay in memory between invocations, so you can avoid having to create them every time you invoke your function.
In the example code, the S3 client initialization code is outside the handler. The runtime initializes the client before the function handles its first event, and the client remains available for reuse across all invocations.
   
    Code best practices for Node.js Lambda functions
    
    Follow these guidelines when building Lambda functions:
    
       
       
       
       
    
        Separate the Lambda handler from your core logic. This allows you to make a more unit-testable function.
      
        Control the dependencies in your function's deployment package.  The AWS Lambda execution environment contains a number of libraries. For the Node.js and Python runtimes, these include the AWS SDKs. To enable the latest set of features and security updates, Lambda will periodically update these libraries. These updates may introduce subtle changes to the behavior of your Lambda function. To have full control of the dependencies your function uses, package all of your dependencies with your deployment package. 
      
        Minimize the complexity of your dependencies. Prefer simpler frameworks that load quickly on execution environment startup.
      
        Minimize your deployment package size to its runtime necessities.  This will reduce the amount of time that it takes for your deployment package to be downloaded and unpacked ahead of invocation.
      
    
 
 
 
     
     
     

      Take advantage of execution environment reuse to improve the performance of your
        function. Initialize SDK clients and database connections outside of the function handler, and
        cache static assets locally in the /tmp directory. Subsequent invocations processed by
        the same instance of your function can reuse these resources. This saves cost by reducing function run time.
      To avoid potential data leaks across invocations, don’t use the execution environment to store user data,
        events, or other information with security implications. If your function relies on a mutable state that can’t
        be stored in memory within the handler, consider creating a separate function or separate versions of a
        function for each user.
    
Use a keep-alive directive to maintain persistent connections. Lambda purges idle connections over time. 
Attempting to reuse an idle connection when invoking a function will result in a connection error. To maintain your persistent connection, use the 
keep-alive directive associated with your runtime. 
For an example, see Reusing Connections with Keep-Alive in Node.js.

Use environment variables to pass operational parameters to your function. For example, if
        you are writing to an Amazon S3 bucket, instead of hard-coding the bucket name you are writing to, configure the
        bucket name as an environment variable.

      Avoid using recursive invocations in your Lambda function, where the function
        invokes itself or initiates a process that may invoke the function again. This could lead to unintended volume of
        function invocations and escalated costs. If you see an unintended volume of invocations, set the function reserved concurrency
        to 0 immediately to throttle all invocations to the function, while you update the
        code.
    
      Do not use non-documented, non-public APIs in your Lambda function code.
        For AWS Lambda managed runtimes, Lambda periodically applies security and functional updates to Lambda's internal APIs.
        These internal API updates may be backwards-incompatible, leading to unintended consequences such as invocation
        failures if your function has a dependency on these non-public APIs. See
        the API reference for a list of
        publicly available APIs.
    
      Write idempotent code. Writing idempotent code for your functions ensures that
        duplicate events are handled the same way. Your code should properly validate events and gracefully handle
        duplicate events. For more information, see
        How do I make
          my Lambda function idempotent?.
    
  Document ConventionsBuilding with Node.jsDeploy .zip file archivesDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideSet up your projectExample functionHandler naming conventionsInput event objectValid handler patternsUsing the SDK for JavaScriptAccessing environment variablesUsing global stateBest practicesDefine Lambda function handler in Node.jsThe Lambda function handler is the method in your function code that processes events. When your function is
  invoked, Lambda runs the handler method. Your function runs until the handler returns a response, exits, or times out.This page describes how to work with Lambda function handlers in Node.js, including options for project
    setup, naming conventions, and best practices. This page also includes an example of a Node.js Lambda
    function that takes in information about an order, produces a text file receipt, and puts this file
    in an Amazon Simple Storage Service (Amazon S3) bucket. For information about how to deploy your function after writing it, see
    Deploy Node.js Lambda functions with .zip file archives or Deploy Node.js Lambda functions with container images.TopicsSetting up your Node.js handler projectExample Node.js Lambda function codeHandler naming conventionsDefining and accessing the input event objectValid handler patterns for Node.js functionsUsing the SDK for JavaScript v3 in your handlerAccessing environment variablesUsing global stateCode best practices for Node.js Lambda functions
    Setting up your Node.js handler project
    There are multiple ways to initialize a Node.js Lambda project. For example, you can create a standard Node.js project using npm, create an AWS SAM application, or create an AWS CDK application.
    To create the project using npm:
    npm init
    This command initializes your project and generates a package.json file that manages your project's metadata and dependencies.
    Your function code lives in a .js or .mjs JavaScript file. In the following example, we name this file index.mjs because it uses an ES module handler. Lambda supports both ES module and CommonJS handlers. For more information, see Designating a function handler as an ES module.
    A typical Node.js Lambda function project follows this general structure:
    /project-root
  ├── index.mjs — Contains main handler
  ├── package.json — Project metadata and dependencies
  ├── package-lock.json — Dependency lock file
  └── node_modules/ — Installed dependencies
   
    Example Node.js Lambda function code
    The following example Lambda function code takes in information about an order,
      produces a text file receipt, and puts this file in an Amazon S3 bucket.
    NoteThis example uses an ES module handler. Lambda supports both ES module and CommonJS handlers. For more information, see Designating a function handler as an ES module.
    Example index.mjs Lambda functionimport { S3Client, PutObjectCommand } from '@aws-sdk/client-s3';

// Initialize the S3 client outside the handler for reuse
const s3Client = new S3Client();

/**
 * Lambda handler for processing orders and storing receipts in S3.
 * @param {Object} event - Input event containing order details
 * @param {string} event.order_id - The unique identifier for the order
 * @param {number} event.amount - The order amount
 * @param {string} event.item - The item purchased
 * @returns {Promise<string>} Success message
 */
export const handler = async(event) => {
    try {
        // Access environment variables
        const bucketName = process.env.RECEIPT_BUCKET;
        if (!bucketName) {
            throw new Error('RECEIPT_BUCKET environment variable is not set');
        }

        // Create the receipt content and key destination
        const receiptContent = `OrderID: ${event.order_id}\nAmount: $${event.amount.toFixed(2)}\nItem: ${event.item}`;
        const key = `receipts/${event.order_id}.txt`;

        // Upload the receipt to S3
        await uploadReceiptToS3(bucketName, key, receiptContent);

        console.log(`Successfully processed order ${event.order_id} and stored receipt in S3 bucket ${bucketName}`);
        return 'Success';
    } catch (error) {
        console.error(`Failed to process order: ${error.message}`);
        throw error;
    }
};

/**
 * Helper function to upload receipt to S3
 * @param {string} bucketName - The S3 bucket name
 * @param {string} key - The S3 object key
 * @param {string} receiptContent - The content to upload
 * @returns {Promise<void>}
 */
async function uploadReceiptToS3(bucketName, key, receiptContent) {
    try {
        const command = new PutObjectCommand({
            Bucket: bucketName,
            Key: key,
            Body: receiptContent
        });

        await s3Client.send(command);
    } catch (error) {
        throw new Error(`Failed to upload receipt to S3: ${error.message}`);
    }
}
    This index.mjs file contains the following sections of code:
    
       
       
       
       
       
    
        import block: Use this block to include libraries that your Lambda function requires, such as AWS SDK clients.
      
        const s3Client declaration: This initializes an Amazon S3 client outside of the handler function. This causes Lambda to run this code during the initialization phase, and the client is preserved for reuse across multiple invocations.
      
        JSDoc comment block: Define the input and output types for your handler using JSDoc annotations.
      
        export const handler: This is the main handler function that Lambda invokes. When deploying your function, specify index.handler for the Handler property. The value of the Handler property is the file name and the name of the exported handler method, separated by a dot.
      
        uploadReceiptToS3 function: This is a helper function that's referenced by the main handler function.
      
    
    For this function to work properly, its  execution role must allow the s3:PutObject action. Also, ensure that you define the RECEIPT_BUCKET environment variable. After a successful invocation, the Amazon S3 bucket should contain a receipt file.
   
    Handler naming conventions
    When you configure a function, the value of the Handler setting is
      the file name and the name of the exported handler method, separated by a dot. The default for functions created in the console and for
      examples in this guide is index.handler. This indicates the handler method that's exported
      from the index.js or index.mjs file.
    If you create a function in the console using a different file name or function handler name, you must edit 
      the default handler name.
    To change the function handler name (console)
        Open the Functions page of the Lambda console and choose your function.
      
        Choose the Code tab.
      
        Scroll down to the Runtime settings pane and choose Edit.
      
        In Handler, enter the new name for your function handler.
      
        Choose Save.
      

   
    Defining and accessing the input event object
    
    JSON is the most common and standard input format for Lambda functions. In this example,
      the function expects an input similar to the following:
    {
    "order_id": "12345",
    "amount": 199.99,
    "item": "Wireless Headphones"
}
    When working with Lambda functions in Node.js, you can define the expected shape of the input event using JSDoc annotations. In this example, we define the input structure in the handler's JSDoc comment:
    /**
 * Lambda handler for processing orders and storing receipts in S3.
 * @param {Object} event - Input event containing order details
 * @param {string} event.order_id - The unique identifier for the order
 * @param {number} event.amount - The order amount
 * @param {string} event.item - The item purchased
 * @returns {Promise<string>} Success message
 */
    After you define these types in your JSDoc comment, you can access the fields of the event object directly in your code. For example, event.order_id retrieves the value of order_id from the original input.
   
    Valid handler patterns for Node.js functions
    We recommend that you use async/await to declare the function handler instead of using callbacks. Async/await is a concise and readable way to write asynchronous code, without the need for nested callbacks or chaining promises. With async/await, you can write code that reads like synchronous code, while still being asynchronous and non-blocking.
     
      Using async/await (recommended)
      
      The async keyword marks a function as asynchronous, and the await keyword pauses the execution of the function until a Promise is resolved. The handler accepts the following arguments:
      
         
         
      
          event: Contains the input data passed to your function.
        
          context: Contains information about the invocation, function, and execution environment. For more information, see Using the Lambda context object to retrieve Node.js function information.
        
      Here are the valid signatures for the async/await pattern:
       
          
          
       export const handler = async (event) => { };export const handler = async (event, context) => { };
      NoteUse a local integrated development environment (IDE) or text editor to write your TypeScript function code. You can’t create TypeScript code on the Lambda console.
     
     
      Using callbacks
      Callback handlers must use the event, context, and callback arguments. Example:
      export const handler = (event, context, callback) => { };
      The callback function expects an Error and a response, which must be JSON-serializable. The function continues to execute until the event loop is empty or the function times out. The response isn't sent to the invoker until all event loop tasks are finished. If the function times out, an error is returned instead. You can configure the runtime to send the response immediately by setting context.callbackWaitsForEmptyEventLoop to false.
      Example  – HTTP request with callbackThe following example function checks a URL and returns the status code to the invoker.import https from "https";
let url = "https://aws.amazon.com/";

export const handler = (event, context, callback) => {
  https.get(url, (res) => {
    callback(null, res.statusCode);
  }).on("error", (e) => {
    callback(Error(e));
  });
};
     
   
    Using the SDK for JavaScript v3 in your handler
    Often, you’ll use Lambda functions to interact with or make updates to other AWS resources. The simplest way to interface with these resources is to use the AWS SDK for JavaScript. All supported Lambda Node.js runtimes include the SDK for JavaScript version 3. However, we strongly recommend that you include the AWS SDK clients that you need in your deployment package. This maximizes backward compatibility during future Lambda runtime updates. Only rely on the runtime-provided SDK when you can't include additional packages (for example, when using the Lambda console code editor or inline code in an AWS CloudFormation template).
    To add SDK dependencies to your function, use the npm install command for the specific SDK clients that you need. In the example code, we used the Amazon S3 client. Add this dependency by running the following command in the directory that contains your package.json file:
npm install @aws-sdk/client-s3
    In the function code, import the client and commands that you need, as the example function demonstrates:
    import { S3Client, PutObjectCommand } from '@aws-sdk/client-s3';
    Then, initialize an Amazon S3 client:
    const s3Client = new S3Client();
    
    In this example, we initialized our Amazon S3 client outside of the main handler function to avoid having to initialize it every time we invoke our function. After you initialize your SDK client, you can then use it to make API calls for that AWS service. The example code calls the Amazon S3 PutObject API action as follows:
    const command = new PutObjectCommand({
    Bucket: bucketName,
    Key: key,
    Body: receiptContent
});
   
    Accessing environment variables
    In your handler code, you can reference any environment variables by using process.env. In this example, we reference the defined RECEIPT_BUCKET environment variable using the following lines of code:
    // Access environment variables
const bucketName = process.env.RECEIPT_BUCKET;
if (!bucketName) {
    throw new Error('RECEIPT_BUCKET environment variable is not set');
}
   
    Using global state
    Lambda runs your static code during the initialization phase before invoking your function for the first time. Resources created during initialization stay in memory between invocations, so you can avoid having to create them every time you invoke your function.
In the example code, the S3 client initialization code is outside the handler. The runtime initializes the client before the function handles its first event, and the client remains available for reuse across all invocations.
   
    Code best practices for Node.js Lambda functions
    
    Follow these guidelines when building Lambda functions:
    
       
       
       
       
    
        Separate the Lambda handler from your core logic. This allows you to make a more unit-testable function.
      
        Control the dependencies in your function's deployment package.  The AWS Lambda execution environment contains a number of libraries. For the Node.js and Python runtimes, these include the AWS SDKs. To enable the latest set of features and security updates, Lambda will periodically update these libraries. These updates may introduce subtle changes to the behavior of your Lambda function. To have full control of the dependencies your function uses, package all of your dependencies with your deployment package. 
      
        Minimize the complexity of your dependencies. Prefer simpler frameworks that load quickly on execution environment startup.
      
        Minimize your deployment package size to its runtime necessities.  This will reduce the amount of time that it takes for your deployment package to be downloaded and unpacked ahead of invocation.
      
    
 
 
 
     
     
     

      Take advantage of execution environment reuse to improve the performance of your
        function. Initialize SDK clients and database connections outside of the function handler, and
        cache static assets locally in the /tmp directory. Subsequent invocations processed by
        the same instance of your function can reuse these resources. This saves cost by reducing function run time.
      To avoid potential data leaks across invocations, don’t use the execution environment to store user data,
        events, or other information with security implications. If your function relies on a mutable state that can’t
        be stored in memory within the handler, consider creating a separate function or separate versions of a
        function for each user.
    
Use a keep-alive directive to maintain persistent connections. Lambda purges idle connections over time. 
Attempting to reuse an idle connection when invoking a function will result in a connection error. To maintain your persistent connection, use the 
keep-alive directive associated with your runtime. 
For an example, see Reusing Connections with Keep-Alive in Node.js.

Use environment variables to pass operational parameters to your function. For example, if
        you are writing to an Amazon S3 bucket, instead of hard-coding the bucket name you are writing to, configure the
        bucket name as an environment variable.

      Avoid using recursive invocations in your Lambda function, where the function
        invokes itself or initiates a process that may invoke the function again. This could lead to unintended volume of
        function invocations and escalated costs. If you see an unintended volume of invocations, set the function reserved concurrency
        to 0 immediately to throttle all invocations to the function, while you update the
        code.
    
      Do not use non-documented, non-public APIs in your Lambda function code.
        For AWS Lambda managed runtimes, Lambda periodically applies security and functional updates to Lambda's internal APIs.
        These internal API updates may be backwards-incompatible, leading to unintended consequences such as invocation
        failures if your function has a dependency on these non-public APIs. See
        the API reference for a list of
        publicly available APIs.
    
      Write idempotent code. Writing idempotent code for your functions ensures that
        duplicate events are handled the same way. Your code should properly validate events and gracefully handle
        duplicate events. For more information, see
        How do I make
          my Lambda function idempotent?.
    
  Document ConventionsBuilding with Node.jsDeploy .zip file archivesDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideSet up your projectExample functionHandler naming conventionsInput event objectValid handler patternsUsing the SDK for JavaScriptAccessing environment variablesUsing global stateBest practicesDefine Lambda function handler in Node.jsThe Lambda function handler is the method in your function code that processes events. When your function is
  invoked, Lambda runs the handler method. Your function runs until the handler returns a response, exits, or times out.This page describes how to work with Lambda function handlers in Node.js, including options for project
    setup, naming conventions, and best practices. This page also includes an example of a Node.js Lambda
    function that takes in information about an order, produces a text file receipt, and puts this file
    in an Amazon Simple Storage Service (Amazon S3) bucket. For information about how to deploy your function after writing it, see
    Deploy Node.js Lambda functions with .zip file archives or Deploy Node.js Lambda functions with container images.TopicsSetting up your Node.js handler projectExample Node.js Lambda function codeHandler naming conventionsDefining and accessing the input event objectValid handler patterns for Node.js functionsUsing the SDK for JavaScript v3 in your handlerAccessing environment variablesUsing global stateCode best practices for Node.js Lambda functions
    Setting up your Node.js handler project
    There are multiple ways to initialize a Node.js Lambda project. For example, you can create a standard Node.js project using npm, create an AWS SAM application, or create an AWS CDK application.
    To create the project using npm:
    npm init
    This command initializes your project and generates a package.json file that manages your project's metadata and dependencies.
    Your function code lives in a .js or .mjs JavaScript file. In the following example, we name this file index.mjs because it uses an ES module handler. Lambda supports both ES module and CommonJS handlers. For more information, see Designating a function handler as an ES module.
    A typical Node.js Lambda function project follows this general structure:
    /project-root
  ├── index.mjs — Contains main handler
  ├── package.json — Project metadata and dependencies
  ├── package-lock.json — Dependency lock file
  └── node_modules/ — Installed dependencies
   
    Example Node.js Lambda function code
    The following example Lambda function code takes in information about an order,
      produces a text file receipt, and puts this file in an Amazon S3 bucket.
    NoteThis example uses an ES module handler. Lambda supports both ES module and CommonJS handlers. For more information, see Designating a function handler as an ES module.
    Example index.mjs Lambda functionimport { S3Client, PutObjectCommand } from '@aws-sdk/client-s3';

// Initialize the S3 client outside the handler for reuse
const s3Client = new S3Client();

/**
 * Lambda handler for processing orders and storing receipts in S3.
 * @param {Object} event - Input event containing order details
 * @param {string} event.order_id - The unique identifier for the order
 * @param {number} event.amount - The order amount
 * @param {string} event.item - The item purchased
 * @returns {Promise<string>} Success message
 */
export const handler = async(event) => {
    try {
        // Access environment variables
        const bucketName = process.env.RECEIPT_BUCKET;
        if (!bucketName) {
            throw new Error('RECEIPT_BUCKET environment variable is not set');
        }

        // Create the receipt content and key destination
        const receiptContent = `OrderID: ${event.order_id}\nAmount: $${event.amount.toFixed(2)}\nItem: ${event.item}`;
        const key = `receipts/${event.order_id}.txt`;

        // Upload the receipt to S3
        await uploadReceiptToS3(bucketName, key, receiptContent);

        console.log(`Successfully processed order ${event.order_id} and stored receipt in S3 bucket ${bucketName}`);
        return 'Success';
    } catch (error) {
        console.error(`Failed to process order: ${error.message}`);
        throw error;
    }
};

/**
 * Helper function to upload receipt to S3
 * @param {string} bucketName - The S3 bucket name
 * @param {string} key - The S3 object key
 * @param {string} receiptContent - The content to upload
 * @returns {Promise<void>}
 */
async function uploadReceiptToS3(bucketName, key, receiptContent) {
    try {
        const command = new PutObjectCommand({
            Bucket: bucketName,
            Key: key,
            Body: receiptContent
        });

        await s3Client.send(command);
    } catch (error) {
        throw new Error(`Failed to upload receipt to S3: ${error.message}`);
    }
}
    This index.mjs file contains the following sections of code:
    
       
       
       
       
       
    
        import block: Use this block to include libraries that your Lambda function requires, such as AWS SDK clients.
      
        const s3Client declaration: This initializes an Amazon S3 client outside of the handler function. This causes Lambda to run this code during the initialization phase, and the client is preserved for reuse across multiple invocations.
      
        JSDoc comment block: Define the input and output types for your handler using JSDoc annotations.
      
        export const handler: This is the main handler function that Lambda invokes. When deploying your function, specify index.handler for the Handler property. The value of the Handler property is the file name and the name of the exported handler method, separated by a dot.
      
        uploadReceiptToS3 function: This is a helper function that's referenced by the main handler function.
      
    
    For this function to work properly, its  execution role must allow the s3:PutObject action. Also, ensure that you define the RECEIPT_BUCKET environment variable. After a successful invocation, the Amazon S3 bucket should contain a receipt file.
   
    Handler naming conventions
    When you configure a function, the value of the Handler setting is
      the file name and the name of the exported handler method, separated by a dot. The default for functions created in the console and for
      examples in this guide is index.handler. This indicates the handler method that's exported
      from the index.js or index.mjs file.
    If you create a function in the console using a different file name or function handler name, you must edit 
      the default handler name.
    To change the function handler name (console)
        Open the Functions page of the Lambda console and choose your function.
      
        Choose the Code tab.
      
        Scroll down to the Runtime settings pane and choose Edit.
      
        In Handler, enter the new name for your function handler.
      
        Choose Save.
      

   
    Defining and accessing the input event object
    
    JSON is the most common and standard input format for Lambda functions. In this example,
      the function expects an input similar to the following:
    {
    "order_id": "12345",
    "amount": 199.99,
    "item": "Wireless Headphones"
}
    When working with Lambda functions in Node.js, you can define the expected shape of the input event using JSDoc annotations. In this example, we define the input structure in the handler's JSDoc comment:
    /**
 * Lambda handler for processing orders and storing receipts in S3.
 * @param {Object} event - Input event containing order details
 * @param {string} event.order_id - The unique identifier for the order
 * @param {number} event.amount - The order amount
 * @param {string} event.item - The item purchased
 * @returns {Promise<string>} Success message
 */
    After you define these types in your JSDoc comment, you can access the fields of the event object directly in your code. For example, event.order_id retrieves the value of order_id from the original input.
   
    Valid handler patterns for Node.js functions
    We recommend that you use async/await to declare the function handler instead of using callbacks. Async/await is a concise and readable way to write asynchronous code, without the need for nested callbacks or chaining promises. With async/await, you can write code that reads like synchronous code, while still being asynchronous and non-blocking.
     
      Using async/await (recommended)
      
      The async keyword marks a function as asynchronous, and the await keyword pauses the execution of the function until a Promise is resolved. The handler accepts the following arguments:
      
         
         
      
          event: Contains the input data passed to your function.
        
          context: Contains information about the invocation, function, and execution environment. For more information, see Using the Lambda context object to retrieve Node.js function information.
        
      Here are the valid signatures for the async/await pattern:
       
          
          
       export const handler = async (event) => { };export const handler = async (event, context) => { };
      NoteUse a local integrated development environment (IDE) or text editor to write your TypeScript function code. You can’t create TypeScript code on the Lambda console.
     
     
      Using callbacks
      Callback handlers must use the event, context, and callback arguments. Example:
      export const handler = (event, context, callback) => { };
      The callback function expects an Error and a response, which must be JSON-serializable. The function continues to execute until the event loop is empty or the function times out. The response isn't sent to the invoker until all event loop tasks are finished. If the function times out, an error is returned instead. You can configure the runtime to send the response immediately by setting context.callbackWaitsForEmptyEventLoop to false.
      Example  – HTTP request with callbackThe following example function checks a URL and returns the status code to the invoker.import https from "https";
let url = "https://aws.amazon.com/";

export const handler = (event, context, callback) => {
  https.get(url, (res) => {
    callback(null, res.statusCode);
  }).on("error", (e) => {
    callback(Error(e));
  });
};
     
   
    Using the SDK for JavaScript v3 in your handler
    Often, you’ll use Lambda functions to interact with or make updates to other AWS resources. The simplest way to interface with these resources is to use the AWS SDK for JavaScript. All supported Lambda Node.js runtimes include the SDK for JavaScript version 3. However, we strongly recommend that you include the AWS SDK clients that you need in your deployment package. This maximizes backward compatibility during future Lambda runtime updates. Only rely on the runtime-provided SDK when you can't include additional packages (for example, when using the Lambda console code editor or inline code in an AWS CloudFormation template).
    To add SDK dependencies to your function, use the npm install command for the specific SDK clients that you need. In the example code, we used the Amazon S3 client. Add this dependency by running the following command in the directory that contains your package.json file:
npm install @aws-sdk/client-s3
    In the function code, import the client and commands that you need, as the example function demonstrates:
    import { S3Client, PutObjectCommand } from '@aws-sdk/client-s3';
    Then, initialize an Amazon S3 client:
    const s3Client = new S3Client();
    
    In this example, we initialized our Amazon S3 client outside of the main handler function to avoid having to initialize it every time we invoke our function. After you initialize your SDK client, you can then use it to make API calls for that AWS service. The example code calls the Amazon S3 PutObject API action as follows:
    const command = new PutObjectCommand({
    Bucket: bucketName,
    Key: key,
    Body: receiptContent
});
   
    Accessing environment variables
    In your handler code, you can reference any environment variables by using process.env. In this example, we reference the defined RECEIPT_BUCKET environment variable using the following lines of code:
    // Access environment variables
const bucketName = process.env.RECEIPT_BUCKET;
if (!bucketName) {
    throw new Error('RECEIPT_BUCKET environment variable is not set');
}
   
    Using global state
    Lambda runs your static code during the initialization phase before invoking your function for the first time. Resources created during initialization stay in memory between invocations, so you can avoid having to create them every time you invoke your function.
In the example code, the S3 client initialization code is outside the handler. The runtime initializes the client before the function handles its first event, and the client remains available for reuse across all invocations.
   
    Code best practices for Node.js Lambda functions
    
    Follow these guidelines when building Lambda functions:
    
       
       
       
       
    
        Separate the Lambda handler from your core logic. This allows you to make a more unit-testable function.
      
        Control the dependencies in your function's deployment package.  The AWS Lambda execution environment contains a number of libraries. For the Node.js and Python runtimes, these include the AWS SDKs. To enable the latest set of features and security updates, Lambda will periodically update these libraries. These updates may introduce subtle changes to the behavior of your Lambda function. To have full control of the dependencies your function uses, package all of your dependencies with your deployment package. 
      
        Minimize the complexity of your dependencies. Prefer simpler frameworks that load quickly on execution environment startup.
      
        Minimize your deployment package size to its runtime necessities.  This will reduce the amount of time that it takes for your deployment package to be downloaded and unpacked ahead of invocation.
      
    
 
 
 
     
     
     

      Take advantage of execution environment reuse to improve the performance of your
        function. Initialize SDK clients and database connections outside of the function handler, and
        cache static assets locally in the /tmp directory. Subsequent invocations processed by
        the same instance of your function can reuse these resources. This saves cost by reducing function run time.
      To avoid potential data leaks across invocations, don’t use the execution environment to store user data,
        events, or other information with security implications. If your function relies on a mutable state that can’t
        be stored in memory within the handler, consider creating a separate function or separate versions of a
        function for each user.
    
Use a keep-alive directive to maintain persistent connections. Lambda purges idle connections over time. 
Attempting to reuse an idle connection when invoking a function will result in a connection error. To maintain your persistent connection, use the 
keep-alive directive associated with your runtime. 
For an example, see Reusing Connections with Keep-Alive in Node.js.

Use environment variables to pass operational parameters to your function. For example, if
        you are writing to an Amazon S3 bucket, instead of hard-coding the bucket name you are writing to, configure the
        bucket name as an environment variable.

      Avoid using recursive invocations in your Lambda function, where the function
        invokes itself or initiates a process that may invoke the function again. This could lead to unintended volume of
        function invocations and escalated costs. If you see an unintended volume of invocations, set the function reserved concurrency
        to 0 immediately to throttle all invocations to the function, while you update the
        code.
    
      Do not use non-documented, non-public APIs in your Lambda function code.
        For AWS Lambda managed runtimes, Lambda periodically applies security and functional updates to Lambda's internal APIs.
        These internal API updates may be backwards-incompatible, leading to unintended consequences such as invocation
        failures if your function has a dependency on these non-public APIs. See
        the API reference for a list of
        publicly available APIs.
    
      Write idempotent code. Writing idempotent code for your functions ensures that
        duplicate events are handled the same way. Your code should properly validate events and gracefully handle
        duplicate events. For more information, see
        How do I make
          my Lambda function idempotent?.
    
  Document ConventionsBuilding with Node.jsDeploy .zip file archivesDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideRuntime dependencies in Node.jsCreating a .zip deployment package with no dependenciesCreating a .zip deployment package with dependenciesCreating a Node.js layer for your dependenciesDependency search path and runtime-included librariesCreating and updating Node.js Lambda functions using .zip filesDeploy Node.js Lambda functions with .zip file archives
    Your AWS Lambda function’s code comprises a .js or .mjs file containing your function’s handler code, together with any additional packages and modules 
    your code depends on. To deploy this function code to Lambda, you use a deployment package. This package may either be a 
  .zip file archive or a container image.  
  For more information about using container images with Node.js, see Deploy Node.js Lambda functions with container images.
  
    To create your deployment package as .zip file archive, you can use your command-line tool’s built-in .zip file archive utility, or any other 
    .zip file utility such as 7zip. The examples shown in the following sections assume 
  you’re using a command-line zip tool in a Linux or MacOS environment. To use the same commands in Windows, you can 
  install the Windows Subsystem for Linux to get a Windows-integrated 
  version of Ubuntu and Bash.
  
    Note that Lambda uses POSIX file permissions, so you may need to set permissions for the deployment package folder before you create the .zip file archive.
  TopicsRuntime dependencies in Node.jsCreating a .zip deployment package with no dependenciesCreating a .zip deployment package with dependenciesCreating a Node.js layer for your dependenciesDependency search path and runtime-included librariesCreating and updating Node.js Lambda functions using .zip files
    Runtime dependencies in Node.js
    
      For Lambda functions that use the Node.js runtime, a dependency can be any Node.js module. The Node.js runtime includes a number of common 
      libraries, as well as a version of the AWS SDK for JavaScript. The nodejs16.x Lambda runtime includes version 2.x of the SDK. Runtime versions nodejs18.x and later include version 3 of the SDK. To use version 2 of the SDK with runtime versions nodejs18.x and later, add the SDK to your 
      .zip file deployment package. If your chosen runtime includes the version of the SDK you are using, you don't need to include the SDK library 
      in your .zip file. To find out which version of the SDK is included in the runtime you're using, see Runtime-included SDK versions.
    
    
      Lambda periodically updates the SDK libraries in the Node.js runtime to include the latest features and security upgrades. Lambda also applies 
      security patches and updates to the other libraries included in the runtime. To have full control of the dependencies in your package, you can 
      add your preferred version of any runtime-included dependency to your deployment package. For example, if you want to use a particular version of 
      the SDK for JavaScript, you can include it in your .zip file as a dependency. For more information on adding runtime-included dependencies to your .zip 
      file, see Dependency search path and runtime-included libraries.
    
    
      Under the AWS shared responsibility model, 
      you are responsible for the management of any dependencies in your functions' deployment packages. This includes applying updates and security 
      patches. To update dependencies in your function's deployment package, first create a new .zip file and then upload it to Lambda. See Creating a .zip deployment package with dependencies 
      and Creating and updating Node.js Lambda functions using .zip files for more information.
    
   
    Creating a .zip deployment package with no dependencies
    
      If your function code has no dependencies except for libraries included in the Lambda runtime, your .zip file contains only the index.js or 
      index.mjs file with your function’s handler code. Use your preferred zip utility to create a .zip file with your index.js or 
      index.mjs file at the root. If the file containing your handler code isn't at the root of your .zip file, Lambda won’t be able to run your code.
    
    
      To learn how to deploy your .zip file to create a new Lambda function or update an existing one, see Creating and updating Node.js Lambda functions using .zip files.
    
   
    Creating a .zip deployment package with dependencies
    If your function code depends on packages or modules that aren't included in the Lambda Node.js runtime,
      you can either add these dependencies to your .zip file with your function code or use a
      Lambda layer. The instructions in this section show you how to
      include your dependencies in your .zip deployment package. For instructions on how to include your
      dependencies in a layer, see Creating a Node.js layer for your dependencies.
    The following example CLI commands create a .zip file named my_deployment_package.zip containing the index.js 
      or index.mjs file with your function's handler code and its dependencies. In the example, you install dependencies using the 
      npm package manager.
    To create the deployment package
        Navigate to the project directory containing your index.js or index.mjs source code file. In this example, 
          the directory is named my_function.
        cd my_function
      
        Install your function's required libraries in the node_modules directory using the npm install command. In this 
          example you install the AWS X-Ray SDK for Node.js.
        npm install aws-xray-sdk
        This creates a folder structure similar to the following:
        ~/my_function
├── index.mjs
└── node_modules
    ├── async
    ├── async-listener
    ├── atomic-batcher
    ├── aws-sdk
    ├── aws-xray-sdk
    ├── aws-xray-sdk-core
        You can also add custom modules that you create yourself to your deployment package. Create a directory under node_modules 
          with the name of your module and save your custom written packages there.
      
        Create a .zip file that contains the contents of your project folder at the root. Use the r (recursive) option to 
          ensure that zip compresses the subfolders.
        zip -r my_deployment_package.zip .
      
   
    Creating a Node.js layer for your dependencies
    The instructions in this section show you how to include your dependencies in a layer. For instructions
      on how to include your dependencies in your deployment package, see
      Creating a .zip deployment package with dependencies.
    When you add a layer to a function, Lambda loads the layer content into the
      /opt directory of that execution environment. For each Lambda runtime,
      the PATH variable already includes specific folder paths within the
      /opt directory. To ensure that Lambda picks up your layer content, 
      your layer .zip file should have its dependencies
      in the following folder paths:
    
       
       
       
          
    
        nodejs/node_modules
      
        nodejs/node16/node_modules (NODE_PATH)
      
        nodejs/node18/node_modules (NODE_PATH)
      
        nodejs/node20/node_modules (NODE_PATH)
      
    For example, your layer .zip file structure might look like the following:
    xray-sdk.zip
└ nodejs/node_modules/aws-xray-sdk
    In addition, Lambda automatically detects any libraries in the /opt/lib
      directory, and any binaries in the /opt/bin directory. To ensure
      that Lambda properly finds your layer content, you can also create a layer
      with the following structure:
      custom-layer.zip
└ lib
    | lib_1
    | lib_2
└ bin
    | bin_1
    | bin_2
    After you package your layer, see Creating and deleting layers in Lambda
      and Adding layers to functions to complete your layer setup.
   
    Dependency search path and runtime-included libraries
    The Node.js runtime includes a number of common libraries, as well as a version of the AWS SDK for JavaScript. If you want to use a different version of a runtime-included library, you can do this by bundling it with your function or by adding it as a 
      dependency in your deployment package. For example, you can use a different version of the SDK by adding it to your .zip deployment package. 
      You can also include it in a Lambda layer for your function.
    When you use an import or require statement in your code, the Node.js runtime searches the directories in the NODE_PATH 
      path until it finds the module. By default, the first location the runtime searches is the directory into which your .zip deployment package is 
      decompressed and mounted (/var/task). If you include a version of a runtime-included library in your deployment package, this 
      version will take precedence over the version included in the runtime. Dependencies in your deployment package also have precedence over 
      dependencies in layers.
    When you add a dependency to a layer, Lambda extracts this to /opt/nodejs/nodexx/node_modules where nodexx 
      represents the version of the runtime you are using. In the search path, this directory has precedence over the directory containing the 
      runtime-included libraries (/var/lang/lib/node_modules). Libraries in function layers therefore have precedence over versions 
      included in the runtime.
    You can see the full search path for your Lambda function by adding the following line of code.
    console.log(process.env.NODE_PATH)
    You can also add dependencies in a separate folder inside your .zip package. For example, you might add a custom module to a folder in 
      your .zip package called common. When your .zip package is decompressed and mounted, this folder is placed inside the /var/task directory. 
      To use a dependency from a folder in your .zip deployment package in your code, use an import { } from or const { } = require() statement, 
      depending on whether you are using CJS or ESM module resolution. For example:
    import { myModule } from './common'
    If you bundle your code with esbuild, rollup, or similar, the dependencies used by your function are bundled together in one 
      or more files. We recommend using this method to vend dependencies whenever possible. Compared to adding dependencies to your deployment package, 
      bundling your code results in improved performance due to the reduction in I/O operations.
   
    Creating and updating Node.js Lambda functions using .zip files
    
      After you have created your .zip deployment package, you can use it to create a new Lambda function or update an existing one. You can deploy 
      your .zip package using the Lambda console, the AWS Command Line Interface, and the Lambda API. You can also create and update Lambda functions using 
      AWS Serverless Application Model (AWS SAM) and AWS CloudFormation.
    
    The maximum size for a .zip deployment package for Lambda is 250 MB (unzipped). Note that this limit applies to the combined size of all the files you upload, 
    including any Lambda layers.
    The Lambda runtime needs permission to read the files in your deployment package. In Linux permissions octal notation, Lambda needs 644 permissions 
      for non-executable files (rw-r--r--) and 755 permissions (rwxr-xr-x) for directories and executable files.
    In Linux and MacOS, use the chmod command to change file permissions on files and directories in your deployment package. For 
      example, to give a non-executable file the correct permissions, run the following command.
    chmod 644 <filepath>
    To change file permissions in Windows, see Set, View, Change, or Remove Permissions on an Object 
    in the Microsoft Windows documentation.
    NoteIf you don't grant Lambda the permissions it needs to access directories in your deployment package, Lambda sets the permissions for those directories to 755 (rwxr-xr-x).
     
      Creating and updating functions with .zip files using the console
      
      To create a new function, you must first create the function in the console, then upload your .zip archive. To update an existing function, open the page for your function, then follow the same procedure to add your updated .zip file.
    

      If your .zip file is less than 50MB, you can create or update a function by uploading the file directly from your local machine. For .zip files greater than 50MB, you must upload your package to an Amazon S3 bucket first. For instructions on how to upload a file to an Amazon S3 bucket using the AWS Management Console, see Getting started with Amazon S3. To upload files using the AWS CLI, see Move objects in the AWS CLI User Guide.
    
      NoteYou cannot change the deployment package type (.zip or container image) for an existing function. For example, you cannot convert a container image function to use a .zip file archive. You must create a new function.
  To create a new function (console)
      Open the Functions page of the Lambda console and choose Create Function.
    
      Choose Author from scratch.
    
      Under Basic information, do the following:
      
          For Function name, enter the name for your function.
          
              For Runtime, select the runtime you want to use.
            
              (Optional) For Architecture, choose the instruction set architecture for your function. The default architecture is x86_64. Ensure that the .zip deployment package for your function is compatible with the instruction set architecture you select.
            
    
      (Optional) Under Permissions, expand Change default execution role. You can create a new Execution role or use an existing one.
    
      Choose Create function. Lambda creates a basic 'Hello world' function using your chosen runtime.
    
  To upload a .zip archive from your local machine (console)
      In the Functions page of the Lambda console, choose the function you want to upload the .zip file for.
    
      Select the Code tab.
    
      In the Code source pane, choose Upload from.
    
      Choose .zip file.
    
      To upload the .zip file, do the following:
      
          Select Upload, then select your .zip file in the file chooser.
        
          Choose Open.
        
          Choose Save.
        
    
  
  To upload a .zip archive from an Amazon S3 bucket (console)
      In the Functions page of the Lambda console, choose the function you want to upload a new .zip file for.
    
      Select the Code tab.
    
      In the Code source pane, choose Upload from.
    
      Choose Amazon S3 location.
    
      Paste the Amazon S3 link URL of your .zip file and choose Save.
    
     
     
      Updating .zip file functions using the console code editor
      
     
    
      For some functions with .zip deployment packages, you can use the Lambda console’s built-in code editor to update your function code directly. To use this feature, your function must meet the following criteria:
    
    
       
       
    
        Your function must use one of the interpreted language runtimes (Python, Node.js, or Ruby)
      
        Your function’s deployment package must be smaller than 50 MB (unzipped).
      
    Function code for functions with container image deployment packages cannot be edited directly in the console.
    To update function code using the console code editor
        Open the Functions page of the Lambda console and select your function.
      
        Select the Code tab.
      
        In the Code source pane, select your source code file and edit it in the integrated code editor.
      
        In the DEPLOY section, choose Deploy to update your function's code:

   
    
   
   

      
     
      Creating and updating functions with .zip files using the AWS CLI
      
      You can can use the AWS CLI to create a new function or to update an existing one using a .zip file. Use the create-function 
      and update-function-code commands to deploy your .zip 
      package. If your .zip file is smaller than 50MB, you can upload the .zip package from a file location on your local build machine. For larger files, 
      you must upload your .zip package from an Amazon S3 bucket. For instructions on how to upload a file to an Amazon S3 bucket using the AWS CLI, see Move objects in the AWS CLI User Guide.
    
    NoteIf you upload your .zip file from an Amazon S3 bucket using the AWS CLI, the bucket must be located in the same AWS Region as your function.
    
      To create a new function using a .zip file with the AWS CLI, you must specify the following:
    
    
       
       
       
       
    
        The name of your function (--function-name)
      
        Your function’s runtime (--runtime)
      
        The Amazon Resource Name (ARN) of your function’s execution role (--role)
      
        The name of the handler method in your function code (--handler)
      
    
      You must also specify the location of your .zip file. If your .zip file is located in a folder on your local build machine, use the --zip-file option to specify the file path, as shown in the following example command.
    
    aws lambda create-function --function-name myFunction \
--runtime nodejs22.x --handler index.handler \
--role arn:aws:iam::111122223333:role/service-role/my-lambda-role \
--zip-file fileb://myFunction.zip
    
      To specify the location of .zip file in an Amazon S3 bucket, use the --code option as shown in the following example command. You only 
      need to use the S3ObjectVersion parameter for versioned objects.
    
    aws lambda create-function --function-name myFunction \
--runtime nodejs22.x --handler index.handler \
--role arn:aws:iam::111122223333:role/service-role/my-lambda-role \
--code S3Bucket=amzn-s3-demo-bucket,S3Key=myFileName.zip,S3ObjectVersion=myObjectVersion
    
      To update an existing function using the CLI, you specify the the name of your function using the --function-name parameter. You 
      must also specify the location of the .zip file you want to use to update your function code. If your .zip file is located in a folder on your 
      local build machine, use the --zip-file option to specify the file path, as shown in the following example command.
    
    aws lambda update-function-code --function-name myFunction \
--zip-file fileb://myFunction.zip
    
      To specify the location of .zip file in an Amazon S3 bucket, use the --s3-bucket and --s3-key options as shown in the 
      following example command. You only need to use the --s3-object-version parameter for versioned objects.
    
    aws lambda update-function-code --function-name myFunction \
--s3-bucket amzn-s3-demo-bucket --s3-key myFileName.zip --s3-object-version myObject Version
     
    
     
      Creating and updating functions with .zip files using the Lambda API
      
      To create and update functions using a .zip file archive, use the following API operations:
    

 
 

CreateFunction

UpdateFunctionCode

     
     
      Creating and updating functions with .zip files using AWS SAM
      
      The AWS Serverless Application Model (AWS SAM) is a toolkit that helps streamline the process of building and running serverless applications on AWS. You define the resources for your application in a 
      YAML or JSON template and use the AWS SAM command line interface (AWS SAM CLI) to build, package, and deploy your applications. When you build a Lambda function from an AWS SAM template, 
      AWS SAM automatically creates a .zip deployment package or container image with your function code and any dependencies you specify. To learn more about using AWS SAM to build and deploy 
      Lambda functions, see Getting started with AWS SAM in the
      AWS Serverless Application Model Developer Guide.

      You can also use AWS SAM to create a Lambda function using an existing .zip file archive. To create a Lambda function using AWS SAM, you can save your .zip file in 
      an Amazon S3 bucket or in a local folder on your build machine. For instructions on how to upload a file to an Amazon S3 bucket using the AWS CLI, 
      see Move objects in the AWS CLI User Guide.
    

      In your AWS SAM template, the AWS::Serverless::Function resource specifies your Lambda function. In this resource, set the following 
  properties to create a function using a .zip file archive:
    

 
 
 

PackageType - set to Zip

CodeUri - set to the  function code's Amazon S3 URI, path to local folder, or FunctionCode object

Runtime - Set to your chosen runtime


      With AWS SAM, if your .zip file is larger than 50MB, you don’t need to upload it to an Amazon S3 bucket first. AWS SAM can upload .zip packages up to 
      the maximum allowed size of 250MB (unzipped) from a location on your local build machine.
    

      To learn more about deploying functions using .zip file in AWS SAM, see AWS::Serverless::Function in the AWS SAM Developer Guide.
    
     
     
      Creating and updating functions with .zip files using AWS CloudFormation
      
      You can use AWS CloudFormation to create a Lambda function using a .zip file archive. To create a Lambda function from a .zip file, you must first upload 
      your file to an Amazon S3 bucket. For instructions on how to upload a file to an Amazon S3 bucket using the AWS CLI, see Move objects 
  in the AWS CLI User Guide. 
  In your AWS CloudFormation template, the AWS::Lambda::Function resource specifies your Lambda function. In this resource, set the following 
    properties to create a function using a .zip file archive:

 
 
 

PackageType - Set to Zip

Code - Enter the Amazon S3 bucket name and the .zip file name in the S3Bucket and S3Key fields

Runtime - Set to your chosen runtime


      The .zip file that AWS CloudFormation generates cannot exceed 4MB. To learn more about deploying functions using .zip file in AWS CloudFormation, see AWS::Lambda::Function 
  in the AWS CloudFormation User Guide.
    
     
  Document ConventionsHandlerDeploy container imagesDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideAWS base images for Node.jsUsing an AWS base imageUsing a non-AWS base imageDeploy Node.js Lambda functions with container imagesThere are three ways to build a container image for a Node.js Lambda function:
     
	 
     
  
      Using an AWS base image for Node.js
      The AWS base images are preloaded with a language runtime, a runtime interface client to manage the interaction between Lambda and your function code, and a runtime interface emulator for local testing.
    
      Using an AWS OS-only base image
      AWS OS-only base images contain an Amazon Linux distribution and the runtime interface emulator. These images are commonly used to create container images for compiled languages, such as Go and Rust, and for a language or language version that Lambda doesn't provide a base image for, such as Node.js 19. You can also use OS-only base images to implement a custom runtime. To make the image compatible with Lambda, you must include the runtime interface client for Node.js in the image.
    
      Using a non-AWS base image
      You can use an alternative base image from another container registry, such as Alpine Linux or Debian. You can also use a custom image created by your organization. To make the image compatible with Lambda, you must include the runtime interface client for Node.js in the image.
    TipTo reduce the time it takes for Lambda container functions to become active, see Use multi-stage builds in the Docker documentation. To build efficient container images, follow the Best practices for writing Dockerfiles.This page explains how to build, test, and deploy container images for Lambda.TopicsAWS base images for Node.jsUsing an AWS base image for Node.jsUsing an alternative base image with the runtime interface client
    AWS base images for Node.js
    AWS provides the following base images for Node.js:
      
    
    
          
            Tags
            Runtime
            Operating system
            Dockerfile
            Deprecation
          
        
      
            22
            Node.js 22
            Amazon Linux 2023
            Dockerfile
                for Node.js 22 on GitHub
            
                          Apr 30, 2027
            
              
          
      
            20
            Node.js 20
            Amazon Linux 2023
            Dockerfile
                for Node.js 20 on GitHub
            
                          Apr 30, 2026
            
              
          
      
            18
            Node.js 18
            Amazon Linux 2
            Dockerfile
                for Node.js 18 on GitHub
            
                          Sep 1, 2025
            
              
          
    

    Amazon ECR repository: gallery.ecr.aws/lambda/nodejs
    The Node.js 20 and later base images are based on the Amazon Linux 2023 minimal container image. Earlier base
      images use Amazon Linux 2. AL2023 provides several advantages over Amazon Linux 2, including a smaller deployment footprint
      and updated versions of libraries such as glibc.
    AL2023-based images use microdnf (symlinked as dnf) as the package manager instead of yum, which is the default package manager in Amazon Linux 2. microdnf is a standalone implementation of dnf. For a list of packages that are included in AL2023-based images, refer to the Minimal Container columns in Comparing packages installed on Amazon Linux 2023 Container Images. For more information about the differences between AL2023 and Amazon Linux 2, see Introducing the Amazon Linux 2023 runtime for AWS Lambda on the AWS
      Compute Blog.    
    NoteTo run AL2023-based images locally, including with AWS Serverless Application Model (AWS SAM), you must use Docker version 20.10.10 or later.  
   
    Using an AWS base image for Node.js
    To complete the steps in this section, you must have the following:
           
           
           
           
        
            AWS CLI version 2
          
            Docker (minimum version 25.0.0)
          
            The Docker buildx plugin.
          
              Node.js
          To create a container image from an AWS base image for Node.js
        Create a directory for the project, and then switch to that directory.
        mkdir example
cd example
      
        Create a new Node.js project with npm. To accept the default options provided in the interactive experience, press Enter.
        npm init
      
        Create a new file called index.js. You can add the following sample function code to the file for testing, or use your own.
        Example  CommonJS handlerexports.handler = async (event) => {
    const response = {
        statusCode: 200,
        body: JSON.stringify('Hello from Lambda!'),
    };
    return response;
};
      
        If your function depends on libraries other than the AWS SDK for JavaScript, use npm to add them to your package.
      
        Create a new Dockerfile with the following configuration:
        
           
           
           
        
            Set the FROM property to the URI of the base image.
          
            Use the COPY command to copy the function code and runtime dependencies to {LAMBDA_TASK_ROOT}, a Lambda-defined environment variable.
          
            Set the CMD argument to the Lambda function handler.
          
        Note that the example Dockerfile does not include a USER instruction. When you deploy a container image to Lambda, Lambda automatically defines a default Linux user with least-privileged permissions. This is different from standard Docker behavior which defaults to the root user when no USER instruction is provided.
        Example  DockerfileFROM public.ecr.aws/lambda/nodejs:22

# Copy function code
COPY index.js ${LAMBDA_TASK_ROOT}
  
# Set the CMD to your handler (could also be done as a parameter override outside of the Dockerfile)
CMD [ "index.handler" ]
      
        Build the Docker image with the docker build command. The
          following example names the image docker-image and gives it the test tag. To make your 
          image compatible with Lambda, you must use the --provenance=false option.
        docker buildx build --platform linux/amd64 --provenance=false -t docker-image:test .
        NoteThe command specifies the --platform linux/amd64 option to ensure that your container is compatible with the Lambda execution environment regardless of the  
       architecture of your build machine. If you intend to create a Lambda function using the ARM64 instruction set architecture, be sure to change the command to use the --platform linux/arm64 
       option instead.
      
          Start the Docker image with the docker run command. In this example,
              docker-image is the image name and test is the tag.
          docker run --platform linux/amd64 -p 9000:8080 docker-image:test
          This command runs the image as a container and creates a local endpoint at
            localhost:9000/2015-03-31/functions/function/invocations.
          NoteIf you built the Docker image for the ARM64 instruction set architecture, be sure to use the --platform linux/arm64 option instead of --platform linux/amd64. 
        
          From a new terminal window, post an event to the local endpoint.
          
            Linux/macOS
      		      In Linux and macOS, run the following curl command:
                curl "http://localhost:9000/2015-03-31/functions/function/invocations" -d '{}'
                This command invokes the function with an empty event and returns a response. If you're using your own function code rather than the sample function code, you might want to invoke the function with a JSON payload. Example:
                curl "http://localhost:9000/2015-03-31/functions/function/invocations" -d '{"payload":"hello world!"}'
      		
            PowerShell
                In PowerShell, run the following Invoke-WebRequest command:
                Invoke-WebRequest -Uri "http://localhost:9000/2015-03-31/functions/function/invocations" -Method Post -Body '{}' -ContentType "application/json"
                This command invokes the function with an empty event and returns a response. If you're using your own function code rather than the sample function code, you might want to invoke the function with a JSON payload. Example:
                Invoke-WebRequest -Uri "http://localhost:9000/2015-03-31/functions/function/invocations" -Method Post -Body '{"payload":"hello world!"}' -ContentType "application/json"
              
          
        
          Get the container ID.
          docker ps
        
          Use the docker kill command to stop the container. In this command, replace 3766c4ab331c with the container ID from the previous step.
          docker kill 3766c4ab331c
        To upload the image to Amazon ECR and create the Lambda function
          Run the get-login-password command to authenticate the Docker CLI to your Amazon ECR registry.
        
         
         
        
          Set the --region value to the AWS Region where you want to create the Amazon ECR repository.
        
          Replace 111122223333 with your AWS account ID.
        
          aws ecr get-login-password --region us-east-1 | docker login --username AWS --password-stdin 111122223333.dkr.ecr.us-east-1.amazonaws.com
          
        
        Create a repository in Amazon ECR using the create-repository command.
        aws ecr create-repository --repository-name hello-world --region us-east-1 --image-scanning-configuration scanOnPush=true --image-tag-mutability MUTABLE
        
        NoteThe Amazon ECR repository must be in the same AWS Region as the Lambda function.
        If successful, you see a response like this:
        {
    "repository": {
        "repositoryArn": "arn:aws:ecr:us-east-1:111122223333:repository/hello-world",
        "registryId": "111122223333",
        "repositoryName": "hello-world",
        "repositoryUri": "111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world",
        "createdAt": "2023-03-09T10:39:01+00:00",
        "imageTagMutability": "MUTABLE",
        "imageScanningConfiguration": {
            "scanOnPush": true
        },
        "encryptionConfiguration": {
            "encryptionType": "AES256"
        }
    }
}
        
      
        Copy the repositoryUri from the output in the previous step.
      
        Run the docker tag command to tag your local image into your Amazon ECR repository as the latest version. In this command: 
        
         
         
        
          docker-image:test is the name and tag of your Docker image. This is the image name and tag that you specified in the docker build command.
        
          Replace <ECRrepositoryUri> with the repositoryUri that you copied. Make sure to include :latest at the end of the URI.
        
        docker tag docker-image:test <ECRrepositoryUri>:latest
      Example:
      docker tag docker-image:test 111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest
      
      
      Run the docker push command to deploy your local image to the Amazon ECR repository. Make sure to include :latest at the end of the repository URI.
docker push 111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest

      
      Create an execution role for the function, if you don't already have one. You need the Amazon Resource Name (ARN) of the role in the next step.
      
        Create the Lambda function. For ImageUri, specify the repository URI from earlier. Make sure to include :latest at the end of the URI.
		aws lambda create-function \
  --function-name hello-world \
  --package-type Image \
  --code ImageUri=111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest \
  --role arn:aws:iam::111122223333:role/lambda-ex
  		
      NoteYou can create a function using an image in a different AWS account, as long as the image is in the same Region as the Lambda function. For more information, see  Amazon ECR cross-account permissions.  
      
      Invoke the function.
      aws lambda invoke --function-name hello-world response.json
      You should see a response like this:
{
  "ExecutedVersion": "$LATEST", 
  "StatusCode": 200
}
    
    To see the output of the function, check the response.json file.
    To update the function code, you must build the image again, upload the new image to the Amazon ECR repository, and then use the update-function-code command to deploy the image to the Lambda function.Lambda resolves the image tag to a specific image digest. This means that if you point the image tag that was used to deploy the function to a new image in Amazon ECR, Lambda doesn't automatically update the function to use the new image.To deploy the new image to the same Lambda function, you must use the update-function-code command, even if the image tag in Amazon ECR remains the same. In the following example, the --publish option creates a new version of the function using the updated container image.aws lambda update-function-code \
  --function-name hello-world \
  --image-uri 111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest \
  --publish
 
    Using an alternative base image with the runtime interface client
    If you use an OS-only base image or an alternative base image, you must include the runtime interface client in your image. The runtime interface client extends the Runtime API, which manages the interaction between Lambda and your function code.
    Install the Node.js runtime interface client using the npm package manager:
    npm install aws-lambda-ric
    You can also download the Node.js runtime interface client from GitHub. 
    The following example demonstrates how to build a container image for Node.js using a non-AWS base image. The example Dockerfile uses a buster base image. The Dockerfile includes the runtime interface client.
        To complete the steps in this section, you must have the following:
           
           
           
           
        
            AWS CLI version 2
          
            Docker (minimum version 25.0.0)
          
            The Docker buildx plugin.
          
              Node.js
          To create a container image from a non-AWS base image
        Create a directory for the project, and then switch to that directory.
        mkdir example
cd example
      
        Create a new Node.js project with npm. To accept the default options provided in the interactive experience, press Enter.
        npm init
      
        Create a new file called index.js. You can add the following sample function code to the file for testing, or use your own.
        Example  CommonJS handlerexports.handler = async (event) => {
    const response = {
        statusCode: 200,
        body: JSON.stringify('Hello from Lambda!'),
    };
    return response;
};
      
        Create a new Dockerfile. The following Dockerfile uses a buster base image instead of an AWS base image. The Dockerfile includes the runtime interface client, which makes the image compatible with Lambda. The Dockerfile uses a multi-stage build. The first stage creates a build image, which is a standard Node.js environment where the function's dependencies are installed. The second stage creates a slimmer image which includes the function code and its dependencies. This reduces the final image size.
        
           
           
          
           
        
            Set the FROM property to the base image identifier.
          
            Use the COPY command to copy the function code and runtime dependencies.
          
            Set the ENTRYPOINT to the module that you want the Docker container to run when it starts. In this case, the module is the runtime interface client.
          
            Set the CMD argument to the Lambda function handler.
          
        Note that the example Dockerfile does not include a USER instruction. When you deploy a container image to Lambda, Lambda automatically defines a default Linux user with least-privileged permissions. This is different from standard Docker behavior which defaults to the root user when no USER instruction is provided.
        Example  Dockerfile# Define custom function directory
ARG FUNCTION_DIR="/function"

FROM node:20-buster as build-image

# Include global arg in this stage of the build
ARG FUNCTION_DIR

# Install build dependencies
RUN apt-get update && \
    apt-get install -y \
    g++ \
    make \
    cmake \
    unzip \
    libcurl4-openssl-dev

# Copy function code
RUN mkdir -p ${FUNCTION_DIR}
COPY . ${FUNCTION_DIR}

WORKDIR ${FUNCTION_DIR}

# Install Node.js dependencies
RUN npm install

# Install the runtime interface client
RUN npm install aws-lambda-ric

# Grab a fresh slim copy of the image to reduce the final size
FROM node:20-buster-slim

# Required for Node runtimes which use npm@8.6.0+ because
# by default npm writes logs under /home/.npm and Lambda fs is read-only
ENV NPM_CONFIG_CACHE=/tmp/.npm

# Include global arg in this stage of the build
ARG FUNCTION_DIR

# Set working directory to function root directory
WORKDIR ${FUNCTION_DIR}

# Copy in the built dependencies
COPY --from=build-image ${FUNCTION_DIR} ${FUNCTION_DIR}

# Set runtime interface client as default command for the container runtime
ENTRYPOINT ["/usr/local/bin/npx", "aws-lambda-ric"]
# Pass the name of the function handler as an argument to the runtime
CMD ["index.handler"]
      
        Build the Docker image with the docker build command. The
          following example names the image docker-image and gives it the test tag. To make your 
          image compatible with Lambda, you must use the --provenance=false option.
        docker buildx build --platform linux/amd64 --provenance=false -t docker-image:test .
        NoteThe command specifies the --platform linux/amd64 option to ensure that your container is compatible with the Lambda execution environment regardless of the  
       architecture of your build machine. If you intend to create a Lambda function using the ARM64 instruction set architecture, be sure to change the command to use the --platform linux/arm64 
       option instead.
      Use the runtime interface emulator to locally test the image. You can build the emulator into your image or use the following procedure to install it on your local machine.To install and run the runtime interface emulator on your local machine
          From your project directory, run the following command to download the runtime interface emulator (x86-64 architecture) from GitHub and install it on your local machine.
          
            Linux/macOS
          mkdir -p ~/.aws-lambda-rie && \
    curl -Lo ~/.aws-lambda-rie/aws-lambda-rie https://github.com/aws/aws-lambda-runtime-interface-emulator/releases/latest/download/aws-lambda-rie && \
    chmod +x ~/.aws-lambda-rie/aws-lambda-rie
      			  To install the arm64 emulator, replace the GitHub repository URL in the previous command with the following:
      			https://github.com/aws/aws-lambda-runtime-interface-emulator/releases/latest/download/aws-lambda-rie-arm64
      		
            PowerShell
      				  $dirPath = "$HOME\.aws-lambda-rie"
if (-not (Test-Path $dirPath)) {
    New-Item -Path $dirPath -ItemType Directory
}
      
$downloadLink = "https://github.com/aws/aws-lambda-runtime-interface-emulator/releases/latest/download/aws-lambda-rie"
$destinationPath = "$HOME\.aws-lambda-rie\aws-lambda-rie"
Invoke-WebRequest -Uri $downloadLink -OutFile $destinationPath
      				  To install the arm64 emulator, replace the $downloadLink with the following:
      				https://github.com/aws/aws-lambda-runtime-interface-emulator/releases/latest/download/aws-lambda-rie-arm64
              
          
        
          Start the Docker image with the docker run command. Note the following:
          
             
             
          
            docker-image is the image name and test is the tag.
            
            /usr/local/bin/npx aws-lambda-ric index.handler is the ENTRYPOINT followed by the CMD from your Dockerfile.
            
          
            Linux/macOS
				    docker run --platform linux/amd64 -d -v ~/.aws-lambda-rie:/aws-lambda -p 9000:8080 \
    --entrypoint /aws-lambda/aws-lambda-rie \
    docker-image:test \
        /usr/local/bin/npx aws-lambda-ric index.handler
      		
            PowerShell
				        docker run --platform linux/amd64 -d -v "$HOME\.aws-lambda-rie:/aws-lambda" -p 9000:8080 `
--entrypoint /aws-lambda/aws-lambda-rie `
docker-image:test `
    /usr/local/bin/npx aws-lambda-ric index.handler
				    
          
          This command runs the image as a container and creates a local endpoint at
            localhost:9000/2015-03-31/functions/function/invocations.
         NoteIf you built the Docker image for the ARM64 instruction set architecture, be sure to use the --platform linux/arm64 option instead of --platform linux/amd64.   
        
          Post an event to the local endpoint.
          
            Linux/macOS
      		      In Linux and macOS, run the following curl command:
                curl "http://localhost:9000/2015-03-31/functions/function/invocations" -d '{}'
                This command invokes the function with an empty event and returns a response. If you're using your own function code rather than the sample function code, you might want to invoke the function with a JSON payload. Example:
                curl "http://localhost:9000/2015-03-31/functions/function/invocations" -d '{"payload":"hello world!"}'
      		
            PowerShell
                In PowerShell, run the following Invoke-WebRequest command:
                Invoke-WebRequest -Uri "http://localhost:9000/2015-03-31/functions/function/invocations" -Method Post -Body '{}' -ContentType "application/json"
                This command invokes the function with an empty event and returns a response. If you're using your own function code rather than the sample function code, you might want to invoke the function with a JSON payload. Example:
                Invoke-WebRequest -Uri "http://localhost:9000/2015-03-31/functions/function/invocations" -Method Post -Body '{"payload":"hello world!"}' -ContentType "application/json"
              
          
        
          Get the container ID.
          docker ps
        
          Use the docker kill command to stop the container. In this command, replace 3766c4ab331c with the container ID from the previous step.
          docker kill 3766c4ab331c
        To upload the image to Amazon ECR and create the Lambda function
          Run the get-login-password command to authenticate the Docker CLI to your Amazon ECR registry.
        
         
         
        
          Set the --region value to the AWS Region where you want to create the Amazon ECR repository.
        
          Replace 111122223333 with your AWS account ID.
        
          aws ecr get-login-password --region us-east-1 | docker login --username AWS --password-stdin 111122223333.dkr.ecr.us-east-1.amazonaws.com
          
        
        Create a repository in Amazon ECR using the create-repository command.
        aws ecr create-repository --repository-name hello-world --region us-east-1 --image-scanning-configuration scanOnPush=true --image-tag-mutability MUTABLE
        
        NoteThe Amazon ECR repository must be in the same AWS Region as the Lambda function.
        If successful, you see a response like this:
        {
    "repository": {
        "repositoryArn": "arn:aws:ecr:us-east-1:111122223333:repository/hello-world",
        "registryId": "111122223333",
        "repositoryName": "hello-world",
        "repositoryUri": "111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world",
        "createdAt": "2023-03-09T10:39:01+00:00",
        "imageTagMutability": "MUTABLE",
        "imageScanningConfiguration": {
            "scanOnPush": true
        },
        "encryptionConfiguration": {
            "encryptionType": "AES256"
        }
    }
}
        
      
        Copy the repositoryUri from the output in the previous step.
      
        Run the docker tag command to tag your local image into your Amazon ECR repository as the latest version. In this command: 
        
         
         
        
          docker-image:test is the name and tag of your Docker image. This is the image name and tag that you specified in the docker build command.
        
          Replace <ECRrepositoryUri> with the repositoryUri that you copied. Make sure to include :latest at the end of the URI.
        
        docker tag docker-image:test <ECRrepositoryUri>:latest
      Example:
      docker tag docker-image:test 111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest
      
      
      Run the docker push command to deploy your local image to the Amazon ECR repository. Make sure to include :latest at the end of the repository URI.
docker push 111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest

      
      Create an execution role for the function, if you don't already have one. You need the Amazon Resource Name (ARN) of the role in the next step.
      
        Create the Lambda function. For ImageUri, specify the repository URI from earlier. Make sure to include :latest at the end of the URI.
		aws lambda create-function \
  --function-name hello-world \
  --package-type Image \
  --code ImageUri=111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest \
  --role arn:aws:iam::111122223333:role/lambda-ex
  		
      NoteYou can create a function using an image in a different AWS account, as long as the image is in the same Region as the Lambda function. For more information, see  Amazon ECR cross-account permissions.  
      
      Invoke the function.
      aws lambda invoke --function-name hello-world response.json
      You should see a response like this:
{
  "ExecutedVersion": "$LATEST", 
  "StatusCode": 200
}
    
    To see the output of the function, check the response.json file.
    To update the function code, you must build the image again, upload the new image to the Amazon ECR repository, and then use the update-function-code command to deploy the image to the Lambda function.Lambda resolves the image tag to a specific image digest. This means that if you point the image tag that was used to deploy the function to a new image in Amazon ECR, Lambda doesn't automatically update the function to use the new image.To deploy the new image to the same Lambda function, you must use the update-function-code command, even if the image tag in Amazon ECR remains the same. In the following example, the --publish option creates a new version of the function using the updated container image.aws lambda update-function-code \
  --function-name hello-world \
  --image-uri 111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest \
  --publish
  Document ConventionsDeploy .zip file archivesLayersDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS Serverless Application ModelDeveloper GuideInitialize a new serverless applicationOptions for sam initTroubleshootingExamplesLearn moreNext stepsCreate your application in AWS SAMAfter completing Getting started
		and reading How to use AWS Serverless Application Model (AWS SAM), you will be ready to create an 
		AWS SAM project in your developer environment. Your AWS SAM project will serve as the 
		starting point for writing your serverless application. For a list of AWS SAM CLI sam init command options, see sam init.The AWS Serverless Application Model Command Line Interface (AWS SAM CLI) sam init command provides options to initialize a new 
		serverless application that consists of:
		 
		 
		 
	
			An AWS SAM template to define your infrastructure code.
		
			A folder structure that organizes your application.
		
			Configuration for your AWS Lambda functions.
		To create an AWS SAM project, refer to the topics in this sections.TopicsInitialize a new serverless applicationOptions for sam initTroubleshootingExamplesLearn moreNext steps
		Initialize a new serverless application
		To initialize a new serverless application using the AWS SAM CLI
				cd to a starting directory.
			
				Run the following at the command line:
				$ sam init
			
				The AWS SAM CLI will guide you through an interactive flow to create a new serverless application.
				NoteAs detailed in Tutorial: Deploy a Hello World application with AWS SAM, this command 
					initializes your serverless application, creating your project directory. This directory will contain several files and folders. The most important 
					file is template.yaml. This is your AWS SAM template. Your version of python must match the version of python listed in the 
					template.yaml file that the sam init command created.
			
		
		 
			Choose a starting template
			A template consists of the following:
			
				 
				 
			
					An AWS SAM template for your infrastructure code.
				
					A starting project directory that organizes your project files. For example, this may include:
					
						 
						 
						 
						 
						 
					
							A structure for your Lambda function code and their dependencies.
						
							An events folder that contains test events for local testing.
						
							A tests folder to support unit testing.
						
							A samconfig.toml file to configure project settings.
						
							A ReadMe file and other basic starting project files.
						
					The following is an example of a starting project directory:
					sam-app
├── README.md
├── __init__.py
├── events
│   └── event.json
├── hello_world
│   ├── __init__.py
│   ├── app.py
│   └── requirements.txt
├── samconfig.toml
├── template.yaml
└── tests
    ├── __init__.py
    ├── integration
    │   ├── __init__.py
    │   └── test_api_gateway.py
    ├── requirements.txt
    └── unit
        ├── __init__.py
        └── test_handler.py
				
			You can select from a list of available AWS Quick Start Templates or provide your own 
				Custom Template Location.
			To choose an AWS Quick Start Template
					When prompted, select AWS Quick Start Templates.
				
					Select an AWS Quick Start template to begin with. The following is an example:
					Which template source would you like to use?
    1 - AWS Quick Start Templates
    2 - Custom Template Location
Choice: 1

Choose an AWS Quick Start application template
    1 - Hello World Example
    2 - Multi-step workflow
    3 - Serverless API
    4 - Scheduled task
    5 - Standalone function
    6 - Data processing
    7 - Hello World Example With Powertools
    8 - Infrastructure event management
    9 - Serverless Connector Hello World Example
    10 - Multi-step workflow with Connectors
    11 - Lambda EFS example
    12 - DynamoDB Example
    13 - Machine Learning
Template: 4
				
			To choose your own custom template location
					When prompted, select the Custom Template Location.
					Which template source would you like to use?
    1 - AWS Quick Start Templates
    2 - Custom Template Location
Choice: 2
				
					The AWS SAM CLI will prompt you to provide a template location.
					Template location (git, mercurial, http(s), zip, path):
					Provide any of the following locations to your template .zip file archive:
					
						 
						 
						 
					
							GitHub repository – The path to the 
								.zip file in your GitHub repository. The file must be in the root of your 
								repository.
						
							Mercurial repository – The path to the 
								.zip file in your Mercurial repository. The file must be in the root of your repository.
						
							.zip path – An HTTPS or local path to your .zip file.
						
				
					The AWS SAM CLI will initialize your serverless application using your custom template.
				
		 
		
		 
			Choose a runtime
			When you choose an AWS Quick Start Template, the AWS SAM CLI prompts you to select a runtime 
				for your Lambda functions. The list of options displayed by the AWS SAM CLI are the runtimes supported natively by 
				Lambda.
			
				 
				 
			
					The runtime provides a 
						language-specific environment that runs in an execution environment.
				
					When deployed to the AWS Cloud, the Lambda service invokes your function in an execution environment.
				
			You can use any other programming language with a custom runtime. To do this, you need to manually create your
				starting application structure. You can then use sam init to quickly initialize your application by
				configuring a custom template location.
			From your selection, the AWS SAM CLI creates the starting directory for your Lambda function code and 
				dependencies.
			If Lambda supports multiple dependency managers for your runtime, you will be prompted to choose your preferred 
				dependency manager.
		 
		
		 
			Choose a package type
			When you choose an AWS Quick Start Template and a runtime, the 
				AWS SAM CLI prompts you to select a package type. The package type determines how your Lambda 
				functions are deployed to use with the Lambda service. The two supported package types are:
			
				 
				 
			
					Container image – Contains the base operating system, the runtime, 
						Lambda extensions, your application code, and its dependencies.
				
					.zip file archive – Contains your application code and its 
						dependencies.
				
			To learn more about deployment package types, see Lambda deployment packages in the 
				AWS Lambda Developer Guide.
			The following is an example directory structure of an application with a Lambda function packaged as a container 
				image. The AWS SAM CLI downloads the image and creates a Dockerfile in the function's directory to
				specify the image.
			sam-app
├── README.md
├── __init__.py
├── events
│   └── event.json
├── hello_world
│   ├── Dockerfile
│   ├── __init__.py
│   ├── app.py
│   └── requirements.txt
├── samconfig.toml
├── template.yaml
└── tests
    ├── __init__.py
    └── unit
        ├── __init__.py
        └── test_handler.py
			The following is an example directory structure of an application with a function packaged as a .zip file 
				archive.
			sam-app
├── README.md
├── __init__.py
├── events
│   └── event.json
├── hello_world
│   ├── __init__.py
│   ├── app.py
│   └── requirements.txt
├── samconfig.toml
├── template.yaml
└── tests
    ├── __init__.py
    ├── integration
    │   ├── __init__.py
    │   └── test_api_gateway.py
    ├── requirements.txt
    └── unit
        ├── __init__.py
        └── test_handler.py
		 
		
		 
			Configure AWS X-Ray tracing
			You can choose to activate AWS X-Ray tracing. To learn more, see What is AWS X-Ray? in the 
				AWS X-Ray Developer Guide.
			If you activate, the AWS SAM CLI configures your AWS SAM template. The following is an example:
			Globals:
  Function:
    ...
    Tracing: Active
  Api:
    TracingEnabled: True
		 
		
		 
			Configure monitoring with Amazon CloudWatch Application Insights
			You can choose to activate monitoring using Amazon CloudWatch Application Insights. To learn more, see Amazon CloudWatch 
				Application Insights in the Amazon CloudWatch User Guide.
			If you activate, the AWS SAM CLI configures your AWS SAM template. The following is an example:
			Resources:
  ApplicationResourceGroup:
    Type: AWS::ResourceGroups::Group
    Properties:
      Name:
        Fn::Join:
        - ''
        - - ApplicationInsights-SAM-
          - Ref: AWS::StackName
      ResourceQuery:
        Type: CLOUDFORMATION_STACK_1_0
  ApplicationInsightsMonitoring:
    Type: AWS::ApplicationInsights::Application
    Properties:
      ResourceGroupName:
        Fn::Join:
        - ''
        - - ApplicationInsights-SAM-
          - Ref: AWS::StackName
      AutoConfigurationEnabled: 'true'
    DependsOn: ApplicationResourceGroup
		 
		
		 
			Name your application
			Provide a name for your application. The AWS SAM CLI creates a top-level folder for your application using this 
				name.
		 
	 
		Options for sam init
		The following are some of the main options you can use with the sam init command. For a list of all 
			options, see sam init.
		
		 
			Initialize an application using a custom template location
			Use the --location option and provide a supported custom template location. The following is an 
				example:
			$ sam init --location https://github.com/aws-samples/sessions-with-aws-sam/raw/master/starter-templates/web-app.zip
		 
		
		 
			Initialize an application without the interactive 
					flow
			Use the --no-interactive option and provide your configuration choices at the command line to skip 
				the interactive flow. The following is an example:
			$ sam init --no-interactive --runtime go1.x --name go-demo --dependency-manager mod --app-template hello-world
		 
	 
		Troubleshooting
		To troubleshoot the AWS SAM CLI, see AWS SAM CLI troubleshooting.
	 
		Examples
		
		 
			Initialize a new serverless application using the 
					Hello World AWS Starter Template
			For this example, see 
				Step 1: Initialize the sample Hello World application in Tutorial: Deploying a Hello World 
					application.
		 
		
		 
			Initialize a new serverless application with a custom 
					template location
			The following are examples of providing a GitHub location to your custom template:
			$ sam init --location gh:aws-samples/cookiecutter-aws-sam-python
$ sam init --location git+sh://git@github.com/aws-samples/cookiecutter-aws-sam-python.git
$ sam init --location hg+ssh://hg@bitbucket.org/repo/template-name
			The following is an example of a local file path:
			$ sam init --location /path/to/template.zip
			The following is an example of a path reachable by HTTPS:
			$ sam init --location https://github.com/aws-samples/sessions-with-aws-sam/raw/master/starter-templates/web-app.zip
		 
	 
		Learn more
		To learn more about using the sam init command, see the following:
		
			 
			 
		
				Learning AWS SAM: sam init
				 – Serverless Land "Learning AWS SAM" series on YouTube.
			
				Structuring serverless 
					applications for use with the AWS SAM CLI (Sessions with SAM S2E7) – Sessions with AWS SAM
					series on YouTube.
			
	 
		Next steps
		Now that you have created your AWS SAM project, you are ready to start authoring your application. 
			See Define your infrastructure with AWS SAM for detailed instructions on the tasks you need to complete to do this.
	Document ConventionsDevelop your applicationDefine your infrastructureDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuidePrerequisitesStep 1: Set up your projectStep 2: Define the stackStep 3: Create the functionStep 4: Deploy the stackStep 5: Test the functionStep 6: Clean upNext stepsDeploying Lambda functions with the AWS CDKThe AWS Cloud Development Kit (AWS CDK) is an infrastructure as code (IaC) framework that you can use to define
        AWS cloud infrastructure by using a programming language of your choosing. To define your
        own cloud infrastructure, you first write an app (in one of the CDK's supported
        languages) that contains one or more stacks. Then, you synthesize it to an AWS CloudFormation template
        and deploy your resources to your AWS account. Follow the steps in this topic to deploy a
        Lambda function that returns an event from an Amazon API Gateway endpoint.The AWS Construct Library, included with the CDK, provides modules that you can
        use to model the resources that AWS services provide. For popular services, the library
        provides curated constructs with smart defaults and best practices. You can use the aws_lambda module to define your function and supporting resources with just a few lines of code. 
        Prerequisites
        Before starting this tutorial, install the AWS CDK by running the following command.
        npm install -g aws-cdk
     
        Step 1: Set up your AWS CDK project
        Create a directory for your new AWS CDK app and initialize the project.
                    
            JavaScript
                    mkdir hello-lambda
cd hello-lambda
cdk init --language javascript
                
            TypeScript
                    mkdir hello-lambda
cd hello-lambda
cdk init --language typescript
                
            Python
                    mkdir hello-lambda
cd hello-lambda
cdk init --language python
                    After the project starts, activate the project's virtual environment and install the baseline dependencies for AWS CDK.
                    source .venv/bin/activate
python -m pip install -r requirements.txt
                
            Java
                    mkdir hello-lambda
cd hello-lambda
cdk init --language java
                    Import this Maven project to your Java integrated development environment (IDE). For example, in Eclipse, choose File, Import, Maven, Existing Maven Projects.
                
            C#
                    mkdir hello-lambda
cd hello-lambda
cdk init --language csharp
                
        
        NoteThe AWS CDK application template uses the name of the project directory to generate
                names for source files and classes. In this example, the directory is named
                hello-lambda. If you use a different project directory name,
                your app won't match these instructions.
        AWS CDK v2 includes stable constructs for all AWS services in a single package that's
            called aws-cdk-lib. This package is installed as a dependency when you
            initialize the project. When working with certain programming languages, the package is
            installed when you build the project for the first time.
     
        Step 2: Define the AWS CDK stack
        A CDK stack is a collection of one or more constructs, which define AWS resources.
            Each CDK stack represents an AWS CloudFormation stack in your CDK app.
        To define your CDK, stack follow the instructions for your preferred programming language. This stack defines the following:
        
             
             
             
             
        
                The function's logical name: MyFunction
            
                The location of the function code, specified in the code property. For more information, see Handler code in the AWS Cloud Development Kit (AWS CDK) API Reference.
            
                The REST API's logical name: HelloApi
            
                The API Gateway endpoint's logical name: ApiGwEndpoint
            
        Note that all of the CDK stacks in this tutorial use the Node.js runtime for the Lambda function. You can use different programming languages for the CDK stack and the Lambda function to leverage the strengths of each language. For example, you can use TypeScript for the CDK stack to leverage the benefits of static typing for your infrastructure code. You can use JavaScript for the Lambda function to take advantage of the flexibility and rapid development of a dynamically typed language.
        
            JavaScript
                    Open the lib/hello-lambda-stack.js file and replace the contents with the following.
                    const { Stack } = require('aws-cdk-lib');
const lambda = require('aws-cdk-lib/aws-lambda');
const apigw = require('aws-cdk-lib/aws-apigateway');

class HelloLambdaStack extends Stack {
  /**
   *
   * @param {Construct} scope
   * @param {string} id
   * @param {StackProps=} props
   */
  constructor(scope, id, props) {
    super(scope, id, props);
    const fn = new lambda.Function(this, 'MyFunction', {
      code: lambda.Code.fromAsset('lib/lambda-handler'),
      runtime: lambda.Runtime.NODEJS_LATEST,
      handler: 'index.handler'
    });

    const endpoint = new apigw.LambdaRestApi(this, 'MyEndpoint', {
      handler: fn,
      restApiName: "HelloApi"
    });

  }
}

module.exports = { HelloLambdaStack }
                
            TypeScript
                    Open the lib/hello-lambda-stack.ts file and replace the contents with the following.
                    import * as cdk from 'aws-cdk-lib';
import { Construct } from 'constructs';
import * as apigw from "aws-cdk-lib/aws-apigateway";
import * as lambda from "aws-cdk-lib/aws-lambda";
import * as path from 'node:path';

export class HelloLambdaStack extends cdk.Stack {
  constructor(scope: Construct, id: string, props?: cdk.StackProps){
    super(scope, id, props)
    const fn = new lambda.Function(this, 'MyFunction', {
      runtime: lambda.Runtime.NODEJS_LATEST,
      handler: 'index.handler',
      code: lambda.Code.fromAsset(path.join(__dirname, 'lambda-handler')),
    });

    const endpoint = new apigw.LambdaRestApi(this, `ApiGwEndpoint`, {
      handler: fn,
      restApiName: `HelloApi`,
    });

  }
}
                            
            Python
                    Open the /hello-lambda/hello_lambda/hello_lambda_stack.py file and replace the contents with the following.
                    from aws_cdk import (
    Stack,
    aws_apigateway as apigw,
    aws_lambda as _lambda
)
from constructs import Construct

class HelloLambdaStack(Stack):

    def __init__(self, scope: Construct, construct_id: str, **kwargs) -> None:
        super().__init__(scope, construct_id, **kwargs)

        fn = _lambda.Function(
            self,
            "MyFunction",
            runtime=_lambda.Runtime.NODEJS_LATEST,
            handler="index.handler",
            code=_lambda.Code.from_asset("lib/lambda-handler")
        )

        endpoint = apigw.LambdaRestApi(
            self,
            "ApiGwEndpoint",
            handler=fn,
            rest_api_name="HelloApi"
        )
                       
            Java
                    Open the /hello-lambda/src/main/java/com/myorg/HelloLambdaStack.java file and replace the contents with the following.
                    package com.myorg;

import software.constructs.Construct;
import software.amazon.awscdk.Stack;
import software.amazon.awscdk.StackProps;
import software.amazon.awscdk.services.apigateway.LambdaRestApi;
import software.amazon.awscdk.services.lambda.Function;

public class HelloLambdaStack extends Stack {
    public HelloLambdaStack(final Construct scope, final String id) {
        this(scope, id, null);
    }

    public HelloLambdaStack(final Construct scope, final String id, final StackProps props) {
        super(scope, id, props);

        Function hello = Function.Builder.create(this, "MyFunction")
                            .runtime(software.amazon.awscdk.services.lambda.Runtime.NODEJS_LATEST)
                            .code(software.amazon.awscdk.services.lambda.Code.fromAsset("lib/lambda-handler"))
                            .handler("index.handler")
                            .build();

        LambdaRestApi api = LambdaRestApi.Builder.create(this, "ApiGwEndpoint")
                                .restApiName("HelloApi")
                                .handler(hello)
                                .build();

    }
}
                
            C#
                    Open the src/HelloLambda/HelloLambdaStack.cs file and replace the contents with the following.
                    using Amazon.CDK;
using Amazon.CDK.AWS.APIGateway;
using Amazon.CDK.AWS.Lambda;
using Constructs;

namespace HelloLambda
{
    public class HelloLambdaStack : Stack
    {
        internal HelloLambdaStack(Construct scope, string id, IStackProps props = null) : base(scope, id, props)
        {
            var fn = new Function(this, "MyFunction", new FunctionProps
            {
                Runtime = Runtime.NODEJS_LATEST,
                Code = Code.FromAsset("lib/lambda-handler"),
                Handler = "index.handler"
            });

            var api = new LambdaRestApi(this, "ApiGwEndpoint", new LambdaRestApiProps
            {
                Handler = fn
            });
        }
    }
}
                
        
     
            Step 3: Create the Lambda function code
       
               From the root of your project (hello-lambda), create the /lib/lambda-handler directory for the Lambda function code. This directory is specified in the code property of your AWS CDK stack.
           
               Create a new filed called index.js in the /lib/lambda-handler directory. Paste the following code into the file. The function extracts specific properties from the API request and returns them as a JSON response.
               exports.handler = async (event) => {
  // Extract specific properties from the event object
  const { resource, path, httpMethod, headers, queryStringParameters, body } = event;
  const response = {
    resource,
    path,
    httpMethod,
    headers,
    queryStringParameters,
    body,
  };
  return {
    body: JSON.stringify(response, null, 2),
    statusCode: 200,
  };
};
           
         
            Step 4: Deploy the AWS CDK stack
            
                    From the root of your project, run the cdk synth command:
                    cdk synth    
                    This command synthesizes an AWS CloudFormation template from your CDK stack. The template is an approximately 400-line YAML
                        file, similar to the following. 
                    NoteIf you get the following error, make sure that you are in the root of your project directory.--app is required either in command-line, in cdk.json or in ~/.cdk.json
                    Example AWS CloudFormation templateResources:
  MyFunctionServiceRole3C357FF2:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Action: sts:AssumeRole
            Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
        Version: "2012-10-17"
      ManagedPolicyArns:
        - Fn::Join:
            - ""
            - - "arn:"
              - Ref: AWS::Partition
              - :iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
    Metadata:
      aws:cdk:path: HelloLambdaStack/MyFunction/ServiceRole/Resource
  MyFunction1BAA52E7:
    Type: AWS::Lambda::Function
    Properties:
      Code:
        S3Bucket:
          Fn::Sub: cdk-hnb659fds-assets-${AWS::AccountId}-${AWS::Region}
        S3Key: ab1111111cd32708dc4b83e81a21c296d607ff2cdef00f1d7f48338782f92l3901.zip
      Handler: index.handler
      Role:
        Fn::GetAtt:
          - MyFunctionServiceRole3C357FF2
          - Arn
      Runtime: nodejs22.x
      ...
                
                    Run the cdk deploy command:
                    cdk deploy    
                    Wait while your resources are created. The final output includes the URL for your API Gateway endpoint. Example:
                    Outputs:
HelloLambdaStack.ApiGwEndpoint77F417B1 = https://abcd1234.execute-api.us-east-1.amazonaws.com/prod/
                    
                
     
        Step 5: Test the function
        To invoke the Lambda function, copy the API Gateway endpoint and paste it into a web browser or run a curl command:
        curl -s https://abcd1234.execute-api.us-east-1.amazonaws.com/prod/
        
        The response is a JSON representation of selected properties from the original event object, which contains information about the request made to the API Gateway endpoint. Example:
        {
  "resource": "/",
  "path": "/",
  "httpMethod": "GET",
  "headers": {
    "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7",
    "Accept-Encoding": "gzip, deflate, br, zstd",
    "Accept-Language": "en-US,en;q=0.9",
    "CloudFront-Forwarded-Proto": "https",
    "CloudFront-Is-Desktop-Viewer": "true",
    "CloudFront-Is-Mobile-Viewer": "false",
    "CloudFront-Is-SmartTV-Viewer": "false",
    "CloudFront-Is-Tablet-Viewer": "false",
    "CloudFront-Viewer-ASN": "16509",
    "CloudFront-Viewer-Country": "US",
    "Host": "abcd1234.execute-api.us-east-1.amazonaws.com",
     ...       
     
        Step 6: Clean up your resources
        The API Gateway endpoint is publicly accessible. To prevent unexpected charges, run the cdk destroy command to delete the stack and all associated resources.
        cdk destroy
     
        Next steps
        
        For information about writing AWS CDK apps in your language of choice, see the
            following:
        
            TypeScript
                    Working with the AWS CDK
                        in TypeScript
                
            
            JavaScript
                    Working with the AWS CDK
                        in JavaScript
                
            
            Python
                    Working with the AWS CDK in Python
                
            
            Java
                    Working with the AWS CDK in Java
                
            
            C#
                    Working with the AWS CDK in C#
                
            Go
                    Working with the AWS CDK in Go
                
        
    Document ConventionsInfrastructure as code (IaC)Lambda runtimesDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideNode.js initializationRuntime-included SDK versionsUsing keep-aliveCA certificate loadingBuilding Lambda functions with Node.jsYou can run JavaScript code with Node.js in AWS Lambda. Lambda provides runtimes for Node.js that run your code to process events. Your code runs
    in an environment that includes the AWS SDK for JavaScript, with credentials from an AWS Identity and Access Management (IAM) role that you manage. To learn more 
    about the SDK versions included with the Node.js runtimes, see Runtime-included SDK versions.Lambda supports the following Node.js runtimes.
      
        Name
        Identifier
        Operating system
        Deprecation date
        Block function create
        Block function update
      
    
      
        
          Node.js 22
        
        
          nodejs22.x
        
        
          Amazon Linux 2023
        

        
                      Apr 30, 2027
            
        
        
                      Jun 1, 2027
            
        
        
                      Jul 1, 2027
            
        

      
      
        
          Node.js 20
        
        
          nodejs20.x
        
        
          Amazon Linux 2023
        

        
                      Apr 30, 2026
            
        
        
                      Jun 1, 2026
            
        
        
                      Jul 1, 2026
            
        

      
      
        
          Node.js 18
        
        
          nodejs18.x
        
        
          Amazon Linux 2
        

        
                      Sep 1, 2025
            
        
        
                      Oct 1, 2025
            
        
        
                      Nov 1, 2025
            
        

      
    To create a Node.js function
      Open the Lambda console.
    
      Choose Create function.
    
      Configure the following settings:
      
         
         
      
          Function name: Enter a name for the function.
        
          Runtime: Choose Node.js 22.x.
        
    
      Choose Create function.
    The console creates a Lambda function with a single source file named index.mjs. You can edit this file and add more files in the built-in code editor. In the DEPLOY section, choose Deploy to update your function's code. Then, to run your code, choose Create test event in the TEST EVENTS section.The index.mjs file exports a function named handler that takes an event object and a
    context object. This is the handler function that Lambda calls when the
    function is invoked. The Node.js function runtime gets invocation events from Lambda and passes them to the
    handler. In the function configuration, the handler value is index.handler.When you save your function code, the Lambda console creates a .zip file archive deployment package. 
   When you develop your function code outside of the console (using an IDE) you need to create a
      deployment package to upload your code to the Lambda function.The function runtime passes a context object to the handler, in addition to the invocation event. The context object contains additional information about the invocation, the
    function, and the execution environment. More information is available from environment variables.Your Lambda function comes with a CloudWatch Logs log group. The function runtime sends details about each invocation to
    CloudWatch Logs. It relays any logs that your function outputs during invocation. If
    your function returns an error, Lambda formats the error and returns it to the
    invoker.TopicsNode.js initializationRuntime-included SDK versionsUsing keep-alive for TCP connectionsCA certificate loadingDefine Lambda function handler in Node.jsDeploy Node.js Lambda functions with .zip file archivesDeploy Node.js Lambda functions with container imagesWorking with layers for Node.js Lambda functionsUsing the Lambda context object to retrieve Node.js function informationLog and monitor Node.js Lambda functionsInstrumenting Node.js code in AWS Lambda
    Node.js initialization
    Node.js has a unique event loop model that causes its initialization behavior to be different from other runtimes. 
      Specifically, Node.js uses a non-blocking I/O model that supports asynchronous operations. 
      This model allows Node.js to perform efficiently for most workloads. 
      For example, if a Node.js function makes a network call, that request may be designated as an asynchronous operation and placed into a callback queue. 
      The function may continue to process other operations within the main call stack without getting blocked by waiting for the network call to return. 
      Once the network call is completed, its callback is executed and then removed from the callback queue.
    
    
      Some initialization tasks may run asynchronously. These asynchronous tasks are not guaranteed to complete execution prior to an invocation. 
      For example, code that makes a network call to fetch a parameter from AWS Parameter Store may not be complete by the time Lambda executes the handler function. 
      As a result, the variable may be null during an invocation. 
      To avoid this, ensure that variables and other asynchronous code are fully initialized before continuing with the rest of the function's core business logic.
    
    Alternatively, you can designate your function code as an ES module, allowing you to use await at the top level
      of the file, outside the scope of your function handler. When you await every Promise, the asynchronous
      initialization code completes before handler invocations, maximizing the effectiveness of
      provisioned concurrency in reducing cold start latency. For more information and an example,
      see Using Node.js ES modules and top-level await in AWS Lambda.
     
      Designating a function handler as an ES module
      By default, Lambda treats files with the .js suffix as CommonJS modules. Optionally, you can designate your
        code as an ES module. You can do this in two ways: specifying the type as module in the function's
        package.json file, or by using the .mjs file name extension. In the first approach, your function
        code treats all .js files as ES modules, while in the second scenario, only the file you specify with .mjs
        is an ES module. You can mix ES modules and CommonJS modules by naming them .mjs and .cjs respectively,
        as .mjs files are always ES modules and .cjs files are always CommonJS modules.
      Lambda searches folders in the NODE_PATH environment variable when loading
        ES modules. You can load the AWS SDK that's included in the runtime using ES module import
        statements. You can also load ES modules from layers.
      
        ES module example
            Example  – ES module handlerconst url = "https://aws.amazon.com/";

export const handler = async(event) => {
    try {
        const res = await fetch(url);
        console.info("status", res.status);
        return res.status;
    }
    catch (e) {
        console.error(e);
        return 500;
    }
};
          
        CommonJS module example
            Example  – CommonJS module handlerconst https = require("https");
let url = "https://aws.amazon.com/";

exports.handler = async function (event) {
  let statusCode;
  await new Promise(function (resolve, reject) {
    https.get(url, (res) => {
        statusCode = res.statusCode;
        resolve(statusCode);
      }).on("error", (e) => {
        reject(Error(e));
      });
  });
  console.log(statusCode);
  return statusCode;
};
          
      
        
   
    Runtime-included SDK versions
    All supported Lambda Node.js runtimes include a specific minor version of the AWS SDK for JavaScript v3, not the latest version. The specific minor version that's included in the runtime depends on the runtime version and your AWS Region. To find the specific version of the SDK included in the runtime that you're using, create a Lambda function with the following code.
    Example index.mjsimport packageJson from '@aws-sdk/client-s3/package.json' with { type: 'json' };

export const handler = async () => ({ version: packageJson.version });This returns a response in the following format:{
  "version": "3.632.0"
}
    For more information, see Using the SDK for JavaScript v3 in your handler.
   
    Using keep-alive for TCP connections
    The default Node.js HTTP/HTTPS agent creates a new TCP connection for every new request. To avoid the cost of
      establishing new connections, keep-alive is enabled by default in nodejs18.x and later Lambda runtimes. Keep-alive can reduce request times for Lambda functions that make multiple API calls using the SDK.
    To disable keep-alive, see
      Reusing connections with keep-alive in Node.js in the AWS SDK for JavaScript 3.x Developer Guide. For more information about using keep-alive, see
      HTTP keep-alive is on by default in modular AWS SDK for JavaScript
      on the AWS Developer Tools Blog.
   
    CA certificate loading
    For Node.js runtime versions up to Node.js 18, Lambda automatically loads Amazon-specific CA (certificate
      authority) certificates to make it easier for you to create functions that interact with other AWS services.
      For example, Lambda includes the Amazon RDS certificates necessary for validating the
      server identity certificate
      installed on your Amazon RDS database. This behavior can have a performance impact during cold starts.
    Starting with Node.js 20, Lambda no longer loads additional CA certificates by default. The Node.js 20 runtime
      contains a certificate file with all Amazon CA certificates located at /var/runtime/ca-cert.pem. To
      restore the same behavior from Node.js 18 and earlier runtimes, set the NODE_EXTRA_CA_CERTS
      environment variable to /var/runtime/ca-cert.pem.
    For optimal performance, we recommend bundling only the certificates that you need with your deployment package
      and loading them via the NODE_EXTRA_CA_CERTS environment variable. The certificates file should
      consist of one or more trusted root or intermediate CA certificates in PEM format. For example, for RDS, include
      the required certificates alongside your code as certificates/rds.pem. Then, load the certificates
      by setting NODE_EXTRA_CA_CERTS to /var/task/certificates/rds.pem.
  Document ConventionsMonitoring concurrencyHandlerDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS SDK for JavaScriptDeveloper Guide for SDK Version 3 The AWS SDK for JavaScript V3 API
            Reference Guide describes in detail all the API operations for the AWS SDK for JavaScript
         version 3 (V3). Create service client requestsMaking requests to AWS service clients is straightforward. Version 3 (V3) of the SDK for JavaScript
      enables you to send requests. NoteYou can also perform operations using version 2 (V2) commands when using the V3 of the
        SDK for JavaScript. For more information, see Using v2 commands.To send a request:
        Initialize a client object with the desired configuration, such as a specific AWS
          Region.
      
        (Optional) Create a request JSON object with the values for the request, such as the
          name of a specific Amazon S3 bucket. You can examine the parameters for the request by looking
          at the API Reference topic for the interface with the name associated with the client
          method. For example, if you use the AbcCommand client method,
          the request interface is AbcInput.
      
        Initialize a service command, optionally, with the request object as input.
      
        Call send on the client with the command object as input.
      For example, to list your Amazon DynamoDB tables in us-west-2, you can do it with
      async/await.import {
  DynamoDBClient,
  ListTablesCommand
} from "@aws-sdk/client-dynamodb";

(async function () {
  const dbClient = new DynamoDBClient({ region: 'us-west-2' });
  const command = new ListTablesCommand({});

  try {
    const results = await dbClient.send(command);
    console.log(results.TableNames.join('\n'));
  } catch (err) {
    console.error(err);
  }
})();Document ConventionsUse a callback functionHandle service client responsesDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nSkip to main content\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideRuntime environment lifecycleCold starts and latencyReducing cold starts with Provisioned ConcurrencyOptimizing static initializationUnderstanding the Lambda execution environment lifecycle
      Lambda invokes your function in an execution environment, which provides a secure and isolated runtime
      environment. The execution environment manages the resources required to run your function. The execution
      environment also provides lifecycle support for the function's runtime and any external extensions associated with your function.
    The function's runtime communicates with Lambda using the Runtime API.
    Extensions communicate with Lambda using the Extensions API.
    Extensions can also receive log messages and other telemetry from the function by using the Telemetry API.
    
         
          
         
         
    When you create your Lambda function, you specify configuration information, such as the amount of memory
    available and the maximum execution time allowed for your function. Lambda uses this information to set up the
    execution environment.The function's runtime and each external extension are processes that run within the execution environment.
    Permissions, resources, credentials, and environment variables are shared between the function and the
    extensions.TopicsLambda execution environment lifecycleCold starts and latencyReducing cold starts with Provisioned ConcurrencyOptimizing static initialization
      Lambda execution environment lifecycle    
        
           
            
           
           
        
        Each phase starts with an event that Lambda sends to the runtime and to all registered extensions. The
        runtime and each extension indicate completion by sending a Next API request. Lambda freezes the
        execution environment when the runtime and each extension have completed and there are no pending events.
        TopicsInit phaseFailures during the Init phaseRestore phase (Lambda SnapStart only)Invoke phaseFailures during the invoke phaseShutdown phase
       
        Init phase
        In the Init phase, Lambda performs three tasks:
        
           
           
           
           
        
            Start all extensions (Extension init)
          
            Bootstrap the runtime (Runtime init)
          
            Run the function's static code (Function init)
          
            Run any before-checkpoint runtime hooks (Lambda SnapStart only)
          
        The Init phase ends when the runtime and all extensions signal that they are ready by sending a
            Next API request. The Init phase is limited to 10 seconds. If all three tasks do not
          complete within 10 seconds, Lambda retries the Init phase at the time of the first function
          invocation with the configured function timeout.
          When Lambda SnapStart is activated, the Init phase happens when you publish a function version. Lambda saves a snapshot of the memory and disk state of the initialized execution environment, persists the encrypted snapshot, and caches it for low-latency access. If you have a before-checkpoint runtime hook, then the code runs at the end of Init phase.
          NoteThe 10-second timeout doesn't apply to functions that are using provisioned concurrency
              or SnapStart. For provisioned concurrency and SnapStart functions, your initialization code
              can run for up to 15 minutes. The time limit is 130 seconds or the configured function
              timeout (maximum 900 seconds), whichever is higher.
        When you use provisioned concurrency,
          Lambda initializes the execution environment when you configure the PC settings for a function. Lambda also ensures that
          initialized execution environments are always available in advance of invocations. You may see gaps between your function's
          invocation and initialization phases. Depending on your function's runtime and memory configuration, you may also see variable
          latency on the first invocation on an initialized execution environment.
        For functions using on-demand concurrency, Lambda may occasionally initialize execution environments ahead of
          invocation requests. When this happens, you may also observe a time gap between your function's initialization and
          invocation phases. We recommend you to not take a dependency on this behavior.
       
       
        Failures during the Init phase
        If a function crashes or times out during the Init phase, Lambda emits error information in the INIT_REPORT log.
    Example  — INIT_REPORT log for timeoutINIT_REPORT Init Duration: 1236.04 ms Phase: init Status: timeout       
    Example  — INIT_REPORT log for extension failureINIT_REPORT Init Duration: 1236.04 ms Phase: init Status: error Error Type: Extension.Crash		
        If the Init phase is successful, Lambda doesn't emit the INIT_REPORT log unless SnapStart or 
          provisioned concurrency is enabled. SnapStart and provisioned concurrency functions always emit INIT_REPORT. 
          For more information, see Monitoring for Lambda SnapStart.
        
       
        Restore phase (Lambda SnapStart only)
        When you first invoke a SnapStart function and as the function scales up, Lambda resumes new execution environments from the persisted snapshot instead of initializing the function from scratch. If you have an after-restore runtime hook, the code runs at the end of the Restore phase. You are charged for the duration of after-restore runtime hooks. The runtime must load and after-restore runtime hooks must complete within the timeout limit (10 seconds). Otherwise, you'll get a SnapStartTimeoutException. When the Restore phase completes, Lambda invokes the function handler (the Invoke phase).
         
          Failures during the Restore phase
          If the Restore phase fails, Lambda emits error information in the RESTORE_REPORT log.
      Example  — RESTORE_REPORT log for timeoutRESTORE_REPORT Restore Duration: 1236.04 ms Status: timeout
      Example  — RESTORE_REPORT log for runtime hook failureRESTORE_REPORT Restore Duration: 1236.04 ms Status: error Error Type: Runtime.ExitError		
        For more information about the RESTORE_REPORT log, see Monitoring for Lambda SnapStart.
         
       
       
        Invoke phase
        When a Lambda function is invoked in response to a Next API request, Lambda sends an
            Invoke event to the runtime and to each extension.
        The function's timeout setting limits the duration of the entire Invoke phase. For example, if
          you set the function timeout as 360 seconds, the function and all extensions need to complete within 360
          seconds. Note that there is no independent post-invoke phase. The duration is the sum of all invocation time
          (runtime + extensions) and is not calculated until the function and all extensions have finished
          executing.
        The invoke phase ends after the runtime and all extensions signal that they are done by sending a
            Next API request.
       
       
        Failures during the invoke phase
        If the Lambda function crashes or times out during the Invoke phase, Lambda resets the
          execution environment. The following diagram illustrates Lambda execution environment behavior when
          there's an invoke failure:
        
           
            
           
           
        
        In the previous diagram:
        
           
           
           
           
           
        
            The first phase is the INIT phase, which runs
              without errors.
          
            The second phase is the INVOKE phase, which runs
              without errors.
          
            At some point, suppose your function runs into an invoke failure (such as a function
              timeout or runtime error). The third phase, labeled INVOKE WITH ERROR
              , illustrates this scenario. When this happens, the Lambda service performs a
              reset. The reset behaves like a Shutdown event. First, Lambda shuts down the
              runtime, then sends a Shutdown event to each registered external extension.
              The event includes the reason for the shutdown. If this environment is used for a new
              invocation, Lambda re-initializes the extension and runtime together with the next
              invocation.
            
            Note that the Lambda reset does not clear the /tmp directory content prior to the next init phase.
              This behavior is consistent with the regular shutdown phase.
            NoteAWS is currently implementing changes to the Lambda service. Due to these changes, you may see minor differences between the structure and content 
of system log messages and trace segments emitted by different Lambda functions in your AWS account.If your function's system log configuration is set to plain text, this change affects the log messages captured in CloudWatch Logs when your 
                function experiences an invoke failure. The following examples show log outputs in both old and new formats.These changes will be implemented during the coming weeks, and all functions in all 
AWS Regions except the China and GovCloud regions will transition to use the new-format log messages and trace segments.
            
            Example CloudWatch Logs log output (runtime or extension crash) - old styleSTART RequestId: c3252230-c73d-49f6-8844-968c01d1e2e1 Version: $LATEST
RequestId: c3252230-c73d-49f6-8844-968c01d1e2e1 Error: Runtime exited without providing a reason
Runtime.ExitError
END RequestId: c3252230-c73d-49f6-8844-968c01d1e2e1
REPORT RequestId: c3252230-c73d-49f6-8844-968c01d1e2e1 Duration: 933.59 ms Billed Duration: 934 ms Memory Size: 128 MB Max Memory Used: 9 MB
            Example CloudWatch Logs log output (function timeout) - old styleSTART RequestId: b70435cc-261c-4438-b9b6-efe4c8f04b21 Version: $LATEST
2024-03-04T17:22:38.033Z b70435cc-261c-4438-b9b6-efe4c8f04b21 Task timed out after 3.00 seconds
END RequestId: b70435cc-261c-4438-b9b6-efe4c8f04b21
REPORT RequestId: b70435cc-261c-4438-b9b6-efe4c8f04b21 Duration: 3004.92 ms Billed Duration: 3000 ms Memory Size: 128 MB Max Memory Used: 33 MB Init Duration: 111.23 ms
            The new format for CloudWatch logs includes an additional statusfield in the REPORT line. In the case of a runtime or 
              extension crash, the REPORT line also includes a field ErrorType.
            
            Example CloudWatch Logs log output (runtime or extension crash) - new styleSTART RequestId: 5b866fb1-7154-4af6-8078-6ef6ca4c2ddd Version: $LATEST
END RequestId: 5b866fb1-7154-4af6-8078-6ef6ca4c2ddd
REPORT RequestId: 5b866fb1-7154-4af6-8078-6ef6ca4c2ddd Duration: 133.61 ms Billed Duration: 133 ms Memory Size: 128 MB Max Memory Used: 31 MB Init Duration: 80.00 ms Status: error Error Type: Runtime.ExitError
            Example CloudWatch Logs log output (function timeout) - new styleSTART RequestId: 527cb862-4f5e-49a9-9ae4-a7edc90f0fda Version: $LATEST
END RequestId: 527cb862-4f5e-49a9-9ae4-a7edc90f0fda
REPORT RequestId: 527cb862-4f5e-49a9-9ae4-a7edc90f0fda Duration: 3016.78 ms Billed Duration: 3016 ms Memory Size: 128 MB Max Memory Used: 31 MB Init Duration: 84.00 ms Status: timeout
          
            The fourth phase represents the INVOKE phase
              immediately following an invoke failure. Here, Lambda initializes the environment again
              by re-running the INIT phase. This is called a
              suppressed init. When suppressed inits occur, Lambda doesn't
              explicitly report an additional INIT phase in CloudWatch Logs.
              Instead, you may notice that the duration in the REPORT line includes an additional
              INIT duration + the
              INVOKE duration. For example, suppose you see the
              following logs in CloudWatch:
            2022-12-20T01:00:00.000-08:00 START RequestId: XXX Version: $LATEST 
2022-12-20T01:00:02.500-08:00 END RequestId: XXX 
2022-12-20T01:00:02.500-08:00 REPORT RequestId: XXX Duration: 3022.91 ms 
Billed Duration: 3000 ms Memory Size: 512 MB Max Memory Used: 157 MB
            In this example, the difference between the REPORT and START timestamps is 2.5 seconds.
              This doesn't match the reported duration of 3022.91 millseconds, because it doesn't take
              into account the extra INIT (suppressed init) that Lambda
              performed. In this example, you can infer that the actual
              INVOKE phase took 2.5 seconds.
            For more insight into this behavior, you can use the
              Accessing real-time telemetry data for extensions using the Telemetry API. The Telemetry API emits
              INIT_START, INIT_RUNTIME_DONE, and INIT_REPORT
              events with phase=invoke whenever suppressed inits occur in between
              invoke phases.
          
            The fifth phase represents the SHUTDOWN phase, which runs
              without errors.
          
       
       
        Shutdown phase
        When Lambda is about to shut down the runtime, it sends a Shutdown event to
          each registered external extension. Extensions can use this time for final cleanup tasks. The Shutdown event
          is a response to a Next API request.
        Duration limit: The maximum duration of the
          Shutdown phase depends on the configuration of registered extensions:
      
         
         
         
      
          0 ms – A function with no registered extensions
        
          500 ms – A function with a registered internal extension
        
          2,000 ms – A function with one or more registered external extensions
        
      If the runtime or an extension does not respond to the Shutdown event within the limit, Lambda
        ends the process using a SIGKILL signal.
        After the function and all extensions have completed, Lambda maintains the execution
          environment for some time in anticipation of another function invocation. However, Lambda terminates execution environments every few hours to allow for runtime updates and maintenance—even for functions that are invoked continuously. You should
          not assume that the execution environment will persist indefinitely. For more information, see
          Implement statelessness in functions.
        When the function is invoked again, Lambda thaws the environment for reuse. Reusing the
        execution environment has the following implications: 
        
           
           
           
        
            Objects declared outside of the function's handler method remain initialized, providing additional
              optimization when the function is invoked again. For example, if your Lambda function establishes a database
              connection, instead of reestablishing the connection, the original connection is used in subsequent
              invocations. We recommend adding logic in your code to check if a connection exists before creating a new
              one.
          
            Each execution environment provides between 512 MB and 10,240 MB, in 1-MB increments, of disk space in the /tmp
              directory. The directory content remains when the execution environment is frozen, providing a transient
              cache that can be used for multiple invocations. You can add extra code to check if the cache has the data
              that you stored. For more information on deployment size limits, see Lambda quotas.
          
            Background processes or callbacks that were initiated by your Lambda function and did not complete when
              the function ended resume if Lambda reuses the execution environment. Make sure that any background processes
              or callbacks in your code are complete before the code exits.
          
         
     
    Cold starts and latency
    When Lambda receives a request to run a function via the Lambda API, the service first prepares an execution
      environment. During this initialization phase, the service downloads your code, starts the environment, and
      runs any initialization code outside of the main handler. Finally, Lambda runs the handler code.
    
       
        
       
       
    
    In this diagram, the first two steps of downloading the code and setting up the environment are frequently referred
      to as a “cold start”. You are not charged for this time, but it does add latency to your overall invocation duration.
    After the invocation completes, the execution environment is frozen. To improve resource management and performance,
      Lambda retains the execution environment for a period of time. During this time, if another request arrives for the same
      function, Lambda can reuse the environment. This second request typically finishes more quickly, since the execution
      environment is already fully set up. This is called a “warm start”.
    Cold starts typically occur in under 1% of invocations. The duration of a cold start varies from under 100 ms to over
      1 second. In general, cold starts are typically more common in development and test functions than production workloads.
      This is because development and test functions are usually invoked less frequently.
   
    Reducing cold starts with Provisioned Concurrency
    If you need predictable function start times for your workload, provisioned
      concurrency is the recommended solution to ensure the lowest possible latency. This feature pre-initializes
      execution environments, reducing cold starts.
    For example, a function with a provisioned concurrency of 6 has 6 execution environments pre-warmed.
    
       
        
       
       
    
   
    Optimizing static initialization
    Static initialization happens before the handler code starts running in a function. This is the initialization code
      that you provide, that is outside of the main handler. This code is often used to import libraries and dependencies,
      set up configurations, and initialize connections to other services.
    The following Python example shows importing, and configuring modules, and creating the Amazon S3 client during the
      initialization phase, before the lambda_handler function runs during invoke.
    import os
import json
import cv2
import logging
import boto3

s3 = boto3.client('s3')
logger = logging.getLogger()
logger.setLevel(logging.INFO)

def lambda_handler(event, context):

  # Handler logic...

    The largest contributor of latency before function execution comes from initialization code. This code runs when
      a new execution environment is created for the first time. The initialization code is not run again if an invocation
      uses a warm execution environment. Factors that affect initialization code latency include:
    
       
       
       
    
        The size of the function package, in terms of imported libraries and dependencies, and Lambda layers.
      
        The amount of code and initialization work.
      
        The performance of libraries and other services in setting up connections and other resources.
      
    There are a number of steps that developers can take to optimize static initialization latency. If a function has
      many objects and connections, you may be able to rearchitect a single function into multiple, specialized functions.
      These are individually smaller and each have less initialization code.
    It’s important that functions only import the libraries and dependencies that they need. For example, if you only
      use Amazon DynamoDB in the AWS SDK, you can require an individual service instead of the entire SDK. Compare the following
      three examples:
    // Instead of const AWS = require('aws-sdk'), use:
const DynamoDB = require('aws-sdk/clients/dynamodb')

// Instead of const AWSXRay = require('aws-xray-sdk'), use:
const AWSXRay = require('aws-xray-sdk-core')

// Instead of const AWS = AWSXRay.captureAWS(require('aws-sdk')), use:
const dynamodb = new DynamoDB.DocumentClient()
AWSXRay.captureAWSClient(dynamodb.service)
    Static initialization is also often the best place to open database connections to allow a function to reuse
      connections over multiple invocations to the same execution environment. However, you may have large numbers of
      objects that are only used in certain execution paths in your function. In this case, you can lazily load variables
      in the global scope to reduce the static initialization duration.
    Avoid global variables for context-specific information. If your function has a global variable that is used
      only for the lifetime of a single invocation and is reset for the next invocation, use a variable scope that is
      local to the handler. Not only does this prevent global variable leaks across invocations, it also improves the
      static initialization performance.
  Document ConventionsProgramming modelEvent-driven architecturesDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideRuntime environment lifecycleCold starts and latencyReducing cold starts with Provisioned ConcurrencyOptimizing static initializationUnderstanding the Lambda execution environment lifecycle
      Lambda invokes your function in an execution environment, which provides a secure and isolated runtime
      environment. The execution environment manages the resources required to run your function. The execution
      environment also provides lifecycle support for the function's runtime and any external extensions associated with your function.
    The function's runtime communicates with Lambda using the Runtime API.
    Extensions communicate with Lambda using the Extensions API.
    Extensions can also receive log messages and other telemetry from the function by using the Telemetry API.
    
         
          
         
         
    When you create your Lambda function, you specify configuration information, such as the amount of memory
    available and the maximum execution time allowed for your function. Lambda uses this information to set up the
    execution environment.The function's runtime and each external extension are processes that run within the execution environment.
    Permissions, resources, credentials, and environment variables are shared between the function and the
    extensions.TopicsLambda execution environment lifecycleCold starts and latencyReducing cold starts with Provisioned ConcurrencyOptimizing static initialization
      Lambda execution environment lifecycle    
        
           
            
           
           
        
        Each phase starts with an event that Lambda sends to the runtime and to all registered extensions. The
        runtime and each extension indicate completion by sending a Next API request. Lambda freezes the
        execution environment when the runtime and each extension have completed and there are no pending events.
        TopicsInit phaseFailures during the Init phaseRestore phase (Lambda SnapStart only)Invoke phaseFailures during the invoke phaseShutdown phase
       
        Init phase
        In the Init phase, Lambda performs three tasks:
        
           
           
           
           
        
            Start all extensions (Extension init)
          
            Bootstrap the runtime (Runtime init)
          
            Run the function's static code (Function init)
          
            Run any before-checkpoint runtime hooks (Lambda SnapStart only)
          
        The Init phase ends when the runtime and all extensions signal that they are ready by sending a
            Next API request. The Init phase is limited to 10 seconds. If all three tasks do not
          complete within 10 seconds, Lambda retries the Init phase at the time of the first function
          invocation with the configured function timeout.
          When Lambda SnapStart is activated, the Init phase happens when you publish a function version. Lambda saves a snapshot of the memory and disk state of the initialized execution environment, persists the encrypted snapshot, and caches it for low-latency access. If you have a before-checkpoint runtime hook, then the code runs at the end of Init phase.
          NoteThe 10-second timeout doesn't apply to functions that are using provisioned concurrency
              or SnapStart. For provisioned concurrency and SnapStart functions, your initialization code
              can run for up to 15 minutes. The time limit is 130 seconds or the configured function
              timeout (maximum 900 seconds), whichever is higher.
        When you use provisioned concurrency,
          Lambda initializes the execution environment when you configure the PC settings for a function. Lambda also ensures that
          initialized execution environments are always available in advance of invocations. You may see gaps between your function's
          invocation and initialization phases. Depending on your function's runtime and memory configuration, you may also see variable
          latency on the first invocation on an initialized execution environment.
        For functions using on-demand concurrency, Lambda may occasionally initialize execution environments ahead of
          invocation requests. When this happens, you may also observe a time gap between your function's initialization and
          invocation phases. We recommend you to not take a dependency on this behavior.
       
       
        Failures during the Init phase
        If a function crashes or times out during the Init phase, Lambda emits error information in the INIT_REPORT log.
    Example  — INIT_REPORT log for timeoutINIT_REPORT Init Duration: 1236.04 ms Phase: init Status: timeout       
    Example  — INIT_REPORT log for extension failureINIT_REPORT Init Duration: 1236.04 ms Phase: init Status: error Error Type: Extension.Crash		
        If the Init phase is successful, Lambda doesn't emit the INIT_REPORT log unless SnapStart or 
          provisioned concurrency is enabled. SnapStart and provisioned concurrency functions always emit INIT_REPORT. 
          For more information, see Monitoring for Lambda SnapStart.
        
       
        Restore phase (Lambda SnapStart only)
        When you first invoke a SnapStart function and as the function scales up, Lambda resumes new execution environments from the persisted snapshot instead of initializing the function from scratch. If you have an after-restore runtime hook, the code runs at the end of the Restore phase. You are charged for the duration of after-restore runtime hooks. The runtime must load and after-restore runtime hooks must complete within the timeout limit (10 seconds). Otherwise, you'll get a SnapStartTimeoutException. When the Restore phase completes, Lambda invokes the function handler (the Invoke phase).
         
          Failures during the Restore phase
          If the Restore phase fails, Lambda emits error information in the RESTORE_REPORT log.
      Example  — RESTORE_REPORT log for timeoutRESTORE_REPORT Restore Duration: 1236.04 ms Status: timeout
      Example  — RESTORE_REPORT log for runtime hook failureRESTORE_REPORT Restore Duration: 1236.04 ms Status: error Error Type: Runtime.ExitError		
        For more information about the RESTORE_REPORT log, see Monitoring for Lambda SnapStart.
         
       
       
        Invoke phase
        When a Lambda function is invoked in response to a Next API request, Lambda sends an
            Invoke event to the runtime and to each extension.
        The function's timeout setting limits the duration of the entire Invoke phase. For example, if
          you set the function timeout as 360 seconds, the function and all extensions need to complete within 360
          seconds. Note that there is no independent post-invoke phase. The duration is the sum of all invocation time
          (runtime + extensions) and is not calculated until the function and all extensions have finished
          executing.
        The invoke phase ends after the runtime and all extensions signal that they are done by sending a
            Next API request.
       
       
        Failures during the invoke phase
        If the Lambda function crashes or times out during the Invoke phase, Lambda resets the
          execution environment. The following diagram illustrates Lambda execution environment behavior when
          there's an invoke failure:
        
           
            
           
           
        
        In the previous diagram:
        
           
           
           
           
           
        
            The first phase is the INIT phase, which runs
              without errors.
          
            The second phase is the INVOKE phase, which runs
              without errors.
          
            At some point, suppose your function runs into an invoke failure (such as a function
              timeout or runtime error). The third phase, labeled INVOKE WITH ERROR
              , illustrates this scenario. When this happens, the Lambda service performs a
              reset. The reset behaves like a Shutdown event. First, Lambda shuts down the
              runtime, then sends a Shutdown event to each registered external extension.
              The event includes the reason for the shutdown. If this environment is used for a new
              invocation, Lambda re-initializes the extension and runtime together with the next
              invocation.
            
            Note that the Lambda reset does not clear the /tmp directory content prior to the next init phase.
              This behavior is consistent with the regular shutdown phase.
            NoteAWS is currently implementing changes to the Lambda service. Due to these changes, you may see minor differences between the structure and content 
of system log messages and trace segments emitted by different Lambda functions in your AWS account.If your function's system log configuration is set to plain text, this change affects the log messages captured in CloudWatch Logs when your 
                function experiences an invoke failure. The following examples show log outputs in both old and new formats.These changes will be implemented during the coming weeks, and all functions in all 
AWS Regions except the China and GovCloud regions will transition to use the new-format log messages and trace segments.
            
            Example CloudWatch Logs log output (runtime or extension crash) - old styleSTART RequestId: c3252230-c73d-49f6-8844-968c01d1e2e1 Version: $LATEST
RequestId: c3252230-c73d-49f6-8844-968c01d1e2e1 Error: Runtime exited without providing a reason
Runtime.ExitError
END RequestId: c3252230-c73d-49f6-8844-968c01d1e2e1
REPORT RequestId: c3252230-c73d-49f6-8844-968c01d1e2e1 Duration: 933.59 ms Billed Duration: 934 ms Memory Size: 128 MB Max Memory Used: 9 MB
            Example CloudWatch Logs log output (function timeout) - old styleSTART RequestId: b70435cc-261c-4438-b9b6-efe4c8f04b21 Version: $LATEST
2024-03-04T17:22:38.033Z b70435cc-261c-4438-b9b6-efe4c8f04b21 Task timed out after 3.00 seconds
END RequestId: b70435cc-261c-4438-b9b6-efe4c8f04b21
REPORT RequestId: b70435cc-261c-4438-b9b6-efe4c8f04b21 Duration: 3004.92 ms Billed Duration: 3000 ms Memory Size: 128 MB Max Memory Used: 33 MB Init Duration: 111.23 ms
            The new format for CloudWatch logs includes an additional statusfield in the REPORT line. In the case of a runtime or 
              extension crash, the REPORT line also includes a field ErrorType.
            
            Example CloudWatch Logs log output (runtime or extension crash) - new styleSTART RequestId: 5b866fb1-7154-4af6-8078-6ef6ca4c2ddd Version: $LATEST
END RequestId: 5b866fb1-7154-4af6-8078-6ef6ca4c2ddd
REPORT RequestId: 5b866fb1-7154-4af6-8078-6ef6ca4c2ddd Duration: 133.61 ms Billed Duration: 133 ms Memory Size: 128 MB Max Memory Used: 31 MB Init Duration: 80.00 ms Status: error Error Type: Runtime.ExitError
            Example CloudWatch Logs log output (function timeout) - new styleSTART RequestId: 527cb862-4f5e-49a9-9ae4-a7edc90f0fda Version: $LATEST
END RequestId: 527cb862-4f5e-49a9-9ae4-a7edc90f0fda
REPORT RequestId: 527cb862-4f5e-49a9-9ae4-a7edc90f0fda Duration: 3016.78 ms Billed Duration: 3016 ms Memory Size: 128 MB Max Memory Used: 31 MB Init Duration: 84.00 ms Status: timeout
          
            The fourth phase represents the INVOKE phase
              immediately following an invoke failure. Here, Lambda initializes the environment again
              by re-running the INIT phase. This is called a
              suppressed init. When suppressed inits occur, Lambda doesn't
              explicitly report an additional INIT phase in CloudWatch Logs.
              Instead, you may notice that the duration in the REPORT line includes an additional
              INIT duration + the
              INVOKE duration. For example, suppose you see the
              following logs in CloudWatch:
            2022-12-20T01:00:00.000-08:00 START RequestId: XXX Version: $LATEST 
2022-12-20T01:00:02.500-08:00 END RequestId: XXX 
2022-12-20T01:00:02.500-08:00 REPORT RequestId: XXX Duration: 3022.91 ms 
Billed Duration: 3000 ms Memory Size: 512 MB Max Memory Used: 157 MB
            In this example, the difference between the REPORT and START timestamps is 2.5 seconds.
              This doesn't match the reported duration of 3022.91 millseconds, because it doesn't take
              into account the extra INIT (suppressed init) that Lambda
              performed. In this example, you can infer that the actual
              INVOKE phase took 2.5 seconds.
            For more insight into this behavior, you can use the
              Accessing real-time telemetry data for extensions using the Telemetry API. The Telemetry API emits
              INIT_START, INIT_RUNTIME_DONE, and INIT_REPORT
              events with phase=invoke whenever suppressed inits occur in between
              invoke phases.
          
            The fifth phase represents the SHUTDOWN phase, which runs
              without errors.
          
       
       
        Shutdown phase
        When Lambda is about to shut down the runtime, it sends a Shutdown event to
          each registered external extension. Extensions can use this time for final cleanup tasks. The Shutdown event
          is a response to a Next API request.
        Duration limit: The maximum duration of the
          Shutdown phase depends on the configuration of registered extensions:
      
         
         
         
      
          0 ms – A function with no registered extensions
        
          500 ms – A function with a registered internal extension
        
          2,000 ms – A function with one or more registered external extensions
        
      If the runtime or an extension does not respond to the Shutdown event within the limit, Lambda
        ends the process using a SIGKILL signal.
        After the function and all extensions have completed, Lambda maintains the execution
          environment for some time in anticipation of another function invocation. However, Lambda terminates execution environments every few hours to allow for runtime updates and maintenance—even for functions that are invoked continuously. You should
          not assume that the execution environment will persist indefinitely. For more information, see
          Implement statelessness in functions.
        When the function is invoked again, Lambda thaws the environment for reuse. Reusing the
        execution environment has the following implications: 
        
           
           
           
        
            Objects declared outside of the function's handler method remain initialized, providing additional
              optimization when the function is invoked again. For example, if your Lambda function establishes a database
              connection, instead of reestablishing the connection, the original connection is used in subsequent
              invocations. We recommend adding logic in your code to check if a connection exists before creating a new
              one.
          
            Each execution environment provides between 512 MB and 10,240 MB, in 1-MB increments, of disk space in the /tmp
              directory. The directory content remains when the execution environment is frozen, providing a transient
              cache that can be used for multiple invocations. You can add extra code to check if the cache has the data
              that you stored. For more information on deployment size limits, see Lambda quotas.
          
            Background processes or callbacks that were initiated by your Lambda function and did not complete when
              the function ended resume if Lambda reuses the execution environment. Make sure that any background processes
              or callbacks in your code are complete before the code exits.
          
         
     
    Cold starts and latency
    When Lambda receives a request to run a function via the Lambda API, the service first prepares an execution
      environment. During this initialization phase, the service downloads your code, starts the environment, and
      runs any initialization code outside of the main handler. Finally, Lambda runs the handler code.
    
       
        
       
       
    
    In this diagram, the first two steps of downloading the code and setting up the environment are frequently referred
      to as a “cold start”. You are not charged for this time, but it does add latency to your overall invocation duration.
    After the invocation completes, the execution environment is frozen. To improve resource management and performance,
      Lambda retains the execution environment for a period of time. During this time, if another request arrives for the same
      function, Lambda can reuse the environment. This second request typically finishes more quickly, since the execution
      environment is already fully set up. This is called a “warm start”.
    Cold starts typically occur in under 1% of invocations. The duration of a cold start varies from under 100 ms to over
      1 second. In general, cold starts are typically more common in development and test functions than production workloads.
      This is because development and test functions are usually invoked less frequently.
   
    Reducing cold starts with Provisioned Concurrency
    If you need predictable function start times for your workload, provisioned
      concurrency is the recommended solution to ensure the lowest possible latency. This feature pre-initializes
      execution environments, reducing cold starts.
    For example, a function with a provisioned concurrency of 6 has 6 execution environments pre-warmed.
    
       
        
       
       
    
   
    Optimizing static initialization
    Static initialization happens before the handler code starts running in a function. This is the initialization code
      that you provide, that is outside of the main handler. This code is often used to import libraries and dependencies,
      set up configurations, and initialize connections to other services.
    The following Python example shows importing, and configuring modules, and creating the Amazon S3 client during the
      initialization phase, before the lambda_handler function runs during invoke.
    import os
import json
import cv2
import logging
import boto3

s3 = boto3.client('s3')
logger = logging.getLogger()
logger.setLevel(logging.INFO)

def lambda_handler(event, context):

  # Handler logic...

    The largest contributor of latency before function execution comes from initialization code. This code runs when
      a new execution environment is created for the first time. The initialization code is not run again if an invocation
      uses a warm execution environment. Factors that affect initialization code latency include:
    
       
       
       
    
        The size of the function package, in terms of imported libraries and dependencies, and Lambda layers.
      
        The amount of code and initialization work.
      
        The performance of libraries and other services in setting up connections and other resources.
      
    There are a number of steps that developers can take to optimize static initialization latency. If a function has
      many objects and connections, you may be able to rearchitect a single function into multiple, specialized functions.
      These are individually smaller and each have less initialization code.
    It’s important that functions only import the libraries and dependencies that they need. For example, if you only
      use Amazon DynamoDB in the AWS SDK, you can require an individual service instead of the entire SDK. Compare the following
      three examples:
    // Instead of const AWS = require('aws-sdk'), use:
const DynamoDB = require('aws-sdk/clients/dynamodb')

// Instead of const AWSXRay = require('aws-xray-sdk'), use:
const AWSXRay = require('aws-xray-sdk-core')

// Instead of const AWS = AWSXRay.captureAWS(require('aws-sdk')), use:
const dynamodb = new DynamoDB.DocumentClient()
AWSXRay.captureAWSClient(dynamodb.service)
    Static initialization is also often the best place to open database connections to allow a function to reuse
      connections over multiple invocations to the same execution environment. However, you may have large numbers of
      objects that are only used in certain execution paths in your function. In this case, you can lazily load variables
      in the global scope to reduce the static initialization duration.
    Avoid global variables for context-specific information. If your function has a global variable that is used
      only for the lifetime of a single invocation and is reset for the next invocation, use a variable scope that is
      local to the handler. Not only does this prevent global variable leaks across invocations, it also improves the
      static initialization performance.
  Document ConventionsProgramming modelEvent-driven architecturesDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaAPI ReferenceRequest SyntaxURI Request ParametersRequest BodyResponse SyntaxResponse ElementsErrorsSee AlsoCreateFunctionCreates a Lambda function. To create a function, you need a deployment package and an execution role. The
      deployment package is a .zip file archive or container image that contains your function code. The execution role
      grants the function permission to use AWS services, such as Amazon CloudWatch Logs for log
      streaming and AWS X-Ray for request tracing.If the deployment package is a container
        image, then you set the package type to Image. For a container image, the code property
      must include the URI of a container image in the Amazon ECR registry. You do not need to specify the
      handler and runtime properties.If the deployment package is a .zip file archive, then
      you set the package type to Zip. For a .zip file archive, the code property specifies the location of
      the .zip file. You must also specify the handler and runtime properties. The code in the deployment package must
      be compatible with the target instruction set architecture of the function (x86-64 or
        arm64). If you do not specify the architecture, then the default value is
      x86-64.When you create a function, Lambda provisions an instance of the function and its supporting
      resources. If your function connects to a VPC, this process can take a minute or so. During this time, you can't
      invoke or modify the function. The State, StateReason, and StateReasonCode
      fields in the response from GetFunctionConfiguration indicate when the function is ready to
      invoke. For more information, see Lambda function states.A function has an unpublished version, and can have published versions and aliases. The unpublished version
      changes when you update your function's code and configuration. A published version is a snapshot of your function
      code and configuration that can't be changed. An alias is a named resource that maps to a version, and can be
      changed to map to a different version. Use the Publish parameter to create version 1 of
      your function from its initial configuration.The other parameters let you configure version-specific and function-level settings. You can modify
      version-specific settings later with UpdateFunctionConfiguration. Function-level settings apply
      to both the unpublished and published versions of the function, and include tags (TagResource)
      and per-function concurrency limits (PutFunctionConcurrency).You can use code signing if your deployment package is a .zip file archive. To enable code signing for this
      function, specify the ARN of a code-signing configuration. When a user attempts to deploy a code package with
        UpdateFunctionCode, Lambda checks that the code package has a valid signature from
      a trusted publisher. The code-signing configuration includes set of signing profiles, which define the trusted
      publishers for this function.If another AWS account or an AWS service invokes your function, use AddPermission to grant permission by creating a resource-based AWS Identity and Access Management (IAM) policy. You can grant permissions at the function level, on a version, or on an alias.To invoke your function directly, use Invoke. To invoke your function in response to events
      in other AWS services, create an event source mapping (CreateEventSourceMapping),
      or configure a function trigger in the other service. For more information, see Invoking Lambda
      functions.
      Request Syntax
      POST /2015-03-31/functions HTTP/1.1
Content-type: application/json

{
   "Architectures": [ "string" ],
   "Code": { 
      "ImageUri": "string",
      "S3Bucket": "string",
      "S3Key": "string",
      "S3ObjectVersion": "string",
      "SourceKMSKeyArn": "string",
      "ZipFile": blob
   },
   "CodeSigningConfigArn": "string",
   "DeadLetterConfig": { 
      "TargetArn": "string"
   },
   "Description": "string",
   "Environment": { 
      "Variables": { 
         "string" : "string" 
      }
   },
   "EphemeralStorage": { 
      "Size": number
   },
   "FileSystemConfigs": [ 
      { 
         "Arn": "string",
         "LocalMountPath": "string"
      }
   ],
   "FunctionName": "string",
   "Handler": "string",
   "ImageConfig": { 
      "Command": [ "string" ],
      "EntryPoint": [ "string" ],
      "WorkingDirectory": "string"
   },
   "KMSKeyArn": "string",
   "Layers": [ "string" ],
   "LoggingConfig": { 
      "ApplicationLogLevel": "string",
      "LogFormat": "string",
      "LogGroup": "string",
      "SystemLogLevel": "string"
   },
   "MemorySize": number,
   "PackageType": "string",
   "Publish": boolean,
   "Role": "string",
   "Runtime": "string",
   "SnapStart": { 
      "ApplyOn": "string"
   },
   "Tags": { 
      "string" : "string" 
   },
   "Timeout": number,
   "TracingConfig": { 
      "Mode": "string"
   },
   "VpcConfig": { 
      "Ipv6AllowedForDualStack": boolean,
      "SecurityGroupIds": [ "string" ],
      "SubnetIds": [ "string" ]
   }
}
    
      URI Request Parameters
      The request does not use any URI parameters.
    
      Request Body
      The request accepts the following data in JSON format.
      
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
      
            
               
                  Architectures
               
            
            
               The instruction set architecture that the function supports. Enter a string array with one of the valid values (arm64 or x86_64).
     The default value is x86_64.
               Type: Array of strings
               Array Members: Fixed number of 1 item.
               Valid Values: x86_64 | arm64
               
               Required: No
            
          
            
               
                  Code
               
            
            
               The code for the function.
               Type: FunctionCode object
               Required: Yes
            
          
            
               
                  CodeSigningConfigArn
               
            
            
               To enable code signing for this function, specify the ARN of a code-signing configuration. A code-signing configuration
includes a set of signing profiles, which define the trusted publishers for this function.
               Type: String
               Length Constraints: Maximum length of 200.
               Pattern: arn:(aws[a-zA-Z-]*)?:lambda:[a-z]{2}((-gov)|(-iso(b?)))?-[a-z]+-\d{1}:\d{12}:code-signing-config:csc-[a-z0-9]{17}
               
               Required: No
            
          
            
               
                  DeadLetterConfig
               
            
            
               A dead-letter queue configuration that specifies the queue or topic where Lambda sends asynchronous events
      when they fail processing. For more information, see Dead-letter queues.
               Type: DeadLetterConfig object
               Required: No
            
          
            
               
                  Description
               
            
            
               A description of the function.
               Type: String
               Length Constraints: Minimum length of 0. Maximum length of 256.
               Required: No
            
          
            
               
                  Environment
               
            
            
               Environment variables that are accessible from function code during execution.
               Type: Environment object
               Required: No
            
          
            
               
                  EphemeralStorage
               
            
            
               The size of the function's /tmp directory in MB. The default value is 512, but can be any whole
      number between 512 and 10,240 MB. For more information, see Configuring ephemeral storage (console).
               Type: EphemeralStorage object
               Required: No
            
          
            
               
                  FileSystemConfigs
               
            
            
               Connection settings for an Amazon EFS file system.
               Type: Array of FileSystemConfig objects
               Array Members: Maximum number of 1 item.
               Required: No
            
          
            
               
                  FunctionName
               
            
            
               The name or ARN of the Lambda function.
               
                  Name formats
                   
                   
                   
               
                     
                        Function name – my-function.
                  
                     
                        Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function.
                  
                     
                        Partial ARN – 123456789012:function:my-function.
                  
               The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64
      characters in length.
               Type: String
               Length Constraints: Minimum length of 1. Maximum length of 140.
               Pattern: (arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\d{1}:)?(\d{12}:)?(function:)?([a-zA-Z0-9-_]+)(:(\$LATEST|[a-zA-Z0-9-_]+))?
               
               Required: Yes
            
          
            
               
                  Handler
               
            
            
               The name of the method within your code that Lambda calls to run your function. 
Handler is required if the deployment package is a .zip file archive. The format includes the
      file name. It can also include namespaces and other qualifiers, depending on the runtime. For more information,
      see Lambda programming model.
               Type: String
               Length Constraints: Maximum length of 128.
               Pattern: [^ ]+
               
               Required: No
            
          
            
               
                  ImageConfig
               
            
            
               Container image configuration
      values that override the values in the container image Dockerfile.
               Type: ImageConfig object
               Required: No
            
          
            
               
                  KMSKeyArn
               
            
            
               The ARN of the AWS Key Management Service (AWS KMS) customer managed key that's used to encrypt the following resources:
               
                   
                   
                   
                   
               
                     The function's environment variables.
                  
                     The function's Lambda SnapStart snapshots.
                  
                     When used with SourceKMSKeyArn, the unzipped version of the .zip deployment package that's used for function invocations. For more information, see 
Specifying a customer managed key for Lambda.
                  
                     The optimized version of the container image that's used for function invocations. Note that this is not the same key that's used to protect your container image in the Amazon Elastic Container Registry (Amazon ECR). For more information, see Function lifecycle.
                  
               If you don't provide a customer managed key, Lambda uses an AWS owned key or an AWS managed key.
               Type: String
               Pattern: (arn:(aws[a-zA-Z-]*)?:[a-z0-9-.]+:.*)|()
               
               Required: No
            
          
            
               
                  Layers
               
            
            
               A list of function layers
      to add to the function's execution environment. Specify each layer by its ARN, including the version.
               Type: Array of strings
               Length Constraints: Minimum length of 1. Maximum length of 140.
               Pattern: arn:[a-zA-Z0-9-]+:lambda:[a-zA-Z0-9-]+:\d{12}:layer:[a-zA-Z0-9-_]+:[0-9]+
               
               Required: No
            
          
            
               
                  LoggingConfig
               
            
            
               The function's Amazon CloudWatch Logs configuration settings.
               Type: LoggingConfig object
               Required: No
            
          
            
               
                  MemorySize
               
            
            
               The amount of memory available to the function at runtime.
      Increasing the function memory also increases its CPU allocation. The default value is 128 MB. The value can be any multiple of 1 MB.
               Type: Integer
               Valid Range: Minimum value of 128. Maximum value of 10240.
               Required: No
            
          
            
               
                  PackageType
               
            
            
               The type of deployment package. Set to Image for container image and set to Zip for .zip file archive.
               Type: String
               Valid Values: Zip | Image
               
               Required: No
            
          
            
               
                  Publish
               
            
            
               Set to true to publish the first version of the function during creation.
               Type: Boolean
               Required: No
            
          
            
               
                  Role
               
            
            
               The Amazon Resource Name (ARN) of the function's execution role.
               Type: String
               Pattern: arn:(aws[a-zA-Z-]*)?:iam::\d{12}:role/?[a-zA-Z_0-9+=,.@\-_/]+
               
               Required: Yes
            
          
            
               
                  Runtime
               
            
            
               The identifier of the function's 
          runtime. Runtime is required if the deployment package is a .zip file archive. Specifying a runtime results in
          an error if you're deploying a function using a container image.
               The following list includes deprecated runtimes. Lambda blocks creating new functions and updating existing
          functions shortly after each runtime is deprecated. For more information, see
          Runtime use after deprecation.
               For a list of all currently supported runtimes, see
          Supported runtimes.
               Type: String
               Valid Values: nodejs | nodejs4.3 | nodejs6.10 | nodejs8.10 | nodejs10.x | nodejs12.x | nodejs14.x | nodejs16.x | java8 | java8.al2 | java11 | python2.7 | python3.6 | python3.7 | python3.8 | python3.9 | dotnetcore1.0 | dotnetcore2.0 | dotnetcore2.1 | dotnetcore3.1 | dotnet6 | dotnet8 | nodejs4.3-edge | go1.x | ruby2.5 | ruby2.7 | provided | provided.al2 | nodejs18.x | python3.10 | java17 | ruby3.2 | ruby3.3 | ruby3.4 | python3.11 | nodejs20.x | provided.al2023 | python3.12 | java21 | python3.13 | nodejs22.x
               
               Required: No
            
          
            
               
                  SnapStart
               
            
            
               The function's SnapStart setting.
               Type: SnapStart object
               Required: No
            
          
            
               
                  Tags
               
            
            
               A list of tags to apply to the
      function.
               Type: String to string map
               Required: No
            
          
            
               
                  Timeout
               
            
            
               The amount of time (in seconds) that Lambda allows a function to run before stopping it. The default is 3 seconds. The
      maximum allowed value is 900 seconds. For more information, see Lambda execution environment.
               Type: Integer
               Valid Range: Minimum value of 1.
               Required: No
            
          
            
               
                  TracingConfig
               
            
            
               Set Mode to Active to sample and trace a subset of incoming requests with
X-Ray.
               Type: TracingConfig object
               Required: No
            
          
            
               
                  VpcConfig
               
            
            
               For network connectivity to AWS resources in a VPC, specify a list of security groups and subnets in the VPC.
      When you connect a function to a VPC, it can access resources and the internet only through that VPC. For more
      information, see Configuring a Lambda function to access resources in a VPC.
               Type: VpcConfig object
               Required: No
            
         
    
      Response Syntax
      HTTP/1.1 201
Content-type: application/json

{
   "Architectures": [ "string" ],
   "CodeSha256": "string",
   "CodeSize": number,
   "DeadLetterConfig": { 
      "TargetArn": "string"
   },
   "Description": "string",
   "Environment": { 
      "Error": { 
         "ErrorCode": "string",
         "Message": "string"
      },
      "Variables": { 
         "string" : "string" 
      }
   },
   "EphemeralStorage": { 
      "Size": number
   },
   "FileSystemConfigs": [ 
      { 
         "Arn": "string",
         "LocalMountPath": "string"
      }
   ],
   "FunctionArn": "string",
   "FunctionName": "string",
   "Handler": "string",
   "ImageConfigResponse": { 
      "Error": { 
         "ErrorCode": "string",
         "Message": "string"
      },
      "ImageConfig": { 
         "Command": [ "string" ],
         "EntryPoint": [ "string" ],
         "WorkingDirectory": "string"
      }
   },
   "KMSKeyArn": "string",
   "LastModified": "string",
   "LastUpdateStatus": "string",
   "LastUpdateStatusReason": "string",
   "LastUpdateStatusReasonCode": "string",
   "Layers": [ 
      { 
         "Arn": "string",
         "CodeSize": number,
         "SigningJobArn": "string",
         "SigningProfileVersionArn": "string"
      }
   ],
   "LoggingConfig": { 
      "ApplicationLogLevel": "string",
      "LogFormat": "string",
      "LogGroup": "string",
      "SystemLogLevel": "string"
   },
   "MasterArn": "string",
   "MemorySize": number,
   "PackageType": "string",
   "RevisionId": "string",
   "Role": "string",
   "Runtime": "string",
   "RuntimeVersionConfig": { 
      "Error": { 
         "ErrorCode": "string",
         "Message": "string"
      },
      "RuntimeVersionArn": "string"
   },
   "SigningJobArn": "string",
   "SigningProfileVersionArn": "string",
   "SnapStart": { 
      "ApplyOn": "string",
      "OptimizationStatus": "string"
   },
   "State": "string",
   "StateReason": "string",
   "StateReasonCode": "string",
   "Timeout": number,
   "TracingConfig": { 
      "Mode": "string"
   },
   "Version": "string",
   "VpcConfig": { 
      "Ipv6AllowedForDualStack": boolean,
      "SecurityGroupIds": [ "string" ],
      "SubnetIds": [ "string" ],
      "VpcId": "string"
   }
}
    
      Response Elements
      If the action is successful, the service sends back an HTTP 201 response.
      The following data is returned in JSON format by the service.
      
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
      
            
               
                  Architectures
               
            
            
               The instruction set architecture that the function supports. Architecture is a string array with one of the 
      valid values. The default architecture value is x86_64.
               Type: Array of strings
               Array Members: Fixed number of 1 item.
               Valid Values: x86_64 | arm64
               
            
          
            
               
                  CodeSha256
               
            
            
               The SHA256 hash of the function's deployment package.
               Type: String
            
          
            
               
                  CodeSize
               
            
            
               The size of the function's deployment package, in bytes.
               Type: Long
            
          
            
               
                  DeadLetterConfig
               
            
            
               The function's dead letter queue.
               Type: DeadLetterConfig object
            
          
            
               
                  Description
               
            
            
               The function's description.
               Type: String
               Length Constraints: Minimum length of 0. Maximum length of 256.
            
          
            
               
                  Environment
               
            
            
               The function's environment variables. Omitted from AWS CloudTrail logs.
               Type: EnvironmentResponse object
            
          
            
               
                  EphemeralStorage
               
            
            
               The size of the function's /tmp directory in MB. The default value is 512, but can be any whole
  number between 512 and 10,240 MB. For more information, see Configuring ephemeral storage (console).
               Type: EphemeralStorage object
            
          
            
               
                  FileSystemConfigs
               
            
            
               Connection settings for an Amazon EFS file system.
               Type: Array of FileSystemConfig objects
               Array Members: Maximum number of 1 item.
            
          
            
               
                  FunctionArn
               
            
            
               The function's Amazon Resource Name (ARN).
               Type: String
               Pattern: arn:(aws[a-zA-Z-]*)?:lambda:[a-z]{2}(-gov)?-[a-z]+-\d{1}:\d{12}:function:[a-zA-Z0-9-_\.]+(:(\$LATEST|[a-zA-Z0-9-_]+))?
               
            
          
            
               
                  FunctionName
               
            
            
               The name of the function.
               Type: String
               Length Constraints: Minimum length of 1. Maximum length of 170.
               Pattern: (arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\d{1}:)?(\d{12}:)?(function:)?([a-zA-Z0-9-_\.]+)(:(\$LATEST|[a-zA-Z0-9-_]+))?
               
            
          
            
               
                  Handler
               
            
            
               The function that Lambda calls to begin running your function.
               Type: String
               Length Constraints: Maximum length of 128.
               Pattern: [^ ]+
               
            
          
            
               
                  ImageConfigResponse
               
            
            
               The function's image configuration values.
               Type: ImageConfigResponse object
            
          
            
               
                  KMSKeyArn
               
            
            
               The ARN of the AWS Key Management Service (AWS KMS) customer managed key that's used to encrypt the following resources:
               
                   
                   
                   
                   
               
                     The function's environment variables.
                  
                     The function's Lambda SnapStart snapshots.
                  
                     When used with SourceKMSKeyArn, the unzipped version of the .zip deployment package that's used for function invocations. For more information, see 
          Specifying a customer managed key for Lambda.
                  
                     The optimized version of the container image that's used for function invocations. Note that this is not the same key that's used to protect your container image in the Amazon Elastic Container Registry (Amazon ECR). For more information, see Function lifecycle.
                  
               If you don't provide a customer managed key, Lambda uses an AWS owned key or an AWS managed key.
               Type: String
               Pattern: (arn:(aws[a-zA-Z-]*)?:[a-z0-9-.]+:.*)|()
               
            
          
            
               
                  LastModified
               
            
            
               The date and time that the function was last updated, in ISO-8601 format (YYYY-MM-DDThh:mm:ss.sTZD).
               Type: String
            
          
            
               
                  LastUpdateStatus
               
            
            
               The status of the last update that was performed on the function. This is first set to Successful
      after function creation completes.
               Type: String
               Valid Values: Successful | Failed | InProgress
               
            
          
            
               
                  LastUpdateStatusReason
               
            
            
               The reason for the last update that was performed on the function.
               Type: String
            
          
            
               
                  LastUpdateStatusReasonCode
               
            
            
               The reason code for the last update that was performed on the function.
               Type: String
               Valid Values: EniLimitExceeded | InsufficientRolePermissions | InvalidConfiguration | InternalError | SubnetOutOfIPAddresses | InvalidSubnet | InvalidSecurityGroup | ImageDeleted | ImageAccessDenied | InvalidImage | KMSKeyAccessDenied | KMSKeyNotFound | InvalidStateKMSKey | DisabledKMSKey | EFSIOError | EFSMountConnectivityError | EFSMountFailure | EFSMountTimeout | InvalidRuntime | InvalidZipFileException | FunctionError
               
            
          
            
               
                  Layers
               
            
            
               The function's layers.
               Type: Array of Layer objects
            
          
            
               
                  LoggingConfig
               
            
            
               The function's Amazon CloudWatch Logs configuration settings.
               Type: LoggingConfig object
            
          
            
               
                  MasterArn
               
            
            
               For Lambda@Edge functions, the ARN of the main function.
               Type: String
               Pattern: arn:(aws[a-zA-Z-]*)?:lambda:[a-z]{2}(-gov)?-[a-z]+-\d{1}:\d{12}:function:[a-zA-Z0-9-_]+(:(\$LATEST|[a-zA-Z0-9-_]+))?
               
            
          
            
               
                  MemorySize
               
            
            
               The amount of memory available to the function at runtime.
               Type: Integer
               Valid Range: Minimum value of 128. Maximum value of 10240.
            
          
            
               
                  PackageType
               
            
            
               The type of deployment package. Set to Image for container image and set Zip for .zip file archive.
               Type: String
               Valid Values: Zip | Image
               
            
          
            
               
                  RevisionId
               
            
            
               The latest updated revision of the function or alias.
               Type: String
            
          
            
               
                  Role
               
            
            
               The function's execution role.
               Type: String
               Pattern: arn:(aws[a-zA-Z-]*)?:iam::\d{12}:role/?[a-zA-Z_0-9+=,.@\-_/]+
               
            
          
            
               
                  Runtime
               
            
            
               The identifier of the function's 
          runtime. Runtime is required if the deployment package is a .zip file archive. Specifying a runtime results in
          an error if you're deploying a function using a container image.
               The following list includes deprecated runtimes. Lambda blocks creating new functions and updating existing
          functions shortly after each runtime is deprecated. For more information, see
          Runtime use after deprecation.
               For a list of all currently supported runtimes, see
          Supported runtimes.
               Type: String
               Valid Values: nodejs | nodejs4.3 | nodejs6.10 | nodejs8.10 | nodejs10.x | nodejs12.x | nodejs14.x | nodejs16.x | java8 | java8.al2 | java11 | python2.7 | python3.6 | python3.7 | python3.8 | python3.9 | dotnetcore1.0 | dotnetcore2.0 | dotnetcore2.1 | dotnetcore3.1 | dotnet6 | dotnet8 | nodejs4.3-edge | go1.x | ruby2.5 | ruby2.7 | provided | provided.al2 | nodejs18.x | python3.10 | java17 | ruby3.2 | ruby3.3 | ruby3.4 | python3.11 | nodejs20.x | provided.al2023 | python3.12 | java21 | python3.13 | nodejs22.x
               
            
          
            
               
                  RuntimeVersionConfig
               
            
            
               The ARN of the runtime and any errors that occured.
               Type: RuntimeVersionConfig object
            
          
            
               
                  SigningJobArn
               
            
            
               The ARN of the signing job.
               Type: String
               Pattern: arn:(aws[a-zA-Z0-9-]*):([a-zA-Z0-9\-])+:([a-z]{2}(-gov)?-[a-z]+-\d{1})?:(\d{12})?:(.*)
               
            
          
            
               
                  SigningProfileVersionArn
               
            
            
               The ARN of the signing profile version.
               Type: String
               Pattern: arn:(aws[a-zA-Z0-9-]*):([a-zA-Z0-9\-])+:([a-z]{2}(-gov)?-[a-z]+-\d{1})?:(\d{12})?:(.*)
               
            
          
            
               
                  SnapStart
               
            
            
               Set ApplyOn to PublishedVersions to create a snapshot of the initialized execution
      environment when you publish a function version. For more information, see Improving startup performance with Lambda SnapStart.
               Type: SnapStartResponse object
            
          
            
               
                  State
               
            
            
               The current state of the function. When the state is Inactive, you can reactivate the function by
      invoking it.
               Type: String
               Valid Values: Pending | Active | Inactive | Failed
               
            
          
            
               
                  StateReason
               
            
            
               The reason for the function's current state.
               Type: String
            
          
            
               
                  StateReasonCode
               
            
            
               The reason code for the function's current state. When the code is Creating, you can't invoke or
      modify the function.
               Type: String
               Valid Values: Idle | Creating | Restoring | EniLimitExceeded | InsufficientRolePermissions | InvalidConfiguration | InternalError | SubnetOutOfIPAddresses | InvalidSubnet | InvalidSecurityGroup | ImageDeleted | ImageAccessDenied | InvalidImage | KMSKeyAccessDenied | KMSKeyNotFound | InvalidStateKMSKey | DisabledKMSKey | EFSIOError | EFSMountConnectivityError | EFSMountFailure | EFSMountTimeout | InvalidRuntime | InvalidZipFileException | FunctionError
               
            
          
            
               
                  Timeout
               
            
            
               The amount of time in seconds that Lambda allows a function to run before stopping it.
               Type: Integer
               Valid Range: Minimum value of 1.
            
          
            
               
                  TracingConfig
               
            
            
               The function's AWS X-Ray tracing configuration.
               Type: TracingConfigResponse object
            
          
            
               
                  Version
               
            
            
               The version of the Lambda function.
               Type: String
               Length Constraints: Minimum length of 1. Maximum length of 1024.
               Pattern: (\$LATEST|[0-9]+)
               
            
          
            
               
                  VpcConfig
               
            
            
               The function's networking configuration.
               Type: VpcConfigResponse object
            
         
    
      Errors
      For information about the errors that are common to all actions, see Common Errors.
      
          
          
          
          
          
          
          
          
          
      
            
               
                  CodeSigningConfigNotFoundException
               
            
            
               The specified code signing configuration does not exist.
               HTTP Status Code: 404
            
          
            
               
                  CodeStorageExceededException
               
            
            
               Your AWS account has exceeded its maximum total code size. For more information, see Lambda quotas.
               HTTP Status Code: 400
            
          
            
               
                  CodeVerificationFailedException
               
            
            
               The code signature failed one or more of the validation checks for signature mismatch or expiry, and the code
      signing policy is set to ENFORCE. Lambda blocks the deployment.
               HTTP Status Code: 400
            
          
            
               
                  InvalidCodeSignatureException
               
            
            
               The code signature failed the integrity check. If the integrity check fails, then Lambda blocks
      deployment, even if the code signing policy is set to WARN.
               HTTP Status Code: 400
            
          
            
               
                  InvalidParameterValueException
               
            
            
               One of the parameters in the request is not valid.
               HTTP Status Code: 400
            
          
            
               
                  ResourceConflictException
               
            
            
               The resource already exists, or another operation is in progress.
               HTTP Status Code: 409
            
          
            
               
                  ResourceNotFoundException
               
            
            
               The resource specified in the request does not exist.
               HTTP Status Code: 404
            
          
            
               
                  ServiceException
               
            
            
               The AWS Lambda service encountered an internal error.
               HTTP Status Code: 500
            
          
            
               
                  TooManyRequestsException
               
            
            
               The request throughput limit was exceeded. For more information, see Lambda quotas.
               HTTP Status Code: 429
            
         
    
      See Also
      For more information about using this API in one of the language-specific AWS SDKs, see the following:
      
          
          
          
          
          
          
          
          
          
          
      
            
               AWS Command Line Interface
            
         
            
               AWS SDK for .NET
            
         
            
               AWS SDK for C++
            
         
            
               AWS SDK for Go v2
            
         
            
               AWS SDK for Java V2
            
         
            
               AWS SDK for JavaScript V3
            
         
            
               AWS SDK for Kotlin
            
         
            
               AWS SDK for PHP V3
            
         
            
               AWS SDK for Python
            
         
            
               AWS SDK for Ruby V3
            
         
   Document ConventionsCreateEventSourceMappingCreateFunctionUrlConfigDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideCreating an execution role in the IAM consoleCreating and managing roles with the AWS CLIGrant least privilege access to your Lambda execution roleDefining Lambda function permissions with an execution roleA Lambda function's execution role is an AWS Identity and Access Management (IAM) role that grants the function permission to access
    AWS services and resources. For example, you might create an execution role that has permission to send logs to
    Amazon CloudWatch and upload trace data to AWS X-Ray. This page provides information on how to create, view, and manage a
    Lambda function's execution role.Lambda automatically assumes your execution role when you invoke your function. You should avoid manually
    calling sts:AssumeRole to assume the execution role in your function code. If your use case requires
    that the role assumes itself, you must include the role itself as a trusted principal in your role's trust policy.
    For more information on how to modify a role trust policy, see 
    Modifying a role trust policy (console) in the IAM User Guide.In order for Lambda to properly assume your execution role, the role's
    trust policy must specify the Lambda service principal
    (lambda.amazonaws.com) as a trusted service.TopicsCreating an execution role in the IAM consoleCreating and managing roles with the AWS CLIGrant least privilege access to your Lambda execution roleViewing and updating permissions in the execution roleWorking with AWS managed policies in the execution roleUsing source function ARN to control function access behavior
    Creating an execution role in the IAM console
    
    By default, Lambda creates an execution role with minimal permissions when you create a function in the Lambda console. Specifically,
      this execution role includes the AWSLambdaBasicExecutionRole managed policy, which gives your function
      basic permissions to log events to Amazon CloudWatch Logs.
    Your functions typically need additional permissions to perform more meaningful
      tasks. For example, you might have a Lambda function that responds to an event by updating
      entries in an Amazon DynamoDB database. You can create an execution role with the necessary
      permissions using the IAM console.
    To create an execution role in the IAM console
        Open the Roles page in the IAM console.
      
        Choose Create role.
      
        Under Trusted entity type, choose AWS service.
      
        Under Use case, choose Lambda.
      
        Choose Next.
      
        Select the AWS managed policies that you want to attach to your role.
          For example, if your function needs to access DynamoDB, select the
          AWSLambdaDynamoDBExecutionRole managed policy.
      
        Choose Next.
      
        Enter a Role name and then choose Create role.
      
    For detailed instructions, see Creating a role
      for an AWS service (console) in the IAM User Guide.
    After you create your execution role, attach it to your function. When you
      create a function in the Lambda console,
      you can attach any execution role that you previously created to the function. If you want
      to attach a new execution role to an existing function, follow the steps in Updating a function's execution role.
   
    Creating and managing roles with the AWS CLI
    To create an execution role with the AWS Command Line Interface (AWS CLI), use the create-role
      command. When using this command, you can specify the trust policy inline.
      A role's trust policy gives the specified principals permission to assume the role. In the
      following example, you grant the Lambda service principal permission to assume your role. Note that
      requirements for escaping quotes in the JSON string may vary depending on your shell.
    aws iam create-role \
  --role-name lambda-ex \
  --assume-role-policy-document '{"Version": "2012-10-17","Statement": [{ "Effect": "Allow", "Principal": {"Service": "lambda.amazonaws.com"}, "Action": "sts:AssumeRole"}]}'
    You can also define the trust policy for the role using a separate JSON file. In the following example,
      trust-policy.json is a file in the current directory.
    Example trust-policy.json{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Principal": {
        "Service": "lambda.amazonaws.com"
      },
      "Action": "sts:AssumeRole"
    }
  ]
}aws iam create-role \
  --role-name lambda-ex \
  --assume-role-policy-document file://trust-policy.json
    You should see the following output:
    {
    "Role": {
        "Path": "/",
        "RoleName": "lambda-ex",
        "RoleId": "AROAQFOXMPL6TZ6ITKWND",
        "Arn": "arn:aws:iam::123456789012:role/lambda-ex",
        "CreateDate": "2020-01-17T23:19:12Z",
        "AssumeRolePolicyDocument": {
            "Version": "2012-10-17",
            "Statement": [
                {
                    "Effect": "Allow",
                    "Principal": {
                        "Service": "lambda.amazonaws.com"
                    },
                    "Action": "sts:AssumeRole"
                }
            ]
        }
    }
}
    To add permissions to the role, use the attach-policy-to-role command. The following
      command adds the AWSLambdaBasicExecutionRole managed policy to the lambda-ex
      execution role.
    aws iam attach-role-policy --role-name lambda-ex --policy-arn arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
    After you create your execution role, attach it to your function. When you
      create a function in the Lambda console,
      you can attach any execution role that you previously created to the function. If you want
      to attach a new execution role to an existing function, follow the steps in Updating a function's execution role.
   
    Grant least privilege access to your Lambda execution role
    When you first create an IAM role for your Lambda function during the development phase, you might sometimes
      grant permissions beyond what is required. Before publishing your function in the production environment, as a
      best practice, adjust the policy to include only the required permissions. For more information, see Apply least-privilege
        permissions in the IAM User Guide.
    Use IAM Access Analyzer to help identify the required permissions for the IAM execution role policy. IAM Access Analyzer
      reviews your AWS CloudTrail logs over the date range that you specify and generates a policy template with only the
      permissions that the function used during that time. You can use the template to create a managed policy with
      fine-grained permissions, and then attach it to the IAM role. That way, you grant only the permissions that the
      role needs to interact with AWS resources for your specific use case.
    For more information, see Generate policies based on access
      activity in the IAM User Guide.
  Document ConventionsLambda permissionsUpdate execution roleDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS SDK for JavaScriptDeveloper Guide for SDK Version 3 The AWS SDK for JavaScript V3 API
            Reference Guide describes in detail all the API operations for the AWS SDK for JavaScript
         version 3 (V3). Use async/awaitRather than using promises, you should consider using async/await. Async functions are
        simpler and take less boilerplate than using promises. Await can only be used in an async
        function to asynchronously wait for a value.The following example uses async/await to list all of your Amazon DynamoDB tables in 
        us-west-2.NoteFor this example to run:
           
           
        
            Install the AWS SDK for JavaScript DynamoDB client by entering npm install
              @aws-sdk/client-dynamodb in the command line of your project.
          
            Ensure you have configured your AWS credentials correctly. For more information,
              see Set credentials. 
          import {
  DynamoDBClient,
  ListTablesCommand
} from "@aws-sdk/client-dynamodb";
(async function () {
  const dbClient = new DynamoDBClient({ region: "us-west-2" });
  const command = new ListTablesCommand({});

  try {
    const results = await dbClient.send(command);
    console.log(results.TableNames.join('\n'));
  } catch (err) {
    console.error(err)
  }
})();Note Not all browsers support async/await. See Async functions for a list of
          browsers with async/await support. Document ConventionsManage asynchronous callsUse promisesDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS SDK for JavaScriptDeveloper Guide for SDK Version 3 The AWS SDK for JavaScript V3 API
            Reference Guide describes in detail all the API operations for the AWS SDK for JavaScript
         version 3 (V3). Use an anonymous callback functionEach service object method can accept an anonymous callback function as the last
        parameter. The signature of this callback function is as follows.function(error, data) {
    // callback handling code
};This callback function executes when either a successful response or error data returns.
        If the method call succeeds, the contents of the response are available to the callback
        function in the data parameter. If the call doesn't succeed, the details about
        the failure are provided in the error parameter.Typically the code inside the callback function tests for an error, which it processes
        if one is returned. If an error is not returned, the code then retrieves the data in the
        response from the data parameter. The basic form of the callback function looks
        like this example.function(error, data) {
    if (error) {
        // error handling code
        console.log(error);
    } else {
        // data handling code
        console.log(data);
    }
};In the previous example, the details of either the error or the returned data are logged
        to the console. Here is an example that shows a callback function passed as part of calling
        a method on a service object.ec2.describeInstances(function(error, data) {
  if (error) {
    console.log(error); // an error occurred
  } else {
    console.log(data); // request succeeded
  }
});Document ConventionsUse promisesCreate service client requestsDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideUsing the Lambda context object to retrieve Node.js function informationWhen Lambda runs your function, it passes a context object to the handler.
    This object provides methods and properties that provide information about the invocation, function, and execution
    environment.
    Context methods
     
  
      getRemainingTimeInMillis() – Returns the number of milliseconds left before the execution times out.
    
    Context properties
     
     
     
     
     
     
     
     
     
     
  
      functionName – The name of the Lambda function.
    
      functionVersion – The version of the function.
    
      invokedFunctionArn – The Amazon Resource Name (ARN) that's used to invoke the function. Indicates if the invoker
    specified a version number or alias.
    
      memoryLimitInMB – The amount of memory that's allocated for the function.
    
      awsRequestId – The identifier of the invocation request.
    
      logGroupName – The log group for the function.
    
      logStreamName – The log stream for the function instance.
    
      identity – (mobile apps) Information about the Amazon Cognito identity that authorized the request.
      
         
         
      
          cognitoIdentityId – The authenticated Amazon Cognito identity.
        
          cognitoIdentityPoolId – The Amazon Cognito identity pool that authorized the invocation.
        
    
      clientContext – (mobile apps) Client context that's provided to Lambda by the client application.
      
         
         
         
         
         
         
         
         
         
         
         
      
          client.installation_id
        
          client.app_title
        
          client.app_version_name
        
          client.app_version_code
        
          client.app_package_name
        
          env.platform_version
        
          env.platform
        
          env.make
        
          env.model
        
          env.locale
        
          custom – Custom values that are set by the client application. 
        
    
      callbackWaitsForEmptyEventLoop – Set to false to send the response right away when the
        callback runs, instead of waiting for the Node.js event loop to
        be empty. If this is false, any outstanding events continue to run during the next invocation.
    The following example function logs context information and returns the location of the logs.Example index.js fileexports.handler = async function(event, context) {
  console.log('Remaining time: ', context.getRemainingTimeInMillis())
  console.log('Function name: ', context.functionName)
  return context.logStreamName
}Document ConventionsLayersLoggingDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideNode.js initializationRuntime-included SDK versionsUsing keep-aliveCA certificate loadingBuilding Lambda functions with Node.jsYou can run JavaScript code with Node.js in AWS Lambda. Lambda provides runtimes for Node.js that run your code to process events. Your code runs
    in an environment that includes the AWS SDK for JavaScript, with credentials from an AWS Identity and Access Management (IAM) role that you manage. To learn more 
    about the SDK versions included with the Node.js runtimes, see Runtime-included SDK versions.Lambda supports the following Node.js runtimes.
      
        Name
        Identifier
        Operating system
        Deprecation date
        Block function create
        Block function update
      
    
      
        
          Node.js 22
        
        
          nodejs22.x
        
        
          Amazon Linux 2023
        

        
                      Apr 30, 2027
            
        
        
                      Jun 1, 2027
            
        
        
                      Jul 1, 2027
            
        

      
      
        
          Node.js 20
        
        
          nodejs20.x
        
        
          Amazon Linux 2023
        

        
                      Apr 30, 2026
            
        
        
                      Jun 1, 2026
            
        
        
                      Jul 1, 2026
            
        

      
      
        
          Node.js 18
        
        
          nodejs18.x
        
        
          Amazon Linux 2
        

        
                      Sep 1, 2025
            
        
        
                      Oct 1, 2025
            
        
        
                      Nov 1, 2025
            
        

      
    To create a Node.js function
      Open the Lambda console.
    
      Choose Create function.
    
      Configure the following settings:
      
         
         
      
          Function name: Enter a name for the function.
        
          Runtime: Choose Node.js 22.x.
        
    
      Choose Create function.
    The console creates a Lambda function with a single source file named index.mjs. You can edit this file and add more files in the built-in code editor. In the DEPLOY section, choose Deploy to update your function's code. Then, to run your code, choose Create test event in the TEST EVENTS section.The index.mjs file exports a function named handler that takes an event object and a
    context object. This is the handler function that Lambda calls when the
    function is invoked. The Node.js function runtime gets invocation events from Lambda and passes them to the
    handler. In the function configuration, the handler value is index.handler.When you save your function code, the Lambda console creates a .zip file archive deployment package. 
   When you develop your function code outside of the console (using an IDE) you need to create a
      deployment package to upload your code to the Lambda function.The function runtime passes a context object to the handler, in addition to the invocation event. The context object contains additional information about the invocation, the
    function, and the execution environment. More information is available from environment variables.Your Lambda function comes with a CloudWatch Logs log group. The function runtime sends details about each invocation to
    CloudWatch Logs. It relays any logs that your function outputs during invocation. If
    your function returns an error, Lambda formats the error and returns it to the
    invoker.TopicsNode.js initializationRuntime-included SDK versionsUsing keep-alive for TCP connectionsCA certificate loadingDefine Lambda function handler in Node.jsDeploy Node.js Lambda functions with .zip file archivesDeploy Node.js Lambda functions with container imagesWorking with layers for Node.js Lambda functionsUsing the Lambda context object to retrieve Node.js function informationLog and monitor Node.js Lambda functionsInstrumenting Node.js code in AWS Lambda
    Node.js initialization
    Node.js has a unique event loop model that causes its initialization behavior to be different from other runtimes. 
      Specifically, Node.js uses a non-blocking I/O model that supports asynchronous operations. 
      This model allows Node.js to perform efficiently for most workloads. 
      For example, if a Node.js function makes a network call, that request may be designated as an asynchronous operation and placed into a callback queue. 
      The function may continue to process other operations within the main call stack without getting blocked by waiting for the network call to return. 
      Once the network call is completed, its callback is executed and then removed from the callback queue.
    
    
      Some initialization tasks may run asynchronously. These asynchronous tasks are not guaranteed to complete execution prior to an invocation. 
      For example, code that makes a network call to fetch a parameter from AWS Parameter Store may not be complete by the time Lambda executes the handler function. 
      As a result, the variable may be null during an invocation. 
      To avoid this, ensure that variables and other asynchronous code are fully initialized before continuing with the rest of the function's core business logic.
    
    Alternatively, you can designate your function code as an ES module, allowing you to use await at the top level
      of the file, outside the scope of your function handler. When you await every Promise, the asynchronous
      initialization code completes before handler invocations, maximizing the effectiveness of
      provisioned concurrency in reducing cold start latency. For more information and an example,
      see Using Node.js ES modules and top-level await in AWS Lambda.
     
      Designating a function handler as an ES module
      By default, Lambda treats files with the .js suffix as CommonJS modules. Optionally, you can designate your
        code as an ES module. You can do this in two ways: specifying the type as module in the function's
        package.json file, or by using the .mjs file name extension. In the first approach, your function
        code treats all .js files as ES modules, while in the second scenario, only the file you specify with .mjs
        is an ES module. You can mix ES modules and CommonJS modules by naming them .mjs and .cjs respectively,
        as .mjs files are always ES modules and .cjs files are always CommonJS modules.
      Lambda searches folders in the NODE_PATH environment variable when loading
        ES modules. You can load the AWS SDK that's included in the runtime using ES module import
        statements. You can also load ES modules from layers.
      
        ES module example
            Example  – ES module handlerconst url = "https://aws.amazon.com/";

export const handler = async(event) => {
    try {
        const res = await fetch(url);
        console.info("status", res.status);
        return res.status;
    }
    catch (e) {
        console.error(e);
        return 500;
    }
};
          
        CommonJS module example
            Example  – CommonJS module handlerconst https = require("https");
let url = "https://aws.amazon.com/";

exports.handler = async function (event) {
  let statusCode;
  await new Promise(function (resolve, reject) {
    https.get(url, (res) => {
        statusCode = res.statusCode;
        resolve(statusCode);
      }).on("error", (e) => {
        reject(Error(e));
      });
  });
  console.log(statusCode);
  return statusCode;
};
          
      
        
   
    Runtime-included SDK versions
    All supported Lambda Node.js runtimes include a specific minor version of the AWS SDK for JavaScript v3, not the latest version. The specific minor version that's included in the runtime depends on the runtime version and your AWS Region. To find the specific version of the SDK included in the runtime that you're using, create a Lambda function with the following code.
    Example index.mjsimport packageJson from '@aws-sdk/client-s3/package.json' with { type: 'json' };

export const handler = async () => ({ version: packageJson.version });This returns a response in the following format:{
  "version": "3.632.0"
}
    For more information, see Using the SDK for JavaScript v3 in your handler.
   
    Using keep-alive for TCP connections
    The default Node.js HTTP/HTTPS agent creates a new TCP connection for every new request. To avoid the cost of
      establishing new connections, keep-alive is enabled by default in nodejs18.x and later Lambda runtimes. Keep-alive can reduce request times for Lambda functions that make multiple API calls using the SDK.
    To disable keep-alive, see
      Reusing connections with keep-alive in Node.js in the AWS SDK for JavaScript 3.x Developer Guide. For more information about using keep-alive, see
      HTTP keep-alive is on by default in modular AWS SDK for JavaScript
      on the AWS Developer Tools Blog.
   
    CA certificate loading
    For Node.js runtime versions up to Node.js 18, Lambda automatically loads Amazon-specific CA (certificate
      authority) certificates to make it easier for you to create functions that interact with other AWS services.
      For example, Lambda includes the Amazon RDS certificates necessary for validating the
      server identity certificate
      installed on your Amazon RDS database. This behavior can have a performance impact during cold starts.
    Starting with Node.js 20, Lambda no longer loads additional CA certificates by default. The Node.js 20 runtime
      contains a certificate file with all Amazon CA certificates located at /var/runtime/ca-cert.pem. To
      restore the same behavior from Node.js 18 and earlier runtimes, set the NODE_EXTRA_CA_CERTS
      environment variable to /var/runtime/ca-cert.pem.
    For optimal performance, we recommend bundling only the certificates that you need with your deployment package
      and loading them via the NODE_EXTRA_CA_CERTS environment variable. The certificates file should
      consist of one or more trusted root or intermediate CA certificates in PEM format. For example, for RDS, include
      the required certificates alongside your code as certificates/rds.pem. Then, load the certificates
      by setting NODE_EXTRA_CA_CERTS to /var/task/certificates/rds.pem.
  Document ConventionsMonitoring concurrencyHandlerDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nSkip to main content\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideBackward compatibilityRuntime update modesTwo-phase runtime version rolloutUnderstanding how Lambda manages runtime version updatesLambda keeps each managed runtime up to date with security updates, bug fixes, new features,
    performance enhancements, and support for minor version releases. These runtime updates are
    published as runtime versions. Lambda applies runtime updates to functions
    by migrating the function from an earlier runtime version to a new runtime version.By default, for functions using managed runtimes, Lambda applies runtime updates automatically. 
    With automatic runtime updates, Lambda takes on the operational burden of patching the
    runtime versions. For most customers, automatic updates are the right choice. You can change
    this default behavior by configuring
      runtime management settings.Lambda also publishes each new runtime version as a container image. To update runtime
    versions for container-based functions, you must create a new
      container image from the updated base image and redeploy your function.Each runtime version is associated with a version number and an ARN (Amazon Resource Name).
    Runtime version numbers use a numbering scheme that Lambda defines, independent of the version
    numbers that the programming language uses. Runtime version numbers are not always sequential. For example, version 42 might be followed by version 45. The runtime version ARN is a unique identifier for
    each runtime version. You can view the ARN of your function's current runtime version in the
    Lambda console, or the INIT_START
      line of your function logs.Runtime versions should not be confused with runtime identifiers. Each runtime has a unique
    runtime identifier, such as python3.13 or 
    nodejs22.x. These correspond to each major programming language release. Runtime
    versions describe the patch version of an individual runtime.NoteThe ARN for the same runtime version number can vary between AWS Regions and CPU
    architectures.TopicsBackward compatibilityRuntime update modesTwo-phase runtime version rolloutConfiguring Lambda runtime management settingsRolling back a Lambda runtime versionIdentifying Lambda runtime version changesUnderstanding the shared responsibility model for Lambda runtime managementControlling Lambda runtime update permissions for high-compliance applications
    Backward compatibility
    Lambda strives to provide runtime updates that are backward compatible with existing functions. However, as with software patching, there are rare cases in which a runtime update can negatively impact an existing function. For example, security patches can expose an underlying issue with an existing function that depends on the previous, insecure behavior.
    When building and deploying your function, it is important to understand how to manage your dependencies to avoid potential incompatibilities with a future runtime update. For example, suppose your function has a dependency on package A, which in turn depends on package B. Both packages are included in the Lambda runtime (for example, they could be parts of the SDK or its dependencies, or parts of the runtime system libraries).
    Consider the following scenarios:
    
          
            Deployment
            Patching compatible
            Reason
          
        
          
            
              
                 
                 
              
                  Package A: Use from runtime
                
                  Package B: Use from runtime
                
            
            Yes
            Future runtime updates to packages A and B are backward compatible.
          
          
            
              
                 
                 
              
                  Package A: In deployment package
                
                  Package B: In deployment package
                
            
            Yes
            Your deployment takes precedence, so future runtime updates to packages A and B
              have no effect.
          
          
            
              
                 
                 
              
                  Package A: In deployment package
                
                  Package B: Use from runtime
                
            
            Yes*
            
              Future runtime updates to package B are backward compatible.
              *If A and B are tightly coupled, compatibility issues can occur. For example, the
                boto3 and botocore packages in the AWS SDK for Python should be deployed
                together.
            
          
          
            
              
                 
                 
              
                  Package A: Use from runtime
                
                  Package B: In deployment package
                
            
            No
            Future runtime updates to package A might require an updated version of package B.
              However, the deployed version of package B takes precedence, and might not be
              forward compatible with the updated version of package A.
          
        
    To maintain compatibility with future runtime updates, follow these best practices:
    
       
       
       
    
        When possible, package all dependencies: Include all required libraries, including the AWS SDK and its dependencies, in your deployment package. This ensures a stable, compatible set of components.
      
        Use runtime-provided SDKs sparingly: Only rely on the runtime-provided SDK when you can't include additional packages (for example, when using the Lambda console code editor or inline code in an AWS CloudFormation template).
      
        Avoid overriding system libraries: Don't deploy custom operating system libraries that may conflict with future runtime updates.
      
   
    Runtime update modes
    Lambda strives to provide runtime updates that are backward compatible with existing
      functions. However, as with software patching, there are rare cases in which a runtime update
      can negatively impact an existing function. For example, security patches can expose an
      underlying issue with an existing function that depends on the previous, insecure behavior.
      Lambda runtime management controls help reduce the risk of impact to your workloads in the rare
      event of a runtime version incompatibility. For each function version ($LATEST or published version), you can choose one of
      the following runtime update modes:
    
       
       
       
    Auto (default) – Automatically update to the most recent
        and secure runtime version using Two-phase runtime version rollout. We recommend this mode for most
        customers so that you always benefit from runtime updates.Function update – Update to the most recent and secure runtime version when you update your function. When you update your function, Lambda
        updates the runtime of your function to the most recent and secure runtime version. This
        approach synchronizes runtime updates with function deployments, giving you control over
        when Lambda applies runtime updates. With this mode, you can detect and mitigate rare
        runtime update incompatibilities early. When using this mode, you must regularly update
        your functions to keep their runtime up to date.Manual – Manually update your runtime version. You specify a runtime version in your function
        configuration. The function uses this runtime version indefinitely. In the rare case in
        which a new runtime version is incompatible with an existing function, you can use this
        mode to roll back your function to an earlier runtime version. We recommend against using
        Manual mode to try to achieve runtime consistency across
        deployments. For more information, see
        Rolling back a Lambda runtime version.
    Responsibility for applying runtime updates to your functions varies according to which runtime update mode you choose. For more information, see 
      Understanding the shared responsibility model for Lambda runtime management.
   
    Two-phase runtime version rollout
    Lambda introduces new runtime versions in the following order:
    
       
       
    In the first
        phase, Lambda applies the new runtime version whenever you create or update a function. A function gets updated when you call the 
        UpdateFunctionCode or UpdateFunctionConfiguration API operations.In the second phase, Lambda updates any function that uses the Auto runtime update mode and that hasn't already
        been updated to the new runtime version. 
    The overall duration of the rollout process varies
      according to multiple factors, including the severity of any security patches included in the
      runtime update.
    If you're actively developing and deploying your functions, you will most likely pick up
      new runtime versions during the first phase. This synchronizes runtime updates with function
      updates. In the rare event that the latest runtime version negatively impacts your
      application, this approach lets you take prompt corrective action. Functions that aren't
      in active development still receive the operational benefit of automatic runtime updates
      during the second phase.
    This approach doesn't affect functions set to Function update or
      Manual mode. Functions using Function update mode
      receive the latest runtime updates only when you create or update them. Functions using
      Manual mode don't receive runtime updates.
    Lambda publishes new runtime versions in a gradual, rolling fashion across AWS Regions.
      If your functions are set to Auto or Function update
      modes, it's possible that functions deployed at the same time to different Regions, or at
      different times in the same Region, will pick up different runtime versions. Customers who
      require guaranteed runtime version consistency across their environments should use container images to deploy their Lambda functions.
      The Manual mode is designed as a temporary mitigation to enable runtime version 
      rollback in the rare event that a runtime version is incompatible with your function.
  Document ConventionsLambda runtimesConfiguring runtime managementDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nSkip to main content\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideCreate environment variablesExample scenario for environment variablesRetrieve environment variablesDefined runtime environment variablesWorking with Lambda environment variablesYou can use environment variables to adjust your function's behavior without updating code. An environment
    variable is a pair of strings that is stored in a function's version-specific configuration. The Lambda runtime makes
    environment variables available to your code and sets additional environment variables that contain information
    about the function and invocation request.NoteTo increase security, we recommend that you use AWS Secrets Manager instead of environment variables to store
      database credentials and other sensitive information like API keys or authorization tokens. For more information, see Use Secrets Manager secrets in Lambda functions.Environment variables are not evaluated before the function invocation. Any value you define is considered a
    literal string and not expanded. Perform the variable evaluation in your function code.
    Creating Lambda environment variables
  You can configure environment variables in Lambda using the Lambda console, the AWS Command Line Interface (AWS CLI), AWS Serverless Application Model (AWS SAM), or using an AWS SDK.
 
   Console
       You define environment variables on the unpublished version of your function. When you publish a version, the
         environment variables are locked for that version along with other version-specific configuration settings.
       You create an environment variable for your function by defining a key and a value. Your function uses the
         name of the key to retrieve the value of the environment variable.
       To set environment variables in the Lambda consoleOpen the Functions page of the Lambda console.
           Choose a function.
         
           Choose the Configuration tab, then choose Environment variables.
         
           Under Environment variables, choose Edit.
         
           Choose Add environment variable.
         
           Enter a key and value.
           
             Requirements
              
              
              
              
           
               Keys start with a letter and are at least two characters.
             
               Keys only contain letters, numbers, and the underscore character (_).
             
               Keys aren't reserved by Lambda.
             
               The total size of all environment variables doesn't exceed 4 KB.
             
         
           Choose Save.
         
       To generate a list of environment variables in the console code editorYou can generate a list of environment variables in the Lambda code editor. This is a quick way to reference
           your environment variables while you code.
           Choose the Code tab.
         
           Scroll down to the ENVIRONMENT VARIABLES section of the code editor. Existing environment variables are listed here:
           
              
               
              
              
           
         
           To create new environment variables, choose the choose the plus sign (
                
                 
                
                
             ):
           
              
               
              
              
           
         
       Environment variables remain encrypted when listed in the console code editor. If you enabled encryption helpers for encryption in transit, then those settings remain unchanged. For more information, see Securing Lambda environment variables.
The environment variables list is read-only and is available only on the Lambda console. This file is not included when you download the function's .zip file archive, and you can't add environment variables by uploading this file.
     
   AWS CLI
       The following example sets two environment variables on a function named my-function.
       aws lambda update-function-configuration \
  --function-name my-function \
  --environment "Variables={BUCKET=amzn-s3-demo-bucket,KEY=file.txt}"
       When you apply environment variables with the update-function-configuration command, the entire
         contents of the Variables structure is replaced. To retain existing environment variables when you
         add a new one, include all existing values in your request.
       To get the current configuration, use the get-function-configuration command.
       aws lambda get-function-configuration \
  --function-name my-function
       You should see the following output:
       {
    "FunctionName": "my-function",
    "FunctionArn": "arn:aws:lambda:us-east-2:111122223333:function:my-function",
    "Runtime": "nodejs22.x",
    "Role": "arn:aws:iam::111122223333:role/lambda-role",
    "Environment": {
        "Variables": {
            "BUCKET": "amzn-s3-demo-bucket",
            "KEY": "file.txt"
        }
    },
    "RevisionId": "0894d3c1-2a3d-4d48-bf7f-abade99f3c15",
    ...
}
       You can pass the revision ID from the output of get-function-configuration as a parameter to
         update-function-configuration. This ensures that the values don't change between when you read the
         configuration and when you update it.
       
       To configure a function's encryption key, set the KMSKeyARN option.
       aws lambda update-function-configuration \
  --function-name my-function \
  --kms-key-arn arn:aws:kms:us-east-2:111122223333:key/055efbb4-xmpl-4336-ba9c-538c7d31f599
     
   AWS SAM
       You can use the  AWS Serverless Application Model to configure environment variables for your function. Update the Environment and Variables properties in your template.yaml file and then run sam deploy.
       Example template.yamlAWSTemplateFormatVersion: '2010-09-09'
Transform: AWS::Serverless-2016-10-31
Description: An AWS Serverless Application Model template describing your function.
Resources:
  my-function:
    Type: AWS::Serverless::Function
    Properties:
      CodeUri: .
      Description: ''
      MemorySize: 128
      Timeout: 120
      Handler: index.handler
      Runtime: nodejs22.x
      Architectures:
        - x86_64
      EphemeralStorage:
        Size: 10240
      Environment:
        Variables:
          BUCKET: amzn-s3-demo-bucket
          KEY: file.txt
      # Other function properties...   
     
   AWS SDKs
       To manage environment variables using an AWS SDK, use the following API operations.
         
         
       
       
       
    UpdateFunctionConfigurationGetFunctionConfigurationCreateFunction
       To learn more, refer to the AWS SDK documentation for your preferred programming language.
     
 
   
    Example scenario for environment variables
    
    You can use environment variables to customize function behavior in your test environment and production
      environment. For example, you can create two functions with the same code but different configurations. One
      function connects to a test database, and the other connects to a production database. In this situation, you use
      environment variables to pass the hostname and other connection details for the database to the function. 
    The following example shows how to define the database host and database name as environment variables.
    
       
        
       
       
    
    If you want your test environment to generate more debug information than the production environment, you
      could set an environment variable to configure your test environment to use more verbose logging or more detailed
      tracing.
    For example, in your test environment, you could set an environment variable with the key LOG_LEVEL and a value indicating a log level of 
      debug or trace. In your Lambda function's code, you can then use this environment variable to set the log level.
    The following code examples in Python and Node.js illustrate how you can achieve this. These examples assume your environment variable has a 
      value of DEBUG in Python or debug in Node.js.
    
      Python
          Example Python code to set log levelimport os
import logging

# Initialize the logger
logger = logging.getLogger()

# Get the log level from the environment variable and default to INFO if not set
log_level = os.environ.get('LOG_LEVEL', 'INFO')

# Set the log level
logger.setLevel(log_level)

def lambda_handler(event, context):
    # Produce some example log outputs
    logger.debug('This is a log with detailed debug information - shown only in test environment')
    logger.info('This is a log with standard information - shown in production and test environments')
    

        
      Node.js (ES module format)
          Example Node.js code to set log levelThis example uses the winston logging library. Use npm to add this library to your function's deployment package. For more information, see
              Creating a .zip deployment package with dependencies.import winston from 'winston';

// Initialize the logger using the log level from environment variables, defaulting to INFO if not set
const logger = winston.createLogger({
   level: process.env.LOG_LEVEL || 'info',
   format: winston.format.json(),
   transports: [new winston.transports.Console()]
});

export const handler = async (event) => {
   // Produce some example log outputs
   logger.debug('This is a log with detailed debug information - shown only in test environment');
   logger.info('This is a log with standard information - shown in production and test environment');
   
};
        
    
   
    Retrieving Lambda environment variables
    To retrieve environment variables in your function code, use the standard method for your programming
      language.
    
      Node.js
          let region = process.env.AWS_REGION
        
      Python
          import os
  region = os.environ['AWS_REGION']
          NoteIn some cases, you may need to use the following format:region = os.environ.get('AWS_REGION')
        
      Ruby
          region = ENV["AWS_REGION"]
        
      Java
          String region = System.getenv("AWS_REGION");
        
      Go
          var region = os.Getenv("AWS_REGION")
        
      C#
          string region = Environment.GetEnvironmentVariable("AWS_REGION");
        
      PowerShell
          $region = $env:AWS_REGION
        
    
    
    Lambda stores environment variables securely by encrypting them at rest. You can configure Lambda to use a different encryption key, encrypt
      environment variable values on the client side, or set environment variables in an AWS CloudFormation template with
      AWS Secrets Manager.
   
    Defined runtime environment variables
    Lambda runtimes set several environment variables during initialization.
      Most of the environment variables provide information about the function or runtime. The keys for these
      environment variables are reserved and cannot be set in your function configuration.
    
      Reserved environment variables
       
       
       
       
       
       
       
       
       
       
       
       
       
       
    
        _HANDLER – The handler location configured on the function.
      
        _X_AMZN_TRACE_ID – The X-Ray tracing
          header. This environment variable changes with each invocation.
        
           
           
        
            This environment variable is not defined for OS-only runtimes (the provided runtime family).
              You can set _X_AMZN_TRACE_ID for custom runtimes using the
              Lambda-Runtime-Trace-Id response header from the
              Next invocation.
          
            For Java runtime versions 17 and later, this environment variable is not used.
              Instead, Lambda stores tracing information in the com.amazonaws.xray.traceHeader
              system property.
          
      
        AWS_DEFAULT_REGION – The default AWS Region where the Lambda function is executed.
      
        AWS_REGION – The AWS Region where the Lambda function is executed. If defined, this value overrides the AWS_DEFAULT_REGION.
        
           
        
            For more information about using the AWS Region environment variables with AWS SDKs, see AWS Region 
              in the AWS SDKs and Tools Reference Guide.
          
      
        AWS_EXECUTION_ENV – The runtime identifier,
          prefixed by AWS_Lambda_ (for example, AWS_Lambda_java8). This environment variable is not defined for OS-only runtimes (the provided runtime family).
      
        AWS_LAMBDA_FUNCTION_NAME – The name of the function.
      
        AWS_LAMBDA_FUNCTION_MEMORY_SIZE – The amount of memory available to the function in
          MB.
      
        AWS_LAMBDA_FUNCTION_VERSION – The version of the function being
          executed.
      
        AWS_LAMBDA_INITIALIZATION_TYPE – The initialization type of the function, which is on-demand, provisioned-concurrency, or snap-start. For information, see  Configuring provisioned concurrency or Improving startup performance with Lambda SnapStart.
      
        AWS_LAMBDA_LOG_GROUP_NAME, AWS_LAMBDA_LOG_STREAM_NAME – The name of the
          Amazon CloudWatch Logs group and stream for the function. The AWS_LAMBDA_LOG_GROUP_NAME and AWS_LAMBDA_LOG_STREAM_NAME environment variables are not available in Lambda SnapStart functions.
      
        AWS_ACCESS_KEY, AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY, AWS_SESSION_TOKEN
          – The access keys obtained from the function's execution
            role.
      
        AWS_LAMBDA_RUNTIME_API – (Custom runtime) The
          host and port of the runtime API.
      
        LAMBDA_TASK_ROOT – The path to your Lambda function code.
      
        LAMBDA_RUNTIME_DIR – The path to runtime libraries.
      
    The following additional environment variables aren't reserved and can be extended in your function
      configuration.
    
      Unreserved environment variables
       
       
       
       
       
       
       
       
       
       
    
        LANG – The locale of the runtime (en_US.UTF-8).
      
        PATH – The execution path
          (/usr/local/bin:/usr/bin/:/bin:/opt/bin).
      
        LD_LIBRARY_PATH – The system library path
          (/var/lang/lib:/lib64:/usr/lib64:$LAMBDA_RUNTIME_DIR:$LAMBDA_RUNTIME_DIR/lib:$LAMBDA_TASK_ROOT:$LAMBDA_TASK_ROOT/lib:/opt/lib).
      
        NODE_PATH – (Node.js) The Node.js library path
          (/opt/nodejs/node12/node_modules/:/opt/nodejs/node_modules:$LAMBDA_RUNTIME_DIR/node_modules).
      
        PYTHONPATH – (Python) The Python
          library path ($LAMBDA_RUNTIME_DIR).
      
        GEM_PATH – (Ruby) The Ruby library path
          ($LAMBDA_TASK_ROOT/vendor/bundle/ruby/3.3.0:/opt/ruby/gems/3.3.0).
      
        AWS_XRAY_CONTEXT_MISSING – For X-Ray tracing, Lambda sets this to
          LOG_ERROR to avoid throwing runtime errors from the X-Ray SDK.
      
        AWS_XRAY_DAEMON_ADDRESS – For X-Ray tracing, the IP address and port of the X-Ray
          daemon.
      
        AWS_LAMBDA_DOTNET_PREJIT – (.NET) Set this variable to enable or
          disable .NET specific runtime optimizations. Values include always, never, and
          provisioned-concurrency. For more information, see Configuring provisioned concurrency for a function.
      
        TZ – The environment's time zone (:UTC). The execution environment uses
          NTP to synchronize the system clock.
      
    The sample values shown reflect the latest runtimes. The presence of specific variables or their values can
      vary on earlier runtimes.
  Document ConventionsTimeoutSecuring environment variablesDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideRuntime environment lifecycleCold starts and latencyReducing cold starts with Provisioned ConcurrencyOptimizing static initializationUnderstanding the Lambda execution environment lifecycle
      Lambda invokes your function in an execution environment, which provides a secure and isolated runtime
      environment. The execution environment manages the resources required to run your function. The execution
      environment also provides lifecycle support for the function's runtime and any external extensions associated with your function.
    The function's runtime communicates with Lambda using the Runtime API.
    Extensions communicate with Lambda using the Extensions API.
    Extensions can also receive log messages and other telemetry from the function by using the Telemetry API.
    
         
          
         
         
    When you create your Lambda function, you specify configuration information, such as the amount of memory
    available and the maximum execution time allowed for your function. Lambda uses this information to set up the
    execution environment.The function's runtime and each external extension are processes that run within the execution environment.
    Permissions, resources, credentials, and environment variables are shared between the function and the
    extensions.TopicsLambda execution environment lifecycleCold starts and latencyReducing cold starts with Provisioned ConcurrencyOptimizing static initialization
      Lambda execution environment lifecycle    
        
           
            
           
           
        
        Each phase starts with an event that Lambda sends to the runtime and to all registered extensions. The
        runtime and each extension indicate completion by sending a Next API request. Lambda freezes the
        execution environment when the runtime and each extension have completed and there are no pending events.
        TopicsInit phaseFailures during the Init phaseRestore phase (Lambda SnapStart only)Invoke phaseFailures during the invoke phaseShutdown phase
       
        Init phase
        In the Init phase, Lambda performs three tasks:
        
           
           
           
           
        
            Start all extensions (Extension init)
          
            Bootstrap the runtime (Runtime init)
          
            Run the function's static code (Function init)
          
            Run any before-checkpoint runtime hooks (Lambda SnapStart only)
          
        The Init phase ends when the runtime and all extensions signal that they are ready by sending a
            Next API request. The Init phase is limited to 10 seconds. If all three tasks do not
          complete within 10 seconds, Lambda retries the Init phase at the time of the first function
          invocation with the configured function timeout.
          When Lambda SnapStart is activated, the Init phase happens when you publish a function version. Lambda saves a snapshot of the memory and disk state of the initialized execution environment, persists the encrypted snapshot, and caches it for low-latency access. If you have a before-checkpoint runtime hook, then the code runs at the end of Init phase.
          NoteThe 10-second timeout doesn't apply to functions that are using provisioned concurrency
              or SnapStart. For provisioned concurrency and SnapStart functions, your initialization code
              can run for up to 15 minutes. The time limit is 130 seconds or the configured function
              timeout (maximum 900 seconds), whichever is higher.
        When you use provisioned concurrency,
          Lambda initializes the execution environment when you configure the PC settings for a function. Lambda also ensures that
          initialized execution environments are always available in advance of invocations. You may see gaps between your function's
          invocation and initialization phases. Depending on your function's runtime and memory configuration, you may also see variable
          latency on the first invocation on an initialized execution environment.
        For functions using on-demand concurrency, Lambda may occasionally initialize execution environments ahead of
          invocation requests. When this happens, you may also observe a time gap between your function's initialization and
          invocation phases. We recommend you to not take a dependency on this behavior.
       
       
        Failures during the Init phase
        If a function crashes or times out during the Init phase, Lambda emits error information in the INIT_REPORT log.
    Example  — INIT_REPORT log for timeoutINIT_REPORT Init Duration: 1236.04 ms Phase: init Status: timeout       
    Example  — INIT_REPORT log for extension failureINIT_REPORT Init Duration: 1236.04 ms Phase: init Status: error Error Type: Extension.Crash		
        If the Init phase is successful, Lambda doesn't emit the INIT_REPORT log unless SnapStart or 
          provisioned concurrency is enabled. SnapStart and provisioned concurrency functions always emit INIT_REPORT. 
          For more information, see Monitoring for Lambda SnapStart.
        
       
        Restore phase (Lambda SnapStart only)
        When you first invoke a SnapStart function and as the function scales up, Lambda resumes new execution environments from the persisted snapshot instead of initializing the function from scratch. If you have an after-restore runtime hook, the code runs at the end of the Restore phase. You are charged for the duration of after-restore runtime hooks. The runtime must load and after-restore runtime hooks must complete within the timeout limit (10 seconds). Otherwise, you'll get a SnapStartTimeoutException. When the Restore phase completes, Lambda invokes the function handler (the Invoke phase).
         
          Failures during the Restore phase
          If the Restore phase fails, Lambda emits error information in the RESTORE_REPORT log.
      Example  — RESTORE_REPORT log for timeoutRESTORE_REPORT Restore Duration: 1236.04 ms Status: timeout
      Example  — RESTORE_REPORT log for runtime hook failureRESTORE_REPORT Restore Duration: 1236.04 ms Status: error Error Type: Runtime.ExitError		
        For more information about the RESTORE_REPORT log, see Monitoring for Lambda SnapStart.
         
       
       
        Invoke phase
        When a Lambda function is invoked in response to a Next API request, Lambda sends an
            Invoke event to the runtime and to each extension.
        The function's timeout setting limits the duration of the entire Invoke phase. For example, if
          you set the function timeout as 360 seconds, the function and all extensions need to complete within 360
          seconds. Note that there is no independent post-invoke phase. The duration is the sum of all invocation time
          (runtime + extensions) and is not calculated until the function and all extensions have finished
          executing.
        The invoke phase ends after the runtime and all extensions signal that they are done by sending a
            Next API request.
       
       
        Failures during the invoke phase
        If the Lambda function crashes or times out during the Invoke phase, Lambda resets the
          execution environment. The following diagram illustrates Lambda execution environment behavior when
          there's an invoke failure:
        
           
            
           
           
        
        In the previous diagram:
        
           
           
           
           
           
        
            The first phase is the INIT phase, which runs
              without errors.
          
            The second phase is the INVOKE phase, which runs
              without errors.
          
            At some point, suppose your function runs into an invoke failure (such as a function
              timeout or runtime error). The third phase, labeled INVOKE WITH ERROR
              , illustrates this scenario. When this happens, the Lambda service performs a
              reset. The reset behaves like a Shutdown event. First, Lambda shuts down the
              runtime, then sends a Shutdown event to each registered external extension.
              The event includes the reason for the shutdown. If this environment is used for a new
              invocation, Lambda re-initializes the extension and runtime together with the next
              invocation.
            
            Note that the Lambda reset does not clear the /tmp directory content prior to the next init phase.
              This behavior is consistent with the regular shutdown phase.
            NoteAWS is currently implementing changes to the Lambda service. Due to these changes, you may see minor differences between the structure and content 
of system log messages and trace segments emitted by different Lambda functions in your AWS account.If your function's system log configuration is set to plain text, this change affects the log messages captured in CloudWatch Logs when your 
                function experiences an invoke failure. The following examples show log outputs in both old and new formats.These changes will be implemented during the coming weeks, and all functions in all 
AWS Regions except the China and GovCloud regions will transition to use the new-format log messages and trace segments.
            
            Example CloudWatch Logs log output (runtime or extension crash) - old styleSTART RequestId: c3252230-c73d-49f6-8844-968c01d1e2e1 Version: $LATEST
RequestId: c3252230-c73d-49f6-8844-968c01d1e2e1 Error: Runtime exited without providing a reason
Runtime.ExitError
END RequestId: c3252230-c73d-49f6-8844-968c01d1e2e1
REPORT RequestId: c3252230-c73d-49f6-8844-968c01d1e2e1 Duration: 933.59 ms Billed Duration: 934 ms Memory Size: 128 MB Max Memory Used: 9 MB
            Example CloudWatch Logs log output (function timeout) - old styleSTART RequestId: b70435cc-261c-4438-b9b6-efe4c8f04b21 Version: $LATEST
2024-03-04T17:22:38.033Z b70435cc-261c-4438-b9b6-efe4c8f04b21 Task timed out after 3.00 seconds
END RequestId: b70435cc-261c-4438-b9b6-efe4c8f04b21
REPORT RequestId: b70435cc-261c-4438-b9b6-efe4c8f04b21 Duration: 3004.92 ms Billed Duration: 3000 ms Memory Size: 128 MB Max Memory Used: 33 MB Init Duration: 111.23 ms
            The new format for CloudWatch logs includes an additional statusfield in the REPORT line. In the case of a runtime or 
              extension crash, the REPORT line also includes a field ErrorType.
            
            Example CloudWatch Logs log output (runtime or extension crash) - new styleSTART RequestId: 5b866fb1-7154-4af6-8078-6ef6ca4c2ddd Version: $LATEST
END RequestId: 5b866fb1-7154-4af6-8078-6ef6ca4c2ddd
REPORT RequestId: 5b866fb1-7154-4af6-8078-6ef6ca4c2ddd Duration: 133.61 ms Billed Duration: 133 ms Memory Size: 128 MB Max Memory Used: 31 MB Init Duration: 80.00 ms Status: error Error Type: Runtime.ExitError
            Example CloudWatch Logs log output (function timeout) - new styleSTART RequestId: 527cb862-4f5e-49a9-9ae4-a7edc90f0fda Version: $LATEST
END RequestId: 527cb862-4f5e-49a9-9ae4-a7edc90f0fda
REPORT RequestId: 527cb862-4f5e-49a9-9ae4-a7edc90f0fda Duration: 3016.78 ms Billed Duration: 3016 ms Memory Size: 128 MB Max Memory Used: 31 MB Init Duration: 84.00 ms Status: timeout
          
            The fourth phase represents the INVOKE phase
              immediately following an invoke failure. Here, Lambda initializes the environment again
              by re-running the INIT phase. This is called a
              suppressed init. When suppressed inits occur, Lambda doesn't
              explicitly report an additional INIT phase in CloudWatch Logs.
              Instead, you may notice that the duration in the REPORT line includes an additional
              INIT duration + the
              INVOKE duration. For example, suppose you see the
              following logs in CloudWatch:
            2022-12-20T01:00:00.000-08:00 START RequestId: XXX Version: $LATEST 
2022-12-20T01:00:02.500-08:00 END RequestId: XXX 
2022-12-20T01:00:02.500-08:00 REPORT RequestId: XXX Duration: 3022.91 ms 
Billed Duration: 3000 ms Memory Size: 512 MB Max Memory Used: 157 MB
            In this example, the difference between the REPORT and START timestamps is 2.5 seconds.
              This doesn't match the reported duration of 3022.91 millseconds, because it doesn't take
              into account the extra INIT (suppressed init) that Lambda
              performed. In this example, you can infer that the actual
              INVOKE phase took 2.5 seconds.
            For more insight into this behavior, you can use the
              Accessing real-time telemetry data for extensions using the Telemetry API. The Telemetry API emits
              INIT_START, INIT_RUNTIME_DONE, and INIT_REPORT
              events with phase=invoke whenever suppressed inits occur in between
              invoke phases.
          
            The fifth phase represents the SHUTDOWN phase, which runs
              without errors.
          
       
       
        Shutdown phase
        When Lambda is about to shut down the runtime, it sends a Shutdown event to
          each registered external extension. Extensions can use this time for final cleanup tasks. The Shutdown event
          is a response to a Next API request.
        Duration limit: The maximum duration of the
          Shutdown phase depends on the configuration of registered extensions:
      
         
         
         
      
          0 ms – A function with no registered extensions
        
          500 ms – A function with a registered internal extension
        
          2,000 ms – A function with one or more registered external extensions
        
      If the runtime or an extension does not respond to the Shutdown event within the limit, Lambda
        ends the process using a SIGKILL signal.
        After the function and all extensions have completed, Lambda maintains the execution
          environment for some time in anticipation of another function invocation. However, Lambda terminates execution environments every few hours to allow for runtime updates and maintenance—even for functions that are invoked continuously. You should
          not assume that the execution environment will persist indefinitely. For more information, see
          Implement statelessness in functions.
        When the function is invoked again, Lambda thaws the environment for reuse. Reusing the
        execution environment has the following implications: 
        
           
           
           
        
            Objects declared outside of the function's handler method remain initialized, providing additional
              optimization when the function is invoked again. For example, if your Lambda function establishes a database
              connection, instead of reestablishing the connection, the original connection is used in subsequent
              invocations. We recommend adding logic in your code to check if a connection exists before creating a new
              one.
          
            Each execution environment provides between 512 MB and 10,240 MB, in 1-MB increments, of disk space in the /tmp
              directory. The directory content remains when the execution environment is frozen, providing a transient
              cache that can be used for multiple invocations. You can add extra code to check if the cache has the data
              that you stored. For more information on deployment size limits, see Lambda quotas.
          
            Background processes or callbacks that were initiated by your Lambda function and did not complete when
              the function ended resume if Lambda reuses the execution environment. Make sure that any background processes
              or callbacks in your code are complete before the code exits.
          
         
     
    Cold starts and latency
    When Lambda receives a request to run a function via the Lambda API, the service first prepares an execution
      environment. During this initialization phase, the service downloads your code, starts the environment, and
      runs any initialization code outside of the main handler. Finally, Lambda runs the handler code.
    
       
        
       
       
    
    In this diagram, the first two steps of downloading the code and setting up the environment are frequently referred
      to as a “cold start”. You are not charged for this time, but it does add latency to your overall invocation duration.
    After the invocation completes, the execution environment is frozen. To improve resource management and performance,
      Lambda retains the execution environment for a period of time. During this time, if another request arrives for the same
      function, Lambda can reuse the environment. This second request typically finishes more quickly, since the execution
      environment is already fully set up. This is called a “warm start”.
    Cold starts typically occur in under 1% of invocations. The duration of a cold start varies from under 100 ms to over
      1 second. In general, cold starts are typically more common in development and test functions than production workloads.
      This is because development and test functions are usually invoked less frequently.
   
    Reducing cold starts with Provisioned Concurrency
    If you need predictable function start times for your workload, provisioned
      concurrency is the recommended solution to ensure the lowest possible latency. This feature pre-initializes
      execution environments, reducing cold starts.
    For example, a function with a provisioned concurrency of 6 has 6 execution environments pre-warmed.
    
       
        
       
       
    
   
    Optimizing static initialization
    Static initialization happens before the handler code starts running in a function. This is the initialization code
      that you provide, that is outside of the main handler. This code is often used to import libraries and dependencies,
      set up configurations, and initialize connections to other services.
    The following Python example shows importing, and configuring modules, and creating the Amazon S3 client during the
      initialization phase, before the lambda_handler function runs during invoke.
    import os
import json
import cv2
import logging
import boto3

s3 = boto3.client('s3')
logger = logging.getLogger()
logger.setLevel(logging.INFO)

def lambda_handler(event, context):

  # Handler logic...

    The largest contributor of latency before function execution comes from initialization code. This code runs when
      a new execution environment is created for the first time. The initialization code is not run again if an invocation
      uses a warm execution environment. Factors that affect initialization code latency include:
    
       
       
       
    
        The size of the function package, in terms of imported libraries and dependencies, and Lambda layers.
      
        The amount of code and initialization work.
      
        The performance of libraries and other services in setting up connections and other resources.
      
    There are a number of steps that developers can take to optimize static initialization latency. If a function has
      many objects and connections, you may be able to rearchitect a single function into multiple, specialized functions.
      These are individually smaller and each have less initialization code.
    It’s important that functions only import the libraries and dependencies that they need. For example, if you only
      use Amazon DynamoDB in the AWS SDK, you can require an individual service instead of the entire SDK. Compare the following
      three examples:
    // Instead of const AWS = require('aws-sdk'), use:
const DynamoDB = require('aws-sdk/clients/dynamodb')

// Instead of const AWSXRay = require('aws-xray-sdk'), use:
const AWSXRay = require('aws-xray-sdk-core')

// Instead of const AWS = AWSXRay.captureAWS(require('aws-sdk')), use:
const dynamodb = new DynamoDB.DocumentClient()
AWSXRay.captureAWSClient(dynamodb.service)
    Static initialization is also often the best place to open database connections to allow a function to reuse
      connections over multiple invocations to the same execution environment. However, you may have large numbers of
      objects that are only used in certain execution paths in your function. In this case, you can lazily load variables
      in the global scope to reduce the static initialization duration.
    Avoid global variables for context-specific information. If your function has a global variable that is used
      only for the lifetime of a single invocation and is reset for the next invocation, use a variable scope that is
      local to the handler. Not only does this prevent global variable leaks across invocations, it also improves the
      static initialization performance.
  Document ConventionsProgramming modelEvent-driven architecturesDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS SDK for JavaScriptDeveloper Guide for SDK Version 3 The AWS SDK for JavaScript V3 API
            Reference Guide describes in detail all the API operations for the AWS SDK for JavaScript
         version 3 (V3). Reuse connections with keep-alive in
                    Node.jsThe default Node.js HTTP/HTTPS agent creates a new TCP connection for every new
                request. To avoid the cost of establishing a new connection, the AWS SDK for JavaScript reuses TCP
                connections by default.For short-lived operations, such as Amazon DynamoDB queries, the latency overhead of
                setting up a TCP connection might be greater than the operation itself.
                Additionally, since DynamoDB encryption
                at rest is integrated with AWS KMS, you may experience latencies from the database having to re-establish
                new AWS KMS cache entries for each operation. If you do not want to reuse TCP connections, you can disable reusing these connections alive with keepAlive on a per-service client
                basis as shown in the following example for a DynamoDB client.import { DynamoDBClient } from "@aws-sdk/client-dynamodb";
import { NodeHttpHandler } from "@smithy/node-http-handler";
import { Agent } from "https";

const dynamodbClient = new DynamoDBClient({
    requestHandler: new NodeHttpHandler({
        httpsAgent: new Agent({ keepAlive: false })
    })
});If keepAlive is enabled, you can also set the initial delay for TCP
                Keep-Alive packets with keepAliveMsecs, which by default is 1000 ms.
                See the Node.js documentation
                for details.Document ConventionsConfigure maxSockets in Node.jsConfigure proxies for Node.jsDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaAPI ReferenceCertificate errors when using an SDK WelcomeThis section contains the AWS Lambda API Reference documentation. Instead of making requests
        to the API directly from your application, we recommend that you use one of the
        AWS Software Development Kits (SDKs) for your programming language. The
        AWS SDKs take care of request authentication, serialization, and connection
        management. If you don't use the AWS SDK, you will need to authenticate your
        request by providing a signature. AWS Lambda supports signature version 4. For more information,
        see Signature Version 4 signing process in the
        Amazon Web Services General Reference.
        Certificate errors when using an SDK 
        Because AWS SDKs use the CA certificates from your computer, changes to the certificates on the AWS servers
            can cause connection failures when you attempt to use an SDK. You can prevent these failures by keeping your
            computer's CA certificates and operating system up-to-date. If you encounter this issue in a corporate
            environment and do not manage your own computer, you might need to ask an administrator to assist with the
            update process. The following list shows minimum operating system and Java versions:
        
             
             
             
             
        
                Microsoft Windows versions that have updates from January 2005 or later installed contain at least one
                    of the required CAs in their trust list. 
            
                Mac OS X 10.4 with Java for Mac OS X 10.4 Release 5 (February 2007), Mac OS X 10.5 (October 2007), and
                    later versions contain at least one of the required CAs in their trust list. 
            
                Red Hat Enterprise Linux 5 (March 2007), 6, and 7 and CentOS 5, 6, and 7 all contain at least one of the
                    required CAs in their default trusted CA list. 
            
                Java 1.4.2_12 (May 2006), 5 Update 2 (March 2005), and all later versions, including Java 6 (December
                    2006), 7, and 8, contain at least one of the required CAs in their default trusted CA list. 
            
        When accessing the AWS Lambda management console or AWS Lambda API endpoints, whether through browsers or
            programmatically, you will need to ensure your client machines support any of the following CAs: 
        
             
             
             
        
                Amazon Root CA 1
            
                Starfield Services Root Certificate Authority - G2
            
                Starfield Class 2 Certification Authority
            
        Root certificates from the first two authorities are available from Amazon trust services, but keeping your computer
            up-to-date is the more straightforward solution. To learn more about ACM-provided certificates, see AWS Certificate Manager FAQs.
        
    Document ConventionsActionsDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationReference guideAWS security credentialsAWS IP address rangesAWS APIsAWS services endpoints and quotasAWS GlossaryAWS General ReferenceThe AWS General Reference provides AWS service endpoint and quota information for Amazon Web Services. Additionally, you can find links to other common topics.ContentsAWS security credentialsAWS IP address rangesAWS APIsAWS services endpoints and quotasAWS Glossary
    AWS security credentials
    
    When you interact with AWS, you specify your AWS security
      credentials to verify who you are and whether you have permission to access the
      resources that you are requesting. AWS uses the security credentials to authenticate and
      authorize your requests.
 
    For more information, see the following resources:
        
    
       
       
      
    
      
      AWS security credentials in the
        IAM User GuideAWS
        security audit guidelines in the
        IAM User Guide
    
   
    AWS IP address ranges
    
    AWS publishes its current IP address ranges in JSON format. You can download
      a .json file to view current ranges. 
    The IP address ranges that you bring to AWS through bring your own IP addresses (BYOIP)
      are not included in the .json file.
    For more information, see the following resources:
    
    
       
       
    AWS IP address ranges in the
        Amazon VPC User GuideAWS services that support IPv6 in the
        Amazon VPC User Guide
   
    AWS APIs
    
    The following pages provide information that is useful when using an AWS API:
    
    
       
       
    Retry behavior in the
        AWS SDKs and Tools Reference GuideSigning AWS API requests in the
        IAM User Guide
    
   
    AWS services endpoints and quotas
    
    You can learn about the endpoints and service quotas in the following pages:
    
    
       
       
       
       
    AWS service endpointsAWS service quotasService endpoints and quotasSpecifying which AWS Regions your account can use in the AWS Account Management Guide
    
    
    
    
    
    
    
   
    AWS Glossary
    
    For the latest AWS terminology, see the AWS Glossary.  
  Document ConventionsAWS service endpointsDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideWhen to use LambdaKey featuresWhat is AWS Lambda?You can use AWS Lambda to run code without provisioning or managing servers. Lambda runs your code
    on a high-availability compute infrastructure and performs all of the administration of the compute resources,
    including server and operating system maintenance, capacity provisioning and automatic scaling, and
    logging. With Lambda, all you need to do is supply your code in one of the language runtimes that Lambda supports.You organize your code into Lambda functions. The Lambda service runs your function only when needed and scales automatically. You only pay for the compute time that you consume—there is no charge when your code is not running. For more information, see AWS Lambda Pricing.TipTo learn how to build serverless solutions, check out the Serverless Developer Guide.
    When to use Lambda
    Lambda is an ideal compute service for application scenarios that need to scale up rapidly, and scale down to
      zero when not in demand. For example, you can use Lambda for:
  
     
     
     
     
     
  
      File processing: Use Amazon Simple Storage Service (Amazon S3) to trigger Lambda data processing in real time after an upload.
    
      Stream processing: Use Lambda and Amazon Kinesis to process real-time streaming data for application activity tracking, transaction order processing, clickstream analysis, data cleansing, log filtering, indexing, social media analysis, Internet of Things (IoT) device data telemetry, and metering.
    
      Web applications: Combine Lambda with other AWS services to build powerful web applications that automatically scale up and down and run in a highly available configuration across multiple data centers.
    
      IoT backends: Build serverless backends using Lambda to handle web, mobile, IoT, and third-party API requests.
    
      Mobile backends: Build backends using Lambda and Amazon API Gateway  to authenticate and process API requests. Use AWS Amplify to easily integrate with your iOS, Android, Web, and React Native frontends.
    
    When using Lambda, you are responsible only for your code. Lambda manages the compute fleet that offers a
      balance of memory, CPU, network, and other resources to run your code. Because Lambda manages these resources, you
      cannot log in to compute instances or customize the operating system on provided
        runtimes. Lambda performs operational and administrative activities on your behalf, including managing
      capacity, monitoring, and logging your Lambda functions.
   
    Key features
    The following key features help you develop Lambda applications that are scalable, secure, and easily
      extensible:

    
    
       

       
      
       
      
       
      
       
  
       
      
       
           
       

       
      
       

       

       
      
    
        Environment variables
        
          Use environment variables to adjust your function's behavior without updating code.
        
      
        Versions
        
          Manage the deployment of your functions with versions, so that, for example, a new function can be used for beta testing without affecting users of the stable production version.
        
      
        Container images
        
          Create a container image for a Lambda function by using an AWS provided base image or an alternative base
            image so that you can reuse your existing container tooling or deploy larger workloads that rely on sizable dependencies, such as machine learning.
        
      
        Lambda layers
        
          Package libraries and other dependencies to reduce the size of deployment archives and makes it faster to deploy your code.
        
      
        Lambda extensions
        
          Augment your Lambda functions with tools for monitoring, observability, security, and governance.
        
      
        Function URLs
        
          Add a dedicated HTTP(S) endpoint to your Lambda function.
        
      
        Response streaming
        
          Configure your Lambda function URLs to stream response payloads back to clients from Node.js functions, to improve time to first byte (TTFB) performance or to return larger payloads.
        
      
        Concurrency and scaling controls
        
          Apply fine-grained control over the scaling and responsiveness of your production applications.
        
      
        Code signing
        
          Verify that only approved developers publish unaltered, trusted code in your Lambda functions 
        
      
        Private networking
        
          Create a private network for resources such as databases, cache instances, or internal services.
        
      
        File system
        
          Configure a function to mount an Amazon Elastic File System (Amazon EFS) to a local directory, so that your function code can access and modify shared resources safely and at high concurrency.
        
      
        Lambda SnapStart
        
          Lambda SnapStart can provide as low as sub-second startup performance, typically with no changes to your function code.
        
      
  Document ConventionsCreate your first functionDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideWhen to use LambdaKey featuresWhat is AWS Lambda?You can use AWS Lambda to run code without provisioning or managing servers. Lambda runs your code
    on a high-availability compute infrastructure and performs all of the administration of the compute resources,
    including server and operating system maintenance, capacity provisioning and automatic scaling, and
    logging. With Lambda, all you need to do is supply your code in one of the language runtimes that Lambda supports.You organize your code into Lambda functions. The Lambda service runs your function only when needed and scales automatically. You only pay for the compute time that you consume—there is no charge when your code is not running. For more information, see AWS Lambda Pricing.TipTo learn how to build serverless solutions, check out the Serverless Developer Guide.
    When to use Lambda
    Lambda is an ideal compute service for application scenarios that need to scale up rapidly, and scale down to
      zero when not in demand. For example, you can use Lambda for:
  
     
     
     
     
     
  
      File processing: Use Amazon Simple Storage Service (Amazon S3) to trigger Lambda data processing in real time after an upload.
    
      Stream processing: Use Lambda and Amazon Kinesis to process real-time streaming data for application activity tracking, transaction order processing, clickstream analysis, data cleansing, log filtering, indexing, social media analysis, Internet of Things (IoT) device data telemetry, and metering.
    
      Web applications: Combine Lambda with other AWS services to build powerful web applications that automatically scale up and down and run in a highly available configuration across multiple data centers.
    
      IoT backends: Build serverless backends using Lambda to handle web, mobile, IoT, and third-party API requests.
    
      Mobile backends: Build backends using Lambda and Amazon API Gateway  to authenticate and process API requests. Use AWS Amplify to easily integrate with your iOS, Android, Web, and React Native frontends.
    
    When using Lambda, you are responsible only for your code. Lambda manages the compute fleet that offers a
      balance of memory, CPU, network, and other resources to run your code. Because Lambda manages these resources, you
      cannot log in to compute instances or customize the operating system on provided
        runtimes. Lambda performs operational and administrative activities on your behalf, including managing
      capacity, monitoring, and logging your Lambda functions.
   
    Key features
    The following key features help you develop Lambda applications that are scalable, secure, and easily
      extensible:

    
    
       

       
      
       
      
       
      
       
  
       
      
       
           
       

       
      
       

       

       
      
    
        Environment variables
        
          Use environment variables to adjust your function's behavior without updating code.
        
      
        Versions
        
          Manage the deployment of your functions with versions, so that, for example, a new function can be used for beta testing without affecting users of the stable production version.
        
      
        Container images
        
          Create a container image for a Lambda function by using an AWS provided base image or an alternative base
            image so that you can reuse your existing container tooling or deploy larger workloads that rely on sizable dependencies, such as machine learning.
        
      
        Lambda layers
        
          Package libraries and other dependencies to reduce the size of deployment archives and makes it faster to deploy your code.
        
      
        Lambda extensions
        
          Augment your Lambda functions with tools for monitoring, observability, security, and governance.
        
      
        Function URLs
        
          Add a dedicated HTTP(S) endpoint to your Lambda function.
        
      
        Response streaming
        
          Configure your Lambda function URLs to stream response payloads back to clients from Node.js functions, to improve time to first byte (TTFB) performance or to return larger payloads.
        
      
        Concurrency and scaling controls
        
          Apply fine-grained control over the scaling and responsiveness of your production applications.
        
      
        Code signing
        
          Verify that only approved developers publish unaltered, trusted code in your Lambda functions 
        
      
        Private networking
        
          Create a private network for resources such as databases, cache instances, or internal services.
        
      
        File system
        
          Configure a function to mount an Amazon Elastic File System (Amazon EFS) to a local directory, so that your function code can access and modify shared resources safely and at high concurrency.
        
      
        Lambda SnapStart
        
          Lambda SnapStart can provide as low as sub-second startup performance, typically with no changes to your function code.
        
      
  Document ConventionsCreate your first functionDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideCreating function versionsUsing versionsGranting permissionsManage Lambda function versionsYou can use versions to manage the deployment of your functions. For example, you can publish a new version of a
    function for beta testing without affecting users of the stable production version. Lambda creates a new version of
    your function each time that you publish the function. The new version is a copy of the unpublished version of the
    function. The unpublished version is named $LATEST.Importantly, any time you deploy your function code, you overwrite the current code in $LATEST.
    To save the current iteration of $LATEST, create a new function version. If $LATEST
    is identical to a previously published version, you won't be able to create a new version until you deploy changes
    to $LATEST. These changes can include updating the code, or modifying the function configuration settings.After you publish a function version, its code, runtime, architecture, memory, layers, and
    most other configuration settings are immutable. This means that you can't change these settings
    without publishing a new version from $LATEST. You can configure the following items for a
    published function version:
     
     
     
     
     
  TriggersDestinationsProvisioned concurrencyAsynchronous invocationDatabase connections and proxiesNoteWhen using runtime management controls with Auto
      mode, the runtime version used by the function version is updated automatically. 
      When using Function update or Manual mode, the runtime version is not updated.
      For more information, see Understanding how Lambda manages runtime version updates.SectionsCreating function versionsUsing versionsGranting permissions
    Creating function versions
    You can change the function code and settings only on the unpublished version of a function. When you publish
      a version, Lambda locks the code and most of the settings to maintain a consistent experience for users of that
      version.
    You can create a function version using the Lambda console.
    To create a new function versionOpen the Functions page of the Lambda console.
        Choose a function and then choose the Versions tab.
      
        On the versions configuration page, choose Publish new
          version.
      
        (Optional) Enter a version description.
      
        Choose Publish.
      
    Alternatively, you can publish a version of a function using the PublishVersion API operation.
    The following AWS CLI command publishes a new version of a function. The response returns configuration information
      about the new version, including the version number and the function ARN with the version suffix.
    aws lambda publish-version --function-name my-function
    You should see the following output:
{
  "FunctionName": "my-function",
  "FunctionArn": "arn:aws:lambda:us-east-2:123456789012:function:my-function:1",
  "Version": "1",
  "Role": "arn:aws:iam::123456789012:role/lambda-role",
  "Handler": "function.handler",
  "Runtime": "nodejs22.x",
  ...
}
    NoteLambda assigns monotonically increasing sequence numbers for versioning. Lambda never reuses version
      numbers, even after you delete and recreate a function.
   
    Using versions
    You can reference your Lambda function using either a qualified ARN or an unqualified ARN.
    
       
       
    
        Qualified ARN – The function ARN with a version suffix. The
          following example refers to version 42 of the helloworld function.
        arn:aws:lambda:aws-region:acct-id:function:helloworld:42       
      
        Unqualified ARN – The function ARN without a version suffix.
        arn:aws:lambda:aws-region:acct-id:function:helloworld
      
    You can use a qualified or an unqualified ARN in all relevant API operations. However, you can't use an
      unqualified ARN to create an alias.
    If you decide not to publish function versions, you can invoke the function using either the qualified or
      unqualified ARN in your event source mapping. When you invoke
      a function using an unqualified ARN, Lambda implicitly invokes $LATEST.
    Lambda publishes a new function version only if the code has never been published, or if
      the code has changed from the last published version. If there is no change, the function
      version remains at the last published version.
    The qualified ARN for each Lambda function version is unique. After you publish a version, you can't change the
      ARN or the function code.
   
    Granting permissions
    You can use a resource-based policy or an identity-based policy to grant access to your function. The scope
      of the permission depends on whether you apply the policy to a function or to one version of a function. For more
      information about function resource names in policies, see Fine-tuning the Resources and Conditions sections of policies. 
    You can simplify the management of event sources and AWS Identity and Access Management (IAM) policies by using function aliases. For
      more information, see Create an alias for a Lambda function.
  Document ConventionsWeighted aliasesTagsDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideRequirementsUsing an AWS base imageUsing an AWS OS-only base imageUsing a non-AWS base imageRuntime interface clientsAmazon ECR permissionsFunction lifecycleCreate a Lambda function using a container imageYour AWS Lambda function's code consists of scripts or compiled programs and their dependencies. 
You use a deployment package to deploy your function code to Lambda. Lambda supports two types of deployment packages: 
container images and .zip file archives. There are three ways to build a container image for a Lambda function:
     
	 
     
  
      Using an AWS base image for Lambda
      The AWS base images are preloaded with a language runtime, a runtime interface client to manage the interaction between Lambda and your function code, and a runtime interface emulator for local testing.
    
      Using an AWS OS-only base image
      AWS OS-only base images contain an Amazon Linux distribution and the runtime interface emulator. These images are commonly used to create container images for compiled languages, such as Go and Rust, and for a language or language version that Lambda doesn't provide a base image for, such as Node.js 19. You can also use OS-only base images to implement a custom runtime. To make the image compatible with Lambda, you must include a runtime interface client for your language in the image.
    
      Using a non-AWS base image
      You can use an alternative base image from another container registry, such as Alpine Linux or Debian. You can also use a custom image created by your organization. To make the image compatible with Lambda, you must include a runtime interface client for your language in the image.
    TipTo reduce the time it takes for Lambda container functions to become active, see Use multi-stage builds in the Docker documentation. To build efficient container images, follow the Best practices for writing Dockerfiles.To create a Lambda function from a container image, build your image locally and upload it to an Amazon Elastic Container Registry
    (Amazon ECR) repository. If you're using a container image provided by an AWS Marketplace seller, you need to clone the
    image to your private Amazon ECR repository first. Then, specify the repository URI when you create the function.
    The Amazon ECR repository must be in the same AWS Region as the Lambda function. You can create a function using an image in a different AWS account, as long as the image is in the same Region as the Lambda function. For more information, see  Amazon ECR cross-account permissions.NoteLambda does not support Amazon ECR FIPS endpoints for container images. If your repository URI includes
      ecr-fips, you are using a FIPS endpoint. Example: 111122223333.dkr.ecr-fips.us-east-1.amazonaws.com.This page explains the base image types and requirements for creating Lambda-compatible container images.NoteYou cannot change the deployment package type (.zip or container image) for an existing function. For example, you cannot convert a container image function to use a .zip file archive. You must create a new function.TopicsRequirementsUsing an AWS base image for LambdaUsing an AWS OS-only base imageUsing a non-AWS base imageRuntime interface clientsAmazon ECR permissionsFunction lifecycle
    Requirements
    Install the AWS CLI version 2 and the Docker CLI. 
      Additionally, note the following requirements:
    
       
       
       
       
       
    
        The container image must implement the Using the Lambda runtime API for custom runtimes. The AWS
          open-source runtime interface clients implement the API. You can
          add a runtime interface client to your preferred base image to make it compatible with Lambda.
      
        The container image must be able to run on a read-only file system. Your function code can access a
          writable /tmp directory with between 512 MB and 10,240 MB, in 1-MB increments, of storage.  
      
        The default Lambda user must be able to read all the files required to run your function code. Lambda
          follows security best practices by defining a default Linux user with least-privileged permissions. This means that you don't need to specify a USER  in your Dockerfile. Verify
          that your application code does not rely on files that other Linux users are restricted from running.
      
        Lambda supports only Linux-based container images.
      
        Lambda provides multi-architecture base images. However, the image you build for your function must target
          only one of the architectures. Lambda does not support functions that use multi-architecture container
          images.
      
   
    Using an AWS base image for Lambda
    You can use one of the AWS base images for Lambda to build the container image for your
      function code. The base images are preloaded with a language runtime and other components
      required to run a container image on Lambda. You add your function code and dependencies to the
      base image and then package it as a container image.
    AWS periodically provides updates to the AWS base images for Lambda. If your Dockerfile includes the
      image name in the FROM property, your Docker client pulls the latest version of the image from the Amazon ECR repository. To
      use the updated base image, you must rebuild your container image and update the function code.
      The Node.js 20, Python 3.12, Java 21, .NET 8, Ruby 3.3, and later base images are based on the Amazon Linux 2023 minimal container image. Earlier base images use Amazon Linux 2. AL2023 provides several advantages over Amazon Linux 2, including a smaller deployment footprint and updated versions of libraries such as glibc.
    AL2023-based images use microdnf (symlinked as dnf) as the package manager instead of yum, which is the default package manager in Amazon Linux 2. microdnf is a standalone implementation of dnf. For a list of packages that are included in AL2023-based images, refer to the Minimal Container columns in Comparing packages installed on Amazon Linux 2023 Container Images. For more information about the differences between AL2023 and Amazon Linux 2, see Introducing the Amazon Linux 2023 runtime for AWS Lambda on the AWS
      Compute Blog.    
    NoteTo run AL2023-based images locally, including with AWS Serverless Application Model (AWS SAM), you must use Docker version 20.10.10 or later.  
    To build a container image using an AWS base image, choose the instructions for your preferred language:
    
       
       
       
       
       
       
       
    
        Node.js
      
        TypeScript (uses a Node.js base image) 
      
        Python
      
        Java 
      
        Go
      
        .NET
      
        Ruby
      
   
    Using an AWS OS-only base image
    AWS OS-only base images contain an Amazon Linux distribution and the runtime interface emulator. These images are commonly used to create container images for compiled languages, such as Go and Rust, and for a language or language version that Lambda doesn't provide a base image for, such as Node.js 19. You can also use OS-only base images to implement a custom runtime. To make the image compatible with Lambda, you must include a runtime interface client for your language in the image.
    
          
            Tags
            Runtime
            Operating system
            Dockerfile
            Deprecation
          
        
      
            al2023
            OS-only Runtime
            Amazon Linux 2023
            Dockerfile
                for OS-only Runtime on GitHub
            
                          Jun 30, 2029
            
              
          
      
            al2
            OS-only Runtime
            Amazon Linux 2
            Dockerfile
                for OS-only Runtime on GitHub
            
                          Jun 30, 2026
            
              
          
    
    Amazon Elastic Container Registry Public Gallery: gallery.ecr.aws/lambda/provided
     
    Using a non-AWS base image
    Lambda
      supports any image that conforms to one of the following image manifest formats:
    
       
       
    Docker image manifest V2, schema 2 (used with Docker version 1.10 and newer)Open Container Initiative (OCI) Specifications (v1.0.0 and up)
    Lambda supports a maximum uncompressed image size of 10 GB, including all layers.
    NoteTo make the image compatible with Lambda, you must include a runtime interface client for your language in the image.
   
    Runtime interface clients
    If you use an OS-only base image or an alternative base image, you must include a runtime interface client in your image. The runtime interface client must extend the Using the Lambda runtime API for custom runtimes, which manages the interaction between Lambda and your function code. AWS provides open-source runtime interface clients for the following languages:
    
  
   
  
   
  
   
  
   
  
   
  
   
  
     

    
      Node.js
    
  
    
      Python
    
  
    
      Java
    
  
    
      .NET
    
  
    
      Go
    
  
    
      Ruby
    
  
    
      Rust – The Rust runtime client is an experimental package. It is subject to change and intended only for evaluation purposes.
    
  
    If you're using a language that doesn't have an AWS-provided runtime interface client, you must create your own.
   
    Amazon ECR permissions
    Before you create a Lambda function from a container image, you must build the image locally and upload it to an Amazon ECR repository. When you create the function, specify the Amazon ECR repository URI.
    Make sure that the permissions for the user or role that creates the function includes GetRepositoryPolicy and SetRepositoryPolicy.
    For example, use the IAM console to create a role with the following policy:
    {
  "Version": "2012-10-17",
  "Statement": [
    {
      "Sid": "VisualEditor0",
      "Effect": "Allow",
      "Action": [
        "ecr:SetRepositoryPolicy",
        "ecr:GetRepositoryPolicy"
      ],
      "Resource": "arn:aws:ecr:us-east-1:111122223333:repository/hello-world"
    }
  ]
}
     
      Amazon ECR repository policies
      For a function in the same account as the container image in Amazon ECR, you can add ecr:BatchGetImage
        and ecr:GetDownloadUrlForLayer permissions to your Amazon ECR repository policy. The following example shows the
        minimum policy:
      {
        "Sid": "LambdaECRImageRetrievalPolicy",
        "Effect": "Allow",
        "Principal": {
          "Service": "lambda.amazonaws.com"
        },
        "Action": [
          "ecr:BatchGetImage",
          "ecr:GetDownloadUrlForLayer"
        ]
    }   
      For more information about Amazon ECR
        repository permissions, see Private repository policies in the
        Amazon Elastic Container Registry User Guide.
      If the Amazon ECR repository does not include these permissions, Lambda attempts to add them automatically. Lambda can add
        permissions only if the principal calling Lambda has ecr:getRepositoryPolicy and
          ecr:setRepositoryPolicy permissions. 
      To view or edit your Amazon ECR repository permissions, follow the directions in Setting a private repository policy statement in the
          Amazon Elastic Container Registry User Guide.
       
         Amazon ECR cross-account permissions
        A different account in the same region can create a function that uses a container image owned by your
          account. In the following example, your Amazon ECR repository permissions policy needs the following statements to
          grant access to account number 123456789012.
        
           
           
        CrossAccountPermission – Allows account 123456789012 to create and update Lambda
              functions that use images from this ECR repository.LambdaECRImageCrossAccountRetrievalPolicy – Lambda will eventually set a
              function's state to inactive if it is not invoked for an extended period. This statement is required so that
              Lambda can retrieve the container image for optimization and caching on behalf of the function owned by
              123456789012.  
        Example — Add cross-account permission to your repository{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Sid": "CrossAccountPermission",
      "Effect": "Allow",
      "Action": [
        "ecr:BatchGetImage",
        "ecr:GetDownloadUrlForLayer"
      ],
      "Principal": {
        "AWS": "arn:aws:iam::123456789012:root"
      }
    },
    {
      "Sid": "LambdaECRImageCrossAccountRetrievalPolicy",
      "Effect": "Allow",
      "Action": [
        "ecr:BatchGetImage",
        "ecr:GetDownloadUrlForLayer"
      ],
      "Principal": {
        "Service": "lambda.amazonaws.com"
      },
      "Condition": {
        "StringLike": {
          "aws:sourceARN": "arn:aws:lambda:us-east-1:123456789012:function:*"
        }
      }
    }
  ]
}
        To give access to multiple accounts, you add the account IDs to the Principal list in the
            CrossAccountPermission policy and to the Condition evaluation list in the
            LambdaECRImageCrossAccountRetrievalPolicy.
        If you are working with multiple accounts in an AWS Organization, we recommend that you enumerate each
          account ID in the ECR permissions policy. This approach aligns with the AWS security best practice of setting
          narrow permissions in IAM policies.
        In addition to Lambda permissions, the user or role that creates the function must also have BatchGetImage and GetDownloadUrlForLayer permissions.
       
     
   
    Function lifecycle
    After you upload a new or updated container image, Lambda optimizes the image before the function can process invocations. The
      optimization process can take a few seconds. The function remains in the Pending state until the
      process completes, when the state transitions to Active. You can't invoke the function until it reaches the Active state. 
    If a function is not invoked for multiple weeks, Lambda reclaims its optimized version, and the function
      transitions to the Inactive state. To reactivate the function, you must invoke it. Lambda rejects the
      first invocation and the function enters the Pending state until Lambda re-optimizes the image. The
      function then returns to the Active state.
    Lambda periodically fetches the associated container image from the Amazon ECR repository. If the
      corresponding container image no longer exists on Amazon ECR or permissions are revoked, the function enters the Failed state, and
      Lambda returns a failure for any function invocations.
    You can use the Lambda API to get information about a function's state. For more information, see Lambda function states.
  Document ConventionsEncryptionMemoryDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideHow to use layersLayers and layer versionsManaging Lambda dependencies with layersA Lambda layer is a .zip file archive that contains supplementary code or data.
  Layers usually contain library dependencies, a custom runtime,
  or configuration files. There are multiple reasons why you might consider using layers:
     
     
     
     
  
      To reduce the size of your deployment packages.
        Instead of including all of your function dependencies along with your function code
        in your deployment package, put them in a layer. This keeps deployment packages small
        and organized.
    
      To separate core function logic from dependencies.
        With layers, you can update your function dependencies independent of your function code,
        and vice versa. This promotes separation of concerns and helps you focus on your function
        logic.
    
      To share dependencies across multiple functions.
        After you create a layer, you can apply it to any number of functions in your account.
        Without layers, you need to include the same dependencies in each individual deployment
        package.
    
      To use the Lambda console code editor. The code
        editor is a useful tool for testing minor function code updates quickly. However, you
        can’t use the editor if your deployment package size is too large. Using layers reduces
        your package size and can unlock usage of the code editor.
    If you're working with Lambda functions in Go or Rust, we recommend against using layers.
    For Go and Rust functions, you provide your function code as an executable, which includes your
    compiled function code along with all of its dependencies. Putting your dependencies in a
    layer forces your function to manually load additional assemblies during the initialization
    phase, which can increase cold start times. For optimal performance for Go and Rust functions,
    include your dependencies along with your deployment package.The following diagram illustrates the high-level architectural differences between two
    functions that share dependencies. One uses Lambda layers, and the other does not.
     
      
     
     
  When you add a layer to a function, Lambda extracts the layer contents into the /opt
    directory in your function’s execution environment.
    All natively supported Lambda runtimes include paths to specific directories within the
    /opt directory. This gives your function access to your layer content. For more
    information about these specific paths and how to properly package your layers, see
    Packaging your layer content.You can include up to five layers per function. Also, you can use layers only with Lambda functions
    deployed as a .zip file archive. For functions
    defined as a container image, package your preferred runtime
    and all code dependencies when you create the container image. For more information, see
    
    Working with Lambda layers and extensions in container images on the AWS Compute Blog.TopicsHow to use layersLayers and layer versionsPackaging your layer contentCreating and deleting layers in LambdaAdding layers to functionsUsing AWS CloudFormation with layersUsing AWS SAM with layers
    How to use layers
    To create a layer, package your dependencies into a .zip file, similar to how you
      create a normal deployment package. More
      specifically, the general process of creating and using layers involves these three steps:
    
       
       
       
    
        First, package your layer content. This means creating a
          .zip file archive. For more information, see Packaging your layer content.
      
        Next, create the layer in Lambda. For more information,
          see Creating and deleting layers in Lambda.
      
        Add the layer to your function(s). For more information,
          see Adding layers to functions.
      
   
    Layers and layer versions
    A layer version is an immutable snapshot of a specific version of a layer. When you create
      a new layer, Lambda creates a new layer version with a version number of 1. Each time you publish
      an update to the layer, Lambda increments the version number and creates a new layer version.
    Every layer version is identified by a unique Amazon Resource Name (ARN). When adding a layer
      to the function, you must specify the exact layer version you want to use (for example, arn:aws:lambda:us-east-1:123456789012:layer:my-layer:1).
  Document ConventionsApplication SignalsPackaging layersDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideExecution environmentImpact on performance and resources PermissionsAugment Lambda functions using Lambda extensionsYou can use Lambda extensions to augment your Lambda functions. For example, use Lambda extensions to integrate
    functions with your preferred monitoring, observability, security, and governance tools. You can choose from a broad
    set of tools that AWS Lambda Partners provides, or you can
    create your own Lambda extensions.Lambda supports external and internal extensions. An external extension runs as an independent process in the
    execution environment and continues to run after the function invocation is fully processed. Because extensions run
    as separate processes, you can write them in a different language than the function. All Lambda runtimes support extensions.An internal extension runs as part of the runtime process. Your function accesses internal extensions by using
    wrapper scripts or in-process mechanisms such as JAVA_TOOL_OPTIONS. For more information, see Modifying the runtime environment.You can add extensions to a function using the Lambda console, the AWS Command Line Interface (AWS CLI), or infrastructure as code
    (IaC) services and tools such as AWS CloudFormation, AWS Serverless Application Model (AWS SAM), and Terraform.You are charged for the execution time that the extension consumes (in 1 ms increments). There is no cost to
    install your own extensions. For more pricing information for extensions, see
    AWS Lambda Pricing. For pricing
    information for partner extensions, see those partners' websites. See AWS Lambda extensions partners
    for a list of official partner extensions.For a tutorial on extensions and how to use them with your Lambda functions, see the
    AWS Lambda Extensions Workshop.TopicsExecution environmentImpact on performance and resources PermissionsConfiguring Lambda extensionsAWS Lambda extensions partnersUsing the Lambda Extensions API to create extensionsAccessing real-time telemetry data for extensions using the Telemetry API
    Execution environment
    Lambda invokes your function in an execution environment, which
      provides a secure and isolated runtime environment. The execution environment manages the resources required to
      run your function and provides lifecycle support for the function's runtime and extensions.
    
The lifecycle of the execution environment includes the following phases:
      
         
         
         
         
      
          Init: In this phase, Lambda creates or
            unfreezes an execution environment with the configured resources, downloads the code for the function and
            all layers, initializes any extensions, initializes the runtime, and then runs the function’s initialization
            code (the code outside the main handler). The Init phase happens either during the first
            invocation, or in advance of function invocations if you have enabled provisioned concurrency.
          The Init phase is split into three sub-phases: Extension init, 
          Runtime init, and Function init. These sub-phases ensure that all extensions and the runtime complete their setup tasks before the function code runs.
          When Lambda SnapStart is activated, the Init phase happens when you publish a function version. Lambda saves a snapshot of the memory and disk state of the initialized execution environment, persists the encrypted snapshot, and caches it for low-latency access. If you have a before-checkpoint runtime hook, then the code runs at the end of Init phase.
        
        Restore (SnapStart only): When you first invoke a SnapStart function and as the function scales up, Lambda resumes new execution environments from the persisted snapshot instead of initializing the function from scratch. If you have an after-restore runtime hook, the code runs at the end of the Restore phase. You are charged for the duration of after-restore runtime hooks. The runtime must load and after-restore runtime hooks must complete within the timeout limit (10 seconds). Otherwise, you'll get a SnapStartTimeoutException. When the Restore phase completes, Lambda invokes the function handler (the Invoke phase).
        
          Invoke: In this phase, Lambda invokes the function handler.
            After the function runs to completion, Lambda prepares to handle another function
            invocation.
        
          Shutdown: This phase is triggered if the Lambda function does not
            receive any invocations for a period of time. In the Shutdown phase, Lambda shuts down
            the runtime, alerts the extensions to let them stop cleanly, and then removes the environment. Lambda
            sends a Shutdown event to each extension, which tells the extension that the environment is about
            to be shut down.
        

    During the Init phase, Lambda extracts layers containing extensions into the /opt
      directory in the execution environment. Lambda looks for extensions in the /opt/extensions/ directory,
      interprets each file as an executable bootstrap for launching the extension, and starts all extensions in
      parallel.
   
    Impact on performance and resources 
    The size of your function's extensions counts towards the deployment package size limit. For a .zip file
      archive, the total unzipped size of the function and all extensions cannot exceed the unzipped deployment package
      size limit of 250 MB.
    Extensions can impact the performance of your function because they share function resources such as CPU,
      memory, and storage. For example, if an extension performs compute-intensive operations, you may see your
      function's execution duration increase.
    Each extension must complete its initialization before Lambda invokes the function. Therefore, an extension
      that consumes significant initialization time can increase the latency of the function invocation.
    To measure the extra time that the extension takes after the function execution, you can use the
      PostRuntimeExtensionsDuration
      function metric. To measure the increase in memory used, you can use the
      MaxMemoryUsed metric. To understand the impact of a specific extension, you can run different
      versions of your functions side by side.
    NoteMaxMemoryUsed metric is one of the Metrics collected by Lambda Insights and not a Lambda native metric.
   
    Permissions
    Extensions have access to the same resources as functions. Because extensions are executed within the same
      environment as the function, permissions are shared between the function and the extension.
    For a .zip file archive, you can create an AWS CloudFormation template to simplify the task of attaching the same extension
      configuration—including AWS Identity and Access Management (IAM) permissions—to multiple functions.
  Document ConventionsLayers with AWS SAMConfiguring extensionsDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideCreating a function URL (console)Creating a function URL (AWS CLI)Adding a function URL to a CloudFormation templateCross-origin resource sharing (CORS)Throttling function URLsDeactivating function URLsDeleting function URLsCreating and managing Lambda function URLsA function URL is a dedicated HTTP(S) endpoint for your Lambda function. You can create and configure a function URL through the Lambda console or the Lambda API.TipLambda offers two ways to invoke your function through an HTTP endpoint: function URLs and Amazon API Gateway. If you're not sure which is the best method for your 
   use case, see Select a method to invoke your Lambda function using an HTTP request.When you create a function URL, Lambda automatically generates a unique URL endpoint for you. Once you create a function URL, its URL endpoint never changes. Function
      URL endpoints have the following format:https://<url-id>.lambda-url.<region>.on.awsNoteFunction URLs are not supported in the following AWS Regions: Asia Pacific (Hyderabad) (ap-south-2),  Asia Pacific (Melbourne) (ap-southeast-4), Asia Pacific (Malaysia) (ap-southeast-5), Canada West (Calgary) (ca-west-1), Europe (Spain) (eu-south-2), Europe (Zurich) (eu-central-2), Israel (Tel Aviv) (il-central-1), and Middle East (UAE) (me-central-1).Function URLs are dual stack-enabled, supporting IPv4 and IPv6. After you configure a function URL for your
    function, you can invoke your function through its HTTP(S) endpoint via a web browser, curl, Postman, or any HTTP
    client.NoteYou can access your function URL through the public Internet only. While Lambda functions do support
    AWS PrivateLink, function URLs do not.Lambda function URLs use resource-based policies for
    security and access control. Function URLs also support cross-origin resource sharing (CORS) configuration
    options.You can apply function URLs to any function alias, or to the $LATEST unpublished function version.
    You can't add a function URL to any other function version.The following section show how to create and manage a function URL using the Lambda console, AWS CLI, and AWS CloudFormation templateTopicsCreating a function URL (console)Creating a function URL (AWS CLI)Adding a function URL to a CloudFormation templateCross-origin resource sharing (CORS)Throttling function URLsDeactivating function URLsDeleting function URLsControl access to Lambda function URLsInvoking Lambda function URLsMonitoring Lambda function URLsSelect a method to invoke your Lambda function using an HTTP requestTutorial: Creating a webhook endpoint using a Lambda function URL
    Creating a function URL (console)
    Follow these steps to create a function URL using the console.
    
            Open the Functions page of the Lambda console.
          
            Choose the name of the function that you want to create the function URL for.
          
            Choose the Configuration tab, and then choose Function
              URL.
          
            Choose Create function URL.
          
            For Auth type, choose AWS_IAM or
                NONE. For more information about function URL authentication, see Access control.
          
            (Optional) Select Configure cross-origin resource sharing (CORS), and then configure
              the CORS settings for your function URL. For more information about CORS, see Cross-origin resource sharing (CORS).
          
            Choose Save.
          This creates a function URL for the $LATEST unpublished version of your function. The function URL
          appears in the Function overview section of the console.
    
            Open the Functions page of the Lambda console.
          
            Choose the name of the function with the alias that you want to create the function URL for.
          
            Choose the Aliases tab, and then choose the name of the alias that you want to create
              the function URL for.
          
            Choose the Configuration tab, and then choose Function
              URL.
          
            Choose Create function URL.
          
            For Auth type, choose AWS_IAM or NONE.
              For more information about function URL authentication, see Access control.
          
            (Optional) Select Configure cross-origin resource sharing (CORS), and then configure
              the CORS settings for your function URL. For more information about CORS, see Cross-origin resource sharing (CORS).
          
            Choose Save.
          This creates a function URL for your function alias. The function URL appears in the console's Function
          overview section for your alias.
    To create a new function with a function URL (console)
            Open the Functions page of the Lambda console.
          
            Choose Create function.
          
            Under Basic information, do the following:
            
                For Function name, enter a name for your function, such as
                    my-function.
              
                For Runtime, choose the language runtime that you prefer, such as
                    Node.js 18.x.
              
                For Architecture, choose either x86_64 or
                    arm64.
              
                Expand Permissions, then choose whether to create a new execution role or use
                  an existing one.
              
          
            Expand Advanced settings, and then select Function URL.
          
            For Auth type, choose AWS_IAM or NONE.
              For more information about function URL authentication, see Access control.
          
            (Optional) Select Configure cross-origin resource sharing (CORS). By selecting this
              option during function creation, your function URL allows requests from all origins by default. You can edit
              the CORS settings for your function URL after creating the function. For more information about CORS, see
              Cross-origin resource sharing (CORS).
          
            Choose Create function.
          This creates a new function with a function URL for the $LATEST
          unpublished version of the function. The function URL appears in the Function
            overview section of the console.
   
    Creating a function URL (AWS CLI)
    To create a function URL for an existing Lambda function using the AWS Command Line Interface (AWS CLI), run the following
      command:
    aws lambda create-function-url-config \
    --function-name my-function \
    --qualifier prod \ // optional
    --auth-type AWS_IAM
    --cors-config {AllowOrigins="https://example.com"} // optional
    This adds a function URL to the prod qualifier for the function
        my-function. For more information about these configuration parameters, see
      CreateFunctionUrlConfig in the API reference.
    NoteTo create a function URL via the AWS CLI, the function must already exist.
   
    Adding a function URL to a CloudFormation template
    To add an AWS::Lambda::Url resource to your AWS CloudFormation template, use the following syntax:
     
      JSON
      {
  "Type" : "AWS::Lambda::Url",
  "Properties" : {
      "AuthType" : String,
      "Cors" : Cors,
      "Qualifier" : String,
      "TargetFunctionArn" : String
    }
}
     
     
      YAML
      Type: AWS::Lambda::Url
Properties: 
  AuthType: String
  Cors: 
    Cors
  Qualifier: String
  TargetFunctionArn: String
     
     
      Parameters
      
         
         
         
         
      (Required) AuthType – Defines the type of authentication for your function URL. Possible
            values are either AWS_IAM or NONE. To restrict access to authenticated users
            only, set to AWS_IAM. To bypass IAM authentication and allow any user to make requests to
            your function, set to NONE.
          (Optional) Cors – Defines the CORS settings for
            your function URL. To add Cors to your AWS::Lambda::Url resource in CloudFormation,
            use the following syntax.
          
          Example AWS::Lambda::Url.Cors (JSON){
  "AllowCredentials" : Boolean,
  "AllowHeaders" : [ String, ... ],
  "AllowMethods" : [ String, ... ],
  "AllowOrigins" : [ String, ... ],
  "ExposeHeaders" : [ String, ... ],
  "MaxAge" : Integer
}
          Example AWS::Lambda::Url.Cors (YAML)  AllowCredentials: Boolean
  AllowHeaders: 
    - String
  AllowMethods: 
    - String
  AllowOrigins: 
    - String
  ExposeHeaders: 
    - String
  MaxAge: Integer
        (Optional) Qualifier – The alias name.(Required) TargetFunctionArn – The name or Amazon Resource Name (ARN) of the Lambda function.
          Valid name formats include the following:
          
             
             
             
          Function name – my-functionFunction ARN –
              arn:aws:lambda:us-west-2:123456789012:function:my-functionPartial ARN – 123456789012:function:my-function
        
     
   
    Cross-origin resource sharing (CORS)
    To define how different origins can access your function URL, use cross-origin resource sharing (CORS). We
      recommend configuring CORS if you intend to call your function URL from a different domain. Lambda supports the
      following CORS headers for function URLs.
    
          
            CORS header
            CORS configuration property
            Example values
          
        
          
            
              
                Access-Control-Allow-Origin
            
            
              AllowOrigins
            
            
              * (allow all origins)
              https://www.example.com
              http://localhost:60905
            
          
          
            
              
                Access-Control-Allow-Methods
            
            
              AllowMethods
            
            
              GET, POST, DELETE, *
            
          
          
            
              
                Access-Control-Allow-Headers
            
            
              AllowHeaders
            
            
              Date, Keep-Alive, X-Custom-Header
            
          
          
            
              
                Access-Control-Expose-Headers
            
            
              ExposeHeaders
            
            
              Date, Keep-Alive, X-Custom-Header
            
          
          
            
              
                Access-Control-Allow-Credentials
            
            
              AllowCredentials
            
            
              TRUE
            
          
          
            
              
                Access-Control-Max-Age
            
            
              MaxAge
            
            
              5 (default), 300
            
          
        
    When you configure CORS for a function URL using the Lambda console or the AWS CLI, Lambda automatically adds the
      CORS headers to all responses through the function URL. Alternatively, you can manually add CORS headers to your
      function response. If there are conflicting headers, the expected behavior depends on the
      type of request:
    
       
       
    
        For preflight requests such as OPTIONS requests, the configured CORS headers on the function URL take
          precedence. Lambda returns only these CORS headers in the response.
      
        For non-preflight requests such as GET or POST requests, Lambda returns both the configured CORS headers
          on the function URL, as well as the CORS headers returned by the function. This can result in duplicate CORS
          headers in the response. You may see an error similar to the following: The 'Access-Control-Allow-Origin'
          header contains multiple values '*, *', but only one is allowed.
      
    In general, we recommend configuring all CORS settings on the function URL, rather than sending CORS
      headers manually in the function response.
   
    Throttling function URLs
    Throttling limits the rate at which your function processes requests. This is useful in many situations, such
      as preventing your function from overloading downstream resources, or handling a sudden surge in requests.
    You can throttle the rate of requests that your Lambda function processes through a function URL by configuring
      reserved concurrency. Reserved concurrency limits the number of maximum concurrent invocations
      for your function. Your function's maximum request rate per second (RPS) is equivalent to 10 times the configured
      reserved concurrency. For example, if you configure your function with a reserved concurrency of 100, then the
      maximum RPS is 1,000.
    Whenever your function concurrency exceeds the reserved concurrency, your function URL returns an HTTP
      429 status code. If your function receives a request that exceeds the 10x RPS maximum based on your
      configured reserved concurrency, you also receive an HTTP 429 error. For more information about
      reserved concurrency, see Configuring reserved concurrency for a function.
   
    Deactivating function URLs
    In an emergency, you might want to reject all traffic to your function URL. To deactivate your function URL,
      set the reserved concurrency to zero. This throttles all requests to your function URL, resulting in HTTP
      429 status responses. To reactivate your function URL, delete the reserved concurrency
      configuration, or set the configuration to an amount greater than zero.
   
    Deleting function URLs
    When you delete a function URL, you can’t recover it. Creating a new function URL will result in a different URL address.
    NoteIf you delete a function URL with auth type NONE, Lambda doesn't automatically delete the
        associated resource-based policy. If you want to delete this policy, you must manually do so.
    
        Open the Functions page of the Lambda console.
      
        Choose the name of the function.
      
        Choose the Configuration tab, and then choose Function
          URL.
      
        Choose Delete.
      
        Enter the word delete into the field to confirm the deletion.
      
        Choose Delete.
      
    NoteWhen you delete a function that has a function URL, Lambda asynchronously deletes the function URL. If you immediately create a new function with the same name in the same account, it is possible that the original function URL will be mapped to the new function instead of deleted.
  Document ConventionsRecursive loop detectionAccess controlDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideBandwidth limits for response streamingResponse streaming for Lambda functionsYou can configure your Lambda function URLs to stream response payloads back to clients. Response
    streaming can benefit latency sensitive applications by improving time to first byte (TTFB)
    performance. This is because you can send partial responses back to the client as they become
    available. Additionally, you can use response streaming to build functions that return larger
    payloads. Response stream payloads have a soft limit of 20 MB as compared to the 6 MB limit for
    buffered responses. Streaming a response also means that your function doesn’t need to fit the entire 
    response in memory. For very large responses, this can reduce the amount of memory you need to 
    configure for your function. The speed at which Lambda streams your responses depends on the response size. The streaming rate for 
    the first 6MB of your function’s response is uncapped. For responses larger than 6MB, the remainder of the response 
    is subject to a bandwidth cap. For more information on streaming bandwidth, see Bandwidth limits for response streaming.Streaming responses incurs a cost. For more information, see AWS Lambda Pricing.Lambda supports response streaming on Node.js managed runtimes. For other languages, you can use a
    custom runtime with a custom Runtime API integration to stream responses or use the Lambda Web Adapter. 
    You can stream responses through Lambda function URLs, the AWS SDK, 
    or using the Lambda InvokeWithResponseStream 
    API.NoteWhen testing your function through the Lambda console, you'll always see responses as buffered.TopicsBandwidth limits for response streamingWriting response streaming-enabled Lambda functionsInvoking a response streaming enabled function using Lambda function URLsTutorial: Creating a response streaming Lambda
      function with a function URL
    Bandwidth limits for response streaming
    The first 6MB of your function’s response payload has uncapped bandwidth. After this initial burst, Lambda streams your response at a 
      maximum rate of  2MBps. If your function responses never exceed 6MB, then this bandwidth limit never applies. 
    NoteBandwidth limits only apply to your function’s response payload, and not to network access by your function.
    The rate of uncapped bandwidth varies depending on a number of factors, including your function’s processing speed.  You can normally 
      expect a rate higher than 2MBps for the first 6MB of your function’s response. If your function is streaming a response to a destination 
      outside of AWS, the streaming rate also depends on the speed of the external internet connection.
    
  Document ConventionsTagsWriting functionsDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideUnderstanding and visualizing concurrencyCalculating concurrency for a functionUnderstanding reserved concurrency and provisioned concurrencyUnderstanding concurrency and requests per secondConcurrency quotasUnderstanding Lambda function scalingConcurrency is the number of in-flight requests that your AWS Lambda function is
    handling at the same time. For each concurrent request, Lambda provisions a separate instance of your execution
    environment. As your functions receive more requests, Lambda automatically handles scaling the number of execution
    environments until you reach your account's concurrency limit. By default, Lambda provides your account with a total
    concurrency limit of 1,000 concurrent executions across all functions in an AWS Region. To support your specific
    account needs, you can request a quota
      increase and configure function-level concurrency controls so that your critical functions don't
    experience throttling.This topic explains concurrency concepts and function scaling in Lambda. By the end of this topic, you'll be able to
    understand how to calculate concurrency, visualize the two main concurrency control options (reserved and
    provisioned), estimate appropriate concurrency control settings, and view metrics for further optimization.SectionsUnderstanding and visualizing concurrencyCalculating concurrency for a functionUnderstanding reserved concurrency and provisioned concurrencyUnderstanding concurrency and requests per secondConcurrency quotasConfiguring reserved concurrency for a functionConfiguring provisioned concurrency for a functionLambda scaling behaviorMonitoring concurrency
    Understanding and visualizing concurrency
    Lambda invokes your function in a secure and isolated execution environment. To handle a
      request, Lambda must first initialize an execution environment (the Init phase),
      before using it to invoke your function (the Invoke phase):
    
       
        
       
       
    
    NoteActual Init and Invoke durations can vary depending on many factors, such as the runtime you choose
      and the Lambda function code. The previous diagram isn't meant to represent the exact proportions of Init and
      Invoke phase durations.
    The previous diagram uses a rectangle to represent a single execution environment. When your function
      receives its very first request (represented by the yellow circle with label 1), Lambda creates
      a new execution environment and runs the code outside your main handler during the Init phase. Then, Lambda
      runs your function's main handler code during the Invoke phase. During this entire process, this execution
      environment is busy and cannot process other requests.
    When Lambda finishes processing the first request, this execution environment can then process additional
      requests for the same function. For subsequent requests, Lambda doesn't need to re-initialize the environment.
    
       
        
       
       
    
    In the previous diagram, Lambda reuses the execution environment to handle the second request
      (represented by the yellow circle with label 2).
    So far, we've focused on just a single instance of your execution environment (that is, a concurrency of 1).
      In practice, Lambda may need to provision multiple execution environment instances in parallel to handle all
      incoming requests. When your function receives a new request, one of two things can happen:
    
       
       
    
        If a pre-initialized execution environment instance is available, Lambda uses it to process the request.
      
        Otherwise, Lambda creates a new execution environment instance to process the request.
      
    For example, let's explore what happens when your function receives 10 requests:
    
       
        
       
       
    
    In the previous diagram, each horizontal plane represents a single execution environment instance (labeled
      from A through F). Here's how Lambda handles each request:
    
          
            Request
            Lambda behavior
            Reasoning
          
        
          
            
              1
            
            
              Provisions new environment A
            
            
              This is the first request; no execution environment instances are available.
            
          
          
            
              2
            
            
              Provisions new environment B
            
            
              Existing execution environment instance A is busy.
            
          
          
            
              3
            
            
              Provisions new environment C
            
            
              Existing execution environment instances A and B are both busy.
            
          
          
            
              4
            
            
              Provisions new environment D
            
            
              Existing execution environment instances A, B, and C are all busy.
            
          
          
            
              5
            
            
              Provisions new environment E
            
            
              Existing execution environment instances A, B, C, and D are all
                busy.
            
          
          
            
              6
            
            
              Reuses environment A
            
            
              Execution environment instance A has finished processing request
                  1 and is now available.
            
          
          
            
              7
            
            
              Reuses environment B
            
            
              Execution environment instance B has finished processing request
                  2 and is now available.
            
          
          
            
              8
            
            
              Reuses environment C
            
            
              Execution environment instance C has finished processing request
                  3 and is now available.
            
          
          
            
              9
            
            
              Provisions new environment F
            
            
              Existing execution environment instances A, B, C, D, and E are all busy.
            
          
          
            
              10
            
            
              Reuses environment D
            
            
              Execution environment instance D has finished processing request
                  4 and is now available.
            
          
        
    As your function receives more concurrent requests, Lambda scales up the number of execution
      environment instances in response. The following animation tracks the number of concurrent
      requests over time:
    
       
        
       
       
    
    By freezing the previous animation at six distinct points in time, we get the following
      diagram:
    
       
        
       
       
    
    In the previous diagram, we can draw a vertical line at any point in time and count the number of environments
      that intersect this line. This gives us the number of concurrent requests at that point in time. For example, at
      time t1, there are three active environments serving three concurrent requests. The maximum number of
      concurrent requests in this simulation occurs at time t4, when there are six active environments
      serving six concurrent requests.
    To summarize, your function's concurrency is the number of concurrent requests that it's handling
      at the same time. In response to an increase in your function's concurrency, Lambda provisions more
      execution environment instances to meet request demand.
   
    Calculating concurrency for a function
    In general, concurrency of a system is the ability to process more than one task simultaneously.
      In Lambda, concurrency is the number of in-flight requests that your function is handling at the same
      time. A quick and practical way of measuring concurrency of a Lambda function is to use the following
      formula:
    Concurrency = (average requests per second) * (average request duration in seconds)
    Concurrency differs from requests per second. For example, suppose your
      function receives 100 requests per second on average. If the average request duration is one second, then it's
      true that the concurrency is also 100:
    Concurrency = (100 requests/second) * (1 second/request) = 100
    However, if the average request duration is 500 ms, then the concurrency is 50:
    Concurrency = (100 requests/second) * (0.5 second/request) = 50
    What does a concurrency of 50 mean in practice? If the average request duration is 500 ms, then you can think
      of an instance of your function as being able to handle two requests per second. Then, it takes 50 instances of
      your function to handle a load of 100 requests per second. A concurrency of 50 means that Lambda must provision 50
      execution environment instances to efficiently handle this workload without any throttling. Here's how to express
      this in equation form:
    Concurrency = (100 requests/second) / (2 requests/second) = 50
    If your function receives double the number of requests (200 requests per second), but only requires half the
      time to process each request (250 ms), then the concurrency is still 50:
    Concurrency = (200 requests/second) * (0.25 second/request) = 50
    Suppose you have a function that takes, on average, 200 ms to run. During peak load, you
          observe 5,000 requests per second. What is the concurrency of your function during
          peak load?
        The average function duration is 200 ms, or 0.2 seconds. Using the concurrency formula, you can plug
              in the numbers to get a concurrency of 1,000:Concurrency = (5,000 requests/second) * (0.2 seconds/request) = 1,000Alternatively, an average function duration of 200 ms means that your function can process
              5 requests per second. To handle the 5,000 request per second workload, you need 1,000
              execution environment instances. Thus, the concurrency is 1,000:Concurrency = (5,000 requests/second) / (5 requests/second) = 1,000
   
    Understanding reserved concurrency and provisioned concurrency
    By default, your account has a concurrency limit of 1,000 concurrent executions across all functions in a
      Region. Your functions share this pool of 1,000 concurrency on an on-demand basis. Your functions experiences
      throttling (that is, they start to drop requests) if you run out of available concurrency.
    Some of your functions might be more critical than others. As a result, you might want to configure
      concurrency settings to ensure that critical functions get the concurrency that they need. There are two types of
      concurrency controls available: reserved concurrency and provisioned concurrency.
    
       
       
    
        Use reserved concurrency to reserve a portion of your account's
          concurrency for a function. This is useful if you don't want other functions taking up all the
          available unreserved concurrency.
      
        Use provisioned concurrency to pre-initialize a number of
          environment instances for a function. This is useful for reducing cold start latencies.
      
     
      Reserved concurrency
      If you want to guarantee that a certain amount of concurrency is available for your function at any
        time, use reserved concurrency.
      Reserved concurrency is the maximum number of concurrent instances that you want to allocate to your
        function. When you dedicate reserved concurrency to a function, no other function can use that concurrency. In
        other words, setting reserved concurrency can impact the concurrency pool that's available to other functions.
        Functions that don't have reserved concurrency share the remaining pool of unreserved concurrency.
      Configuring reserved concurrency counts towards your overall account concurrency limit. There is no charge
        for configuring reserved concurrency for a function.
      To better understand reserved concurrency, consider the following diagram:
      
         
          
         
         
      
      In this diagram, your account concurrency limit for all the functions in this Region is at the default limit
        of 1,000. Suppose you have two critical functions, function-blue and function-orange,
        that routinely expect to get high invocation volumes. You decide to give 400 units of reserved concurrency to
          function-blue, and 400 units of reserved concurrency to function-orange. In this
        example, all other functions in your account must share the remaining 200 units of unreserved
        concurrency.
      The diagram has five points of interest:
      
         
         
         
         
         
      
          At t1, both function-orange and function-blue begin receiving
            requests. Each function begins to use up its allocated portion of reserved concurrency units.
        
          At t2, function-orange and function-blue steadily receive more
            requests. At the same time, you deploy some other Lambda functions, which begin receiving requests. You don't
            allocate reserved concurrency to these other functions. They begin using the remaining 200 units of
            unreserved concurrency.
        
          At t3, function-orange hits the max concurrency of 400. Although there is
            unused concurrency elsewhere in your account, function-orange cannot access it. The red line
            indicates that function-orange is experiencing throttling, and Lambda may drop requests.
        
          At t4, function-orange starts to receive fewer requests and is no longer
            throttling. However, your other functions experience a spike in traffic and begin throttling. Although
            there is unused concurrency elsewhere in your account, these other functions cannot access it. The red
            line indicates that your other functions are experiencing throttling.
        
          At t5, other functions start to receive fewer requests and are no longer throttling.
        
      From this example, notice that reserving concurrency has the following effects:
      
         
         
         
      
          Your function can scale independently of other functions in your
              account. All of your account's functions in the same Region that don't have reserved
            concurrency share the pool of unreserved concurrency. Without reserved concurrency, other functions can
            potentially use up all of your available concurrency. This prevents critical functions from scaling up if
            needed.
        
          Your function can't scale out of control. Reserved concurrency caps
            your function's maximum concurrency. This means that your function can't use concurrency reserved for other
            functions, or concurrency from the unreserved pool. You can reserve concurrency to prevent your function
            from using all the available concurrency in your account, or from overloading downstream resources.
        
          You may not be able to use all of your account's available concurrency.
            Reserving concurrency counts towards your account concurrency limit, but this also means that other
            functions cannot use that chunk of reserved concurrency. If your function doesn't use up all of the
            concurrency that you reserve for it, you're effectively wasting that concurrency. This isn't an issue unless
            other functions in your account could benefit from the wasted concurrency.
        
      To learn how to manage reserved concurrency settings for your functions, see Configuring reserved concurrency for a function.
     
     
      Provisioned concurrency
      You use reserved concurrency to define the maximum number of execution environments reserved for a Lambda function.
        However, none of these environments come pre-initialized. As a result, your function invocations may take longer
        because Lambda must first initialize the new environment before being able to use it to invoke your function.
        When Lambda has to initialize a new environment in order to carry out an invocation, this is known as a
        cold start. 
        To mitigate cold starts, you can use provisioned concurrency.
      Provisioned concurrency is the number of pre-initialized execution environments that you want to allocate to
        your function. If you set provisioned concurrency on a function, Lambda initializes that number of execution
        environments so that they are prepared to respond immediately to function requests.
      NoteUsing provisioned concurrency incurs additional charges to your account. If you're working with the Java
          11 or Java 17 runtimes, you can also use Lambda SnapStart to mitigate cold start issues at no additional cost.
          SnapStart uses cached snapshots of your execution environment to significantly improve startup
          performance. You cannot use both SnapStart and provisioned concurrency on the same function version. For more
          information about SnapStart features, limitations, and supported Regions, see Improving startup performance with Lambda SnapStart.
      When using provisioned concurrency, Lambda still recycles execution environments in the background. For example,
        this can occur after an invocation failure. However, at
        any given time, Lambda always ensures that the number of pre-initialized environments is equal to the value of your
        function's provisioned concurrency setting. Importantly, even if you're using provisioned concurrency, you can
        still experience a cold start delay if Lambda has to reset the execution environment.
      In contrast, when using reserved concurrency, Lambda may completely terminate an environment after a period of
        inactivity. The following diagram illustrates this by comparing the lifecycle of a single execution environment
        when you configure your function using reserved concurrency compared to provisioned concurrency.
      
         
          
         
         
      
      The diagram has four points of interest:
      
            
              Time
              Reserved concurrency
              Provisioned concurrency
            
          
            
              
                t1
              
              
                Nothing happens.
              
              
                Lambda pre-initializes an execution environment instance.
              
            
            
              
                t2
              
              
                Request 1 comes in. Lambda must initialize a new execution environment instance.
              
              
                Request 1 comes in. Lambda uses the pre-initialized environment instance.
              
            
            
              
                t3
              
              
                After some inactivity, Lambda terminates the active environment instance.
              
              
                Nothing happens.
              
            
            
              
                t4
              
              
                Request 2 comes in. Lambda must initialize a new execution environment instance.
              
              
                Request 2 comes in. Lambda uses the pre-initialized environment instance.
              
            
          
      To better understand provisioned concurrency, consider the following diagram:
      
         
          
         
         
      
      In this diagram, you have an account concurrency limit of 1,000. You decide to give 400 units of provisioned
        concurrency to function-orange. All functions in your account, including
        function-orange, can use the remaining 600 units of unreserved concurrency.
      The diagram has five points of interest:
      
         
         
         
         
         
      
          At t1, function-orange begins receiving requests. Since Lambda has pre-initialized
            400 execution environment instances, function-orange is ready for immediate invocation.
        
          At t2, function-orange reaches 400 concurrent requests. As a result,
            function-orange runs out of provisioned concurrency. However, since there's still unreserved
            concurrency available, Lambda can use this to handle additional requests to function-orange
            (there's no throttling). Lambda must create new instances to serve these requests, and your function may
            experience cold start latencies.
        
          At t3, function-orange returns to 400 concurrent requests after a brief spike
            in traffic. Lambda is again able to handle all requests without cold start latencies.
        
          At t4, functions in your account experience a burst in traffic. This burst can come from
            function-orange or any other function in your account. Lambda uses unreserved concurrency to
            handle these requests.
        
          At t5, functions in your account reach the maximum concurrency limit of 1,000, and
            experience throttling.
        
      The previous example considered only provisioned concurrency. In practice, you can set both provisioned
        concurrency and reserved concurrency on a function. You might do this if you had a function that handles a
        consistent load of invocations on weekdays, but routinely sees spikes of traffic on weekends. In this case, you
        could use provisioned concurrency to set a baseline amount of environments to handle request during weekdays,
        and use reserved concurrency to handle the weekend spikes. Consider the following diagram:
      
         
          
         
         
      
      In this diagram, suppose that you configure 200 units of provisioned concurrency and 400 units of
        reserved concurrency for function-orange. Because you configured reserved concurrency,
        function-orange cannot use any of the 600 units of unreserved concurrency.
      This diagram has five points of interest:
      
         
         
         
         
         
      
          At t1, function-orange begins receiving requests. Since Lambda has
            pre-initialized 200 execution environment instances, function-orange is ready for
            immediate invocation.
        
          At t2, function-orange uses up all its provisioned concurrency.
            function-orange can continue serving requests using reserved concurrency, but these
            requests may experience cold start latencies.
        
          At t3, function-orange reaches 400 concurrent requests. As a result,
            function-orange uses up all its reserved concurrency. Since function-orange
            cannot use unreserved concurrency, requests begin to throttle.
        
          At t4, function-orange starts to receive fewer requests, and no longer
            throttles.
        
          At t5, function-orange drops down to 200 concurrent requests, so all requests
            are again able to use provisioned concurrency (that is, no cold start latencies).
        
      Both reserved concurrency and provisioned concurrency count towards your account concurrency limit and Regional quotas. In other words, allocating reserved and provisioned
        concurrency can impact the concurrency pool that's available to other functions. Configuring provisioned
        concurrency incurs charges to your AWS account.
      NoteIf the amount of provisioned concurrency on a function's versions and aliases adds up to the function's reserved
          concurrency, then all invocations run on provisioned concurrency. This configuration also has the effect of
          throttling the unpublished version of the function ($LATEST), which prevents it from executing.
          You can't allocate more provisioned concurrency than reserved concurrency for a function.
      To manage provisioned concurrency settings for your functions, see Configuring provisioned concurrency for a function. To automate
        provisioned concurrency scaling based on a schedule or application utilization, see Using Application Auto Scaling to automate provisioned concurrency management.
     
     
      How Lambda allocates provisioned concurrency
      Provisioned concurrency doesn't come online immediately after you configure it. Lambda
        starts allocating provisioned concurrency after a minute or two of preparation. For each 
        function, Lambda can provision up to 6,000 execution environments every minute, regardless 
        of AWS Region. This is exactly the same as the concurrency scaling rate for functions.
      When you submit a request to allocate provisioned concurrency, you can't access
        any of those environments until Lambda completely finishes allocating them. For example,
        if you request 5,000 provisioned concurrency, none of your requests can use
        provisioned concurrency until Lambda completely finishes allocating the 5,000 execution
        environments.
     
     
      Comparing reserved concurrency and provisioned concurrency
      The following table summarizes and compares reserved and provisioned concurrency.
      
            
              Topic
              Reserved concurrency
              Provisioned concurrency
            
          
            
              
                Definition
              
              
                Maximum number of execution environment instances for your function.
              
              
                Set number of pre-provisioned execution environment instances for your function.
              
            
            
              
                Provisioning behavior
              
              
                Lambda provisions new instances on an on-demand basis.
              
              
                Lambda pre-provisions instances (that is, before your function starts receiving requests).
              
            
            
              
                Cold start behavior
              
              
                Cold start latency possible, since Lambda must create new instances on-demand.
              
              
                Cold start latency not possible, since Lambda doesn't have to create instances on-demand.
              
            
            
              
                Throttling behavior
              
              
                Function throttled when reserved concurrency limit reached.
              
              
                If reserved concurrency not set: function uses unreserved concurrency when provisioned concurrency
                  limit reached.
                If reserved concurrency set: function throttled when reserved concurrency limit reached.
              
            
            
              
                Default behavior if not set
              
              
                Function uses unreserved concurrency available in your account.
              
              
                Lambda doesn't pre-provision any instances. Instead, if reserved concurrency not set: function uses
                  unreserved concurrency available in your account.
                If reserved concurrency set: function uses reserved concurrency.
              
            
            
              
                Pricing
              
              
                No additional charge.
              
              
                Incurs additional charges.
              
            
          
     
   
    Understanding concurrency and requests per second
    As mentioned in the previous section, concurrency differs from requests per second. This is an
      especially important distinction to make when working with functions that have an average request
      duration of less than 100 ms.
    Across all functions in your account, Lambda enforces a requests per second limit that's equal to 10
      times your account concurrency. For example, since the default account concurrency limit is 1,000,
      functions in your account can handle a maximum of 10,000 requests per second.
    For example, consider a function with an average request duration of 50 ms. At 20,000 requests
      per second, here's the concurrency of this function:
    Concurrency = (20,000 requests/second) * (0.05 second/request) = 1,000
    Based on this result, you might expect that the account concurrency limit of 1,000 is sufficient
      to handle this load. However, because of the 10,000 requests per second limit, your function can only
      handle 10,000 requests per second out of the 20,000 total requests. This function experiences throttling.
    The lesson is that you must consider both concurrency and requests per second when configuring concurrency
      settings for your functions. In this case, you need to request an account concurrency limit increase to
      2,000, since this would increase your total requests per second limit to 20,000.
    NoteBased on this request per second limit, it's incorrect to say that each Lambda execution
        environment can handle only a maximum of 10 requests per second. Instead of observing the
        load on any individual execution environment, Lambda only considers overall concurrency and
        overall requests per second when calculating your quotas.
    Suppose that you have a function that takes, on average, 20 ms to run. During peak load, you observe 30,000
          requests per second. What is the concurrency of your function during peak load?The average function duration is 20 ms, or 0.02 seconds. Using the concurrency formula,
              you can plug in the numbers to get a concurrency of 600:Concurrency = (30,000 requests/second) * (0.02 seconds/request) = 600By default, the account concurrency limit of 1,000 seems sufficient to handle this load.
              However, the requests per second limit of 10,000 isn't enough to handle the incoming 30,000
              requests per second. To fully accommodate the 30,000 requests, you need to request an account
              concurrency limit increase to 3,000 or higher.
    The requests per second limit applies to all quotas in Lambda that involve concurrency. In other
      words, it applies to synchronous on-demand functions, functions that use provisioned concurrency,
      and concurrency scaling behavior. For example, here
      are a few scenarios where you must carefully consider both your concurrency and request per second limits:
    
       
       
    
        A function using on-demand concurrency can experience a burst increase of 500 concurrency
          every 10 seconds, or by 5,000 requests per second every 10 seconds, whichever happens first.
      
        Suppose you have a function that has a provisioned concurrency allocation of 10. This
          function spills over into on-demand concurrency after 10 concurrency or 100 requests per
          second, whichever happens first.
      
   
    Concurrency quotas
    Lambda sets quotas for the total amount of concurrency that you can use across all functions in a Region. These
      quotas exist on two levels:
    
       
       
       
    
        At the account level, your functions can have up to 1,000 units of
          concurrency by default. To increase this limit, see Requesting a quota increase in the
            Service Quotas User Guide.
      
        At the function level, you can reserve up to 900 units of concurrency
          across all your functions by default. Regardless of your total account concurrency limit, Lambda always
          reserves 100 units of concurrency for your functions that don't explicitly reserve concurrency. For example,
          if you increased your account concurrency limit to 2,000, then you can reserve up to 1,900 units of
          concurrency at the function level.
      
        At both the account level and the function level, Lambda also enforces a requests per second limit of
          equal to 10 times the corresponding concurrency quota. For instance, this applies to account-level
          concurrency, functions using on-demand concurrency, functions using provisoned concurrency, and
          concurrency scaling behavior. For more information, see
          Understanding concurrency and requests per second.
      
    To check your current account level concurrency quota, use the AWS Command Line Interface (AWS CLI) to run the following
      command:
    aws lambda get-account-settings
    You should see output that looks like the following:
    {
    "AccountLimit": {
        "TotalCodeSize": 80530636800,
        "CodeSizeUnzipped": 262144000,
        "CodeSizeZipped": 52428800,
        "ConcurrentExecutions": 1000,
        "UnreservedConcurrentExecutions": 900
    },
    "AccountUsage": {
        "TotalCodeSize": 410759889,
        "FunctionCount": 8
    }
}

    ConcurrentExecutions is your total account-level concurrency quota.
        UnreservedConcurrentExecutions is the amount of reserved concurrency that you can still allocate to
      your functions.
    As your function receives more requests, Lambda automatically scales up the number of execution environments to
      handle these requests until your account reaches its concurrency quota. However, to protect against over-scaling in
      response to sudden bursts of traffic, Lambda limits how fast your functions can scale. This 
      concurrency scaling rate is the maximum rate at which functions in your account can scale in response
      to increased requests. (That is, how quickly Lambda can create new execution environments.) The concurrency scaling
      rate differs from the account-level concurrency limit, which is the total amount of concurrency available to your
      functions.
    In each AWS Region, and for each function,
      your concurrency scaling rate is 1,000 execution environment instances every 10 seconds (or 10,000 requests per
      second every 10 seconds). In other words, every 10 seconds, Lambda can allocate
      at most 1,000 additional execution environment instances, or accommodate 10,000 additional
      requests per second, to each of your functions.
    Usually, you don't need to worry about this limitation. Lambda's scaling rate is sufficient for most
      use cases.
    Importantly, the concurrency scaling rate is a function-level limit. This means that each function in your
      account can scale independently of other functions.
    For more information about scaling behavior, see Lambda scaling behavior.
  Document ConventionsTutorial: Creating a webhook endpointConfiguring reserved concurrencyDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideSignature validationUsing code signing to verify code integrity with LambdaCode signing helps ensure that only trusted code is deployed to your Lambda functions. Using AWS Signer, you can create digitally signed code packages for your functions. When you add a code signing configuration to a function, Lambda verifies that all new code deployments are signed by a trusted source. Because code signing validation checks run at deployment time, there is no impact on function execution.ImportantCode signing configurations only prevent new deployments of unsigned code. If you add a code signing configuration to an existing function that has unsigned code, that code keeps running until you deploy a new code package.When you enable code signing for a function, any layers that you add to the function must also be signed by an allowed signing profile.There is no additional charge for using AWS Signer or code signing for AWS Lambda.
    Signature validation
    Lambda performs the following validation checks when you deploy a signed code package to your function:
    
       
       
       
       
    
        Integrity: Validates that the code package has not been modified since it was signed. Lambda
          compares the hash of the package with the hash from the signature.
      
        Expiry: Validates that the signature of the code package has not expired.
      
        Mismatch: Validates that the code package is signed with an allowed signing profile
      
        Revocation: Validates that the signature of the code package has not been revoked.
      
    When you create a code signing configuration, you can use the UntrustedArtifactOnDeployment parameter to specify how Lambda should respond if the expiry, mismatch, or revocation checks fail. You can choose one of these actions:
    
       
       
    
        Warn: This is the default setting. Lambda allows the deployment of the code package, but issues a warning. Lambda issues a new
          Amazon CloudWatch metric and also stores the warning in the CloudTrail log.
      
        Enforce Lambda issues a warning (the same as for the Warn action) and blocks the deployment of the
          code package.
      
  TopicsCreating code signing configurations for LambdaConfiguring IAM policies for Lambda code signing configurationsUsing tags on code signing configurationsDocument ConventionsSecuring workloads with public endpointsCreate configurationDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideRequired IAM permissionsAttaching Lambda functions to an Amazon VPC in your AWS accountInternet access when attached to a VPCIPv6 supportBest practices for using Lambda with Amazon VPCsUnderstanding Hyperplane Elastic Network Interfaces (ENIs)Using IAM condition keys for VPC settingsVPC tutorialsGiving Lambda functions access to resources in an Amazon VPCWith Amazon Virtual Private Cloud (Amazon VPC), you can create private networks in your AWS account to host resources such as Amazon Elastic Compute Cloud (Amazon EC2) 
    instances, Amazon Relational Database Service (Amazon RDS) instances, and Amazon ElastiCache instances. You can give your Lambda function access to resources hosted 
    in an Amazon VPC by attaching your function to the VPC through the private subnets that contain the resources. Follow the instructions 
    in the following sections to attach a Lambda function to an Amazon VPC using the Lambda console, the AWS Command Line Interface (AWS CLI), or AWS SAM.NoteEvery Lambda function runs inside a VPC that is owned and managed by the Lambda service. These VPCs are maintained automatically 
      by Lambda and are not visible to customers. Configuring your function to access other AWS resources in an Amazon VPC has no effect on the 
      Lambda-managed VPC your function runs inside.SectionsRequired IAM permissionsAttaching Lambda functions to an Amazon VPC in your AWS accountInternet access when attached to a VPCIPv6 supportBest practices for using Lambda with Amazon VPCsUnderstanding Hyperplane Elastic Network Interfaces (ENIs)Using IAM condition keys for VPC settingsVPC tutorials
      Required IAM permissions
    To attach a Lambda function to an Amazon VPC in your AWS account, Lambda needs permissions to create and manage the network 
      interfaces it uses to give your function access to the resources in the VPC.
    The network interfaces that Lambda creates are known as Hyperplane Elastic Network Interfaces, or Hyperplane ENIs. To learn more about 
      these network interfaces, see Understanding Hyperplane Elastic Network Interfaces (ENIs).
      You can give your function the permissions it needs by attaching the AWS managed policy 
        AWSLambdaVPCAccessExecutionRole to your function's execution role. When you create a new function in the Lambda console 
        and attach it to a VPC, Lambda automatically adds this permissions policy for you. 
      If you prefer to create your own IAM permissions policy, make sure to add all of the following permissions:
    
       
       
       
       
       
       
    
        ec2:CreateNetworkInterface
      
        ec2:DescribeNetworkInterfaces – This action only works if it's allowed on all resources 
          ("Resource": "*").
      
        ec2:DescribeSubnets
      
        ec2:DeleteNetworkInterface – If you don't specify a resource ID for 
          DeleteNetworkInterface in the execution role, your function may not be able to access the 
          VPC. Either specify a unique resource ID, or include all resource IDs, for example, "Resource": "arn:aws:ec2:us-west-2:123456789012:*/*".
      
        ec2:AssignPrivateIpAddresses
      
        ec2:UnassignPrivateIpAddresses
      
    Note that your function's role only needs these permissions to create the network interfaces, not to invoke your function. You can still 
      invoke your function successfully when it’s attached to an Amazon VPC, even if you remove these permissions from your function’s execution role. 
    To attach your function to a VPC, Lambda also needs to verify network resources using your IAM user role. Ensure that your user role 
      has the following IAM permissions:
    
       
       
       
       
    
        ec2:DescribeSecurityGroups
      
        ec2:DescribeSubnets
      
        ec2:DescribeVpcs
      
        ec2:getSecurityGroupsForVpc
      
    NoteThe Amazon EC2 permissions that you grant to your function's execution role are used by the Lambda service to attach your function 
        to a VPC. However, you're also implicitly granting these permissions to your function's code. This means that your function code is 
        able to make these Amazon EC2 API calls. For advice on following security best practices, see Security best practices.
     
    Attaching Lambda functions to an Amazon VPC in your AWS account
    Attach your function to an Amazon VPC in your AWS account by using the Lambda console, the AWS CLI or AWS SAM. If you're using the AWS CLI or AWS SAM, or attaching 
    an existing function to a VPC using the Lambda console, make sure that your function's execution role has the necessary permissions listed in the previous section.
      Lambda functions can't connect directly to a VPC with  dedicated instance tenancy. To connect to resources
        in a dedicated VPC, peer it to a
          second VPC with default tenancy.
    
    
      Lambda console
          To attach a function to an Amazon VPC when you create it
              Open the Functions page of the Lambda console and choose Create function.
            
              Under Basic information, for Function name, enter a name for your function.
            
              Configure VPC settings for the function by doing the following:
              
                  Expand Advanced settings.
                
                  Select Enable VPC, and then select the VPC you want to attach the function to.
                
                  (Optional) To allow outbound IPv6 traffic, select Allow IPv6 traffic for dual-stack subnets.
                
                  Choose the subnets and security groups to create the network interface for. If you selected Allow IPv6 traffic for dual-stack subnets, 
                    all selected subnets must have an IPv4 CIDR block and an IPv6 CIDR block.
                  NoteTo access private resources, connect your function to private subnets. If your function needs internet access, see 
                      Enable internet access for VPC-connected Lambda functions. Connecting a function to a public subnet doesn't give it internet access or a public IP address. 
                
            
              Choose Create function.
            
          To attach an existing function to an Amazon VPC
              Open the Functions page of the Lambda console and select your function.
            
              Choose the Configuration tab, then choose VPC.
            
              Choose Edit.
            
              Under VPC, select the Amazon VPC you want to attach your function to.
            
              (Optional) To allow outbound IPv6 traffic, select Allow IPv6 traffic for dual-stack subnets. 
            
              Choose the subnets and security groups to create the network interface for. If you selected Allow IPv6 traffic for dual-stack subnets, 
                all selected subnets must have an IPv4 CIDR block and an IPv6 CIDR block.
              NoteTo access private resources, connect your function to private subnets. If your function needs internet access, see 
                  Enable internet access for VPC-connected Lambda functions. Connecting a function to a public subnet doesn't give it internet access or a public IP address. 
            
              Choose Save.
            
        
      AWS CLI
          To attach a function to an Amazon VPC when you create it
              To create a Lambda function and attach it to a VPC, run the following CLI create-function command.
              aws lambda create-function --function-name my-function \
--runtime nodejs22.x --handler index.js --zip-file fileb://function.zip \
--role arn:aws:iam::123456789012:role/lambda-role \
--vpc-config Ipv6AllowedForDualStack=true,SubnetIds=subnet-071f712345678e7c8,subnet-07fd123456788a036,SecurityGroupIds=sg-085912345678492fb
              Specify your own subnets and security groups and set Ipv6AllowedForDualStack to true or false according to your use case.
            
          To attach an existing function to an Amazon VPC
              To attach an existing function to a VPC, run the following CLI update-function-configuration command.
              aws lambda update-function-configuration --function-name my-function \
--vpc-config Ipv6AllowedForDualStack=true, SubnetIds=subnet-071f712345678e7c8,subnet-07fd123456788a036,SecurityGroupIds=sg-085912345678492fb
            
           To unattach your function from a VPC
              To unattach your function from a VPC, run the following update-function-configurationCLI command with an empty list of VPC subnets and security groups.
              aws lambda update-function-configuration --function-name my-function \
--vpc-config SubnetIds=[],SecurityGroupIds=[]
            
        
      AWS SAM
          To attach your function to a VPC
              To attach a Lambda function to an Amazon VPC, add the VpcConfig property to your function definition as shown in 
                the following example template. For more information about this property, see AWS::Lambda::Function VpcConfig 
                in the AWS CloudFormation User Guide (the AWS SAM VpcConfig property is passed directly to the VpcConfig 
                property of an AWS CloudFormation AWS::Lambda::Function resource).
              AWSTemplateFormatVersion: '2010-09-09'
Transform: AWS::Serverless-2016-10-31

Resources:
  MyFunction:
    Type: AWS::Serverless::Function
    Properties:
      CodeUri: ./lambda_function/
      Handler: lambda_function.handler
      Runtime: python3.12
      VpcConfig:
        SecurityGroupIds:
          - !Ref MySecurityGroup
        SubnetIds:
          - !Ref MySubnet1
          - !Ref MySubnet2
      Policies:
        - AWSLambdaVPCAccessExecutionRole

  MySecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Security group for Lambda function
      VpcId: !Ref MyVPC

  MySubnet1:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref MyVPC
      CidrBlock: 10.0.1.0/24

  MySubnet2:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref MyVPC
      CidrBlock: 10.0.2.0/24

  MyVPC:
    Type: AWS::EC2::VPC
    Properties:
      CidrBlock: 10.0.0.0/16
              For more information about configuring your VPC in AWS SAM, see AWS::EC2::VPC 
                in the AWS CloudFormation User Guide.
            
        
    
   
    Internet access when attached to a VPC
    By default, Lambda functions have access to the public internet. When you attach your function to a VPC, it can only access resources 
      available within that VPC. To give your function access to the internet, you also need to configure the VPC to have internet access. To 
      learn more, see Enable internet access for VPC-connected Lambda functions.
   
  IPv6 support
  Your function can connect to resources in dual-stack VPC subnets over IPv6. This option is turned off by default. To allow outbound IPv6 traffic, use the console or the --vpc-config Ipv6AllowedForDualStack=true option with the create-function or update-function-configuration command.
  NoteTo allow outbound IPv6 traffic in a VPC, all of the subnets that are connected to the function must be dual-stack subnets. Lambda doesn't support outbound IPv6 connections for IPv6-only subnets in a VPC or outbound IPv6 connections for functions that are not connected to a VPC.
  You can update your function code to explicitly connect to subnet resources over IPv6. The following Python example opens a socket and connects to an IPv6 server.
  Example  — Connect to IPv6 serverdef connect_to_server(event, context):
    server_address = event['host']
    server_port = event['port']
    message = event['message']
    run_connect_to_server(server_address, server_port, message)

def run_connect_to_server(server_address, server_port, message):
    sock = socket.socket(socket.AF_INET6, socket.SOCK_STREAM, 0)
    try:
        # Send data
        sock.connect((server_address, int(server_port), 0, 0))
        sock.sendall(message.encode())
        BUFF_SIZE = 4096
        data = b''
        while True:
            segment = sock.recv(BUFF_SIZE)
            data += segment
            # Either 0 or end of data
            if len(segment) < BUFF_SIZE:
                break
        return data
    finally:
        sock.close()

 
    Best practices for using Lambda with Amazon VPCs
    To ensure that your Lambda VPC configuration meets best practice guidelines, follow the advice in the following sections.
     
      Security best practices
      To attach your Lambda function to a VPC, you need to give your function’s execution role a number of Amazon EC2 permissions. These 
        permissions are required to create the network interfaces your function uses to access the resources in the VPC. However, these 
        permissions are also implicitly granted to your function’s code. This means that your function code has permission to make these Amazon EC2 API calls.
      To follow the principle of least-privilege access, add a deny policy like the following example to your function’s execution role. 
        This policy prevents your function from making calls to the Amazon EC2 APIs that the Lambda service uses to attach your function to a VPC.
      {
    "Version": "2012-10-17",
    "Statement": [
        {
            "Effect": "Deny",
            "Action": [ 
                 "ec2:CreateNetworkInterface",
                 "ec2:DeleteNetworkInterface",
                 "ec2:DescribeNetworkInterfaces",
                 "ec2:DescribeSubnets",
                 "ec2:DetachNetworkInterface",
                 "ec2:AssignPrivateIpAddresses",
                 "ec2:UnassignPrivateIpAddresses"
            ],
            "Resource": [ "*" ],
            "Condition": {
                "ArnEquals": {
                    "lambda:SourceFunctionArn": [
                        "arn:aws:lambda:us-west-2:123456789012:function:my_function"
                    ]
                }
            }
        }
    ]
}
      AWS provides security groups and 
        network Access Control Lists (ACLs) to increase security 
        in your VPC. Security groups control inbound and outbound traffic for your resources, and network ACLs control inbound and outbound traffic 
        for your subnets. Security groups provide enough access control for most subnets. You can use network ACLs if you want an additional layer 
        of security for your VPC. For general guidelines on security best practices when using Amazon VPCs, see Security best practices for your VPC 
        in the Amazon Virtual Private Cloud User Guide.
     
     
      Performance best practices
      When you attach your function to a VPC, Lambda checks to see if there is an available network resource (Hyperplane ENI) it can use to 
        connect to. Hyperplane ENIs are associated with a particular combination of security groups and VPC subnets. If you’ve already attached 
        one function to a VPC, specifying the same subnets and security groups when you attach another function means that Lambda can share the 
        network resources and avoid the need to create a new Hyperplane ENI. For more information about Hyperplane ENIs and their lifecycle, 
        see Understanding Hyperplane Elastic Network Interfaces (ENIs).
     
   
    Understanding Hyperplane Elastic Network Interfaces (ENIs)
    A Hyperplane ENI is a managed resource that acts as a network interface between your Lambda function and the resources you want your function 
      to connect to. The Lambda service creates and manages these ENIs automatically when you attach your function to a VPC.
    Hyperplane ENIs are not directly visible to you, and you don’t need to configure or manage them. However, knowing how they work can help 
      you to understand your function’s behavior when you attach it to a VPC.
    The first time you attach a function to a VPC using a particular subnet and security group combination, Lambda creates a Hyperplane ENI. Other 
      functions in your account that use the same subnet and security group combination can also use this ENI. Wherever possible, Lambda reuses existing 
      ENIs to optimize resource utilization and minimize the creation of new ENIs. Each Hyperplane ENI supports up to 65,000 connections/ports. If the 
      number of connections exceeds this limit, Lambda scales the number of ENIs automatically based on network traffic and concurrency requirements.
    For new functions, while Lambda is creating a Hyperplane ENI, your function remains in the Pending state and you can’t invoke it. Your function 
      transitions to the Active state only when the Hyperplane ENI is ready, which can take several minutes. For existing functions, you can’t perform 
      additional operations that target the function, such as creating versions or updating the function’s code, but you can continue to invoke previous 
      versions of the function.
      As part of managing the ENI lifecycle, Lambda may delete and recreate ENIs to load balance network traffic across ENIs or to address issues found 
        in ENI health-checks. Additionally, if a Lambda function remains idle for 30 days, Lambda reclaims any unused Hyperplane ENIs and sets the function state to idle. The next invocation attempt will fail, and the function re-enters the Pending state until Lambda completes the creation or allocation of a Hyperplane ENI. We recommend that your design doesn't rely on the persistence of ENIs.
    When you update a function to remove its VPC configuration, Lambda requires up to 20 minutes to delete the
      attached Hyperplane ENI. Lambda only deletes the ENI if no other function (or published function version) is
      using that Hyperplane ENI. 
    Lambda relies on permissions in the function  execution
      role to delete the Hyperplane ENI. If you delete the execution role before Lambda deletes the Hyperplane
      ENI, Lambda won't be able to delete the Hyperplane ENI. You can manually perform the deletion.
   
    Using IAM condition keys for VPC settings
    You can use Lambda-specific condition keys for VPC settings to provide additional permission controls for your
      Lambda functions. For example, you can require that all functions in your organization are connected to a VPC. You
      can also specify the subnets and security groups that the function's users can and can't use.
    Lambda supports the following condition keys in IAM policies:
    
       
       
       
    
        lambda:VpcIds – Allow or deny one or more VPCs.
      
        lambda:SubnetIds – Allow or deny one or more subnets.
      
        lambda:SecurityGroupIds – Allow or deny one or more security
          groups.
      
    The Lambda API operations CreateFunction and UpdateFunctionConfiguration support these condition keys. For
      more information about using condition keys in IAM policies, see IAM JSON Policy Elements:
        Condition in the IAM User Guide.
    TipIf your function already includes a VPC configuration from a previous API request, you can send an
        UpdateFunctionConfiguration request without the VPC configuration.
     
      Example policies with condition keys for VPC settings
      The following examples demonstrate how to use condition keys for VPC settings. After you create a policy
        statement with the desired restrictions, append the policy statement for the target user or role.
       
        Ensure that users deploy only VPC-connected functions
        To ensure that all users deploy only VPC-connected functions, you can deny function create and update
          operations that don't include a valid VPC ID. 
        Note that VPC ID is not an input parameter to the CreateFunction or
          UpdateFunctionConfiguration request. Lambda retrieves the VPC ID value based on the subnet and
          security group parameters.
        {
  "Version": "2012-10-17",
  "Statement": [
    {
      "Sid": "EnforceVPCFunction",
      "Action": [
          "lambda:CreateFunction",
          "lambda:UpdateFunctionConfiguration"
       ],
      "Effect": "Deny",
      "Resource": "*",
      "Condition": {
        "Null": {
           "lambda:VpcIds": "true"
        }
      }
    }
  ]
}
        
       
       
        Deny users access to specific VPCs, subnets, or security
            groups
        To deny users access to specific VPCs, use StringEquals to check the value of the
          lambda:VpcIds condition. The following example denies users access to vpc-1 and
          vpc-2.
        {
  "Version": "2012-10-17",
  "Statement": [
    {
      "Sid": "EnforceOutOfVPC",
      "Action": [
          "lambda:CreateFunction",
          "lambda:UpdateFunctionConfiguration"
       ],
      "Effect": "Deny",
      "Resource": "*",
      "Condition": {
        "StringEquals": {
            "lambda:VpcIds": ["vpc-1", "vpc-2"]
        }
      }
    } 
        
        To deny users access to specific subnets, use StringEquals to check the value of the
          lambda:SubnetIds condition. The following example denies users access to subnet-1
          and subnet-2.
        {
      "Sid": "EnforceOutOfSubnet",
      "Action": [
          "lambda:CreateFunction",
          "lambda:UpdateFunctionConfiguration"
       ],
      "Effect": "Deny",
      "Resource": "*",
      "Condition": {
        "ForAnyValue:StringEquals": {
            "lambda:SubnetIds": ["subnet-1", "subnet-2"]
        }
      }
    }
       
        To deny users access to specific security groups, use StringEquals to check the value of the
          lambda:SecurityGroupIds condition. The following example denies users access to
          sg-1 and sg-2.
        {
      "Sid": "EnforceOutOfSecurityGroups",
      "Action": [
          "lambda:CreateFunction",
          "lambda:UpdateFunctionConfiguration"
       ],
      "Effect": "Deny",
      "Resource": "*",
      "Condition": {
        "ForAnyValue:StringEquals": {
            "lambda:SecurityGroupIds": ["sg-1", "sg-2"]
        }
      }
    }
  ]
}
        
       
       
        Allow users to create and update functions with specific VPC
            settings
        To allow users to access specific VPCs, use StringEquals to check the value of the
          lambda:VpcIds condition. The following example allows users to access vpc-1 and
          vpc-2.
        {
  "Version": "2012-10-17",
  "Statement": [
    {
      "Sid": "EnforceStayInSpecificVpc",
      "Action": [
          "lambda:CreateFunction",
          "lambda:UpdateFunctionConfiguration"
       ],
      "Effect": "Allow",
      "Resource": "*",
      "Condition": {
        "StringEquals": {
            "lambda:VpcIds": ["vpc-1", "vpc-2"]
        }
      }
    }
        
        To allow users to access specific subnets, use StringEquals to check the value of the
          lambda:SubnetIds condition. The following example allows users to access subnet-1
          and subnet-2.
        {
      "Sid": "EnforceStayInSpecificSubnets",
      "Action": [
          "lambda:CreateFunction",
          "lambda:UpdateFunctionConfiguration"
       ],
      "Effect": "Allow",
      "Resource": "*",
      "Condition": {
        "ForAllValues:StringEquals": {
            "lambda:SubnetIds": ["subnet-1", "subnet-2"]
        }
      }
    }
      
        To allow users to access specific security groups, use StringEquals to check the value of the
          lambda:SecurityGroupIds condition. The following example allows users to access
          sg-1 and sg-2.
        {
      "Sid": "EnforceStayInSpecificSecurityGroup",
      "Action": [
          "lambda:CreateFunction",
          "lambda:UpdateFunctionConfiguration"
       ],
      "Effect": "Allow",
      "Resource": "*",
      "Condition": {
        "ForAllValues:StringEquals": {
            "lambda:SecurityGroupIds": ["sg-1", "sg-2"]
        }
      }
    }
  ]
} 
        
       
     
   
    VPC tutorials
    In the following tutorials, you connect a Lambda function to resources in your VPC.
    
       
       
    
        Tutorial: Using a Lambda function to access Amazon RDS in an Amazon VPC
      
        Tutorial: Configuring a Lambda function to access Amazon ElastiCache in an Amazon VPC
      
  Document ConventionsSecuring environment variablesAttaching functions to resources in another accountDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideExecution role and user permissionsConfiguring a file system and access pointConnecting to a file system (console)Configuring file system access for Lambda functionsYou can configure a function to mount an Amazon Elastic File System (Amazon EFS) file system to a local directory. With Amazon EFS, your
    function code can access and modify shared resources safely and at high concurrency.SectionsExecution role and user permissionsConfiguring a file system and access pointConnecting to a file system (console)
    Execution role and user permissions
    
    If the file system doesn't have a user-configured AWS Identity and Access Management (IAM) policy, EFS uses a default policy that grants full access to any client that can connect to the file system using a file system mount target. 
      If the file system has a user-configured IAM policy, your function's
      execution role must have the correct elasticfilesystem permissions.
    
      Execution role permissions
       
       
    
        elasticfilesystem:ClientMount
      
        elasticfilesystem:ClientWrite (not required for read-only
          connections)
      
    These permissions are included in the AmazonElasticFileSystemClientReadWriteAccess
      managed policy. Additionally, your execution role must have the permissions
      required to connect to the file system's VPC.
    When you configure a file system, Lambda uses your permissions to verify mount targets. To configure a function
      to connect to a file system, your user needs the following permissions:
    
      User permissions
       
    
        elasticfilesystem:DescribeMountTargets
      
   
    Configuring a file system and access point
    
    Create a file system in Amazon EFS with a mount target in every Availability Zone that your function connects to.
      For performance and resilience, use at least two Availability Zones. For example, in a simple configuration you
      could have a VPC with two private subnets in separate Availability Zones. The function connects to both subnets
      and a mount target is available in each. Ensure that NFS traffic (port 2049) is allowed by the security groups
      used by the function and mount targets.
    
    NoteWhen you create a file system, you choose a performance mode that can't be changed later. General
        purpose mode has lower latency, and Max I/O mode supports a higher maximum
        throughput and IOPS. For help choosing, see Amazon EFS
          performance in the Amazon Elastic File System User Guide.
    
    An access point connects each instance of the function to the right mount target for the Availability Zone it
      connects to. For best performance, create an access point with a non-root path, and limit the number of files that
      you create in each directory. The
      following example creates a directory named my-function on the file system and sets the owner ID to
      1001 with standard directory permissions (755).
    Example access point configuration
         
         
         
         
         
         
         
      
          Name – files
        
          User ID – 1001
        
          Group ID – 1001
        
          Path – /my-function
        
          Permissions – 755
        
          Owner user ID – 1001
        
          Group user ID – 1001
        
    When a function uses the access point, it is given user ID 1001 and has full access to the directory.
    For more information, see the following topics in the Amazon Elastic File System User Guide:
    
       
       
    
        Creating resources for Amazon EFS
      
        Working with users, groups, and
          permissions
      
   
    Connecting to a file system (console)
    
    A function connects to a file system over the local network in a VPC. The subnets that your function connects to
      can be the same subnets that contain mount points for your file system, or subnets in the same Availability Zone
      that can route NFS traffic (port 2049) to the file system.
    NoteIf your function is not already connected to a VPC, see Giving Lambda functions access to resources in an Amazon VPC.
    To configure file system accessOpen the Functions page of the Lambda console.
        Choose a function.
      
        Choose Configuration and then choose File systems.
      
        Under File system, choose Add file system.
      
        Configure the following properties:
        
           
           
        
            EFS file system – The access point for a file system in the same VPC.
          
            Local mount path – The location where the file system is mounted on the
              Lambda function, starting with /mnt/.
          
      
    
    PricingAmazon EFS charges for storage and throughput, with rates that vary by storage class. For details, see Amazon EFS pricing.Lambda charges for data transfer between VPCs. This only applies if your function's VPC is peered to another
        VPC with a file system. The rates are the same as for Amazon EC2 data transfer between VPCs in the same Region. For
        details, see Lambda pricing.
  Document ConventionsInbound networkingAliasesDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideUse casesSupported features and limitationsSupported RegionsCompatibility considerationsPricingImproving startup performance with Lambda SnapStartLambda SnapStart can provide as low as sub-second startup performance, typically with no changes to your function code. SnapStart makes it easier to build highly responsive and scalable applications without provisioning resources or implementing complex performance optimizations.The largest contributor to startup latency (often referred to as cold start time) is the time that Lambda spends initializing the function, which includes loading the function's code, starting the runtime, and initializing the function code. With SnapStart, Lambda initializes your function when you publish a function version. Lambda takes a Firecracker
      microVM snapshot of the memory and disk state of the initialized execution environment, encrypts the snapshot, and intelligently caches it to optimize retrieval latency.To ensure resiliency, Lambda maintains several copies of each snapshot. Lambda automatically patches snapshots and their copies with the latest runtime and security updates. When you invoke the function version for the first time, and as the invocations scale up,
    Lambda resumes new execution environments from the cached snapshot instead of initializing them from scratch, improving
    startup latency.ImportantIf your applications depend on uniqueness of state, you must evaluate your function code and verify that it is
      resilient to snapshot operations. For more information, see Handling uniqueness with Lambda SnapStart.TopicsWhen to use SnapStartSupported features and limitationsSupported RegionsCompatibility considerationsSnapStart pricingActivating and managing Lambda SnapStartHandling uniqueness with Lambda SnapStartImplement code before or after Lambda function snapshotsMonitoring for Lambda SnapStartSecurity model for Lambda SnapStartMaximize Lambda SnapStart performanceTroubleshooting SnapStart errors for Lambda functions
    When to use SnapStart
    Lambda SnapStart is designed to address the latency variability introduced by one-time initialization code, such as loading module dependencies or frameworks. These operations can sometimes take several seconds to complete during the initial invocation. Use SnapStart to reduce this latency from several seconds to as low as sub-second, in optimal scenarios. SnapStart works best when used with function invocations at scale. Functions that are invoked infrequently might not experience the same performance improvements.
      SnapStart is particularly beneficial for two main types of applications:
    
       
       
    
        Latency-sensitive APIs and user flows: Functions that are part of critical API endpoints or user-facing flows can benefit from SnapStart's reduced latency and improved response times.
      
        Latency-sensitive data processing workflows: Time-bound data processing workflows that use Lambda functions can achieve better throughput by reducing outlier function initialization latency.
      
    Provisioned concurrency keeps functions initialized and ready to respond in double-digit milliseconds. Use provisioned concurrency if your application has strict cold start latency requirements that can't be adequately addressed by SnapStart.
   
    Supported features and limitations
    SnapStart is available for the following Lambda managed runtimes:
    
       
       
       
    
        Java 11 and later
      
        Python 3.12 and later
      
        .NET 8 and later. If you're using the Lambda Annotations framework for .NET, upgrade to Amazon.Lambda.Annotations version 1.6.0 or later to ensure compatibility with SnapStart.
      
    Other managed runtimes (such as nodejs22.x and ruby3.4), OS-only runtimes, and container images are not supported.
    SnapStart does not support provisioned concurrency, Amazon Elastic File System (Amazon EFS), or ephemeral
      storage greater than 512 MB.
    NoteYou can use SnapStart only on published function
          versions and aliases that point to versions. You can't use
        SnapStart on a function's unpublished version ($LATEST).
   
    Supported Regions
    For Java runtimes, Lambda SnapStart is available in all commercial Regions except Asia Pacific (Malaysia).For Python and .NET runtimes, Lambda SnapStart is available in the following AWS Regions:
           
           
           
           
           
           
           
           
           
        US East (N. Virginia)US East (Ohio)US West (Oregon)Asia Pacific (Singapore)Asia Pacific (Sydney)Asia Pacific (Tokyo)Europe (Frankfurt)Europe (Ireland)Europe (Stockholm)
   
    Compatibility considerations
    
      With SnapStart, Lambda uses a single snapshot as the initial state for multiple execution environments. If
        your function uses any of the following during the initialization
          phase, then you might need to make some changes before using SnapStart:
       
       
       
    
        Uniqueness
        
          If your initialization code generates unique content that is included in the snapshot, then the content might not be unique when it is reused across execution environments. To maintain uniqueness when using SnapStart, you must generate unique content after initialization. This includes unique IDs, unique secrets, and entropy that's used to generate pseudorandomness. To learn how to restore uniqueness, see Handling uniqueness with Lambda SnapStart.
        
      
        Network connections
        
          The state of connections that your function establishes during the initialization phase isn't guaranteed when Lambda resumes your function from a snapshot. Validate the state of your network connections and re-establish them as necessary.
            In most cases, network connections that an AWS SDK establishes automatically resume. For other connections, review the best
              practices. 
        
      
        Temporary data
        
          Some functions download or initialize ephemeral data, such as temporary credentials or cached
            timestamps, during the initialization phase. Refresh ephemeral data in the function handler before using it, even when not using SnapStart.
        
      
   
    SnapStart pricing
    NoteFor Java managed runtimes, there's no additional cost for SnapStart. You're charged based on the number of requests for your functions,
        the time that it takes your code to run, and the memory configured for your function.
    The cost of using SnapStart includes the following:    
    
       
       
    
        Caching: For every function version that you publish with SnapStart enabled,  you pay for the cost of caching and maintaining the snapshot. The price depends on the amount of memory that you allocate to your function. You're charged for a minimum of 3 hours. You will continue to be charged as long as your function remains active. Use the ListVersionsByFunction API action to identify function versions, and then use DeleteFunction to delete unused versions. To automatically delete unused function versions, see the Lambda Version Cleanup pattern on Serverless Land.
      
        Restoration: Each time a function instance is restored from a snapshot, you pay a restoration charge. The price depends on the amount of memory you allocate to your function.
      
    As with all Lambda functions, duration charges apply to code that runs in the function handler. For SnapStart functions, duration charges also apply to initialization code that's declared outside of the handler, the time it takes for the runtime to load, and any code that runs in a runtime hook. Duration is calculated from the time that your code begins running until it returns or otherwise ends, rounded up to the nearest 1 ms. Lambda maintains cached copies of your snapshot for resiliency and automatically applies software updates, such as runtime upgrades and security patches to them. Charges apply each time that Lambda re-runs your initialization code to apply software updates.
    For more information about the cost of using SnapStart, see AWS Lambda Pricing.
  Document ConventionsTesting serverless functionsActivating SnapStartDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideRuntime dependencies in Node.jsCreating a .zip deployment package with no dependenciesCreating a .zip deployment package with dependenciesCreating a Node.js layer for your dependenciesDependency search path and runtime-included librariesCreating and updating Node.js Lambda functions using .zip filesDeploy Node.js Lambda functions with .zip file archives
    Your AWS Lambda function’s code comprises a .js or .mjs file containing your function’s handler code, together with any additional packages and modules 
    your code depends on. To deploy this function code to Lambda, you use a deployment package. This package may either be a 
  .zip file archive or a container image.  
  For more information about using container images with Node.js, see Deploy Node.js Lambda functions with container images.
  
    To create your deployment package as .zip file archive, you can use your command-line tool’s built-in .zip file archive utility, or any other 
    .zip file utility such as 7zip. The examples shown in the following sections assume 
  you’re using a command-line zip tool in a Linux or MacOS environment. To use the same commands in Windows, you can 
  install the Windows Subsystem for Linux to get a Windows-integrated 
  version of Ubuntu and Bash.
  
    Note that Lambda uses POSIX file permissions, so you may need to set permissions for the deployment package folder before you create the .zip file archive.
  TopicsRuntime dependencies in Node.jsCreating a .zip deployment package with no dependenciesCreating a .zip deployment package with dependenciesCreating a Node.js layer for your dependenciesDependency search path and runtime-included librariesCreating and updating Node.js Lambda functions using .zip files
    Runtime dependencies in Node.js
    
      For Lambda functions that use the Node.js runtime, a dependency can be any Node.js module. The Node.js runtime includes a number of common 
      libraries, as well as a version of the AWS SDK for JavaScript. The nodejs16.x Lambda runtime includes version 2.x of the SDK. Runtime versions nodejs18.x and later include version 3 of the SDK. To use version 2 of the SDK with runtime versions nodejs18.x and later, add the SDK to your 
      .zip file deployment package. If your chosen runtime includes the version of the SDK you are using, you don't need to include the SDK library 
      in your .zip file. To find out which version of the SDK is included in the runtime you're using, see Runtime-included SDK versions.
    
    
      Lambda periodically updates the SDK libraries in the Node.js runtime to include the latest features and security upgrades. Lambda also applies 
      security patches and updates to the other libraries included in the runtime. To have full control of the dependencies in your package, you can 
      add your preferred version of any runtime-included dependency to your deployment package. For example, if you want to use a particular version of 
      the SDK for JavaScript, you can include it in your .zip file as a dependency. For more information on adding runtime-included dependencies to your .zip 
      file, see Dependency search path and runtime-included libraries.
    
    
      Under the AWS shared responsibility model, 
      you are responsible for the management of any dependencies in your functions' deployment packages. This includes applying updates and security 
      patches. To update dependencies in your function's deployment package, first create a new .zip file and then upload it to Lambda. See Creating a .zip deployment package with dependencies 
      and Creating and updating Node.js Lambda functions using .zip files for more information.
    
   
    Creating a .zip deployment package with no dependencies
    
      If your function code has no dependencies except for libraries included in the Lambda runtime, your .zip file contains only the index.js or 
      index.mjs file with your function’s handler code. Use your preferred zip utility to create a .zip file with your index.js or 
      index.mjs file at the root. If the file containing your handler code isn't at the root of your .zip file, Lambda won’t be able to run your code.
    
    
      To learn how to deploy your .zip file to create a new Lambda function or update an existing one, see Creating and updating Node.js Lambda functions using .zip files.
    
   
    Creating a .zip deployment package with dependencies
    If your function code depends on packages or modules that aren't included in the Lambda Node.js runtime,
      you can either add these dependencies to your .zip file with your function code or use a
      Lambda layer. The instructions in this section show you how to
      include your dependencies in your .zip deployment package. For instructions on how to include your
      dependencies in a layer, see Creating a Node.js layer for your dependencies.
    The following example CLI commands create a .zip file named my_deployment_package.zip containing the index.js 
      or index.mjs file with your function's handler code and its dependencies. In the example, you install dependencies using the 
      npm package manager.
    To create the deployment package
        Navigate to the project directory containing your index.js or index.mjs source code file. In this example, 
          the directory is named my_function.
        cd my_function
      
        Install your function's required libraries in the node_modules directory using the npm install command. In this 
          example you install the AWS X-Ray SDK for Node.js.
        npm install aws-xray-sdk
        This creates a folder structure similar to the following:
        ~/my_function
├── index.mjs
└── node_modules
    ├── async
    ├── async-listener
    ├── atomic-batcher
    ├── aws-sdk
    ├── aws-xray-sdk
    ├── aws-xray-sdk-core
        You can also add custom modules that you create yourself to your deployment package. Create a directory under node_modules 
          with the name of your module and save your custom written packages there.
      
        Create a .zip file that contains the contents of your project folder at the root. Use the r (recursive) option to 
          ensure that zip compresses the subfolders.
        zip -r my_deployment_package.zip .
      
   
    Creating a Node.js layer for your dependencies
    The instructions in this section show you how to include your dependencies in a layer. For instructions
      on how to include your dependencies in your deployment package, see
      Creating a .zip deployment package with dependencies.
    When you add a layer to a function, Lambda loads the layer content into the
      /opt directory of that execution environment. For each Lambda runtime,
      the PATH variable already includes specific folder paths within the
      /opt directory. To ensure that Lambda picks up your layer content, 
      your layer .zip file should have its dependencies
      in the following folder paths:
    
       
       
       
          
    
        nodejs/node_modules
      
        nodejs/node16/node_modules (NODE_PATH)
      
        nodejs/node18/node_modules (NODE_PATH)
      
        nodejs/node20/node_modules (NODE_PATH)
      
    For example, your layer .zip file structure might look like the following:
    xray-sdk.zip
└ nodejs/node_modules/aws-xray-sdk
    In addition, Lambda automatically detects any libraries in the /opt/lib
      directory, and any binaries in the /opt/bin directory. To ensure
      that Lambda properly finds your layer content, you can also create a layer
      with the following structure:
      custom-layer.zip
└ lib
    | lib_1
    | lib_2
└ bin
    | bin_1
    | bin_2
    After you package your layer, see Creating and deleting layers in Lambda
      and Adding layers to functions to complete your layer setup.
   
    Dependency search path and runtime-included libraries
    The Node.js runtime includes a number of common libraries, as well as a version of the AWS SDK for JavaScript. If you want to use a different version of a runtime-included library, you can do this by bundling it with your function or by adding it as a 
      dependency in your deployment package. For example, you can use a different version of the SDK by adding it to your .zip deployment package. 
      You can also include it in a Lambda layer for your function.
    When you use an import or require statement in your code, the Node.js runtime searches the directories in the NODE_PATH 
      path until it finds the module. By default, the first location the runtime searches is the directory into which your .zip deployment package is 
      decompressed and mounted (/var/task). If you include a version of a runtime-included library in your deployment package, this 
      version will take precedence over the version included in the runtime. Dependencies in your deployment package also have precedence over 
      dependencies in layers.
    When you add a dependency to a layer, Lambda extracts this to /opt/nodejs/nodexx/node_modules where nodexx 
      represents the version of the runtime you are using. In the search path, this directory has precedence over the directory containing the 
      runtime-included libraries (/var/lang/lib/node_modules). Libraries in function layers therefore have precedence over versions 
      included in the runtime.
    You can see the full search path for your Lambda function by adding the following line of code.
    console.log(process.env.NODE_PATH)
    You can also add dependencies in a separate folder inside your .zip package. For example, you might add a custom module to a folder in 
      your .zip package called common. When your .zip package is decompressed and mounted, this folder is placed inside the /var/task directory. 
      To use a dependency from a folder in your .zip deployment package in your code, use an import { } from or const { } = require() statement, 
      depending on whether you are using CJS or ESM module resolution. For example:
    import { myModule } from './common'
    If you bundle your code with esbuild, rollup, or similar, the dependencies used by your function are bundled together in one 
      or more files. We recommend using this method to vend dependencies whenever possible. Compared to adding dependencies to your deployment package, 
      bundling your code results in improved performance due to the reduction in I/O operations.
   
    Creating and updating Node.js Lambda functions using .zip files
    
      After you have created your .zip deployment package, you can use it to create a new Lambda function or update an existing one. You can deploy 
      your .zip package using the Lambda console, the AWS Command Line Interface, and the Lambda API. You can also create and update Lambda functions using 
      AWS Serverless Application Model (AWS SAM) and AWS CloudFormation.
    
    The maximum size for a .zip deployment package for Lambda is 250 MB (unzipped). Note that this limit applies to the combined size of all the files you upload, 
    including any Lambda layers.
    The Lambda runtime needs permission to read the files in your deployment package. In Linux permissions octal notation, Lambda needs 644 permissions 
      for non-executable files (rw-r--r--) and 755 permissions (rwxr-xr-x) for directories and executable files.
    In Linux and MacOS, use the chmod command to change file permissions on files and directories in your deployment package. For 
      example, to give a non-executable file the correct permissions, run the following command.
    chmod 644 <filepath>
    To change file permissions in Windows, see Set, View, Change, or Remove Permissions on an Object 
    in the Microsoft Windows documentation.
    NoteIf you don't grant Lambda the permissions it needs to access directories in your deployment package, Lambda sets the permissions for those directories to 755 (rwxr-xr-x).
     
      Creating and updating functions with .zip files using the console
      
      To create a new function, you must first create the function in the console, then upload your .zip archive. To update an existing function, open the page for your function, then follow the same procedure to add your updated .zip file.
    

      If your .zip file is less than 50MB, you can create or update a function by uploading the file directly from your local machine. For .zip files greater than 50MB, you must upload your package to an Amazon S3 bucket first. For instructions on how to upload a file to an Amazon S3 bucket using the AWS Management Console, see Getting started with Amazon S3. To upload files using the AWS CLI, see Move objects in the AWS CLI User Guide.
    
      NoteYou cannot change the deployment package type (.zip or container image) for an existing function. For example, you cannot convert a container image function to use a .zip file archive. You must create a new function.
  To create a new function (console)
      Open the Functions page of the Lambda console and choose Create Function.
    
      Choose Author from scratch.
    
      Under Basic information, do the following:
      
          For Function name, enter the name for your function.
          
              For Runtime, select the runtime you want to use.
            
              (Optional) For Architecture, choose the instruction set architecture for your function. The default architecture is x86_64. Ensure that the .zip deployment package for your function is compatible with the instruction set architecture you select.
            
    
      (Optional) Under Permissions, expand Change default execution role. You can create a new Execution role or use an existing one.
    
      Choose Create function. Lambda creates a basic 'Hello world' function using your chosen runtime.
    
  To upload a .zip archive from your local machine (console)
      In the Functions page of the Lambda console, choose the function you want to upload the .zip file for.
    
      Select the Code tab.
    
      In the Code source pane, choose Upload from.
    
      Choose .zip file.
    
      To upload the .zip file, do the following:
      
          Select Upload, then select your .zip file in the file chooser.
        
          Choose Open.
        
          Choose Save.
        
    
  
  To upload a .zip archive from an Amazon S3 bucket (console)
      In the Functions page of the Lambda console, choose the function you want to upload a new .zip file for.
    
      Select the Code tab.
    
      In the Code source pane, choose Upload from.
    
      Choose Amazon S3 location.
    
      Paste the Amazon S3 link URL of your .zip file and choose Save.
    
     
     
      Updating .zip file functions using the console code editor
      
     
    
      For some functions with .zip deployment packages, you can use the Lambda console’s built-in code editor to update your function code directly. To use this feature, your function must meet the following criteria:
    
    
       
       
    
        Your function must use one of the interpreted language runtimes (Python, Node.js, or Ruby)
      
        Your function’s deployment package must be smaller than 50 MB (unzipped).
      
    Function code for functions with container image deployment packages cannot be edited directly in the console.
    To update function code using the console code editor
        Open the Functions page of the Lambda console and select your function.
      
        Select the Code tab.
      
        In the Code source pane, select your source code file and edit it in the integrated code editor.
      
        In the DEPLOY section, choose Deploy to update your function's code:

   
    
   
   

      
     
      Creating and updating functions with .zip files using the AWS CLI
      
      You can can use the AWS CLI to create a new function or to update an existing one using a .zip file. Use the create-function 
      and update-function-code commands to deploy your .zip 
      package. If your .zip file is smaller than 50MB, you can upload the .zip package from a file location on your local build machine. For larger files, 
      you must upload your .zip package from an Amazon S3 bucket. For instructions on how to upload a file to an Amazon S3 bucket using the AWS CLI, see Move objects in the AWS CLI User Guide.
    
    NoteIf you upload your .zip file from an Amazon S3 bucket using the AWS CLI, the bucket must be located in the same AWS Region as your function.
    
      To create a new function using a .zip file with the AWS CLI, you must specify the following:
    
    
       
       
       
       
    
        The name of your function (--function-name)
      
        Your function’s runtime (--runtime)
      
        The Amazon Resource Name (ARN) of your function’s execution role (--role)
      
        The name of the handler method in your function code (--handler)
      
    
      You must also specify the location of your .zip file. If your .zip file is located in a folder on your local build machine, use the --zip-file option to specify the file path, as shown in the following example command.
    
    aws lambda create-function --function-name myFunction \
--runtime nodejs22.x --handler index.handler \
--role arn:aws:iam::111122223333:role/service-role/my-lambda-role \
--zip-file fileb://myFunction.zip
    
      To specify the location of .zip file in an Amazon S3 bucket, use the --code option as shown in the following example command. You only 
      need to use the S3ObjectVersion parameter for versioned objects.
    
    aws lambda create-function --function-name myFunction \
--runtime nodejs22.x --handler index.handler \
--role arn:aws:iam::111122223333:role/service-role/my-lambda-role \
--code S3Bucket=amzn-s3-demo-bucket,S3Key=myFileName.zip,S3ObjectVersion=myObjectVersion
    
      To update an existing function using the CLI, you specify the the name of your function using the --function-name parameter. You 
      must also specify the location of the .zip file you want to use to update your function code. If your .zip file is located in a folder on your 
      local build machine, use the --zip-file option to specify the file path, as shown in the following example command.
    
    aws lambda update-function-code --function-name myFunction \
--zip-file fileb://myFunction.zip
    
      To specify the location of .zip file in an Amazon S3 bucket, use the --s3-bucket and --s3-key options as shown in the 
      following example command. You only need to use the --s3-object-version parameter for versioned objects.
    
    aws lambda update-function-code --function-name myFunction \
--s3-bucket amzn-s3-demo-bucket --s3-key myFileName.zip --s3-object-version myObject Version
     
    
     
      Creating and updating functions with .zip files using the Lambda API
      
      To create and update functions using a .zip file archive, use the following API operations:
    

 
 

CreateFunction

UpdateFunctionCode

     
     
      Creating and updating functions with .zip files using AWS SAM
      
      The AWS Serverless Application Model (AWS SAM) is a toolkit that helps streamline the process of building and running serverless applications on AWS. You define the resources for your application in a 
      YAML or JSON template and use the AWS SAM command line interface (AWS SAM CLI) to build, package, and deploy your applications. When you build a Lambda function from an AWS SAM template, 
      AWS SAM automatically creates a .zip deployment package or container image with your function code and any dependencies you specify. To learn more about using AWS SAM to build and deploy 
      Lambda functions, see Getting started with AWS SAM in the
      AWS Serverless Application Model Developer Guide.

      You can also use AWS SAM to create a Lambda function using an existing .zip file archive. To create a Lambda function using AWS SAM, you can save your .zip file in 
      an Amazon S3 bucket or in a local folder on your build machine. For instructions on how to upload a file to an Amazon S3 bucket using the AWS CLI, 
      see Move objects in the AWS CLI User Guide.
    

      In your AWS SAM template, the AWS::Serverless::Function resource specifies your Lambda function. In this resource, set the following 
  properties to create a function using a .zip file archive:
    

 
 
 

PackageType - set to Zip

CodeUri - set to the  function code's Amazon S3 URI, path to local folder, or FunctionCode object

Runtime - Set to your chosen runtime


      With AWS SAM, if your .zip file is larger than 50MB, you don’t need to upload it to an Amazon S3 bucket first. AWS SAM can upload .zip packages up to 
      the maximum allowed size of 250MB (unzipped) from a location on your local build machine.
    

      To learn more about deploying functions using .zip file in AWS SAM, see AWS::Serverless::Function in the AWS SAM Developer Guide.
    
     
     
      Creating and updating functions with .zip files using AWS CloudFormation
      
      You can use AWS CloudFormation to create a Lambda function using a .zip file archive. To create a Lambda function from a .zip file, you must first upload 
      your file to an Amazon S3 bucket. For instructions on how to upload a file to an Amazon S3 bucket using the AWS CLI, see Move objects 
  in the AWS CLI User Guide. 
  In your AWS CloudFormation template, the AWS::Lambda::Function resource specifies your Lambda function. In this resource, set the following 
    properties to create a function using a .zip file archive:

 
 
 

PackageType - Set to Zip

Code - Enter the Amazon S3 bucket name and the .zip file name in the S3Bucket and S3Key fields

Runtime - Set to your chosen runtime


      The .zip file that AWS CloudFormation generates cannot exceed 4MB. To learn more about deploying functions using .zip file in AWS CloudFormation, see AWS::Lambda::Function 
  in the AWS CloudFormation User Guide.
    
     
  Document ConventionsHandlerDeploy container imagesDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideRuntime dependencies in Node.jsCreating a .zip deployment package with no dependenciesCreating a .zip deployment package with dependenciesCreating a Node.js layer for your dependenciesDependency search path and runtime-included librariesCreating and updating Node.js Lambda functions using .zip filesDeploy Node.js Lambda functions with .zip file archives
    Your AWS Lambda function’s code comprises a .js or .mjs file containing your function’s handler code, together with any additional packages and modules 
    your code depends on. To deploy this function code to Lambda, you use a deployment package. This package may either be a 
  .zip file archive or a container image.  
  For more information about using container images with Node.js, see Deploy Node.js Lambda functions with container images.
  
    To create your deployment package as .zip file archive, you can use your command-line tool’s built-in .zip file archive utility, or any other 
    .zip file utility such as 7zip. The examples shown in the following sections assume 
  you’re using a command-line zip tool in a Linux or MacOS environment. To use the same commands in Windows, you can 
  install the Windows Subsystem for Linux to get a Windows-integrated 
  version of Ubuntu and Bash.
  
    Note that Lambda uses POSIX file permissions, so you may need to set permissions for the deployment package folder before you create the .zip file archive.
  TopicsRuntime dependencies in Node.jsCreating a .zip deployment package with no dependenciesCreating a .zip deployment package with dependenciesCreating a Node.js layer for your dependenciesDependency search path and runtime-included librariesCreating and updating Node.js Lambda functions using .zip files
    Runtime dependencies in Node.js
    
      For Lambda functions that use the Node.js runtime, a dependency can be any Node.js module. The Node.js runtime includes a number of common 
      libraries, as well as a version of the AWS SDK for JavaScript. The nodejs16.x Lambda runtime includes version 2.x of the SDK. Runtime versions nodejs18.x and later include version 3 of the SDK. To use version 2 of the SDK with runtime versions nodejs18.x and later, add the SDK to your 
      .zip file deployment package. If your chosen runtime includes the version of the SDK you are using, you don't need to include the SDK library 
      in your .zip file. To find out which version of the SDK is included in the runtime you're using, see Runtime-included SDK versions.
    
    
      Lambda periodically updates the SDK libraries in the Node.js runtime to include the latest features and security upgrades. Lambda also applies 
      security patches and updates to the other libraries included in the runtime. To have full control of the dependencies in your package, you can 
      add your preferred version of any runtime-included dependency to your deployment package. For example, if you want to use a particular version of 
      the SDK for JavaScript, you can include it in your .zip file as a dependency. For more information on adding runtime-included dependencies to your .zip 
      file, see Dependency search path and runtime-included libraries.
    
    
      Under the AWS shared responsibility model, 
      you are responsible for the management of any dependencies in your functions' deployment packages. This includes applying updates and security 
      patches. To update dependencies in your function's deployment package, first create a new .zip file and then upload it to Lambda. See Creating a .zip deployment package with dependencies 
      and Creating and updating Node.js Lambda functions using .zip files for more information.
    
   
    Creating a .zip deployment package with no dependencies
    
      If your function code has no dependencies except for libraries included in the Lambda runtime, your .zip file contains only the index.js or 
      index.mjs file with your function’s handler code. Use your preferred zip utility to create a .zip file with your index.js or 
      index.mjs file at the root. If the file containing your handler code isn't at the root of your .zip file, Lambda won’t be able to run your code.
    
    
      To learn how to deploy your .zip file to create a new Lambda function or update an existing one, see Creating and updating Node.js Lambda functions using .zip files.
    
   
    Creating a .zip deployment package with dependencies
    If your function code depends on packages or modules that aren't included in the Lambda Node.js runtime,
      you can either add these dependencies to your .zip file with your function code or use a
      Lambda layer. The instructions in this section show you how to
      include your dependencies in your .zip deployment package. For instructions on how to include your
      dependencies in a layer, see Creating a Node.js layer for your dependencies.
    The following example CLI commands create a .zip file named my_deployment_package.zip containing the index.js 
      or index.mjs file with your function's handler code and its dependencies. In the example, you install dependencies using the 
      npm package manager.
    To create the deployment package
        Navigate to the project directory containing your index.js or index.mjs source code file. In this example, 
          the directory is named my_function.
        cd my_function
      
        Install your function's required libraries in the node_modules directory using the npm install command. In this 
          example you install the AWS X-Ray SDK for Node.js.
        npm install aws-xray-sdk
        This creates a folder structure similar to the following:
        ~/my_function
├── index.mjs
└── node_modules
    ├── async
    ├── async-listener
    ├── atomic-batcher
    ├── aws-sdk
    ├── aws-xray-sdk
    ├── aws-xray-sdk-core
        You can also add custom modules that you create yourself to your deployment package. Create a directory under node_modules 
          with the name of your module and save your custom written packages there.
      
        Create a .zip file that contains the contents of your project folder at the root. Use the r (recursive) option to 
          ensure that zip compresses the subfolders.
        zip -r my_deployment_package.zip .
      
   
    Creating a Node.js layer for your dependencies
    The instructions in this section show you how to include your dependencies in a layer. For instructions
      on how to include your dependencies in your deployment package, see
      Creating a .zip deployment package with dependencies.
    When you add a layer to a function, Lambda loads the layer content into the
      /opt directory of that execution environment. For each Lambda runtime,
      the PATH variable already includes specific folder paths within the
      /opt directory. To ensure that Lambda picks up your layer content, 
      your layer .zip file should have its dependencies
      in the following folder paths:
    
       
       
       
          
    
        nodejs/node_modules
      
        nodejs/node16/node_modules (NODE_PATH)
      
        nodejs/node18/node_modules (NODE_PATH)
      
        nodejs/node20/node_modules (NODE_PATH)
      
    For example, your layer .zip file structure might look like the following:
    xray-sdk.zip
└ nodejs/node_modules/aws-xray-sdk
    In addition, Lambda automatically detects any libraries in the /opt/lib
      directory, and any binaries in the /opt/bin directory. To ensure
      that Lambda properly finds your layer content, you can also create a layer
      with the following structure:
      custom-layer.zip
└ lib
    | lib_1
    | lib_2
└ bin
    | bin_1
    | bin_2
    After you package your layer, see Creating and deleting layers in Lambda
      and Adding layers to functions to complete your layer setup.
   
    Dependency search path and runtime-included libraries
    The Node.js runtime includes a number of common libraries, as well as a version of the AWS SDK for JavaScript. If you want to use a different version of a runtime-included library, you can do this by bundling it with your function or by adding it as a 
      dependency in your deployment package. For example, you can use a different version of the SDK by adding it to your .zip deployment package. 
      You can also include it in a Lambda layer for your function.
    When you use an import or require statement in your code, the Node.js runtime searches the directories in the NODE_PATH 
      path until it finds the module. By default, the first location the runtime searches is the directory into which your .zip deployment package is 
      decompressed and mounted (/var/task). If you include a version of a runtime-included library in your deployment package, this 
      version will take precedence over the version included in the runtime. Dependencies in your deployment package also have precedence over 
      dependencies in layers.
    When you add a dependency to a layer, Lambda extracts this to /opt/nodejs/nodexx/node_modules where nodexx 
      represents the version of the runtime you are using. In the search path, this directory has precedence over the directory containing the 
      runtime-included libraries (/var/lang/lib/node_modules). Libraries in function layers therefore have precedence over versions 
      included in the runtime.
    You can see the full search path for your Lambda function by adding the following line of code.
    console.log(process.env.NODE_PATH)
    You can also add dependencies in a separate folder inside your .zip package. For example, you might add a custom module to a folder in 
      your .zip package called common. When your .zip package is decompressed and mounted, this folder is placed inside the /var/task directory. 
      To use a dependency from a folder in your .zip deployment package in your code, use an import { } from or const { } = require() statement, 
      depending on whether you are using CJS or ESM module resolution. For example:
    import { myModule } from './common'
    If you bundle your code with esbuild, rollup, or similar, the dependencies used by your function are bundled together in one 
      or more files. We recommend using this method to vend dependencies whenever possible. Compared to adding dependencies to your deployment package, 
      bundling your code results in improved performance due to the reduction in I/O operations.
   
    Creating and updating Node.js Lambda functions using .zip files
    
      After you have created your .zip deployment package, you can use it to create a new Lambda function or update an existing one. You can deploy 
      your .zip package using the Lambda console, the AWS Command Line Interface, and the Lambda API. You can also create and update Lambda functions using 
      AWS Serverless Application Model (AWS SAM) and AWS CloudFormation.
    
    The maximum size for a .zip deployment package for Lambda is 250 MB (unzipped). Note that this limit applies to the combined size of all the files you upload, 
    including any Lambda layers.
    The Lambda runtime needs permission to read the files in your deployment package. In Linux permissions octal notation, Lambda needs 644 permissions 
      for non-executable files (rw-r--r--) and 755 permissions (rwxr-xr-x) for directories and executable files.
    In Linux and MacOS, use the chmod command to change file permissions on files and directories in your deployment package. For 
      example, to give a non-executable file the correct permissions, run the following command.
    chmod 644 <filepath>
    To change file permissions in Windows, see Set, View, Change, or Remove Permissions on an Object 
    in the Microsoft Windows documentation.
    NoteIf you don't grant Lambda the permissions it needs to access directories in your deployment package, Lambda sets the permissions for those directories to 755 (rwxr-xr-x).
     
      Creating and updating functions with .zip files using the console
      
      To create a new function, you must first create the function in the console, then upload your .zip archive. To update an existing function, open the page for your function, then follow the same procedure to add your updated .zip file.
    

      If your .zip file is less than 50MB, you can create or update a function by uploading the file directly from your local machine. For .zip files greater than 50MB, you must upload your package to an Amazon S3 bucket first. For instructions on how to upload a file to an Amazon S3 bucket using the AWS Management Console, see Getting started with Amazon S3. To upload files using the AWS CLI, see Move objects in the AWS CLI User Guide.
    
      NoteYou cannot change the deployment package type (.zip or container image) for an existing function. For example, you cannot convert a container image function to use a .zip file archive. You must create a new function.
  To create a new function (console)
      Open the Functions page of the Lambda console and choose Create Function.
    
      Choose Author from scratch.
    
      Under Basic information, do the following:
      
          For Function name, enter the name for your function.
          
              For Runtime, select the runtime you want to use.
            
              (Optional) For Architecture, choose the instruction set architecture for your function. The default architecture is x86_64. Ensure that the .zip deployment package for your function is compatible with the instruction set architecture you select.
            
    
      (Optional) Under Permissions, expand Change default execution role. You can create a new Execution role or use an existing one.
    
      Choose Create function. Lambda creates a basic 'Hello world' function using your chosen runtime.
    
  To upload a .zip archive from your local machine (console)
      In the Functions page of the Lambda console, choose the function you want to upload the .zip file for.
    
      Select the Code tab.
    
      In the Code source pane, choose Upload from.
    
      Choose .zip file.
    
      To upload the .zip file, do the following:
      
          Select Upload, then select your .zip file in the file chooser.
        
          Choose Open.
        
          Choose Save.
        
    
  
  To upload a .zip archive from an Amazon S3 bucket (console)
      In the Functions page of the Lambda console, choose the function you want to upload a new .zip file for.
    
      Select the Code tab.
    
      In the Code source pane, choose Upload from.
    
      Choose Amazon S3 location.
    
      Paste the Amazon S3 link URL of your .zip file and choose Save.
    
     
     
      Updating .zip file functions using the console code editor
      
     
    
      For some functions with .zip deployment packages, you can use the Lambda console’s built-in code editor to update your function code directly. To use this feature, your function must meet the following criteria:
    
    
       
       
    
        Your function must use one of the interpreted language runtimes (Python, Node.js, or Ruby)
      
        Your function’s deployment package must be smaller than 50 MB (unzipped).
      
    Function code for functions with container image deployment packages cannot be edited directly in the console.
    To update function code using the console code editor
        Open the Functions page of the Lambda console and select your function.
      
        Select the Code tab.
      
        In the Code source pane, select your source code file and edit it in the integrated code editor.
      
        In the DEPLOY section, choose Deploy to update your function's code:

   
    
   
   

      
     
      Creating and updating functions with .zip files using the AWS CLI
      
      You can can use the AWS CLI to create a new function or to update an existing one using a .zip file. Use the create-function 
      and update-function-code commands to deploy your .zip 
      package. If your .zip file is smaller than 50MB, you can upload the .zip package from a file location on your local build machine. For larger files, 
      you must upload your .zip package from an Amazon S3 bucket. For instructions on how to upload a file to an Amazon S3 bucket using the AWS CLI, see Move objects in the AWS CLI User Guide.
    
    NoteIf you upload your .zip file from an Amazon S3 bucket using the AWS CLI, the bucket must be located in the same AWS Region as your function.
    
      To create a new function using a .zip file with the AWS CLI, you must specify the following:
    
    
       
       
       
       
    
        The name of your function (--function-name)
      
        Your function’s runtime (--runtime)
      
        The Amazon Resource Name (ARN) of your function’s execution role (--role)
      
        The name of the handler method in your function code (--handler)
      
    
      You must also specify the location of your .zip file. If your .zip file is located in a folder on your local build machine, use the --zip-file option to specify the file path, as shown in the following example command.
    
    aws lambda create-function --function-name myFunction \
--runtime nodejs22.x --handler index.handler \
--role arn:aws:iam::111122223333:role/service-role/my-lambda-role \
--zip-file fileb://myFunction.zip
    
      To specify the location of .zip file in an Amazon S3 bucket, use the --code option as shown in the following example command. You only 
      need to use the S3ObjectVersion parameter for versioned objects.
    
    aws lambda create-function --function-name myFunction \
--runtime nodejs22.x --handler index.handler \
--role arn:aws:iam::111122223333:role/service-role/my-lambda-role \
--code S3Bucket=amzn-s3-demo-bucket,S3Key=myFileName.zip,S3ObjectVersion=myObjectVersion
    
      To update an existing function using the CLI, you specify the the name of your function using the --function-name parameter. You 
      must also specify the location of the .zip file you want to use to update your function code. If your .zip file is located in a folder on your 
      local build machine, use the --zip-file option to specify the file path, as shown in the following example command.
    
    aws lambda update-function-code --function-name myFunction \
--zip-file fileb://myFunction.zip
    
      To specify the location of .zip file in an Amazon S3 bucket, use the --s3-bucket and --s3-key options as shown in the 
      following example command. You only need to use the --s3-object-version parameter for versioned objects.
    
    aws lambda update-function-code --function-name myFunction \
--s3-bucket amzn-s3-demo-bucket --s3-key myFileName.zip --s3-object-version myObject Version
     
    
     
      Creating and updating functions with .zip files using the Lambda API
      
      To create and update functions using a .zip file archive, use the following API operations:
    

 
 

CreateFunction

UpdateFunctionCode

     
     
      Creating and updating functions with .zip files using AWS SAM
      
      The AWS Serverless Application Model (AWS SAM) is a toolkit that helps streamline the process of building and running serverless applications on AWS. You define the resources for your application in a 
      YAML or JSON template and use the AWS SAM command line interface (AWS SAM CLI) to build, package, and deploy your applications. When you build a Lambda function from an AWS SAM template, 
      AWS SAM automatically creates a .zip deployment package or container image with your function code and any dependencies you specify. To learn more about using AWS SAM to build and deploy 
      Lambda functions, see Getting started with AWS SAM in the
      AWS Serverless Application Model Developer Guide.

      You can also use AWS SAM to create a Lambda function using an existing .zip file archive. To create a Lambda function using AWS SAM, you can save your .zip file in 
      an Amazon S3 bucket or in a local folder on your build machine. For instructions on how to upload a file to an Amazon S3 bucket using the AWS CLI, 
      see Move objects in the AWS CLI User Guide.
    

      In your AWS SAM template, the AWS::Serverless::Function resource specifies your Lambda function. In this resource, set the following 
  properties to create a function using a .zip file archive:
    

 
 
 

PackageType - set to Zip

CodeUri - set to the  function code's Amazon S3 URI, path to local folder, or FunctionCode object

Runtime - Set to your chosen runtime


      With AWS SAM, if your .zip file is larger than 50MB, you don’t need to upload it to an Amazon S3 bucket first. AWS SAM can upload .zip packages up to 
      the maximum allowed size of 250MB (unzipped) from a location on your local build machine.
    

      To learn more about deploying functions using .zip file in AWS SAM, see AWS::Serverless::Function in the AWS SAM Developer Guide.
    
     
     
      Creating and updating functions with .zip files using AWS CloudFormation
      
      You can use AWS CloudFormation to create a Lambda function using a .zip file archive. To create a Lambda function from a .zip file, you must first upload 
      your file to an Amazon S3 bucket. For instructions on how to upload a file to an Amazon S3 bucket using the AWS CLI, see Move objects 
  in the AWS CLI User Guide. 
  In your AWS CloudFormation template, the AWS::Lambda::Function resource specifies your Lambda function. In this resource, set the following 
    properties to create a function using a .zip file archive:

 
 
 

PackageType - Set to Zip

Code - Enter the Amazon S3 bucket name and the .zip file name in the S3Bucket and S3Key fields

Runtime - Set to your chosen runtime


      The .zip file that AWS CloudFormation generates cannot exceed 4MB. To learn more about deploying functions using .zip file in AWS CloudFormation, see AWS::Lambda::Function 
  in the AWS CloudFormation User Guide.
    
     
  Document ConventionsHandlerDeploy container imagesDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideRuntime dependencies in Node.jsCreating a .zip deployment package with no dependenciesCreating a .zip deployment package with dependenciesCreating a Node.js layer for your dependenciesDependency search path and runtime-included librariesCreating and updating Node.js Lambda functions using .zip filesDeploy Node.js Lambda functions with .zip file archives
    Your AWS Lambda function’s code comprises a .js or .mjs file containing your function’s handler code, together with any additional packages and modules 
    your code depends on. To deploy this function code to Lambda, you use a deployment package. This package may either be a 
  .zip file archive or a container image.  
  For more information about using container images with Node.js, see Deploy Node.js Lambda functions with container images.
  
    To create your deployment package as .zip file archive, you can use your command-line tool’s built-in .zip file archive utility, or any other 
    .zip file utility such as 7zip. The examples shown in the following sections assume 
  you’re using a command-line zip tool in a Linux or MacOS environment. To use the same commands in Windows, you can 
  install the Windows Subsystem for Linux to get a Windows-integrated 
  version of Ubuntu and Bash.
  
    Note that Lambda uses POSIX file permissions, so you may need to set permissions for the deployment package folder before you create the .zip file archive.
  TopicsRuntime dependencies in Node.jsCreating a .zip deployment package with no dependenciesCreating a .zip deployment package with dependenciesCreating a Node.js layer for your dependenciesDependency search path and runtime-included librariesCreating and updating Node.js Lambda functions using .zip files
    Runtime dependencies in Node.js
    
      For Lambda functions that use the Node.js runtime, a dependency can be any Node.js module. The Node.js runtime includes a number of common 
      libraries, as well as a version of the AWS SDK for JavaScript. The nodejs16.x Lambda runtime includes version 2.x of the SDK. Runtime versions nodejs18.x and later include version 3 of the SDK. To use version 2 of the SDK with runtime versions nodejs18.x and later, add the SDK to your 
      .zip file deployment package. If your chosen runtime includes the version of the SDK you are using, you don't need to include the SDK library 
      in your .zip file. To find out which version of the SDK is included in the runtime you're using, see Runtime-included SDK versions.
    
    
      Lambda periodically updates the SDK libraries in the Node.js runtime to include the latest features and security upgrades. Lambda also applies 
      security patches and updates to the other libraries included in the runtime. To have full control of the dependencies in your package, you can 
      add your preferred version of any runtime-included dependency to your deployment package. For example, if you want to use a particular version of 
      the SDK for JavaScript, you can include it in your .zip file as a dependency. For more information on adding runtime-included dependencies to your .zip 
      file, see Dependency search path and runtime-included libraries.
    
    
      Under the AWS shared responsibility model, 
      you are responsible for the management of any dependencies in your functions' deployment packages. This includes applying updates and security 
      patches. To update dependencies in your function's deployment package, first create a new .zip file and then upload it to Lambda. See Creating a .zip deployment package with dependencies 
      and Creating and updating Node.js Lambda functions using .zip files for more information.
    
   
    Creating a .zip deployment package with no dependencies
    
      If your function code has no dependencies except for libraries included in the Lambda runtime, your .zip file contains only the index.js or 
      index.mjs file with your function’s handler code. Use your preferred zip utility to create a .zip file with your index.js or 
      index.mjs file at the root. If the file containing your handler code isn't at the root of your .zip file, Lambda won’t be able to run your code.
    
    
      To learn how to deploy your .zip file to create a new Lambda function or update an existing one, see Creating and updating Node.js Lambda functions using .zip files.
    
   
    Creating a .zip deployment package with dependencies
    If your function code depends on packages or modules that aren't included in the Lambda Node.js runtime,
      you can either add these dependencies to your .zip file with your function code or use a
      Lambda layer. The instructions in this section show you how to
      include your dependencies in your .zip deployment package. For instructions on how to include your
      dependencies in a layer, see Creating a Node.js layer for your dependencies.
    The following example CLI commands create a .zip file named my_deployment_package.zip containing the index.js 
      or index.mjs file with your function's handler code and its dependencies. In the example, you install dependencies using the 
      npm package manager.
    To create the deployment package
        Navigate to the project directory containing your index.js or index.mjs source code file. In this example, 
          the directory is named my_function.
        cd my_function
      
        Install your function's required libraries in the node_modules directory using the npm install command. In this 
          example you install the AWS X-Ray SDK for Node.js.
        npm install aws-xray-sdk
        This creates a folder structure similar to the following:
        ~/my_function
├── index.mjs
└── node_modules
    ├── async
    ├── async-listener
    ├── atomic-batcher
    ├── aws-sdk
    ├── aws-xray-sdk
    ├── aws-xray-sdk-core
        You can also add custom modules that you create yourself to your deployment package. Create a directory under node_modules 
          with the name of your module and save your custom written packages there.
      
        Create a .zip file that contains the contents of your project folder at the root. Use the r (recursive) option to 
          ensure that zip compresses the subfolders.
        zip -r my_deployment_package.zip .
      
   
    Creating a Node.js layer for your dependencies
    The instructions in this section show you how to include your dependencies in a layer. For instructions
      on how to include your dependencies in your deployment package, see
      Creating a .zip deployment package with dependencies.
    When you add a layer to a function, Lambda loads the layer content into the
      /opt directory of that execution environment. For each Lambda runtime,
      the PATH variable already includes specific folder paths within the
      /opt directory. To ensure that Lambda picks up your layer content, 
      your layer .zip file should have its dependencies
      in the following folder paths:
    
       
       
       
          
    
        nodejs/node_modules
      
        nodejs/node16/node_modules (NODE_PATH)
      
        nodejs/node18/node_modules (NODE_PATH)
      
        nodejs/node20/node_modules (NODE_PATH)
      
    For example, your layer .zip file structure might look like the following:
    xray-sdk.zip
└ nodejs/node_modules/aws-xray-sdk
    In addition, Lambda automatically detects any libraries in the /opt/lib
      directory, and any binaries in the /opt/bin directory. To ensure
      that Lambda properly finds your layer content, you can also create a layer
      with the following structure:
      custom-layer.zip
└ lib
    | lib_1
    | lib_2
└ bin
    | bin_1
    | bin_2
    After you package your layer, see Creating and deleting layers in Lambda
      and Adding layers to functions to complete your layer setup.
   
    Dependency search path and runtime-included libraries
    The Node.js runtime includes a number of common libraries, as well as a version of the AWS SDK for JavaScript. If you want to use a different version of a runtime-included library, you can do this by bundling it with your function or by adding it as a 
      dependency in your deployment package. For example, you can use a different version of the SDK by adding it to your .zip deployment package. 
      You can also include it in a Lambda layer for your function.
    When you use an import or require statement in your code, the Node.js runtime searches the directories in the NODE_PATH 
      path until it finds the module. By default, the first location the runtime searches is the directory into which your .zip deployment package is 
      decompressed and mounted (/var/task). If you include a version of a runtime-included library in your deployment package, this 
      version will take precedence over the version included in the runtime. Dependencies in your deployment package also have precedence over 
      dependencies in layers.
    When you add a dependency to a layer, Lambda extracts this to /opt/nodejs/nodexx/node_modules where nodexx 
      represents the version of the runtime you are using. In the search path, this directory has precedence over the directory containing the 
      runtime-included libraries (/var/lang/lib/node_modules). Libraries in function layers therefore have precedence over versions 
      included in the runtime.
    You can see the full search path for your Lambda function by adding the following line of code.
    console.log(process.env.NODE_PATH)
    You can also add dependencies in a separate folder inside your .zip package. For example, you might add a custom module to a folder in 
      your .zip package called common. When your .zip package is decompressed and mounted, this folder is placed inside the /var/task directory. 
      To use a dependency from a folder in your .zip deployment package in your code, use an import { } from or const { } = require() statement, 
      depending on whether you are using CJS or ESM module resolution. For example:
    import { myModule } from './common'
    If you bundle your code with esbuild, rollup, or similar, the dependencies used by your function are bundled together in one 
      or more files. We recommend using this method to vend dependencies whenever possible. Compared to adding dependencies to your deployment package, 
      bundling your code results in improved performance due to the reduction in I/O operations.
   
    Creating and updating Node.js Lambda functions using .zip files
    
      After you have created your .zip deployment package, you can use it to create a new Lambda function or update an existing one. You can deploy 
      your .zip package using the Lambda console, the AWS Command Line Interface, and the Lambda API. You can also create and update Lambda functions using 
      AWS Serverless Application Model (AWS SAM) and AWS CloudFormation.
    
    The maximum size for a .zip deployment package for Lambda is 250 MB (unzipped). Note that this limit applies to the combined size of all the files you upload, 
    including any Lambda layers.
    The Lambda runtime needs permission to read the files in your deployment package. In Linux permissions octal notation, Lambda needs 644 permissions 
      for non-executable files (rw-r--r--) and 755 permissions (rwxr-xr-x) for directories and executable files.
    In Linux and MacOS, use the chmod command to change file permissions on files and directories in your deployment package. For 
      example, to give a non-executable file the correct permissions, run the following command.
    chmod 644 <filepath>
    To change file permissions in Windows, see Set, View, Change, or Remove Permissions on an Object 
    in the Microsoft Windows documentation.
    NoteIf you don't grant Lambda the permissions it needs to access directories in your deployment package, Lambda sets the permissions for those directories to 755 (rwxr-xr-x).
     
      Creating and updating functions with .zip files using the console
      
      To create a new function, you must first create the function in the console, then upload your .zip archive. To update an existing function, open the page for your function, then follow the same procedure to add your updated .zip file.
    

      If your .zip file is less than 50MB, you can create or update a function by uploading the file directly from your local machine. For .zip files greater than 50MB, you must upload your package to an Amazon S3 bucket first. For instructions on how to upload a file to an Amazon S3 bucket using the AWS Management Console, see Getting started with Amazon S3. To upload files using the AWS CLI, see Move objects in the AWS CLI User Guide.
    
      NoteYou cannot change the deployment package type (.zip or container image) for an existing function. For example, you cannot convert a container image function to use a .zip file archive. You must create a new function.
  To create a new function (console)
      Open the Functions page of the Lambda console and choose Create Function.
    
      Choose Author from scratch.
    
      Under Basic information, do the following:
      
          For Function name, enter the name for your function.
          
              For Runtime, select the runtime you want to use.
            
              (Optional) For Architecture, choose the instruction set architecture for your function. The default architecture is x86_64. Ensure that the .zip deployment package for your function is compatible with the instruction set architecture you select.
            
    
      (Optional) Under Permissions, expand Change default execution role. You can create a new Execution role or use an existing one.
    
      Choose Create function. Lambda creates a basic 'Hello world' function using your chosen runtime.
    
  To upload a .zip archive from your local machine (console)
      In the Functions page of the Lambda console, choose the function you want to upload the .zip file for.
    
      Select the Code tab.
    
      In the Code source pane, choose Upload from.
    
      Choose .zip file.
    
      To upload the .zip file, do the following:
      
          Select Upload, then select your .zip file in the file chooser.
        
          Choose Open.
        
          Choose Save.
        
    
  
  To upload a .zip archive from an Amazon S3 bucket (console)
      In the Functions page of the Lambda console, choose the function you want to upload a new .zip file for.
    
      Select the Code tab.
    
      In the Code source pane, choose Upload from.
    
      Choose Amazon S3 location.
    
      Paste the Amazon S3 link URL of your .zip file and choose Save.
    
     
     
      Updating .zip file functions using the console code editor
      
     
    
      For some functions with .zip deployment packages, you can use the Lambda console’s built-in code editor to update your function code directly. To use this feature, your function must meet the following criteria:
    
    
       
       
    
        Your function must use one of the interpreted language runtimes (Python, Node.js, or Ruby)
      
        Your function’s deployment package must be smaller than 50 MB (unzipped).
      
    Function code for functions with container image deployment packages cannot be edited directly in the console.
    To update function code using the console code editor
        Open the Functions page of the Lambda console and select your function.
      
        Select the Code tab.
      
        In the Code source pane, select your source code file and edit it in the integrated code editor.
      
        In the DEPLOY section, choose Deploy to update your function's code:

   
    
   
   

      
     
      Creating and updating functions with .zip files using the AWS CLI
      
      You can can use the AWS CLI to create a new function or to update an existing one using a .zip file. Use the create-function 
      and update-function-code commands to deploy your .zip 
      package. If your .zip file is smaller than 50MB, you can upload the .zip package from a file location on your local build machine. For larger files, 
      you must upload your .zip package from an Amazon S3 bucket. For instructions on how to upload a file to an Amazon S3 bucket using the AWS CLI, see Move objects in the AWS CLI User Guide.
    
    NoteIf you upload your .zip file from an Amazon S3 bucket using the AWS CLI, the bucket must be located in the same AWS Region as your function.
    
      To create a new function using a .zip file with the AWS CLI, you must specify the following:
    
    
       
       
       
       
    
        The name of your function (--function-name)
      
        Your function’s runtime (--runtime)
      
        The Amazon Resource Name (ARN) of your function’s execution role (--role)
      
        The name of the handler method in your function code (--handler)
      
    
      You must also specify the location of your .zip file. If your .zip file is located in a folder on your local build machine, use the --zip-file option to specify the file path, as shown in the following example command.
    
    aws lambda create-function --function-name myFunction \
--runtime nodejs22.x --handler index.handler \
--role arn:aws:iam::111122223333:role/service-role/my-lambda-role \
--zip-file fileb://myFunction.zip
    
      To specify the location of .zip file in an Amazon S3 bucket, use the --code option as shown in the following example command. You only 
      need to use the S3ObjectVersion parameter for versioned objects.
    
    aws lambda create-function --function-name myFunction \
--runtime nodejs22.x --handler index.handler \
--role arn:aws:iam::111122223333:role/service-role/my-lambda-role \
--code S3Bucket=amzn-s3-demo-bucket,S3Key=myFileName.zip,S3ObjectVersion=myObjectVersion
    
      To update an existing function using the CLI, you specify the the name of your function using the --function-name parameter. You 
      must also specify the location of the .zip file you want to use to update your function code. If your .zip file is located in a folder on your 
      local build machine, use the --zip-file option to specify the file path, as shown in the following example command.
    
    aws lambda update-function-code --function-name myFunction \
--zip-file fileb://myFunction.zip
    
      To specify the location of .zip file in an Amazon S3 bucket, use the --s3-bucket and --s3-key options as shown in the 
      following example command. You only need to use the --s3-object-version parameter for versioned objects.
    
    aws lambda update-function-code --function-name myFunction \
--s3-bucket amzn-s3-demo-bucket --s3-key myFileName.zip --s3-object-version myObject Version
     
    
     
      Creating and updating functions with .zip files using the Lambda API
      
      To create and update functions using a .zip file archive, use the following API operations:
    

 
 

CreateFunction

UpdateFunctionCode

     
     
      Creating and updating functions with .zip files using AWS SAM
      
      The AWS Serverless Application Model (AWS SAM) is a toolkit that helps streamline the process of building and running serverless applications on AWS. You define the resources for your application in a 
      YAML or JSON template and use the AWS SAM command line interface (AWS SAM CLI) to build, package, and deploy your applications. When you build a Lambda function from an AWS SAM template, 
      AWS SAM automatically creates a .zip deployment package or container image with your function code and any dependencies you specify. To learn more about using AWS SAM to build and deploy 
      Lambda functions, see Getting started with AWS SAM in the
      AWS Serverless Application Model Developer Guide.

      You can also use AWS SAM to create a Lambda function using an existing .zip file archive. To create a Lambda function using AWS SAM, you can save your .zip file in 
      an Amazon S3 bucket or in a local folder on your build machine. For instructions on how to upload a file to an Amazon S3 bucket using the AWS CLI, 
      see Move objects in the AWS CLI User Guide.
    

      In your AWS SAM template, the AWS::Serverless::Function resource specifies your Lambda function. In this resource, set the following 
  properties to create a function using a .zip file archive:
    

 
 
 

PackageType - set to Zip

CodeUri - set to the  function code's Amazon S3 URI, path to local folder, or FunctionCode object

Runtime - Set to your chosen runtime


      With AWS SAM, if your .zip file is larger than 50MB, you don’t need to upload it to an Amazon S3 bucket first. AWS SAM can upload .zip packages up to 
      the maximum allowed size of 250MB (unzipped) from a location on your local build machine.
    

      To learn more about deploying functions using .zip file in AWS SAM, see AWS::Serverless::Function in the AWS SAM Developer Guide.
    
     
     
      Creating and updating functions with .zip files using AWS CloudFormation
      
      You can use AWS CloudFormation to create a Lambda function using a .zip file archive. To create a Lambda function from a .zip file, you must first upload 
      your file to an Amazon S3 bucket. For instructions on how to upload a file to an Amazon S3 bucket using the AWS CLI, see Move objects 
  in the AWS CLI User Guide. 
  In your AWS CloudFormation template, the AWS::Lambda::Function resource specifies your Lambda function. In this resource, set the following 
    properties to create a function using a .zip file archive:

 
 
 

PackageType - Set to Zip

Code - Enter the Amazon S3 bucket name and the .zip file name in the S3Bucket and S3Key fields

Runtime - Set to your chosen runtime


      The .zip file that AWS CloudFormation generates cannot exceed 4MB. To learn more about deploying functions using .zip file in AWS CloudFormation, see AWS::Lambda::Function 
  in the AWS CloudFormation User Guide.
    
     
  Document ConventionsHandlerDeploy container imagesDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideRuntime dependencies in Node.jsCreating a .zip deployment package with no dependenciesCreating a .zip deployment package with dependenciesCreating a Node.js layer for your dependenciesDependency search path and runtime-included librariesCreating and updating Node.js Lambda functions using .zip filesDeploy Node.js Lambda functions with .zip file archives
    Your AWS Lambda function’s code comprises a .js or .mjs file containing your function’s handler code, together with any additional packages and modules 
    your code depends on. To deploy this function code to Lambda, you use a deployment package. This package may either be a 
  .zip file archive or a container image.  
  For more information about using container images with Node.js, see Deploy Node.js Lambda functions with container images.
  
    To create your deployment package as .zip file archive, you can use your command-line tool’s built-in .zip file archive utility, or any other 
    .zip file utility such as 7zip. The examples shown in the following sections assume 
  you’re using a command-line zip tool in a Linux or MacOS environment. To use the same commands in Windows, you can 
  install the Windows Subsystem for Linux to get a Windows-integrated 
  version of Ubuntu and Bash.
  
    Note that Lambda uses POSIX file permissions, so you may need to set permissions for the deployment package folder before you create the .zip file archive.
  TopicsRuntime dependencies in Node.jsCreating a .zip deployment package with no dependenciesCreating a .zip deployment package with dependenciesCreating a Node.js layer for your dependenciesDependency search path and runtime-included librariesCreating and updating Node.js Lambda functions using .zip files
    Runtime dependencies in Node.js
    
      For Lambda functions that use the Node.js runtime, a dependency can be any Node.js module. The Node.js runtime includes a number of common 
      libraries, as well as a version of the AWS SDK for JavaScript. The nodejs16.x Lambda runtime includes version 2.x of the SDK. Runtime versions nodejs18.x and later include version 3 of the SDK. To use version 2 of the SDK with runtime versions nodejs18.x and later, add the SDK to your 
      .zip file deployment package. If your chosen runtime includes the version of the SDK you are using, you don't need to include the SDK library 
      in your .zip file. To find out which version of the SDK is included in the runtime you're using, see Runtime-included SDK versions.
    
    
      Lambda periodically updates the SDK libraries in the Node.js runtime to include the latest features and security upgrades. Lambda also applies 
      security patches and updates to the other libraries included in the runtime. To have full control of the dependencies in your package, you can 
      add your preferred version of any runtime-included dependency to your deployment package. For example, if you want to use a particular version of 
      the SDK for JavaScript, you can include it in your .zip file as a dependency. For more information on adding runtime-included dependencies to your .zip 
      file, see Dependency search path and runtime-included libraries.
    
    
      Under the AWS shared responsibility model, 
      you are responsible for the management of any dependencies in your functions' deployment packages. This includes applying updates and security 
      patches. To update dependencies in your function's deployment package, first create a new .zip file and then upload it to Lambda. See Creating a .zip deployment package with dependencies 
      and Creating and updating Node.js Lambda functions using .zip files for more information.
    
   
    Creating a .zip deployment package with no dependencies
    
      If your function code has no dependencies except for libraries included in the Lambda runtime, your .zip file contains only the index.js or 
      index.mjs file with your function’s handler code. Use your preferred zip utility to create a .zip file with your index.js or 
      index.mjs file at the root. If the file containing your handler code isn't at the root of your .zip file, Lambda won’t be able to run your code.
    
    
      To learn how to deploy your .zip file to create a new Lambda function or update an existing one, see Creating and updating Node.js Lambda functions using .zip files.
    
   
    Creating a .zip deployment package with dependencies
    If your function code depends on packages or modules that aren't included in the Lambda Node.js runtime,
      you can either add these dependencies to your .zip file with your function code or use a
      Lambda layer. The instructions in this section show you how to
      include your dependencies in your .zip deployment package. For instructions on how to include your
      dependencies in a layer, see Creating a Node.js layer for your dependencies.
    The following example CLI commands create a .zip file named my_deployment_package.zip containing the index.js 
      or index.mjs file with your function's handler code and its dependencies. In the example, you install dependencies using the 
      npm package manager.
    To create the deployment package
        Navigate to the project directory containing your index.js or index.mjs source code file. In this example, 
          the directory is named my_function.
        cd my_function
      
        Install your function's required libraries in the node_modules directory using the npm install command. In this 
          example you install the AWS X-Ray SDK for Node.js.
        npm install aws-xray-sdk
        This creates a folder structure similar to the following:
        ~/my_function
├── index.mjs
└── node_modules
    ├── async
    ├── async-listener
    ├── atomic-batcher
    ├── aws-sdk
    ├── aws-xray-sdk
    ├── aws-xray-sdk-core
        You can also add custom modules that you create yourself to your deployment package. Create a directory under node_modules 
          with the name of your module and save your custom written packages there.
      
        Create a .zip file that contains the contents of your project folder at the root. Use the r (recursive) option to 
          ensure that zip compresses the subfolders.
        zip -r my_deployment_package.zip .
      
   
    Creating a Node.js layer for your dependencies
    The instructions in this section show you how to include your dependencies in a layer. For instructions
      on how to include your dependencies in your deployment package, see
      Creating a .zip deployment package with dependencies.
    When you add a layer to a function, Lambda loads the layer content into the
      /opt directory of that execution environment. For each Lambda runtime,
      the PATH variable already includes specific folder paths within the
      /opt directory. To ensure that Lambda picks up your layer content, 
      your layer .zip file should have its dependencies
      in the following folder paths:
    
       
       
       
          
    
        nodejs/node_modules
      
        nodejs/node16/node_modules (NODE_PATH)
      
        nodejs/node18/node_modules (NODE_PATH)
      
        nodejs/node20/node_modules (NODE_PATH)
      
    For example, your layer .zip file structure might look like the following:
    xray-sdk.zip
└ nodejs/node_modules/aws-xray-sdk
    In addition, Lambda automatically detects any libraries in the /opt/lib
      directory, and any binaries in the /opt/bin directory. To ensure
      that Lambda properly finds your layer content, you can also create a layer
      with the following structure:
      custom-layer.zip
└ lib
    | lib_1
    | lib_2
└ bin
    | bin_1
    | bin_2
    After you package your layer, see Creating and deleting layers in Lambda
      and Adding layers to functions to complete your layer setup.
   
    Dependency search path and runtime-included libraries
    The Node.js runtime includes a number of common libraries, as well as a version of the AWS SDK for JavaScript. If you want to use a different version of a runtime-included library, you can do this by bundling it with your function or by adding it as a 
      dependency in your deployment package. For example, you can use a different version of the SDK by adding it to your .zip deployment package. 
      You can also include it in a Lambda layer for your function.
    When you use an import or require statement in your code, the Node.js runtime searches the directories in the NODE_PATH 
      path until it finds the module. By default, the first location the runtime searches is the directory into which your .zip deployment package is 
      decompressed and mounted (/var/task). If you include a version of a runtime-included library in your deployment package, this 
      version will take precedence over the version included in the runtime. Dependencies in your deployment package also have precedence over 
      dependencies in layers.
    When you add a dependency to a layer, Lambda extracts this to /opt/nodejs/nodexx/node_modules where nodexx 
      represents the version of the runtime you are using. In the search path, this directory has precedence over the directory containing the 
      runtime-included libraries (/var/lang/lib/node_modules). Libraries in function layers therefore have precedence over versions 
      included in the runtime.
    You can see the full search path for your Lambda function by adding the following line of code.
    console.log(process.env.NODE_PATH)
    You can also add dependencies in a separate folder inside your .zip package. For example, you might add a custom module to a folder in 
      your .zip package called common. When your .zip package is decompressed and mounted, this folder is placed inside the /var/task directory. 
      To use a dependency from a folder in your .zip deployment package in your code, use an import { } from or const { } = require() statement, 
      depending on whether you are using CJS or ESM module resolution. For example:
    import { myModule } from './common'
    If you bundle your code with esbuild, rollup, or similar, the dependencies used by your function are bundled together in one 
      or more files. We recommend using this method to vend dependencies whenever possible. Compared to adding dependencies to your deployment package, 
      bundling your code results in improved performance due to the reduction in I/O operations.
   
    Creating and updating Node.js Lambda functions using .zip files
    
      After you have created your .zip deployment package, you can use it to create a new Lambda function or update an existing one. You can deploy 
      your .zip package using the Lambda console, the AWS Command Line Interface, and the Lambda API. You can also create and update Lambda functions using 
      AWS Serverless Application Model (AWS SAM) and AWS CloudFormation.
    
    The maximum size for a .zip deployment package for Lambda is 250 MB (unzipped). Note that this limit applies to the combined size of all the files you upload, 
    including any Lambda layers.
    The Lambda runtime needs permission to read the files in your deployment package. In Linux permissions octal notation, Lambda needs 644 permissions 
      for non-executable files (rw-r--r--) and 755 permissions (rwxr-xr-x) for directories and executable files.
    In Linux and MacOS, use the chmod command to change file permissions on files and directories in your deployment package. For 
      example, to give a non-executable file the correct permissions, run the following command.
    chmod 644 <filepath>
    To change file permissions in Windows, see Set, View, Change, or Remove Permissions on an Object 
    in the Microsoft Windows documentation.
    NoteIf you don't grant Lambda the permissions it needs to access directories in your deployment package, Lambda sets the permissions for those directories to 755 (rwxr-xr-x).
     
      Creating and updating functions with .zip files using the console
      
      To create a new function, you must first create the function in the console, then upload your .zip archive. To update an existing function, open the page for your function, then follow the same procedure to add your updated .zip file.
    

      If your .zip file is less than 50MB, you can create or update a function by uploading the file directly from your local machine. For .zip files greater than 50MB, you must upload your package to an Amazon S3 bucket first. For instructions on how to upload a file to an Amazon S3 bucket using the AWS Management Console, see Getting started with Amazon S3. To upload files using the AWS CLI, see Move objects in the AWS CLI User Guide.
    
      NoteYou cannot change the deployment package type (.zip or container image) for an existing function. For example, you cannot convert a container image function to use a .zip file archive. You must create a new function.
  To create a new function (console)
      Open the Functions page of the Lambda console and choose Create Function.
    
      Choose Author from scratch.
    
      Under Basic information, do the following:
      
          For Function name, enter the name for your function.
          
              For Runtime, select the runtime you want to use.
            
              (Optional) For Architecture, choose the instruction set architecture for your function. The default architecture is x86_64. Ensure that the .zip deployment package for your function is compatible with the instruction set architecture you select.
            
    
      (Optional) Under Permissions, expand Change default execution role. You can create a new Execution role or use an existing one.
    
      Choose Create function. Lambda creates a basic 'Hello world' function using your chosen runtime.
    
  To upload a .zip archive from your local machine (console)
      In the Functions page of the Lambda console, choose the function you want to upload the .zip file for.
    
      Select the Code tab.
    
      In the Code source pane, choose Upload from.
    
      Choose .zip file.
    
      To upload the .zip file, do the following:
      
          Select Upload, then select your .zip file in the file chooser.
        
          Choose Open.
        
          Choose Save.
        
    
  
  To upload a .zip archive from an Amazon S3 bucket (console)
      In the Functions page of the Lambda console, choose the function you want to upload a new .zip file for.
    
      Select the Code tab.
    
      In the Code source pane, choose Upload from.
    
      Choose Amazon S3 location.
    
      Paste the Amazon S3 link URL of your .zip file and choose Save.
    
     
     
      Updating .zip file functions using the console code editor
      
     
    
      For some functions with .zip deployment packages, you can use the Lambda console’s built-in code editor to update your function code directly. To use this feature, your function must meet the following criteria:
    
    
       
       
    
        Your function must use one of the interpreted language runtimes (Python, Node.js, or Ruby)
      
        Your function’s deployment package must be smaller than 50 MB (unzipped).
      
    Function code for functions with container image deployment packages cannot be edited directly in the console.
    To update function code using the console code editor
        Open the Functions page of the Lambda console and select your function.
      
        Select the Code tab.
      
        In the Code source pane, select your source code file and edit it in the integrated code editor.
      
        In the DEPLOY section, choose Deploy to update your function's code:

   
    
   
   

      
     
      Creating and updating functions with .zip files using the AWS CLI
      
      You can can use the AWS CLI to create a new function or to update an existing one using a .zip file. Use the create-function 
      and update-function-code commands to deploy your .zip 
      package. If your .zip file is smaller than 50MB, you can upload the .zip package from a file location on your local build machine. For larger files, 
      you must upload your .zip package from an Amazon S3 bucket. For instructions on how to upload a file to an Amazon S3 bucket using the AWS CLI, see Move objects in the AWS CLI User Guide.
    
    NoteIf you upload your .zip file from an Amazon S3 bucket using the AWS CLI, the bucket must be located in the same AWS Region as your function.
    
      To create a new function using a .zip file with the AWS CLI, you must specify the following:
    
    
       
       
       
       
    
        The name of your function (--function-name)
      
        Your function’s runtime (--runtime)
      
        The Amazon Resource Name (ARN) of your function’s execution role (--role)
      
        The name of the handler method in your function code (--handler)
      
    
      You must also specify the location of your .zip file. If your .zip file is located in a folder on your local build machine, use the --zip-file option to specify the file path, as shown in the following example command.
    
    aws lambda create-function --function-name myFunction \
--runtime nodejs22.x --handler index.handler \
--role arn:aws:iam::111122223333:role/service-role/my-lambda-role \
--zip-file fileb://myFunction.zip
    
      To specify the location of .zip file in an Amazon S3 bucket, use the --code option as shown in the following example command. You only 
      need to use the S3ObjectVersion parameter for versioned objects.
    
    aws lambda create-function --function-name myFunction \
--runtime nodejs22.x --handler index.handler \
--role arn:aws:iam::111122223333:role/service-role/my-lambda-role \
--code S3Bucket=amzn-s3-demo-bucket,S3Key=myFileName.zip,S3ObjectVersion=myObjectVersion
    
      To update an existing function using the CLI, you specify the the name of your function using the --function-name parameter. You 
      must also specify the location of the .zip file you want to use to update your function code. If your .zip file is located in a folder on your 
      local build machine, use the --zip-file option to specify the file path, as shown in the following example command.
    
    aws lambda update-function-code --function-name myFunction \
--zip-file fileb://myFunction.zip
    
      To specify the location of .zip file in an Amazon S3 bucket, use the --s3-bucket and --s3-key options as shown in the 
      following example command. You only need to use the --s3-object-version parameter for versioned objects.
    
    aws lambda update-function-code --function-name myFunction \
--s3-bucket amzn-s3-demo-bucket --s3-key myFileName.zip --s3-object-version myObject Version
     
    
     
      Creating and updating functions with .zip files using the Lambda API
      
      To create and update functions using a .zip file archive, use the following API operations:
    

 
 

CreateFunction

UpdateFunctionCode

     
     
      Creating and updating functions with .zip files using AWS SAM
      
      The AWS Serverless Application Model (AWS SAM) is a toolkit that helps streamline the process of building and running serverless applications on AWS. You define the resources for your application in a 
      YAML or JSON template and use the AWS SAM command line interface (AWS SAM CLI) to build, package, and deploy your applications. When you build a Lambda function from an AWS SAM template, 
      AWS SAM automatically creates a .zip deployment package or container image with your function code and any dependencies you specify. To learn more about using AWS SAM to build and deploy 
      Lambda functions, see Getting started with AWS SAM in the
      AWS Serverless Application Model Developer Guide.

      You can also use AWS SAM to create a Lambda function using an existing .zip file archive. To create a Lambda function using AWS SAM, you can save your .zip file in 
      an Amazon S3 bucket or in a local folder on your build machine. For instructions on how to upload a file to an Amazon S3 bucket using the AWS CLI, 
      see Move objects in the AWS CLI User Guide.
    

      In your AWS SAM template, the AWS::Serverless::Function resource specifies your Lambda function. In this resource, set the following 
  properties to create a function using a .zip file archive:
    

 
 
 

PackageType - set to Zip

CodeUri - set to the  function code's Amazon S3 URI, path to local folder, or FunctionCode object

Runtime - Set to your chosen runtime


      With AWS SAM, if your .zip file is larger than 50MB, you don’t need to upload it to an Amazon S3 bucket first. AWS SAM can upload .zip packages up to 
      the maximum allowed size of 250MB (unzipped) from a location on your local build machine.
    

      To learn more about deploying functions using .zip file in AWS SAM, see AWS::Serverless::Function in the AWS SAM Developer Guide.
    
     
     
      Creating and updating functions with .zip files using AWS CloudFormation
      
      You can use AWS CloudFormation to create a Lambda function using a .zip file archive. To create a Lambda function from a .zip file, you must first upload 
      your file to an Amazon S3 bucket. For instructions on how to upload a file to an Amazon S3 bucket using the AWS CLI, see Move objects 
  in the AWS CLI User Guide. 
  In your AWS CloudFormation template, the AWS::Lambda::Function resource specifies your Lambda function. In this resource, set the following 
    properties to create a function using a .zip file archive:

 
 
 

PackageType - Set to Zip

Code - Enter the Amazon S3 bucket name and the .zip file name in the S3Bucket and S3Key fields

Runtime - Set to your chosen runtime


      The .zip file that AWS CloudFormation generates cannot exceed 4MB. To learn more about deploying functions using .zip file in AWS CloudFormation, see AWS::Lambda::Function 
  in the AWS CloudFormation User Guide.
    
     
  Document ConventionsHandlerDeploy container imagesDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideRuntime dependencies in Node.jsCreating a .zip deployment package with no dependenciesCreating a .zip deployment package with dependenciesCreating a Node.js layer for your dependenciesDependency search path and runtime-included librariesCreating and updating Node.js Lambda functions using .zip filesDeploy Node.js Lambda functions with .zip file archives
    Your AWS Lambda function’s code comprises a .js or .mjs file containing your function’s handler code, together with any additional packages and modules 
    your code depends on. To deploy this function code to Lambda, you use a deployment package. This package may either be a 
  .zip file archive or a container image.  
  For more information about using container images with Node.js, see Deploy Node.js Lambda functions with container images.
  
    To create your deployment package as .zip file archive, you can use your command-line tool’s built-in .zip file archive utility, or any other 
    .zip file utility such as 7zip. The examples shown in the following sections assume 
  you’re using a command-line zip tool in a Linux or MacOS environment. To use the same commands in Windows, you can 
  install the Windows Subsystem for Linux to get a Windows-integrated 
  version of Ubuntu and Bash.
  
    Note that Lambda uses POSIX file permissions, so you may need to set permissions for the deployment package folder before you create the .zip file archive.
  TopicsRuntime dependencies in Node.jsCreating a .zip deployment package with no dependenciesCreating a .zip deployment package with dependenciesCreating a Node.js layer for your dependenciesDependency search path and runtime-included librariesCreating and updating Node.js Lambda functions using .zip files
    Runtime dependencies in Node.js
    
      For Lambda functions that use the Node.js runtime, a dependency can be any Node.js module. The Node.js runtime includes a number of common 
      libraries, as well as a version of the AWS SDK for JavaScript. The nodejs16.x Lambda runtime includes version 2.x of the SDK. Runtime versions nodejs18.x and later include version 3 of the SDK. To use version 2 of the SDK with runtime versions nodejs18.x and later, add the SDK to your 
      .zip file deployment package. If your chosen runtime includes the version of the SDK you are using, you don't need to include the SDK library 
      in your .zip file. To find out which version of the SDK is included in the runtime you're using, see Runtime-included SDK versions.
    
    
      Lambda periodically updates the SDK libraries in the Node.js runtime to include the latest features and security upgrades. Lambda also applies 
      security patches and updates to the other libraries included in the runtime. To have full control of the dependencies in your package, you can 
      add your preferred version of any runtime-included dependency to your deployment package. For example, if you want to use a particular version of 
      the SDK for JavaScript, you can include it in your .zip file as a dependency. For more information on adding runtime-included dependencies to your .zip 
      file, see Dependency search path and runtime-included libraries.
    
    
      Under the AWS shared responsibility model, 
      you are responsible for the management of any dependencies in your functions' deployment packages. This includes applying updates and security 
      patches. To update dependencies in your function's deployment package, first create a new .zip file and then upload it to Lambda. See Creating a .zip deployment package with dependencies 
      and Creating and updating Node.js Lambda functions using .zip files for more information.
    
   
    Creating a .zip deployment package with no dependencies
    
      If your function code has no dependencies except for libraries included in the Lambda runtime, your .zip file contains only the index.js or 
      index.mjs file with your function’s handler code. Use your preferred zip utility to create a .zip file with your index.js or 
      index.mjs file at the root. If the file containing your handler code isn't at the root of your .zip file, Lambda won’t be able to run your code.
    
    
      To learn how to deploy your .zip file to create a new Lambda function or update an existing one, see Creating and updating Node.js Lambda functions using .zip files.
    
   
    Creating a .zip deployment package with dependencies
    If your function code depends on packages or modules that aren't included in the Lambda Node.js runtime,
      you can either add these dependencies to your .zip file with your function code or use a
      Lambda layer. The instructions in this section show you how to
      include your dependencies in your .zip deployment package. For instructions on how to include your
      dependencies in a layer, see Creating a Node.js layer for your dependencies.
    The following example CLI commands create a .zip file named my_deployment_package.zip containing the index.js 
      or index.mjs file with your function's handler code and its dependencies. In the example, you install dependencies using the 
      npm package manager.
    To create the deployment package
        Navigate to the project directory containing your index.js or index.mjs source code file. In this example, 
          the directory is named my_function.
        cd my_function
      
        Install your function's required libraries in the node_modules directory using the npm install command. In this 
          example you install the AWS X-Ray SDK for Node.js.
        npm install aws-xray-sdk
        This creates a folder structure similar to the following:
        ~/my_function
├── index.mjs
└── node_modules
    ├── async
    ├── async-listener
    ├── atomic-batcher
    ├── aws-sdk
    ├── aws-xray-sdk
    ├── aws-xray-sdk-core
        You can also add custom modules that you create yourself to your deployment package. Create a directory under node_modules 
          with the name of your module and save your custom written packages there.
      
        Create a .zip file that contains the contents of your project folder at the root. Use the r (recursive) option to 
          ensure that zip compresses the subfolders.
        zip -r my_deployment_package.zip .
      
   
    Creating a Node.js layer for your dependencies
    The instructions in this section show you how to include your dependencies in a layer. For instructions
      on how to include your dependencies in your deployment package, see
      Creating a .zip deployment package with dependencies.
    When you add a layer to a function, Lambda loads the layer content into the
      /opt directory of that execution environment. For each Lambda runtime,
      the PATH variable already includes specific folder paths within the
      /opt directory. To ensure that Lambda picks up your layer content, 
      your layer .zip file should have its dependencies
      in the following folder paths:
    
       
       
       
          
    
        nodejs/node_modules
      
        nodejs/node16/node_modules (NODE_PATH)
      
        nodejs/node18/node_modules (NODE_PATH)
      
        nodejs/node20/node_modules (NODE_PATH)
      
    For example, your layer .zip file structure might look like the following:
    xray-sdk.zip
└ nodejs/node_modules/aws-xray-sdk
    In addition, Lambda automatically detects any libraries in the /opt/lib
      directory, and any binaries in the /opt/bin directory. To ensure
      that Lambda properly finds your layer content, you can also create a layer
      with the following structure:
      custom-layer.zip
└ lib
    | lib_1
    | lib_2
└ bin
    | bin_1
    | bin_2
    After you package your layer, see Creating and deleting layers in Lambda
      and Adding layers to functions to complete your layer setup.
   
    Dependency search path and runtime-included libraries
    The Node.js runtime includes a number of common libraries, as well as a version of the AWS SDK for JavaScript. If you want to use a different version of a runtime-included library, you can do this by bundling it with your function or by adding it as a 
      dependency in your deployment package. For example, you can use a different version of the SDK by adding it to your .zip deployment package. 
      You can also include it in a Lambda layer for your function.
    When you use an import or require statement in your code, the Node.js runtime searches the directories in the NODE_PATH 
      path until it finds the module. By default, the first location the runtime searches is the directory into which your .zip deployment package is 
      decompressed and mounted (/var/task). If you include a version of a runtime-included library in your deployment package, this 
      version will take precedence over the version included in the runtime. Dependencies in your deployment package also have precedence over 
      dependencies in layers.
    When you add a dependency to a layer, Lambda extracts this to /opt/nodejs/nodexx/node_modules where nodexx 
      represents the version of the runtime you are using. In the search path, this directory has precedence over the directory containing the 
      runtime-included libraries (/var/lang/lib/node_modules). Libraries in function layers therefore have precedence over versions 
      included in the runtime.
    You can see the full search path for your Lambda function by adding the following line of code.
    console.log(process.env.NODE_PATH)
    You can also add dependencies in a separate folder inside your .zip package. For example, you might add a custom module to a folder in 
      your .zip package called common. When your .zip package is decompressed and mounted, this folder is placed inside the /var/task directory. 
      To use a dependency from a folder in your .zip deployment package in your code, use an import { } from or const { } = require() statement, 
      depending on whether you are using CJS or ESM module resolution. For example:
    import { myModule } from './common'
    If you bundle your code with esbuild, rollup, or similar, the dependencies used by your function are bundled together in one 
      or more files. We recommend using this method to vend dependencies whenever possible. Compared to adding dependencies to your deployment package, 
      bundling your code results in improved performance due to the reduction in I/O operations.
   
    Creating and updating Node.js Lambda functions using .zip files
    
      After you have created your .zip deployment package, you can use it to create a new Lambda function or update an existing one. You can deploy 
      your .zip package using the Lambda console, the AWS Command Line Interface, and the Lambda API. You can also create and update Lambda functions using 
      AWS Serverless Application Model (AWS SAM) and AWS CloudFormation.
    
    The maximum size for a .zip deployment package for Lambda is 250 MB (unzipped). Note that this limit applies to the combined size of all the files you upload, 
    including any Lambda layers.
    The Lambda runtime needs permission to read the files in your deployment package. In Linux permissions octal notation, Lambda needs 644 permissions 
      for non-executable files (rw-r--r--) and 755 permissions (rwxr-xr-x) for directories and executable files.
    In Linux and MacOS, use the chmod command to change file permissions on files and directories in your deployment package. For 
      example, to give a non-executable file the correct permissions, run the following command.
    chmod 644 <filepath>
    To change file permissions in Windows, see Set, View, Change, or Remove Permissions on an Object 
    in the Microsoft Windows documentation.
    NoteIf you don't grant Lambda the permissions it needs to access directories in your deployment package, Lambda sets the permissions for those directories to 755 (rwxr-xr-x).
     
      Creating and updating functions with .zip files using the console
      
      To create a new function, you must first create the function in the console, then upload your .zip archive. To update an existing function, open the page for your function, then follow the same procedure to add your updated .zip file.
    

      If your .zip file is less than 50MB, you can create or update a function by uploading the file directly from your local machine. For .zip files greater than 50MB, you must upload your package to an Amazon S3 bucket first. For instructions on how to upload a file to an Amazon S3 bucket using the AWS Management Console, see Getting started with Amazon S3. To upload files using the AWS CLI, see Move objects in the AWS CLI User Guide.
    
      NoteYou cannot change the deployment package type (.zip or container image) for an existing function. For example, you cannot convert a container image function to use a .zip file archive. You must create a new function.
  To create a new function (console)
      Open the Functions page of the Lambda console and choose Create Function.
    
      Choose Author from scratch.
    
      Under Basic information, do the following:
      
          For Function name, enter the name for your function.
          
              For Runtime, select the runtime you want to use.
            
              (Optional) For Architecture, choose the instruction set architecture for your function. The default architecture is x86_64. Ensure that the .zip deployment package for your function is compatible with the instruction set architecture you select.
            
    
      (Optional) Under Permissions, expand Change default execution role. You can create a new Execution role or use an existing one.
    
      Choose Create function. Lambda creates a basic 'Hello world' function using your chosen runtime.
    
  To upload a .zip archive from your local machine (console)
      In the Functions page of the Lambda console, choose the function you want to upload the .zip file for.
    
      Select the Code tab.
    
      In the Code source pane, choose Upload from.
    
      Choose .zip file.
    
      To upload the .zip file, do the following:
      
          Select Upload, then select your .zip file in the file chooser.
        
          Choose Open.
        
          Choose Save.
        
    
  
  To upload a .zip archive from an Amazon S3 bucket (console)
      In the Functions page of the Lambda console, choose the function you want to upload a new .zip file for.
    
      Select the Code tab.
    
      In the Code source pane, choose Upload from.
    
      Choose Amazon S3 location.
    
      Paste the Amazon S3 link URL of your .zip file and choose Save.
    
     
     
      Updating .zip file functions using the console code editor
      
     
    
      For some functions with .zip deployment packages, you can use the Lambda console’s built-in code editor to update your function code directly. To use this feature, your function must meet the following criteria:
    
    
       
       
    
        Your function must use one of the interpreted language runtimes (Python, Node.js, or Ruby)
      
        Your function’s deployment package must be smaller than 50 MB (unzipped).
      
    Function code for functions with container image deployment packages cannot be edited directly in the console.
    To update function code using the console code editor
        Open the Functions page of the Lambda console and select your function.
      
        Select the Code tab.
      
        In the Code source pane, select your source code file and edit it in the integrated code editor.
      
        In the DEPLOY section, choose Deploy to update your function's code:

   
    
   
   

      
     
      Creating and updating functions with .zip files using the AWS CLI
      
      You can can use the AWS CLI to create a new function or to update an existing one using a .zip file. Use the create-function 
      and update-function-code commands to deploy your .zip 
      package. If your .zip file is smaller than 50MB, you can upload the .zip package from a file location on your local build machine. For larger files, 
      you must upload your .zip package from an Amazon S3 bucket. For instructions on how to upload a file to an Amazon S3 bucket using the AWS CLI, see Move objects in the AWS CLI User Guide.
    
    NoteIf you upload your .zip file from an Amazon S3 bucket using the AWS CLI, the bucket must be located in the same AWS Region as your function.
    
      To create a new function using a .zip file with the AWS CLI, you must specify the following:
    
    
       
       
       
       
    
        The name of your function (--function-name)
      
        Your function’s runtime (--runtime)
      
        The Amazon Resource Name (ARN) of your function’s execution role (--role)
      
        The name of the handler method in your function code (--handler)
      
    
      You must also specify the location of your .zip file. If your .zip file is located in a folder on your local build machine, use the --zip-file option to specify the file path, as shown in the following example command.
    
    aws lambda create-function --function-name myFunction \
--runtime nodejs22.x --handler index.handler \
--role arn:aws:iam::111122223333:role/service-role/my-lambda-role \
--zip-file fileb://myFunction.zip
    
      To specify the location of .zip file in an Amazon S3 bucket, use the --code option as shown in the following example command. You only 
      need to use the S3ObjectVersion parameter for versioned objects.
    
    aws lambda create-function --function-name myFunction \
--runtime nodejs22.x --handler index.handler \
--role arn:aws:iam::111122223333:role/service-role/my-lambda-role \
--code S3Bucket=amzn-s3-demo-bucket,S3Key=myFileName.zip,S3ObjectVersion=myObjectVersion
    
      To update an existing function using the CLI, you specify the the name of your function using the --function-name parameter. You 
      must also specify the location of the .zip file you want to use to update your function code. If your .zip file is located in a folder on your 
      local build machine, use the --zip-file option to specify the file path, as shown in the following example command.
    
    aws lambda update-function-code --function-name myFunction \
--zip-file fileb://myFunction.zip
    
      To specify the location of .zip file in an Amazon S3 bucket, use the --s3-bucket and --s3-key options as shown in the 
      following example command. You only need to use the --s3-object-version parameter for versioned objects.
    
    aws lambda update-function-code --function-name myFunction \
--s3-bucket amzn-s3-demo-bucket --s3-key myFileName.zip --s3-object-version myObject Version
     
    
     
      Creating and updating functions with .zip files using the Lambda API
      
      To create and update functions using a .zip file archive, use the following API operations:
    

 
 

CreateFunction

UpdateFunctionCode

     
     
      Creating and updating functions with .zip files using AWS SAM
      
      The AWS Serverless Application Model (AWS SAM) is a toolkit that helps streamline the process of building and running serverless applications on AWS. You define the resources for your application in a 
      YAML or JSON template and use the AWS SAM command line interface (AWS SAM CLI) to build, package, and deploy your applications. When you build a Lambda function from an AWS SAM template, 
      AWS SAM automatically creates a .zip deployment package or container image with your function code and any dependencies you specify. To learn more about using AWS SAM to build and deploy 
      Lambda functions, see Getting started with AWS SAM in the
      AWS Serverless Application Model Developer Guide.

      You can also use AWS SAM to create a Lambda function using an existing .zip file archive. To create a Lambda function using AWS SAM, you can save your .zip file in 
      an Amazon S3 bucket or in a local folder on your build machine. For instructions on how to upload a file to an Amazon S3 bucket using the AWS CLI, 
      see Move objects in the AWS CLI User Guide.
    

      In your AWS SAM template, the AWS::Serverless::Function resource specifies your Lambda function. In this resource, set the following 
  properties to create a function using a .zip file archive:
    

 
 
 

PackageType - set to Zip

CodeUri - set to the  function code's Amazon S3 URI, path to local folder, or FunctionCode object

Runtime - Set to your chosen runtime


      With AWS SAM, if your .zip file is larger than 50MB, you don’t need to upload it to an Amazon S3 bucket first. AWS SAM can upload .zip packages up to 
      the maximum allowed size of 250MB (unzipped) from a location on your local build machine.
    

      To learn more about deploying functions using .zip file in AWS SAM, see AWS::Serverless::Function in the AWS SAM Developer Guide.
    
     
     
      Creating and updating functions with .zip files using AWS CloudFormation
      
      You can use AWS CloudFormation to create a Lambda function using a .zip file archive. To create a Lambda function from a .zip file, you must first upload 
      your file to an Amazon S3 bucket. For instructions on how to upload a file to an Amazon S3 bucket using the AWS CLI, see Move objects 
  in the AWS CLI User Guide. 
  In your AWS CloudFormation template, the AWS::Lambda::Function resource specifies your Lambda function. In this resource, set the following 
    properties to create a function using a .zip file archive:

 
 
 

PackageType - Set to Zip

Code - Enter the Amazon S3 bucket name and the .zip file name in the S3Bucket and S3Key fields

Runtime - Set to your chosen runtime


      The .zip file that AWS CloudFormation generates cannot exceed 4MB. To learn more about deploying functions using .zip file in AWS CloudFormation, see AWS::Lambda::Function 
  in the AWS CloudFormation User Guide.
    
     
  Document ConventionsHandlerDeploy container imagesDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideRuntime dependencies in Node.jsCreating a .zip deployment package with no dependenciesCreating a .zip deployment package with dependenciesCreating a Node.js layer for your dependenciesDependency search path and runtime-included librariesCreating and updating Node.js Lambda functions using .zip filesDeploy Node.js Lambda functions with .zip file archives
    Your AWS Lambda function’s code comprises a .js or .mjs file containing your function’s handler code, together with any additional packages and modules 
    your code depends on. To deploy this function code to Lambda, you use a deployment package. This package may either be a 
  .zip file archive or a container image.  
  For more information about using container images with Node.js, see Deploy Node.js Lambda functions with container images.
  
    To create your deployment package as .zip file archive, you can use your command-line tool’s built-in .zip file archive utility, or any other 
    .zip file utility such as 7zip. The examples shown in the following sections assume 
  you’re using a command-line zip tool in a Linux or MacOS environment. To use the same commands in Windows, you can 
  install the Windows Subsystem for Linux to get a Windows-integrated 
  version of Ubuntu and Bash.
  
    Note that Lambda uses POSIX file permissions, so you may need to set permissions for the deployment package folder before you create the .zip file archive.
  TopicsRuntime dependencies in Node.jsCreating a .zip deployment package with no dependenciesCreating a .zip deployment package with dependenciesCreating a Node.js layer for your dependenciesDependency search path and runtime-included librariesCreating and updating Node.js Lambda functions using .zip files
    Runtime dependencies in Node.js
    
      For Lambda functions that use the Node.js runtime, a dependency can be any Node.js module. The Node.js runtime includes a number of common 
      libraries, as well as a version of the AWS SDK for JavaScript. The nodejs16.x Lambda runtime includes version 2.x of the SDK. Runtime versions nodejs18.x and later include version 3 of the SDK. To use version 2 of the SDK with runtime versions nodejs18.x and later, add the SDK to your 
      .zip file deployment package. If your chosen runtime includes the version of the SDK you are using, you don't need to include the SDK library 
      in your .zip file. To find out which version of the SDK is included in the runtime you're using, see Runtime-included SDK versions.
    
    
      Lambda periodically updates the SDK libraries in the Node.js runtime to include the latest features and security upgrades. Lambda also applies 
      security patches and updates to the other libraries included in the runtime. To have full control of the dependencies in your package, you can 
      add your preferred version of any runtime-included dependency to your deployment package. For example, if you want to use a particular version of 
      the SDK for JavaScript, you can include it in your .zip file as a dependency. For more information on adding runtime-included dependencies to your .zip 
      file, see Dependency search path and runtime-included libraries.
    
    
      Under the AWS shared responsibility model, 
      you are responsible for the management of any dependencies in your functions' deployment packages. This includes applying updates and security 
      patches. To update dependencies in your function's deployment package, first create a new .zip file and then upload it to Lambda. See Creating a .zip deployment package with dependencies 
      and Creating and updating Node.js Lambda functions using .zip files for more information.
    
   
    Creating a .zip deployment package with no dependencies
    
      If your function code has no dependencies except for libraries included in the Lambda runtime, your .zip file contains only the index.js or 
      index.mjs file with your function’s handler code. Use your preferred zip utility to create a .zip file with your index.js or 
      index.mjs file at the root. If the file containing your handler code isn't at the root of your .zip file, Lambda won’t be able to run your code.
    
    
      To learn how to deploy your .zip file to create a new Lambda function or update an existing one, see Creating and updating Node.js Lambda functions using .zip files.
    
   
    Creating a .zip deployment package with dependencies
    If your function code depends on packages or modules that aren't included in the Lambda Node.js runtime,
      you can either add these dependencies to your .zip file with your function code or use a
      Lambda layer. The instructions in this section show you how to
      include your dependencies in your .zip deployment package. For instructions on how to include your
      dependencies in a layer, see Creating a Node.js layer for your dependencies.
    The following example CLI commands create a .zip file named my_deployment_package.zip containing the index.js 
      or index.mjs file with your function's handler code and its dependencies. In the example, you install dependencies using the 
      npm package manager.
    To create the deployment package
        Navigate to the project directory containing your index.js or index.mjs source code file. In this example, 
          the directory is named my_function.
        cd my_function
      
        Install your function's required libraries in the node_modules directory using the npm install command. In this 
          example you install the AWS X-Ray SDK for Node.js.
        npm install aws-xray-sdk
        This creates a folder structure similar to the following:
        ~/my_function
├── index.mjs
└── node_modules
    ├── async
    ├── async-listener
    ├── atomic-batcher
    ├── aws-sdk
    ├── aws-xray-sdk
    ├── aws-xray-sdk-core
        You can also add custom modules that you create yourself to your deployment package. Create a directory under node_modules 
          with the name of your module and save your custom written packages there.
      
        Create a .zip file that contains the contents of your project folder at the root. Use the r (recursive) option to 
          ensure that zip compresses the subfolders.
        zip -r my_deployment_package.zip .
      
   
    Creating a Node.js layer for your dependencies
    The instructions in this section show you how to include your dependencies in a layer. For instructions
      on how to include your dependencies in your deployment package, see
      Creating a .zip deployment package with dependencies.
    When you add a layer to a function, Lambda loads the layer content into the
      /opt directory of that execution environment. For each Lambda runtime,
      the PATH variable already includes specific folder paths within the
      /opt directory. To ensure that Lambda picks up your layer content, 
      your layer .zip file should have its dependencies
      in the following folder paths:
    
       
       
       
          
    
        nodejs/node_modules
      
        nodejs/node16/node_modules (NODE_PATH)
      
        nodejs/node18/node_modules (NODE_PATH)
      
        nodejs/node20/node_modules (NODE_PATH)
      
    For example, your layer .zip file structure might look like the following:
    xray-sdk.zip
└ nodejs/node_modules/aws-xray-sdk
    In addition, Lambda automatically detects any libraries in the /opt/lib
      directory, and any binaries in the /opt/bin directory. To ensure
      that Lambda properly finds your layer content, you can also create a layer
      with the following structure:
      custom-layer.zip
└ lib
    | lib_1
    | lib_2
└ bin
    | bin_1
    | bin_2
    After you package your layer, see Creating and deleting layers in Lambda
      and Adding layers to functions to complete your layer setup.
   
    Dependency search path and runtime-included libraries
    The Node.js runtime includes a number of common libraries, as well as a version of the AWS SDK for JavaScript. If you want to use a different version of a runtime-included library, you can do this by bundling it with your function or by adding it as a 
      dependency in your deployment package. For example, you can use a different version of the SDK by adding it to your .zip deployment package. 
      You can also include it in a Lambda layer for your function.
    When you use an import or require statement in your code, the Node.js runtime searches the directories in the NODE_PATH 
      path until it finds the module. By default, the first location the runtime searches is the directory into which your .zip deployment package is 
      decompressed and mounted (/var/task). If you include a version of a runtime-included library in your deployment package, this 
      version will take precedence over the version included in the runtime. Dependencies in your deployment package also have precedence over 
      dependencies in layers.
    When you add a dependency to a layer, Lambda extracts this to /opt/nodejs/nodexx/node_modules where nodexx 
      represents the version of the runtime you are using. In the search path, this directory has precedence over the directory containing the 
      runtime-included libraries (/var/lang/lib/node_modules). Libraries in function layers therefore have precedence over versions 
      included in the runtime.
    You can see the full search path for your Lambda function by adding the following line of code.
    console.log(process.env.NODE_PATH)
    You can also add dependencies in a separate folder inside your .zip package. For example, you might add a custom module to a folder in 
      your .zip package called common. When your .zip package is decompressed and mounted, this folder is placed inside the /var/task directory. 
      To use a dependency from a folder in your .zip deployment package in your code, use an import { } from or const { } = require() statement, 
      depending on whether you are using CJS or ESM module resolution. For example:
    import { myModule } from './common'
    If you bundle your code with esbuild, rollup, or similar, the dependencies used by your function are bundled together in one 
      or more files. We recommend using this method to vend dependencies whenever possible. Compared to adding dependencies to your deployment package, 
      bundling your code results in improved performance due to the reduction in I/O operations.
   
    Creating and updating Node.js Lambda functions using .zip files
    
      After you have created your .zip deployment package, you can use it to create a new Lambda function or update an existing one. You can deploy 
      your .zip package using the Lambda console, the AWS Command Line Interface, and the Lambda API. You can also create and update Lambda functions using 
      AWS Serverless Application Model (AWS SAM) and AWS CloudFormation.
    
    The maximum size for a .zip deployment package for Lambda is 250 MB (unzipped). Note that this limit applies to the combined size of all the files you upload, 
    including any Lambda layers.
    The Lambda runtime needs permission to read the files in your deployment package. In Linux permissions octal notation, Lambda needs 644 permissions 
      for non-executable files (rw-r--r--) and 755 permissions (rwxr-xr-x) for directories and executable files.
    In Linux and MacOS, use the chmod command to change file permissions on files and directories in your deployment package. For 
      example, to give a non-executable file the correct permissions, run the following command.
    chmod 644 <filepath>
    To change file permissions in Windows, see Set, View, Change, or Remove Permissions on an Object 
    in the Microsoft Windows documentation.
    NoteIf you don't grant Lambda the permissions it needs to access directories in your deployment package, Lambda sets the permissions for those directories to 755 (rwxr-xr-x).
     
      Creating and updating functions with .zip files using the console
      
      To create a new function, you must first create the function in the console, then upload your .zip archive. To update an existing function, open the page for your function, then follow the same procedure to add your updated .zip file.
    

      If your .zip file is less than 50MB, you can create or update a function by uploading the file directly from your local machine. For .zip files greater than 50MB, you must upload your package to an Amazon S3 bucket first. For instructions on how to upload a file to an Amazon S3 bucket using the AWS Management Console, see Getting started with Amazon S3. To upload files using the AWS CLI, see Move objects in the AWS CLI User Guide.
    
      NoteYou cannot change the deployment package type (.zip or container image) for an existing function. For example, you cannot convert a container image function to use a .zip file archive. You must create a new function.
  To create a new function (console)
      Open the Functions page of the Lambda console and choose Create Function.
    
      Choose Author from scratch.
    
      Under Basic information, do the following:
      
          For Function name, enter the name for your function.
          
              For Runtime, select the runtime you want to use.
            
              (Optional) For Architecture, choose the instruction set architecture for your function. The default architecture is x86_64. Ensure that the .zip deployment package for your function is compatible with the instruction set architecture you select.
            
    
      (Optional) Under Permissions, expand Change default execution role. You can create a new Execution role or use an existing one.
    
      Choose Create function. Lambda creates a basic 'Hello world' function using your chosen runtime.
    
  To upload a .zip archive from your local machine (console)
      In the Functions page of the Lambda console, choose the function you want to upload the .zip file for.
    
      Select the Code tab.
    
      In the Code source pane, choose Upload from.
    
      Choose .zip file.
    
      To upload the .zip file, do the following:
      
          Select Upload, then select your .zip file in the file chooser.
        
          Choose Open.
        
          Choose Save.
        
    
  
  To upload a .zip archive from an Amazon S3 bucket (console)
      In the Functions page of the Lambda console, choose the function you want to upload a new .zip file for.
    
      Select the Code tab.
    
      In the Code source pane, choose Upload from.
    
      Choose Amazon S3 location.
    
      Paste the Amazon S3 link URL of your .zip file and choose Save.
    
     
     
      Updating .zip file functions using the console code editor
      
     
    
      For some functions with .zip deployment packages, you can use the Lambda console’s built-in code editor to update your function code directly. To use this feature, your function must meet the following criteria:
    
    
       
       
    
        Your function must use one of the interpreted language runtimes (Python, Node.js, or Ruby)
      
        Your function’s deployment package must be smaller than 50 MB (unzipped).
      
    Function code for functions with container image deployment packages cannot be edited directly in the console.
    To update function code using the console code editor
        Open the Functions page of the Lambda console and select your function.
      
        Select the Code tab.
      
        In the Code source pane, select your source code file and edit it in the integrated code editor.
      
        In the DEPLOY section, choose Deploy to update your function's code:

   
    
   
   

      
     
      Creating and updating functions with .zip files using the AWS CLI
      
      You can can use the AWS CLI to create a new function or to update an existing one using a .zip file. Use the create-function 
      and update-function-code commands to deploy your .zip 
      package. If your .zip file is smaller than 50MB, you can upload the .zip package from a file location on your local build machine. For larger files, 
      you must upload your .zip package from an Amazon S3 bucket. For instructions on how to upload a file to an Amazon S3 bucket using the AWS CLI, see Move objects in the AWS CLI User Guide.
    
    NoteIf you upload your .zip file from an Amazon S3 bucket using the AWS CLI, the bucket must be located in the same AWS Region as your function.
    
      To create a new function using a .zip file with the AWS CLI, you must specify the following:
    
    
       
       
       
       
    
        The name of your function (--function-name)
      
        Your function’s runtime (--runtime)
      
        The Amazon Resource Name (ARN) of your function’s execution role (--role)
      
        The name of the handler method in your function code (--handler)
      
    
      You must also specify the location of your .zip file. If your .zip file is located in a folder on your local build machine, use the --zip-file option to specify the file path, as shown in the following example command.
    
    aws lambda create-function --function-name myFunction \
--runtime nodejs22.x --handler index.handler \
--role arn:aws:iam::111122223333:role/service-role/my-lambda-role \
--zip-file fileb://myFunction.zip
    
      To specify the location of .zip file in an Amazon S3 bucket, use the --code option as shown in the following example command. You only 
      need to use the S3ObjectVersion parameter for versioned objects.
    
    aws lambda create-function --function-name myFunction \
--runtime nodejs22.x --handler index.handler \
--role arn:aws:iam::111122223333:role/service-role/my-lambda-role \
--code S3Bucket=amzn-s3-demo-bucket,S3Key=myFileName.zip,S3ObjectVersion=myObjectVersion
    
      To update an existing function using the CLI, you specify the the name of your function using the --function-name parameter. You 
      must also specify the location of the .zip file you want to use to update your function code. If your .zip file is located in a folder on your 
      local build machine, use the --zip-file option to specify the file path, as shown in the following example command.
    
    aws lambda update-function-code --function-name myFunction \
--zip-file fileb://myFunction.zip
    
      To specify the location of .zip file in an Amazon S3 bucket, use the --s3-bucket and --s3-key options as shown in the 
      following example command. You only need to use the --s3-object-version parameter for versioned objects.
    
    aws lambda update-function-code --function-name myFunction \
--s3-bucket amzn-s3-demo-bucket --s3-key myFileName.zip --s3-object-version myObject Version
     
    
     
      Creating and updating functions with .zip files using the Lambda API
      
      To create and update functions using a .zip file archive, use the following API operations:
    

 
 

CreateFunction

UpdateFunctionCode

     
     
      Creating and updating functions with .zip files using AWS SAM
      
      The AWS Serverless Application Model (AWS SAM) is a toolkit that helps streamline the process of building and running serverless applications on AWS. You define the resources for your application in a 
      YAML or JSON template and use the AWS SAM command line interface (AWS SAM CLI) to build, package, and deploy your applications. When you build a Lambda function from an AWS SAM template, 
      AWS SAM automatically creates a .zip deployment package or container image with your function code and any dependencies you specify. To learn more about using AWS SAM to build and deploy 
      Lambda functions, see Getting started with AWS SAM in the
      AWS Serverless Application Model Developer Guide.

      You can also use AWS SAM to create a Lambda function using an existing .zip file archive. To create a Lambda function using AWS SAM, you can save your .zip file in 
      an Amazon S3 bucket or in a local folder on your build machine. For instructions on how to upload a file to an Amazon S3 bucket using the AWS CLI, 
      see Move objects in the AWS CLI User Guide.
    

      In your AWS SAM template, the AWS::Serverless::Function resource specifies your Lambda function. In this resource, set the following 
  properties to create a function using a .zip file archive:
    

 
 
 

PackageType - set to Zip

CodeUri - set to the  function code's Amazon S3 URI, path to local folder, or FunctionCode object

Runtime - Set to your chosen runtime


      With AWS SAM, if your .zip file is larger than 50MB, you don’t need to upload it to an Amazon S3 bucket first. AWS SAM can upload .zip packages up to 
      the maximum allowed size of 250MB (unzipped) from a location on your local build machine.
    

      To learn more about deploying functions using .zip file in AWS SAM, see AWS::Serverless::Function in the AWS SAM Developer Guide.
    
     
     
      Creating and updating functions with .zip files using AWS CloudFormation
      
      You can use AWS CloudFormation to create a Lambda function using a .zip file archive. To create a Lambda function from a .zip file, you must first upload 
      your file to an Amazon S3 bucket. For instructions on how to upload a file to an Amazon S3 bucket using the AWS CLI, see Move objects 
  in the AWS CLI User Guide. 
  In your AWS CloudFormation template, the AWS::Lambda::Function resource specifies your Lambda function. In this resource, set the following 
    properties to create a function using a .zip file archive:

 
 
 

PackageType - Set to Zip

Code - Enter the Amazon S3 bucket name and the .zip file name in the S3Bucket and S3Key fields

Runtime - Set to your chosen runtime


      The .zip file that AWS CloudFormation generates cannot exceed 4MB. To learn more about deploying functions using .zip file in AWS CloudFormation, see AWS::Lambda::Function 
  in the AWS CloudFormation User Guide.
    
     
  Document ConventionsHandlerDeploy container imagesDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideNode.js initializationRuntime-included SDK versionsUsing keep-aliveCA certificate loadingBuilding Lambda functions with Node.jsYou can run JavaScript code with Node.js in AWS Lambda. Lambda provides runtimes for Node.js that run your code to process events. Your code runs
    in an environment that includes the AWS SDK for JavaScript, with credentials from an AWS Identity and Access Management (IAM) role that you manage. To learn more 
    about the SDK versions included with the Node.js runtimes, see Runtime-included SDK versions.Lambda supports the following Node.js runtimes.
      
        Name
        Identifier
        Operating system
        Deprecation date
        Block function create
        Block function update
      
    
      
        
          Node.js 22
        
        
          nodejs22.x
        
        
          Amazon Linux 2023
        

        
                      Apr 30, 2027
            
        
        
                      Jun 1, 2027
            
        
        
                      Jul 1, 2027
            
        

      
      
        
          Node.js 20
        
        
          nodejs20.x
        
        
          Amazon Linux 2023
        

        
                      Apr 30, 2026
            
        
        
                      Jun 1, 2026
            
        
        
                      Jul 1, 2026
            
        

      
      
        
          Node.js 18
        
        
          nodejs18.x
        
        
          Amazon Linux 2
        

        
                      Sep 1, 2025
            
        
        
                      Oct 1, 2025
            
        
        
                      Nov 1, 2025
            
        

      
    To create a Node.js function
      Open the Lambda console.
    
      Choose Create function.
    
      Configure the following settings:
      
         
         
      
          Function name: Enter a name for the function.
        
          Runtime: Choose Node.js 22.x.
        
    
      Choose Create function.
    The console creates a Lambda function with a single source file named index.mjs. You can edit this file and add more files in the built-in code editor. In the DEPLOY section, choose Deploy to update your function's code. Then, to run your code, choose Create test event in the TEST EVENTS section.The index.mjs file exports a function named handler that takes an event object and a
    context object. This is the handler function that Lambda calls when the
    function is invoked. The Node.js function runtime gets invocation events from Lambda and passes them to the
    handler. In the function configuration, the handler value is index.handler.When you save your function code, the Lambda console creates a .zip file archive deployment package. 
   When you develop your function code outside of the console (using an IDE) you need to create a
      deployment package to upload your code to the Lambda function.The function runtime passes a context object to the handler, in addition to the invocation event. The context object contains additional information about the invocation, the
    function, and the execution environment. More information is available from environment variables.Your Lambda function comes with a CloudWatch Logs log group. The function runtime sends details about each invocation to
    CloudWatch Logs. It relays any logs that your function outputs during invocation. If
    your function returns an error, Lambda formats the error and returns it to the
    invoker.TopicsNode.js initializationRuntime-included SDK versionsUsing keep-alive for TCP connectionsCA certificate loadingDefine Lambda function handler in Node.jsDeploy Node.js Lambda functions with .zip file archivesDeploy Node.js Lambda functions with container imagesWorking with layers for Node.js Lambda functionsUsing the Lambda context object to retrieve Node.js function informationLog and monitor Node.js Lambda functionsInstrumenting Node.js code in AWS Lambda
    Node.js initialization
    Node.js has a unique event loop model that causes its initialization behavior to be different from other runtimes. 
      Specifically, Node.js uses a non-blocking I/O model that supports asynchronous operations. 
      This model allows Node.js to perform efficiently for most workloads. 
      For example, if a Node.js function makes a network call, that request may be designated as an asynchronous operation and placed into a callback queue. 
      The function may continue to process other operations within the main call stack without getting blocked by waiting for the network call to return. 
      Once the network call is completed, its callback is executed and then removed from the callback queue.
    
    
      Some initialization tasks may run asynchronously. These asynchronous tasks are not guaranteed to complete execution prior to an invocation. 
      For example, code that makes a network call to fetch a parameter from AWS Parameter Store may not be complete by the time Lambda executes the handler function. 
      As a result, the variable may be null during an invocation. 
      To avoid this, ensure that variables and other asynchronous code are fully initialized before continuing with the rest of the function's core business logic.
    
    Alternatively, you can designate your function code as an ES module, allowing you to use await at the top level
      of the file, outside the scope of your function handler. When you await every Promise, the asynchronous
      initialization code completes before handler invocations, maximizing the effectiveness of
      provisioned concurrency in reducing cold start latency. For more information and an example,
      see Using Node.js ES modules and top-level await in AWS Lambda.
     
      Designating a function handler as an ES module
      By default, Lambda treats files with the .js suffix as CommonJS modules. Optionally, you can designate your
        code as an ES module. You can do this in two ways: specifying the type as module in the function's
        package.json file, or by using the .mjs file name extension. In the first approach, your function
        code treats all .js files as ES modules, while in the second scenario, only the file you specify with .mjs
        is an ES module. You can mix ES modules and CommonJS modules by naming them .mjs and .cjs respectively,
        as .mjs files are always ES modules and .cjs files are always CommonJS modules.
      Lambda searches folders in the NODE_PATH environment variable when loading
        ES modules. You can load the AWS SDK that's included in the runtime using ES module import
        statements. You can also load ES modules from layers.
      
        ES module example
            Example  – ES module handlerconst url = "https://aws.amazon.com/";

export const handler = async(event) => {
    try {
        const res = await fetch(url);
        console.info("status", res.status);
        return res.status;
    }
    catch (e) {
        console.error(e);
        return 500;
    }
};
          
        CommonJS module example
            Example  – CommonJS module handlerconst https = require("https");
let url = "https://aws.amazon.com/";

exports.handler = async function (event) {
  let statusCode;
  await new Promise(function (resolve, reject) {
    https.get(url, (res) => {
        statusCode = res.statusCode;
        resolve(statusCode);
      }).on("error", (e) => {
        reject(Error(e));
      });
  });
  console.log(statusCode);
  return statusCode;
};
          
      
        
   
    Runtime-included SDK versions
    All supported Lambda Node.js runtimes include a specific minor version of the AWS SDK for JavaScript v3, not the latest version. The specific minor version that's included in the runtime depends on the runtime version and your AWS Region. To find the specific version of the SDK included in the runtime that you're using, create a Lambda function with the following code.
    Example index.mjsimport packageJson from '@aws-sdk/client-s3/package.json' with { type: 'json' };

export const handler = async () => ({ version: packageJson.version });This returns a response in the following format:{
  "version": "3.632.0"
}
    For more information, see Using the SDK for JavaScript v3 in your handler.
   
    Using keep-alive for TCP connections
    The default Node.js HTTP/HTTPS agent creates a new TCP connection for every new request. To avoid the cost of
      establishing new connections, keep-alive is enabled by default in nodejs18.x and later Lambda runtimes. Keep-alive can reduce request times for Lambda functions that make multiple API calls using the SDK.
    To disable keep-alive, see
      Reusing connections with keep-alive in Node.js in the AWS SDK for JavaScript 3.x Developer Guide. For more information about using keep-alive, see
      HTTP keep-alive is on by default in modular AWS SDK for JavaScript
      on the AWS Developer Tools Blog.
   
    CA certificate loading
    For Node.js runtime versions up to Node.js 18, Lambda automatically loads Amazon-specific CA (certificate
      authority) certificates to make it easier for you to create functions that interact with other AWS services.
      For example, Lambda includes the Amazon RDS certificates necessary for validating the
      server identity certificate
      installed on your Amazon RDS database. This behavior can have a performance impact during cold starts.
    Starting with Node.js 20, Lambda no longer loads additional CA certificates by default. The Node.js 20 runtime
      contains a certificate file with all Amazon CA certificates located at /var/runtime/ca-cert.pem. To
      restore the same behavior from Node.js 18 and earlier runtimes, set the NODE_EXTRA_CA_CERTS
      environment variable to /var/runtime/ca-cert.pem.
    For optimal performance, we recommend bundling only the certificates that you need with your deployment package
      and loading them via the NODE_EXTRA_CA_CERTS environment variable. The certificates file should
      consist of one or more trusted root or intermediate CA certificates in PEM format. For example, for RDS, include
      the required certificates alongside your code as certificates/rds.pem. Then, load the certificates
      by setting NODE_EXTRA_CA_CERTS to /var/task/certificates/rds.pem.
  Document ConventionsMonitoring concurrencyHandlerDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideSupported runtimesNew runtime releasesRuntime deprecation policyShared responsibility modelRuntime use after deprecationReceiving runtime deprecation notificationsDeprecated runtimesLambda runtimesLambda supports multiple languages through the use of runtimes. A runtime provides a language-specific environment that relays invocation events, context information, and responses between Lambda and the function. You can use runtimes that Lambda provides, or build your own.   
  Each major programming language release has a separate runtime, with a unique runtime identifier, such as nodejs22.x or python3.13. To configure a function to use a new major language version, you need to change the runtime identifier. Since AWS Lambda cannot guarantee backward compatibility between major versions, this is a customer-driven operation.
    For a function defined as a container image,
    you choose a runtime and the Linux distribution when you create the container image.  To change the runtime, you create a new container image.When you use a .zip file archive for the deployment package, you choose a runtime when you create the function.
    To change the runtime, you can update your function's configuration.
    The runtime is paired with one of the Amazon Linux distributions. The underlying execution environment provides
    additional libraries and environment variables that you can access from
    your function code.Lambda invokes your function in an execution environment. The execution
    environment provides a secure and isolated runtime environment that manages the resources required to run your
    function. Lambda re-uses the execution environment from a previous invocation if one is available, or it can create a
    new execution environment.  To use other languages in Lambda, such as Go or Rust, use an OS-only runtime. The
    Lambda execution environment provides a runtime interface for getting invocation
    events and sending responses. You can deploy other languages by implementing a custom runtime alongside your function code, or in a layer.
    Supported runtimes
  The following table lists the supported Lambda runtimes and projected deprecation dates. After a runtime is deprecated, you're 
    still able to create and update functions for a limited period. For more information, see Runtime use after deprecation. 
    The table provides the currently forecasted dates for runtime deprecation, based on our Runtime deprecation policy. These dates are provided for planning purposes and are 
    subject to change.
  
  
  
      
        Name
        Identifier
        Operating system
        Deprecation date
        Block function create
        Block function update
      
    
                  
        
          Node.js 22
        
        
          nodejs22.x
        
        
          Amazon Linux 2023
        
        
                      Apr 30, 2027
            
        
        
                      Jun 1, 2027
                      
        
        
                      Jul 1, 2027
                      
        
      
            
        
          Node.js 20
        
        
          nodejs20.x
        
        
          Amazon Linux 2023
        
        
                      Apr 30, 2026
            
        
        
                      Jun 1, 2026
                      
        
        
                      Jul 1, 2026
                      
        
      
            
        
          Node.js 18
        
        
          nodejs18.x
        
        
          Amazon Linux 2
        
        
                      Sep 1, 2025
            
        
        
                      Oct 1, 2025
                      
        
        
                      Nov 1, 2025
                      
        
      
                        
        
          Python 3.13
        
        
          python3.13
        
        
          Amazon Linux 2023
        
        
                      Jun 30, 2029
            
        
        
                      Jul 31, 2029
                      
        
        
                      Aug 31, 2029
                      
        
      
            
        
          Python 3.12
        
        
          python3.12
        
        
          Amazon Linux 2023
        
        
                      Oct 31, 2028
            
        
        
                      Nov 30, 2028
                      
        
        
                      Jan 10, 2029
                      
        
      
            
        
          Python 3.11
        
        
          python3.11
        
        
          Amazon Linux 2
        
        
                      Jun 30, 2026
            
        
        
                      Jul 31, 2026
                      
        
        
                      Aug 31, 2026
                      
        
      
            
        
          Python 3.10
        
        
          python3.10
        
        
          Amazon Linux 2
        
        
                      Jun 30, 2026
            
        
        
                      Jul 31, 2026
                      
        
        
                      Aug 31, 2026
                      
        
      
            
        
          Python 3.9
        
        
          python3.9
        
        
          Amazon Linux 2
        
        
                      Nov 3, 2025
            
        
        
                      Dec 8, 2025
                      
        
        
                      Jan 8, 2026
                      
        
      
                        
        
          Java 21
        
        
          java21
        
        
          Amazon Linux 2023
        
        
                      Jun 30, 2029
            
        
        
                      Jul 31, 2029
                      
        
        
                      Aug 31, 2029
                      
        
      
            
        
          Java 17
        
        
          java17
        
        
          Amazon Linux 2
        
        
                      Jun 30, 2026
            
        
        
                      Jul 31, 2026
                      
        
        
                      Aug 31, 2026
                      
        
      
            
        
          Java 11
        
        
          java11
        
        
          Amazon Linux 2
        
        
                      Jun 30, 2026
            
        
        
                      Jul 31, 2026
                      
        
        
                      Aug 31, 2026
                      
        
      
            
        
          Java 8
        
        
          java8.al2
        
        
          Amazon Linux 2
        
        
                      Jun 30, 2026
            
        
        
                      Jul 31, 2026
                      
        
        
                      Aug 31, 2026
                      
        
      
                        
        
          .NET 9 (container only)
        
        
          dotnet9
        
        
          Amazon Linux 2023
        
        
          
            Not scheduled
            
        
        
          
            Not scheduled
                      
        
        
          
            Not scheduled
                      
        
      
            
        
          .NET 8
        
        
          dotnet8
        
        
          Amazon Linux 2023
        
        
                      Nov 10, 2026
            
        
        
                      Dec 10, 2026
                      
        
        
                      Jan 11, 2027
                      
        
      
                                    
        
          Ruby 3.4
        
        
          ruby3.4
        
        
          Amazon Linux 2023
        
        
          
            Not scheduled
            
        
        
          
            Not scheduled
                      
        
        
          
            Not scheduled
                      
        
      
            
        
          Ruby 3.3
        
        
          ruby3.3
        
        
          Amazon Linux 2023
        
        
                      Mar 31, 2027
            
        
        
                      Apr 30, 2027
                      
        
        
                      May 31, 2027
                      
        
      
            
        
          Ruby 3.2
        
        
          ruby3.2
        
        
          Amazon Linux 2
        
        
                      Mar 31, 2026
            
        
        
                      Apr 30, 2026
                      
        
        
                      May 31, 2026
                      
        
      
                        
        
          OS-only Runtime
        
        
          provided.al2023
        
        
          Amazon Linux 2023
        
        
                      Jun 30, 2029
            
        
        
                      Jul 31, 2029
                      
        
        
                      Aug 31, 2029
                      
        
      
            
        
          OS-only Runtime
        
        
          provided.al2
        
        
          Amazon Linux 2
        
        
                      Jun 30, 2026
            
        
        
                      Jul 31, 2026
                      
        
        
                      Aug 31, 2026
                      
        
      
                
  NoteFor new regions, Lambda will not support runtimes that are set to be deprecated within the next 6 months.
  
  Lambda keeps managed runtimes and their corresponding container base images up to date with patches and support for minor version releases. 
    For more information see Lambda runtime updates.
    To programmatically interact with other AWS services and resources from your Lambda function, you can use one of AWS SDKs. The Node.js, Python, 
      and Ruby runtimes include a version of the AWS SDK. However, to maintain full control of your dependencies, and to maximize backward compatibility 
      during automatic runtime updates, we recommend that you always include the SDK modules your code uses (along with any dependencies) in your 
      function's deployment package or in a Lambda layer.
    We recommend that you use the runtime-included SDK version only when you can't include additional packages in your deployment. For example, 
      when you create your function using the Lambda console code editor or using inline function code in an AWS CloudFormation template.
    Lambda periodically updates the versions of the AWS SDKs included in the Node.js, Python, and Ruby runtimes. To determine the version of the 
      AWS SDK included in the runtime you're using, see the following sections:
    
       
       
       
    
        Runtime-included SDK versions (Node.js)
      
        Runtime-included SDK versions (Python)
      
        Runtime-included SDK versions (Ruby)
      
  
    
  Lambda continues to support the Go programming language after deprecation of the Go 1.x runtime. For more information, see 
    
    Migrating AWS Lambda functions from the Go1.x runtime to the custom runtime on Amazon Linux 2 
    on the AWS Compute Blog.

  All supported Lambda runtimes support both x86_64 and arm64 architectures.
   
    New runtime releases
    Lambda provides managed runtimes for new language versions only when the release reaches the long-term support (LTS) phase of the language's release 
      cycle. For example, for the Node.js release cycle, when the release reaches the 
      Active LTS phase.
    Before the release reaches the long-term support phase, it remains in development and can still be subject to breaking changes. Lambda applies runtime updates 
      automatically by default, so breaking changes to a runtime version could stop your functions from working as expected.
    Lambda doesn't provide managed runtimes for language versions which aren't scheduled for LTS release.
    The following list shows the target launch month for upcoming Lambda runtimes. These dates are indicative only and subject to change.
    
       
       
       
       
    
        Java 25 - October 2025
      
        Python 3.14 - November 2025
      
        Node.js 24 - November 2025
      
        .NET 10 - December 2025
      
   
    Runtime deprecation policy
    
    Lambda runtimes for .zip file archives are built around a combination of operating system, 
      programming language, and software libraries that are subject to maintenance and security updates. Lambda’s standard deprecation policy is to 
      deprecate a runtime when any major component of the runtime reaches the end of community long-term support (LTS) and security updates are no 
      longer available. Most usually, this is the language runtime, though in some cases, a runtime can be deprecated because the operating system 
      (OS) reaches end of LTS.
    After a runtime is deprecated, AWS may no longer apply security patches or updates to that runtime, and functions using that runtime are no 
      longer eligible for technical support. Such deprecated runtimes are provided ‘as-is’, without any warranties, and may contain bugs, errors, 
      defects, or other vulnerabilities.
    To learn more about managing runtime upgrades and deprecation, see the following sections and Managing AWS Lambda runtime upgrades 
      on the AWS Compute Blog.
    ImportantLambda occasionally delays deprecation of a Lambda runtime for a limited period beyond the end of support date of the language version 
        that the runtime supports. During this period, Lambda only applies security patches to the runtime OS. Lambda doesn’t apply security patches 
        to programming language runtimes after they reach their end of support date.
    
   
    Shared responsibility model
    
      Lambda is responsible for curating and publishing security updates for all supported managed runtimes and container base images. By default, Lambda will apply these 
      updates automatically to functions using managed runtimes. Where the default automatic runtime update setting has been changed, see the runtime management controls shared responsibility model. 
      For functions deployed using container images, you're responsible for rebuilding your function's container image from the latest base image and redeploying the container image.
    
    
      When a runtime is deprecated, Lambda’s responsibility for updating the managed runtime and container base images ceases. You are responsible for upgrading your functions to 
      use a supported runtime or base image.
    
    
     In all cases, you are responsible for applying updates to your function code, including its dependencies. Your responsibilities under the shared responsibility model are 
     summarized in the following table.
    
          
            Runtime lifecycle phase
            Lambda's responsibilities
            Your responsibilities
          
        
          
            Supported managed runtime
            
              Provide regular runtime updates with security patches and other updates.
              Apply runtime updates automatically by default (see Runtime update modes for non-default behaviors).
            
            Update your function code, including dependencies, to address any security vulnerabilities.
          
          
            Supported container image
            Provide regular updates to container base image with security patches and other updates.
            
              Update your function code, including dependencies, to address any security vulnerabilities.
              Regularly re-build and re-deploy your container image using the latest base image.
            
          
          
            Managed runtime approaching deprecation
            
              Notify customers prior to runtime deprecation via documentation, AWS Health Dashboard, email, and Trusted Advisor.
              Responsibility for runtime updates ends at deprecation.
            
            
              Monitor Lambda documentation, AWS Health Dashboard, email, or Trusted Advisor for runtime deprecation information.
              Upgrade functions to a supported runtime before the previous runtime is deprecated.
            
          
          
            Container image approaching deprecation
            
              Deprecation notifications are not available for functions using container images.
              Responsibility for container base image updates ends at deprecation.
            
            Be aware of deprecation schedules and upgrade functions to a supported base image before the previous image is deprecated.
          
        
    
   
      Runtime use after deprecation
      After a runtime is deprecated, AWS may no longer apply security patches or updates to that runtime, and functions using that runtime are no 
        longer eligible for technical support. Such deprecated runtimes are provided ‘as-is’, without any warranties, and may contain bugs, errors, defects, 
        or other vulnerabilities. Functions that use a deprecated runtime may also experience degraded performance or other issues, such as a certificate expiry, 
        that can cause them to stop working properly.
      For at least 30 days after a runtime is deprecated, you’re still able to create new Lambda functions using that runtime. Starting from 30 days 
        after deprecation, Lambda begins blocking the creation of new functions.
      For at least 60 days after a runtime is deprecated, you’re still able to update function code and configuration for existing functions. Starting 
        from 60 days after deprecation, Lambda begins blocking the update of function code and configuration for existing functions.
      NoteFor some runtimes, AWS is delaying the block-function-create and block-function-update dates beyond the usual 30 and 60 days 
        after deprecation. AWS has made this change in response to customer feedback to give you more time to upgrade your functions. Refer to the 
        tables in Supported runtimes and Deprecated runtimes to see the dates for your runtime.
      You can update a function to use a newer supported runtime indefinitely after a runtime is deprecated. You should test that your 
        function works with the new runtime before applying the runtime change in production environments, since you will not be able to revert to the 
        deprecated runtime once the 60-day period has passed. We recommend using function versions and 
        aliases to enable safe deployment with rollback.
      Note that the exact length of time for which you can continue to create and update functions isn’t fixed. This period can vary 
        for each deprecation and for different AWS Regions. Nominal dates for the blocking of function creates and updates are provided in the 
        Supported Runtimes table in the first section of this page. Lambda will not start blocking function creates or updates before the dates given in this table.
      You can continue to invoke your functions indefinitely after the runtime is deprecated. However, AWS strongly recommends that you migrate functions 
        to a supported runtime so that your functions continue to receive security patches and remain eligible for technical support.
     
      Receiving runtime deprecation notifications
      When a runtime approaches its deprecation date, Lambda sends you an email alert if any functions in your AWS account use that runtime. 
        Notifications are also displayed in the AWS Health Dashboard and in AWS Trusted Advisor.
      
         
         
         
      
          Receiving email notifications:
          Lambda sends you an email alert at least 180 days before a runtime is deprecated. This email lists 
            the $LATEST versions of all functions using the runtime. To see a full list of affected function versions, use Trusted Advisor or see Retrieve data about Lambda functions that use a deprecated runtime. 
          Lambda sends email notification to your AWS account's primary account contact. For information about 
            viewing or updating the email addresses in your account, see Updating contact information in the AWS General Reference.
        
          Receiving notifications through the AWS Health Dashboard:
          The AWS Health Dashboard displays a notification at least 180 days before a runtime is deprecated. Notifications 
            appear on the Your account health page under Other notifications. 
            The Affected resources tab of the notification lists the $LATEST versions of all functions using the runtime.
          NoteTo see a full and up-to-date list of affected function versions, use Trusted Advisor or see Retrieve data about Lambda functions that use a deprecated runtime.
          AWS Health Dashboard notifications expire 90 days after the affected runtime is deprecated.
        
          Using AWS Trusted Advisor
          Trusted Advisor displays a notification at least 180 days before a runtime is deprecated. Notifications appear on the 
            Security page. A list of your affected functions is displayed under 
            AWS Lambda Functions Using Deprecated Runtimes. This list of functions shows both $LATEST and published versions and 
            updates automatically to reflect your functions' current status.
          You can turn on weekly email notifications from Trusted Advisor in the Preferences 
            page of the Trusted Advisor console.
        
     
      Deprecated runtimes
      The following runtimes have reached end of support:
      
      
        Name
        Identifier
        Operating system
        Deprecation date
        Block function create
        Block function update
      
    
            
        
          .NET 6
        
        
          dotnet6
        
        
          Amazon Linux 2
        
        
                      Dec 20, 2024
            
        
        
                      Oct 1, 2025
            
        
        
                      Nov 1, 2025
            
        
      
            
        
          Python 3.8
        
        
          python3.8
        
        
          Amazon Linux 2
        
        
                      Oct 14, 2024
            
        
        
                      Oct 1, 2025
            
        
        
                      Nov 1, 2025
            
        
      
            
        
          Node.js 16
        
        
          nodejs16.x
        
        
          Amazon Linux 2
        
        
                      Jun 12, 2024
            
        
        
                      Oct 1, 2025
            
        
        
                      Nov 1, 2025
            
        
      
            
        
          .NET 7 (container only)
        
        
          dotnet7
        
        
          Amazon Linux 2
        
        
                      May 14, 2024
            
        
        
          
            N/A
            
        
        
          
            N/A
            
        
      
            
        
          Java 8
        
        
          java8
        
        
          Amazon Linux
        
        
                      Jan 8, 2024
            
        
        
                      Feb 8, 2024
            
        
        
                      Nov 1, 2025
            
        
      
            
        
          Go 1.x
        
        
          go1.x
        
        
          Amazon Linux
        
        
                      Jan 8, 2024
            
        
        
                      Feb 8, 2024
            
        
        
                      Nov 1, 2025
            
        
      
            
        
          OS-only Runtime
        
        
          provided
        
        
          Amazon Linux
        
        
                      Jan 8, 2024
            
        
        
                      Feb 8, 2024
            
        
        
                      Nov 1, 2025
            
        
      
            
        
          Ruby 2.7
        
        
          ruby2.7
        
        
          Amazon Linux 2
        
        
                      Dec 7, 2023
            
        
        
                      Jan 9, 2024
            
        
        
                      Nov 1, 2025
            
        
      
            
        
          Node.js 14
        
        
          nodejs14.x
        
        
          Amazon Linux 2
        
        
                      Dec 4, 2023
            
        
        
                      Jan 9, 2024
            
        
        
                      Nov 1, 2025
            
        
      
            
        
          Python 3.7
        
        
          python3.7
        
        
          Amazon Linux
        
        
                      Dec 4, 2023
            
        
        
                      Jan 9, 2024
            
        
        
                      Nov 1, 2025
            
        
      
            
        
          .NET Core 3.1
        
        
          dotnetcore3.1
        
        
          Amazon Linux 2
        
        
                      Apr 3, 2023
            
        
        
                      Apr 3, 2023
            
        
        
                      May 3, 2023
            
        
      
            
        
          Node.js 12
        
        
          nodejs12.x
        
        
          Amazon Linux 2
        
        
                      Mar 31, 2023
            
        
        
                      Mar 31, 2023
            
        
        
                      Apr 30, 2023
            
        
      
            
        
          Python 3.6
        
        
          python3.6
        
        
          Amazon Linux
        
        
                      Jul 18, 2022
            
        
        
                      Jul 18, 2022
            
        
        
                      Aug 29, 2022
            
        
      
            
        
          .NET 5 (container only)
        
        
          dotnet5.0
        
        
          Amazon Linux 2
        
        
                      May 10, 2022
            
        
        
          
            N/A
            
        
        
          
            N/A
            
        
      
            
        
          .NET Core 2.1
        
        
          dotnetcore2.1
        
        
          Amazon Linux
        
        
                      Jan 5, 2022
            
        
        
                      Jan 5, 2022
            
        
        
                      Apr 13, 2022
            
        
      
            
        
          Node.js 10
        
        
          nodejs10.x
        
        
          Amazon Linux 2
        
        
                      Jul 30, 2021
            
        
        
                      Jul 30, 2021
            
        
        
                      Feb 14, 2022
            
        
      
            
        
          Ruby 2.5
        
        
          ruby2.5
        
        
          Amazon Linux
        
        
                      Jul 30, 2021
            
        
        
                      Jul 30, 2021
            
        
        
                      Mar 31, 2022
            
        
      
            
        
          Python 2.7
        
        
          python2.7
        
        
          Amazon Linux
        
        
                      Jul 15, 2021
            
        
        
                      Jul 15, 2021
            
        
        
                      May 30, 2022
            
        
      
            
        
          Node.js 8.10
        
        
          nodejs8.10
        
        
          Amazon Linux
        
        
                      Mar 6, 2020
            
        
        
                      Feb 4, 2020
            
        
        
                      Mar 6, 2020
            
        
      
            
        
          Node.js 4.3
        
        
          nodejs4.3
        
        
          Amazon Linux
        
        
                      Mar 5, 2020
            
        
        
                      Feb 3, 2020
            
        
        
                      Mar 5, 2020
            
        
      
            
        
          Node.js 4.3 edge
        
        
          nodejs4.3-edge
        
        
          Amazon Linux
        
        
                      Mar 5, 2020
            
        
        
                      Mar 31, 2019
            
        
        
                      Apr 30, 2019
            
        
      
            
        
          Node.js 6.10
        
        
          nodejs6.10
        
        
          Amazon Linux
        
        
                      Aug 12, 2019
            
        
        
                      Jul 12, 2019
            
        
        
                      Aug 12, 2019
            
        
      
            
        
          .NET Core 1.0
        
        
          dotnetcore1.0
        
        
          Amazon Linux
        
        
                      Jun 27, 2019
            
        
        
                      Jun 30, 2019
            
        
        
                      Jul 30, 2019
            
        
      
            
        
          .NET Core 2.0
        
        
          dotnetcore2.0
        
        
          Amazon Linux
        
        
                      May 30, 2019
            
        
        
                      Apr 30, 2019
            
        
        
                      May 30, 2019
            
        
      
            
        
          Node.js 0.10
        
        
          nodejs
        
        
          Amazon Linux
        
        
                      Aug 30, 2016
            
        
        
                      Sep 30, 2016
            
        
        
                      Oct 31, 2016
            
        
      
          
      
      In almost all cases, the end-of-life date of a language version or operating system is known well in advance.
        The following links give end-of-life schedules for each language that Lambda supports as a managed runtime.
      
      
        Language and framework support policies
         
         
         
         
         
         
      
          Node.js – github.com
        
          Python – devguide.python.org
        
          Ruby – www.ruby-lang.org
        
          Java – www.oracle.com and Corretto FAQs
        
          Go – golang.org
        
          .NET – dotnet.microsoft.com
        
    Document ConventionsUsing the AWS CDKRuntime version updatesDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideCreating a layerDeleting a layer versionCreating and deleting layers in LambdaA Lambda layer is a .zip file archive that contains supplementary code or data.
  Layers usually contain library dependencies, a custom runtime,
  or configuration files. This section explains how to create and delete layers in Lambda. For more conceptual
    information about layers and why you might consider using them, see
    Managing Lambda dependencies with layers.After you’ve packaged your layer content, the
    next step is to create the layer in Lambda. This section demonstrates how to create and
    delete layers using the Lambda console or the Lambda API only. To create a layer using
    AWS CloudFormation, see Using AWS CloudFormation with layers. To create a layer using the
    AWS Serverless Application Model (AWS SAM), see Using AWS SAM with layers.TopicsCreating a layerDeleting a layer version
    Creating a layer
    To create a layer, you can either upload the .zip file archive from your local
      machine or from Amazon Simple Storage Service (Amazon S3). Lambda extracts the layer contents into the
      /opt directory when setting up the execution environment for the function.
    Layers can have one or more layer versions.
      When you create a layer, Lambda sets the layer version to version 1. You can change the
      permissions on an existing layer version at any time. However, to update the code or make
      other configuration changes, you must create a new version of the layer.
    To create a layer (console)
        Open the Layers page
          of the Lambda console.
      
        Choose Create layer.
      
        Under Layer configuration, for Name,
          enter a name for your layer.
      
        (Optional) For Description, enter a description for
          your layer.
      
        To upload your layer code, do one of the following:
        
          
            To upload a .zip file from your computer, choose Upload a
              .zip file. Then, choose Upload to select
              your local .zip file.
          
          
            To upload a file from Amazon S3, choose Upload a file from
              Amazon S3. Then, for Amazon S3 link URL,
              enter a link to the file.
          
        
      
        (Optional) For Compatible architectures, choose one
          value or both values. For more information, see Selecting and configuring an instruction set architecture for your Lambda function.
      
        (Optional) For Compatible runtimes, choose the
          runtimes that your layer is compatible with.
      
        (Optional) For License, enter any necessary license information.
      
        Choose Create.
      
    Alternatively, you can run the publish-layer-version AWS Command Line Interface (CLI) command. Example:
    aws lambda publish-layer-version \
    --layer-name my-layer \
    --zip-file fileb://layer.zip \
    --compatible-runtimes python3.13
    Each time that you run publish-layer-version, Lambda creates a new version of the layer.
   
    Deleting a layer version
    To delete a layer version, use the DeleteLayerVersion API operation. For example,
      run the delete-layer-version AWS CLI command with the layer name and layer version specified.
    aws lambda delete-layer-version --layer-name my-layer --version-number 1
    When you delete a layer version, you can no longer configure a Lambda function
      to use it. However, any function that already uses the version continues to have
      access to it. Also, Lambda never reuses version numbers for a layer name.
    When calculating quotas, deleting
      a layer version means it's no longer counted as part of the default 75 GB quota for
      storage of functions and layers. However, for functions that consume a deleted layer
      version, the layer content still counts towards the function's deployment package size
      quota (i.e. 250MB for .zip file archives).
  Document ConventionsPackaging layersAdding layersDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideFinding layer informationAdding layers to functionsA Lambda layer is a .zip file archive that contains supplementary code or data.
  Layers usually contain library dependencies, a custom runtime,
  or configuration files. This section explains how to add a layer to a Lambda function. For more conceptual
    information about layers and why you might consider using them, see
    Managing Lambda dependencies with layers.Before you can configure a Lambda function to use a layer, you must:
     
     
     
  
      Package your layer content
    
      Create a layer in Lambda
    
      Make sure that you have permission to call the GetLayerVersion API on the
        layer version. For functions in your AWS account, you must have this permission in
        your user policy. To use a layer
        in another account, the owner of that account must grant your account permission in a
        resource-based policy. For
        examples, see Granting Lambda layer access to other accounts.
    You can add up to five layers to a Lambda function. The total unzipped size of the
    function and all layers cannot exceed the unzipped deployment package size quota of 250 MB.
    For more information, see Lambda quotas.Your functions can continue to use any layer version that you’ve already added, even
    after that layer version has been deleted, or after your permission to access the layer
    is revoked. However, you cannot create a new function that uses a deleted layer version.To add a layer to a functionOpen the Functions page of the Lambda console.
      Choose the function.
    
      Scroll down to the Layers section, and then choose Add a layer.
    
      Under Choose a layer, choose a layer source:
      
          AWS layers: Choose from the list of AWS-managed extensions.
        
          Custom layers: Choose a layer created in your AWS account.
        
          Specify an ARN: To use a layer from a different AWS account, such as a third-party extension, enter the Amazon Resource Name (ARN).
        
    
      Choose Add.
    The order in which you add the layers is the order in which Lambda merges the layer content
    into the execution environment. You can change the layer merge order using the console.To update layer merge order for your function (console)Open the Functions page of the Lambda console.
      Choose the function to configure.
    
      Under Layers, choose Edit
    
      Choose one of the layers.
    
      Choose Merge earlier or Merge later to adjust the order of the layers.
    
      Choose Save.
    Layers are versioned. The content of each layer version is immutable. The owner of a
    layer can release new layer versions to provide updated content. You can use the console
    to update the layer version attached to your functions.To update layer versions for your function (console)
      Open the Layers page
        of the Lambda console.
    
      Choose the layer you want to update the version for.
    
      Choose the Functions using this version tab.
    
      Choose the functions you want to modify, then choose Edit.
    
      For Layer version, choose the layer version to change to.
    
      Choose Update functions.
    You cannot update function layer versions across AWS accounts.
    Finding layer information
    To find layers in your account that are compatible with your function’s runtime,
      use the ListLayers API. For example, you can use the following list-layers AWS Command Line Interface (CLI) command:
    aws lambda list-layers --compatible-runtime python3.13
    You should see output similar to the following:
    {
    "Layers": [
        {
            "LayerName": "my-layer",
            "LayerArn": "arn:aws:lambda:us-east-2:123456789012:layer:my-layer",
            "LatestMatchingVersion": {
                "LayerVersionArn": "arn:aws:lambda:us-east-2:123456789012:layer:my-layer:2",
                "Version": 2,
                "Description": "My layer",
                "CreatedDate": "2025-04-15T00:37:46.592+0000",
                "CompatibleRuntimes": [
                    "python3.13"
                ]
            }
        }
    ]
}
    To list all layers in your account, omit the --compatible-runtime option.
      The response details show the latest version of each layer.
    You can also get the latest version of a layer using the ListLayerVersions API.
      For example, you can use the following list-layer-versions CLI command:
    aws lambda list-layer-versions --layer-name my-layer
    You should see output similar to the following:
    {
    "LayerVersions": [
        {
            "LayerVersionArn": "arn:aws:lambda:us-east-2:123456789012:layer:my-layer:2",
            "Version": 2,
            "Description": "My layer",
            "CreatedDate": "2023-11-15T00:37:46.592+0000",
            "CompatibleRuntimes": [
                "java11"
            ]
        },
        {
            "LayerVersionArn": "arn:aws:lambda:us-east-2:123456789012:layer:my-layer:1",
            "Version": 1,
            "Description": "My layer",
            "CreatedDate": "2023-11-15T00:27:46.592+0000",
            "CompatibleRuntimes": [
                "java11"
            ]
        }
    ]
}
  Document ConventionsCreating and deleting layersLayers with AWS CloudFormationDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAmazon Simple Storage Service (S3)User GuideSetting upStep 1: Create a bucketStep 2: Upload an objectStep 3: Download an objectStep 4: Copy an objectStep 5: Delete the objects and bucketNext stepsGetting started with Amazon S3You can get started with Amazon S3 by working with buckets and objects. A bucket is a container for objects. An object is
    a file and any metadata that describes that file.To store an object in Amazon S3, you create a bucket and then upload the object to the bucket.
    When the object is in the bucket, you can open it, download it, and move it. When you no longer
    need an object or a bucket, you can clean up your resources.With Amazon S3, you pay only for what you use. For more information about Amazon S3 features and
    pricing, see Amazon S3. If you are a new Amazon S3 customer, you
    can get started with Amazon S3 for free. For more information, see AWS Free Tier.NoteFor more information about using the Amazon S3 Express One Zone storage class with directory buckets, see S3 Express One Zone and Working with directory buckets.    
      Video: Getting started with Amazon S3
    The following video shows you how to get started with
      Amazon S3.
  
       
        
       
       
    
    Prerequisites
    Before you begin, confirm that you've completed the steps in Setting up Amazon S3.
   
  Setting up Amazon S3
  When you sign up for AWS, your AWS account is automatically signed up for all services
    in AWS, including Amazon S3. You are charged only for the services that you use.
  With Amazon S3, you pay only for what you use. For more information about Amazon S3 features and
    pricing, see Amazon S3. If you are a new Amazon S3 customer, you
    can get started with Amazon S3 for free. For more information, see AWS Free Tier.
  To set up Amazon S3, use the steps in the following sections.
  When you sign up for AWS and set up Amazon S3, you can optionally change the display language
    in the AWS Management Console. For more information, see Changing the language
      of the AWS Management Console in the AWS Management Console Getting Started Guide.
  TopicsSign up for an AWS accountCreate a user with administrative access

  
  


   
    Sign up for an AWS account 

If you do not have an AWS account, complete the following steps to create one.
To sign up for an AWS accountOpen https://portal.aws.amazon.com/billing/signup.
  Follow the online instructions.
  Part of the sign-up procedure involves receiving a phone call and entering 
  a verification code on the phone keypad.
  When you sign up for an AWS account, an AWS account root user is created. The root user has access to all AWS services
  and resources in the account. As a security best practice, assign administrative access to a user, and use only the root user to perform tasks that require root user access.
  
 AWS sends you a confirmation email after the sign-up process is
complete. At any time, you can view your current account activity and manage your account by
going to https://aws.amazon.com/ and choosing My
  Account.
   


 
Create a user with administrative access 
After you sign up for an AWS account, secure your AWS account root user, enable AWS IAM Identity Center, and create an administrative user so that you 
don't use the root user for everyday tasks.
Secure your AWS account root user


 Sign in to the AWS Management Console as the account owner by choosing Root user and entering your AWS account email address. On the next page, enter your password.
 
 For help signing in by using root user, see Signing in as the root user in the AWS Sign-In User Guide.

 Turn on multi-factor authentication (MFA) for your root user.
 For instructions, see Enable a virtual MFA device for your AWS account root user (console) in the IAM User Guide. 

Create a user with administrative access
 Enable IAM Identity Center.
 For instructions, see Enabling
 AWS IAM Identity Center in the
 AWS IAM Identity Center User Guide.

 In IAM Identity Center, grant administrative access to a user.
 For a tutorial about using the IAM Identity Center directory as your identity source, see 
 Configure user access with the default IAM Identity Center directory in the
 AWS IAM Identity Center User Guide.

Sign in as the user with administrative access

To sign in with your IAM Identity Center user, use the sign-in URL that was sent to your email address when you created the IAM Identity Center user.

For help signing in using an IAM Identity Center user, see Signing in to the AWS access portal in the AWS Sign-In User Guide.

Assign access to additional users
 In IAM Identity Center, create a permission set that follows the best practice of applying least-privilege permissions.
 For instructions, see 
 Create a permission set in the AWS IAM Identity Center User Guide.
 
 Assign users to a group, and then assign single sign-on access to the group.
 For instructions, see 
 Add groups in the AWS IAM Identity Center User Guide.
 
 





 
  Step 1: Create your first S3 bucket
  After you sign up for AWS, you're ready to create a bucket in Amazon S3 using the AWS Management Console.
    Every object in Amazon S3 is stored in a bucket. Before you can
    store data in Amazon S3, you must create a bucket. 
  NoteFor more information about using the Amazon S3 Express One Zone storage class with directory buckets, see S3 Express One Zone and Working with directory buckets.
  NoteYou are not charged for creating a bucket. You are charged only for storing objects in the
      bucket and for transferring objects in and out of the bucket. The charges that you incur
      through following the examples in this guide are minimal (less than $1). For more information
      about storage charges, see Amazon S3
      pricing.
  Sign in to the AWS Management Console and open the Amazon S3 console at
         https://console.aws.amazon.com/s3/. In the navigation bar on the top of the page, choose the name of the currently displayed AWS Region. Next, choose the Region in which you want to create a bucket. 
    
    Note
         
         
      
          After you create a bucket, you can't change its Region. 
        
          To minimize latency and costs and address regulatory requirements, choose a Region close to
            you. Objects stored in a Region never leave that Region unless you explicitly transfer them to
            another Region. For a list of Amazon S3 AWS Regions, see AWS service endpoints in the Amazon Web Services General Reference.
        
    
        In the left navigation pane, choose General purpose buckets.
    
        Choose Create bucket. The Create bucket page opens.
    
        For Bucket name, enter a name for your bucket.
        The bucket name must:
        
             
             
             
             
       
        
                Be unique within a partition. A partition is a grouping of Regions. AWS currently has
          three partitions: aws (commercial Regions), aws-cn (China Regions), and
            aws-us-gov (AWS GovCloud (US) Regions).
            
                Be between 3 and 63 characters long.
            
                Consist only of lowercase letters, numbers, periods (.), and hyphens
            (-). For best compatibility, we recommend that you avoid using periods
            (.) in bucket names, except for buckets that are used only for static website
          hosting.
            
                Begin and end with a letter or number. 
            
        For a complete list of bucket-naming rules, see General purpose bucket naming rules.
      
        Important
         
         
      
          After you create the bucket, you can't change its name. 
        
          Don't include sensitive information in the bucket name. The bucket name is visible in the URLs
            that point to the objects in the bucket.
        
    
        (Optional) Under General configuration, you can choose to copy an existing
      bucket's settings to your new bucket. If you don't want to copy the settings of an existing bucket, skip
      to the next step.
        NoteThis option:
                 
                 
            Isn't available in the AWS CLI and is only available in the Amazon S3 consoleDoesn't copy the bucket policy from the existing bucket to the new bucket
         To copy an existing bucket's settings, under Copy settings from existing
        bucket, select Choose bucket. The Choose bucket
      window opens. Find the bucket with the settings that you want to copy, and select Choose
        bucket. The Choose bucket window closes, and the Create
        bucket window reopens.
        Under Copy settings from existing bucket, you now see the name of the
      bucket that you selected. The settings of your new bucket now match the settings of the bucket that you
      selected. If you want to remove the copied settings, choose Restore defaults.
      Review the remaining bucket settings on the Create bucket page. If you don't want
      to make any changes, you can skip to the final step. 
    
        Under Object Ownership, to disable or enable ACLs and control
            ownership of objects uploaded in your bucket, choose one of the following
            settings:
        
            ACLs disabled
             
        
                 Bucket owner enforced (default) – 
	ACLs are disabled, and the bucket owner automatically owns and has full control over every object in the general purpose bucket. ACLs 
	no longer affect access permissions to data in the S3 general purpose bucket. The bucket uses policies exclusively to define access control.
                By default, ACLs are disabled. A majority of modern use cases in Amazon S3 no
                    longer require the use of ACLs. We recommend that you keep ACLs disabled, except
                    in unusual circumstances where you must control access for each object
                    individually. For more information, see Controlling ownership of objects and disabling ACLs
			for your bucket.
            
        
            ACLs enabled
             
             
        
                Bucket owner preferred – The bucket owner owns and
                    has full control over new objects that other accounts write to the bucket with
                    the bucket-owner-full-control canned ACL. 
                If you apply the Bucket owner preferred setting, to
                    require all Amazon S3 uploads to include the bucket-owner-full-control
                    canned ACL, you can add a
                        bucket policy that allows only object uploads that use this
                    ACL.
            
                Object writer – The AWS account that uploads an
                    object owns the object, has full control over it, and can grant other users
                    access to it through ACLs.
            
        NoteThe default setting is Bucket owner enforced. To apply the
                default setting and keep ACLs disabled, only the s3:CreateBucket
                permission is needed. To enable ACLs, you must have the
                s3:PutBucketOwnershipControls permission.
    
        Under Block Public Access settings for this bucket, choose the
            Block Public Access settings that you want to apply to the bucket. 
        By default, all four Block Public Access settings are enabled. We recommend that you
            keep all settings enabled, unless you know that you need to turn off one or more of them
            for your specific use case. For more information about blocking public access, see Blocking public access to your Amazon S3
			storage.
        NoteTo enable all Block Public Access settings, only the s3:CreateBucket permission
            is required. To turn off any Block Public Access settings, you must have the
            s3:PutBucketPublicAccessBlock permission.
    
        (Optional) By default, Bucket Versioning is disabled. Versioning is a means
      of keeping multiple variants of an object in the same bucket. You can use versioning to preserve,
      retrieve, and restore every version of every object stored in your bucket. With versioning, you can
      recover more easily from both unintended user actions and application failures. For more information
      about versioning, see Retaining multiple versions of objects with S3 Versioning. 
    To enable versioning on your bucket, choose Enable. 
    
        (Optional) Under Tags, you can choose to add tags to your bucket. With
      AWS cost allocation, you can use bucket tags to annotate billing for your use of a bucket. A tag is a
      key-value pair that represents a label that you assign to a bucket. For more information, see Using cost allocation S3 bucket tags.    
        To add a bucket tag, enter a Key and optionally a
            Value and choose Add Tag.
    
    To configure Default encryption, under Encryption type,
      choose one of the following: 
    
       
       
                   
    
        Server-side encryption with Amazon S3 managed keys (SSE-S3)
      
        Server-side encryption with AWS Key Management Service keys (SSE-KMS)
      
        Dual-layer server-side encryption with AWS Key Management Service (AWS KMS) keys
          (DSSE-KMS)
        ImportantIf you use the SSE-KMS or DSSE-KMS option for your default encryption configuration, you are
            subject to the requests per second (RPS) quota of AWS KMS. For more information about AWS KMS quotas
            and how to request a quota increase, see Quotas in
            the AWS Key Management Service Developer Guide.
      
    Buckets and new objects are encrypted by using server-side encryption with Amazon S3 managed keys
      (SSE-S3) as the base level of encryption configuration. For more information about default encryption,
      see Setting default server-side encryption behavior for Amazon S3
      buckets. For more information about
      SSE-S3, see Using server-side encryption with Amazon S3 managed keys
			(SSE-S3).
    For more information about using server-side encryption to encrypt your data, see Protecting data with encryption. 
  
    If you chose Server-side encryption with Amazon S3 managed keys (SSE-S3) or
        Dual-layer server-side encryption with AWS Key Management Service (AWS KMS) keys (DSSE-KMS), do the
      following:
    
        Under AWS KMS key, specify your KMS key in one of the following ways:
        
           
           
           
        
            To choose from a list of available KMS keys, choose Choose from
              your AWS KMS keys, and choose your
              KMS key from the list of available keys.
            Both the AWS managed key (aws/s3) and your customer managed keys appear in this
              list. For more information about customer managed keys, see Customer keys and
                AWS keys in the AWS Key Management Service Developer Guide.
          
            To enter the KMS key ARN, choose Enter AWS KMS key
              ARN, and enter your KMS key ARN in the field that appears.
            
          
            To create a new customer managed key in the AWS KMS console, choose Create a
              KMS key.
            For more information about creating an AWS KMS key, see Creating keys in the AWS Key Management Service Developer Guide.
          
        ImportantYou can use only KMS keys that are available in the same AWS Region as the bucket. The
            Amazon S3 console lists only the first 100 KMS keys in the same Region as the bucket. To use a
            KMS key that isn't listed, you must enter your KMS key ARN. If you want to use a KMS key
            that's owned by a different account, you must first have permission to use the key, and then you
            must enter the KMS key ARN. For more information about cross account permissions for KMS keys,
            see Creating KMS keys that other accounts can use in the
              AWS Key Management Service Developer Guide. For more information about SSE-KMS, see Specifying server-side encryption with AWS KMS
      (SSE-KMS). For more
            information about DSSE-KMS, see Using dual-layer server-side encryption with AWS KMS keys
            (DSSE-KMS).When you use an AWS KMS key for server-side encryption in Amazon S3, you must
            choose a symmetric encryption KMS key. Amazon S3 supports only symmetric encryption KMS keys and not
            asymmetric KMS keys. For more information, see Identifying symmetric and
              asymmetric KMS keys in the AWS Key Management Service Developer Guide.
      
        When you configure your bucket to use default encryption with SSE-KMS, you can also use S3 Bucket Keys.
          S3 Bucket Keys lower the cost of encryption by decreasing request traffic from Amazon S3 to AWS KMS. For more
          information, see Reducing the cost of SSE-KMS with Amazon S3 Bucket Keys. S3 Bucket Keys aren't
          supported for DSSE-KMS.
        By default, S3 Bucket Keys are enabled in the Amazon S3 console. We recommend leaving S3 Bucket Keys enabled to
          lower your costs. To disable S3 Bucket Keys for your bucket, under Bucket Key, choose
            Disable.
      
  
        (Optional) S3 Object Lock helps protect new objects from being deleted or overwritten. For
      more information, see Locking objects with Object Lock. If you want to enable
      S3 Object Lock, do the following:
        
                Choose Advanced settings.
                ImportantEnabling Object Lock automatically enables versioning for the bucket. After you've
            enabled and successfully created the bucket, you must also configure the Object Lock default
            retention and legal hold settings on the bucket's Properties tab. 
            
                If you want to enable Object Lock, choose
                    Enable, read the warning that appears, and acknowledge it.
            
        NoteTo create an Object Lock enabled bucket, you must have the following permissions:
          s3:CreateBucket, s3:PutBucketVersioning, and
          s3:PutBucketObjectLockConfiguration.
    
        Choose Create bucket.
    
  You've created a bucket in Amazon S3. 
   
    Next step
    To add an object to your bucket, see Step 2: Upload an object to your bucket.
   
 
  Step 2: Upload an object to your bucket
  After creating a bucket in Amazon S3, you're ready to upload an object to the bucket. An object
    can be any kind of file: a text file, a photo, a video, and so on.
  
  NoteFor more information about using the Amazon S3 Express One Zone storage class with directory buckets, see S3 Express One Zone and Working with directory buckets.
  To upload an object to a bucketOpen the Amazon S3 console at
         https://console.aws.amazon.com/s3/.
      In the Buckets list, choose the name of the bucket that you want to
        upload your object to.
    
      On the Objects tab for your bucket, choose
          Upload.
    
      Under Files and folders, choose Add
        files.
    
      Choose a file to upload, and then choose Open.
      
    
      Choose Upload. 
    
  You've successfully uploaded an object to your bucket. 
   
    Next step
    To view your object, see Step 3: Download an object.
   
 
  Step 3: Download an object
  After you upload an object to a bucket, you can view information about your object and
    download the object to your local computer.
  NoteFor more information about using the Amazon S3 Express One Zone storage class with directory buckets, see S3 Express One Zone and Working with directory buckets.
   
    Using the S3 console
    This section explains how to use the Amazon S3 console to download an object from an S3
        bucket.
    Note
             
             
        
                You can download only one object at a time.
            
                If you use the Amazon S3 console to download an object whose key name ends with a
                    period (.), the period is removed from the key name of the
                    downloaded object. To retain the period at the end of the name of the downloaded
                    object, you must use the AWS Command Line Interface (AWS CLI), AWS SDKs, or Amazon S3 REST API. 
            
    To download an object from an S3 bucket Sign in to the AWS Management Console and open the Amazon S3 console at
         https://console.aws.amazon.com/s3/. 
            In the left navigation pane, choose General purpose buckets or Directory buckets.
        
            In the buckets list, choose the name of the bucket that you
                want to download an object from.
             
        
            You can download an object from an S3 bucket in any of the following ways:
            
                 
                 
            
                    Select the check box next to the object, and choose
                            Download. If you want to download the object to a
                        specific folder, on the Actions menu, choose
                            Download as.
                
                    If you want to download a specific version of the object, turn on
                            Show versions (located next to the search box).
                        Select the check box next to the version of the object that you want, and
                        choose Download. If you want to download the object to
                        a specific folder, on the Actions menu, choose
                            Download as.
                
        
 
  You've successfully downloaded your object.
   
    Next step
    To copy and paste your object within Amazon S3, see Step 4: Copy your object to a folder.
   
  
 
  Step 4: Copy your object to a folder
  You've already added an object to a bucket and downloaded the object. Now, you create a
    folder and copy the object and paste it into the folder.
  NoteFor more information about using the Amazon S3 Express One Zone storage class with directory buckets, see S3 Express One Zone and Working with directory buckets.
  To copy an object to a folder
      In the Buckets list, choose your bucket name.
    
      Choose Create folder and configure a new folder: 
      
          Enter a folder name (for example, favorite-pics).
        
          For the folder encryption setting, choose Disable.
        
          Choose Save.
        
    
      Navigate to the Amazon S3 bucket or folder that contains the objects that you want to
        copy.
    
      Select the check box to the left of the names of the objects that you want to
        copy.
    
      Choose Actions and choose Copy from the list
        of options that appears.
      Alternatively, choose Copy from the options in the upper right.
      
    
      Choose the destination folder:
      
          Choose Browse S3.
        
          Choose the option button to the left of the folder name.
          To navigate into a folder and choose a subfolder as your destination, choose the
            folder name.
        
          Choose Choose destination.
        
      The path to your destination folder appears in the Destination box.
        In Destination, you can alternately enter your destination path, for
        example,
        s3://bucket-name/folder-name/.
    
      In the bottom right, choose Copy.
      Amazon S3 copies your objects to the destination folder.
    
   
    Next step
    To delete an object and a bucket in Amazon S3, see Step 5: Delete your objects and bucket.
   
 
  Step 5: Delete your objects and bucket
  When you no longer need an object or a bucket, we recommend that you delete them to prevent
    further charges. If you completed this getting started walkthrough as a learning exercise, and
    you don't plan to use your bucket or objects, we recommend that you delete your bucket and
    objects so that charges no longer accrue. 
  Before you delete your bucket, empty the bucket or delete the objects in the bucket. After
    you delete your objects and bucket, they are no longer available.
  If you want to continue to use the same bucket name, we recommend that you delete the
    objects or empty the bucket, but don't delete the bucket. After you delete a bucket, the name
    becomes available to reuse. However, another AWS account might create a bucket with the same
    name before you have a chance to reuse it. 
  NoteFor more information about using the Amazon S3 Express One Zone storage class with directory buckets, see S3 Express One Zone and Working with directory buckets.
  TopicsDeleting an objectEmptying your bucketDeleting your bucket
  
   
    Deleting an object
    If you want to choose which objects you delete without emptying all the objects from your
      bucket, you can delete an object. 
    
        In the Buckets list, choose the name of the bucket that you want
          to delete an object from.
      
        Select the object that you want to
          delete.
      
        Choose Delete from the options in the upper right.
        
      
        On the Delete objects page, type delete to confirm deletion of your objects.
      
        Choose Delete objects.
      
   
   
    Emptying your bucket
    If you plan to delete your bucket, you must first empty your bucket, which deletes all the
      objects in the bucket. 
    To empty a bucket
        In the Buckets list, select the bucket that you want to empty,
          and then choose Empty.
      
        To confirm that you want to empty the bucket and delete all the objects in it, in
            Empty bucket, type permanently
          delete.
        ImportantEmptying the bucket cannot be undone. Objects added to the bucket while the empty
            bucket action is in progress will be deleted.
      
        To empty the bucket and delete all the objects in it, and choose
          Empty.
        An Empty bucket: Status page opens that you can use to review a
          summary of failed and successful object deletions.
      
        To return to your bucket list, choose Exit.
      
   
   
    Deleting your bucket
    After you empty your bucket or delete all the objects from your bucket, you can delete
        your bucket.
        To delete a bucket, in the Buckets list, select the
          bucket.
      
        Choose Delete.
      
        To confirm deletion, in Delete bucket, type the name of the
          bucket.
        ImportantDeleting a bucket cannot be undone. Bucket names are unique. If you delete your
            bucket, another AWS user can use the name. If you want to continue to use the same
            bucket name, don't delete your bucket. Instead, empty and keep the bucket. 
      
        To delete your bucket, choose Delete bucket.
      
   
 
    Next steps
    In the preceding examples, you learned how to perform some basic Amazon S3 tasks.
    The following topics explain the learning paths that you can use to
        gain a deeper understanding of Amazon S3 so that you can implement it in your
        applications.
    NoteFor more information about using the Amazon S3 Express One Zone storage class with directory buckets, see S3 Express One Zone and Working with directory buckets.
    TopicsUnderstand common use casesControl access to your buckets and
                objectsProtect and monitor your storageDevelop with Amazon S3Learn from tutorialsExplore training and support

     
        Understand common use cases
        You can use Amazon S3 to support your specific use case. The AWS Solutions
                Library and AWS
                Blog provide use-case specific information and
            tutorials. The following are some common use cases for Amazon S3:
        
             
             
             
             
        
                Backup and storage – Use Amazon S3 storage
                    management features to manage costs, meet regulatory requirements, reduce
                    latency, and save multiple distinct copies of your data for compliance
                    requirements.
            
                Application hosting – Deploy, install,
                    and manage web applications that are reliable, highly scalable, and low-cost.
                    For example, you can configure your Amazon S3 bucket to host a static website. For
                    more information, see Hosting a static website using Amazon S3.
            
                Media hosting – Build a highly available
                    infrastructure that hosts video, photo, or music uploads and downloads.
            
                Software delivery – Host your software
                    applications for customers to download.
            
     
     
        Control access to your buckets and
                objects
        Amazon S3 provides a variety of security features and tools. For an overview, see Access control in Amazon S3.
        By default, S3 buckets and the objects in them are private. You
            have access only to the S3 resources that you create. You can use
            the following features to grant granular resource permissions that
            support your specific use case or to audit the permissions of your
            Amazon S3 resources. 
        
             
             
             
             
             
             
        
                S3
                        Block Public Access – Block public access to S3 buckets and
                    objects. By default, Block Public Access settings are turned on at the bucket
                    level.
            
                AWS Identity and Access Management (IAM)
                        identities – Use IAM or AWS IAM Identity Center to create IAM
                    identities in your AWS account to manage access to your Amazon S3 resources. For
                    example, you can use IAM with Amazon S3 to control the type of access that a user
                    or group of users has to an Amazon S3 bucket that your AWS account owns. For more
                    information about IAM identities and best practices, see IAM identities
                        (users, user groups, and roles) in the IAM User Guide.
            
                Bucket policies – Use IAM-based policy
                    language to configure resource-based permissions for your S3
                    buckets and the objects in them.
            
                Access
                        control lists (ACLs) – Grant read and write permissions for
                    individual buckets and objects to authorized users. As a general rule, we
                    recommend using S3 resource-based policies (bucket policies and access point
                    policies) or IAM user policies for access control instead of ACLs. Policies
                    are a simplified and more flexible access-control option. With bucket policies
                    and access point policies, you can define rules that apply broadly across all
                    requests to your Amazon S3 resources. For more information about the specific cases
                    when you'd use ACLs instead of resource-based policies or IAM user policies,
                    see Identity and Access Management for Amazon S3.
            
                S3 Object Ownership – Take ownership of every object in
                    your bucket, simplifying access management for data stored in Amazon S3.
                    S3 Object Ownership is an Amazon S3 bucket-level setting that you can use to
                    disable or enable ACLs. By default, ACLs are disabled. With ACLs disabled, the
                    bucket owner owns all the objects in the bucket and manages access to data
                    exclusively by using access-management policies.
            
                IAM Access Analyzer for S3 – Evaluate and monitor your S3
                    bucket access policies, ensuring that the policies provide
                    only the intended access to your S3 resources. 
            
     
     
        Protect and monitor your storage
        
             
             
        
                Protecting your storage – After
                    you create buckets and upload objects in Amazon S3, you can protect your object
                    storage. For example, you can use S3 Versioning, S3 Replication, and Multi-Region Access Point
                    failover controls for disaster recovery, AWS Backup to back up your data, and
                    S3 Object Lock to set retention periods, prevent deletions and overwrites, and
                    meet compliance requirements.
            
                Monitoring your
                        storage – Monitoring is an important part
                    of maintaining the reliability, availability, and
                    performance of Amazon S3 and your AWS solutions. You can
                    monitor storage activity and costs. Also, we recommend that
                    you collect monitoring data from all the parts of your AWS
                    solution so that you can more easily debug a multipoint
                    failure if one occurs. 
                You can also use analytics and insights in Amazon S3 to understand, analyze, and
                    optimize your storage usage. For example, use Amazon S3 Storage Lens to understand, analyze, and optimize your storage.
                    S3 Storage Lens provides 29+ usage and activity metrics and interactive dashboards to
                    aggregate data for your entire organization, specific accounts, Regions,
                    buckets, or prefixes. Use Storage Class
                        Analysis to analyze storage access patterns to decide when it's time
                    to move your data to a more cost-effective storage class. To manage your costs,
                    you can use S3 Lifecycle.
            
     
     
        Develop with Amazon S3
        Amazon S3 is a REST service. You can send requests to Amazon S3 using the
            REST API or the AWS SDK libraries, which wrap the underlying Amazon S3
            REST API, simplifying your programming tasks. You can also use the
            AWS Command Line Interface (AWS CLI) to make Amazon S3 API calls. For more information, see
            Making requests
             in the Amazon S3 API Reference.
        The Amazon S3 REST API is an HTTP interface to Amazon S3. With the REST API,
            you use standard HTTP requests to create, fetch, and delete buckets
            and objects. To use the REST API, you can use any toolkit that
            supports HTTP. You can even use a browser to fetch objects, as long
            as they are anonymously readable. For more information, see Developing with Amazon S3 in the Amazon S3 API Reference.
        To help you build applications using the language of your choice, we provide the
            following resources.
        
                AWS CLI
                    You can access the features of Amazon S3 using the AWS CLI.
                        To download and configure the AWS CLI, see Developing with Amazon S3 using the AWS CLI
                         in the Amazon S3 API Reference.
        
                    The AWS CLI provides two tiers of commands for accessing
                        Amazon S3: High-level (s3) commands and API-level (s3api and s3control commands. The high-level S3
                        commands simplify performing common tasks, such as
                        creating, manipulating, and deleting objects and
                        buckets. The s3api and s3control commands expose direct
                        access to all Amazon S3 API operations, which you can use to
                        carry out advanced operations that might not be possible
                        with the high-level commands alone.
                    For a list of Amazon S3 AWS CLI commands, see s3, s3api, and s3control.
         
        AWS SDKs and Explorers
                    You can use the AWS SDKs when developing applications with Amazon S3. The
                        AWS SDKs simplify your programming tasks by wrapping the underlying REST
                        API. The AWS Mobile SDKs and the Amplify JavaScript library are also
                        available for building connected mobile and web applications using
                        AWS.
         
                    In addition to the AWS SDKs, AWS Explorers are
                        available for Visual Studio and Eclipse for Java IDE. In
                        this case, the SDKs and the explorers are bundled
                        together as AWS Toolkits.
        For more information, see Developing with Amazon S3 using the AWS SDKs
         in the Amazon S3 API Reference.
               
        Sample Code and Libraries
                    The AWS
                            Developer Center and AWS
                            Code Sample Catalog have sample code and
                        libraries written especially for Amazon S3. You can use these
                        code samples to understand how to implement the Amazon S3
                        API. You can also view the Amazon Simple Storage Service API Reference
                        to understand the Amazon S3 API operations in detail.
                   
     

     
        Learn from tutorials
        You can get started with step-by-step tutorials to learn more about Amazon S3. These tutorials are intended for a lab-type
            environment, and they use fictitious company names, user names, and so
            on. Their purpose is to provide general guidance. They are not intended
            for direct use in a production environment without careful review and
            adaptation to meet the unique needs of your organization's environment.


     
        Getting started
        
             
              
             
        
                Tutorial: Storing and retrieving a file with Amazon S3
            
                Tutorial: Getting started using S3 Intelligent-Tiering
            
                Tutorial: Getting started using the Amazon S3 Glacier storage classes
                    
     

     
        Optimizing storage costs
        
             
             
             
        
                Tutorial: Getting started using S3 Intelligent-Tiering
            
                Tutorial: Getting started using the Amazon S3 Glacier storage classes
            
                Tutorial: Optimizing costs and gaining visibility into usage with S3 Storage Lens
                    
     
    
         
        Managing storage
        
             
                          
        
                Tutorial: Getting started with Amazon S3 Multi-Region Access Points
            
                Tutorial: Replicating existing objects in your Amazon S3 buckets with S3 Batch Replication
                    
     

     
        Hosting videos and websites
        
             
             
             
        
                Tutorial: Hosting on-demand
            streaming video with Amazon S3, Amazon CloudFront, and Amazon Route 53
            
                Tutorial: Configuring a static website on
            Amazon S3
            
                Tutorial: Configuring a static website using a
			custom domain registered with Route 53
                    
     

     
        Processing data
        
             
             
                        
             
        
                Tutorial: Transforming data for your
            application with S3 Object Lambda
            
                Tutorial:
            Detecting and redacting PII data with S3 Object Lambda and Amazon Comprehend
            
                Tutorial: Using S3 Object Lambda to dynamically watermark images as they are retrieved
            
                Tutorial: Batch-transcoding
            videos with S3 Batch Operations
                    
     
    
     
        Protecting data
        
             
             
                 
                             
        
                Tutorial: Checking the integrity of data in Amazon S3 with additional checksums
            
                Tutorial: Replicating data within and between AWS Regions using S3 Replication
            
                Tutorial: Protecting data on Amazon S3 against accidental deletion or application bugs
                    using S3 Versioning, S3 Object Lock, and S3 Replication
            
                Tutorial: Replicating existing objects in your Amazon S3 buckets with S3 Batch Replication
                    
     
    



     
     
        Explore training and support
        You can learn from AWS experts to advance your skills and get expert assistance
            achieving your objectives.
        
             
             
             
        
                Training – Training resources provide a hands-on approach to learning Amazon S3. For more
                    information, see AWS training and
                        certification and AWS online tech talks.
                
            
                Discussion Forums – On the forum, you can review posts to understand what you can and can't do
                    with Amazon S3. You can also post your questions. For more information, see
                    Discussion Forums.
            
                Technical Support – If you have further questions, you can contact Technical Support.
            
     
Document ConventionsWhat is Amazon S3?Working with general purpose bucketsDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS Command Line InterfaceUser Guide for Version 2PrerequisitesBefore you startCreate a bucketList buckets and objectsDelete bucketsDelete objectsMove objectsCopy objectsSync objectsFrequently used options for s3
        commandsResourcesUsing high-level (s3) commands in the AWS CLIThis topic describes some of the commands you can use to manage Amazon S3 buckets and objects
    using the
      aws s3
    commands in the AWS CLI. For commands not covered in this topic and additional command examples,
    see the
      aws s3
    commands in the AWS CLI Reference.The high-level aws s3 commands simplify managing Amazon S3 objects. These commands
    enable you to manage the contents of Amazon S3 within itself and with local directories.TopicsPrerequisitesBefore you startCreate a bucketList buckets and objectsDelete bucketsDelete objectsMove objectsCopy objectsSync objectsFrequently used options for s3
        commandsResources
    Prerequisites
    To run the s3 commands, you need to:
    
       
       
       
    Install and configure the AWS CLI. For more information, see
                        Installing or updating to the latest version of
            the AWS CLI and Authentication and access credentials for the
      AWS CLI.
        The profile that you use must have permissions that allow the AWS operations
          performed by the examples.
      
        Understand these Amazon S3 terms:
        
           
           
           
        
            Bucket – A top-level Amazon S3 folder.
          
            Prefix – An Amazon S3 folder in a bucket.
          
            Object – Any item that's hosted in an Amazon S3
              bucket.
          
      
   
    Before you start
    This section describes a few things to note before you use aws s3
      commands.
     
      Large object uploads
      When you use aws s3 commands to upload large objects to an Amazon S3 bucket, the
        AWS CLI automatically performs a multipart upload. You can't resume a failed upload when using
        these aws s3 commands. 
      If the multipart upload fails due to a timeout, or if you manually canceled in the
        AWS CLI, the AWS CLI stops the upload and cleans up any files that were created. This process
        can take several minutes. 
      If the multipart upload or cleanup process is canceled by a kill command or system
        failure, the created files remain in the Amazon S3 bucket. To clean up the multipart upload, use
        the
          s3api abort-multipart-upload command.
     
     
      File properties and tags in multipart
          copies
      When you use the AWS CLI version 1 version of commands in the aws s3 namespace to
        copy a file from one Amazon S3 bucket location to another Amazon S3 bucket location, and that
        operation uses multipart copy, no
        file properties from the source object are copied to the destination object.
       
        By
          default, the AWS CLI version 2 commands in the s3 namespace that perform multipart
          copies transfers all tags and the following set of properties from the source to the
          destination copy: content-type, content-language,
            content-encoding, content-disposition,
            cache-control, expires, and metadata.
        This can result in additional AWS API calls to the Amazon S3 endpoint that would not have
          been made if you used AWS CLI version 1. These can include: HeadObject,
            GetObjectTagging, and PutObjectTagging.
        If you need to change this default behavior in AWS CLI version 2 commands, use the
            --copy-props parameter to specify one of the following options:
        
           
           
           
        
            default – The default value. Specifies
              that the copy includes all tags attached to the source object and the properties
              encompassed by the --metadata-directive parameter used for non-multipart
              copies: content-type, content-language,
                content-encoding, content-disposition,
                cache-control, expires, and metadata.
          
            metadata-directive – Specifies that the
              copy includes only the properties that are encompassed by the
                --metadata-directive parameter used for non-multipart copies. It
              doesn't copy any tags.
          
            none – Specifies that the copy includes
              none of the properties from the source object.
          
       
     
   
    Create a bucket
    Use the
        s3 mb command
      to make a bucket. Bucket names must be globally unique (unique across all of Amazon S3) and should be DNS
      compliant. 
    Bucket names can contain lowercase letters, numbers, hyphens, and periods. Bucket names
      can start and end only with a letter or number, and cannot contain a period next to a hyphen
      or another period. 
    Syntax
    $ aws s3 mb <target> [--options]
    The following example creates the s3://amzn-s3-demo-bucket bucket.$ aws s3 mb s3://amzn-s3-demo-bucket
   
    List buckets and objects
    To list your buckets, folders, or objects, use the
        s3 ls command.
      Using the command without a target or options lists all buckets. 
    Syntax
    $ aws s3 ls <target> [--options]
    For a few common options to use with this command, and examples, see Frequently used options for s3
        commands. For a complete list of available
      options, see
        s3 ls in the
        AWS CLI Command Reference.
    The following example lists all of your Amazon S3 buckets.$ aws s3 ls
2018-12-11 17:08:50 amzn-s3-demo-bucket1
2018-12-14 14:55:44 amzn-s3-demo-bucket2The following command lists all objects and prefixes in a bucket. In this example
          output, the prefix example/ has one file named
            MyFile1.txt.$ aws s3 ls s3://amzn-s3-demo-bucket
                           PRE example/
2018-12-04 19:05:48          3 MyFile1.txtYou can filter the output to a specific prefix by including it in the command. The
          following command lists the objects in bucket-name/example/
          (that is, objects in bucket-name filtered by the prefix
            example/).$ aws s3 ls s3://amzn-s3-demo-bucket/example/
2018-12-06 18:59:32          3 MyFile1.txtTo display only the buckets and objects in a specific region, use the
            --region options$ aws s3 ls --region us-east-2
2018-12-06 18:59:32          3 MyFile1.txtIf you have a large list of buckets and objects, you can paginated the results using
          the --max-items or --page-size options. The
            --max-items option limits how many total buckets and objects are returned
          in a call and the --page-size option limits how many of those are listed on a
          page.$ aws s3 ls --max-items 100 --page-size 10For more information on pagination, see How to use the --page-size
          parameter and How to use the --max-items
          parameter.
   
    Delete buckets
    To delete a bucket, use the
        s3 rb command. 
     
      Syntax
     
    $ aws s3 rb <target> [--options]
    The following example removes the s3://amzn-s3-demo-bucket bucket.$ aws s3 rb s3://amzn-s3-demo-bucketBy default, the bucket must be empty for the operation to succeed. To remove a bucket
          that's not empty, you need to include the --force option. If you're using a
          versioned bucket that contains previously deleted—but retained—objects, this
          command does not allow you to remove the bucket. You must first
          remove all of the content.The following example deletes all objects and prefixes in the bucket, and then deletes
          the bucket.$ aws s3 rb s3://amzn-s3-demo-bucket --force
   
    Delete objects
    To delete objects in a bucket or your local directory, use the
        s3 rm command. 
    Syntax
    $ aws s3 rm  <target> [--options]
    For a few common options to use with this command, and examples, see Frequently used options for s3
        commands. For a complete list of options,
      see
        s3 rm in the
        AWS CLI Command Reference.
    The following example deletes filename.txt from
            s3://amzn-s3-demo-bucket/example.$ aws s3 rm s3://amzn-s3-demo-bucket/example/filename.txtThe following example deletes all objects from
            s3://amzn-s3-demo-bucket/example using the --recursive
          option.$ aws s3 rm s3://amzn-s3-demo-bucket/example --recursive
   
    Move objects
    Use the
        s3 mv command
      to move objects from a bucket or a local directory. The s3 mv command copies the
      source object or file to the specified destination and then deletes the source object or
      file.
    Syntax
    $ aws s3 mv <source> <target> [--options]
    For a few common options to use with this command, and examples, see Frequently used options for s3
        commands. For a complete list of available
      options, see
        s3 mv in the
        AWS CLI Command Reference.
    WarningIf you are using any type of access point ARNs or access point aliases in your Amazon S3
        source or destination URIs, you must take extra care that your source and destination Amazon S3
        URIs resolve to different underlying buckets. If the source and destination buckets are the
        same, the source file or object can be moved onto itself, which can result in accidental
        deletion of your source file or object. To verify that the source and destination buckets
        are not the same, use the --validate-same-s3-paths parameter, or set the
        environment variable AWS_CLI_S3_MV_VALIDATE_SAME_S3_PATHS to
        true.
    
    The following example moves all objects from
            s3://amzn-s3-demo-bucket/example to
            s3://amzn-s3-demo-bucket/.$ aws s3 mv s3://amzn-s3-demo-bucket/example s3://amzn-s3-demo-bucket/The following example moves a local file from your current working directory to the
          Amazon S3 bucket with the s3 mv command.$ aws s3 mv filename.txt s3://amzn-s3-demo-bucketThe following example moves a file from your Amazon S3 bucket to your current working
          directory, where ./ specifies your current working directory.$ aws s3 mv s3://amzn-s3-demo-bucket/filename.txt ./
   
    Copy objects
    Use the
        s3 cp command
      to copy objects from a bucket or a local directory. 
    Syntax
    $ aws s3 cp <source> <target> [--options]
    You can use the dash parameter for file streaming to standard input (stdin)
      or standard output (stdout). 
    WarningIf you're using PowerShell, the shell might alter the encoding of a CRLF or add a CRLF
        to piped input or output, or redirected output.
    The s3 cp command uses the following syntax to upload a file stream from
        stdin to a specified bucket.
    Syntax
    $ aws s3 cp - <target> [--options]
    The s3 cp command uses the following syntax to download an Amazon S3 file stream
      for stdout.
    Syntax
    $ aws s3 cp <target> [--options] -
    For a few common options to use with this command, and examples, see Frequently used options for s3
        commands. For the complete list of
      options, see
        s3 cp in the
        AWS CLI Command Reference.
    The following example copies all objects from
            s3://amzn-s3-demo-bucket/example to
          s3://amzn-s3-demo-bucket/.$ aws s3 cp s3://amzn-s3-demo-bucket/example s3://amzn-s3-demo-bucket/The following example copies a local file from your current working directory to the
          Amazon S3 bucket with the s3 cp command.$ aws s3 cp filename.txt s3://amzn-s3-demo-bucketThe following example copies a file from your Amazon S3 bucket to your current working
          directory, where ./ specifies your current working directory.$ aws s3 cp s3://amzn-s3-demo-bucket/filename.txt ./The following example uses echo to stream the text "hello world" to the
            s3://bucket-name/filename.txt file.$ echo "hello world" | aws s3 cp - s3://amzn-s3-demo-bucket/filename.txtThe following example streams the
            s3://amzn-s3-demo-bucket/filename.txt file to stdout
          and prints the contents to the console.$ aws s3 cp s3://amzn-s3-demo-bucket/filename.txt -
hello worldThe following example streams the contents of s3://bucket-name/pre to
            stdout, uses the bzip2 command to compress the files, and
          uploads the new compressed file named key.bz2 to
            s3://bucket-name.$ aws s3 cp s3://amzn-s3-demo-bucket/pre - | bzip2 --best | aws s3 cp - s3://amzn-s3-demo-bucket/key.bz2
   
    Sync objects
    The
        s3 sync
      command synchronizes the contents of a bucket and a directory, or the contents of two buckets.
      Typically, s3 sync copies missing or outdated files or objects between the source
      and target. However, you can also supply the --delete option to remove files or
      objects from the target that are not present in the source. 
    Syntax
    $ aws s3 sync <source> <target> [--options]
    For a few common options to use with this command, and examples, see Frequently used options for s3
        commands. For a complete list of options,
      see
        s3 sync in
      the AWS CLI Command Reference.
    The following example synchronizes the contents of an Amazon S3 prefix named
            path in the bucket named amzn-s3-demo-bucket with the
          current working directory. s3 sync updates any files that have a size or modified time that are
          different from files with the same name at the destination. The output displays specific
          operations performed during the sync. Notice that the operation recursively synchronizes
          the subdirectory MySubdirectory and its contents with
            s3://amzn-s3-demo-bucket/path/MySubdirectory.$ aws s3 sync . s3://amzn-s3-demo-bucket/path
upload: MySubdirectory\MyFile3.txt to s3://amzn-s3-demo-bucket/path/MySubdirectory/MyFile3.txt
upload: MyFile2.txt to s3://amzn-s3-demo-bucket/path/MyFile2.txt
upload: MyFile1.txt to s3://amzn-s3-demo-bucket/path/MyFile1.txtThe following example, which extends the previous one, shows how to use the
            --delete option.// Delete local file
$ rm ./MyFile1.txt

// Attempt sync without --delete option - nothing happens
$ aws s3 sync . s3://amzn-s3-demo-bucket/path

// Sync with deletion - object is deleted from bucket
$ aws s3 sync . s3://amzn-s3-demo-bucket/path --delete
delete: s3://amzn-s3-demo-bucket/path/MyFile1.txt

// Delete object from bucket
$ aws s3 rm s3://amzn-s3-demo-bucket/path/MySubdirectory/MyFile3.txt
delete: s3://amzn-s3-demo-bucket/path/MySubdirectory/MyFile3.txt

// Sync with deletion - local file is deleted
$ aws s3 sync s3://amzn-s3-demo-bucket/path . --delete
delete: MySubdirectory\MyFile3.txt

// Sync with Infrequent Access storage class
$ aws s3 sync . s3://amzn-s3-demo-bucket/path --storage-class STANDARD_IAWhen using the --delete option, the --exclude and
            --include options can filter files or objects to delete during an s3
            sync operation. In this case, the parameter string must specify files to exclude
          from, or include for, deletion in the context of the target directory or bucket. The
          following shows an example.Assume local directory and s3://amzn-s3-demo-bucket/path currently in sync and each contains 3 files:
MyFile1.txt
MyFile2.rtf
MyFile88.txt
'''

// Sync with delete, excluding files that match a pattern. MyFile88.txt is deleted, while remote MyFile1.txt is not.
$ aws s3 sync . s3://amzn-s3-demo-bucket/path --delete --exclude "path/MyFile?.txt"
delete: s3://amzn-s3-demo-bucket/path/MyFile88.txt
'''

// Sync with delete, excluding MyFile2.rtf - local file is NOT deleted
$ aws s3 sync s3://amzn-s3-demo-bucket/path . --delete --exclude "./MyFile2.rtf"
download: s3://amzn-s3-demo-bucket/path/MyFile1.txt to MyFile1.txt
'''

// Sync with delete, local copy of MyFile2.rtf is deleted
$ aws s3 sync s3://amzn-s3-demo-bucket/path . --delete
delete: MyFile2.rtf
   
    Frequently used options for s3
        commands
    The following options are frequently used for the commands described in this topic. For a
      complete list of options you can use on a command, see the specific command in the
        AWS CLI version 2 reference
      guide.
    
       
       
       
       
       
    
        acl
        
          s3 sync and s3 cp can use the --acl option.
            This enables you to set the access permissions for files copied to Amazon S3. The
              --acl option accepts private, public-read, and
              public-read-write values. For more information, see Canned
              ACL in the Amazon S3 User Guide.
          $ aws s3 sync . s3://amzn-s3-demo-bucket/path --acl public-read
        
      
        exclude
        
          When you use the s3 cp, s3 mv, s3 sync, or
              s3 rm command, you can filter the results by using the
              --exclude or --include option. The --exclude
            option sets rules to only exclude objects from the command, and the options apply in the
            order specified. This is shown in the following example.
          Local directory contains 3 files:
MyFile1.txt
MyFile2.rtf
MyFile88.txt

// Exclude all .txt files, resulting in only MyFile2.rtf being copied
$ aws s3 cp . s3://amzn-s3-demo-bucket/path --exclude "*.txt"

// Exclude all .txt files but include all files with the "MyFile*.txt" format, resulting in, MyFile1.txt, MyFile2.rtf, MyFile88.txt being copied
$ aws s3 cp . s3://amzn-s3-demo-bucket/path --exclude "*.txt" --include "MyFile*.txt"

// Exclude all .txt files, but include all files with the "MyFile*.txt" format, but exclude all files with the "MyFile?.txt" format resulting in, MyFile2.rtf and MyFile88.txt being copied
$ aws s3 cp . s3://amzn-s3-demo-bucket/path --exclude "*.txt" --include "MyFile*.txt" --exclude "MyFile?.txt"
        
      
        include
        
          When you use the s3 cp, s3 mv, s3 sync, or
              s3 rm command, you can filter the results using the
              --exclude or --include option. The --include
            option sets rules to only include objects specified for the command, and the options
            apply in the order specified. This is shown in the following example.
          Local directory contains 3 files:
MyFile1.txt
MyFile2.rtf
MyFile88.txt

// Include all .txt files, resulting in MyFile1.txt and MyFile88.txt being copied
$ aws s3 cp . s3://amzn-s3-demo-bucket/path --include "*.txt"

// Include all .txt files but exclude all files with the "MyFile*.txt" format, resulting in no files being copied
$ aws s3 cp . s3://amzn-s3-demo-bucket/path --include "*.txt" --exclude "MyFile*.txt"

// Include all .txt files, but exclude all files with the "MyFile*.txt" format, but include all files with the "MyFile?.txt" format resulting in MyFile1.txt being copied

$ aws s3 cp . s3://amzn-s3-demo-bucket/path --include "*.txt" --exclude "MyFile*.txt" --include "MyFile?.txt"
        
      
        grant
        
          The s3 cp, s3 mv, and s3 sync commands
            include a --grants option that you can use to grant permissions on the
            object to specified users or groups. Set the --grants option to a list of
            permissions using the following syntax. Replace Permission,
              Grantee_Type, and Grantee_ID with your own values.
          Syntax
          --grants Permission=Grantee_Type=Grantee_ID
         [Permission=Grantee_Type=Grantee_ID ...]
          Each value contains the following elements:
          
             
             
             
          
              Permission – Specifies the granted permissions.
                Can be set to read, readacl, writeacl, or
                  full.
            
              Grantee_Type – Specifies how to identify the
                grantee. Can be set to uri, emailaddress, or
                  id.
            
              Grantee_ID – Specifies the grantee based on
                  Grantee_Type.
              
                 
                 
                 
              
                  uri – The group's URI. For more information, see Who is a
                    grantee?
                
                  emailaddress – The account's email address.
                
                  id – The account's canonical ID.
                
            
          For more information about Amazon S3 access control, see Access control.
          The following example copies an object into a bucket. It grants read
            permissions on the object to everyone, and full permissions
              (read, readacl, and writeacl) to the account
            associated with user@example.com. 
          $ aws s3 cp file.txt s3://amzn-s3-demo-bucket/ --grants read=uri=http://acs.amazonaws.com/groups/global/AllUsers full=emailaddress=user@example.com
          You can also specify a nondefault storage class (REDUCED_REDUNDANCY or
              STANDARD_IA) for objects that you upload to Amazon S3. To do this, use the
              --storage-class option.
          $ aws s3 cp file.txt s3://amzn-s3-demo-bucket/ --storage-class REDUCED_REDUNDANCY
        
      
        recursive
        
          When you use this option, the command is performed on all files or objects under the
            specified directory or prefix. The following example deletes
              s3://amzn-s3-demo-bucket/path and all of its contents.
          $ aws s3 rm s3://amzn-s3-demo-bucket/path --recursive
        
      
   
    Resources
    AWS CLI reference:
    
       
       
       
       
       
       
       
       
    
        aws
          s3
      
        aws s3
          cp
      
        aws s3
          mb
      
        aws s3
          mv
      
        aws s3
          ls
      
        aws s3
          rb
      
        aws s3
          rm
      
        aws s3
            sync
      
    Service reference:
    
       
       
       
       
    
        Working with
            Amazon S3 buckets in the Amazon S3 User Guide
      
        Working with
            Amazon S3 objects in the Amazon S3 User Guide
      
        Listing keys
            hierarchically using a prefix and delimiter in the
            Amazon S3 User Guide
      
        Abort multipart
            uploads to an S3 bucket using the AWS SDK for .NET (low-level) in the
            Amazon S3 User Guide
      
  Document ConventionsAmazon S3API-level (s3 api) commandsDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaAPI ReferenceRequest SyntaxURI Request ParametersRequest BodyResponse SyntaxResponse ElementsErrorsSee AlsoCreateFunctionCreates a Lambda function. To create a function, you need a deployment package and an execution role. The
      deployment package is a .zip file archive or container image that contains your function code. The execution role
      grants the function permission to use AWS services, such as Amazon CloudWatch Logs for log
      streaming and AWS X-Ray for request tracing.If the deployment package is a container
        image, then you set the package type to Image. For a container image, the code property
      must include the URI of a container image in the Amazon ECR registry. You do not need to specify the
      handler and runtime properties.If the deployment package is a .zip file archive, then
      you set the package type to Zip. For a .zip file archive, the code property specifies the location of
      the .zip file. You must also specify the handler and runtime properties. The code in the deployment package must
      be compatible with the target instruction set architecture of the function (x86-64 or
        arm64). If you do not specify the architecture, then the default value is
      x86-64.When you create a function, Lambda provisions an instance of the function and its supporting
      resources. If your function connects to a VPC, this process can take a minute or so. During this time, you can't
      invoke or modify the function. The State, StateReason, and StateReasonCode
      fields in the response from GetFunctionConfiguration indicate when the function is ready to
      invoke. For more information, see Lambda function states.A function has an unpublished version, and can have published versions and aliases. The unpublished version
      changes when you update your function's code and configuration. A published version is a snapshot of your function
      code and configuration that can't be changed. An alias is a named resource that maps to a version, and can be
      changed to map to a different version. Use the Publish parameter to create version 1 of
      your function from its initial configuration.The other parameters let you configure version-specific and function-level settings. You can modify
      version-specific settings later with UpdateFunctionConfiguration. Function-level settings apply
      to both the unpublished and published versions of the function, and include tags (TagResource)
      and per-function concurrency limits (PutFunctionConcurrency).You can use code signing if your deployment package is a .zip file archive. To enable code signing for this
      function, specify the ARN of a code-signing configuration. When a user attempts to deploy a code package with
        UpdateFunctionCode, Lambda checks that the code package has a valid signature from
      a trusted publisher. The code-signing configuration includes set of signing profiles, which define the trusted
      publishers for this function.If another AWS account or an AWS service invokes your function, use AddPermission to grant permission by creating a resource-based AWS Identity and Access Management (IAM) policy. You can grant permissions at the function level, on a version, or on an alias.To invoke your function directly, use Invoke. To invoke your function in response to events
      in other AWS services, create an event source mapping (CreateEventSourceMapping),
      or configure a function trigger in the other service. For more information, see Invoking Lambda
      functions.
      Request Syntax
      POST /2015-03-31/functions HTTP/1.1
Content-type: application/json

{
   "Architectures": [ "string" ],
   "Code": { 
      "ImageUri": "string",
      "S3Bucket": "string",
      "S3Key": "string",
      "S3ObjectVersion": "string",
      "SourceKMSKeyArn": "string",
      "ZipFile": blob
   },
   "CodeSigningConfigArn": "string",
   "DeadLetterConfig": { 
      "TargetArn": "string"
   },
   "Description": "string",
   "Environment": { 
      "Variables": { 
         "string" : "string" 
      }
   },
   "EphemeralStorage": { 
      "Size": number
   },
   "FileSystemConfigs": [ 
      { 
         "Arn": "string",
         "LocalMountPath": "string"
      }
   ],
   "FunctionName": "string",
   "Handler": "string",
   "ImageConfig": { 
      "Command": [ "string" ],
      "EntryPoint": [ "string" ],
      "WorkingDirectory": "string"
   },
   "KMSKeyArn": "string",
   "Layers": [ "string" ],
   "LoggingConfig": { 
      "ApplicationLogLevel": "string",
      "LogFormat": "string",
      "LogGroup": "string",
      "SystemLogLevel": "string"
   },
   "MemorySize": number,
   "PackageType": "string",
   "Publish": boolean,
   "Role": "string",
   "Runtime": "string",
   "SnapStart": { 
      "ApplyOn": "string"
   },
   "Tags": { 
      "string" : "string" 
   },
   "Timeout": number,
   "TracingConfig": { 
      "Mode": "string"
   },
   "VpcConfig": { 
      "Ipv6AllowedForDualStack": boolean,
      "SecurityGroupIds": [ "string" ],
      "SubnetIds": [ "string" ]
   }
}
    
      URI Request Parameters
      The request does not use any URI parameters.
    
      Request Body
      The request accepts the following data in JSON format.
      
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
      
            
               
                  Architectures
               
            
            
               The instruction set architecture that the function supports. Enter a string array with one of the valid values (arm64 or x86_64).
     The default value is x86_64.
               Type: Array of strings
               Array Members: Fixed number of 1 item.
               Valid Values: x86_64 | arm64
               
               Required: No
            
          
            
               
                  Code
               
            
            
               The code for the function.
               Type: FunctionCode object
               Required: Yes
            
          
            
               
                  CodeSigningConfigArn
               
            
            
               To enable code signing for this function, specify the ARN of a code-signing configuration. A code-signing configuration
includes a set of signing profiles, which define the trusted publishers for this function.
               Type: String
               Length Constraints: Maximum length of 200.
               Pattern: arn:(aws[a-zA-Z-]*)?:lambda:[a-z]{2}((-gov)|(-iso(b?)))?-[a-z]+-\d{1}:\d{12}:code-signing-config:csc-[a-z0-9]{17}
               
               Required: No
            
          
            
               
                  DeadLetterConfig
               
            
            
               A dead-letter queue configuration that specifies the queue or topic where Lambda sends asynchronous events
      when they fail processing. For more information, see Dead-letter queues.
               Type: DeadLetterConfig object
               Required: No
            
          
            
               
                  Description
               
            
            
               A description of the function.
               Type: String
               Length Constraints: Minimum length of 0. Maximum length of 256.
               Required: No
            
          
            
               
                  Environment
               
            
            
               Environment variables that are accessible from function code during execution.
               Type: Environment object
               Required: No
            
          
            
               
                  EphemeralStorage
               
            
            
               The size of the function's /tmp directory in MB. The default value is 512, but can be any whole
      number between 512 and 10,240 MB. For more information, see Configuring ephemeral storage (console).
               Type: EphemeralStorage object
               Required: No
            
          
            
               
                  FileSystemConfigs
               
            
            
               Connection settings for an Amazon EFS file system.
               Type: Array of FileSystemConfig objects
               Array Members: Maximum number of 1 item.
               Required: No
            
          
            
               
                  FunctionName
               
            
            
               The name or ARN of the Lambda function.
               
                  Name formats
                   
                   
                   
               
                     
                        Function name – my-function.
                  
                     
                        Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function.
                  
                     
                        Partial ARN – 123456789012:function:my-function.
                  
               The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64
      characters in length.
               Type: String
               Length Constraints: Minimum length of 1. Maximum length of 140.
               Pattern: (arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\d{1}:)?(\d{12}:)?(function:)?([a-zA-Z0-9-_]+)(:(\$LATEST|[a-zA-Z0-9-_]+))?
               
               Required: Yes
            
          
            
               
                  Handler
               
            
            
               The name of the method within your code that Lambda calls to run your function. 
Handler is required if the deployment package is a .zip file archive. The format includes the
      file name. It can also include namespaces and other qualifiers, depending on the runtime. For more information,
      see Lambda programming model.
               Type: String
               Length Constraints: Maximum length of 128.
               Pattern: [^ ]+
               
               Required: No
            
          
            
               
                  ImageConfig
               
            
            
               Container image configuration
      values that override the values in the container image Dockerfile.
               Type: ImageConfig object
               Required: No
            
          
            
               
                  KMSKeyArn
               
            
            
               The ARN of the AWS Key Management Service (AWS KMS) customer managed key that's used to encrypt the following resources:
               
                   
                   
                   
                   
               
                     The function's environment variables.
                  
                     The function's Lambda SnapStart snapshots.
                  
                     When used with SourceKMSKeyArn, the unzipped version of the .zip deployment package that's used for function invocations. For more information, see 
Specifying a customer managed key for Lambda.
                  
                     The optimized version of the container image that's used for function invocations. Note that this is not the same key that's used to protect your container image in the Amazon Elastic Container Registry (Amazon ECR). For more information, see Function lifecycle.
                  
               If you don't provide a customer managed key, Lambda uses an AWS owned key or an AWS managed key.
               Type: String
               Pattern: (arn:(aws[a-zA-Z-]*)?:[a-z0-9-.]+:.*)|()
               
               Required: No
            
          
            
               
                  Layers
               
            
            
               A list of function layers
      to add to the function's execution environment. Specify each layer by its ARN, including the version.
               Type: Array of strings
               Length Constraints: Minimum length of 1. Maximum length of 140.
               Pattern: arn:[a-zA-Z0-9-]+:lambda:[a-zA-Z0-9-]+:\d{12}:layer:[a-zA-Z0-9-_]+:[0-9]+
               
               Required: No
            
          
            
               
                  LoggingConfig
               
            
            
               The function's Amazon CloudWatch Logs configuration settings.
               Type: LoggingConfig object
               Required: No
            
          
            
               
                  MemorySize
               
            
            
               The amount of memory available to the function at runtime.
      Increasing the function memory also increases its CPU allocation. The default value is 128 MB. The value can be any multiple of 1 MB.
               Type: Integer
               Valid Range: Minimum value of 128. Maximum value of 10240.
               Required: No
            
          
            
               
                  PackageType
               
            
            
               The type of deployment package. Set to Image for container image and set to Zip for .zip file archive.
               Type: String
               Valid Values: Zip | Image
               
               Required: No
            
          
            
               
                  Publish
               
            
            
               Set to true to publish the first version of the function during creation.
               Type: Boolean
               Required: No
            
          
            
               
                  Role
               
            
            
               The Amazon Resource Name (ARN) of the function's execution role.
               Type: String
               Pattern: arn:(aws[a-zA-Z-]*)?:iam::\d{12}:role/?[a-zA-Z_0-9+=,.@\-_/]+
               
               Required: Yes
            
          
            
               
                  Runtime
               
            
            
               The identifier of the function's 
          runtime. Runtime is required if the deployment package is a .zip file archive. Specifying a runtime results in
          an error if you're deploying a function using a container image.
               The following list includes deprecated runtimes. Lambda blocks creating new functions and updating existing
          functions shortly after each runtime is deprecated. For more information, see
          Runtime use after deprecation.
               For a list of all currently supported runtimes, see
          Supported runtimes.
               Type: String
               Valid Values: nodejs | nodejs4.3 | nodejs6.10 | nodejs8.10 | nodejs10.x | nodejs12.x | nodejs14.x | nodejs16.x | java8 | java8.al2 | java11 | python2.7 | python3.6 | python3.7 | python3.8 | python3.9 | dotnetcore1.0 | dotnetcore2.0 | dotnetcore2.1 | dotnetcore3.1 | dotnet6 | dotnet8 | nodejs4.3-edge | go1.x | ruby2.5 | ruby2.7 | provided | provided.al2 | nodejs18.x | python3.10 | java17 | ruby3.2 | ruby3.3 | ruby3.4 | python3.11 | nodejs20.x | provided.al2023 | python3.12 | java21 | python3.13 | nodejs22.x
               
               Required: No
            
          
            
               
                  SnapStart
               
            
            
               The function's SnapStart setting.
               Type: SnapStart object
               Required: No
            
          
            
               
                  Tags
               
            
            
               A list of tags to apply to the
      function.
               Type: String to string map
               Required: No
            
          
            
               
                  Timeout
               
            
            
               The amount of time (in seconds) that Lambda allows a function to run before stopping it. The default is 3 seconds. The
      maximum allowed value is 900 seconds. For more information, see Lambda execution environment.
               Type: Integer
               Valid Range: Minimum value of 1.
               Required: No
            
          
            
               
                  TracingConfig
               
            
            
               Set Mode to Active to sample and trace a subset of incoming requests with
X-Ray.
               Type: TracingConfig object
               Required: No
            
          
            
               
                  VpcConfig
               
            
            
               For network connectivity to AWS resources in a VPC, specify a list of security groups and subnets in the VPC.
      When you connect a function to a VPC, it can access resources and the internet only through that VPC. For more
      information, see Configuring a Lambda function to access resources in a VPC.
               Type: VpcConfig object
               Required: No
            
         
    
      Response Syntax
      HTTP/1.1 201
Content-type: application/json

{
   "Architectures": [ "string" ],
   "CodeSha256": "string",
   "CodeSize": number,
   "DeadLetterConfig": { 
      "TargetArn": "string"
   },
   "Description": "string",
   "Environment": { 
      "Error": { 
         "ErrorCode": "string",
         "Message": "string"
      },
      "Variables": { 
         "string" : "string" 
      }
   },
   "EphemeralStorage": { 
      "Size": number
   },
   "FileSystemConfigs": [ 
      { 
         "Arn": "string",
         "LocalMountPath": "string"
      }
   ],
   "FunctionArn": "string",
   "FunctionName": "string",
   "Handler": "string",
   "ImageConfigResponse": { 
      "Error": { 
         "ErrorCode": "string",
         "Message": "string"
      },
      "ImageConfig": { 
         "Command": [ "string" ],
         "EntryPoint": [ "string" ],
         "WorkingDirectory": "string"
      }
   },
   "KMSKeyArn": "string",
   "LastModified": "string",
   "LastUpdateStatus": "string",
   "LastUpdateStatusReason": "string",
   "LastUpdateStatusReasonCode": "string",
   "Layers": [ 
      { 
         "Arn": "string",
         "CodeSize": number,
         "SigningJobArn": "string",
         "SigningProfileVersionArn": "string"
      }
   ],
   "LoggingConfig": { 
      "ApplicationLogLevel": "string",
      "LogFormat": "string",
      "LogGroup": "string",
      "SystemLogLevel": "string"
   },
   "MasterArn": "string",
   "MemorySize": number,
   "PackageType": "string",
   "RevisionId": "string",
   "Role": "string",
   "Runtime": "string",
   "RuntimeVersionConfig": { 
      "Error": { 
         "ErrorCode": "string",
         "Message": "string"
      },
      "RuntimeVersionArn": "string"
   },
   "SigningJobArn": "string",
   "SigningProfileVersionArn": "string",
   "SnapStart": { 
      "ApplyOn": "string",
      "OptimizationStatus": "string"
   },
   "State": "string",
   "StateReason": "string",
   "StateReasonCode": "string",
   "Timeout": number,
   "TracingConfig": { 
      "Mode": "string"
   },
   "Version": "string",
   "VpcConfig": { 
      "Ipv6AllowedForDualStack": boolean,
      "SecurityGroupIds": [ "string" ],
      "SubnetIds": [ "string" ],
      "VpcId": "string"
   }
}
    
      Response Elements
      If the action is successful, the service sends back an HTTP 201 response.
      The following data is returned in JSON format by the service.
      
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
      
            
               
                  Architectures
               
            
            
               The instruction set architecture that the function supports. Architecture is a string array with one of the 
      valid values. The default architecture value is x86_64.
               Type: Array of strings
               Array Members: Fixed number of 1 item.
               Valid Values: x86_64 | arm64
               
            
          
            
               
                  CodeSha256
               
            
            
               The SHA256 hash of the function's deployment package.
               Type: String
            
          
            
               
                  CodeSize
               
            
            
               The size of the function's deployment package, in bytes.
               Type: Long
            
          
            
               
                  DeadLetterConfig
               
            
            
               The function's dead letter queue.
               Type: DeadLetterConfig object
            
          
            
               
                  Description
               
            
            
               The function's description.
               Type: String
               Length Constraints: Minimum length of 0. Maximum length of 256.
            
          
            
               
                  Environment
               
            
            
               The function's environment variables. Omitted from AWS CloudTrail logs.
               Type: EnvironmentResponse object
            
          
            
               
                  EphemeralStorage
               
            
            
               The size of the function's /tmp directory in MB. The default value is 512, but can be any whole
  number between 512 and 10,240 MB. For more information, see Configuring ephemeral storage (console).
               Type: EphemeralStorage object
            
          
            
               
                  FileSystemConfigs
               
            
            
               Connection settings for an Amazon EFS file system.
               Type: Array of FileSystemConfig objects
               Array Members: Maximum number of 1 item.
            
          
            
               
                  FunctionArn
               
            
            
               The function's Amazon Resource Name (ARN).
               Type: String
               Pattern: arn:(aws[a-zA-Z-]*)?:lambda:[a-z]{2}(-gov)?-[a-z]+-\d{1}:\d{12}:function:[a-zA-Z0-9-_\.]+(:(\$LATEST|[a-zA-Z0-9-_]+))?
               
            
          
            
               
                  FunctionName
               
            
            
               The name of the function.
               Type: String
               Length Constraints: Minimum length of 1. Maximum length of 170.
               Pattern: (arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\d{1}:)?(\d{12}:)?(function:)?([a-zA-Z0-9-_\.]+)(:(\$LATEST|[a-zA-Z0-9-_]+))?
               
            
          
            
               
                  Handler
               
            
            
               The function that Lambda calls to begin running your function.
               Type: String
               Length Constraints: Maximum length of 128.
               Pattern: [^ ]+
               
            
          
            
               
                  ImageConfigResponse
               
            
            
               The function's image configuration values.
               Type: ImageConfigResponse object
            
          
            
               
                  KMSKeyArn
               
            
            
               The ARN of the AWS Key Management Service (AWS KMS) customer managed key that's used to encrypt the following resources:
               
                   
                   
                   
                   
               
                     The function's environment variables.
                  
                     The function's Lambda SnapStart snapshots.
                  
                     When used with SourceKMSKeyArn, the unzipped version of the .zip deployment package that's used for function invocations. For more information, see 
          Specifying a customer managed key for Lambda.
                  
                     The optimized version of the container image that's used for function invocations. Note that this is not the same key that's used to protect your container image in the Amazon Elastic Container Registry (Amazon ECR). For more information, see Function lifecycle.
                  
               If you don't provide a customer managed key, Lambda uses an AWS owned key or an AWS managed key.
               Type: String
               Pattern: (arn:(aws[a-zA-Z-]*)?:[a-z0-9-.]+:.*)|()
               
            
          
            
               
                  LastModified
               
            
            
               The date and time that the function was last updated, in ISO-8601 format (YYYY-MM-DDThh:mm:ss.sTZD).
               Type: String
            
          
            
               
                  LastUpdateStatus
               
            
            
               The status of the last update that was performed on the function. This is first set to Successful
      after function creation completes.
               Type: String
               Valid Values: Successful | Failed | InProgress
               
            
          
            
               
                  LastUpdateStatusReason
               
            
            
               The reason for the last update that was performed on the function.
               Type: String
            
          
            
               
                  LastUpdateStatusReasonCode
               
            
            
               The reason code for the last update that was performed on the function.
               Type: String
               Valid Values: EniLimitExceeded | InsufficientRolePermissions | InvalidConfiguration | InternalError | SubnetOutOfIPAddresses | InvalidSubnet | InvalidSecurityGroup | ImageDeleted | ImageAccessDenied | InvalidImage | KMSKeyAccessDenied | KMSKeyNotFound | InvalidStateKMSKey | DisabledKMSKey | EFSIOError | EFSMountConnectivityError | EFSMountFailure | EFSMountTimeout | InvalidRuntime | InvalidZipFileException | FunctionError
               
            
          
            
               
                  Layers
               
            
            
               The function's layers.
               Type: Array of Layer objects
            
          
            
               
                  LoggingConfig
               
            
            
               The function's Amazon CloudWatch Logs configuration settings.
               Type: LoggingConfig object
            
          
            
               
                  MasterArn
               
            
            
               For Lambda@Edge functions, the ARN of the main function.
               Type: String
               Pattern: arn:(aws[a-zA-Z-]*)?:lambda:[a-z]{2}(-gov)?-[a-z]+-\d{1}:\d{12}:function:[a-zA-Z0-9-_]+(:(\$LATEST|[a-zA-Z0-9-_]+))?
               
            
          
            
               
                  MemorySize
               
            
            
               The amount of memory available to the function at runtime.
               Type: Integer
               Valid Range: Minimum value of 128. Maximum value of 10240.
            
          
            
               
                  PackageType
               
            
            
               The type of deployment package. Set to Image for container image and set Zip for .zip file archive.
               Type: String
               Valid Values: Zip | Image
               
            
          
            
               
                  RevisionId
               
            
            
               The latest updated revision of the function or alias.
               Type: String
            
          
            
               
                  Role
               
            
            
               The function's execution role.
               Type: String
               Pattern: arn:(aws[a-zA-Z-]*)?:iam::\d{12}:role/?[a-zA-Z_0-9+=,.@\-_/]+
               
            
          
            
               
                  Runtime
               
            
            
               The identifier of the function's 
          runtime. Runtime is required if the deployment package is a .zip file archive. Specifying a runtime results in
          an error if you're deploying a function using a container image.
               The following list includes deprecated runtimes. Lambda blocks creating new functions and updating existing
          functions shortly after each runtime is deprecated. For more information, see
          Runtime use after deprecation.
               For a list of all currently supported runtimes, see
          Supported runtimes.
               Type: String
               Valid Values: nodejs | nodejs4.3 | nodejs6.10 | nodejs8.10 | nodejs10.x | nodejs12.x | nodejs14.x | nodejs16.x | java8 | java8.al2 | java11 | python2.7 | python3.6 | python3.7 | python3.8 | python3.9 | dotnetcore1.0 | dotnetcore2.0 | dotnetcore2.1 | dotnetcore3.1 | dotnet6 | dotnet8 | nodejs4.3-edge | go1.x | ruby2.5 | ruby2.7 | provided | provided.al2 | nodejs18.x | python3.10 | java17 | ruby3.2 | ruby3.3 | ruby3.4 | python3.11 | nodejs20.x | provided.al2023 | python3.12 | java21 | python3.13 | nodejs22.x
               
            
          
            
               
                  RuntimeVersionConfig
               
            
            
               The ARN of the runtime and any errors that occured.
               Type: RuntimeVersionConfig object
            
          
            
               
                  SigningJobArn
               
            
            
               The ARN of the signing job.
               Type: String
               Pattern: arn:(aws[a-zA-Z0-9-]*):([a-zA-Z0-9\-])+:([a-z]{2}(-gov)?-[a-z]+-\d{1})?:(\d{12})?:(.*)
               
            
          
            
               
                  SigningProfileVersionArn
               
            
            
               The ARN of the signing profile version.
               Type: String
               Pattern: arn:(aws[a-zA-Z0-9-]*):([a-zA-Z0-9\-])+:([a-z]{2}(-gov)?-[a-z]+-\d{1})?:(\d{12})?:(.*)
               
            
          
            
               
                  SnapStart
               
            
            
               Set ApplyOn to PublishedVersions to create a snapshot of the initialized execution
      environment when you publish a function version. For more information, see Improving startup performance with Lambda SnapStart.
               Type: SnapStartResponse object
            
          
            
               
                  State
               
            
            
               The current state of the function. When the state is Inactive, you can reactivate the function by
      invoking it.
               Type: String
               Valid Values: Pending | Active | Inactive | Failed
               
            
          
            
               
                  StateReason
               
            
            
               The reason for the function's current state.
               Type: String
            
          
            
               
                  StateReasonCode
               
            
            
               The reason code for the function's current state. When the code is Creating, you can't invoke or
      modify the function.
               Type: String
               Valid Values: Idle | Creating | Restoring | EniLimitExceeded | InsufficientRolePermissions | InvalidConfiguration | InternalError | SubnetOutOfIPAddresses | InvalidSubnet | InvalidSecurityGroup | ImageDeleted | ImageAccessDenied | InvalidImage | KMSKeyAccessDenied | KMSKeyNotFound | InvalidStateKMSKey | DisabledKMSKey | EFSIOError | EFSMountConnectivityError | EFSMountFailure | EFSMountTimeout | InvalidRuntime | InvalidZipFileException | FunctionError
               
            
          
            
               
                  Timeout
               
            
            
               The amount of time in seconds that Lambda allows a function to run before stopping it.
               Type: Integer
               Valid Range: Minimum value of 1.
            
          
            
               
                  TracingConfig
               
            
            
               The function's AWS X-Ray tracing configuration.
               Type: TracingConfigResponse object
            
          
            
               
                  Version
               
            
            
               The version of the Lambda function.
               Type: String
               Length Constraints: Minimum length of 1. Maximum length of 1024.
               Pattern: (\$LATEST|[0-9]+)
               
            
          
            
               
                  VpcConfig
               
            
            
               The function's networking configuration.
               Type: VpcConfigResponse object
            
         
    
      Errors
      For information about the errors that are common to all actions, see Common Errors.
      
          
          
          
          
          
          
          
          
          
      
            
               
                  CodeSigningConfigNotFoundException
               
            
            
               The specified code signing configuration does not exist.
               HTTP Status Code: 404
            
          
            
               
                  CodeStorageExceededException
               
            
            
               Your AWS account has exceeded its maximum total code size. For more information, see Lambda quotas.
               HTTP Status Code: 400
            
          
            
               
                  CodeVerificationFailedException
               
            
            
               The code signature failed one or more of the validation checks for signature mismatch or expiry, and the code
      signing policy is set to ENFORCE. Lambda blocks the deployment.
               HTTP Status Code: 400
            
          
            
               
                  InvalidCodeSignatureException
               
            
            
               The code signature failed the integrity check. If the integrity check fails, then Lambda blocks
      deployment, even if the code signing policy is set to WARN.
               HTTP Status Code: 400
            
          
            
               
                  InvalidParameterValueException
               
            
            
               One of the parameters in the request is not valid.
               HTTP Status Code: 400
            
          
            
               
                  ResourceConflictException
               
            
            
               The resource already exists, or another operation is in progress.
               HTTP Status Code: 409
            
          
            
               
                  ResourceNotFoundException
               
            
            
               The resource specified in the request does not exist.
               HTTP Status Code: 404
            
          
            
               
                  ServiceException
               
            
            
               The AWS Lambda service encountered an internal error.
               HTTP Status Code: 500
            
          
            
               
                  TooManyRequestsException
               
            
            
               The request throughput limit was exceeded. For more information, see Lambda quotas.
               HTTP Status Code: 429
            
         
    
      See Also
      For more information about using this API in one of the language-specific AWS SDKs, see the following:
      
          
          
          
          
          
          
          
          
          
          
      
            
               AWS Command Line Interface
            
         
            
               AWS SDK for .NET
            
         
            
               AWS SDK for C++
            
         
            
               AWS SDK for Go v2
            
         
            
               AWS SDK for Java V2
            
         
            
               AWS SDK for JavaScript V3
            
         
            
               AWS SDK for Kotlin
            
         
            
               AWS SDK for PHP V3
            
         
            
               AWS SDK for Python
            
         
            
               AWS SDK for Ruby V3
            
         
   Document ConventionsCreateEventSourceMappingCreateFunctionUrlConfigDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS Command Line InterfaceUser Guide for Version 2AWS CLI install and update
                instructionsTroubleshooting AWS CLI install and uninstall
                errorsNext stepsInstalling or updating to the latest version of
            the AWS CLIThis topic describes how to install or update the latest release of the AWS Command Line Interface (AWS CLI)
        on supported operating systems. For information on the latest releases of AWS CLI, see the
            AWS CLI version 2
            Changelog on GitHub.To install a past release of the AWS CLI, see Installing past releases of the AWS CLI version 2. For
        uninstall instructions, see Uninstalling the AWS CLI version 2.ImportantAWS CLI versions 1 and 2 use the same aws command name. If you previously
            installed AWS CLI version 1, see Migration guide for the AWS CLI version 2.TopicsAWS CLI install and update
                instructionsTroubleshooting AWS CLI install and uninstall
                errorsNext steps
        AWS CLI install and update
                instructions
        For installation instructions, expand the section for your operating system.
        
                    Install and update requirements
                
                    
                     
                     
                     
                     
                
                        You must be able to extract or "unzip" the downloaded package. If
                            your operating system doesn't have the built-in unzip
                            command, use an equivalent.
                    
                        The AWS CLI uses glibc, groff, and
                            less. These are included by default in most major
                            distributions of Linux.
                    
                        We support the AWS CLI on 64-bit versions of recent distributions of
                            CentOS, Fedora, Ubuntu, Amazon Linux 1, Amazon Linux 2, Amazon Linux 2023, and Linux
                            ARM.
                    
                        Because AWS doesn't maintain third-party repositories other than
                                snap, we can’t guarantee that they contain the latest
                            version of the AWS CLI.
                    
                    Install or
                        update the AWS CLI
                WarningIf this is your first time updating on Amazon Linux, to install the latest
                        version of the AWS CLI, you must uninstall the pre-installed
                        yum version using the following command:$ sudo yum remove awscliAfter the yum installation of the AWS CLI is removed,
                        follow the below Linux install instructions.
                You can install the AWS CLI by using one of the following methods:
                    
                         
                         
                    
                            The command line installer is
                                good option for version control, as you can specify the version to
                                install. This option does not auto-update and you must download a
                                new installer each time you update to overwrite previous
                                version.
                        
                            The officially supported snap
                                    package is a good option to always have the latest
                                version of the AWS CLI as snap packages automatically refresh. There
                                is no built-in support for selecting minor versions of AWS CLI and
                                therefore is not an optimal install method if your team needs to pin
                                versions.
                        
                
                    Command line installer - Linux x86 (64-bit)
                                To update your current installation of AWS CLI, download a new
                                    installer each time you update to overwrite previous versions.
                                    Follow these steps from the command line to install the AWS CLI on
                                    Linux.
                                The following are quick installation steps in a single copy
                                    and paste group that provide a basic installation. For guided
                                    instructions, see the steps that follow.
                                            Note(Optional)
                                                  The following command block downloads and installs
                                                  the AWS CLI without first verifying the integrity of
                                                  your download. To verify the integrity of your
                                                  download, use the below step by step
                                                  instructions.
                                            To install the
                                                AWS CLI, run the following commands.
                                            $ curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
unzip awscliv2.zip
sudo ./aws/install
                                            To update your current
                                        installation of the AWS CLI, add your existing
                                    symlink and installer information to construct the
                                        install command using the
                                        --bin-dir, --install-dir, and
                                        --update parameters. The following command
                                    block uses an example symlink of
                                        /usr/local/bin and example
                                    installer location of
                                        /usr/local/aws-cli to install the
                                    AWS CLI locally for the current user.
                                            $ curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
unzip awscliv2.zip
sudo ./aws/install --bin-dir /usr/local/bin --install-dir /usr/local/aws-cli --update
                                Guided installation steps
                                        Download the installation file in one of the following
                                            ways:
                                                  
                                                   
                                                   
                                                  
                                                  Use the
                                                  curl command – The
                                                  -o option specifies the file name
                                                  that the downloaded package is written to. The
                                                  options on the following example command write the
                                                  downloaded file to the current directory with the
                                                  local name awscliv2.zip. 
                                                  $ curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
                                                  
                                                  Downloading from the
                                                  URL – To download the installer
                                                  with your browser, use the following URL: https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip
                                                  
                                    
                                        (Optional) Verifying the
                                                integrity of your downloaded zip
                                            file
                                        If you chose to manually download the AWS CLI installer
                                            package .zip in the above steps,
                                            you can use the following steps to verify the signatures
                                            by using the GnuPG tool.
                                        The AWS CLI installer package .zip
                                            files are cryptographically signed using PGP signatures.
                                            If there is any damage or alteration of the files, this
                                            verification fails and you should not proceed with
                                            installation.
                                        
                                                Download and install the gpg
                                                  command using your package manager. For more
                                                  information about GnuPG, see the
                                                  GnuPG
                                                  website. 
                                            
                                                To create the public key file, create a text
                                                  file and paste in the following text.
                                                -----BEGIN PGP PUBLIC KEY BLOCK-----

mQINBF2Cr7UBEADJZHcgusOJl7ENSyumXh85z0TRV0xJorM2B/JL0kHOyigQluUG
ZMLhENaG0bYatdrKP+3H91lvK050pXwnO/R7fB/FSTouki4ciIx5OuLlnJZIxSzx
PqGl0mkxImLNbGWoi6Lto0LYxqHN2iQtzlwTVmq9733zd3XfcXrZ3+LblHAgEt5G
TfNxEKJ8soPLyWmwDH6HWCnjZ/aIQRBTIQ05uVeEoYxSh6wOai7ss/KveoSNBbYz
gbdzoqI2Y8cgH2nbfgp3DSasaLZEdCSsIsK1u05CinE7k2qZ7KgKAUIcT/cR/grk
C6VwsnDU0OUCideXcQ8WeHutqvgZH1JgKDbznoIzeQHJD238GEu+eKhRHcz8/jeG
94zkcgJOz3KbZGYMiTh277Fvj9zzvZsbMBCedV1BTg3TqgvdX4bdkhf5cH+7NtWO
lrFj6UwAsGukBTAOxC0l/dnSmZhJ7Z1KmEWilro/gOrjtOxqRQutlIqG22TaqoPG
fYVN+en3Zwbt97kcgZDwqbuykNt64oZWc4XKCa3mprEGC3IbJTBFqglXmZ7l9ywG
EEUJYOlb2XrSuPWml39beWdKM8kzr1OjnlOm6+lpTRCBfo0wa9F8YZRhHPAkwKkX
XDeOGpWRj4ohOx0d2GWkyV5xyN14p2tQOCdOODmz80yUTgRpPVQUtOEhXQARAQAB
tCFBV1MgQ0xJIFRlYW0gPGF3cy1jbGlAYW1hem9uLmNvbT6JAlQEEwEIAD4CGwMF
CwkIBwIGFQoJCAsCBBYCAwECHgECF4AWIQT7Xbd/1cEYuAURraimMQrMRnJHXAUC
ZqFYbwUJCv/cOgAKCRCmMQrMRnJHXKYuEAC+wtZ611qQtOl0t5spM9SWZuszbcyA
0xBAJq2pncnp6wdCOkuAPu4/R3UCIoD2C49MkLj9Y0Yvue8CCF6OIJ8L+fKBv2DI
yWZGmHL0p9wa/X8NCKQrKxK1gq5PuCzi3f3SqwfbZuZGeK/ubnmtttWXpUtuU/Iz
VR0u/0sAy3j4uTGKh2cX7XnZbSqgJhUk9H324mIJiSwzvw1Ker6xtH/LwdBeJCck
bVBdh3LZis4zuD4IZeBO1vRvjot3Oq4xadUv5RSPATg7T1kivrtLCnwvqc6L4LnF
0OkNysk94L3LQSHyQW2kQS1cVwr+yGUSiSp+VvMbAobAapmMJWP6e/dKyAUGIX6+
2waLdbBs2U7MXznx/2ayCLPH7qCY9cenbdj5JhG9ibVvFWqqhSo22B/URQE/CMrG
+3xXwtHEBoMyWEATr1tWwn2yyQGbkUGANneSDFiTFeoQvKNyyCFTFO1F2XKCcuDs
19nj34PE2TJilTG2QRlMr4D0NgwLLAMg2Los1CK6nXWnImYHKuaKS9LVaCoC8vu7
IRBik1NX6SjrQnftk0M9dY+s0ZbAN1gbdjZ8H3qlbl/4TxMdr87m8LP4FZIIo261
Eycv34pVkCePZiP+dgamEiQJ7IL4ZArio9mv6HbDGV6mLY45+l6/0EzCwkI5IyIf
BfWC9s/USgxchg==
=ptgS
-----END PGP PUBLIC KEY BLOCK-----
                                                For reference, the following are the details
                                                  of the public key.
                                                Key ID:           A6310ACC4672475C
Type:             RSA
Size:             4096/4096
Created:          2019-09-18
Expires:          2025-07-24
User ID:          AWS CLI Team <aws-cli@amazon.com>
Key fingerprint:  FB5D B77F D5C1 18B8 0511  ADA8 A631 0ACC 4672 475C
                                            
                                                Import the AWS CLI public key with the following
                                                  command, substituting
                                                  public-key-file-name
                                                  with the file name of the public key you
                                                  created.
                                                $ gpg --import public-key-file-name
gpg: /home/username/.gnupg/trustdb.gpg: trustdb created
gpg: key A6310ACC4672475C: public key "AWS CLI Team <aws-cli@amazon.com>" imported
gpg: Total number processed: 1
gpg:               imported: 1
                                            
                                                Download the AWS CLI signature file for the
                                                  package you downloaded. It has the same path and
                                                  name as the .zip file it corresponds
                                                  to, but has the extension .sig. In
                                                  the following examples, we save it to the current
                                                  directory as a file named
                                                  awscliv2.sig.
                                                  For the latest version
                                                  of the AWS CLI, use the following command
                                                  block:
                                                  $ curl -o awscliv2.sig https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip.sig
                                                  For a specific version
                                                  of the AWS CLI, append a hyphen and the
                                                  version number to the filename. For this example
                                                  the filename for version
                                                  2.0.30 would be
                                                  awscli-exe-linux-x86_64-2.0.30.zip.sig
                                                  resulting in the following command:
                                                  $ curl -o awscliv2.sig https://awscli.amazonaws.com/awscli-exe-linux-x86_64-2.0.30.zip.sig
                                                   For a list of versions, see the AWS CLI version 2 Changelog on GitHub.
                                            
                                                Verify the signature, passing both the
                                                  downloaded .sig and
                                                  .zip file names as parameters to the
                                                  gpg command.
                                                $ gpg --verify awscliv2.sig awscliv2.zip
                                                The output should look similar to the
                                                  following.
                                                gpg: Signature made Mon Nov  4 19:00:01 2019 PST
gpg:                using RSA key FB5D B77F D5C1 18B8 0511 ADA8 A631 0ACC 4672 475C
gpg: Good signature from "AWS CLI Team <aws-cli@amazon.com>" [unknown]
gpg: WARNING: This key is not certified with a trusted signature!
gpg:          There is no indication that the signature belongs to the owner.
Primary key fingerprint: FB5D B77F D5C1 18B8 0511  ADA8 A631 0ACC 4672 475C
                                                ImportantThe warning in the output is expected and
                                                  doesn't indicate a problem. It occurs because
                                                  there isn't a chain of trust between your personal
                                                  PGP key (if you have one) and the AWS CLI PGP key.
                                                  For more information, see Web of trust.
                                            
                                    
                                        Unzip the installer. If your Linux distribution
                                            doesn't have a built-in unzip command, use
                                            an equivalent to unzip it. The following example command
                                            unzips the package and creates a directory named
                                                aws under the current
                                            directory.
                                        $ unzip awscliv2.zip
                                        NoteWhen updating from a previous version, the
                                                  unzip command prompts to overwrite
                                                existing files. To skip these prompts, such as with
                                                script automation, use the -u update
                                                flag for unzip. This flag automatically
                                                updates existing files and creates new ones as
                                                needed.$ unzip -u awscliv2.zip
                                    
                                        Run the install program. The installation command uses
                                            a file named install in the newly
                                            unzipped aws directory. By default,
                                            the files are all installed to
                                                /usr/local/aws-cli, and a
                                            symbolic link is created in
                                                /usr/local/bin. The command
                                            includes sudo to grant write permissions to
                                            those directories. 
                                        $ sudo ./aws/install
                                        You can install without sudo if you
                                            specify directories that you already have write
                                            permissions to. Use the following instructions for the
                                                install command to specify the
                                            installation location:
                                        
                                             
                                             
                                             
                                        
                                                Ensure that the paths you provide to the
                                                  -i and -b parameters
                                                  contain no volume name or directory names that
                                                  contain any space characters or other white space
                                                  characters. If there is a space, the installation
                                                  fails.
                                            
                                                --install-dir or -i
                                                  – This option specifies the directory to
                                                  copy all of the files to.
                                                The default value is
                                                  /usr/local/aws-cli.
                                            
                                                --bin-dir or -b
                                                  – This option specifies that the main
                                                  aws program in the install directory
                                                  is symbolically linked to the file
                                                  aws in the specified path.
                                                  You must have write permissions to the specified
                                                  directory. Creating a symlink to a directory that
                                                  is already in your path eliminates the need to add
                                                  the install directory to the user's
                                                  $PATH variable. 
                                                The default value is
                                                  /usr/local/bin.
                                            
                                        $ ./aws/install -i /usr/local/aws-cli -b /usr/local/bin
                                        NoteTo update your current installation of the AWS CLI,
                                                add your existing symlink and installer information
                                                to construct the install command with
                                                the --update parameter.$ sudo ./aws/install --bin-dir /usr/local/bin --install-dir /usr/local/aws-cli --updateTo locate the existing symlink and installation
                                                directory, use the following steps:
                                                 
                                                 
                                            
                                                  Use the which command to find
                                                  your symlink. This gives you the path to use with
                                                  the --bin-dir parameter.
                                                  $ which aws
/usr/local/bin/aws
                                                
                                                  Use the ls command to find the
                                                  directory that your symlink points to. This gives
                                                  you the path to use with the
                                                  --install-dir parameter.
                                                  $ ls -l /usr/local/bin/aws
lrwxrwxrwx 1 ec2-user ec2-user 49 Oct 22 09:49 /usr/local/bin/aws -> /usr/local/aws-cli/v2/current/bin/aws
                                                
                                    
                                        Confirm the installation with the following command. 
                                        $ aws --version
aws-cli/2.25.11 Python/3.11.6 Linux/5.10.205-195.807.amzn2.x86_64 
                                        If the aws command cannot be found, you
                                            might need to restart your terminal or follow the
                                            troubleshooting in Troubleshooting errors for the AWS CLI.
                                    
                            
                        Command line - Linux ARM
                                To update your current installation of AWS CLI, download a new
                                    installer each time you update to overwrite previous versions.
                                    Follow these steps from the command line to install the AWS CLI on
                                    Linux.
                                The following are quick installation steps in a single copy
                                    and paste group that provide a basic installation. For guided
                                    instructions, see the steps that follow.
                                Note(Optional) The following
                                        command block downloads and installs the AWS CLI without first
                                        verifying the integrity of your download. To verify the
                                        integrity of your download, use the below step by step
                                        instructions.
                                To install the AWS CLI, run the
                                    following commands.
                                $ curl "https://awscli.amazonaws.com/awscli-exe-linux-aarch64.zip" -o "awscliv2.zip"
unzip awscliv2.zip
sudo ./aws/install
                                To update your current
                                        installation of the AWS CLI, add your existing
                                    symlink and installer information to construct the
                                        install command using the
                                        --bin-dir, --install-dir, and
                                        --update parameters. The following command
                                    block uses an example symlink of
                                        /usr/local/bin and example
                                    installer location of
                                        /usr/local/aws-cli.
                                $ curl "https://awscli.amazonaws.com/awscli-exe-linux-aarch64.zip" -o "awscliv2.zip"
unzip awscliv2.zip
sudo ./aws/install --bin-dir /usr/local/bin --install-dir /usr/local/aws-cli --update
                                Guided installation steps
                                        Download the installation file in one of the following
                                            ways:
                                        
                                             
                                             
                                        
                                                Use the
                                                  curl command – The
                                                  -o option specifies the file name
                                                  that the downloaded package is written to. The
                                                  options on the following example command write the
                                                  downloaded file to the current directory with the
                                                  local name awscliv2.zip. 
                                                $ curl "https://awscli.amazonaws.com/awscli-exe-linux-aarch64.zip" -o "awscliv2.zip"
                                            
                                                Downloading from the
                                                  URL – To download the installer
                                                  with your browser, use the following URL: https://awscli.amazonaws.com/awscli-exe-linux-aarch64.zip
                                            
                                    
                                        (Optional) Verifying the
                                                integrity of your downloaded zip
                                            file
                                        If you chose to manually download the AWS CLI installer
                                            package .zip in the above steps,
                                            you can use the following steps to verify the signatures
                                            by using the GnuPG tool.
                                        The AWS CLI installer package .zip
                                            files are cryptographically signed using PGP signatures.
                                            If there is any damage or alteration of the files, this
                                            verification fails and you should not proceed with
                                            installation.
                                        
                                                Download and install the gpg
                                                  command using your package manager. For more
                                                  information about GnuPG, see the
                                                  GnuPG
                                                  website. 
                                            
                                                To create the public key file, create a text
                                                  file and paste in the following text.
                                                -----BEGIN PGP PUBLIC KEY BLOCK-----

mQINBF2Cr7UBEADJZHcgusOJl7ENSyumXh85z0TRV0xJorM2B/JL0kHOyigQluUG
ZMLhENaG0bYatdrKP+3H91lvK050pXwnO/R7fB/FSTouki4ciIx5OuLlnJZIxSzx
PqGl0mkxImLNbGWoi6Lto0LYxqHN2iQtzlwTVmq9733zd3XfcXrZ3+LblHAgEt5G
TfNxEKJ8soPLyWmwDH6HWCnjZ/aIQRBTIQ05uVeEoYxSh6wOai7ss/KveoSNBbYz
gbdzoqI2Y8cgH2nbfgp3DSasaLZEdCSsIsK1u05CinE7k2qZ7KgKAUIcT/cR/grk
C6VwsnDU0OUCideXcQ8WeHutqvgZH1JgKDbznoIzeQHJD238GEu+eKhRHcz8/jeG
94zkcgJOz3KbZGYMiTh277Fvj9zzvZsbMBCedV1BTg3TqgvdX4bdkhf5cH+7NtWO
lrFj6UwAsGukBTAOxC0l/dnSmZhJ7Z1KmEWilro/gOrjtOxqRQutlIqG22TaqoPG
fYVN+en3Zwbt97kcgZDwqbuykNt64oZWc4XKCa3mprEGC3IbJTBFqglXmZ7l9ywG
EEUJYOlb2XrSuPWml39beWdKM8kzr1OjnlOm6+lpTRCBfo0wa9F8YZRhHPAkwKkX
XDeOGpWRj4ohOx0d2GWkyV5xyN14p2tQOCdOODmz80yUTgRpPVQUtOEhXQARAQAB
tCFBV1MgQ0xJIFRlYW0gPGF3cy1jbGlAYW1hem9uLmNvbT6JAlQEEwEIAD4CGwMF
CwkIBwIGFQoJCAsCBBYCAwECHgECF4AWIQT7Xbd/1cEYuAURraimMQrMRnJHXAUC
ZqFYbwUJCv/cOgAKCRCmMQrMRnJHXKYuEAC+wtZ611qQtOl0t5spM9SWZuszbcyA
0xBAJq2pncnp6wdCOkuAPu4/R3UCIoD2C49MkLj9Y0Yvue8CCF6OIJ8L+fKBv2DI
yWZGmHL0p9wa/X8NCKQrKxK1gq5PuCzi3f3SqwfbZuZGeK/ubnmtttWXpUtuU/Iz
VR0u/0sAy3j4uTGKh2cX7XnZbSqgJhUk9H324mIJiSwzvw1Ker6xtH/LwdBeJCck
bVBdh3LZis4zuD4IZeBO1vRvjot3Oq4xadUv5RSPATg7T1kivrtLCnwvqc6L4LnF
0OkNysk94L3LQSHyQW2kQS1cVwr+yGUSiSp+VvMbAobAapmMJWP6e/dKyAUGIX6+
2waLdbBs2U7MXznx/2ayCLPH7qCY9cenbdj5JhG9ibVvFWqqhSo22B/URQE/CMrG
+3xXwtHEBoMyWEATr1tWwn2yyQGbkUGANneSDFiTFeoQvKNyyCFTFO1F2XKCcuDs
19nj34PE2TJilTG2QRlMr4D0NgwLLAMg2Los1CK6nXWnImYHKuaKS9LVaCoC8vu7
IRBik1NX6SjrQnftk0M9dY+s0ZbAN1gbdjZ8H3qlbl/4TxMdr87m8LP4FZIIo261
Eycv34pVkCePZiP+dgamEiQJ7IL4ZArio9mv6HbDGV6mLY45+l6/0EzCwkI5IyIf
BfWC9s/USgxchg==
=ptgS
-----END PGP PUBLIC KEY BLOCK-----
                                                For reference, the following are the details
                                                  of the public key.
                                                Key ID:           A6310ACC4672475C
Type:             RSA
Size:             4096/4096
Created:          2019-09-18
Expires:          2025-07-24
User ID:          AWS CLI Team <aws-cli@amazon.com>
Key fingerprint:  FB5D B77F D5C1 18B8 0511  ADA8 A631 0ACC 4672 475C
                                            
                                                Import the AWS CLI public key with the following
                                                  command, substituting
                                                  public-key-file-name
                                                  with the file name of the public key you
                                                  created.
                                                $ gpg --import public-key-file-name
gpg: /home/username/.gnupg/trustdb.gpg: trustdb created
gpg: key A6310ACC4672475C: public key "AWS CLI Team <aws-cli@amazon.com>" imported
gpg: Total number processed: 1
gpg:               imported: 1
                                            
                                                Download the AWS CLI signature file for the
                                                  package you downloaded. It has the same path and
                                                  name as the .zip file it corresponds
                                                  to, but has the extension .sig. In
                                                  the following examples, we save it to the current
                                                  directory as a file named
                                                  awscliv2.sig.
                                                For the latest version
                                                  of the AWS CLI, use the following command
                                                  block:
                                                $ curl -o awscliv2.sig https://awscli.amazonaws.com/awscli-exe-linux-aarch64.zip.sig
                                                For a specific version
                                                  of the AWS CLI, append a hyphen and the
                                                  version number to the filename. For this example
                                                  the filename for version
                                                  2.0.30 would be
                                                  awscli-exe-linux-aarch64-2.0.30.zip.sig
                                                  resulting in the following command:
                                                $ curl -o awscliv2.sig https://awscli.amazonaws.com/awscli-exe-linux-aarch64-2.0.30.zip.sig
                                                 For a list of versions, see the AWS CLI version 2 Changelog on GitHub.
                                            
                                                Verify the signature, passing both the
                                                  downloaded .sig and
                                                  .zip file names as parameters to the
                                                  gpg command.
                                                $ gpg --verify awscliv2.sig awscliv2.zip
                                                The output should look similar to the
                                                  following.
                                                gpg: Signature made Mon Nov  4 19:00:01 2019 PST
gpg:                using RSA key FB5D B77F D5C1 18B8 0511 ADA8 A631 0ACC 4672 475C
gpg: Good signature from "AWS CLI Team <aws-cli@amazon.com>" [unknown]
gpg: WARNING: This key is not certified with a trusted signature!
gpg:          There is no indication that the signature belongs to the owner.
Primary key fingerprint: FB5D B77F D5C1 18B8 0511  ADA8 A631 0ACC 4672 475C
                                                ImportantThe warning in the output is expected and
                                                  doesn't indicate a problem. It occurs because
                                                  there isn't a chain of trust between your personal
                                                  PGP key (if you have one) and the AWS CLI PGP key.
                                                  For more information, see Web of trust.
                                            
                                    
                                        Unzip the installer. If your Linux distribution
                                            doesn't have a built-in unzip command, use
                                            an equivalent to unzip it. The following example command
                                            unzips the package and creates a directory named
                                                aws under the current
                                            directory.
                                        $ unzip awscliv2.zip
                                        NoteWhen updating from a previous version, the
                                                  unzip command prompts to overwrite
                                                existing files. To skip these prompts, such as with
                                                script automation, use the -u update
                                                flag for unzip. This flag automatically
                                                updates existing files and creates new ones as
                                                needed.$ unzip -u awscliv2.zip
                                    
                                        Run the install program. The installation command uses
                                            a file named install in the newly
                                            unzipped aws directory. By default,
                                            the files are all installed to
                                                /usr/local/aws-cli, and a
                                            symbolic link is created in
                                                /usr/local/bin. The command
                                            includes sudo to grant write permissions to
                                            those directories. 
                                        $ sudo ./aws/install
                                        You can install without sudo if you
                                            specify directories that you already have write
                                            permissions to. Use the following instructions for the
                                                install command to specify the
                                            installation location:
                                        
                                             
                                             
                                             
                                        
                                                Ensure that the paths you provide to the
                                                  -i and -b parameters
                                                  contain no volume name or directory names that
                                                  contain any space characters or other white space
                                                  characters. If there is a space, the installation
                                                  fails.
                                            
                                                --install-dir or -i
                                                  – This option specifies the directory to
                                                  copy all of the files to.
                                                The default value is
                                                  /usr/local/aws-cli.
                                            
                                                --bin-dir or -b
                                                  – This option specifies that the main
                                                  aws program in the install directory
                                                  is symbolically linked to the file
                                                  aws in the specified path.
                                                  You must have write permissions to the specified
                                                  directory. Creating a symlink to a directory that
                                                  is already in your path eliminates the need to add
                                                  the install directory to the user's
                                                  $PATH variable. 
                                                The default value is
                                                  /usr/local/bin.
                                            
                                        $ ./aws/install -i /usr/local/aws-cli -b /usr/local/bin
                                        NoteTo update your current installation of the AWS CLI,
                                                add your existing symlink and installer information
                                                to construct the install command with
                                                the --update parameter.$ sudo ./aws/install --bin-dir /usr/local/bin --install-dir /usr/local/aws-cli --updateTo locate the existing symlink and installation
                                                directory, use the following steps:
                                                 
                                                 
                                            
                                                  Use the which command to find
                                                  your symlink. This gives you the path to use with
                                                  the --bin-dir parameter.
                                                  $ which aws
/usr/local/bin/aws
                                                
                                                  Use the ls command to find the
                                                  directory that your symlink points to. This gives
                                                  you the path to use with the
                                                  --install-dir parameter.
                                                  $ ls -l /usr/local/bin/aws
lrwxrwxrwx 1 ec2-user ec2-user 49 Oct 22 09:49 /usr/local/bin/aws -> /usr/local/aws-cli/v2/current/bin/aws
                                                
                                    
                                        Confirm the installation with the following command. 
                                        $ aws --version
aws-cli/2.25.11 Python/3.11.6 Linux/5.10.205-195.807.amzn2.x86_64 
                                        If the aws command cannot be found, you
                                            might need to restart your terminal or follow the
                                            troubleshooting in Troubleshooting errors for the AWS CLI.
                                    
                            
                    Snap package
                                We provide an official AWS supported version of the AWS CLI on
                                        snap. If you want to always have the latest
                                    version of the AWS CLI installed on your system, a snap package
                                    provides this for you as it auto-updates. There is no built-in
                                    support for selecting minor versions of AWS CLI and therefore it
                                    is not an optimal install method if your team needs to pin
                                    versions. If you want to install a specific minor version of the
                                    AWS CLI, we suggest you use the command line installer.
                                
                                        If your Linux platform does not already have
                                                snap installed, install
                                                snap on your platform. 
                                        
                                                For information on installing
                                                  snap, see Installing the daemon in the Snap
                                                  documentation.
                                            
                                                You may need to restart your system so that
                                                  your PATH variables are updated
                                                  correctly. If you are having installation issues,
                                                  follow steps in Fix common issues in the Snap
                                                  documentation.
                                            
                                                To verify that snap is installed
                                                  correctly, run the following command.
                                                $ snap version
                                            
                                    
                                        Run the following snap install command
                                            for the AWS CLI.
                                        $ snap install aws-cli --classic
                                        Depending on your permissions, you may need to add
                                                sudo to the command.
                                        $ sudo snap install aws-cli --classic
                                        NoteTo view the snap repository for the AWS CLI,
                                                including additional snap instructions,
                                                see the aws-cli page in the
                                                  Canonical Snapcraft
                                                  website.
                                    
                                        Verify that the AWS CLI installed correctly.
                                        $ aws --version
aws-cli/2.25.11 Python/3.11.6 Linux/5.10.205-195.807.amzn2.x86_64 
                                        If you get an error, see Troubleshooting errors for the AWS CLI.
                                    
                            
                
                
        
                    Install and update
                            requirements
                    
                         
                         
                    
                            We support the AWS CLI on macOS versions 11 and later. For more
                                information, see macOS support policy updates for the AWS CLI v2 on the
                                    AWS Developer Tools
                                Blog.
                        
                            Because AWS doesn't maintain third-party repositories, we can’t
                                guarantee that they contain the latest version of the AWS CLI.
                        
                    
                    
    macOS version support matrix
    
                
                    AWS CLI version
                    Supported macOS version
                
            
                
                    2.21.0 – current
                    11+
                
                
                    2.17.0 –2.20.0
                    10.15+
                
                
                    2.0.0 – 2.16.12
                    10.14 and below
                
            

                 
                    Install or update the
                            AWS CLI
                    If you are updating to the latest version, use the same installation
                        method that you used in your current version. You can install the AWS CLI on
                        macOS in the following ways.
                    
                        GUI installer
                                The following steps show how to install the latest version
                                        of the AWS CLI by using the standard macOS user interface and
                                        your browser.
                                        In your browser, download the macOS
                                                pkg file: https://awscli.amazonaws.com/AWSCLIV2.pkg
                                    
                                        Run your downloaded file and follow the on-screen
                                            instructions. You can choose to install the AWS CLI in the
                                            following ways:
                                        
                                             
                                             
                                        
                                                For all users on the
                                                  computer (requires
                                                  sudo)
                                                
                                                   
                                                   
                                                
                                                  You can install to any folder, or choose the
                                                  recommended default folder of
                                                  /usr/local/aws-cli.
                                                  
                                                  The installer automatically creates a
                                                  symlink at /usr/local/bin/aws that
                                                  links to the main program in the installation
                                                  folder you chose.
                                                  
                                            
                                                For only the current
                                                  user (doesn't require
                                                  sudo)
                                                
                                                   
                                                   
                                                
                                                  You can install to any folder to which you
                                                  have write permission.
                                                  
                                                  Due to standard user permissions, after the
                              installer finishes, you must manually create a symlink file in your
                                $PATH that points to the aws and
                                aws_completer programs by using the following commands
                              at the command prompt. The default location for a symlink is
                                /usr/local/bin/:
                                                  $ ln -s /folder/installed/aws-cli/aws /usr/local/bin/aws
$ ln -s /folder/installed/aws-cli/aws_completer /usr/local/bin/aws_completer
                             If you don't have write permissions to the folder, you may need
                              to use sudo in your command. The following example uses
                                sudo with the default location for a symlink in
                                /usr/local/bin/:
                            $ sudo ln -s /folder/installed/aws-cli/aws /usr/local/bin/aws
$ sudo ln -s /folder/installed/aws-cli/aws_completer /usr/local/bin/aws_completer
                          
                                            
                                        NoteYou can view debug logs for the installation by
                                                pressing Cmd+L
                                                anywhere in the installer. This opens a log pane
                                                that enables you to filter and save the log. The log
                                                file is also automatically saved to
                                                  /var/log/install.log.
                                    
                                        To verify that the shell can find and run the
                                                aws command in your $PATH,
                                            use the following commands. 
                                        $ which aws
/usr/local/bin/aws 
$ aws --version
aws-cli/2.25.11 Python/3.11.6 Darwin/23.3.0
                                        If the aws command cannot be found, you
                                            might need to restart your terminal or follow the
                                            troubleshooting in Troubleshooting errors for the AWS CLI.
                                    
                            
                        Command line installer - All users
                                If you have sudo permissions, you can install the
                                    AWS CLI for all users on the computer. We provide the steps in one
                                    easy to copy and paste group. See the descriptions of each line
                                    in the following steps. 
                                $ curl "https://awscli.amazonaws.com/AWSCLIV2.pkg" -o "AWSCLIV2.pkg"
$ sudo installer -pkg AWSCLIV2.pkg -target /
                                Guided installation instructions
                                        Download the file using the curl command.
                                            The -o option specifies the file name that
                                            the downloaded package is written to. In this example,
                                            the file is written to
                                                AWSCLIV2.pkg in the
                                            current folder.
                                        $ curl "https://awscli.amazonaws.com/AWSCLIV2.pkg" -o "AWSCLIV2.pkg"
                                    
                                        Run the standard macOS installer program,
                                            specifying the downloaded .pkg file
                                            as the source. Use the -pkg parameter to
                                            specify the name of the package to install, and the
                                                -target / parameter for which drive to
                                            install the package to. The files are installed to
                                                /usr/local/aws-cli, and a
                                            symlink is automatically created in
                                                /usr/local/bin. You must
                                            include sudo on the command to grant write
                                            permissions to those folders. 
                                        $ sudo installer -pkg ./AWSCLIV2.pkg -target /
                                        After installation is complete, debug logs are written
                                            to /var/log/install.log.
                                    
                                        To verify that the shell can find and run the
                                                aws command in your $PATH,
                                            use the following commands. 
                                        $ which aws
/usr/local/bin/aws 
$ aws --version
aws-cli/2.25.11 Python/3.11.6 Darwin/23.3.0
                                        If the aws command cannot be found, you
                                            might need to restart your terminal or follow the
                                            troubleshooting in Troubleshooting errors for the AWS CLI.
                                    
                            
                        Command line - Current user
                                
                                        To specify which folder the AWS CLI is installed to, you
                                            must create an XML file with any file name. This file is
                                            an XML-formatted file that looks like the following
                                            example. Leave all values as shown, except you must
                                            replace the path
                                                /Users/myusername in line
                                            9 with the path to the folder you want the AWS CLI
                                            installed to. The folder must
                                                already exist, or the command fails. The
                                            following XML example, named
                                                choices.xml, specifies
                                            the installer to install the AWS CLI in the folder
                                                /Users/myusername, where it
                                            creates a folder named
                                            aws-cli.
                                        <?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
  <array>
    <dict>
      <key>choiceAttribute</key>
      <string>customLocation</string>
      <key>attributeSetting</key>
      <string>/Users/myusername</string>
      <key>choiceIdentifier</key>
      <string>default</string>
    </dict>
  </array>
</plist>
                                    
                                        Download the pkg installer using
                                            the curl command. The -o
                                            option specifies the file name that the downloaded
                                            package is written to. In this example, the file is
                                            written to AWSCLIV2.pkg
                                            in the current folder.
                                        $ curl "https://awscli.amazonaws.com/AWSCLIV2.pkg" -o "AWSCLIV2.pkg"
                                    
                                        Run the standard macOS installer program
                                            with the following options:
                                        
                                             
                                             
                                             
                                        
                                                Specify the name of the package to install by
                                                  using the -pkg parameter.
                                            
                                                Specify installing to a current user only by
                                                  setting the -target parameter to
                                                  CurrentUserHomeDirectory.
                                            
                                                Specify the path (relative to the current
                                                  folder) and name of the XML file that you created
                                                  in the -applyChoiceChangesXML
                                                  parameter.
                                            
                                        The following example installs the AWS CLI in the folder
                                                /Users/myusername/aws-cli.
                                        $ installer -pkg AWSCLIV2.pkg \
            -target CurrentUserHomeDirectory \
            -applyChoiceChangesXML choices.xml
                                    
                                        Because standard user permissions typically don't
                                            allow writing to folders in your $PATH, the
                                            installer in this mode doesn't try to add the symlinks
                                            to the aws and aws_completer
                                            programs. For the AWS CLI to run correctly, you must
                                            manually create the symlinks after the installer
                                            finishes. If your $PATH includes a folder
                                            you can write to and you specify the folder as the
                                            target's path, you can run the following command without
                                                sudo. If you don't have a writable
                                            folder in your $PATH, you must use
                                                sudo for permissions to write to the
                                            specified target folder. The default location for a
                                            symlink is /usr/local/bin/. Replace
                                                folder/installed with the path to your
                                            AWS CLI installation.
                                        $ sudo ln -s /folder/installed/aws-cli/aws /usr/local/bin/aws
$ sudo ln -s /folder/installed/aws-cli/aws_completer /usr/local/bin/aws_completer
                                        After installation is complete, debug logs are written
                                            to /var/log/install.log.
                                    
                                        To verify that the shell can find and run the
                                                aws command in your $PATH,
                                            use the following commands. 
                                        $ which aws
/usr/local/bin/aws 
$ aws --version
aws-cli/2.25.11 Python/3.11.6 Darwin/23.3.0
                                        If the aws command cannot be found, you
                                            might need to restart your terminal or follow the
                                            troubleshooting in Troubleshooting errors for the AWS CLI.
                                    
                            
                    
                
        
                    Install and update
                            requirements
                    
                         
                         
                    
                            We support the AWS CLI on Microsoft-supported versions of 64-bit
                                Windows.
                        
                            Admin rights to install software
                        
                 
                    Install or update the
                            AWS CLI
                    To update your current installation of AWS CLI on Windows, download a new
                        installer each time you update to overwrite previous versions. AWS CLI is
                        updated regularly. To see when the latest version was released, see the
                            AWS CLI version 2 Changelog on GitHub. 
                    
                            Download and run the AWS CLI MSI installer for Windows
                                (64-bit):
                            https://awscli.amazonaws.com/AWSCLIV2.msi
                            Alternatively, you can run the msiexec command to run
                                the MSI installer.
                            C:\> msiexec.exe /i https://awscli.amazonaws.com/AWSCLIV2.msi
                            For various parameters that can be used with msiexec,
                                see msiexec on the Microsoft
                                    Docs website. For example, you can use the
                                    /qn flag for a silent installation.
                            C:\> msiexec.exe /i https://awscli.amazonaws.com/AWSCLIV2.msi /qn
                        
                            To confirm the installation, open the Start
                                menu, search for cmd to open a command prompt window,
                                and at the command prompt use the aws --version
                                command. 
                            C:\> aws --version
aws-cli/2.25.11 Python/3.11.6 Windows/10 exe/AMD64 prompt/off
                            If Windows is unable to find the program, you might need to close
                                and reopen the command prompt window to refresh the path, or follow
                                the troubleshooting in Troubleshooting errors for the AWS CLI.
                        
                
     
        Troubleshooting AWS CLI install and uninstall
                errors
        If you come across issues after installing or uninstalling the AWS CLI, see Troubleshooting errors for the AWS CLI for troubleshooting steps. For the most
            relevant troubleshooting steps, see Command not found errors, The "aws --version" command
                returns a different version than you installed, and The "aws --version" command returns a
                version after uninstalling the AWS CLI.
     
        Next steps
        After you successfully install the AWS CLI, you can safely delete your downloaded
            installer files. After completing the steps in Prerequisites to use the AWS CLI version 2
            and installing the AWS CLI, you should perform a Setting up the AWS CLI.
    Document ConventionsPrerequisitesPast releasesDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nAWS CLI Command Reference
        
Home
User Guide
Forum
GitHub\nAWS CLI Command Reference
        
Home
User Guide
Forum
GitHub\nAWS CLI Command Reference
        
Home
User Guide
Forum
GitHub\nAWS CLI Command Reference\nNavigation
      
        
          index
        
          next |
        
          previous |
        AWS CLI 1.40.17 Command Reference »
          aws »
          lambda »
        create-function\nAWS CLI 1.40.17 Command Reference »\nAWS CLI 1.40.17 Command Reference\n← create-event-source-mapping
          /
          
        
          create-function-url-config →
      
    
  
        
      
        
  
    
  

  
    Table of Contents
    
create-function
Description
Synopsis
Options
Global Options
Examples
Output




  

    Quick search
    
        Search box
        
        Search
        
        
    


  Feedback
  Did you find this page useful? Do you have a suggestion to improve the documentation? Give us feedback.
    
    If you would like to suggest an improvement or fix for the AWS CLI, check out our contributing guide on GitHub.

  User Guide
  First time using the AWS CLI? See the
  User Guide for
  help getting started.

        
      
            
                
                    
                        Note:
                        You are viewing the documentation for an older major version of the AWS CLI (version 1).
                    
                    
                        AWS CLI version 2, the latest major version of AWS CLI, is now stable and recommended for general use.
                        
                            To view this page for the AWS CLI version 2, click
                            here.
                        
                        For more information see the AWS CLI version 2
                        installation instructions
                        and
                        migration guide.
                    
                
              
  [ aws . lambda ]

create-function¶

Description¶
Creates a Lambda function. To create a function, you need a deployment package and an execution role . The deployment package is a .zip file archive or container image that contains your function code. The execution role grants the function permission to use Amazon Web Services services, such as Amazon CloudWatch Logs for log streaming and X-Ray for request tracing.
If the deployment package is a container image , then you set the package type to Image . For a container image, the code property must include the URI of a container image in the Amazon ECR registry. You do not need to specify the handler and runtime properties.
If the deployment package is a .zip file archive , then you set the package type to Zip . For a .zip file archive, the code property specifies the location of the .zip file. You must also specify the handler and runtime properties. The code in the deployment package must be compatible with the target instruction set architecture of the function (x86-64 or arm64 ). If you do not specify the architecture, then the default value is x86-64 .
When you create a function, Lambda provisions an instance of the function and its supporting resources. If your function connects to a VPC, this process can take a minute or so. During this time, you can’t invoke or modify the function. The State , StateReason , and StateReasonCode fields in the response from  GetFunctionConfiguration indicate when the function is ready to invoke. For more information, see Lambda function states .
A function has an unpublished version, and can have published versions and aliases. The unpublished version changes when you update your function’s code and configuration. A published version is a snapshot of your function code and configuration that can’t be changed. An alias is a named resource that maps to a version, and can be changed to map to a different version. Use the Publish parameter to create version 1 of your function from its initial configuration.
The other parameters let you configure version-specific and function-level settings. You can modify version-specific settings later with  UpdateFunctionConfiguration . Function-level settings apply to both the unpublished and published versions of the function, and include tags ( TagResource ) and per-function concurrency limits ( PutFunctionConcurrency ).
You can use code signing if your deployment package is a .zip file archive. To enable code signing for this function, specify the ARN of a code-signing configuration. When a user attempts to deploy a code package with  UpdateFunctionCode , Lambda checks that the code package has a valid signature from a trusted publisher. The code-signing configuration includes set of signing profiles, which define the trusted publishers for this function.
If another Amazon Web Services account or an Amazon Web Services service invokes your function, use  AddPermission to grant permission by creating a resource-based Identity and Access Management (IAM) policy. You can grant permissions at the function level, on a version, or on an alias.
To invoke your function directly, use  Invoke . To invoke your function in response to events in other Amazon Web Services services, create an event source mapping ( CreateEventSourceMapping ), or configure a function trigger in the other service. For more information, see Invoking Lambda functions .
See also: AWS API Documentation


Synopsis¶
  create-function
--function-name <value>
[--runtime <value>]
--role <value>
[--handler <value>]
[--code <value>]
[--description <value>]
[--timeout <value>]
[--memory-size <value>]
[--publish | --no-publish]
[--vpc-config <value>]
[--package-type <value>]
[--dead-letter-config <value>]
[--environment <value>]
[--kms-key-arn <value>]
[--tracing-config <value>]
[--tags <value>]
[--layers <value>]
[--file-system-configs <value>]
[--image-config <value>]
[--code-signing-config-arn <value>]
[--architectures <value>]
[--ephemeral-storage <value>]
[--snap-start <value>]
[--logging-config <value>]
[--zip-file <value>]
[--cli-input-json <value>]
[--generate-cli-skeleton <value>]
[--debug]
[--endpoint-url <value>]
[--no-verify-ssl]
[--no-paginate]
[--output <value>]
[--query <value>]
[--profile <value>]
[--region <value>]
[--version <value>]
[--color <value>]
[--no-sign-request]
[--ca-bundle <value>]
[--cli-read-timeout <value>]
[--cli-connect-timeout <value>]




Options¶
--function-name (string)

The name or ARN of the Lambda function.

Name formats

Function name – my-function .
Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function .
Partial ARN – 123456789012:function:my-function .

The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.

--runtime (string)

The identifier of the function’s runtime . Runtime is required if the deployment package is a .zip file archive. Specifying a runtime results in an error if you’re deploying a function using a container image.
The following list includes deprecated runtimes. Lambda blocks creating new functions and updating existing functions shortly after each runtime is deprecated. For more information, see Runtime use after deprecation .
For a list of all currently supported runtimes, see Supported runtimes .
Possible values:

nodejs
nodejs4.3
nodejs6.10
nodejs8.10
nodejs10.x
nodejs12.x
nodejs14.x
nodejs16.x
java8
java8.al2
java11
python2.7
python3.6
python3.7
python3.8
python3.9
dotnetcore1.0
dotnetcore2.0
dotnetcore2.1
dotnetcore3.1
dotnet6
dotnet8
nodejs4.3-edge
go1.x
ruby2.5
ruby2.7
provided
provided.al2
nodejs18.x
python3.10
java17
ruby3.2
ruby3.3
ruby3.4
python3.11
nodejs20.x
provided.al2023
python3.12
java21
python3.13
nodejs22.x


--role (string)

The Amazon Resource Name (ARN) of the function’s execution role.
--handler (string)

The name of the method within your code that Lambda calls to run your function. Handler is required if the deployment package is a .zip file archive. The format includes the file name. It can also include namespaces and other qualifiers, depending on the runtime. For more information, see Lambda programming model .
--code (structure)

The code for the function.
S3Bucket -> (string)

An Amazon S3 bucket in the same Amazon Web Services Region as your function. The bucket can be in a different Amazon Web Services account.
S3Key -> (string)

The Amazon S3 key of the deployment package.
S3ObjectVersion -> (string)

For versioned objects, the version of the deployment package object to use.
ImageUri -> (string)

URI of a container image in the Amazon ECR registry.
SourceKMSKeyArn -> (string)

The ARN of the Key Management Service (KMS) customer managed key that’s used to encrypt your function’s .zip deployment package. If you don’t provide a customer managed key, Lambda uses an Amazon Web Services owned key .

Shorthand Syntax:
S3Bucket=string,S3Key=string,S3ObjectVersion=string,ImageUri=string,SourceKMSKeyArn=string


JSON Syntax:
{
  "S3Bucket": "string",
  "S3Key": "string",
  "S3ObjectVersion": "string",
  "ImageUri": "string",
  "SourceKMSKeyArn": "string"
}


--description (string)

A description of the function.
--timeout (integer)

The amount of time (in seconds) that Lambda allows a function to run before stopping it. The default is 3 seconds. The maximum allowed value is 900 seconds. For more information, see Lambda execution environment .
--memory-size (integer)

The amount of memory available to the function at runtime. Increasing the function memory also increases its CPU allocation. The default value is 128 MB. The value can be any multiple of 1 MB.
--publish | --no-publish (boolean)

Set to true to publish the first version of the function during creation.
--vpc-config (structure)

For network connectivity to Amazon Web Services resources in a VPC, specify a list of security groups and subnets in the VPC. When you connect a function to a VPC, it can access resources and the internet only through that VPC. For more information, see Configuring a Lambda function to access resources in a VPC .
SubnetIds -> (list)

A list of VPC subnet IDs.
(string)

SecurityGroupIds -> (list)

A list of VPC security group IDs.
(string)

Ipv6AllowedForDualStack -> (boolean)

Allows outbound IPv6 traffic on VPC functions that are connected to dual-stack subnets.

Shorthand Syntax:
SubnetIds=string,string,SecurityGroupIds=string,string,Ipv6AllowedForDualStack=boolean


JSON Syntax:
{
  "SubnetIds": ["string", ...],
  "SecurityGroupIds": ["string", ...],
  "Ipv6AllowedForDualStack": true|false
}


--package-type (string)

The type of deployment package. Set to Image for container image and set to Zip for .zip file archive.
Possible values:

Zip
Image


--dead-letter-config (structure)

A dead-letter queue configuration that specifies the queue or topic where Lambda sends asynchronous events when they fail processing. For more information, see Dead-letter queues .
TargetArn -> (string)

The Amazon Resource Name (ARN) of an Amazon SQS queue or Amazon SNS topic.

Shorthand Syntax:
TargetArn=string


JSON Syntax:
{
  "TargetArn": "string"
}


--environment (structure)

Environment variables that are accessible from function code during execution.
Variables -> (map)

Environment variable key-value pairs. For more information, see Using Lambda environment variables .
key -> (string)
value -> (string)


Shorthand Syntax:
Variables={KeyName1=string,KeyName2=string}


JSON Syntax:
{
  "Variables": {"string": "string"
    ...}
}


--kms-key-arn (string)

The ARN of the Key Management Service (KMS) customer managed key that’s used to encrypt the following resources:

The function’s environment variables .
The function’s Lambda SnapStart snapshots.
When used with SourceKMSKeyArn , the unzipped version of the .zip deployment package that’s used for function invocations. For more information, see Specifying a customer managed key for Lambda .
The optimized version of the container image that’s used for function invocations. Note that this is not the same key that’s used to protect your container image in the Amazon Elastic Container Registry (Amazon ECR). For more information, see Function lifecycle .

If you don’t provide a customer managed key, Lambda uses an Amazon Web Services owned key or an Amazon Web Services managed key .

--tracing-config (structure)

Set Mode to Active to sample and trace a subset of incoming requests with X-Ray .
Mode -> (string)

The tracing mode.

Shorthand Syntax:
Mode=string


JSON Syntax:
{
  "Mode": "Active"|"PassThrough"
}


--tags (map)

A list of tags to apply to the function.
key -> (string)
value -> (string)

Shorthand Syntax:
KeyName1=string,KeyName2=string


JSON Syntax:
{"string": "string"
  ...}


--layers (list)

A list of function layers to add to the function’s execution environment. Specify each layer by its ARN, including the version.
(string)

Syntax:
"string" "string" ...


--file-system-configs (list)

Connection settings for an Amazon EFS file system.
(structure)

Details about the connection between a Lambda function and an Amazon EFS file system .
Arn -> (string)

The Amazon Resource Name (ARN) of the Amazon EFS access point that provides access to the file system.
LocalMountPath -> (string)

The path where the function can access the file system, starting with /mnt/ .


Shorthand Syntax:
Arn=string,LocalMountPath=string ...


JSON Syntax:
[
  {
    "Arn": "string",
    "LocalMountPath": "string"
  }
  ...
]


--image-config (structure)

Container image configuration values that override the values in the container image Dockerfile.
EntryPoint -> (list)

Specifies the entry point to their application, which is typically the location of the runtime executable.
(string)

Command -> (list)

Specifies parameters that you want to pass in with ENTRYPOINT.
(string)

WorkingDirectory -> (string)

Specifies the working directory.

Shorthand Syntax:
EntryPoint=string,string,Command=string,string,WorkingDirectory=string


JSON Syntax:
{
  "EntryPoint": ["string", ...],
  "Command": ["string", ...],
  "WorkingDirectory": "string"
}


--code-signing-config-arn (string)

To enable code signing for this function, specify the ARN of a code-signing configuration. A code-signing configuration includes a set of signing profiles, which define the trusted publishers for this function.
--architectures (list)

The instruction set architecture that the function supports. Enter a string array with one of the valid values (arm64 or x86_64). The default value is x86_64 .
(string)

Syntax:
"string" "string" ...

Where valid values are:
  x86_64
  arm64


--ephemeral-storage (structure)

The size of the function’s /tmp directory in MB. The default value is 512, but can be any whole number between 512 and 10,240 MB. For more information, see Configuring ephemeral storage (console) .
Size -> (integer)

The size of the function’s /tmp directory.

Shorthand Syntax:
Size=integer


JSON Syntax:
{
  "Size": integer
}


--snap-start (structure)

The function’s SnapStart setting.
ApplyOn -> (string)

Set to PublishedVersions to create a snapshot of the initialized execution environment when you publish a function version.

Shorthand Syntax:
ApplyOn=string


JSON Syntax:
{
  "ApplyOn": "PublishedVersions"|"None"
}


--logging-config (structure)

The function’s Amazon CloudWatch Logs configuration settings.
LogFormat -> (string)

The format in which Lambda sends your function’s application and system logs to CloudWatch. Select between plain text and structured JSON.
ApplicationLogLevel -> (string)

Set this property to filter the application logs for your function that Lambda sends to CloudWatch. Lambda only sends application logs at the selected level of detail and lower, where TRACE is the highest level and FATAL is the lowest.
SystemLogLevel -> (string)

Set this property to filter the system logs for your function that Lambda sends to CloudWatch. Lambda only sends system logs at the selected level of detail and lower, where DEBUG is the highest level and WARN is the lowest.
LogGroup -> (string)

The name of the Amazon CloudWatch log group the function sends logs to. By default, Lambda functions send logs to a default log group named /aws/lambda/<function name> . To use a different log group, enter an existing log group or enter a new log group name.

Shorthand Syntax:
LogFormat=string,ApplicationLogLevel=string,SystemLogLevel=string,LogGroup=string


JSON Syntax:
{
  "LogFormat": "JSON"|"Text",
  "ApplicationLogLevel": "TRACE"|"DEBUG"|"INFO"|"WARN"|"ERROR"|"FATAL",
  "SystemLogLevel": "DEBUG"|"INFO"|"WARN",
  "LogGroup": "string"
}


--zip-file (blob)

The path to the zip file of the code you are uploading. Specify –zip-file or –code, but not both. Example: fileb://code.zip
--cli-input-json (string)
Performs service operation based on the JSON string provided. The JSON string follows the format provided by --generate-cli-skeleton. If other arguments are provided on the command line, the CLI values will override the JSON-provided values. It is not possible to pass arbitrary binary values using a JSON-provided value as the string will be taken literally.
--generate-cli-skeleton (string)
Prints a JSON skeleton to standard output without sending an API request. If provided with no value or the value input, prints a sample input JSON that can be used as an argument for --cli-input-json. If provided with the value output, it validates the command inputs and returns a sample output JSON for that command.


Global Options¶
--debug (boolean)
Turn on debug logging.
--endpoint-url (string)
Override command’s default URL with the given URL.
--no-verify-ssl (boolean)
By default, the AWS CLI uses SSL when communicating with AWS services. For each SSL connection, the AWS CLI will verify SSL certificates. This option overrides the default behavior of verifying SSL certificates.
--no-paginate (boolean)
Disable automatic pagination. If automatic pagination is disabled, the AWS CLI will only make one call, for the first page of results.
--output (string)
The formatting style for command output.

json
text
table

--query (string)
A JMESPath query to use in filtering the response data.
--profile (string)
Use a specific profile from your credential file.
--region (string)
The region to use. Overrides config/env settings.
--version (string)
Display the version of this tool.
--color (string)
Turn on/off color output.

on
off
auto

--no-sign-request (boolean)
Do not sign requests. Credentials will not be loaded if this argument is provided.
--ca-bundle (string)
The CA certificate bundle to use when verifying SSL certificates. Overrides config/env settings.
--cli-read-timeout (int)
The maximum socket read time in seconds. If the value is set to 0, the socket read will be blocking and not timeout. The default value is 60 seconds.
--cli-connect-timeout (int)
The maximum socket connect time in seconds. If the value is set to 0, the socket connect will be blocking and not timeout. The default value is 60 seconds.


Examples¶

NoteTo use the following examples, you must have the AWS CLI installed and configured. See the Getting started guide in the AWS CLI User Guide for more information.
Unless otherwise stated, all examples have unix-like quotation rules. These examples will need to be adapted to your terminal’s quoting rules. See Using quotation marks with strings in the AWS CLI User Guide .

To create a Lambda function
The following create-function example creates a Lambda function named my-function.
aws lambda create-function \
    --function-name my-function \
    --runtime nodejs18.x \
    --zip-file fileb://my-function.zip \
    --handler my-function.handler \
    --role arn:aws:iam::123456789012:role/service-role/MyTestFunction-role-tges6bf4


Contents of my-function.zip:
This file is a deployment package that contains your function code and any dependencies.


Output:
{
    "TracingConfig": {
        "Mode": "PassThrough"
    },
    "CodeSha256": "PFn4S+er27qk+UuZSTKEQfNKG/XNn7QJs90mJgq6oH8=",
    "FunctionName": "my-function",
    "CodeSize": 308,
    "RevisionId": "873282ed-4cd3-4dc8-a069-d0c647e470c6",
    "MemorySize": 128,
    "FunctionArn": "arn:aws:lambda:us-west-2:123456789012:function:my-function",
    "Version": "$LATEST",
    "Role": "arn:aws:iam::123456789012:role/service-role/MyTestFunction-role-zgur6bf4",
    "Timeout": 3,
    "LastModified": "2023-10-14T22:26:11.234+0000",
    "Handler": "my-function.handler",
    "Runtime": "nodejs18.x",
    "Description": ""
}


For more information, see AWS Lambda Function Configuration in the AWS Lambda Developer Guide.


Output¶
FunctionName -> (string)

The name of the function.
FunctionArn -> (string)

The function’s Amazon Resource Name (ARN).
Runtime -> (string)

The identifier of the function’s runtime . Runtime is required if the deployment package is a .zip file archive. Specifying a runtime results in an error if you’re deploying a function using a container image.
The following list includes deprecated runtimes. Lambda blocks creating new functions and updating existing functions shortly after each runtime is deprecated. For more information, see Runtime use after deprecation .
For a list of all currently supported runtimes, see Supported runtimes .

Role -> (string)

The function’s execution role.
Handler -> (string)

The function that Lambda calls to begin running your function.
CodeSize -> (long)

The size of the function’s deployment package, in bytes.
Description -> (string)

The function’s description.
Timeout -> (integer)

The amount of time in seconds that Lambda allows a function to run before stopping it.
MemorySize -> (integer)

The amount of memory available to the function at runtime.
LastModified -> (string)

The date and time that the function was last updated, in ISO-8601 format (YYYY-MM-DDThh:mm:ss.sTZD).
CodeSha256 -> (string)

The SHA256 hash of the function’s deployment package.
Version -> (string)

The version of the Lambda function.
VpcConfig -> (structure)

The function’s networking configuration.
SubnetIds -> (list)

A list of VPC subnet IDs.
(string)

SecurityGroupIds -> (list)

A list of VPC security group IDs.
(string)

VpcId -> (string)

The ID of the VPC.
Ipv6AllowedForDualStack -> (boolean)

Allows outbound IPv6 traffic on VPC functions that are connected to dual-stack subnets.

DeadLetterConfig -> (structure)

The function’s dead letter queue.
TargetArn -> (string)

The Amazon Resource Name (ARN) of an Amazon SQS queue or Amazon SNS topic.

Environment -> (structure)

The function’s environment variables . Omitted from CloudTrail logs.
Variables -> (map)

Environment variable key-value pairs. Omitted from CloudTrail logs.
key -> (string)
value -> (string)

Error -> (structure)

Error messages for environment variables that couldn’t be applied.
ErrorCode -> (string)

The error code.
Message -> (string)

The error message.


KMSKeyArn -> (string)

The ARN of the Key Management Service (KMS) customer managed key that’s used to encrypt the following resources:

The function’s environment variables .
The function’s Lambda SnapStart snapshots.
When used with SourceKMSKeyArn , the unzipped version of the .zip deployment package that’s used for function invocations. For more information, see Specifying a customer managed key for Lambda .
The optimized version of the container image that’s used for function invocations. Note that this is not the same key that’s used to protect your container image in the Amazon Elastic Container Registry (Amazon ECR). For more information, see Function lifecycle .

If you don’t provide a customer managed key, Lambda uses an Amazon Web Services owned key or an Amazon Web Services managed key .

TracingConfig -> (structure)

The function’s X-Ray tracing configuration.
Mode -> (string)

The tracing mode.

MasterArn -> (string)

For Lambda@Edge functions, the ARN of the main function.
RevisionId -> (string)

The latest updated revision of the function or alias.
Layers -> (list)

The function’s layers .
(structure)

An Lambda layer .
Arn -> (string)

The Amazon Resource Name (ARN) of the function layer.
CodeSize -> (long)

The size of the layer archive in bytes.
SigningProfileVersionArn -> (string)

The Amazon Resource Name (ARN) for a signing profile version.
SigningJobArn -> (string)

The Amazon Resource Name (ARN) of a signing job.


State -> (string)

The current state of the function. When the state is Inactive , you can reactivate the function by invoking it.
StateReason -> (string)

The reason for the function’s current state.
StateReasonCode -> (string)

The reason code for the function’s current state. When the code is Creating , you can’t invoke or modify the function.
LastUpdateStatus -> (string)

The status of the last update that was performed on the function. This is first set to Successful after function creation completes.
LastUpdateStatusReason -> (string)

The reason for the last update that was performed on the function.
LastUpdateStatusReasonCode -> (string)

The reason code for the last update that was performed on the function.
FileSystemConfigs -> (list)

Connection settings for an Amazon EFS file system .
(structure)

Details about the connection between a Lambda function and an Amazon EFS file system .
Arn -> (string)

The Amazon Resource Name (ARN) of the Amazon EFS access point that provides access to the file system.
LocalMountPath -> (string)

The path where the function can access the file system, starting with /mnt/ .


PackageType -> (string)

The type of deployment package. Set to Image for container image and set Zip for .zip file archive.
ImageConfigResponse -> (structure)

The function’s image configuration values.
ImageConfig -> (structure)

Configuration values that override the container image Dockerfile.
EntryPoint -> (list)

Specifies the entry point to their application, which is typically the location of the runtime executable.
(string)

Command -> (list)

Specifies parameters that you want to pass in with ENTRYPOINT.
(string)

WorkingDirectory -> (string)

Specifies the working directory.

Error -> (structure)

Error response to GetFunctionConfiguration .
ErrorCode -> (string)

Error code.
Message -> (string)

Error message.


SigningProfileVersionArn -> (string)

The ARN of the signing profile version.
SigningJobArn -> (string)

The ARN of the signing job.
Architectures -> (list)

The instruction set architecture that the function supports. Architecture is a string array with one of the valid values. The default architecture value is x86_64 .
(string)

EphemeralStorage -> (structure)

The size of the function’s /tmp directory in MB. The default value is 512, but can be any whole number between 512 and 10,240 MB. For more information, see Configuring ephemeral storage (console) .
Size -> (integer)

The size of the function’s /tmp directory.

SnapStart -> (structure)

Set ApplyOn to PublishedVersions to create a snapshot of the initialized execution environment when you publish a function version. For more information, see Improving startup performance with Lambda SnapStart .
ApplyOn -> (string)

When set to PublishedVersions , Lambda creates a snapshot of the execution environment when you publish a function version.
OptimizationStatus -> (string)

When you provide a qualified Amazon Resource Name (ARN) , this response element indicates whether SnapStart is activated for the specified function version.

RuntimeVersionConfig -> (structure)

The ARN of the runtime and any errors that occured.
RuntimeVersionArn -> (string)

The ARN of the runtime version you want the function to use.
Error -> (structure)

Error response when Lambda is unable to retrieve the runtime version for a function.
ErrorCode -> (string)

The error code.
Message -> (string)

The error message.


LoggingConfig -> (structure)

The function’s Amazon CloudWatch Logs configuration settings.
LogFormat -> (string)

The format in which Lambda sends your function’s application and system logs to CloudWatch. Select between plain text and structured JSON.
ApplicationLogLevel -> (string)

Set this property to filter the application logs for your function that Lambda sends to CloudWatch. Lambda only sends application logs at the selected level of detail and lower, where TRACE is the highest level and FATAL is the lowest.
SystemLogLevel -> (string)

Set this property to filter the system logs for your function that Lambda sends to CloudWatch. Lambda only sends system logs at the selected level of detail and lower, where DEBUG is the highest level and WARN is the lowest.
LogGroup -> (string)

The name of the Amazon CloudWatch log group the function sends logs to. By default, Lambda functions send logs to a default log group named /aws/lambda/<function name> . To use a different log group, enter an existing log group or enter a new log group name.





            
          
        
        
    
      
        
          ← create-event-source-mapping
          /
          
        
          create-function-url-config →\n← create-event-source-mapping
          /
          
        
          create-function-url-config →\n← create-event-source-mapping
          /\n← create-event-source-mapping\ncreate-function-url-config →\ncreate-function-url-config →\nTable of Contents
    
create-function
Description
Synopsis
Options
Global Options
Examples
Output




  

    Quick search
    
        Search box
        
        Search
        
        
    


  Feedback
  Did you find this page useful? Do you have a suggestion to improve the documentation? Give us feedback.
    
    If you would like to suggest an improvement or fix for the AWS CLI, check out our contributing guide on GitHub.

  User Guide
  First time using the AWS CLI? See the
  User Guide for
  help getting started.

        
      
            
                
                    
                        Note:
                        You are viewing the documentation for an older major version of the AWS CLI (version 1).
                    
                    
                        AWS CLI version 2, the latest major version of AWS CLI, is now stable and recommended for general use.
                        
                            To view this page for the AWS CLI version 2, click
                            here.
                        
                        For more information see the AWS CLI version 2
                        installation instructions
                        and
                        migration guide.
                    
                
              
  [ aws . lambda ]

create-function¶

Description¶
Creates a Lambda function. To create a function, you need a deployment package and an execution role . The deployment package is a .zip file archive or container image that contains your function code. The execution role grants the function permission to use Amazon Web Services services, such as Amazon CloudWatch Logs for log streaming and X-Ray for request tracing.
If the deployment package is a container image , then you set the package type to Image . For a container image, the code property must include the URI of a container image in the Amazon ECR registry. You do not need to specify the handler and runtime properties.
If the deployment package is a .zip file archive , then you set the package type to Zip . For a .zip file archive, the code property specifies the location of the .zip file. You must also specify the handler and runtime properties. The code in the deployment package must be compatible with the target instruction set architecture of the function (x86-64 or arm64 ). If you do not specify the architecture, then the default value is x86-64 .
When you create a function, Lambda provisions an instance of the function and its supporting resources. If your function connects to a VPC, this process can take a minute or so. During this time, you can’t invoke or modify the function. The State , StateReason , and StateReasonCode fields in the response from  GetFunctionConfiguration indicate when the function is ready to invoke. For more information, see Lambda function states .
A function has an unpublished version, and can have published versions and aliases. The unpublished version changes when you update your function’s code and configuration. A published version is a snapshot of your function code and configuration that can’t be changed. An alias is a named resource that maps to a version, and can be changed to map to a different version. Use the Publish parameter to create version 1 of your function from its initial configuration.
The other parameters let you configure version-specific and function-level settings. You can modify version-specific settings later with  UpdateFunctionConfiguration . Function-level settings apply to both the unpublished and published versions of the function, and include tags ( TagResource ) and per-function concurrency limits ( PutFunctionConcurrency ).
You can use code signing if your deployment package is a .zip file archive. To enable code signing for this function, specify the ARN of a code-signing configuration. When a user attempts to deploy a code package with  UpdateFunctionCode , Lambda checks that the code package has a valid signature from a trusted publisher. The code-signing configuration includes set of signing profiles, which define the trusted publishers for this function.
If another Amazon Web Services account or an Amazon Web Services service invokes your function, use  AddPermission to grant permission by creating a resource-based Identity and Access Management (IAM) policy. You can grant permissions at the function level, on a version, or on an alias.
To invoke your function directly, use  Invoke . To invoke your function in response to events in other Amazon Web Services services, create an event source mapping ( CreateEventSourceMapping ), or configure a function trigger in the other service. For more information, see Invoking Lambda functions .
See also: AWS API Documentation


Synopsis¶
  create-function
--function-name <value>
[--runtime <value>]
--role <value>
[--handler <value>]
[--code <value>]
[--description <value>]
[--timeout <value>]
[--memory-size <value>]
[--publish | --no-publish]
[--vpc-config <value>]
[--package-type <value>]
[--dead-letter-config <value>]
[--environment <value>]
[--kms-key-arn <value>]
[--tracing-config <value>]
[--tags <value>]
[--layers <value>]
[--file-system-configs <value>]
[--image-config <value>]
[--code-signing-config-arn <value>]
[--architectures <value>]
[--ephemeral-storage <value>]
[--snap-start <value>]
[--logging-config <value>]
[--zip-file <value>]
[--cli-input-json <value>]
[--generate-cli-skeleton <value>]
[--debug]
[--endpoint-url <value>]
[--no-verify-ssl]
[--no-paginate]
[--output <value>]
[--query <value>]
[--profile <value>]
[--region <value>]
[--version <value>]
[--color <value>]
[--no-sign-request]
[--ca-bundle <value>]
[--cli-read-timeout <value>]
[--cli-connect-timeout <value>]




Options¶
--function-name (string)

The name or ARN of the Lambda function.

Name formats

Function name – my-function .
Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function .
Partial ARN – 123456789012:function:my-function .

The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.

--runtime (string)

The identifier of the function’s runtime . Runtime is required if the deployment package is a .zip file archive. Specifying a runtime results in an error if you’re deploying a function using a container image.
The following list includes deprecated runtimes. Lambda blocks creating new functions and updating existing functions shortly after each runtime is deprecated. For more information, see Runtime use after deprecation .
For a list of all currently supported runtimes, see Supported runtimes .
Possible values:

nodejs
nodejs4.3
nodejs6.10
nodejs8.10
nodejs10.x
nodejs12.x
nodejs14.x
nodejs16.x
java8
java8.al2
java11
python2.7
python3.6
python3.7
python3.8
python3.9
dotnetcore1.0
dotnetcore2.0
dotnetcore2.1
dotnetcore3.1
dotnet6
dotnet8
nodejs4.3-edge
go1.x
ruby2.5
ruby2.7
provided
provided.al2
nodejs18.x
python3.10
java17
ruby3.2
ruby3.3
ruby3.4
python3.11
nodejs20.x
provided.al2023
python3.12
java21
python3.13
nodejs22.x


--role (string)

The Amazon Resource Name (ARN) of the function’s execution role.
--handler (string)

The name of the method within your code that Lambda calls to run your function. Handler is required if the deployment package is a .zip file archive. The format includes the file name. It can also include namespaces and other qualifiers, depending on the runtime. For more information, see Lambda programming model .
--code (structure)

The code for the function.
S3Bucket -> (string)

An Amazon S3 bucket in the same Amazon Web Services Region as your function. The bucket can be in a different Amazon Web Services account.
S3Key -> (string)

The Amazon S3 key of the deployment package.
S3ObjectVersion -> (string)

For versioned objects, the version of the deployment package object to use.
ImageUri -> (string)

URI of a container image in the Amazon ECR registry.
SourceKMSKeyArn -> (string)

The ARN of the Key Management Service (KMS) customer managed key that’s used to encrypt your function’s .zip deployment package. If you don’t provide a customer managed key, Lambda uses an Amazon Web Services owned key .

Shorthand Syntax:
S3Bucket=string,S3Key=string,S3ObjectVersion=string,ImageUri=string,SourceKMSKeyArn=string


JSON Syntax:
{
  "S3Bucket": "string",
  "S3Key": "string",
  "S3ObjectVersion": "string",
  "ImageUri": "string",
  "SourceKMSKeyArn": "string"
}


--description (string)

A description of the function.
--timeout (integer)

The amount of time (in seconds) that Lambda allows a function to run before stopping it. The default is 3 seconds. The maximum allowed value is 900 seconds. For more information, see Lambda execution environment .
--memory-size (integer)

The amount of memory available to the function at runtime. Increasing the function memory also increases its CPU allocation. The default value is 128 MB. The value can be any multiple of 1 MB.
--publish | --no-publish (boolean)

Set to true to publish the first version of the function during creation.
--vpc-config (structure)

For network connectivity to Amazon Web Services resources in a VPC, specify a list of security groups and subnets in the VPC. When you connect a function to a VPC, it can access resources and the internet only through that VPC. For more information, see Configuring a Lambda function to access resources in a VPC .
SubnetIds -> (list)

A list of VPC subnet IDs.
(string)

SecurityGroupIds -> (list)

A list of VPC security group IDs.
(string)

Ipv6AllowedForDualStack -> (boolean)

Allows outbound IPv6 traffic on VPC functions that are connected to dual-stack subnets.

Shorthand Syntax:
SubnetIds=string,string,SecurityGroupIds=string,string,Ipv6AllowedForDualStack=boolean


JSON Syntax:
{
  "SubnetIds": ["string", ...],
  "SecurityGroupIds": ["string", ...],
  "Ipv6AllowedForDualStack": true|false
}


--package-type (string)

The type of deployment package. Set to Image for container image and set to Zip for .zip file archive.
Possible values:

Zip
Image


--dead-letter-config (structure)

A dead-letter queue configuration that specifies the queue or topic where Lambda sends asynchronous events when they fail processing. For more information, see Dead-letter queues .
TargetArn -> (string)

The Amazon Resource Name (ARN) of an Amazon SQS queue or Amazon SNS topic.

Shorthand Syntax:
TargetArn=string


JSON Syntax:
{
  "TargetArn": "string"
}


--environment (structure)

Environment variables that are accessible from function code during execution.
Variables -> (map)

Environment variable key-value pairs. For more information, see Using Lambda environment variables .
key -> (string)
value -> (string)


Shorthand Syntax:
Variables={KeyName1=string,KeyName2=string}


JSON Syntax:
{
  "Variables": {"string": "string"
    ...}
}


--kms-key-arn (string)

The ARN of the Key Management Service (KMS) customer managed key that’s used to encrypt the following resources:

The function’s environment variables .
The function’s Lambda SnapStart snapshots.
When used with SourceKMSKeyArn , the unzipped version of the .zip deployment package that’s used for function invocations. For more information, see Specifying a customer managed key for Lambda .
The optimized version of the container image that’s used for function invocations. Note that this is not the same key that’s used to protect your container image in the Amazon Elastic Container Registry (Amazon ECR). For more information, see Function lifecycle .

If you don’t provide a customer managed key, Lambda uses an Amazon Web Services owned key or an Amazon Web Services managed key .

--tracing-config (structure)

Set Mode to Active to sample and trace a subset of incoming requests with X-Ray .
Mode -> (string)

The tracing mode.

Shorthand Syntax:
Mode=string


JSON Syntax:
{
  "Mode": "Active"|"PassThrough"
}


--tags (map)

A list of tags to apply to the function.
key -> (string)
value -> (string)

Shorthand Syntax:
KeyName1=string,KeyName2=string


JSON Syntax:
{"string": "string"
  ...}


--layers (list)

A list of function layers to add to the function’s execution environment. Specify each layer by its ARN, including the version.
(string)

Syntax:
"string" "string" ...


--file-system-configs (list)

Connection settings for an Amazon EFS file system.
(structure)

Details about the connection between a Lambda function and an Amazon EFS file system .
Arn -> (string)

The Amazon Resource Name (ARN) of the Amazon EFS access point that provides access to the file system.
LocalMountPath -> (string)

The path where the function can access the file system, starting with /mnt/ .


Shorthand Syntax:
Arn=string,LocalMountPath=string ...


JSON Syntax:
[
  {
    "Arn": "string",
    "LocalMountPath": "string"
  }
  ...
]


--image-config (structure)

Container image configuration values that override the values in the container image Dockerfile.
EntryPoint -> (list)

Specifies the entry point to their application, which is typically the location of the runtime executable.
(string)

Command -> (list)

Specifies parameters that you want to pass in with ENTRYPOINT.
(string)

WorkingDirectory -> (string)

Specifies the working directory.

Shorthand Syntax:
EntryPoint=string,string,Command=string,string,WorkingDirectory=string


JSON Syntax:
{
  "EntryPoint": ["string", ...],
  "Command": ["string", ...],
  "WorkingDirectory": "string"
}


--code-signing-config-arn (string)

To enable code signing for this function, specify the ARN of a code-signing configuration. A code-signing configuration includes a set of signing profiles, which define the trusted publishers for this function.
--architectures (list)

The instruction set architecture that the function supports. Enter a string array with one of the valid values (arm64 or x86_64). The default value is x86_64 .
(string)

Syntax:
"string" "string" ...

Where valid values are:
  x86_64
  arm64


--ephemeral-storage (structure)

The size of the function’s /tmp directory in MB. The default value is 512, but can be any whole number between 512 and 10,240 MB. For more information, see Configuring ephemeral storage (console) .
Size -> (integer)

The size of the function’s /tmp directory.

Shorthand Syntax:
Size=integer


JSON Syntax:
{
  "Size": integer
}


--snap-start (structure)

The function’s SnapStart setting.
ApplyOn -> (string)

Set to PublishedVersions to create a snapshot of the initialized execution environment when you publish a function version.

Shorthand Syntax:
ApplyOn=string


JSON Syntax:
{
  "ApplyOn": "PublishedVersions"|"None"
}


--logging-config (structure)

The function’s Amazon CloudWatch Logs configuration settings.
LogFormat -> (string)

The format in which Lambda sends your function’s application and system logs to CloudWatch. Select between plain text and structured JSON.
ApplicationLogLevel -> (string)

Set this property to filter the application logs for your function that Lambda sends to CloudWatch. Lambda only sends application logs at the selected level of detail and lower, where TRACE is the highest level and FATAL is the lowest.
SystemLogLevel -> (string)

Set this property to filter the system logs for your function that Lambda sends to CloudWatch. Lambda only sends system logs at the selected level of detail and lower, where DEBUG is the highest level and WARN is the lowest.
LogGroup -> (string)

The name of the Amazon CloudWatch log group the function sends logs to. By default, Lambda functions send logs to a default log group named /aws/lambda/<function name> . To use a different log group, enter an existing log group or enter a new log group name.

Shorthand Syntax:
LogFormat=string,ApplicationLogLevel=string,SystemLogLevel=string,LogGroup=string


JSON Syntax:
{
  "LogFormat": "JSON"|"Text",
  "ApplicationLogLevel": "TRACE"|"DEBUG"|"INFO"|"WARN"|"ERROR"|"FATAL",
  "SystemLogLevel": "DEBUG"|"INFO"|"WARN",
  "LogGroup": "string"
}


--zip-file (blob)

The path to the zip file of the code you are uploading. Specify –zip-file or –code, but not both. Example: fileb://code.zip
--cli-input-json (string)
Performs service operation based on the JSON string provided. The JSON string follows the format provided by --generate-cli-skeleton. If other arguments are provided on the command line, the CLI values will override the JSON-provided values. It is not possible to pass arbitrary binary values using a JSON-provided value as the string will be taken literally.
--generate-cli-skeleton (string)
Prints a JSON skeleton to standard output without sending an API request. If provided with no value or the value input, prints a sample input JSON that can be used as an argument for --cli-input-json. If provided with the value output, it validates the command inputs and returns a sample output JSON for that command.


Global Options¶
--debug (boolean)
Turn on debug logging.
--endpoint-url (string)
Override command’s default URL with the given URL.
--no-verify-ssl (boolean)
By default, the AWS CLI uses SSL when communicating with AWS services. For each SSL connection, the AWS CLI will verify SSL certificates. This option overrides the default behavior of verifying SSL certificates.
--no-paginate (boolean)
Disable automatic pagination. If automatic pagination is disabled, the AWS CLI will only make one call, for the first page of results.
--output (string)
The formatting style for command output.

json
text
table

--query (string)
A JMESPath query to use in filtering the response data.
--profile (string)
Use a specific profile from your credential file.
--region (string)
The region to use. Overrides config/env settings.
--version (string)
Display the version of this tool.
--color (string)
Turn on/off color output.

on
off
auto

--no-sign-request (boolean)
Do not sign requests. Credentials will not be loaded if this argument is provided.
--ca-bundle (string)
The CA certificate bundle to use when verifying SSL certificates. Overrides config/env settings.
--cli-read-timeout (int)
The maximum socket read time in seconds. If the value is set to 0, the socket read will be blocking and not timeout. The default value is 60 seconds.
--cli-connect-timeout (int)
The maximum socket connect time in seconds. If the value is set to 0, the socket connect will be blocking and not timeout. The default value is 60 seconds.


Examples¶

NoteTo use the following examples, you must have the AWS CLI installed and configured. See the Getting started guide in the AWS CLI User Guide for more information.
Unless otherwise stated, all examples have unix-like quotation rules. These examples will need to be adapted to your terminal’s quoting rules. See Using quotation marks with strings in the AWS CLI User Guide .

To create a Lambda function
The following create-function example creates a Lambda function named my-function.
aws lambda create-function \
    --function-name my-function \
    --runtime nodejs18.x \
    --zip-file fileb://my-function.zip \
    --handler my-function.handler \
    --role arn:aws:iam::123456789012:role/service-role/MyTestFunction-role-tges6bf4


Contents of my-function.zip:
This file is a deployment package that contains your function code and any dependencies.


Output:
{
    "TracingConfig": {
        "Mode": "PassThrough"
    },
    "CodeSha256": "PFn4S+er27qk+UuZSTKEQfNKG/XNn7QJs90mJgq6oH8=",
    "FunctionName": "my-function",
    "CodeSize": 308,
    "RevisionId": "873282ed-4cd3-4dc8-a069-d0c647e470c6",
    "MemorySize": 128,
    "FunctionArn": "arn:aws:lambda:us-west-2:123456789012:function:my-function",
    "Version": "$LATEST",
    "Role": "arn:aws:iam::123456789012:role/service-role/MyTestFunction-role-zgur6bf4",
    "Timeout": 3,
    "LastModified": "2023-10-14T22:26:11.234+0000",
    "Handler": "my-function.handler",
    "Runtime": "nodejs18.x",
    "Description": ""
}


For more information, see AWS Lambda Function Configuration in the AWS Lambda Developer Guide.


Output¶
FunctionName -> (string)

The name of the function.
FunctionArn -> (string)

The function’s Amazon Resource Name (ARN).
Runtime -> (string)

The identifier of the function’s runtime . Runtime is required if the deployment package is a .zip file archive. Specifying a runtime results in an error if you’re deploying a function using a container image.
The following list includes deprecated runtimes. Lambda blocks creating new functions and updating existing functions shortly after each runtime is deprecated. For more information, see Runtime use after deprecation .
For a list of all currently supported runtimes, see Supported runtimes .

Role -> (string)

The function’s execution role.
Handler -> (string)

The function that Lambda calls to begin running your function.
CodeSize -> (long)

The size of the function’s deployment package, in bytes.
Description -> (string)

The function’s description.
Timeout -> (integer)

The amount of time in seconds that Lambda allows a function to run before stopping it.
MemorySize -> (integer)

The amount of memory available to the function at runtime.
LastModified -> (string)

The date and time that the function was last updated, in ISO-8601 format (YYYY-MM-DDThh:mm:ss.sTZD).
CodeSha256 -> (string)

The SHA256 hash of the function’s deployment package.
Version -> (string)

The version of the Lambda function.
VpcConfig -> (structure)

The function’s networking configuration.
SubnetIds -> (list)

A list of VPC subnet IDs.
(string)

SecurityGroupIds -> (list)

A list of VPC security group IDs.
(string)

VpcId -> (string)

The ID of the VPC.
Ipv6AllowedForDualStack -> (boolean)

Allows outbound IPv6 traffic on VPC functions that are connected to dual-stack subnets.

DeadLetterConfig -> (structure)

The function’s dead letter queue.
TargetArn -> (string)

The Amazon Resource Name (ARN) of an Amazon SQS queue or Amazon SNS topic.

Environment -> (structure)

The function’s environment variables . Omitted from CloudTrail logs.
Variables -> (map)

Environment variable key-value pairs. Omitted from CloudTrail logs.
key -> (string)
value -> (string)

Error -> (structure)

Error messages for environment variables that couldn’t be applied.
ErrorCode -> (string)

The error code.
Message -> (string)

The error message.


KMSKeyArn -> (string)

The ARN of the Key Management Service (KMS) customer managed key that’s used to encrypt the following resources:

The function’s environment variables .
The function’s Lambda SnapStart snapshots.
When used with SourceKMSKeyArn , the unzipped version of the .zip deployment package that’s used for function invocations. For more information, see Specifying a customer managed key for Lambda .
The optimized version of the container image that’s used for function invocations. Note that this is not the same key that’s used to protect your container image in the Amazon Elastic Container Registry (Amazon ECR). For more information, see Function lifecycle .

If you don’t provide a customer managed key, Lambda uses an Amazon Web Services owned key or an Amazon Web Services managed key .

TracingConfig -> (structure)

The function’s X-Ray tracing configuration.
Mode -> (string)

The tracing mode.

MasterArn -> (string)

For Lambda@Edge functions, the ARN of the main function.
RevisionId -> (string)

The latest updated revision of the function or alias.
Layers -> (list)

The function’s layers .
(structure)

An Lambda layer .
Arn -> (string)

The Amazon Resource Name (ARN) of the function layer.
CodeSize -> (long)

The size of the layer archive in bytes.
SigningProfileVersionArn -> (string)

The Amazon Resource Name (ARN) for a signing profile version.
SigningJobArn -> (string)

The Amazon Resource Name (ARN) of a signing job.


State -> (string)

The current state of the function. When the state is Inactive , you can reactivate the function by invoking it.
StateReason -> (string)

The reason for the function’s current state.
StateReasonCode -> (string)

The reason code for the function’s current state. When the code is Creating , you can’t invoke or modify the function.
LastUpdateStatus -> (string)

The status of the last update that was performed on the function. This is first set to Successful after function creation completes.
LastUpdateStatusReason -> (string)

The reason for the last update that was performed on the function.
LastUpdateStatusReasonCode -> (string)

The reason code for the last update that was performed on the function.
FileSystemConfigs -> (list)

Connection settings for an Amazon EFS file system .
(structure)

Details about the connection between a Lambda function and an Amazon EFS file system .
Arn -> (string)

The Amazon Resource Name (ARN) of the Amazon EFS access point that provides access to the file system.
LocalMountPath -> (string)

The path where the function can access the file system, starting with /mnt/ .


PackageType -> (string)

The type of deployment package. Set to Image for container image and set Zip for .zip file archive.
ImageConfigResponse -> (structure)

The function’s image configuration values.
ImageConfig -> (structure)

Configuration values that override the container image Dockerfile.
EntryPoint -> (list)

Specifies the entry point to their application, which is typically the location of the runtime executable.
(string)

Command -> (list)

Specifies parameters that you want to pass in with ENTRYPOINT.
(string)

WorkingDirectory -> (string)

Specifies the working directory.

Error -> (structure)

Error response to GetFunctionConfiguration .
ErrorCode -> (string)

Error code.
Message -> (string)

Error message.


SigningProfileVersionArn -> (string)

The ARN of the signing profile version.
SigningJobArn -> (string)

The ARN of the signing job.
Architectures -> (list)

The instruction set architecture that the function supports. Architecture is a string array with one of the valid values. The default architecture value is x86_64 .
(string)

EphemeralStorage -> (structure)

The size of the function’s /tmp directory in MB. The default value is 512, but can be any whole number between 512 and 10,240 MB. For more information, see Configuring ephemeral storage (console) .
Size -> (integer)

The size of the function’s /tmp directory.

SnapStart -> (structure)

Set ApplyOn to PublishedVersions to create a snapshot of the initialized execution environment when you publish a function version. For more information, see Improving startup performance with Lambda SnapStart .
ApplyOn -> (string)

When set to PublishedVersions , Lambda creates a snapshot of the execution environment when you publish a function version.
OptimizationStatus -> (string)

When you provide a qualified Amazon Resource Name (ARN) , this response element indicates whether SnapStart is activated for the specified function version.

RuntimeVersionConfig -> (structure)

The ARN of the runtime and any errors that occured.
RuntimeVersionArn -> (string)

The ARN of the runtime version you want the function to use.
Error -> (structure)

Error response when Lambda is unable to retrieve the runtime version for a function.
ErrorCode -> (string)

The error code.
Message -> (string)

The error message.


LoggingConfig -> (structure)

The function’s Amazon CloudWatch Logs configuration settings.
LogFormat -> (string)

The format in which Lambda sends your function’s application and system logs to CloudWatch. Select between plain text and structured JSON.
ApplicationLogLevel -> (string)

Set this property to filter the application logs for your function that Lambda sends to CloudWatch. Lambda only sends application logs at the selected level of detail and lower, where TRACE is the highest level and FATAL is the lowest.
SystemLogLevel -> (string)

Set this property to filter the system logs for your function that Lambda sends to CloudWatch. Lambda only sends system logs at the selected level of detail and lower, where DEBUG is the highest level and WARN is the lowest.
LogGroup -> (string)

The name of the Amazon CloudWatch log group the function sends logs to. By default, Lambda functions send logs to a default log group named /aws/lambda/<function name> . To use a different log group, enter an existing log group or enter a new log group name.\nTable of Contents
    
create-function
Description
Synopsis
Options
Global Options
Examples
Output




  

    Quick search
    
        Search box
        
        Search
        
        
    


  Feedback
  Did you find this page useful? Do you have a suggestion to improve the documentation? Give us feedback.
    
    If you would like to suggest an improvement or fix for the AWS CLI, check out our contributing guide on GitHub.

  User Guide
  First time using the AWS CLI? See the
  User Guide for
  help getting started.\nTable of Contents
    
create-function
Description
Synopsis
Options
Global Options
Examples
Output




  

    Quick search
    
        Search box
        
        Search
        
        
    


  Feedback
  Did you find this page useful? Do you have a suggestion to improve the documentation? Give us feedback.
    
    If you would like to suggest an improvement or fix for the AWS CLI, check out our contributing guide on GitHub.

  User Guide
  First time using the AWS CLI? See the
  User Guide for
  help getting started.\nTable of Contents
    
create-function
Description
Synopsis
Options
Global Options
Examples
Output\ncreate-function
Description
Synopsis
Options
Global Options
Examples
Output\nQuick search
    
        Search box
        
        Search\nFeedback
  Did you find this page useful? Do you have a suggestion to improve the documentation? Give us feedback.
    
    If you would like to suggest an improvement or fix for the AWS CLI, check out our contributing guide on GitHub.\nDid you find this page useful? Do you have a suggestion to improve the documentation? Give us feedback.
    
    If you would like to suggest an improvement or fix for the AWS CLI, check out our contributing guide on GitHub.\nUser Guide
  First time using the AWS CLI? See the
  User Guide for
  help getting started.\nFirst time using the AWS CLI? See the
  User Guide for
  help getting started.\nNote:
                        You are viewing the documentation for an older major version of the AWS CLI (version 1).
                    
                    
                        AWS CLI version 2, the latest major version of AWS CLI, is now stable and recommended for general use.
                        
                            To view this page for the AWS CLI version 2, click
                            here.
                        
                        For more information see the AWS CLI version 2
                        installation instructions
                        and
                        migration guide.
                    
                
              
  [ aws . lambda ]

create-function¶

Description¶
Creates a Lambda function. To create a function, you need a deployment package and an execution role . The deployment package is a .zip file archive or container image that contains your function code. The execution role grants the function permission to use Amazon Web Services services, such as Amazon CloudWatch Logs for log streaming and X-Ray for request tracing.
If the deployment package is a container image , then you set the package type to Image . For a container image, the code property must include the URI of a container image in the Amazon ECR registry. You do not need to specify the handler and runtime properties.
If the deployment package is a .zip file archive , then you set the package type to Zip . For a .zip file archive, the code property specifies the location of the .zip file. You must also specify the handler and runtime properties. The code in the deployment package must be compatible with the target instruction set architecture of the function (x86-64 or arm64 ). If you do not specify the architecture, then the default value is x86-64 .
When you create a function, Lambda provisions an instance of the function and its supporting resources. If your function connects to a VPC, this process can take a minute or so. During this time, you can’t invoke or modify the function. The State , StateReason , and StateReasonCode fields in the response from  GetFunctionConfiguration indicate when the function is ready to invoke. For more information, see Lambda function states .
A function has an unpublished version, and can have published versions and aliases. The unpublished version changes when you update your function’s code and configuration. A published version is a snapshot of your function code and configuration that can’t be changed. An alias is a named resource that maps to a version, and can be changed to map to a different version. Use the Publish parameter to create version 1 of your function from its initial configuration.
The other parameters let you configure version-specific and function-level settings. You can modify version-specific settings later with  UpdateFunctionConfiguration . Function-level settings apply to both the unpublished and published versions of the function, and include tags ( TagResource ) and per-function concurrency limits ( PutFunctionConcurrency ).
You can use code signing if your deployment package is a .zip file archive. To enable code signing for this function, specify the ARN of a code-signing configuration. When a user attempts to deploy a code package with  UpdateFunctionCode , Lambda checks that the code package has a valid signature from a trusted publisher. The code-signing configuration includes set of signing profiles, which define the trusted publishers for this function.
If another Amazon Web Services account or an Amazon Web Services service invokes your function, use  AddPermission to grant permission by creating a resource-based Identity and Access Management (IAM) policy. You can grant permissions at the function level, on a version, or on an alias.
To invoke your function directly, use  Invoke . To invoke your function in response to events in other Amazon Web Services services, create an event source mapping ( CreateEventSourceMapping ), or configure a function trigger in the other service. For more information, see Invoking Lambda functions .
See also: AWS API Documentation


Synopsis¶
  create-function
--function-name <value>
[--runtime <value>]
--role <value>
[--handler <value>]
[--code <value>]
[--description <value>]
[--timeout <value>]
[--memory-size <value>]
[--publish | --no-publish]
[--vpc-config <value>]
[--package-type <value>]
[--dead-letter-config <value>]
[--environment <value>]
[--kms-key-arn <value>]
[--tracing-config <value>]
[--tags <value>]
[--layers <value>]
[--file-system-configs <value>]
[--image-config <value>]
[--code-signing-config-arn <value>]
[--architectures <value>]
[--ephemeral-storage <value>]
[--snap-start <value>]
[--logging-config <value>]
[--zip-file <value>]
[--cli-input-json <value>]
[--generate-cli-skeleton <value>]
[--debug]
[--endpoint-url <value>]
[--no-verify-ssl]
[--no-paginate]
[--output <value>]
[--query <value>]
[--profile <value>]
[--region <value>]
[--version <value>]
[--color <value>]
[--no-sign-request]
[--ca-bundle <value>]
[--cli-read-timeout <value>]
[--cli-connect-timeout <value>]




Options¶
--function-name (string)

The name or ARN of the Lambda function.

Name formats

Function name – my-function .
Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function .
Partial ARN – 123456789012:function:my-function .

The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.

--runtime (string)

The identifier of the function’s runtime . Runtime is required if the deployment package is a .zip file archive. Specifying a runtime results in an error if you’re deploying a function using a container image.
The following list includes deprecated runtimes. Lambda blocks creating new functions and updating existing functions shortly after each runtime is deprecated. For more information, see Runtime use after deprecation .
For a list of all currently supported runtimes, see Supported runtimes .
Possible values:

nodejs
nodejs4.3
nodejs6.10
nodejs8.10
nodejs10.x
nodejs12.x
nodejs14.x
nodejs16.x
java8
java8.al2
java11
python2.7
python3.6
python3.7
python3.8
python3.9
dotnetcore1.0
dotnetcore2.0
dotnetcore2.1
dotnetcore3.1
dotnet6
dotnet8
nodejs4.3-edge
go1.x
ruby2.5
ruby2.7
provided
provided.al2
nodejs18.x
python3.10
java17
ruby3.2
ruby3.3
ruby3.4
python3.11
nodejs20.x
provided.al2023
python3.12
java21
python3.13
nodejs22.x


--role (string)

The Amazon Resource Name (ARN) of the function’s execution role.
--handler (string)

The name of the method within your code that Lambda calls to run your function. Handler is required if the deployment package is a .zip file archive. The format includes the file name. It can also include namespaces and other qualifiers, depending on the runtime. For more information, see Lambda programming model .
--code (structure)

The code for the function.
S3Bucket -> (string)

An Amazon S3 bucket in the same Amazon Web Services Region as your function. The bucket can be in a different Amazon Web Services account.
S3Key -> (string)

The Amazon S3 key of the deployment package.
S3ObjectVersion -> (string)

For versioned objects, the version of the deployment package object to use.
ImageUri -> (string)

URI of a container image in the Amazon ECR registry.
SourceKMSKeyArn -> (string)

The ARN of the Key Management Service (KMS) customer managed key that’s used to encrypt your function’s .zip deployment package. If you don’t provide a customer managed key, Lambda uses an Amazon Web Services owned key .

Shorthand Syntax:
S3Bucket=string,S3Key=string,S3ObjectVersion=string,ImageUri=string,SourceKMSKeyArn=string


JSON Syntax:
{
  "S3Bucket": "string",
  "S3Key": "string",
  "S3ObjectVersion": "string",
  "ImageUri": "string",
  "SourceKMSKeyArn": "string"
}


--description (string)

A description of the function.
--timeout (integer)

The amount of time (in seconds) that Lambda allows a function to run before stopping it. The default is 3 seconds. The maximum allowed value is 900 seconds. For more information, see Lambda execution environment .
--memory-size (integer)

The amount of memory available to the function at runtime. Increasing the function memory also increases its CPU allocation. The default value is 128 MB. The value can be any multiple of 1 MB.
--publish | --no-publish (boolean)

Set to true to publish the first version of the function during creation.
--vpc-config (structure)

For network connectivity to Amazon Web Services resources in a VPC, specify a list of security groups and subnets in the VPC. When you connect a function to a VPC, it can access resources and the internet only through that VPC. For more information, see Configuring a Lambda function to access resources in a VPC .
SubnetIds -> (list)

A list of VPC subnet IDs.
(string)

SecurityGroupIds -> (list)

A list of VPC security group IDs.
(string)

Ipv6AllowedForDualStack -> (boolean)

Allows outbound IPv6 traffic on VPC functions that are connected to dual-stack subnets.

Shorthand Syntax:
SubnetIds=string,string,SecurityGroupIds=string,string,Ipv6AllowedForDualStack=boolean


JSON Syntax:
{
  "SubnetIds": ["string", ...],
  "SecurityGroupIds": ["string", ...],
  "Ipv6AllowedForDualStack": true|false
}


--package-type (string)

The type of deployment package. Set to Image for container image and set to Zip for .zip file archive.
Possible values:

Zip
Image


--dead-letter-config (structure)

A dead-letter queue configuration that specifies the queue or topic where Lambda sends asynchronous events when they fail processing. For more information, see Dead-letter queues .
TargetArn -> (string)

The Amazon Resource Name (ARN) of an Amazon SQS queue or Amazon SNS topic.

Shorthand Syntax:
TargetArn=string


JSON Syntax:
{
  "TargetArn": "string"
}


--environment (structure)

Environment variables that are accessible from function code during execution.
Variables -> (map)

Environment variable key-value pairs. For more information, see Using Lambda environment variables .
key -> (string)
value -> (string)


Shorthand Syntax:
Variables={KeyName1=string,KeyName2=string}


JSON Syntax:
{
  "Variables": {"string": "string"
    ...}
}


--kms-key-arn (string)

The ARN of the Key Management Service (KMS) customer managed key that’s used to encrypt the following resources:

The function’s environment variables .
The function’s Lambda SnapStart snapshots.
When used with SourceKMSKeyArn , the unzipped version of the .zip deployment package that’s used for function invocations. For more information, see Specifying a customer managed key for Lambda .
The optimized version of the container image that’s used for function invocations. Note that this is not the same key that’s used to protect your container image in the Amazon Elastic Container Registry (Amazon ECR). For more information, see Function lifecycle .

If you don’t provide a customer managed key, Lambda uses an Amazon Web Services owned key or an Amazon Web Services managed key .

--tracing-config (structure)

Set Mode to Active to sample and trace a subset of incoming requests with X-Ray .
Mode -> (string)

The tracing mode.

Shorthand Syntax:
Mode=string


JSON Syntax:
{
  "Mode": "Active"|"PassThrough"
}


--tags (map)

A list of tags to apply to the function.
key -> (string)
value -> (string)

Shorthand Syntax:
KeyName1=string,KeyName2=string


JSON Syntax:
{"string": "string"
  ...}


--layers (list)

A list of function layers to add to the function’s execution environment. Specify each layer by its ARN, including the version.
(string)

Syntax:
"string" "string" ...


--file-system-configs (list)

Connection settings for an Amazon EFS file system.
(structure)

Details about the connection between a Lambda function and an Amazon EFS file system .
Arn -> (string)

The Amazon Resource Name (ARN) of the Amazon EFS access point that provides access to the file system.
LocalMountPath -> (string)

The path where the function can access the file system, starting with /mnt/ .


Shorthand Syntax:
Arn=string,LocalMountPath=string ...


JSON Syntax:
[
  {
    "Arn": "string",
    "LocalMountPath": "string"
  }
  ...
]


--image-config (structure)

Container image configuration values that override the values in the container image Dockerfile.
EntryPoint -> (list)

Specifies the entry point to their application, which is typically the location of the runtime executable.
(string)

Command -> (list)

Specifies parameters that you want to pass in with ENTRYPOINT.
(string)

WorkingDirectory -> (string)

Specifies the working directory.

Shorthand Syntax:
EntryPoint=string,string,Command=string,string,WorkingDirectory=string


JSON Syntax:
{
  "EntryPoint": ["string", ...],
  "Command": ["string", ...],
  "WorkingDirectory": "string"
}


--code-signing-config-arn (string)

To enable code signing for this function, specify the ARN of a code-signing configuration. A code-signing configuration includes a set of signing profiles, which define the trusted publishers for this function.
--architectures (list)

The instruction set architecture that the function supports. Enter a string array with one of the valid values (arm64 or x86_64). The default value is x86_64 .
(string)

Syntax:
"string" "string" ...

Where valid values are:
  x86_64
  arm64


--ephemeral-storage (structure)

The size of the function’s /tmp directory in MB. The default value is 512, but can be any whole number between 512 and 10,240 MB. For more information, see Configuring ephemeral storage (console) .
Size -> (integer)

The size of the function’s /tmp directory.

Shorthand Syntax:
Size=integer


JSON Syntax:
{
  "Size": integer
}


--snap-start (structure)

The function’s SnapStart setting.
ApplyOn -> (string)

Set to PublishedVersions to create a snapshot of the initialized execution environment when you publish a function version.

Shorthand Syntax:
ApplyOn=string


JSON Syntax:
{
  "ApplyOn": "PublishedVersions"|"None"
}


--logging-config (structure)

The function’s Amazon CloudWatch Logs configuration settings.
LogFormat -> (string)

The format in which Lambda sends your function’s application and system logs to CloudWatch. Select between plain text and structured JSON.
ApplicationLogLevel -> (string)

Set this property to filter the application logs for your function that Lambda sends to CloudWatch. Lambda only sends application logs at the selected level of detail and lower, where TRACE is the highest level and FATAL is the lowest.
SystemLogLevel -> (string)

Set this property to filter the system logs for your function that Lambda sends to CloudWatch. Lambda only sends system logs at the selected level of detail and lower, where DEBUG is the highest level and WARN is the lowest.
LogGroup -> (string)

The name of the Amazon CloudWatch log group the function sends logs to. By default, Lambda functions send logs to a default log group named /aws/lambda/<function name> . To use a different log group, enter an existing log group or enter a new log group name.

Shorthand Syntax:
LogFormat=string,ApplicationLogLevel=string,SystemLogLevel=string,LogGroup=string


JSON Syntax:
{
  "LogFormat": "JSON"|"Text",
  "ApplicationLogLevel": "TRACE"|"DEBUG"|"INFO"|"WARN"|"ERROR"|"FATAL",
  "SystemLogLevel": "DEBUG"|"INFO"|"WARN",
  "LogGroup": "string"
}


--zip-file (blob)

The path to the zip file of the code you are uploading. Specify –zip-file or –code, but not both. Example: fileb://code.zip
--cli-input-json (string)
Performs service operation based on the JSON string provided. The JSON string follows the format provided by --generate-cli-skeleton. If other arguments are provided on the command line, the CLI values will override the JSON-provided values. It is not possible to pass arbitrary binary values using a JSON-provided value as the string will be taken literally.
--generate-cli-skeleton (string)
Prints a JSON skeleton to standard output without sending an API request. If provided with no value or the value input, prints a sample input JSON that can be used as an argument for --cli-input-json. If provided with the value output, it validates the command inputs and returns a sample output JSON for that command.


Global Options¶
--debug (boolean)
Turn on debug logging.
--endpoint-url (string)
Override command’s default URL with the given URL.
--no-verify-ssl (boolean)
By default, the AWS CLI uses SSL when communicating with AWS services. For each SSL connection, the AWS CLI will verify SSL certificates. This option overrides the default behavior of verifying SSL certificates.
--no-paginate (boolean)
Disable automatic pagination. If automatic pagination is disabled, the AWS CLI will only make one call, for the first page of results.
--output (string)
The formatting style for command output.

json
text
table

--query (string)
A JMESPath query to use in filtering the response data.
--profile (string)
Use a specific profile from your credential file.
--region (string)
The region to use. Overrides config/env settings.
--version (string)
Display the version of this tool.
--color (string)
Turn on/off color output.

on
off
auto

--no-sign-request (boolean)
Do not sign requests. Credentials will not be loaded if this argument is provided.
--ca-bundle (string)
The CA certificate bundle to use when verifying SSL certificates. Overrides config/env settings.
--cli-read-timeout (int)
The maximum socket read time in seconds. If the value is set to 0, the socket read will be blocking and not timeout. The default value is 60 seconds.
--cli-connect-timeout (int)
The maximum socket connect time in seconds. If the value is set to 0, the socket connect will be blocking and not timeout. The default value is 60 seconds.


Examples¶

NoteTo use the following examples, you must have the AWS CLI installed and configured. See the Getting started guide in the AWS CLI User Guide for more information.
Unless otherwise stated, all examples have unix-like quotation rules. These examples will need to be adapted to your terminal’s quoting rules. See Using quotation marks with strings in the AWS CLI User Guide .

To create a Lambda function
The following create-function example creates a Lambda function named my-function.
aws lambda create-function \
    --function-name my-function \
    --runtime nodejs18.x \
    --zip-file fileb://my-function.zip \
    --handler my-function.handler \
    --role arn:aws:iam::123456789012:role/service-role/MyTestFunction-role-tges6bf4


Contents of my-function.zip:
This file is a deployment package that contains your function code and any dependencies.


Output:
{
    "TracingConfig": {
        "Mode": "PassThrough"
    },
    "CodeSha256": "PFn4S+er27qk+UuZSTKEQfNKG/XNn7QJs90mJgq6oH8=",
    "FunctionName": "my-function",
    "CodeSize": 308,
    "RevisionId": "873282ed-4cd3-4dc8-a069-d0c647e470c6",
    "MemorySize": 128,
    "FunctionArn": "arn:aws:lambda:us-west-2:123456789012:function:my-function",
    "Version": "$LATEST",
    "Role": "arn:aws:iam::123456789012:role/service-role/MyTestFunction-role-zgur6bf4",
    "Timeout": 3,
    "LastModified": "2023-10-14T22:26:11.234+0000",
    "Handler": "my-function.handler",
    "Runtime": "nodejs18.x",
    "Description": ""
}


For more information, see AWS Lambda Function Configuration in the AWS Lambda Developer Guide.


Output¶
FunctionName -> (string)

The name of the function.
FunctionArn -> (string)

The function’s Amazon Resource Name (ARN).
Runtime -> (string)

The identifier of the function’s runtime . Runtime is required if the deployment package is a .zip file archive. Specifying a runtime results in an error if you’re deploying a function using a container image.
The following list includes deprecated runtimes. Lambda blocks creating new functions and updating existing functions shortly after each runtime is deprecated. For more information, see Runtime use after deprecation .
For a list of all currently supported runtimes, see Supported runtimes .

Role -> (string)

The function’s execution role.
Handler -> (string)

The function that Lambda calls to begin running your function.
CodeSize -> (long)

The size of the function’s deployment package, in bytes.
Description -> (string)

The function’s description.
Timeout -> (integer)

The amount of time in seconds that Lambda allows a function to run before stopping it.
MemorySize -> (integer)

The amount of memory available to the function at runtime.
LastModified -> (string)

The date and time that the function was last updated, in ISO-8601 format (YYYY-MM-DDThh:mm:ss.sTZD).
CodeSha256 -> (string)

The SHA256 hash of the function’s deployment package.
Version -> (string)

The version of the Lambda function.
VpcConfig -> (structure)

The function’s networking configuration.
SubnetIds -> (list)

A list of VPC subnet IDs.
(string)

SecurityGroupIds -> (list)

A list of VPC security group IDs.
(string)

VpcId -> (string)

The ID of the VPC.
Ipv6AllowedForDualStack -> (boolean)

Allows outbound IPv6 traffic on VPC functions that are connected to dual-stack subnets.

DeadLetterConfig -> (structure)

The function’s dead letter queue.
TargetArn -> (string)

The Amazon Resource Name (ARN) of an Amazon SQS queue or Amazon SNS topic.

Environment -> (structure)

The function’s environment variables . Omitted from CloudTrail logs.
Variables -> (map)

Environment variable key-value pairs. Omitted from CloudTrail logs.
key -> (string)
value -> (string)

Error -> (structure)

Error messages for environment variables that couldn’t be applied.
ErrorCode -> (string)

The error code.
Message -> (string)

The error message.


KMSKeyArn -> (string)

The ARN of the Key Management Service (KMS) customer managed key that’s used to encrypt the following resources:

The function’s environment variables .
The function’s Lambda SnapStart snapshots.
When used with SourceKMSKeyArn , the unzipped version of the .zip deployment package that’s used for function invocations. For more information, see Specifying a customer managed key for Lambda .
The optimized version of the container image that’s used for function invocations. Note that this is not the same key that’s used to protect your container image in the Amazon Elastic Container Registry (Amazon ECR). For more information, see Function lifecycle .

If you don’t provide a customer managed key, Lambda uses an Amazon Web Services owned key or an Amazon Web Services managed key .

TracingConfig -> (structure)

The function’s X-Ray tracing configuration.
Mode -> (string)

The tracing mode.

MasterArn -> (string)

For Lambda@Edge functions, the ARN of the main function.
RevisionId -> (string)

The latest updated revision of the function or alias.
Layers -> (list)

The function’s layers .
(structure)

An Lambda layer .
Arn -> (string)

The Amazon Resource Name (ARN) of the function layer.
CodeSize -> (long)

The size of the layer archive in bytes.
SigningProfileVersionArn -> (string)

The Amazon Resource Name (ARN) for a signing profile version.
SigningJobArn -> (string)

The Amazon Resource Name (ARN) of a signing job.


State -> (string)

The current state of the function. When the state is Inactive , you can reactivate the function by invoking it.
StateReason -> (string)

The reason for the function’s current state.
StateReasonCode -> (string)

The reason code for the function’s current state. When the code is Creating , you can’t invoke or modify the function.
LastUpdateStatus -> (string)

The status of the last update that was performed on the function. This is first set to Successful after function creation completes.
LastUpdateStatusReason -> (string)

The reason for the last update that was performed on the function.
LastUpdateStatusReasonCode -> (string)

The reason code for the last update that was performed on the function.
FileSystemConfigs -> (list)

Connection settings for an Amazon EFS file system .
(structure)

Details about the connection between a Lambda function and an Amazon EFS file system .
Arn -> (string)

The Amazon Resource Name (ARN) of the Amazon EFS access point that provides access to the file system.
LocalMountPath -> (string)

The path where the function can access the file system, starting with /mnt/ .


PackageType -> (string)

The type of deployment package. Set to Image for container image and set Zip for .zip file archive.
ImageConfigResponse -> (structure)

The function’s image configuration values.
ImageConfig -> (structure)

Configuration values that override the container image Dockerfile.
EntryPoint -> (list)

Specifies the entry point to their application, which is typically the location of the runtime executable.
(string)

Command -> (list)

Specifies parameters that you want to pass in with ENTRYPOINT.
(string)

WorkingDirectory -> (string)

Specifies the working directory.

Error -> (structure)

Error response to GetFunctionConfiguration .
ErrorCode -> (string)

Error code.
Message -> (string)

Error message.


SigningProfileVersionArn -> (string)

The ARN of the signing profile version.
SigningJobArn -> (string)

The ARN of the signing job.
Architectures -> (list)

The instruction set architecture that the function supports. Architecture is a string array with one of the valid values. The default architecture value is x86_64 .
(string)

EphemeralStorage -> (structure)

The size of the function’s /tmp directory in MB. The default value is 512, but can be any whole number between 512 and 10,240 MB. For more information, see Configuring ephemeral storage (console) .
Size -> (integer)

The size of the function’s /tmp directory.

SnapStart -> (structure)

Set ApplyOn to PublishedVersions to create a snapshot of the initialized execution environment when you publish a function version. For more information, see Improving startup performance with Lambda SnapStart .
ApplyOn -> (string)

When set to PublishedVersions , Lambda creates a snapshot of the execution environment when you publish a function version.
OptimizationStatus -> (string)

When you provide a qualified Amazon Resource Name (ARN) , this response element indicates whether SnapStart is activated for the specified function version.

RuntimeVersionConfig -> (structure)

The ARN of the runtime and any errors that occured.
RuntimeVersionArn -> (string)

The ARN of the runtime version you want the function to use.
Error -> (structure)

Error response when Lambda is unable to retrieve the runtime version for a function.
ErrorCode -> (string)

The error code.
Message -> (string)

The error message.


LoggingConfig -> (structure)

The function’s Amazon CloudWatch Logs configuration settings.
LogFormat -> (string)

The format in which Lambda sends your function’s application and system logs to CloudWatch. Select between plain text and structured JSON.
ApplicationLogLevel -> (string)

Set this property to filter the application logs for your function that Lambda sends to CloudWatch. Lambda only sends application logs at the selected level of detail and lower, where TRACE is the highest level and FATAL is the lowest.
SystemLogLevel -> (string)

Set this property to filter the system logs for your function that Lambda sends to CloudWatch. Lambda only sends system logs at the selected level of detail and lower, where DEBUG is the highest level and WARN is the lowest.
LogGroup -> (string)

The name of the Amazon CloudWatch log group the function sends logs to. By default, Lambda functions send logs to a default log group named /aws/lambda/<function name> . To use a different log group, enter an existing log group or enter a new log group name.\nNote:
                        You are viewing the documentation for an older major version of the AWS CLI (version 1).
                    
                    
                        AWS CLI version 2, the latest major version of AWS CLI, is now stable and recommended for general use.
                        
                            To view this page for the AWS CLI version 2, click
                            here.
                        
                        For more information see the AWS CLI version 2
                        installation instructions
                        and
                        migration guide.\nAWS CLI version 2, the latest major version of AWS CLI, is now stable and recommended for general use.
                        
                            To view this page for the AWS CLI version 2, click
                            here.
                        
                        For more information see the AWS CLI version 2
                        installation instructions
                        and
                        migration guide.\ninstallation instructions\ncreate-function¶

Description¶
Creates a Lambda function. To create a function, you need a deployment package and an execution role . The deployment package is a .zip file archive or container image that contains your function code. The execution role grants the function permission to use Amazon Web Services services, such as Amazon CloudWatch Logs for log streaming and X-Ray for request tracing.
If the deployment package is a container image , then you set the package type to Image . For a container image, the code property must include the URI of a container image in the Amazon ECR registry. You do not need to specify the handler and runtime properties.
If the deployment package is a .zip file archive , then you set the package type to Zip . For a .zip file archive, the code property specifies the location of the .zip file. You must also specify the handler and runtime properties. The code in the deployment package must be compatible with the target instruction set architecture of the function (x86-64 or arm64 ). If you do not specify the architecture, then the default value is x86-64 .
When you create a function, Lambda provisions an instance of the function and its supporting resources. If your function connects to a VPC, this process can take a minute or so. During this time, you can’t invoke or modify the function. The State , StateReason , and StateReasonCode fields in the response from  GetFunctionConfiguration indicate when the function is ready to invoke. For more information, see Lambda function states .
A function has an unpublished version, and can have published versions and aliases. The unpublished version changes when you update your function’s code and configuration. A published version is a snapshot of your function code and configuration that can’t be changed. An alias is a named resource that maps to a version, and can be changed to map to a different version. Use the Publish parameter to create version 1 of your function from its initial configuration.
The other parameters let you configure version-specific and function-level settings. You can modify version-specific settings later with  UpdateFunctionConfiguration . Function-level settings apply to both the unpublished and published versions of the function, and include tags ( TagResource ) and per-function concurrency limits ( PutFunctionConcurrency ).
You can use code signing if your deployment package is a .zip file archive. To enable code signing for this function, specify the ARN of a code-signing configuration. When a user attempts to deploy a code package with  UpdateFunctionCode , Lambda checks that the code package has a valid signature from a trusted publisher. The code-signing configuration includes set of signing profiles, which define the trusted publishers for this function.
If another Amazon Web Services account or an Amazon Web Services service invokes your function, use  AddPermission to grant permission by creating a resource-based Identity and Access Management (IAM) policy. You can grant permissions at the function level, on a version, or on an alias.
To invoke your function directly, use  Invoke . To invoke your function in response to events in other Amazon Web Services services, create an event source mapping ( CreateEventSourceMapping ), or configure a function trigger in the other service. For more information, see Invoking Lambda functions .
See also: AWS API Documentation


Synopsis¶
  create-function
--function-name <value>
[--runtime <value>]
--role <value>
[--handler <value>]
[--code <value>]
[--description <value>]
[--timeout <value>]
[--memory-size <value>]
[--publish | --no-publish]
[--vpc-config <value>]
[--package-type <value>]
[--dead-letter-config <value>]
[--environment <value>]
[--kms-key-arn <value>]
[--tracing-config <value>]
[--tags <value>]
[--layers <value>]
[--file-system-configs <value>]
[--image-config <value>]
[--code-signing-config-arn <value>]
[--architectures <value>]
[--ephemeral-storage <value>]
[--snap-start <value>]
[--logging-config <value>]
[--zip-file <value>]
[--cli-input-json <value>]
[--generate-cli-skeleton <value>]
[--debug]
[--endpoint-url <value>]
[--no-verify-ssl]
[--no-paginate]
[--output <value>]
[--query <value>]
[--profile <value>]
[--region <value>]
[--version <value>]
[--color <value>]
[--no-sign-request]
[--ca-bundle <value>]
[--cli-read-timeout <value>]
[--cli-connect-timeout <value>]




Options¶
--function-name (string)

The name or ARN of the Lambda function.

Name formats

Function name – my-function .
Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function .
Partial ARN – 123456789012:function:my-function .

The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.

--runtime (string)

The identifier of the function’s runtime . Runtime is required if the deployment package is a .zip file archive. Specifying a runtime results in an error if you’re deploying a function using a container image.
The following list includes deprecated runtimes. Lambda blocks creating new functions and updating existing functions shortly after each runtime is deprecated. For more information, see Runtime use after deprecation .
For a list of all currently supported runtimes, see Supported runtimes .
Possible values:

nodejs
nodejs4.3
nodejs6.10
nodejs8.10
nodejs10.x
nodejs12.x
nodejs14.x
nodejs16.x
java8
java8.al2
java11
python2.7
python3.6
python3.7
python3.8
python3.9
dotnetcore1.0
dotnetcore2.0
dotnetcore2.1
dotnetcore3.1
dotnet6
dotnet8
nodejs4.3-edge
go1.x
ruby2.5
ruby2.7
provided
provided.al2
nodejs18.x
python3.10
java17
ruby3.2
ruby3.3
ruby3.4
python3.11
nodejs20.x
provided.al2023
python3.12
java21
python3.13
nodejs22.x


--role (string)

The Amazon Resource Name (ARN) of the function’s execution role.
--handler (string)

The name of the method within your code that Lambda calls to run your function. Handler is required if the deployment package is a .zip file archive. The format includes the file name. It can also include namespaces and other qualifiers, depending on the runtime. For more information, see Lambda programming model .
--code (structure)

The code for the function.
S3Bucket -> (string)

An Amazon S3 bucket in the same Amazon Web Services Region as your function. The bucket can be in a different Amazon Web Services account.
S3Key -> (string)

The Amazon S3 key of the deployment package.
S3ObjectVersion -> (string)

For versioned objects, the version of the deployment package object to use.
ImageUri -> (string)

URI of a container image in the Amazon ECR registry.
SourceKMSKeyArn -> (string)

The ARN of the Key Management Service (KMS) customer managed key that’s used to encrypt your function’s .zip deployment package. If you don’t provide a customer managed key, Lambda uses an Amazon Web Services owned key .

Shorthand Syntax:
S3Bucket=string,S3Key=string,S3ObjectVersion=string,ImageUri=string,SourceKMSKeyArn=string


JSON Syntax:
{
  "S3Bucket": "string",
  "S3Key": "string",
  "S3ObjectVersion": "string",
  "ImageUri": "string",
  "SourceKMSKeyArn": "string"
}


--description (string)

A description of the function.
--timeout (integer)

The amount of time (in seconds) that Lambda allows a function to run before stopping it. The default is 3 seconds. The maximum allowed value is 900 seconds. For more information, see Lambda execution environment .
--memory-size (integer)

The amount of memory available to the function at runtime. Increasing the function memory also increases its CPU allocation. The default value is 128 MB. The value can be any multiple of 1 MB.
--publish | --no-publish (boolean)

Set to true to publish the first version of the function during creation.
--vpc-config (structure)

For network connectivity to Amazon Web Services resources in a VPC, specify a list of security groups and subnets in the VPC. When you connect a function to a VPC, it can access resources and the internet only through that VPC. For more information, see Configuring a Lambda function to access resources in a VPC .
SubnetIds -> (list)

A list of VPC subnet IDs.
(string)

SecurityGroupIds -> (list)

A list of VPC security group IDs.
(string)

Ipv6AllowedForDualStack -> (boolean)

Allows outbound IPv6 traffic on VPC functions that are connected to dual-stack subnets.

Shorthand Syntax:
SubnetIds=string,string,SecurityGroupIds=string,string,Ipv6AllowedForDualStack=boolean


JSON Syntax:
{
  "SubnetIds": ["string", ...],
  "SecurityGroupIds": ["string", ...],
  "Ipv6AllowedForDualStack": true|false
}


--package-type (string)

The type of deployment package. Set to Image for container image and set to Zip for .zip file archive.
Possible values:

Zip
Image


--dead-letter-config (structure)

A dead-letter queue configuration that specifies the queue or topic where Lambda sends asynchronous events when they fail processing. For more information, see Dead-letter queues .
TargetArn -> (string)

The Amazon Resource Name (ARN) of an Amazon SQS queue or Amazon SNS topic.

Shorthand Syntax:
TargetArn=string


JSON Syntax:
{
  "TargetArn": "string"
}


--environment (structure)

Environment variables that are accessible from function code during execution.
Variables -> (map)

Environment variable key-value pairs. For more information, see Using Lambda environment variables .
key -> (string)
value -> (string)


Shorthand Syntax:
Variables={KeyName1=string,KeyName2=string}


JSON Syntax:
{
  "Variables": {"string": "string"
    ...}
}


--kms-key-arn (string)

The ARN of the Key Management Service (KMS) customer managed key that’s used to encrypt the following resources:

The function’s environment variables .
The function’s Lambda SnapStart snapshots.
When used with SourceKMSKeyArn , the unzipped version of the .zip deployment package that’s used for function invocations. For more information, see Specifying a customer managed key for Lambda .
The optimized version of the container image that’s used for function invocations. Note that this is not the same key that’s used to protect your container image in the Amazon Elastic Container Registry (Amazon ECR). For more information, see Function lifecycle .

If you don’t provide a customer managed key, Lambda uses an Amazon Web Services owned key or an Amazon Web Services managed key .

--tracing-config (structure)

Set Mode to Active to sample and trace a subset of incoming requests with X-Ray .
Mode -> (string)

The tracing mode.

Shorthand Syntax:
Mode=string


JSON Syntax:
{
  "Mode": "Active"|"PassThrough"
}


--tags (map)

A list of tags to apply to the function.
key -> (string)
value -> (string)

Shorthand Syntax:
KeyName1=string,KeyName2=string


JSON Syntax:
{"string": "string"
  ...}


--layers (list)

A list of function layers to add to the function’s execution environment. Specify each layer by its ARN, including the version.
(string)

Syntax:
"string" "string" ...


--file-system-configs (list)

Connection settings for an Amazon EFS file system.
(structure)

Details about the connection between a Lambda function and an Amazon EFS file system .
Arn -> (string)

The Amazon Resource Name (ARN) of the Amazon EFS access point that provides access to the file system.
LocalMountPath -> (string)

The path where the function can access the file system, starting with /mnt/ .


Shorthand Syntax:
Arn=string,LocalMountPath=string ...


JSON Syntax:
[
  {
    "Arn": "string",
    "LocalMountPath": "string"
  }
  ...
]


--image-config (structure)

Container image configuration values that override the values in the container image Dockerfile.
EntryPoint -> (list)

Specifies the entry point to their application, which is typically the location of the runtime executable.
(string)

Command -> (list)

Specifies parameters that you want to pass in with ENTRYPOINT.
(string)

WorkingDirectory -> (string)

Specifies the working directory.

Shorthand Syntax:
EntryPoint=string,string,Command=string,string,WorkingDirectory=string


JSON Syntax:
{
  "EntryPoint": ["string", ...],
  "Command": ["string", ...],
  "WorkingDirectory": "string"
}


--code-signing-config-arn (string)

To enable code signing for this function, specify the ARN of a code-signing configuration. A code-signing configuration includes a set of signing profiles, which define the trusted publishers for this function.
--architectures (list)

The instruction set architecture that the function supports. Enter a string array with one of the valid values (arm64 or x86_64). The default value is x86_64 .
(string)

Syntax:
"string" "string" ...

Where valid values are:
  x86_64
  arm64


--ephemeral-storage (structure)

The size of the function’s /tmp directory in MB. The default value is 512, but can be any whole number between 512 and 10,240 MB. For more information, see Configuring ephemeral storage (console) .
Size -> (integer)

The size of the function’s /tmp directory.

Shorthand Syntax:
Size=integer


JSON Syntax:
{
  "Size": integer
}


--snap-start (structure)

The function’s SnapStart setting.
ApplyOn -> (string)

Set to PublishedVersions to create a snapshot of the initialized execution environment when you publish a function version.

Shorthand Syntax:
ApplyOn=string


JSON Syntax:
{
  "ApplyOn": "PublishedVersions"|"None"
}


--logging-config (structure)

The function’s Amazon CloudWatch Logs configuration settings.
LogFormat -> (string)

The format in which Lambda sends your function’s application and system logs to CloudWatch. Select between plain text and structured JSON.
ApplicationLogLevel -> (string)

Set this property to filter the application logs for your function that Lambda sends to CloudWatch. Lambda only sends application logs at the selected level of detail and lower, where TRACE is the highest level and FATAL is the lowest.
SystemLogLevel -> (string)

Set this property to filter the system logs for your function that Lambda sends to CloudWatch. Lambda only sends system logs at the selected level of detail and lower, where DEBUG is the highest level and WARN is the lowest.
LogGroup -> (string)

The name of the Amazon CloudWatch log group the function sends logs to. By default, Lambda functions send logs to a default log group named /aws/lambda/<function name> . To use a different log group, enter an existing log group or enter a new log group name.

Shorthand Syntax:
LogFormat=string,ApplicationLogLevel=string,SystemLogLevel=string,LogGroup=string


JSON Syntax:
{
  "LogFormat": "JSON"|"Text",
  "ApplicationLogLevel": "TRACE"|"DEBUG"|"INFO"|"WARN"|"ERROR"|"FATAL",
  "SystemLogLevel": "DEBUG"|"INFO"|"WARN",
  "LogGroup": "string"
}


--zip-file (blob)

The path to the zip file of the code you are uploading. Specify –zip-file or –code, but not both. Example: fileb://code.zip
--cli-input-json (string)
Performs service operation based on the JSON string provided. The JSON string follows the format provided by --generate-cli-skeleton. If other arguments are provided on the command line, the CLI values will override the JSON-provided values. It is not possible to pass arbitrary binary values using a JSON-provided value as the string will be taken literally.
--generate-cli-skeleton (string)
Prints a JSON skeleton to standard output without sending an API request. If provided with no value or the value input, prints a sample input JSON that can be used as an argument for --cli-input-json. If provided with the value output, it validates the command inputs and returns a sample output JSON for that command.


Global Options¶
--debug (boolean)
Turn on debug logging.
--endpoint-url (string)
Override command’s default URL with the given URL.
--no-verify-ssl (boolean)
By default, the AWS CLI uses SSL when communicating with AWS services. For each SSL connection, the AWS CLI will verify SSL certificates. This option overrides the default behavior of verifying SSL certificates.
--no-paginate (boolean)
Disable automatic pagination. If automatic pagination is disabled, the AWS CLI will only make one call, for the first page of results.
--output (string)
The formatting style for command output.

json
text
table

--query (string)
A JMESPath query to use in filtering the response data.
--profile (string)
Use a specific profile from your credential file.
--region (string)
The region to use. Overrides config/env settings.
--version (string)
Display the version of this tool.
--color (string)
Turn on/off color output.

on
off
auto

--no-sign-request (boolean)
Do not sign requests. Credentials will not be loaded if this argument is provided.
--ca-bundle (string)
The CA certificate bundle to use when verifying SSL certificates. Overrides config/env settings.
--cli-read-timeout (int)
The maximum socket read time in seconds. If the value is set to 0, the socket read will be blocking and not timeout. The default value is 60 seconds.
--cli-connect-timeout (int)
The maximum socket connect time in seconds. If the value is set to 0, the socket connect will be blocking and not timeout. The default value is 60 seconds.


Examples¶

NoteTo use the following examples, you must have the AWS CLI installed and configured. See the Getting started guide in the AWS CLI User Guide for more information.
Unless otherwise stated, all examples have unix-like quotation rules. These examples will need to be adapted to your terminal’s quoting rules. See Using quotation marks with strings in the AWS CLI User Guide .

To create a Lambda function
The following create-function example creates a Lambda function named my-function.
aws lambda create-function \
    --function-name my-function \
    --runtime nodejs18.x \
    --zip-file fileb://my-function.zip \
    --handler my-function.handler \
    --role arn:aws:iam::123456789012:role/service-role/MyTestFunction-role-tges6bf4


Contents of my-function.zip:
This file is a deployment package that contains your function code and any dependencies.


Output:
{
    "TracingConfig": {
        "Mode": "PassThrough"
    },
    "CodeSha256": "PFn4S+er27qk+UuZSTKEQfNKG/XNn7QJs90mJgq6oH8=",
    "FunctionName": "my-function",
    "CodeSize": 308,
    "RevisionId": "873282ed-4cd3-4dc8-a069-d0c647e470c6",
    "MemorySize": 128,
    "FunctionArn": "arn:aws:lambda:us-west-2:123456789012:function:my-function",
    "Version": "$LATEST",
    "Role": "arn:aws:iam::123456789012:role/service-role/MyTestFunction-role-zgur6bf4",
    "Timeout": 3,
    "LastModified": "2023-10-14T22:26:11.234+0000",
    "Handler": "my-function.handler",
    "Runtime": "nodejs18.x",
    "Description": ""
}


For more information, see AWS Lambda Function Configuration in the AWS Lambda Developer Guide.


Output¶
FunctionName -> (string)

The name of the function.
FunctionArn -> (string)

The function’s Amazon Resource Name (ARN).
Runtime -> (string)

The identifier of the function’s runtime . Runtime is required if the deployment package is a .zip file archive. Specifying a runtime results in an error if you’re deploying a function using a container image.
The following list includes deprecated runtimes. Lambda blocks creating new functions and updating existing functions shortly after each runtime is deprecated. For more information, see Runtime use after deprecation .
For a list of all currently supported runtimes, see Supported runtimes .

Role -> (string)

The function’s execution role.
Handler -> (string)

The function that Lambda calls to begin running your function.
CodeSize -> (long)

The size of the function’s deployment package, in bytes.
Description -> (string)

The function’s description.
Timeout -> (integer)

The amount of time in seconds that Lambda allows a function to run before stopping it.
MemorySize -> (integer)

The amount of memory available to the function at runtime.
LastModified -> (string)

The date and time that the function was last updated, in ISO-8601 format (YYYY-MM-DDThh:mm:ss.sTZD).
CodeSha256 -> (string)

The SHA256 hash of the function’s deployment package.
Version -> (string)

The version of the Lambda function.
VpcConfig -> (structure)

The function’s networking configuration.
SubnetIds -> (list)

A list of VPC subnet IDs.
(string)

SecurityGroupIds -> (list)

A list of VPC security group IDs.
(string)

VpcId -> (string)

The ID of the VPC.
Ipv6AllowedForDualStack -> (boolean)

Allows outbound IPv6 traffic on VPC functions that are connected to dual-stack subnets.

DeadLetterConfig -> (structure)

The function’s dead letter queue.
TargetArn -> (string)

The Amazon Resource Name (ARN) of an Amazon SQS queue or Amazon SNS topic.

Environment -> (structure)

The function’s environment variables . Omitted from CloudTrail logs.
Variables -> (map)

Environment variable key-value pairs. Omitted from CloudTrail logs.
key -> (string)
value -> (string)

Error -> (structure)

Error messages for environment variables that couldn’t be applied.
ErrorCode -> (string)

The error code.
Message -> (string)

The error message.


KMSKeyArn -> (string)

The ARN of the Key Management Service (KMS) customer managed key that’s used to encrypt the following resources:

The function’s environment variables .
The function’s Lambda SnapStart snapshots.
When used with SourceKMSKeyArn , the unzipped version of the .zip deployment package that’s used for function invocations. For more information, see Specifying a customer managed key for Lambda .
The optimized version of the container image that’s used for function invocations. Note that this is not the same key that’s used to protect your container image in the Amazon Elastic Container Registry (Amazon ECR). For more information, see Function lifecycle .

If you don’t provide a customer managed key, Lambda uses an Amazon Web Services owned key or an Amazon Web Services managed key .

TracingConfig -> (structure)

The function’s X-Ray tracing configuration.
Mode -> (string)

The tracing mode.

MasterArn -> (string)

For Lambda@Edge functions, the ARN of the main function.
RevisionId -> (string)

The latest updated revision of the function or alias.
Layers -> (list)

The function’s layers .
(structure)

An Lambda layer .
Arn -> (string)

The Amazon Resource Name (ARN) of the function layer.
CodeSize -> (long)

The size of the layer archive in bytes.
SigningProfileVersionArn -> (string)

The Amazon Resource Name (ARN) for a signing profile version.
SigningJobArn -> (string)

The Amazon Resource Name (ARN) of a signing job.


State -> (string)

The current state of the function. When the state is Inactive , you can reactivate the function by invoking it.
StateReason -> (string)

The reason for the function’s current state.
StateReasonCode -> (string)

The reason code for the function’s current state. When the code is Creating , you can’t invoke or modify the function.
LastUpdateStatus -> (string)

The status of the last update that was performed on the function. This is first set to Successful after function creation completes.
LastUpdateStatusReason -> (string)

The reason for the last update that was performed on the function.
LastUpdateStatusReasonCode -> (string)

The reason code for the last update that was performed on the function.
FileSystemConfigs -> (list)

Connection settings for an Amazon EFS file system .
(structure)

Details about the connection between a Lambda function and an Amazon EFS file system .
Arn -> (string)

The Amazon Resource Name (ARN) of the Amazon EFS access point that provides access to the file system.
LocalMountPath -> (string)

The path where the function can access the file system, starting with /mnt/ .


PackageType -> (string)

The type of deployment package. Set to Image for container image and set Zip for .zip file archive.
ImageConfigResponse -> (structure)

The function’s image configuration values.
ImageConfig -> (structure)

Configuration values that override the container image Dockerfile.
EntryPoint -> (list)

Specifies the entry point to their application, which is typically the location of the runtime executable.
(string)

Command -> (list)

Specifies parameters that you want to pass in with ENTRYPOINT.
(string)

WorkingDirectory -> (string)

Specifies the working directory.

Error -> (structure)

Error response to GetFunctionConfiguration .
ErrorCode -> (string)

Error code.
Message -> (string)

Error message.


SigningProfileVersionArn -> (string)

The ARN of the signing profile version.
SigningJobArn -> (string)

The ARN of the signing job.
Architectures -> (list)

The instruction set architecture that the function supports. Architecture is a string array with one of the valid values. The default architecture value is x86_64 .
(string)

EphemeralStorage -> (structure)

The size of the function’s /tmp directory in MB. The default value is 512, but can be any whole number between 512 and 10,240 MB. For more information, see Configuring ephemeral storage (console) .
Size -> (integer)

The size of the function’s /tmp directory.

SnapStart -> (structure)

Set ApplyOn to PublishedVersions to create a snapshot of the initialized execution environment when you publish a function version. For more information, see Improving startup performance with Lambda SnapStart .
ApplyOn -> (string)

When set to PublishedVersions , Lambda creates a snapshot of the execution environment when you publish a function version.
OptimizationStatus -> (string)

When you provide a qualified Amazon Resource Name (ARN) , this response element indicates whether SnapStart is activated for the specified function version.

RuntimeVersionConfig -> (structure)

The ARN of the runtime and any errors that occured.
RuntimeVersionArn -> (string)

The ARN of the runtime version you want the function to use.
Error -> (structure)

Error response when Lambda is unable to retrieve the runtime version for a function.
ErrorCode -> (string)

The error code.
Message -> (string)

The error message.


LoggingConfig -> (structure)

The function’s Amazon CloudWatch Logs configuration settings.
LogFormat -> (string)

The format in which Lambda sends your function’s application and system logs to CloudWatch. Select between plain text and structured JSON.
ApplicationLogLevel -> (string)

Set this property to filter the application logs for your function that Lambda sends to CloudWatch. Lambda only sends application logs at the selected level of detail and lower, where TRACE is the highest level and FATAL is the lowest.
SystemLogLevel -> (string)

Set this property to filter the system logs for your function that Lambda sends to CloudWatch. Lambda only sends system logs at the selected level of detail and lower, where DEBUG is the highest level and WARN is the lowest.
LogGroup -> (string)

The name of the Amazon CloudWatch log group the function sends logs to. By default, Lambda functions send logs to a default log group named /aws/lambda/<function name> . To use a different log group, enter an existing log group or enter a new log group name.\nDescription¶
Creates a Lambda function. To create a function, you need a deployment package and an execution role . The deployment package is a .zip file archive or container image that contains your function code. The execution role grants the function permission to use Amazon Web Services services, such as Amazon CloudWatch Logs for log streaming and X-Ray for request tracing.
If the deployment package is a container image , then you set the package type to Image . For a container image, the code property must include the URI of a container image in the Amazon ECR registry. You do not need to specify the handler and runtime properties.
If the deployment package is a .zip file archive , then you set the package type to Zip . For a .zip file archive, the code property specifies the location of the .zip file. You must also specify the handler and runtime properties. The code in the deployment package must be compatible with the target instruction set architecture of the function (x86-64 or arm64 ). If you do not specify the architecture, then the default value is x86-64 .
When you create a function, Lambda provisions an instance of the function and its supporting resources. If your function connects to a VPC, this process can take a minute or so. During this time, you can’t invoke or modify the function. The State , StateReason , and StateReasonCode fields in the response from  GetFunctionConfiguration indicate when the function is ready to invoke. For more information, see Lambda function states .
A function has an unpublished version, and can have published versions and aliases. The unpublished version changes when you update your function’s code and configuration. A published version is a snapshot of your function code and configuration that can’t be changed. An alias is a named resource that maps to a version, and can be changed to map to a different version. Use the Publish parameter to create version 1 of your function from its initial configuration.
The other parameters let you configure version-specific and function-level settings. You can modify version-specific settings later with  UpdateFunctionConfiguration . Function-level settings apply to both the unpublished and published versions of the function, and include tags ( TagResource ) and per-function concurrency limits ( PutFunctionConcurrency ).
You can use code signing if your deployment package is a .zip file archive. To enable code signing for this function, specify the ARN of a code-signing configuration. When a user attempts to deploy a code package with  UpdateFunctionCode , Lambda checks that the code package has a valid signature from a trusted publisher. The code-signing configuration includes set of signing profiles, which define the trusted publishers for this function.
If another Amazon Web Services account or an Amazon Web Services service invokes your function, use  AddPermission to grant permission by creating a resource-based Identity and Access Management (IAM) policy. You can grant permissions at the function level, on a version, or on an alias.
To invoke your function directly, use  Invoke . To invoke your function in response to events in other Amazon Web Services services, create an event source mapping ( CreateEventSourceMapping ), or configure a function trigger in the other service. For more information, see Invoking Lambda functions .
See also: AWS API Documentation\nCreates a Lambda function. To create a function, you need a deployment package and an execution role . The deployment package is a .zip file archive or container image that contains your function code. The execution role grants the function permission to use Amazon Web Services services, such as Amazon CloudWatch Logs for log streaming and X-Ray for request tracing.\nIf the deployment package is a container image , then you set the package type to Image . For a container image, the code property must include the URI of a container image in the Amazon ECR registry. You do not need to specify the handler and runtime properties.\nIf the deployment package is a .zip file archive , then you set the package type to Zip . For a .zip file archive, the code property specifies the location of the .zip file. You must also specify the handler and runtime properties. The code in the deployment package must be compatible with the target instruction set architecture of the function (x86-64 or arm64 ). If you do not specify the architecture, then the default value is x86-64 .\nWhen you create a function, Lambda provisions an instance of the function and its supporting resources. If your function connects to a VPC, this process can take a minute or so. During this time, you can’t invoke or modify the function. The State , StateReason , and StateReasonCode fields in the response from  GetFunctionConfiguration indicate when the function is ready to invoke. For more information, see Lambda function states .\nLambda function states\nA function has an unpublished version, and can have published versions and aliases. The unpublished version changes when you update your function’s code and configuration. A published version is a snapshot of your function code and configuration that can’t be changed. An alias is a named resource that maps to a version, and can be changed to map to a different version. Use the Publish parameter to create version 1 of your function from its initial configuration.\nThe other parameters let you configure version-specific and function-level settings. You can modify version-specific settings later with  UpdateFunctionConfiguration . Function-level settings apply to both the unpublished and published versions of the function, and include tags ( TagResource ) and per-function concurrency limits ( PutFunctionConcurrency ).\nYou can use code signing if your deployment package is a .zip file archive. To enable code signing for this function, specify the ARN of a code-signing configuration. When a user attempts to deploy a code package with  UpdateFunctionCode , Lambda checks that the code package has a valid signature from a trusted publisher. The code-signing configuration includes set of signing profiles, which define the trusted publishers for this function.\nIf another Amazon Web Services account or an Amazon Web Services service invokes your function, use  AddPermission to grant permission by creating a resource-based Identity and Access Management (IAM) policy. You can grant permissions at the function level, on a version, or on an alias.\nTo invoke your function directly, use  Invoke . To invoke your function in response to events in other Amazon Web Services services, create an event source mapping ( CreateEventSourceMapping ), or configure a function trigger in the other service. For more information, see Invoking Lambda functions .\nInvoking Lambda functions\nSee also: AWS API Documentation\nAWS API Documentation\nSynopsis¶
  create-function
--function-name <value>
[--runtime <value>]
--role <value>
[--handler <value>]
[--code <value>]
[--description <value>]
[--timeout <value>]
[--memory-size <value>]
[--publish | --no-publish]
[--vpc-config <value>]
[--package-type <value>]
[--dead-letter-config <value>]
[--environment <value>]
[--kms-key-arn <value>]
[--tracing-config <value>]
[--tags <value>]
[--layers <value>]
[--file-system-configs <value>]
[--image-config <value>]
[--code-signing-config-arn <value>]
[--architectures <value>]
[--ephemeral-storage <value>]
[--snap-start <value>]
[--logging-config <value>]
[--zip-file <value>]
[--cli-input-json <value>]
[--generate-cli-skeleton <value>]
[--debug]
[--endpoint-url <value>]
[--no-verify-ssl]
[--no-paginate]
[--output <value>]
[--query <value>]
[--profile <value>]
[--region <value>]
[--version <value>]
[--color <value>]
[--no-sign-request]
[--ca-bundle <value>]
[--cli-read-timeout <value>]
[--cli-connect-timeout <value>]\ncreate-function
--function-name <value>
[--runtime <value>]
--role <value>
[--handler <value>]
[--code <value>]
[--description <value>]
[--timeout <value>]
[--memory-size <value>]
[--publish | --no-publish]
[--vpc-config <value>]
[--package-type <value>]
[--dead-letter-config <value>]
[--environment <value>]
[--kms-key-arn <value>]
[--tracing-config <value>]
[--tags <value>]
[--layers <value>]
[--file-system-configs <value>]
[--image-config <value>]
[--code-signing-config-arn <value>]
[--architectures <value>]
[--ephemeral-storage <value>]
[--snap-start <value>]
[--logging-config <value>]
[--zip-file <value>]
[--cli-input-json <value>]
[--generate-cli-skeleton <value>]
[--debug]
[--endpoint-url <value>]
[--no-verify-ssl]
[--no-paginate]
[--output <value>]
[--query <value>]
[--profile <value>]
[--region <value>]
[--version <value>]
[--color <value>]
[--no-sign-request]
[--ca-bundle <value>]
[--cli-read-timeout <value>]
[--cli-connect-timeout <value>]\ncreate-function
--function-name <value>
[--runtime <value>]
--role <value>
[--handler <value>]
[--code <value>]
[--description <value>]
[--timeout <value>]
[--memory-size <value>]
[--publish | --no-publish]
[--vpc-config <value>]
[--package-type <value>]
[--dead-letter-config <value>]
[--environment <value>]
[--kms-key-arn <value>]
[--tracing-config <value>]
[--tags <value>]
[--layers <value>]
[--file-system-configs <value>]
[--image-config <value>]
[--code-signing-config-arn <value>]
[--architectures <value>]
[--ephemeral-storage <value>]
[--snap-start <value>]
[--logging-config <value>]
[--zip-file <value>]
[--cli-input-json <value>]
[--generate-cli-skeleton <value>]
[--debug]
[--endpoint-url <value>]
[--no-verify-ssl]
[--no-paginate]
[--output <value>]
[--query <value>]
[--profile <value>]
[--region <value>]
[--version <value>]
[--color <value>]
[--no-sign-request]
[--ca-bundle <value>]
[--cli-read-timeout <value>]
[--cli-connect-timeout <value>]\nOptions¶
--function-name (string)

The name or ARN of the Lambda function.

Name formats

Function name – my-function .
Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function .
Partial ARN – 123456789012:function:my-function .

The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.

--runtime (string)

The identifier of the function’s runtime . Runtime is required if the deployment package is a .zip file archive. Specifying a runtime results in an error if you’re deploying a function using a container image.
The following list includes deprecated runtimes. Lambda blocks creating new functions and updating existing functions shortly after each runtime is deprecated. For more information, see Runtime use after deprecation .
For a list of all currently supported runtimes, see Supported runtimes .
Possible values:

nodejs
nodejs4.3
nodejs6.10
nodejs8.10
nodejs10.x
nodejs12.x
nodejs14.x
nodejs16.x
java8
java8.al2
java11
python2.7
python3.6
python3.7
python3.8
python3.9
dotnetcore1.0
dotnetcore2.0
dotnetcore2.1
dotnetcore3.1
dotnet6
dotnet8
nodejs4.3-edge
go1.x
ruby2.5
ruby2.7
provided
provided.al2
nodejs18.x
python3.10
java17
ruby3.2
ruby3.3
ruby3.4
python3.11
nodejs20.x
provided.al2023
python3.12
java21
python3.13
nodejs22.x


--role (string)

The Amazon Resource Name (ARN) of the function’s execution role.
--handler (string)

The name of the method within your code that Lambda calls to run your function. Handler is required if the deployment package is a .zip file archive. The format includes the file name. It can also include namespaces and other qualifiers, depending on the runtime. For more information, see Lambda programming model .
--code (structure)

The code for the function.
S3Bucket -> (string)

An Amazon S3 bucket in the same Amazon Web Services Region as your function. The bucket can be in a different Amazon Web Services account.
S3Key -> (string)

The Amazon S3 key of the deployment package.
S3ObjectVersion -> (string)

For versioned objects, the version of the deployment package object to use.
ImageUri -> (string)

URI of a container image in the Amazon ECR registry.
SourceKMSKeyArn -> (string)

The ARN of the Key Management Service (KMS) customer managed key that’s used to encrypt your function’s .zip deployment package. If you don’t provide a customer managed key, Lambda uses an Amazon Web Services owned key .

Shorthand Syntax:
S3Bucket=string,S3Key=string,S3ObjectVersion=string,ImageUri=string,SourceKMSKeyArn=string


JSON Syntax:
{
  "S3Bucket": "string",
  "S3Key": "string",
  "S3ObjectVersion": "string",
  "ImageUri": "string",
  "SourceKMSKeyArn": "string"
}


--description (string)

A description of the function.
--timeout (integer)

The amount of time (in seconds) that Lambda allows a function to run before stopping it. The default is 3 seconds. The maximum allowed value is 900 seconds. For more information, see Lambda execution environment .
--memory-size (integer)

The amount of memory available to the function at runtime. Increasing the function memory also increases its CPU allocation. The default value is 128 MB. The value can be any multiple of 1 MB.
--publish | --no-publish (boolean)

Set to true to publish the first version of the function during creation.
--vpc-config (structure)

For network connectivity to Amazon Web Services resources in a VPC, specify a list of security groups and subnets in the VPC. When you connect a function to a VPC, it can access resources and the internet only through that VPC. For more information, see Configuring a Lambda function to access resources in a VPC .
SubnetIds -> (list)

A list of VPC subnet IDs.
(string)

SecurityGroupIds -> (list)

A list of VPC security group IDs.
(string)

Ipv6AllowedForDualStack -> (boolean)

Allows outbound IPv6 traffic on VPC functions that are connected to dual-stack subnets.

Shorthand Syntax:
SubnetIds=string,string,SecurityGroupIds=string,string,Ipv6AllowedForDualStack=boolean


JSON Syntax:
{
  "SubnetIds": ["string", ...],
  "SecurityGroupIds": ["string", ...],
  "Ipv6AllowedForDualStack": true|false
}


--package-type (string)

The type of deployment package. Set to Image for container image and set to Zip for .zip file archive.
Possible values:

Zip
Image


--dead-letter-config (structure)

A dead-letter queue configuration that specifies the queue or topic where Lambda sends asynchronous events when they fail processing. For more information, see Dead-letter queues .
TargetArn -> (string)

The Amazon Resource Name (ARN) of an Amazon SQS queue or Amazon SNS topic.

Shorthand Syntax:
TargetArn=string


JSON Syntax:
{
  "TargetArn": "string"
}


--environment (structure)

Environment variables that are accessible from function code during execution.
Variables -> (map)

Environment variable key-value pairs. For more information, see Using Lambda environment variables .
key -> (string)
value -> (string)


Shorthand Syntax:
Variables={KeyName1=string,KeyName2=string}


JSON Syntax:
{
  "Variables": {"string": "string"
    ...}
}


--kms-key-arn (string)

The ARN of the Key Management Service (KMS) customer managed key that’s used to encrypt the following resources:

The function’s environment variables .
The function’s Lambda SnapStart snapshots.
When used with SourceKMSKeyArn , the unzipped version of the .zip deployment package that’s used for function invocations. For more information, see Specifying a customer managed key for Lambda .
The optimized version of the container image that’s used for function invocations. Note that this is not the same key that’s used to protect your container image in the Amazon Elastic Container Registry (Amazon ECR). For more information, see Function lifecycle .

If you don’t provide a customer managed key, Lambda uses an Amazon Web Services owned key or an Amazon Web Services managed key .

--tracing-config (structure)

Set Mode to Active to sample and trace a subset of incoming requests with X-Ray .
Mode -> (string)

The tracing mode.

Shorthand Syntax:
Mode=string


JSON Syntax:
{
  "Mode": "Active"|"PassThrough"
}


--tags (map)

A list of tags to apply to the function.
key -> (string)
value -> (string)

Shorthand Syntax:
KeyName1=string,KeyName2=string


JSON Syntax:
{"string": "string"
  ...}


--layers (list)

A list of function layers to add to the function’s execution environment. Specify each layer by its ARN, including the version.
(string)

Syntax:
"string" "string" ...


--file-system-configs (list)

Connection settings for an Amazon EFS file system.
(structure)

Details about the connection between a Lambda function and an Amazon EFS file system .
Arn -> (string)

The Amazon Resource Name (ARN) of the Amazon EFS access point that provides access to the file system.
LocalMountPath -> (string)

The path where the function can access the file system, starting with /mnt/ .


Shorthand Syntax:
Arn=string,LocalMountPath=string ...


JSON Syntax:
[
  {
    "Arn": "string",
    "LocalMountPath": "string"
  }
  ...
]


--image-config (structure)

Container image configuration values that override the values in the container image Dockerfile.
EntryPoint -> (list)

Specifies the entry point to their application, which is typically the location of the runtime executable.
(string)

Command -> (list)

Specifies parameters that you want to pass in with ENTRYPOINT.
(string)

WorkingDirectory -> (string)

Specifies the working directory.

Shorthand Syntax:
EntryPoint=string,string,Command=string,string,WorkingDirectory=string


JSON Syntax:
{
  "EntryPoint": ["string", ...],
  "Command": ["string", ...],
  "WorkingDirectory": "string"
}


--code-signing-config-arn (string)

To enable code signing for this function, specify the ARN of a code-signing configuration. A code-signing configuration includes a set of signing profiles, which define the trusted publishers for this function.
--architectures (list)

The instruction set architecture that the function supports. Enter a string array with one of the valid values (arm64 or x86_64). The default value is x86_64 .
(string)

Syntax:
"string" "string" ...

Where valid values are:
  x86_64
  arm64


--ephemeral-storage (structure)

The size of the function’s /tmp directory in MB. The default value is 512, but can be any whole number between 512 and 10,240 MB. For more information, see Configuring ephemeral storage (console) .
Size -> (integer)

The size of the function’s /tmp directory.

Shorthand Syntax:
Size=integer


JSON Syntax:
{
  "Size": integer
}


--snap-start (structure)

The function’s SnapStart setting.
ApplyOn -> (string)

Set to PublishedVersions to create a snapshot of the initialized execution environment when you publish a function version.

Shorthand Syntax:
ApplyOn=string


JSON Syntax:
{
  "ApplyOn": "PublishedVersions"|"None"
}


--logging-config (structure)

The function’s Amazon CloudWatch Logs configuration settings.
LogFormat -> (string)

The format in which Lambda sends your function’s application and system logs to CloudWatch. Select between plain text and structured JSON.
ApplicationLogLevel -> (string)

Set this property to filter the application logs for your function that Lambda sends to CloudWatch. Lambda only sends application logs at the selected level of detail and lower, where TRACE is the highest level and FATAL is the lowest.
SystemLogLevel -> (string)

Set this property to filter the system logs for your function that Lambda sends to CloudWatch. Lambda only sends system logs at the selected level of detail and lower, where DEBUG is the highest level and WARN is the lowest.
LogGroup -> (string)

The name of the Amazon CloudWatch log group the function sends logs to. By default, Lambda functions send logs to a default log group named /aws/lambda/<function name> . To use a different log group, enter an existing log group or enter a new log group name.

Shorthand Syntax:
LogFormat=string,ApplicationLogLevel=string,SystemLogLevel=string,LogGroup=string


JSON Syntax:
{
  "LogFormat": "JSON"|"Text",
  "ApplicationLogLevel": "TRACE"|"DEBUG"|"INFO"|"WARN"|"ERROR"|"FATAL",
  "SystemLogLevel": "DEBUG"|"INFO"|"WARN",
  "LogGroup": "string"
}


--zip-file (blob)

The path to the zip file of the code you are uploading. Specify –zip-file or –code, but not both. Example: fileb://code.zip
--cli-input-json (string)
Performs service operation based on the JSON string provided. The JSON string follows the format provided by --generate-cli-skeleton. If other arguments are provided on the command line, the CLI values will override the JSON-provided values. It is not possible to pass arbitrary binary values using a JSON-provided value as the string will be taken literally.
--generate-cli-skeleton (string)
Prints a JSON skeleton to standard output without sending an API request. If provided with no value or the value input, prints a sample input JSON that can be used as an argument for --cli-input-json. If provided with the value output, it validates the command inputs and returns a sample output JSON for that command.\n--function-name (string)\nThe name or ARN of the Lambda function.

Name formats

Function name – my-function .
Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function .
Partial ARN – 123456789012:function:my-function .

The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.\nThe name or ARN of the Lambda function.\nFunction name – my-function .\nFunction ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function .\narn:aws:lambda:us-west-2:123456789012:function:my-function\nPartial ARN – 123456789012:function:my-function .\n123456789012:function:my-function\nThe length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64 characters in length.\nThe identifier of the function’s runtime . Runtime is required if the deployment package is a .zip file archive. Specifying a runtime results in an error if you’re deploying a function using a container image.
The following list includes deprecated runtimes. Lambda blocks creating new functions and updating existing functions shortly after each runtime is deprecated. For more information, see Runtime use after deprecation .
For a list of all currently supported runtimes, see Supported runtimes .
Possible values:

nodejs
nodejs4.3
nodejs6.10
nodejs8.10
nodejs10.x
nodejs12.x
nodejs14.x
nodejs16.x
java8
java8.al2
java11
python2.7
python3.6
python3.7
python3.8
python3.9
dotnetcore1.0
dotnetcore2.0
dotnetcore2.1
dotnetcore3.1
dotnet6
dotnet8
nodejs4.3-edge
go1.x
ruby2.5
ruby2.7
provided
provided.al2
nodejs18.x
python3.10
java17
ruby3.2
ruby3.3
ruby3.4
python3.11
nodejs20.x
provided.al2023
python3.12
java21
python3.13
nodejs22.x\nThe identifier of the function’s runtime . Runtime is required if the deployment package is a .zip file archive. Specifying a runtime results in an error if you’re deploying a function using a container image.\nThe following list includes deprecated runtimes. Lambda blocks creating new functions and updating existing functions shortly after each runtime is deprecated. For more information, see Runtime use after deprecation .\nRuntime use after deprecation\nFor a list of all currently supported runtimes, see Supported runtimes .\nThe Amazon Resource Name (ARN) of the function’s execution role.\nThe name of the method within your code that Lambda calls to run your function. Handler is required if the deployment package is a .zip file archive. The format includes the file name. It can also include namespaces and other qualifiers, depending on the runtime. For more information, see Lambda programming model .\nLambda programming model\nThe code for the function.
S3Bucket -> (string)

An Amazon S3 bucket in the same Amazon Web Services Region as your function. The bucket can be in a different Amazon Web Services account.
S3Key -> (string)

The Amazon S3 key of the deployment package.
S3ObjectVersion -> (string)

For versioned objects, the version of the deployment package object to use.
ImageUri -> (string)

URI of a container image in the Amazon ECR registry.
SourceKMSKeyArn -> (string)

The ARN of the Key Management Service (KMS) customer managed key that’s used to encrypt your function’s .zip deployment package. If you don’t provide a customer managed key, Lambda uses an Amazon Web Services owned key .\nThe code for the function.\nAn Amazon S3 bucket in the same Amazon Web Services Region as your function. The bucket can be in a different Amazon Web Services account.\nThe Amazon S3 key of the deployment package.\nS3ObjectVersion -> (string)\nFor versioned objects, the version of the deployment package object to use.\nURI of a container image in the Amazon ECR registry.\nSourceKMSKeyArn -> (string)\nThe ARN of the Key Management Service (KMS) customer managed key that’s used to encrypt your function’s .zip deployment package. If you don’t provide a customer managed key, Lambda uses an Amazon Web Services owned key .\nAmazon Web Services owned key\nS3Bucket=string,S3Key=string,S3ObjectVersion=string,ImageUri=string,SourceKMSKeyArn=string\nS3Bucket=string,S3Key=string,S3ObjectVersion=string,ImageUri=string,SourceKMSKeyArn=string\n{
  "S3Bucket": "string",
  "S3Key": "string",
  "S3ObjectVersion": "string",
  "ImageUri": "string",
  "SourceKMSKeyArn": "string"
}\n{
  "S3Bucket": "string",
  "S3Key": "string",
  "S3ObjectVersion": "string",
  "ImageUri": "string",
  "SourceKMSKeyArn": "string"
}\n--description (string)\nA description of the function.\nThe amount of time (in seconds) that Lambda allows a function to run before stopping it. The default is 3 seconds. The maximum allowed value is 900 seconds. For more information, see Lambda execution environment .\nLambda execution environment\n--memory-size (integer)\nThe amount of memory available to the function at runtime. Increasing the function memory also increases its CPU allocation. The default value is 128 MB. The value can be any multiple of 1 MB.\nmemory available to the function\n--publish | --no-publish (boolean)\nSet to true to publish the first version of the function during creation.\n--vpc-config (structure)\nFor network connectivity to Amazon Web Services resources in a VPC, specify a list of security groups and subnets in the VPC. When you connect a function to a VPC, it can access resources and the internet only through that VPC. For more information, see Configuring a Lambda function to access resources in a VPC .
SubnetIds -> (list)

A list of VPC subnet IDs.
(string)

SecurityGroupIds -> (list)

A list of VPC security group IDs.
(string)

Ipv6AllowedForDualStack -> (boolean)

Allows outbound IPv6 traffic on VPC functions that are connected to dual-stack subnets.\nFor network connectivity to Amazon Web Services resources in a VPC, specify a list of security groups and subnets in the VPC. When you connect a function to a VPC, it can access resources and the internet only through that VPC. For more information, see Configuring a Lambda function to access resources in a VPC .\nConfiguring a Lambda function to access resources in a VPC\nA list of VPC subnet IDs.
(string)\nA list of VPC subnet IDs.\nSecurityGroupIds -> (list)\nA list of VPC security group IDs.
(string)\nA list of VPC security group IDs.\nIpv6AllowedForDualStack -> (boolean)\nAllows outbound IPv6 traffic on VPC functions that are connected to dual-stack subnets.\nSubnetIds=string,string,SecurityGroupIds=string,string,Ipv6AllowedForDualStack=boolean\nSubnetIds=string,string,SecurityGroupIds=string,string,Ipv6AllowedForDualStack=boolean\nIpv6AllowedForDualStack\n{
  "SubnetIds": ["string", ...],
  "SecurityGroupIds": ["string", ...],
  "Ipv6AllowedForDualStack": true|false
}\n{
  "SubnetIds": ["string", ...],
  "SecurityGroupIds": ["string", ...],
  "Ipv6AllowedForDualStack": true|false
}\n"Ipv6AllowedForDualStack"\n--package-type (string)\nThe type of deployment package. Set to Image for container image and set to Zip for .zip file archive.
Possible values:

Zip
Image\nThe type of deployment package. Set to Image for container image and set to Zip for .zip file archive.\n--dead-letter-config (structure)\nA dead-letter queue configuration that specifies the queue or topic where Lambda sends asynchronous events when they fail processing. For more information, see Dead-letter queues .
TargetArn -> (string)

The Amazon Resource Name (ARN) of an Amazon SQS queue or Amazon SNS topic.\nA dead-letter queue configuration that specifies the queue or topic where Lambda sends asynchronous events when they fail processing. For more information, see Dead-letter queues .\nTargetArn -> (string)\nThe Amazon Resource Name (ARN) of an Amazon SQS queue or Amazon SNS topic.\n{
  "TargetArn": "string"
}\n{
  "TargetArn": "string"
}\n--environment (structure)\nEnvironment variables that are accessible from function code during execution.
Variables -> (map)

Environment variable key-value pairs. For more information, see Using Lambda environment variables .
key -> (string)
value -> (string)\nEnvironment variables that are accessible from function code during execution.\nEnvironment variable key-value pairs. For more information, see Using Lambda environment variables .
key -> (string)
value -> (string)\nEnvironment variable key-value pairs. For more information, see Using Lambda environment variables .\nUsing Lambda environment variables\nVariables={KeyName1=string,KeyName2=string}\nVariables={KeyName1=string,KeyName2=string}\n{
  "Variables": {"string": "string"
    ...}
}\n{
  "Variables": {"string": "string"
    ...}
}\n--kms-key-arn (string)\nThe ARN of the Key Management Service (KMS) customer managed key that’s used to encrypt the following resources:

The function’s environment variables .
The function’s Lambda SnapStart snapshots.
When used with SourceKMSKeyArn , the unzipped version of the .zip deployment package that’s used for function invocations. For more information, see Specifying a customer managed key for Lambda .
The optimized version of the container image that’s used for function invocations. Note that this is not the same key that’s used to protect your container image in the Amazon Elastic Container Registry (Amazon ECR). For more information, see Function lifecycle .

If you don’t provide a customer managed key, Lambda uses an Amazon Web Services owned key or an Amazon Web Services managed key .\nThe ARN of the Key Management Service (KMS) customer managed key that’s used to encrypt the following resources:\nThe function’s environment variables .\nenvironment variables\nThe function’s Lambda SnapStart snapshots.\nWhen used with SourceKMSKeyArn , the unzipped version of the .zip deployment package that’s used for function invocations. For more information, see Specifying a customer managed key for Lambda .\nSpecifying a customer managed key for Lambda\nThe optimized version of the container image that’s used for function invocations. Note that this is not the same key that’s used to protect your container image in the Amazon Elastic Container Registry (Amazon ECR). For more information, see Function lifecycle .\nIf you don’t provide a customer managed key, Lambda uses an Amazon Web Services owned key or an Amazon Web Services managed key .\nAmazon Web Services owned key\nAmazon Web Services managed key\n--tracing-config (structure)\nSet Mode to Active to sample and trace a subset of incoming requests with X-Ray .
Mode -> (string)

The tracing mode.\nSet Mode to Active to sample and trace a subset of incoming requests with X-Ray .\n{
  "Mode": "Active"|"PassThrough"
}\n{
  "Mode": "Active"|"PassThrough"
}\nA list of tags to apply to the function.
key -> (string)
value -> (string)\nA list of tags to apply to the function.\nKeyName1=string,KeyName2=string\nKeyName1=string,KeyName2=string\n{"string": "string"
  ...}\n{"string": "string"
  ...}\nA list of function layers to add to the function’s execution environment. Specify each layer by its ARN, including the version.
(string)\nA list of function layers to add to the function’s execution environment. Specify each layer by its ARN, including the version.\n"string" "string" ...\n"string" "string" ...\n--file-system-configs (list)\n--file-system-configs\nConnection settings for an Amazon EFS file system.
(structure)

Details about the connection between a Lambda function and an Amazon EFS file system .
Arn -> (string)

The Amazon Resource Name (ARN) of the Amazon EFS access point that provides access to the file system.
LocalMountPath -> (string)

The path where the function can access the file system, starting with /mnt/ .\nConnection settings for an Amazon EFS file system.\nDetails about the connection between a Lambda function and an Amazon EFS file system .
Arn -> (string)

The Amazon Resource Name (ARN) of the Amazon EFS access point that provides access to the file system.
LocalMountPath -> (string)

The path where the function can access the file system, starting with /mnt/ .\nDetails about the connection between a Lambda function and an Amazon EFS file system .\nAmazon EFS file system\nThe Amazon Resource Name (ARN) of the Amazon EFS access point that provides access to the file system.\nLocalMountPath -> (string)\nThe path where the function can access the file system, starting with /mnt/ .\nArn=string,LocalMountPath=string ...\nArn=string,LocalMountPath=string ...\n[
  {
    "Arn": "string",
    "LocalMountPath": "string"
  }
  ...
]\n[
  {
    "Arn": "string",
    "LocalMountPath": "string"
  }
  ...
]\n--image-config (structure)\nContainer image configuration values that override the values in the container image Dockerfile.
EntryPoint -> (list)

Specifies the entry point to their application, which is typically the location of the runtime executable.
(string)

Command -> (list)

Specifies parameters that you want to pass in with ENTRYPOINT.
(string)

WorkingDirectory -> (string)

Specifies the working directory.\nContainer image configuration values that override the values in the container image Dockerfile.\nSpecifies the entry point to their application, which is typically the location of the runtime executable.
(string)\nSpecifies the entry point to their application, which is typically the location of the runtime executable.\nSpecifies parameters that you want to pass in with ENTRYPOINT.
(string)\nSpecifies parameters that you want to pass in with ENTRYPOINT.\nWorkingDirectory -> (string)\nSpecifies the working directory.\nEntryPoint=string,string,Command=string,string,WorkingDirectory=string\nEntryPoint=string,string,Command=string,string,WorkingDirectory=string\n{
  "EntryPoint": ["string", ...],
  "Command": ["string", ...],
  "WorkingDirectory": "string"
}\n{
  "EntryPoint": ["string", ...],
  "Command": ["string", ...],
  "WorkingDirectory": "string"
}\n--code-signing-config-arn (string)\n--code-signing-config-arn\nTo enable code signing for this function, specify the ARN of a code-signing configuration. A code-signing configuration includes a set of signing profiles, which define the trusted publishers for this function.\n--architectures (list)\nThe instruction set architecture that the function supports. Enter a string array with one of the valid values (arm64 or x86_64). The default value is x86_64 .
(string)\nThe instruction set architecture that the function supports. Enter a string array with one of the valid values (arm64 or x86_64). The default value is x86_64 .\n"string" "string" ...

Where valid values are:
  x86_64
  arm64\n"string" "string" ...

Where valid values are:
  x86_64
  arm64\n--ephemeral-storage (structure)\nThe size of the function’s /tmp directory in MB. The default value is 512, but can be any whole number between 512 and 10,240 MB. For more information, see Configuring ephemeral storage (console) .
Size -> (integer)

The size of the function’s /tmp directory.\nThe size of the function’s /tmp directory in MB. The default value is 512, but can be any whole number between 512 and 10,240 MB. For more information, see Configuring ephemeral storage (console) .\nConfiguring ephemeral storage (console)\nThe size of the function’s /tmp directory.\n{
  "Size": integer
}\n{
  "Size": integer
}\n--snap-start (structure)\nThe function’s SnapStart setting.
ApplyOn -> (string)

Set to PublishedVersions to create a snapshot of the initialized execution environment when you publish a function version.\nThe function’s SnapStart setting.\nSet to PublishedVersions to create a snapshot of the initialized execution environment when you publish a function version.\n{
  "ApplyOn": "PublishedVersions"|"None"
}\n{
  "ApplyOn": "PublishedVersions"|"None"
}\n--logging-config (structure)\nThe function’s Amazon CloudWatch Logs configuration settings.
LogFormat -> (string)

The format in which Lambda sends your function’s application and system logs to CloudWatch. Select between plain text and structured JSON.
ApplicationLogLevel -> (string)

Set this property to filter the application logs for your function that Lambda sends to CloudWatch. Lambda only sends application logs at the selected level of detail and lower, where TRACE is the highest level and FATAL is the lowest.
SystemLogLevel -> (string)

Set this property to filter the system logs for your function that Lambda sends to CloudWatch. Lambda only sends system logs at the selected level of detail and lower, where DEBUG is the highest level and WARN is the lowest.
LogGroup -> (string)

The name of the Amazon CloudWatch log group the function sends logs to. By default, Lambda functions send logs to a default log group named /aws/lambda/<function name> . To use a different log group, enter an existing log group or enter a new log group name.\nThe function’s Amazon CloudWatch Logs configuration settings.\nLogFormat -> (string)\nThe format in which Lambda sends your function’s application and system logs to CloudWatch. Select between plain text and structured JSON.\nApplicationLogLevel -> (string)\nSet this property to filter the application logs for your function that Lambda sends to CloudWatch. Lambda only sends application logs at the selected level of detail and lower, where TRACE is the highest level and FATAL is the lowest.\nSystemLogLevel -> (string)\nSet this property to filter the system logs for your function that Lambda sends to CloudWatch. Lambda only sends system logs at the selected level of detail and lower, where DEBUG is the highest level and WARN is the lowest.\nThe name of the Amazon CloudWatch log group the function sends logs to. By default, Lambda functions send logs to a default log group named /aws/lambda/<function name> . To use a different log group, enter an existing log group or enter a new log group name.\n/aws/lambda/<function\nLogFormat=string,ApplicationLogLevel=string,SystemLogLevel=string,LogGroup=string\nLogFormat=string,ApplicationLogLevel=string,SystemLogLevel=string,LogGroup=string\n{
  "LogFormat": "JSON"|"Text",
  "ApplicationLogLevel": "TRACE"|"DEBUG"|"INFO"|"WARN"|"ERROR"|"FATAL",
  "SystemLogLevel": "DEBUG"|"INFO"|"WARN",
  "LogGroup": "string"
}\n{
  "LogFormat": "JSON"|"Text",
  "ApplicationLogLevel": "TRACE"|"DEBUG"|"INFO"|"WARN"|"ERROR"|"FATAL",
  "SystemLogLevel": "DEBUG"|"INFO"|"WARN",
  "LogGroup": "string"
}\n"ApplicationLogLevel"\nThe path to the zip file of the code you are uploading. Specify –zip-file or –code, but not both. Example: fileb://code.zip\n--cli-input-json (string)
Performs service operation based on the JSON string provided. The JSON string follows the format provided by --generate-cli-skeleton. If other arguments are provided on the command line, the CLI values will override the JSON-provided values. It is not possible to pass arbitrary binary values using a JSON-provided value as the string will be taken literally.\n--generate-cli-skeleton\n--generate-cli-skeleton (string)
Prints a JSON skeleton to standard output without sending an API request. If provided with no value or the value input, prints a sample input JSON that can be used as an argument for --cli-input-json. If provided with the value output, it validates the command inputs and returns a sample output JSON for that command.\n--generate-cli-skeleton\nGlobal Options¶
--debug (boolean)
Turn on debug logging.
--endpoint-url (string)
Override command’s default URL with the given URL.
--no-verify-ssl (boolean)
By default, the AWS CLI uses SSL when communicating with AWS services. For each SSL connection, the AWS CLI will verify SSL certificates. This option overrides the default behavior of verifying SSL certificates.
--no-paginate (boolean)
Disable automatic pagination. If automatic pagination is disabled, the AWS CLI will only make one call, for the first page of results.
--output (string)
The formatting style for command output.

json
text
table

--query (string)
A JMESPath query to use in filtering the response data.
--profile (string)
Use a specific profile from your credential file.
--region (string)
The region to use. Overrides config/env settings.
--version (string)
Display the version of this tool.
--color (string)
Turn on/off color output.

on
off
auto

--no-sign-request (boolean)
Do not sign requests. Credentials will not be loaded if this argument is provided.
--ca-bundle (string)
The CA certificate bundle to use when verifying SSL certificates. Overrides config/env settings.
--cli-read-timeout (int)
The maximum socket read time in seconds. If the value is set to 0, the socket read will be blocking and not timeout. The default value is 60 seconds.
--cli-connect-timeout (int)
The maximum socket connect time in seconds. If the value is set to 0, the socket connect will be blocking and not timeout. The default value is 60 seconds.\nTurn on debug logging.\n--endpoint-url (string)\nOverride command’s default URL with the given URL.\n--no-verify-ssl (boolean)\nBy default, the AWS CLI uses SSL when communicating with AWS services. For each SSL connection, the AWS CLI will verify SSL certificates. This option overrides the default behavior of verifying SSL certificates.\n--no-paginate (boolean)\nDisable automatic pagination. If automatic pagination is disabled, the AWS CLI will only make one call, for the first page of results.\nThe formatting style for command output.\nA JMESPath query to use in filtering the response data.\nUse a specific profile from your credential file.\nThe region to use. Overrides config/env settings.\nDisplay the version of this tool.\nTurn on/off color output.\n--no-sign-request (boolean)\nDo not sign requests. Credentials will not be loaded if this argument is provided.\nThe CA certificate bundle to use when verifying SSL certificates. Overrides config/env settings.\n--cli-read-timeout (int)\nThe maximum socket read time in seconds. If the value is set to 0, the socket read will be blocking and not timeout. The default value is 60 seconds.\n--cli-connect-timeout (int)\n--cli-connect-timeout\nThe maximum socket connect time in seconds. If the value is set to 0, the socket connect will be blocking and not timeout. The default value is 60 seconds.\nExamples¶

NoteTo use the following examples, you must have the AWS CLI installed and configured. See the Getting started guide in the AWS CLI User Guide for more information.
Unless otherwise stated, all examples have unix-like quotation rules. These examples will need to be adapted to your terminal’s quoting rules. See Using quotation marks with strings in the AWS CLI User Guide .

To create a Lambda function
The following create-function example creates a Lambda function named my-function.
aws lambda create-function \
    --function-name my-function \
    --runtime nodejs18.x \
    --zip-file fileb://my-function.zip \
    --handler my-function.handler \
    --role arn:aws:iam::123456789012:role/service-role/MyTestFunction-role-tges6bf4


Contents of my-function.zip:
This file is a deployment package that contains your function code and any dependencies.


Output:
{
    "TracingConfig": {
        "Mode": "PassThrough"
    },
    "CodeSha256": "PFn4S+er27qk+UuZSTKEQfNKG/XNn7QJs90mJgq6oH8=",
    "FunctionName": "my-function",
    "CodeSize": 308,
    "RevisionId": "873282ed-4cd3-4dc8-a069-d0c647e470c6",
    "MemorySize": 128,
    "FunctionArn": "arn:aws:lambda:us-west-2:123456789012:function:my-function",
    "Version": "$LATEST",
    "Role": "arn:aws:iam::123456789012:role/service-role/MyTestFunction-role-zgur6bf4",
    "Timeout": 3,
    "LastModified": "2023-10-14T22:26:11.234+0000",
    "Handler": "my-function.handler",
    "Runtime": "nodejs18.x",
    "Description": ""
}


For more information, see AWS Lambda Function Configuration in the AWS Lambda Developer Guide.\nNoteTo use the following examples, you must have the AWS CLI installed and configured. See the Getting started guide in the AWS CLI User Guide for more information.
Unless otherwise stated, all examples have unix-like quotation rules. These examples will need to be adapted to your terminal’s quoting rules. See Using quotation marks with strings in the AWS CLI User Guide .\nTo use the following examples, you must have the AWS CLI installed and configured. See the Getting started guide in the AWS CLI User Guide for more information.\nGetting started guide\nUnless otherwise stated, all examples have unix-like quotation rules. These examples will need to be adapted to your terminal’s quoting rules. See Using quotation marks with strings in the AWS CLI User Guide .\nUsing quotation marks with strings\nTo create a Lambda function\nThe following create-function example creates a Lambda function named my-function.\naws lambda create-function \
    --function-name my-function \
    --runtime nodejs18.x \
    --zip-file fileb://my-function.zip \
    --handler my-function.handler \
    --role arn:aws:iam::123456789012:role/service-role/MyTestFunction-role-tges6bf4\naws lambda create-function \
    --function-name my-function \
    --runtime nodejs18.x \
    --zip-file fileb://my-function.zip \
    --handler my-function.handler \
    --role arn:aws:iam::123456789012:role/service-role/MyTestFunction-role-tges6bf4\nContents of my-function.zip:\nThis file is a deployment package that contains your function code and any dependencies.\nThis file is a deployment package that contains your function code and any dependencies.\n{
    "TracingConfig": {
        "Mode": "PassThrough"
    },
    "CodeSha256": "PFn4S+er27qk+UuZSTKEQfNKG/XNn7QJs90mJgq6oH8=",
    "FunctionName": "my-function",
    "CodeSize": 308,
    "RevisionId": "873282ed-4cd3-4dc8-a069-d0c647e470c6",
    "MemorySize": 128,
    "FunctionArn": "arn:aws:lambda:us-west-2:123456789012:function:my-function",
    "Version": "$LATEST",
    "Role": "arn:aws:iam::123456789012:role/service-role/MyTestFunction-role-zgur6bf4",
    "Timeout": 3,
    "LastModified": "2023-10-14T22:26:11.234+0000",
    "Handler": "my-function.handler",
    "Runtime": "nodejs18.x",
    "Description": ""
}\n{
    "TracingConfig": {
        "Mode": "PassThrough"
    },
    "CodeSha256": "PFn4S+er27qk+UuZSTKEQfNKG/XNn7QJs90mJgq6oH8=",
    "FunctionName": "my-function",
    "CodeSize": 308,
    "RevisionId": "873282ed-4cd3-4dc8-a069-d0c647e470c6",
    "MemorySize": 128,
    "FunctionArn": "arn:aws:lambda:us-west-2:123456789012:function:my-function",
    "Version": "$LATEST",
    "Role": "arn:aws:iam::123456789012:role/service-role/MyTestFunction-role-zgur6bf4",
    "Timeout": 3,
    "LastModified": "2023-10-14T22:26:11.234+0000",
    "Handler": "my-function.handler",
    "Runtime": "nodejs18.x",
    "Description": ""
}\n"PFn4S+er27qk+UuZSTKEQfNKG/XNn7QJs90mJgq6oH8="\n"873282ed-4cd3-4dc8-a069-d0c647e470c6"\n"arn:aws:lambda:us-west-2:123456789012:function:my-function"\n"arn:aws:iam::123456789012:role/service-role/MyTestFunction-role-zgur6bf4"\n"2023-10-14T22:26:11.234+0000"\n"my-function.handler"\nFor more information, see AWS Lambda Function Configuration in the AWS Lambda Developer Guide.\nAWS Lambda Function Configuration\nOutput¶
FunctionName -> (string)

The name of the function.
FunctionArn -> (string)

The function’s Amazon Resource Name (ARN).
Runtime -> (string)

The identifier of the function’s runtime . Runtime is required if the deployment package is a .zip file archive. Specifying a runtime results in an error if you’re deploying a function using a container image.
The following list includes deprecated runtimes. Lambda blocks creating new functions and updating existing functions shortly after each runtime is deprecated. For more information, see Runtime use after deprecation .
For a list of all currently supported runtimes, see Supported runtimes .

Role -> (string)

The function’s execution role.
Handler -> (string)

The function that Lambda calls to begin running your function.
CodeSize -> (long)

The size of the function’s deployment package, in bytes.
Description -> (string)

The function’s description.
Timeout -> (integer)

The amount of time in seconds that Lambda allows a function to run before stopping it.
MemorySize -> (integer)

The amount of memory available to the function at runtime.
LastModified -> (string)

The date and time that the function was last updated, in ISO-8601 format (YYYY-MM-DDThh:mm:ss.sTZD).
CodeSha256 -> (string)

The SHA256 hash of the function’s deployment package.
Version -> (string)

The version of the Lambda function.
VpcConfig -> (structure)

The function’s networking configuration.
SubnetIds -> (list)

A list of VPC subnet IDs.
(string)

SecurityGroupIds -> (list)

A list of VPC security group IDs.
(string)

VpcId -> (string)

The ID of the VPC.
Ipv6AllowedForDualStack -> (boolean)

Allows outbound IPv6 traffic on VPC functions that are connected to dual-stack subnets.

DeadLetterConfig -> (structure)

The function’s dead letter queue.
TargetArn -> (string)

The Amazon Resource Name (ARN) of an Amazon SQS queue or Amazon SNS topic.

Environment -> (structure)

The function’s environment variables . Omitted from CloudTrail logs.
Variables -> (map)

Environment variable key-value pairs. Omitted from CloudTrail logs.
key -> (string)
value -> (string)

Error -> (structure)

Error messages for environment variables that couldn’t be applied.
ErrorCode -> (string)

The error code.
Message -> (string)

The error message.


KMSKeyArn -> (string)

The ARN of the Key Management Service (KMS) customer managed key that’s used to encrypt the following resources:

The function’s environment variables .
The function’s Lambda SnapStart snapshots.
When used with SourceKMSKeyArn , the unzipped version of the .zip deployment package that’s used for function invocations. For more information, see Specifying a customer managed key for Lambda .
The optimized version of the container image that’s used for function invocations. Note that this is not the same key that’s used to protect your container image in the Amazon Elastic Container Registry (Amazon ECR). For more information, see Function lifecycle .

If you don’t provide a customer managed key, Lambda uses an Amazon Web Services owned key or an Amazon Web Services managed key .

TracingConfig -> (structure)

The function’s X-Ray tracing configuration.
Mode -> (string)

The tracing mode.

MasterArn -> (string)

For Lambda@Edge functions, the ARN of the main function.
RevisionId -> (string)

The latest updated revision of the function or alias.
Layers -> (list)

The function’s layers .
(structure)

An Lambda layer .
Arn -> (string)

The Amazon Resource Name (ARN) of the function layer.
CodeSize -> (long)

The size of the layer archive in bytes.
SigningProfileVersionArn -> (string)

The Amazon Resource Name (ARN) for a signing profile version.
SigningJobArn -> (string)

The Amazon Resource Name (ARN) of a signing job.


State -> (string)

The current state of the function. When the state is Inactive , you can reactivate the function by invoking it.
StateReason -> (string)

The reason for the function’s current state.
StateReasonCode -> (string)

The reason code for the function’s current state. When the code is Creating , you can’t invoke or modify the function.
LastUpdateStatus -> (string)

The status of the last update that was performed on the function. This is first set to Successful after function creation completes.
LastUpdateStatusReason -> (string)

The reason for the last update that was performed on the function.
LastUpdateStatusReasonCode -> (string)

The reason code for the last update that was performed on the function.
FileSystemConfigs -> (list)

Connection settings for an Amazon EFS file system .
(structure)

Details about the connection between a Lambda function and an Amazon EFS file system .
Arn -> (string)

The Amazon Resource Name (ARN) of the Amazon EFS access point that provides access to the file system.
LocalMountPath -> (string)

The path where the function can access the file system, starting with /mnt/ .


PackageType -> (string)

The type of deployment package. Set to Image for container image and set Zip for .zip file archive.
ImageConfigResponse -> (structure)

The function’s image configuration values.
ImageConfig -> (structure)

Configuration values that override the container image Dockerfile.
EntryPoint -> (list)

Specifies the entry point to their application, which is typically the location of the runtime executable.
(string)

Command -> (list)

Specifies parameters that you want to pass in with ENTRYPOINT.
(string)

WorkingDirectory -> (string)

Specifies the working directory.

Error -> (structure)

Error response to GetFunctionConfiguration .
ErrorCode -> (string)

Error code.
Message -> (string)

Error message.


SigningProfileVersionArn -> (string)

The ARN of the signing profile version.
SigningJobArn -> (string)

The ARN of the signing job.
Architectures -> (list)

The instruction set architecture that the function supports. Architecture is a string array with one of the valid values. The default architecture value is x86_64 .
(string)

EphemeralStorage -> (structure)

The size of the function’s /tmp directory in MB. The default value is 512, but can be any whole number between 512 and 10,240 MB. For more information, see Configuring ephemeral storage (console) .
Size -> (integer)

The size of the function’s /tmp directory.

SnapStart -> (structure)

Set ApplyOn to PublishedVersions to create a snapshot of the initialized execution environment when you publish a function version. For more information, see Improving startup performance with Lambda SnapStart .
ApplyOn -> (string)

When set to PublishedVersions , Lambda creates a snapshot of the execution environment when you publish a function version.
OptimizationStatus -> (string)

When you provide a qualified Amazon Resource Name (ARN) , this response element indicates whether SnapStart is activated for the specified function version.

RuntimeVersionConfig -> (structure)

The ARN of the runtime and any errors that occured.
RuntimeVersionArn -> (string)

The ARN of the runtime version you want the function to use.
Error -> (structure)

Error response when Lambda is unable to retrieve the runtime version for a function.
ErrorCode -> (string)

The error code.
Message -> (string)

The error message.


LoggingConfig -> (structure)

The function’s Amazon CloudWatch Logs configuration settings.
LogFormat -> (string)

The format in which Lambda sends your function’s application and system logs to CloudWatch. Select between plain text and structured JSON.
ApplicationLogLevel -> (string)

Set this property to filter the application logs for your function that Lambda sends to CloudWatch. Lambda only sends application logs at the selected level of detail and lower, where TRACE is the highest level and FATAL is the lowest.
SystemLogLevel -> (string)

Set this property to filter the system logs for your function that Lambda sends to CloudWatch. Lambda only sends system logs at the selected level of detail and lower, where DEBUG is the highest level and WARN is the lowest.
LogGroup -> (string)

The name of the Amazon CloudWatch log group the function sends logs to. By default, Lambda functions send logs to a default log group named /aws/lambda/<function name> . To use a different log group, enter an existing log group or enter a new log group name.\nFunctionName -> (string)\nThe name of the function.\nFunctionArn -> (string)\nThe function’s Amazon Resource Name (ARN).\nThe identifier of the function’s runtime . Runtime is required if the deployment package is a .zip file archive. Specifying a runtime results in an error if you’re deploying a function using a container image.
The following list includes deprecated runtimes. Lambda blocks creating new functions and updating existing functions shortly after each runtime is deprecated. For more information, see Runtime use after deprecation .
For a list of all currently supported runtimes, see Supported runtimes .\nThe identifier of the function’s runtime . Runtime is required if the deployment package is a .zip file archive. Specifying a runtime results in an error if you’re deploying a function using a container image.\nThe following list includes deprecated runtimes. Lambda blocks creating new functions and updating existing functions shortly after each runtime is deprecated. For more information, see Runtime use after deprecation .\nRuntime use after deprecation\nFor a list of all currently supported runtimes, see Supported runtimes .\nThe function’s execution role.\nThe function that Lambda calls to begin running your function.\nThe size of the function’s deployment package, in bytes.\nDescription -> (string)\nThe function’s description.\nThe amount of time in seconds that Lambda allows a function to run before stopping it.\nMemorySize -> (integer)\nThe amount of memory available to the function at runtime.\nLastModified -> (string)\nThe date and time that the function was last updated, in ISO-8601 format (YYYY-MM-DDThh:mm:ss.sTZD).\nCodeSha256 -> (string)\nThe SHA256 hash of the function’s deployment package.\nThe version of the Lambda function.\nVpcConfig -> (structure)\nThe function’s networking configuration.
SubnetIds -> (list)

A list of VPC subnet IDs.
(string)

SecurityGroupIds -> (list)

A list of VPC security group IDs.
(string)

VpcId -> (string)

The ID of the VPC.
Ipv6AllowedForDualStack -> (boolean)

Allows outbound IPv6 traffic on VPC functions that are connected to dual-stack subnets.\nThe function’s networking configuration.\nA list of VPC subnet IDs.
(string)\nA list of VPC subnet IDs.\nSecurityGroupIds -> (list)\nA list of VPC security group IDs.
(string)\nA list of VPC security group IDs.\nIpv6AllowedForDualStack -> (boolean)\nAllows outbound IPv6 traffic on VPC functions that are connected to dual-stack subnets.\nDeadLetterConfig -> (structure)\nThe function’s dead letter queue.
TargetArn -> (string)

The Amazon Resource Name (ARN) of an Amazon SQS queue or Amazon SNS topic.\nThe function’s dead letter queue.\nTargetArn -> (string)\nThe Amazon Resource Name (ARN) of an Amazon SQS queue or Amazon SNS topic.\nEnvironment -> (structure)\nThe function’s environment variables . Omitted from CloudTrail logs.
Variables -> (map)

Environment variable key-value pairs. Omitted from CloudTrail logs.
key -> (string)
value -> (string)

Error -> (structure)

Error messages for environment variables that couldn’t be applied.
ErrorCode -> (string)

The error code.
Message -> (string)

The error message.\nThe function’s environment variables . Omitted from CloudTrail logs.\nenvironment variables\nEnvironment variable key-value pairs. Omitted from CloudTrail logs.
key -> (string)
value -> (string)\nEnvironment variable key-value pairs. Omitted from CloudTrail logs.\nError messages for environment variables that couldn’t be applied.
ErrorCode -> (string)

The error code.
Message -> (string)

The error message.\nError messages for environment variables that couldn’t be applied.\nErrorCode -> (string)\nKMSKeyArn -> (string)\nThe ARN of the Key Management Service (KMS) customer managed key that’s used to encrypt the following resources:

The function’s environment variables .
The function’s Lambda SnapStart snapshots.
When used with SourceKMSKeyArn , the unzipped version of the .zip deployment package that’s used for function invocations. For more information, see Specifying a customer managed key for Lambda .
The optimized version of the container image that’s used for function invocations. Note that this is not the same key that’s used to protect your container image in the Amazon Elastic Container Registry (Amazon ECR). For more information, see Function lifecycle .

If you don’t provide a customer managed key, Lambda uses an Amazon Web Services owned key or an Amazon Web Services managed key .\nThe ARN of the Key Management Service (KMS) customer managed key that’s used to encrypt the following resources:\nThe function’s environment variables .\nenvironment variables\nThe function’s Lambda SnapStart snapshots.\nWhen used with SourceKMSKeyArn , the unzipped version of the .zip deployment package that’s used for function invocations. For more information, see Specifying a customer managed key for Lambda .\nSpecifying a customer managed key for Lambda\nThe optimized version of the container image that’s used for function invocations. Note that this is not the same key that’s used to protect your container image in the Amazon Elastic Container Registry (Amazon ECR). For more information, see Function lifecycle .\nIf you don’t provide a customer managed key, Lambda uses an Amazon Web Services owned key or an Amazon Web Services managed key .\nAmazon Web Services owned key\nAmazon Web Services managed key\nTracingConfig -> (structure)\nThe function’s X-Ray tracing configuration.
Mode -> (string)

The tracing mode.\nThe function’s X-Ray tracing configuration.\nMasterArn -> (string)\nFor Lambda@Edge functions, the ARN of the main function.\nRevisionId -> (string)\nThe latest updated revision of the function or alias.\nThe function’s layers .
(structure)

An Lambda layer .
Arn -> (string)

The Amazon Resource Name (ARN) of the function layer.
CodeSize -> (long)

The size of the layer archive in bytes.
SigningProfileVersionArn -> (string)

The Amazon Resource Name (ARN) for a signing profile version.
SigningJobArn -> (string)

The Amazon Resource Name (ARN) of a signing job.\nThe function’s layers .\nAn Lambda layer .
Arn -> (string)

The Amazon Resource Name (ARN) of the function layer.
CodeSize -> (long)

The size of the layer archive in bytes.
SigningProfileVersionArn -> (string)

The Amazon Resource Name (ARN) for a signing profile version.
SigningJobArn -> (string)

The Amazon Resource Name (ARN) of a signing job.\nThe Amazon Resource Name (ARN) of the function layer.\nThe size of the layer archive in bytes.\nSigningProfileVersionArn -> (string)\nThe Amazon Resource Name (ARN) for a signing profile version.\nSigningJobArn -> (string)\nThe Amazon Resource Name (ARN) of a signing job.\nThe current state of the function. When the state is Inactive , you can reactivate the function by invoking it.\nStateReason -> (string)\nThe reason for the function’s current state.\nStateReasonCode -> (string)\nThe reason code for the function’s current state. When the code is Creating , you can’t invoke or modify the function.\nLastUpdateStatus -> (string)\nThe status of the last update that was performed on the function. This is first set to Successful after function creation completes.\nLastUpdateStatusReason -> (string)\nThe reason for the last update that was performed on the function.\nLastUpdateStatusReasonCode -> (string)\nThe reason code for the last update that was performed on the function.\nFileSystemConfigs -> (list)\nConnection settings for an Amazon EFS file system .
(structure)

Details about the connection between a Lambda function and an Amazon EFS file system .
Arn -> (string)

The Amazon Resource Name (ARN) of the Amazon EFS access point that provides access to the file system.
LocalMountPath -> (string)

The path where the function can access the file system, starting with /mnt/ .\nConnection settings for an Amazon EFS file system .\nAmazon EFS file system\nDetails about the connection between a Lambda function and an Amazon EFS file system .
Arn -> (string)

The Amazon Resource Name (ARN) of the Amazon EFS access point that provides access to the file system.
LocalMountPath -> (string)

The path where the function can access the file system, starting with /mnt/ .\nDetails about the connection between a Lambda function and an Amazon EFS file system .\nAmazon EFS file system\nThe Amazon Resource Name (ARN) of the Amazon EFS access point that provides access to the file system.\nLocalMountPath -> (string)\nThe path where the function can access the file system, starting with /mnt/ .\nPackageType -> (string)\nThe type of deployment package. Set to Image for container image and set Zip for .zip file archive.\nImageConfigResponse -> (structure)\nThe function’s image configuration values.
ImageConfig -> (structure)

Configuration values that override the container image Dockerfile.
EntryPoint -> (list)

Specifies the entry point to their application, which is typically the location of the runtime executable.
(string)

Command -> (list)

Specifies parameters that you want to pass in with ENTRYPOINT.
(string)

WorkingDirectory -> (string)

Specifies the working directory.

Error -> (structure)

Error response to GetFunctionConfiguration .
ErrorCode -> (string)

Error code.
Message -> (string)

Error message.\nThe function’s image configuration values.\nImageConfig -> (structure)\nConfiguration values that override the container image Dockerfile.
EntryPoint -> (list)

Specifies the entry point to their application, which is typically the location of the runtime executable.
(string)

Command -> (list)

Specifies parameters that you want to pass in with ENTRYPOINT.
(string)

WorkingDirectory -> (string)

Specifies the working directory.\nConfiguration values that override the container image Dockerfile.\nSpecifies the entry point to their application, which is typically the location of the runtime executable.
(string)\nSpecifies the entry point to their application, which is typically the location of the runtime executable.\nSpecifies parameters that you want to pass in with ENTRYPOINT.
(string)\nSpecifies parameters that you want to pass in with ENTRYPOINT.\nWorkingDirectory -> (string)\nSpecifies the working directory.\nError response to GetFunctionConfiguration .
ErrorCode -> (string)

Error code.
Message -> (string)

Error message.\nError response to GetFunctionConfiguration .\nGetFunctionConfiguration\nErrorCode -> (string)\nSigningProfileVersionArn -> (string)\nThe ARN of the signing profile version.\nSigningJobArn -> (string)\nThe ARN of the signing job.\nArchitectures -> (list)\nThe instruction set architecture that the function supports. Architecture is a string array with one of the valid values. The default architecture value is x86_64 .
(string)\nThe instruction set architecture that the function supports. Architecture is a string array with one of the valid values. The default architecture value is x86_64 .\nEphemeralStorage -> (structure)\nThe size of the function’s /tmp directory in MB. The default value is 512, but can be any whole number between 512 and 10,240 MB. For more information, see Configuring ephemeral storage (console) .
Size -> (integer)

The size of the function’s /tmp directory.\nThe size of the function’s /tmp directory in MB. The default value is 512, but can be any whole number between 512 and 10,240 MB. For more information, see Configuring ephemeral storage (console) .\nConfiguring ephemeral storage (console)\nThe size of the function’s /tmp directory.\nSnapStart -> (structure)\nSet ApplyOn to PublishedVersions to create a snapshot of the initialized execution environment when you publish a function version. For more information, see Improving startup performance with Lambda SnapStart .
ApplyOn -> (string)

When set to PublishedVersions , Lambda creates a snapshot of the execution environment when you publish a function version.
OptimizationStatus -> (string)

When you provide a qualified Amazon Resource Name (ARN) , this response element indicates whether SnapStart is activated for the specified function version.\nSet ApplyOn to PublishedVersions to create a snapshot of the initialized execution environment when you publish a function version. For more information, see Improving startup performance with Lambda SnapStart .\nImproving startup performance with Lambda SnapStart\nWhen set to PublishedVersions , Lambda creates a snapshot of the execution environment when you publish a function version.\nOptimizationStatus -> (string)\nWhen you provide a qualified Amazon Resource Name (ARN) , this response element indicates whether SnapStart is activated for the specified function version.\nqualified Amazon Resource Name (ARN)\nRuntimeVersionConfig -> (structure)\nThe ARN of the runtime and any errors that occured.
RuntimeVersionArn -> (string)

The ARN of the runtime version you want the function to use.
Error -> (structure)

Error response when Lambda is unable to retrieve the runtime version for a function.
ErrorCode -> (string)

The error code.
Message -> (string)

The error message.\nThe ARN of the runtime and any errors that occured.\nRuntimeVersionArn -> (string)\nThe ARN of the runtime version you want the function to use.\nError response when Lambda is unable to retrieve the runtime version for a function.
ErrorCode -> (string)

The error code.
Message -> (string)

The error message.\nError response when Lambda is unable to retrieve the runtime version for a function.\nErrorCode -> (string)\nLoggingConfig -> (structure)\nThe function’s Amazon CloudWatch Logs configuration settings.
LogFormat -> (string)

The format in which Lambda sends your function’s application and system logs to CloudWatch. Select between plain text and structured JSON.
ApplicationLogLevel -> (string)

Set this property to filter the application logs for your function that Lambda sends to CloudWatch. Lambda only sends application logs at the selected level of detail and lower, where TRACE is the highest level and FATAL is the lowest.
SystemLogLevel -> (string)

Set this property to filter the system logs for your function that Lambda sends to CloudWatch. Lambda only sends system logs at the selected level of detail and lower, where DEBUG is the highest level and WARN is the lowest.
LogGroup -> (string)

The name of the Amazon CloudWatch log group the function sends logs to. By default, Lambda functions send logs to a default log group named /aws/lambda/<function name> . To use a different log group, enter an existing log group or enter a new log group name.\nThe function’s Amazon CloudWatch Logs configuration settings.\nLogFormat -> (string)\nThe format in which Lambda sends your function’s application and system logs to CloudWatch. Select between plain text and structured JSON.\nApplicationLogLevel -> (string)\nSet this property to filter the application logs for your function that Lambda sends to CloudWatch. Lambda only sends application logs at the selected level of detail and lower, where TRACE is the highest level and FATAL is the lowest.\nSystemLogLevel -> (string)\nSet this property to filter the system logs for your function that Lambda sends to CloudWatch. Lambda only sends system logs at the selected level of detail and lower, where DEBUG is the highest level and WARN is the lowest.\nThe name of the Amazon CloudWatch log group the function sends logs to. By default, Lambda functions send logs to a default log group named /aws/lambda/<function name> . To use a different log group, enter an existing log group or enter a new log group name.\n/aws/lambda/<function\n← create-event-source-mapping
          /
          
        
          create-function-url-config →\n← create-event-source-mapping
          /\n← create-event-source-mapping\ncreate-function-url-config →\ncreate-function-url-config →\nNavigation
      
        
          index
        
          next |
        
          previous |
        AWS CLI 1.40.17 Command Reference »
          aws »
          lambda »
        create-function\nAWS CLI 1.40.17 Command Reference »\nAWS CLI 1.40.17 Command Reference\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaAPI ReferenceRequest SyntaxURI Request ParametersRequest BodyResponse SyntaxResponse ElementsErrorsSee AlsoCreateFunctionCreates a Lambda function. To create a function, you need a deployment package and an execution role. The
      deployment package is a .zip file archive or container image that contains your function code. The execution role
      grants the function permission to use AWS services, such as Amazon CloudWatch Logs for log
      streaming and AWS X-Ray for request tracing.If the deployment package is a container
        image, then you set the package type to Image. For a container image, the code property
      must include the URI of a container image in the Amazon ECR registry. You do not need to specify the
      handler and runtime properties.If the deployment package is a .zip file archive, then
      you set the package type to Zip. For a .zip file archive, the code property specifies the location of
      the .zip file. You must also specify the handler and runtime properties. The code in the deployment package must
      be compatible with the target instruction set architecture of the function (x86-64 or
        arm64). If you do not specify the architecture, then the default value is
      x86-64.When you create a function, Lambda provisions an instance of the function and its supporting
      resources. If your function connects to a VPC, this process can take a minute or so. During this time, you can't
      invoke or modify the function. The State, StateReason, and StateReasonCode
      fields in the response from GetFunctionConfiguration indicate when the function is ready to
      invoke. For more information, see Lambda function states.A function has an unpublished version, and can have published versions and aliases. The unpublished version
      changes when you update your function's code and configuration. A published version is a snapshot of your function
      code and configuration that can't be changed. An alias is a named resource that maps to a version, and can be
      changed to map to a different version. Use the Publish parameter to create version 1 of
      your function from its initial configuration.The other parameters let you configure version-specific and function-level settings. You can modify
      version-specific settings later with UpdateFunctionConfiguration. Function-level settings apply
      to both the unpublished and published versions of the function, and include tags (TagResource)
      and per-function concurrency limits (PutFunctionConcurrency).You can use code signing if your deployment package is a .zip file archive. To enable code signing for this
      function, specify the ARN of a code-signing configuration. When a user attempts to deploy a code package with
        UpdateFunctionCode, Lambda checks that the code package has a valid signature from
      a trusted publisher. The code-signing configuration includes set of signing profiles, which define the trusted
      publishers for this function.If another AWS account or an AWS service invokes your function, use AddPermission to grant permission by creating a resource-based AWS Identity and Access Management (IAM) policy. You can grant permissions at the function level, on a version, or on an alias.To invoke your function directly, use Invoke. To invoke your function in response to events
      in other AWS services, create an event source mapping (CreateEventSourceMapping),
      or configure a function trigger in the other service. For more information, see Invoking Lambda
      functions.
      Request Syntax
      POST /2015-03-31/functions HTTP/1.1
Content-type: application/json

{
   "Architectures": [ "string" ],
   "Code": { 
      "ImageUri": "string",
      "S3Bucket": "string",
      "S3Key": "string",
      "S3ObjectVersion": "string",
      "SourceKMSKeyArn": "string",
      "ZipFile": blob
   },
   "CodeSigningConfigArn": "string",
   "DeadLetterConfig": { 
      "TargetArn": "string"
   },
   "Description": "string",
   "Environment": { 
      "Variables": { 
         "string" : "string" 
      }
   },
   "EphemeralStorage": { 
      "Size": number
   },
   "FileSystemConfigs": [ 
      { 
         "Arn": "string",
         "LocalMountPath": "string"
      }
   ],
   "FunctionName": "string",
   "Handler": "string",
   "ImageConfig": { 
      "Command": [ "string" ],
      "EntryPoint": [ "string" ],
      "WorkingDirectory": "string"
   },
   "KMSKeyArn": "string",
   "Layers": [ "string" ],
   "LoggingConfig": { 
      "ApplicationLogLevel": "string",
      "LogFormat": "string",
      "LogGroup": "string",
      "SystemLogLevel": "string"
   },
   "MemorySize": number,
   "PackageType": "string",
   "Publish": boolean,
   "Role": "string",
   "Runtime": "string",
   "SnapStart": { 
      "ApplyOn": "string"
   },
   "Tags": { 
      "string" : "string" 
   },
   "Timeout": number,
   "TracingConfig": { 
      "Mode": "string"
   },
   "VpcConfig": { 
      "Ipv6AllowedForDualStack": boolean,
      "SecurityGroupIds": [ "string" ],
      "SubnetIds": [ "string" ]
   }
}
    
      URI Request Parameters
      The request does not use any URI parameters.
    
      Request Body
      The request accepts the following data in JSON format.
      
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
      
            
               
                  Architectures
               
            
            
               The instruction set architecture that the function supports. Enter a string array with one of the valid values (arm64 or x86_64).
     The default value is x86_64.
               Type: Array of strings
               Array Members: Fixed number of 1 item.
               Valid Values: x86_64 | arm64
               
               Required: No
            
          
            
               
                  Code
               
            
            
               The code for the function.
               Type: FunctionCode object
               Required: Yes
            
          
            
               
                  CodeSigningConfigArn
               
            
            
               To enable code signing for this function, specify the ARN of a code-signing configuration. A code-signing configuration
includes a set of signing profiles, which define the trusted publishers for this function.
               Type: String
               Length Constraints: Maximum length of 200.
               Pattern: arn:(aws[a-zA-Z-]*)?:lambda:[a-z]{2}((-gov)|(-iso(b?)))?-[a-z]+-\d{1}:\d{12}:code-signing-config:csc-[a-z0-9]{17}
               
               Required: No
            
          
            
               
                  DeadLetterConfig
               
            
            
               A dead-letter queue configuration that specifies the queue or topic where Lambda sends asynchronous events
      when they fail processing. For more information, see Dead-letter queues.
               Type: DeadLetterConfig object
               Required: No
            
          
            
               
                  Description
               
            
            
               A description of the function.
               Type: String
               Length Constraints: Minimum length of 0. Maximum length of 256.
               Required: No
            
          
            
               
                  Environment
               
            
            
               Environment variables that are accessible from function code during execution.
               Type: Environment object
               Required: No
            
          
            
               
                  EphemeralStorage
               
            
            
               The size of the function's /tmp directory in MB. The default value is 512, but can be any whole
      number between 512 and 10,240 MB. For more information, see Configuring ephemeral storage (console).
               Type: EphemeralStorage object
               Required: No
            
          
            
               
                  FileSystemConfigs
               
            
            
               Connection settings for an Amazon EFS file system.
               Type: Array of FileSystemConfig objects
               Array Members: Maximum number of 1 item.
               Required: No
            
          
            
               
                  FunctionName
               
            
            
               The name or ARN of the Lambda function.
               
                  Name formats
                   
                   
                   
               
                     
                        Function name – my-function.
                  
                     
                        Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function.
                  
                     
                        Partial ARN – 123456789012:function:my-function.
                  
               The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64
      characters in length.
               Type: String
               Length Constraints: Minimum length of 1. Maximum length of 140.
               Pattern: (arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\d{1}:)?(\d{12}:)?(function:)?([a-zA-Z0-9-_]+)(:(\$LATEST|[a-zA-Z0-9-_]+))?
               
               Required: Yes
            
          
            
               
                  Handler
               
            
            
               The name of the method within your code that Lambda calls to run your function. 
Handler is required if the deployment package is a .zip file archive. The format includes the
      file name. It can also include namespaces and other qualifiers, depending on the runtime. For more information,
      see Lambda programming model.
               Type: String
               Length Constraints: Maximum length of 128.
               Pattern: [^ ]+
               
               Required: No
            
          
            
               
                  ImageConfig
               
            
            
               Container image configuration
      values that override the values in the container image Dockerfile.
               Type: ImageConfig object
               Required: No
            
          
            
               
                  KMSKeyArn
               
            
            
               The ARN of the AWS Key Management Service (AWS KMS) customer managed key that's used to encrypt the following resources:
               
                   
                   
                   
                   
               
                     The function's environment variables.
                  
                     The function's Lambda SnapStart snapshots.
                  
                     When used with SourceKMSKeyArn, the unzipped version of the .zip deployment package that's used for function invocations. For more information, see 
Specifying a customer managed key for Lambda.
                  
                     The optimized version of the container image that's used for function invocations. Note that this is not the same key that's used to protect your container image in the Amazon Elastic Container Registry (Amazon ECR). For more information, see Function lifecycle.
                  
               If you don't provide a customer managed key, Lambda uses an AWS owned key or an AWS managed key.
               Type: String
               Pattern: (arn:(aws[a-zA-Z-]*)?:[a-z0-9-.]+:.*)|()
               
               Required: No
            
          
            
               
                  Layers
               
            
            
               A list of function layers
      to add to the function's execution environment. Specify each layer by its ARN, including the version.
               Type: Array of strings
               Length Constraints: Minimum length of 1. Maximum length of 140.
               Pattern: arn:[a-zA-Z0-9-]+:lambda:[a-zA-Z0-9-]+:\d{12}:layer:[a-zA-Z0-9-_]+:[0-9]+
               
               Required: No
            
          
            
               
                  LoggingConfig
               
            
            
               The function's Amazon CloudWatch Logs configuration settings.
               Type: LoggingConfig object
               Required: No
            
          
            
               
                  MemorySize
               
            
            
               The amount of memory available to the function at runtime.
      Increasing the function memory also increases its CPU allocation. The default value is 128 MB. The value can be any multiple of 1 MB.
               Type: Integer
               Valid Range: Minimum value of 128. Maximum value of 10240.
               Required: No
            
          
            
               
                  PackageType
               
            
            
               The type of deployment package. Set to Image for container image and set to Zip for .zip file archive.
               Type: String
               Valid Values: Zip | Image
               
               Required: No
            
          
            
               
                  Publish
               
            
            
               Set to true to publish the first version of the function during creation.
               Type: Boolean
               Required: No
            
          
            
               
                  Role
               
            
            
               The Amazon Resource Name (ARN) of the function's execution role.
               Type: String
               Pattern: arn:(aws[a-zA-Z-]*)?:iam::\d{12}:role/?[a-zA-Z_0-9+=,.@\-_/]+
               
               Required: Yes
            
          
            
               
                  Runtime
               
            
            
               The identifier of the function's 
          runtime. Runtime is required if the deployment package is a .zip file archive. Specifying a runtime results in
          an error if you're deploying a function using a container image.
               The following list includes deprecated runtimes. Lambda blocks creating new functions and updating existing
          functions shortly after each runtime is deprecated. For more information, see
          Runtime use after deprecation.
               For a list of all currently supported runtimes, see
          Supported runtimes.
               Type: String
               Valid Values: nodejs | nodejs4.3 | nodejs6.10 | nodejs8.10 | nodejs10.x | nodejs12.x | nodejs14.x | nodejs16.x | java8 | java8.al2 | java11 | python2.7 | python3.6 | python3.7 | python3.8 | python3.9 | dotnetcore1.0 | dotnetcore2.0 | dotnetcore2.1 | dotnetcore3.1 | dotnet6 | dotnet8 | nodejs4.3-edge | go1.x | ruby2.5 | ruby2.7 | provided | provided.al2 | nodejs18.x | python3.10 | java17 | ruby3.2 | ruby3.3 | ruby3.4 | python3.11 | nodejs20.x | provided.al2023 | python3.12 | java21 | python3.13 | nodejs22.x
               
               Required: No
            
          
            
               
                  SnapStart
               
            
            
               The function's SnapStart setting.
               Type: SnapStart object
               Required: No
            
          
            
               
                  Tags
               
            
            
               A list of tags to apply to the
      function.
               Type: String to string map
               Required: No
            
          
            
               
                  Timeout
               
            
            
               The amount of time (in seconds) that Lambda allows a function to run before stopping it. The default is 3 seconds. The
      maximum allowed value is 900 seconds. For more information, see Lambda execution environment.
               Type: Integer
               Valid Range: Minimum value of 1.
               Required: No
            
          
            
               
                  TracingConfig
               
            
            
               Set Mode to Active to sample and trace a subset of incoming requests with
X-Ray.
               Type: TracingConfig object
               Required: No
            
          
            
               
                  VpcConfig
               
            
            
               For network connectivity to AWS resources in a VPC, specify a list of security groups and subnets in the VPC.
      When you connect a function to a VPC, it can access resources and the internet only through that VPC. For more
      information, see Configuring a Lambda function to access resources in a VPC.
               Type: VpcConfig object
               Required: No
            
         
    
      Response Syntax
      HTTP/1.1 201
Content-type: application/json

{
   "Architectures": [ "string" ],
   "CodeSha256": "string",
   "CodeSize": number,
   "DeadLetterConfig": { 
      "TargetArn": "string"
   },
   "Description": "string",
   "Environment": { 
      "Error": { 
         "ErrorCode": "string",
         "Message": "string"
      },
      "Variables": { 
         "string" : "string" 
      }
   },
   "EphemeralStorage": { 
      "Size": number
   },
   "FileSystemConfigs": [ 
      { 
         "Arn": "string",
         "LocalMountPath": "string"
      }
   ],
   "FunctionArn": "string",
   "FunctionName": "string",
   "Handler": "string",
   "ImageConfigResponse": { 
      "Error": { 
         "ErrorCode": "string",
         "Message": "string"
      },
      "ImageConfig": { 
         "Command": [ "string" ],
         "EntryPoint": [ "string" ],
         "WorkingDirectory": "string"
      }
   },
   "KMSKeyArn": "string",
   "LastModified": "string",
   "LastUpdateStatus": "string",
   "LastUpdateStatusReason": "string",
   "LastUpdateStatusReasonCode": "string",
   "Layers": [ 
      { 
         "Arn": "string",
         "CodeSize": number,
         "SigningJobArn": "string",
         "SigningProfileVersionArn": "string"
      }
   ],
   "LoggingConfig": { 
      "ApplicationLogLevel": "string",
      "LogFormat": "string",
      "LogGroup": "string",
      "SystemLogLevel": "string"
   },
   "MasterArn": "string",
   "MemorySize": number,
   "PackageType": "string",
   "RevisionId": "string",
   "Role": "string",
   "Runtime": "string",
   "RuntimeVersionConfig": { 
      "Error": { 
         "ErrorCode": "string",
         "Message": "string"
      },
      "RuntimeVersionArn": "string"
   },
   "SigningJobArn": "string",
   "SigningProfileVersionArn": "string",
   "SnapStart": { 
      "ApplyOn": "string",
      "OptimizationStatus": "string"
   },
   "State": "string",
   "StateReason": "string",
   "StateReasonCode": "string",
   "Timeout": number,
   "TracingConfig": { 
      "Mode": "string"
   },
   "Version": "string",
   "VpcConfig": { 
      "Ipv6AllowedForDualStack": boolean,
      "SecurityGroupIds": [ "string" ],
      "SubnetIds": [ "string" ],
      "VpcId": "string"
   }
}
    
      Response Elements
      If the action is successful, the service sends back an HTTP 201 response.
      The following data is returned in JSON format by the service.
      
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
      
            
               
                  Architectures
               
            
            
               The instruction set architecture that the function supports. Architecture is a string array with one of the 
      valid values. The default architecture value is x86_64.
               Type: Array of strings
               Array Members: Fixed number of 1 item.
               Valid Values: x86_64 | arm64
               
            
          
            
               
                  CodeSha256
               
            
            
               The SHA256 hash of the function's deployment package.
               Type: String
            
          
            
               
                  CodeSize
               
            
            
               The size of the function's deployment package, in bytes.
               Type: Long
            
          
            
               
                  DeadLetterConfig
               
            
            
               The function's dead letter queue.
               Type: DeadLetterConfig object
            
          
            
               
                  Description
               
            
            
               The function's description.
               Type: String
               Length Constraints: Minimum length of 0. Maximum length of 256.
            
          
            
               
                  Environment
               
            
            
               The function's environment variables. Omitted from AWS CloudTrail logs.
               Type: EnvironmentResponse object
            
          
            
               
                  EphemeralStorage
               
            
            
               The size of the function's /tmp directory in MB. The default value is 512, but can be any whole
  number between 512 and 10,240 MB. For more information, see Configuring ephemeral storage (console).
               Type: EphemeralStorage object
            
          
            
               
                  FileSystemConfigs
               
            
            
               Connection settings for an Amazon EFS file system.
               Type: Array of FileSystemConfig objects
               Array Members: Maximum number of 1 item.
            
          
            
               
                  FunctionArn
               
            
            
               The function's Amazon Resource Name (ARN).
               Type: String
               Pattern: arn:(aws[a-zA-Z-]*)?:lambda:[a-z]{2}(-gov)?-[a-z]+-\d{1}:\d{12}:function:[a-zA-Z0-9-_\.]+(:(\$LATEST|[a-zA-Z0-9-_]+))?
               
            
          
            
               
                  FunctionName
               
            
            
               The name of the function.
               Type: String
               Length Constraints: Minimum length of 1. Maximum length of 170.
               Pattern: (arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\d{1}:)?(\d{12}:)?(function:)?([a-zA-Z0-9-_\.]+)(:(\$LATEST|[a-zA-Z0-9-_]+))?
               
            
          
            
               
                  Handler
               
            
            
               The function that Lambda calls to begin running your function.
               Type: String
               Length Constraints: Maximum length of 128.
               Pattern: [^ ]+
               
            
          
            
               
                  ImageConfigResponse
               
            
            
               The function's image configuration values.
               Type: ImageConfigResponse object
            
          
            
               
                  KMSKeyArn
               
            
            
               The ARN of the AWS Key Management Service (AWS KMS) customer managed key that's used to encrypt the following resources:
               
                   
                   
                   
                   
               
                     The function's environment variables.
                  
                     The function's Lambda SnapStart snapshots.
                  
                     When used with SourceKMSKeyArn, the unzipped version of the .zip deployment package that's used for function invocations. For more information, see 
          Specifying a customer managed key for Lambda.
                  
                     The optimized version of the container image that's used for function invocations. Note that this is not the same key that's used to protect your container image in the Amazon Elastic Container Registry (Amazon ECR). For more information, see Function lifecycle.
                  
               If you don't provide a customer managed key, Lambda uses an AWS owned key or an AWS managed key.
               Type: String
               Pattern: (arn:(aws[a-zA-Z-]*)?:[a-z0-9-.]+:.*)|()
               
            
          
            
               
                  LastModified
               
            
            
               The date and time that the function was last updated, in ISO-8601 format (YYYY-MM-DDThh:mm:ss.sTZD).
               Type: String
            
          
            
               
                  LastUpdateStatus
               
            
            
               The status of the last update that was performed on the function. This is first set to Successful
      after function creation completes.
               Type: String
               Valid Values: Successful | Failed | InProgress
               
            
          
            
               
                  LastUpdateStatusReason
               
            
            
               The reason for the last update that was performed on the function.
               Type: String
            
          
            
               
                  LastUpdateStatusReasonCode
               
            
            
               The reason code for the last update that was performed on the function.
               Type: String
               Valid Values: EniLimitExceeded | InsufficientRolePermissions | InvalidConfiguration | InternalError | SubnetOutOfIPAddresses | InvalidSubnet | InvalidSecurityGroup | ImageDeleted | ImageAccessDenied | InvalidImage | KMSKeyAccessDenied | KMSKeyNotFound | InvalidStateKMSKey | DisabledKMSKey | EFSIOError | EFSMountConnectivityError | EFSMountFailure | EFSMountTimeout | InvalidRuntime | InvalidZipFileException | FunctionError
               
            
          
            
               
                  Layers
               
            
            
               The function's layers.
               Type: Array of Layer objects
            
          
            
               
                  LoggingConfig
               
            
            
               The function's Amazon CloudWatch Logs configuration settings.
               Type: LoggingConfig object
            
          
            
               
                  MasterArn
               
            
            
               For Lambda@Edge functions, the ARN of the main function.
               Type: String
               Pattern: arn:(aws[a-zA-Z-]*)?:lambda:[a-z]{2}(-gov)?-[a-z]+-\d{1}:\d{12}:function:[a-zA-Z0-9-_]+(:(\$LATEST|[a-zA-Z0-9-_]+))?
               
            
          
            
               
                  MemorySize
               
            
            
               The amount of memory available to the function at runtime.
               Type: Integer
               Valid Range: Minimum value of 128. Maximum value of 10240.
            
          
            
               
                  PackageType
               
            
            
               The type of deployment package. Set to Image for container image and set Zip for .zip file archive.
               Type: String
               Valid Values: Zip | Image
               
            
          
            
               
                  RevisionId
               
            
            
               The latest updated revision of the function or alias.
               Type: String
            
          
            
               
                  Role
               
            
            
               The function's execution role.
               Type: String
               Pattern: arn:(aws[a-zA-Z-]*)?:iam::\d{12}:role/?[a-zA-Z_0-9+=,.@\-_/]+
               
            
          
            
               
                  Runtime
               
            
            
               The identifier of the function's 
          runtime. Runtime is required if the deployment package is a .zip file archive. Specifying a runtime results in
          an error if you're deploying a function using a container image.
               The following list includes deprecated runtimes. Lambda blocks creating new functions and updating existing
          functions shortly after each runtime is deprecated. For more information, see
          Runtime use after deprecation.
               For a list of all currently supported runtimes, see
          Supported runtimes.
               Type: String
               Valid Values: nodejs | nodejs4.3 | nodejs6.10 | nodejs8.10 | nodejs10.x | nodejs12.x | nodejs14.x | nodejs16.x | java8 | java8.al2 | java11 | python2.7 | python3.6 | python3.7 | python3.8 | python3.9 | dotnetcore1.0 | dotnetcore2.0 | dotnetcore2.1 | dotnetcore3.1 | dotnet6 | dotnet8 | nodejs4.3-edge | go1.x | ruby2.5 | ruby2.7 | provided | provided.al2 | nodejs18.x | python3.10 | java17 | ruby3.2 | ruby3.3 | ruby3.4 | python3.11 | nodejs20.x | provided.al2023 | python3.12 | java21 | python3.13 | nodejs22.x
               
            
          
            
               
                  RuntimeVersionConfig
               
            
            
               The ARN of the runtime and any errors that occured.
               Type: RuntimeVersionConfig object
            
          
            
               
                  SigningJobArn
               
            
            
               The ARN of the signing job.
               Type: String
               Pattern: arn:(aws[a-zA-Z0-9-]*):([a-zA-Z0-9\-])+:([a-z]{2}(-gov)?-[a-z]+-\d{1})?:(\d{12})?:(.*)
               
            
          
            
               
                  SigningProfileVersionArn
               
            
            
               The ARN of the signing profile version.
               Type: String
               Pattern: arn:(aws[a-zA-Z0-9-]*):([a-zA-Z0-9\-])+:([a-z]{2}(-gov)?-[a-z]+-\d{1})?:(\d{12})?:(.*)
               
            
          
            
               
                  SnapStart
               
            
            
               Set ApplyOn to PublishedVersions to create a snapshot of the initialized execution
      environment when you publish a function version. For more information, see Improving startup performance with Lambda SnapStart.
               Type: SnapStartResponse object
            
          
            
               
                  State
               
            
            
               The current state of the function. When the state is Inactive, you can reactivate the function by
      invoking it.
               Type: String
               Valid Values: Pending | Active | Inactive | Failed
               
            
          
            
               
                  StateReason
               
            
            
               The reason for the function's current state.
               Type: String
            
          
            
               
                  StateReasonCode
               
            
            
               The reason code for the function's current state. When the code is Creating, you can't invoke or
      modify the function.
               Type: String
               Valid Values: Idle | Creating | Restoring | EniLimitExceeded | InsufficientRolePermissions | InvalidConfiguration | InternalError | SubnetOutOfIPAddresses | InvalidSubnet | InvalidSecurityGroup | ImageDeleted | ImageAccessDenied | InvalidImage | KMSKeyAccessDenied | KMSKeyNotFound | InvalidStateKMSKey | DisabledKMSKey | EFSIOError | EFSMountConnectivityError | EFSMountFailure | EFSMountTimeout | InvalidRuntime | InvalidZipFileException | FunctionError
               
            
          
            
               
                  Timeout
               
            
            
               The amount of time in seconds that Lambda allows a function to run before stopping it.
               Type: Integer
               Valid Range: Minimum value of 1.
            
          
            
               
                  TracingConfig
               
            
            
               The function's AWS X-Ray tracing configuration.
               Type: TracingConfigResponse object
            
          
            
               
                  Version
               
            
            
               The version of the Lambda function.
               Type: String
               Length Constraints: Minimum length of 1. Maximum length of 1024.
               Pattern: (\$LATEST|[0-9]+)
               
            
          
            
               
                  VpcConfig
               
            
            
               The function's networking configuration.
               Type: VpcConfigResponse object
            
         
    
      Errors
      For information about the errors that are common to all actions, see Common Errors.
      
          
          
          
          
          
          
          
          
          
      
            
               
                  CodeSigningConfigNotFoundException
               
            
            
               The specified code signing configuration does not exist.
               HTTP Status Code: 404
            
          
            
               
                  CodeStorageExceededException
               
            
            
               Your AWS account has exceeded its maximum total code size. For more information, see Lambda quotas.
               HTTP Status Code: 400
            
          
            
               
                  CodeVerificationFailedException
               
            
            
               The code signature failed one or more of the validation checks for signature mismatch or expiry, and the code
      signing policy is set to ENFORCE. Lambda blocks the deployment.
               HTTP Status Code: 400
            
          
            
               
                  InvalidCodeSignatureException
               
            
            
               The code signature failed the integrity check. If the integrity check fails, then Lambda blocks
      deployment, even if the code signing policy is set to WARN.
               HTTP Status Code: 400
            
          
            
               
                  InvalidParameterValueException
               
            
            
               One of the parameters in the request is not valid.
               HTTP Status Code: 400
            
          
            
               
                  ResourceConflictException
               
            
            
               The resource already exists, or another operation is in progress.
               HTTP Status Code: 409
            
          
            
               
                  ResourceNotFoundException
               
            
            
               The resource specified in the request does not exist.
               HTTP Status Code: 404
            
          
            
               
                  ServiceException
               
            
            
               The AWS Lambda service encountered an internal error.
               HTTP Status Code: 500
            
          
            
               
                  TooManyRequestsException
               
            
            
               The request throughput limit was exceeded. For more information, see Lambda quotas.
               HTTP Status Code: 429
            
         
    
      See Also
      For more information about using this API in one of the language-specific AWS SDKs, see the following:
      
          
          
          
          
          
          
          
          
          
          
      
            
               AWS Command Line Interface
            
         
            
               AWS SDK for .NET
            
         
            
               AWS SDK for C++
            
         
            
               AWS SDK for Go v2
            
         
            
               AWS SDK for Java V2
            
         
            
               AWS SDK for JavaScript V3
            
         
            
               AWS SDK for Kotlin
            
         
            
               AWS SDK for PHP V3
            
         
            
               AWS SDK for Python
            
         
            
               AWS SDK for Ruby V3
            
         
   Document ConventionsCreateEventSourceMappingCreateFunctionUrlConfigDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaAPI ReferenceRequest SyntaxURI Request ParametersRequest BodyResponse SyntaxResponse ElementsErrorsSee AlsoUpdateFunctionCodeUpdates a Lambda function's code. If code signing is enabled for the function, the code package
      must be signed by a trusted publisher. For more information, see Configuring code signing for Lambda.If the function's package type is Image, then you must specify the code package in
        ImageUri as the URI of a container image in the Amazon ECR registry.If the function's package type is Zip, then you must specify the deployment package as a .zip file
        archive. Enter the Amazon S3 bucket and key of the code .zip file location. You can also provide
      the function code inline using the ZipFile field.The code in the deployment package must be compatible with the target instruction set architecture of the
      function (x86-64 or arm64).The function's code is locked when you publish a version. You can't modify the code of a published version,
      only the unpublished version.NoteFor a function defined as a container image, Lambda resolves the image tag to an image digest. In
          Amazon ECR, if you update the image tag to a new image, Lambda does not automatically
        update the function.
      Request Syntax
      PUT /2015-03-31/functions/FunctionName/code HTTP/1.1
Content-type: application/json

{
   "Architectures": [ "string" ],
   "DryRun": boolean,
   "ImageUri": "string",
   "Publish": boolean,
   "RevisionId": "string",
   "S3Bucket": "string",
   "S3Key": "string",
   "S3ObjectVersion": "string",
   "SourceKMSKeyArn": "string",
   "ZipFile": blob
}
    
      URI Request Parameters
      The request uses the following URI parameters.
      
          
      
            
               
                  FunctionName
               
            
            
               The name or ARN of the Lambda function.
               
                  Name formats
                   
                   
                   
               
                     
                        Function name – my-function.
                  
                     
                        Function ARN – arn:aws:lambda:us-west-2:123456789012:function:my-function.
                  
                     
                        Partial ARN – 123456789012:function:my-function.
                  
               The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64
      characters in length.
               Length Constraints: Minimum length of 1. Maximum length of 140.
               Pattern: (arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\d{1}:)?(\d{12}:)?(function:)?([a-zA-Z0-9-_]+)(:(\$LATEST|[a-zA-Z0-9-_]+))?
               
               Required: Yes
            
         
    
      Request Body
      The request accepts the following data in JSON format.
      
          
          
          
          
          
          
          
          
          
          
      
            
               
                  Architectures
               
            
            
               The instruction set architecture that the function supports. Enter a string array with one of the valid values (arm64 or x86_64).
     The default value is x86_64.
               Type: Array of strings
               Array Members: Fixed number of 1 item.
               Valid Values: x86_64 | arm64
               
               Required: No
            
          
            
               
                  DryRun
               
            
            
               Set to true to validate the request parameters and access permissions without modifying the function
      code.
               Type: Boolean
               Required: No
            
          
            
               
                  ImageUri
               
            
            
               URI of a container image in the Amazon ECR registry. Do not use for a function defined with a .zip
      file archive.
               Type: String
               Required: No
            
          
            
               
                  Publish
               
            
            
               Set to true to publish a new version of the function after updating the code. This has the same effect as
      calling PublishVersion separately.
               Type: Boolean
               Required: No
            
          
            
               
                  RevisionId
               
            
            
               Update the function only if the revision ID matches the ID that's specified. Use this option to avoid modifying a
      function that has changed since you last read it.
               Type: String
               Required: No
            
          
            
               
                  S3Bucket
               
            
            
               An Amazon S3 bucket in the same AWS Region as your function. The bucket can be in a different 
AWS account. Use only with a function defined with a .zip file archive deployment package.
               Type: String
               Length Constraints: Minimum length of 3. Maximum length of 63.
               Pattern: ^[0-9A-Za-z\.\-_]*(?<!\.)$
               
               Required: No
            
          
            
               
                  S3Key
               
            
            
               The Amazon S3 key of the deployment package. Use only with a function defined with a .zip file archive deployment package.
               Type: String
               Length Constraints: Minimum length of 1. Maximum length of 1024.
               Required: No
            
          
            
               
                  S3ObjectVersion
               
            
            
               For versioned objects, the version of the deployment package object to use.
               Type: String
               Length Constraints: Minimum length of 1. Maximum length of 1024.
               Required: No
            
          
            
               
                  SourceKMSKeyArn
               
            
            
               The ARN of the AWS Key Management Service (AWS KMS) customer managed key that's used to encrypt your function's 
      .zip deployment package. If you don't provide a customer managed key, Lambda uses an AWS managed key.
               Type: String
               Pattern: (arn:(aws[a-zA-Z-]*)?:[a-z0-9-.]+:.*)|()
               
               Required: No
            
          
            
               
                  ZipFile
               
            
            
               The base64-encoded contents of the deployment package. AWS SDK and AWS CLI clients 
handle the encoding for you. Use only with a function defined with a .zip file archive deployment package.
               Type: Base64-encoded binary data object
               Required: No
            
         
    
      Response Syntax
      HTTP/1.1 200
Content-type: application/json

{
   "Architectures": [ "string" ],
   "CodeSha256": "string",
   "CodeSize": number,
   "DeadLetterConfig": { 
      "TargetArn": "string"
   },
   "Description": "string",
   "Environment": { 
      "Error": { 
         "ErrorCode": "string",
         "Message": "string"
      },
      "Variables": { 
         "string" : "string" 
      }
   },
   "EphemeralStorage": { 
      "Size": number
   },
   "FileSystemConfigs": [ 
      { 
         "Arn": "string",
         "LocalMountPath": "string"
      }
   ],
   "FunctionArn": "string",
   "FunctionName": "string",
   "Handler": "string",
   "ImageConfigResponse": { 
      "Error": { 
         "ErrorCode": "string",
         "Message": "string"
      },
      "ImageConfig": { 
         "Command": [ "string" ],
         "EntryPoint": [ "string" ],
         "WorkingDirectory": "string"
      }
   },
   "KMSKeyArn": "string",
   "LastModified": "string",
   "LastUpdateStatus": "string",
   "LastUpdateStatusReason": "string",
   "LastUpdateStatusReasonCode": "string",
   "Layers": [ 
      { 
         "Arn": "string",
         "CodeSize": number,
         "SigningJobArn": "string",
         "SigningProfileVersionArn": "string"
      }
   ],
   "LoggingConfig": { 
      "ApplicationLogLevel": "string",
      "LogFormat": "string",
      "LogGroup": "string",
      "SystemLogLevel": "string"
   },
   "MasterArn": "string",
   "MemorySize": number,
   "PackageType": "string",
   "RevisionId": "string",
   "Role": "string",
   "Runtime": "string",
   "RuntimeVersionConfig": { 
      "Error": { 
         "ErrorCode": "string",
         "Message": "string"
      },
      "RuntimeVersionArn": "string"
   },
   "SigningJobArn": "string",
   "SigningProfileVersionArn": "string",
   "SnapStart": { 
      "ApplyOn": "string",
      "OptimizationStatus": "string"
   },
   "State": "string",
   "StateReason": "string",
   "StateReasonCode": "string",
   "Timeout": number,
   "TracingConfig": { 
      "Mode": "string"
   },
   "Version": "string",
   "VpcConfig": { 
      "Ipv6AllowedForDualStack": boolean,
      "SecurityGroupIds": [ "string" ],
      "SubnetIds": [ "string" ],
      "VpcId": "string"
   }
}
    
      Response Elements
      If the action is successful, the service sends back an HTTP 200 response.
      The following data is returned in JSON format by the service.
      
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
      
            
               
                  Architectures
               
            
            
               The instruction set architecture that the function supports. Architecture is a string array with one of the 
      valid values. The default architecture value is x86_64.
               Type: Array of strings
               Array Members: Fixed number of 1 item.
               Valid Values: x86_64 | arm64
               
            
          
            
               
                  CodeSha256
               
            
            
               The SHA256 hash of the function's deployment package.
               Type: String
            
          
            
               
                  CodeSize
               
            
            
               The size of the function's deployment package, in bytes.
               Type: Long
            
          
            
               
                  DeadLetterConfig
               
            
            
               The function's dead letter queue.
               Type: DeadLetterConfig object
            
          
            
               
                  Description
               
            
            
               The function's description.
               Type: String
               Length Constraints: Minimum length of 0. Maximum length of 256.
            
          
            
               
                  Environment
               
            
            
               The function's environment variables. Omitted from AWS CloudTrail logs.
               Type: EnvironmentResponse object
            
          
            
               
                  EphemeralStorage
               
            
            
               The size of the function's /tmp directory in MB. The default value is 512, but can be any whole
  number between 512 and 10,240 MB. For more information, see Configuring ephemeral storage (console).
               Type: EphemeralStorage object
            
          
            
               
                  FileSystemConfigs
               
            
            
               Connection settings for an Amazon EFS file system.
               Type: Array of FileSystemConfig objects
               Array Members: Maximum number of 1 item.
            
          
            
               
                  FunctionArn
               
            
            
               The function's Amazon Resource Name (ARN).
               Type: String
               Pattern: arn:(aws[a-zA-Z-]*)?:lambda:[a-z]{2}(-gov)?-[a-z]+-\d{1}:\d{12}:function:[a-zA-Z0-9-_\.]+(:(\$LATEST|[a-zA-Z0-9-_]+))?
               
            
          
            
               
                  FunctionName
               
            
            
               The name of the function.
               Type: String
               Length Constraints: Minimum length of 1. Maximum length of 170.
               Pattern: (arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\d{1}:)?(\d{12}:)?(function:)?([a-zA-Z0-9-_\.]+)(:(\$LATEST|[a-zA-Z0-9-_]+))?
               
            
          
            
               
                  Handler
               
            
            
               The function that Lambda calls to begin running your function.
               Type: String
               Length Constraints: Maximum length of 128.
               Pattern: [^ ]+
               
            
          
            
               
                  ImageConfigResponse
               
            
            
               The function's image configuration values.
               Type: ImageConfigResponse object
            
          
            
               
                  KMSKeyArn
               
            
            
               The ARN of the AWS Key Management Service (AWS KMS) customer managed key that's used to encrypt the following resources:
               
                   
                   
                   
                   
               
                     The function's environment variables.
                  
                     The function's Lambda SnapStart snapshots.
                  
                     When used with SourceKMSKeyArn, the unzipped version of the .zip deployment package that's used for function invocations. For more information, see 
          Specifying a customer managed key for Lambda.
                  
                     The optimized version of the container image that's used for function invocations. Note that this is not the same key that's used to protect your container image in the Amazon Elastic Container Registry (Amazon ECR). For more information, see Function lifecycle.
                  
               If you don't provide a customer managed key, Lambda uses an AWS owned key or an AWS managed key.
               Type: String
               Pattern: (arn:(aws[a-zA-Z-]*)?:[a-z0-9-.]+:.*)|()
               
            
          
            
               
                  LastModified
               
            
            
               The date and time that the function was last updated, in ISO-8601 format (YYYY-MM-DDThh:mm:ss.sTZD).
               Type: String
            
          
            
               
                  LastUpdateStatus
               
            
            
               The status of the last update that was performed on the function. This is first set to Successful
      after function creation completes.
               Type: String
               Valid Values: Successful | Failed | InProgress
               
            
          
            
               
                  LastUpdateStatusReason
               
            
            
               The reason for the last update that was performed on the function.
               Type: String
            
          
            
               
                  LastUpdateStatusReasonCode
               
            
            
               The reason code for the last update that was performed on the function.
               Type: String
               Valid Values: EniLimitExceeded | InsufficientRolePermissions | InvalidConfiguration | InternalError | SubnetOutOfIPAddresses | InvalidSubnet | InvalidSecurityGroup | ImageDeleted | ImageAccessDenied | InvalidImage | KMSKeyAccessDenied | KMSKeyNotFound | InvalidStateKMSKey | DisabledKMSKey | EFSIOError | EFSMountConnectivityError | EFSMountFailure | EFSMountTimeout | InvalidRuntime | InvalidZipFileException | FunctionError
               
            
          
            
               
                  Layers
               
            
            
               The function's layers.
               Type: Array of Layer objects
            
          
            
               
                  LoggingConfig
               
            
            
               The function's Amazon CloudWatch Logs configuration settings.
               Type: LoggingConfig object
            
          
            
               
                  MasterArn
               
            
            
               For Lambda@Edge functions, the ARN of the main function.
               Type: String
               Pattern: arn:(aws[a-zA-Z-]*)?:lambda:[a-z]{2}(-gov)?-[a-z]+-\d{1}:\d{12}:function:[a-zA-Z0-9-_]+(:(\$LATEST|[a-zA-Z0-9-_]+))?
               
            
          
            
               
                  MemorySize
               
            
            
               The amount of memory available to the function at runtime.
               Type: Integer
               Valid Range: Minimum value of 128. Maximum value of 10240.
            
          
            
               
                  PackageType
               
            
            
               The type of deployment package. Set to Image for container image and set Zip for .zip file archive.
               Type: String
               Valid Values: Zip | Image
               
            
          
            
               
                  RevisionId
               
            
            
               The latest updated revision of the function or alias.
               Type: String
            
          
            
               
                  Role
               
            
            
               The function's execution role.
               Type: String
               Pattern: arn:(aws[a-zA-Z-]*)?:iam::\d{12}:role/?[a-zA-Z_0-9+=,.@\-_/]+
               
            
          
            
               
                  Runtime
               
            
            
               The identifier of the function's 
          runtime. Runtime is required if the deployment package is a .zip file archive. Specifying a runtime results in
          an error if you're deploying a function using a container image.
               The following list includes deprecated runtimes. Lambda blocks creating new functions and updating existing
          functions shortly after each runtime is deprecated. For more information, see
          Runtime use after deprecation.
               For a list of all currently supported runtimes, see
          Supported runtimes.
               Type: String
               Valid Values: nodejs | nodejs4.3 | nodejs6.10 | nodejs8.10 | nodejs10.x | nodejs12.x | nodejs14.x | nodejs16.x | java8 | java8.al2 | java11 | python2.7 | python3.6 | python3.7 | python3.8 | python3.9 | dotnetcore1.0 | dotnetcore2.0 | dotnetcore2.1 | dotnetcore3.1 | dotnet6 | dotnet8 | nodejs4.3-edge | go1.x | ruby2.5 | ruby2.7 | provided | provided.al2 | nodejs18.x | python3.10 | java17 | ruby3.2 | ruby3.3 | ruby3.4 | python3.11 | nodejs20.x | provided.al2023 | python3.12 | java21 | python3.13 | nodejs22.x
               
            
          
            
               
                  RuntimeVersionConfig
               
            
            
               The ARN of the runtime and any errors that occured.
               Type: RuntimeVersionConfig object
            
          
            
               
                  SigningJobArn
               
            
            
               The ARN of the signing job.
               Type: String
               Pattern: arn:(aws[a-zA-Z0-9-]*):([a-zA-Z0-9\-])+:([a-z]{2}(-gov)?-[a-z]+-\d{1})?:(\d{12})?:(.*)
               
            
          
            
               
                  SigningProfileVersionArn
               
            
            
               The ARN of the signing profile version.
               Type: String
               Pattern: arn:(aws[a-zA-Z0-9-]*):([a-zA-Z0-9\-])+:([a-z]{2}(-gov)?-[a-z]+-\d{1})?:(\d{12})?:(.*)
               
            
          
            
               
                  SnapStart
               
            
            
               Set ApplyOn to PublishedVersions to create a snapshot of the initialized execution
      environment when you publish a function version. For more information, see Improving startup performance with Lambda SnapStart.
               Type: SnapStartResponse object
            
          
            
               
                  State
               
            
            
               The current state of the function. When the state is Inactive, you can reactivate the function by
      invoking it.
               Type: String
               Valid Values: Pending | Active | Inactive | Failed
               
            
          
            
               
                  StateReason
               
            
            
               The reason for the function's current state.
               Type: String
            
          
            
               
                  StateReasonCode
               
            
            
               The reason code for the function's current state. When the code is Creating, you can't invoke or
      modify the function.
               Type: String
               Valid Values: Idle | Creating | Restoring | EniLimitExceeded | InsufficientRolePermissions | InvalidConfiguration | InternalError | SubnetOutOfIPAddresses | InvalidSubnet | InvalidSecurityGroup | ImageDeleted | ImageAccessDenied | InvalidImage | KMSKeyAccessDenied | KMSKeyNotFound | InvalidStateKMSKey | DisabledKMSKey | EFSIOError | EFSMountConnectivityError | EFSMountFailure | EFSMountTimeout | InvalidRuntime | InvalidZipFileException | FunctionError
               
            
          
            
               
                  Timeout
               
            
            
               The amount of time in seconds that Lambda allows a function to run before stopping it.
               Type: Integer
               Valid Range: Minimum value of 1.
            
          
            
               
                  TracingConfig
               
            
            
               The function's AWS X-Ray tracing configuration.
               Type: TracingConfigResponse object
            
          
            
               
                  Version
               
            
            
               The version of the Lambda function.
               Type: String
               Length Constraints: Minimum length of 1. Maximum length of 1024.
               Pattern: (\$LATEST|[0-9]+)
               
            
          
            
               
                  VpcConfig
               
            
            
               The function's networking configuration.
               Type: VpcConfigResponse object
            
         
    
      Errors
      For information about the errors that are common to all actions, see Common Errors.
      
          
          
          
          
          
          
          
          
          
          
      
            
               
                  CodeSigningConfigNotFoundException
               
            
            
               The specified code signing configuration does not exist.
               HTTP Status Code: 404
            
          
            
               
                  CodeStorageExceededException
               
            
            
               Your AWS account has exceeded its maximum total code size. For more information, see Lambda quotas.
               HTTP Status Code: 400
            
          
            
               
                  CodeVerificationFailedException
               
            
            
               The code signature failed one or more of the validation checks for signature mismatch or expiry, and the code
      signing policy is set to ENFORCE. Lambda blocks the deployment.
               HTTP Status Code: 400
            
          
            
               
                  InvalidCodeSignatureException
               
            
            
               The code signature failed the integrity check. If the integrity check fails, then Lambda blocks
      deployment, even if the code signing policy is set to WARN.
               HTTP Status Code: 400
            
          
            
               
                  InvalidParameterValueException
               
            
            
               One of the parameters in the request is not valid.
               HTTP Status Code: 400
            
          
            
               
                  PreconditionFailedException
               
            
            
               The RevisionId provided does not match the latest RevisionId for the Lambda function or alias.
               
                   
                   
               
                     
                        For AddPermission and RemovePermission API operations: Call GetPolicy to retrieve the latest RevisionId for your resource.
                  
                     
                        For all other API operations: Call GetFunction or GetAlias to retrieve the latest RevisionId for your resource.
                  
               HTTP Status Code: 412
            
          
            
               
                  ResourceConflictException
               
            
            
               The resource already exists, or another operation is in progress.
               HTTP Status Code: 409
            
          
            
               
                  ResourceNotFoundException
               
            
            
               The resource specified in the request does not exist.
               HTTP Status Code: 404
            
          
            
               
                  ServiceException
               
            
            
               The AWS Lambda service encountered an internal error.
               HTTP Status Code: 500
            
          
            
               
                  TooManyRequestsException
               
            
            
               The request throughput limit was exceeded. For more information, see Lambda quotas.
               HTTP Status Code: 429
            
         
    
      See Also
      For more information about using this API in one of the language-specific AWS SDKs, see the following:
      
          
          
          
          
          
          
          
          
          
          
      
            
               AWS Command Line Interface
            
         
            
               AWS SDK for .NET
            
         
            
               AWS SDK for C++
            
         
            
               AWS SDK for Go v2
            
         
            
               AWS SDK for Java V2
            
         
            
               AWS SDK for JavaScript V3
            
         
            
               AWS SDK for Kotlin
            
         
            
               AWS SDK for PHP V3
            
         
            
               AWS SDK for Python
            
         
            
               AWS SDK for Ruby V3
            
         
   Document ConventionsUpdateEventSourceMappingUpdateFunctionConfigurationDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS Serverless Application ModelDeveloper GuideGetting started with AWS SAMGet started with AWS SAM by reviewing and completing the topics in this section. AWS SAM prerequisites provides detailed instructions 
    on setting up an AWS account, creating IAM users, creating key access, and installing and configuring the AWS SAM CLI. After completing the prequisites, 
    you’ll be ready to Install the AWS SAM CLI, which you can do on Linux, Windows, and macOS operating systems. 
    After installation is complete, you can optionally walk through the AWS SAM Hello World tutorial. Following this tutorial will walk you through the process of creating 
    a basic serverless application with AWS SAM. After completing the tutorial, you’ll be ready to review the concepts detailed in How to use AWS Serverless Application Model (AWS SAM).TopicsAWS SAM prerequisitesInstall the AWS SAM CLITutorial: Deploy a Hello World application with AWS SAMDocument ConventionsServerless conceptsPrerequisitesDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS Serverless Application ModelDeveloper GuideSyntaxPropertiesExamplesFunctionCodeThe deployment package for a Lambda function.SyntaxTo declare this entity in your AWS Serverless Application Model (AWS SAM) template, use the following syntax.
        
            YAML
          Bucket: String
  Key: String
  Version: String

    
 
    Properties
    
        
         

         

         

    
            
                Bucket
            
            
                An Amazon S3 bucket in the same AWS Region as your function.

                Type: String
                Required: Yes

                AWS CloudFormation compatibility: This property is passed directly to the S3Bucket property of the AWS::Lambda::Function Code data type.

            
         
            
                Key
            
            
                The Amazon S3 key of the deployment package.

                Type: String
                Required: Yes

                AWS CloudFormation compatibility: This property is passed directly to the S3Key property of the AWS::Lambda::Function Code data type.

            
         
            
                Version
            
            
                For versioned objects, the version of the deployment package object to use.

                Type: String
                Required: No

                AWS CloudFormation compatibility: This property is passed directly to the S3ObjectVersion property of the AWS::Lambda::Function Code data type.

            
        
 
    Examples
    
     
        FunctionCode
        CodeUri: Function Code example

        
            YAML
            CodeUri:
  Bucket: sam-s3-demo-bucket-name
  Key: mykey-name
  Version: 121212

        
     

Document ConventionsSQSFunctionUrlConfigDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS Serverless Application ModelDeveloper GuideSyntaxPropertiesReturn ValuesExamplesAWS::Serverless::FunctionCreates an AWS Lambda function, an AWS Identity and Access Management (IAM) execution role, and event source
		mappings that trigger the function.The AWS::Serverless::Function resource
		also supports the Metadata resource attribute, so you can instruct AWS SAM to build
		custom runtimes that your application requires. For more information about building custom
		runtimes, see Building Lambda functions with custom runtimes in AWS SAM.NoteWhen you deploy to AWS CloudFormation, AWS SAM transforms your AWS SAM resources into AWS CloudFormation resources.
			For more information, see Generated AWS CloudFormation resources for AWS SAM.
		Syntax
		To declare this entity in your AWS Serverless Application Model (AWS SAM) template, use the following
			syntax.
		
			YAML
			Type: AWS::Serverless::Function
Properties:
  Architectures: List
  AssumeRolePolicyDocument: JSON
  AutoPublishAlias: String
  AutoPublishAliasAllProperties: Boolean
  AutoPublishCodeSha256: String
  CodeSigningConfigArn: String
  CodeUri: String | FunctionCode
  DeadLetterQueue: Map | DeadLetterQueue
  DeploymentPreference: DeploymentPreference
  Description: String
  Environment: Environment
  EphemeralStorage: EphemeralStorage
  EventInvokeConfig: EventInvokeConfiguration
  Events: EventSource
  FileSystemConfigs: List
  FunctionName: String
  FunctionUrlConfig: FunctionUrlConfig
  Handler: String
  ImageConfig: ImageConfig
  ImageUri: String
  InlineCode: String
  KmsKeyArn: String
  Layers: List
  LoggingConfig: LoggingConfig
  MemorySize: Integer
  PackageType: String
  PermissionsBoundary: String
  Policies: String | List | Map
  PropagateTags: Boolean
  ProvisionedConcurrencyConfig: ProvisionedConcurrencyConfig
  RecursiveLoop: String
  ReservedConcurrentExecutions: Integer
  Role: String
  RolePath: String
  Runtime: String
  RuntimeManagementConfig: RuntimeManagementConfig
  SnapStart: SnapStart
  SourceKMSKeyArn: String
  Tags: Map
  Timeout: Integer
  Tracing: String
  VersionDescription: String
  VpcConfig: VpcConfig

		
	 
		Properties
		

			 

			 

			 

			 

			 

			 

			 

			 

			 

			 

			 

			 

			 

			 
			 

			 

			 

			 

			 

			 

			 

			 

			 
			
			
			 

			 

			 

			 

			
			 

			
			 
			
			
			 
			
			 

			 

			 

			 

			 

			 

			 
			
			 

			 

			 

			 

			 

			 

		
				
					Architectures
				
				
					The instruction set architecture for the function.
					For more information about this property, see Lambda instruction set architectures in
						the AWS Lambda Developer Guide.
					Valid values: One of x86_64 or
							arm64

					Type: List
					Required: No
					Default: x86_64

					AWS CloudFormation compatibility: This property is passed directly to the
								Architectures property of an AWS::Lambda::Function
						resource.

				
			 
				
					AssumeRolePolicyDocument
				
				
					Adds an AssumeRolePolicyDocument for the default created Role for this
						function. If this property isn't specified, AWS SAM adds a default assume role for this
						function.

					Type: JSON
					Required: No

					AWS CloudFormation compatibility: This property is similar to the
								AssumeRolePolicyDocument property of an AWS::IAM::Role
						resource. AWS SAM adds this property to the generated IAM role for this function. If a
						role's Amazon Resource Name (ARN) is provided for this function, this property does
						nothing.

				
			 
				
					AutoPublishAlias
				
				
					The name of the Lambda alias. For more information about Lambda aliases, see Lambda function aliases in the
							AWS Lambda Developer Guide. For examples that use this
						property, see Deploying serverless applications
      gradually with AWS SAM.
					AWS SAM generates AWS::Lambda::Version and AWS::Lambda::Alias resources when this property is set. For
						information about this scenario, see AutoPublishAlias property is specified. For
						general information about generated AWS CloudFormation resources, see Generated AWS CloudFormation resources for AWS SAM.

					Type: String
					Required: No

					AWS CloudFormation compatibility: This property is unique to AWS SAM and
						doesn't have an AWS CloudFormation equivalent.

				
			 
				
					AutoPublishAliasAllProperties
				
				
					Specifies when a new AWS::Lambda::Version is created. When true, a new
						Lambda version is created when any property in the Lambda function is modified. When
							false, a new Lambda version is created only when any of the following
						properties are modified:
					
						 
						 
					
							Environment, MemorySize, or
								SnapStart.
						
							Any change that results in an update to the Code property, such as
									CodeDict, ImageUri, or InlineCode.
						
					This property requires AutoPublishAlias to be defined.
					If AutoPublishCodeSha256 is also specified, its behavior takes precedence
						over AutoPublishAliasAllProperties: true.
					Type: Boolean
					Required: No
					Default value: false
					AWS CloudFormation compatibility: This property is unique to AWS SAM and
						doesn't have an AWS CloudFormation equivalent.
				

			 
				
					AutoPublishCodeSha256
				
				
					When used, this string works with the CodeUri value to determine if a new Lambda version needs to be published. 
						This property is often used to resolve the following deployment issue: A deployment package is stored in an Amazon S3 location 
						and is replaced by a new deployment package with updated Lambda function code but the CodeUri property remains unchanged
						(as opposed to the new deployment package being uploaded to a new Amazon S3 location and the CodeUri
						being changed to the new location).
					
					This problem is marked by an AWS SAM template having the following characteristics:
					
					
						 
						 
						 
					The DeploymentPreference object is configured for gradual deployments (as described in Deploying serverless applications
      gradually with AWS SAM)The AutoPublishAlias property is set and doesn't change between deploymentsThe CodeUri property is set and doesn't change between deployments.
					
					In this scenario, updating AutoPublishCodeSha256 results in a new Lambda version being created successfully. 
						However, new function code deployed to Amazon S3 will not be recognized. To recognize new function code, consider using versioning in your Amazon S3 bucket. 
						Specify the Version property for your Lambda function and configure your bucket to always use the latest deployment package.
					
					In this scenario, to trigger the gradual deployment successfully, you must provide a unique value for AutoPublishCodeSha256.

					Type: String
					Required: No

					AWS CloudFormation compatibility: This property is unique to AWS SAM and
						doesn't have an AWS CloudFormation equivalent.

				
			 
				
					CodeSigningConfigArn
				
				
					The ARN of the AWS::Lambda::CodeSigningConfig resource, used to enable code
						signing for this function. For more information about code signing, see Set up code signing for your AWS SAM application.

					Type: String
					Required: No

					AWS CloudFormation compatibility: This property is passed directly to the
								CodeSigningConfigArn property of an
							AWS::Lambda::Function resource.

				
			 
				
					CodeUri
				
				
					The code for the function. Accepted values include:
					
						 
						 
						 
					
							The function's Amazon S3 URI. For example, s3://bucket-123456789/sam-app/1234567890abcdefg.
						
							The local path to the function. For example, hello_world/.
						
							A FunctionCode object.
						
					NoteIf you provide a function's Amazon S3 URI or FunctionCode object, 
						you must reference a valid Lambda deployment package.If you provide a local file path, use the AWS SAM CLI to upload the local file at deployment. To learn more, see How AWS SAM uploads local files at deployment.If you use intrinsic functions in CodeUri property, AWS SAM will not be able to correctly parse the values. Consider using 
						AWS::LanguageExtensions transform instead.
					Type: [ String | FunctionCode ]
					Required: Conditional. When PackageType is set to Zip, one of CodeUri or InlineCode is 
						required.
					AWS CloudFormation compatibility: This property is similar to the 
						Code property of an AWS::Lambda::Function resource. The nested Amazon S3 properties are named differently.
				
			 
				
					DeadLetterQueue
				
				
					Configures an Amazon Simple Notification Service (Amazon SNS) topic or Amazon Simple Queue Service (Amazon SQS) queue where Lambda sends
						events that it can't process. For more information about dead-letter queue
						functionality, see Dead-letter queues in the AWS Lambda Developer Guide.
					NoteIf your Lambda function's event source is an Amazon SQS queue, configure a dead-letter
							queue for the source queue, not for the Lambda function. The dead-letter queue that you
							configure for a function is used for the function's asynchronous invocation queue, not
							for event source queues.

					Type: Map | DeadLetterQueue
					Required: No

					AWS CloudFormation compatibility: This property is similar to the
								DeadLetterConfig property of an AWS::Lambda::Function
						resource. In AWS CloudFormation the type is derived from the TargetArn, whereas in AWS SAM
						you must pass the type along with the TargetArn.

				
			 
				
					DeploymentPreference
				
				
					The settings to enable gradual Lambda deployments.
					If a DeploymentPreference object is specified, AWS SAM creates an AWS::CodeDeploy::Application called
							ServerlessDeploymentApplication (one per stack), an AWS::CodeDeploy::DeploymentGroup called
								<function-logical-id>DeploymentGroup,
						and an AWS::IAM::Role called
						CodeDeployServiceRole.

					Type: DeploymentPreference
					Required: No

					AWS CloudFormation compatibility: This property is unique to AWS SAM and
						doesn't have an AWS CloudFormation equivalent.
					See also: For more information about this property, see Deploying serverless applications
      gradually with AWS SAM.

				
			 
				
					Description
				
				
					A description of the function.

					Type: String
					Required: No

					AWS CloudFormation compatibility: This property is passed directly to the
								Description property of an AWS::Lambda::Function
						resource.

				
			 
				
					Environment
				
				
					The configuration for the runtime environment.

					Type: Environment
					Required: No

					AWS CloudFormation compatibility: This property is passed directly to the
								Environment property of an AWS::Lambda::Function
						resource.

				
			 
				
					EphemeralStorage
				
				
					An object that specifies the disk space, in MB, available to your Lambda function in
							/tmp.
					For more information about this property, see Lambda execution environment in the
							AWS Lambda Developer Guide.

					Type: EphemeralStorage
					Required: No

					AWS CloudFormation compatibility: This property is passed directly to the
								EphemeralStorage property of an AWS::Lambda::Function
						resource.

				
			 
				
					EventInvokeConfig
				
				
					The object that describes event invoke configuration on a Lambda function.

					Type: EventInvokeConfiguration
					Required: No

					AWS CloudFormation compatibility: This property is unique to AWS SAM and
						doesn't have an AWS CloudFormation equivalent.

				
			 
				
					Events
				
				
					Specifies the events that trigger this function. Events consist of a type and a set
						of properties that depend on the type.

					Type: EventSource
					Required: No

					AWS CloudFormation compatibility: This property is unique to AWS SAM and
						doesn't have an AWS CloudFormation equivalent.

				
			 
				
					FileSystemConfigs
				
				
					List of FileSystemConfig objects that specify the connection settings for an
						Amazon Elastic File System (Amazon EFS) file system.
					If your template contains an AWS::EFS::MountTarget resource, you must also specify a
							DependsOn resource attribute to ensure that the mount target is created
						or updated before the function.

					Type: List
					Required: No

					AWS CloudFormation compatibility: This property is passed directly to the
								FileSystemConfigs property of an AWS::Lambda::Function
						resource.

				
			 
				
					FunctionName
				
				
					A name for the function. If you don't specify a name, a unique name is generated for
						you.

					Type: String
					Required: No

					AWS CloudFormation compatibility: This property is passed directly to the
								FunctionName property of an AWS::Lambda::Function
						resource.

				
			 
				
					FunctionUrlConfig
				
				
					The object that describes a function URL. A function URL is an HTTPS endpoint that
						you can use to invoke your function.
					For more information, see Function
							URLs in the AWS Lambda Developer Guide.

					Type: FunctionUrlConfig
					Required: No

					AWS CloudFormation compatibility: This property is unique to AWS SAM and
						doesn't have an AWS CloudFormation equivalent.

				
			 
				
					Handler
				
				
					The function within your code that is called to begin execution. This property is
						only required if the PackageType property is set to
						Zip.

					Type: String
					Required: Conditional

					AWS CloudFormation compatibility: This property is passed directly to the
								Handler property of an AWS::Lambda::Function
						resource.

				
			 
				
					ImageConfig
				
				
					The object used to configure Lambda container image settings. For more information,
						see Using container images with
							Lambda in the AWS Lambda Developer Guide.

					Type: ImageConfig
					Required: No

					AWS CloudFormation compatibility: This property is passed directly to the
								ImageConfig property of an AWS::Lambda::Function
						resource.

				
			 
				
					ImageUri
				
				
					The URI of the Amazon Elastic Container Registry (Amazon ECR) repository for the Lambda function's container
						image. This property only applies if the PackageType property is set to
							Image, otherwise it is ignored. For more information, see Using container images with Lambda in the
							AWS Lambda Developer Guide.
					NoteIf the PackageType property is set to Image, then either
								ImageUri is required, or you must build your application with necessary
								Metadata entries in the AWS SAM template file. For more information, see
								Default build with AWS SAM.
					Building your application with necessary Metadata entries takes
						precedence over ImageUri, so if you specify both then ImageUri
						is ignored.

					Type: String
					Required: No

					AWS CloudFormation compatibility: This property is passed directly to the
								ImageUri property of the AWS::Lambda::Function
						Code data type.

				
			 
				
					InlineCode
				
				
					The Lambda function code that is written directly in the template. This property only
						applies if the PackageType property is set to Zip, otherwise
						it is ignored.
					NoteIf the PackageType property is set to Zip (default),
							then one of CodeUri or InlineCode is required.

					Type: String
					Required: Conditional

					AWS CloudFormation compatibility: This property is passed directly to the
								ZipFile property of the AWS::Lambda::Function
						Code data type.

				
			 
				
					KmsKeyArn
				
				
					The ARN of an AWS Key Management Service (AWS KMS) key that Lambda uses to encrypt and decrypt your
						function's environment variables.

					Type: String
					Required: No

					AWS CloudFormation compatibility: This property is passed directly to the
								KmsKeyArn property of an AWS::Lambda::Function
						resource.

				
			 
				
					Layers
				
				
					The list of LayerVersion ARNs that this function should use. The order
						specified here is the order in which they will be imported when running the Lambda
						function. The version is either a full ARN including the version or a reference to a LayerVersion resource. For example, a reference to a LayerVersion will be !Ref MyLayer 
						while a full ARN including the version will be 
						arn:aws:lambda:region:account-id:layer:layer-name:version.

					Type: List
					Required: No

					AWS CloudFormation compatibility: This property is passed directly to the
								Layers property of an AWS::Lambda::Function
						resource.

				
			 
				
					LoggingConfig
				
				
					The function's Amazon CloudWatch Logs configuration settings.
					Type: LoggingConfig
					Required: No
					AWS CloudFormation compatibility: This property is passed directly to the 
						LoggingConfig property of an AWS::Lambda::Function resource.
				
			 
				
					MemorySize
				
				
					The size of the memory in MB allocated per invocation of the function.

					Type: Integer
					Required: No

					AWS CloudFormation compatibility: This property is passed directly to the
								MemorySize property of an AWS::Lambda::Function
						resource.

				
			 
				
					PackageType
				
				
					The deployment package type of the Lambda function. For more information, see Lambda deployment packages in
						the AWS Lambda Developer Guide.
					Notes:
					1. If this property is set to Zip (default), then either
							CodeUri or InlineCode applies, and ImageUri is
						ignored.
					2. If this property is set to Image, then only ImageUri
						applies, and both CodeUri and InlineCode are ignored. The
						Amazon ECR repository required to store the function's container image can be auto created by
						the AWS SAM CLI. For more information, see sam deploy.
					Valid values: Zip or
							Image

					Type: String
					Required: No
					Default: Zip

					AWS CloudFormation compatibility: This property is passed directly to the
								PackageType property of an AWS::Lambda::Function
						resource.

				
			 
				
					PermissionsBoundary
				
				
					The ARN of a permissions boundary to use for this function's execution role. This
						property works only if the role is generated for you.

					Type: String
					Required: No

					AWS CloudFormation compatibility: This property is passed directly to the
								PermissionsBoundary property of an AWS::IAM::Role
						resource.

				
			 
				
					Policies
				
				
					Permission policies for this function. Policies will be appended to the function's
						default AWS Identity and Access Management (IAM) execution role.
					This property accepts a single value or list of values. Allowed values
						include:
					
						 
						 
						 
						 
					
							AWS SAM policy templates.
						
							The ARN of an AWS managed policy or  customer managed policy.
						
							The name of an AWS managed policy from the following  list.
						
							An 
									inline IAM policy formatted in YAML as a map.
						
					NoteIf you set the Role property, this property is ignored.
					Type: String | List | Map
					Required: No

					AWS CloudFormation compatibility: This property is similar to the
								Policies property of an AWS::IAM::Role resource.
				
			 
				PropagateTags
				
					Indicate whether or not to pass tags from the Tags property to your
							AWS::Serverless::Function generated
						resources. Specify True to propagate tags in your generated
						resources.
					Type: Boolean
					Required: No
					Default: False
					AWS CloudFormation compatibility: This property is unique to AWS SAM and
						doesn't have an AWS CloudFormation equivalent.
				
			 
				
					ProvisionedConcurrencyConfig
				
				
					The provisioned concurrency configuration of a function's alias.
					NoteProvisionedConcurrencyConfig can be specified only if the
							AutoPublishAlias is set. Otherwise, an error results.
					
					Type: ProvisionedConcurrencyConfig
					Required: No
					
					AWS CloudFormation compatibility: This property is passed directly to the
						ProvisionedConcurrencyConfig property of an
						AWS::Lambda::Alias resource.
					
				
			 
				
					RecursiveLoop
				
				
					The status of your function's recursive loop detection configuration.
					
					When this value is set to Allow and Lambda detects your function being invoked as part of a recursive loop, it doesn't take any action.
					
					When this value is set to Terminate and Lambda detects your function being invoked as part of a recursive loop, it stops your function being invoked and notifies you. 
					
					Type: String
					Required: No
					
					AWS CloudFormation compatibility: This property is passed directly to the 
						RecursiveLoop 
						property of the AWS::Lambda::Function resource.
					
				
			 
				
					ReservedConcurrentExecutions
				
				
					The maximum number of concurrent executions that you want to reserve for the
						function.
					For more information about this property, see Lambda Function Scaling in the AWS Lambda Developer Guide.

					Type: Integer
					Required: No

					AWS CloudFormation compatibility: This property is passed directly to the
								ReservedConcurrentExecutions property of an
							AWS::Lambda::Function resource.

				
			 
				
					Role
				
				
					The ARN of an IAM role to use as this function's execution role.

					Type: String
					Required: No

					AWS CloudFormation compatibility: This property is similar to the
								Role property of an AWS::Lambda::Function resource.
						This is required in AWS CloudFormation but not in AWS SAM. If a role isn't specified, one is created
						for you with a logical ID of
								<function-logical-id>Role.

				
			 
				
					RolePath
				
				
					The path to the function's IAM execution role.
					Use this property when the role is generated for you. Do not use when the role is
						specified with the Role property.
					Type: String
					Required: Conditional
					AWS CloudFormation compatibility: This property is passed directly to the
								Path property of an AWS::IAM::Role resource.

				
			 
				
					Runtime
				
				
					The identifier of the function's runtime. This property is only required if the PackageType
						property is set to Zip.
					NoteIf you specify the provided identifier for this property, you can use
							the Metadata resource attribute to instruct AWS SAM to build the custom
							runtime that this function requires. For more information about building custom
							runtimes, see Building Lambda functions with custom runtimes in AWS SAM.

					Type: String
					Required: Conditional

					AWS CloudFormation compatibility: This property is passed directly to the
								Runtime property of an AWS::Lambda::Function
						resource.

				
			 
				
					RuntimeManagementConfig
				
				
					Configure runtime management options for your Lambda functions such as runtime
						environment updates, rollback behavior, and selecting a specific runtime version. To
						learn more, see Lambda runtime updates in the AWS Lambda Developer Guide.
					Type: RuntimeManagementConfig
					Required: No
					AWS CloudFormation compatibility: This property is passed directly to the
								 RuntimeManagementConfig property of an
							AWS::Lambda::Function resource.
				
			 
				
					SnapStart
				
				
					Create a snapshot of any new Lambda function version. A snapshot is a cached state of
						your initialized function, including all of its dependencies. The function is
						initialized just once and the cached state is reused for all future invocations,
						improving application performance by reducing the number of times your function must be
						initialized. To learn more, see Improving startup performance with Lambda
							SnapStart in the AWS Lambda Developer Guide.

					Type: SnapStart
					Required: No

					AWS CloudFormation compatibility: This property is passed directly to the
								SnapStart property of an AWS::Lambda::Function
						resource.

				
			 
				
					SourceKmsKeyArn
				
				
					Represents a KMS key ARN that is used to encrypt the customer's ZIP function code.
					
					Type: String
					Required: No
					
					AWS CloudFormation compatibility: This property is passed directly to the
						SourceKmsKeyArn property of an AWS::Lambda::Function Code data type.
					
				
			 
				
					Tags
				
				
					A map (string to string) that specifies the tags added to this function. For details
						about valid keys and values for tags, see Tag Key and
							Value Requirements in the AWS Lambda Developer Guide.
					When the stack is created, AWS SAM automatically adds a
							lambda:createdBy:SAM tag to this Lambda function, and to the default roles
						that are generated for this function.

					Type: Map
					Required: No

					AWS CloudFormation compatibility: This property is similar to the
								Tags property of an AWS::Lambda::Function resource. The
							Tags property in AWS SAM consists of key-value pairs (whereas in AWS CloudFormation this
						property consists of a list of Tag objects). Also, AWS SAM automatically adds
						a lambda:createdBy:SAM tag to this Lambda function, and to the default roles
						that are generated for this function.

				
			 
				
					Timeout
				
				
					The maximum time in seconds that the function can run before it is stopped.

					Type: Integer
					Required: No
					Default: 3

					AWS CloudFormation compatibility: This property is passed directly to the
								Timeout property of an AWS::Lambda::Function
						resource.

				
			 
				
					Tracing
				
				
					The string that specifies the function's X-Ray tracing mode.
					
						 
						 
						 
					
							Active – Activates X-Ray tracing for the function.
						
							Disabled – Deactivates X-Ray for the function.
						
							PassThrough – Activates X-Ray tracing for the function. Sampling decision is delegated
								to the downstream services.
						
					If specified as Active or PassThrough and the Role property is not set, 
						AWS SAM adds the arn:aws:iam::aws:policy/AWSXrayWriteOnlyAccess policy to the Lambda execution role that 
						it creates for you.
					For more information about X-Ray, see Using AWS Lambda with
							AWS X-Ray in the AWS Lambda Developer Guide.
					Valid values: [Active|Disabled|PassThrough]
					Type: String
					Required: No

					AWS CloudFormation compatibility: This property is similar to the TracingConfig property of an AWS::Lambda::Function resource.
				
			 
				
					VersionDescription
				
				
					Specifies the Description field that is added on the new Lambda version
						resource.

					Type: String
					Required: No

					AWS CloudFormation compatibility: This property is passed directly to the
								Description property of an AWS::Lambda::Version
						resource.

				
			 
				
					VpcConfig
				
				
					The configuration that enables this function to access private resources within your
						virtual private cloud (VPC).

					Type: VpcConfig
					Required: No

					AWS CloudFormation compatibility: This property is passed directly to the
								VpcConfig property of an AWS::Lambda::Function
						resource.

				
			
	 
		Return Values

		
		 
			Ref
			When the logical ID of this resource is provided to the Ref intrinsic
				function, it returns the resource name of the underlying Lambda function.
			For more information about using the Ref function, see Ref in the AWS CloudFormation User Guide. 
		 


		
		 
			Fn::GetAtt
			Fn::GetAtt returns a value for a specified attribute of this type. The
				following are the available attributes and sample return values. 
			For more information about using Fn::GetAtt, see Fn::GetAtt in the AWS CloudFormation User Guide. 
			

				 

			
					Arn
					
						The ARN of the underlying Lambda function.
					
				
		 

	 
		Examples
		
		 
			Simple function
			The following is a basic example of an AWS::Serverless::Function resource of package type Zip
				(default) and function code in an Amazon S3 bucket.

			
				YAML
				Type: AWS::Serverless::Function
Properties:
  Handler: index.handler
  Runtime: python3.9
  CodeUri: s3://bucket-name/key-name

			
		 

		 
			Function
					properties example
			The following is an example of an AWS::Serverless::Function of package type Zip (default) that
				uses InlineCode, Layers, Tracing,
					Policies, Amazon EFS, and an Api event source.

			
				YAML
				Type: AWS::Serverless::Function
DependsOn: MyMountTarget        # This is needed if an AWS::EFS::MountTarget resource is declared for EFS
Properties:
  Handler: index.handler
  Runtime: python3.9
  InlineCode: |
    def handler(event, context):
      print("Hello, world!")
  ReservedConcurrentExecutions: 30
  Layers:
    - Ref: MyLayer
  Tracing: Active
  Timeout: 120
  FileSystemConfigs:
    - Arn: !Ref MyEfsFileSystem
      LocalMountPath: /mnt/EFS
  Policies:
    - AWSLambdaExecute
    - Version: '2012-10-17' 
      Statement:
        - Effect: Allow
          Action:
            - s3:GetObject
            - s3:GetObjectACL
          Resource: 'arn:aws:s3:::sam-s3-demo-bucket/*'
  Events:
    ApiEvent:
      Type: Api
      Properties:
        Path: /path
        Method: get

			
		 

		 
			ImageConfig
					example
			The following is an example of an ImageConfig for a Lambda function of
				package type Image.

			
				YAML
				HelloWorldFunction:
  Type: AWS::Serverless::Function
  Properties:
    PackageType: Image
    ImageUri: account-id.dkr.ecr.region.amazonaws.com/ecr-repo-name:image-name
    ImageConfig:
      Command:
        - "app.lambda_handler"
      EntryPoint:
        - "entrypoint1"
      WorkingDirectory: "workDir"

			
		 

		 
			
					RuntimeManagementConfig examples

			A Lambda function configured to update its runtime environment according to current
				behavior:
			TestFunction
  Type: AWS::Serverless::Function
  Properties:
    ...
    Runtime: python3.9
    RuntimeManagementConfig:
      UpdateRuntimeOn: Auto

			A Lambda function configured to update its runtime environment when the function is
				updated:
			TestFunction
  Type: AWS::Serverless::Function
  Properties:
    ...
    Runtime: python3.9
    RuntimeManagementConfig:
      UpdateRuntimeOn: FunctionUpdate

			A Lambda function configured to update its runtime environment manually:
			TestFunction
  Type: AWS::Serverless::Function
  Properties:
    ...
    Runtime: python3.9
    RuntimeManagementConfig:
      RuntimeVersionArn: arn:aws:lambda:us-east-1::runtime:4c459dd0104ee29ec65dcad056c0b3ddbe20d6db76b265ade7eda9a066859b1e
      UpdateRuntimeOn: Manual

		 

		 
			SnapStart
					examples

			Example of a Lambda function with SnapStart turned on for future versions:
			TestFunc
  Type: AWS::Serverless::Function
  Properties:
    ...
    SnapStart:
      ApplyOn: PublishedVersions
		 

	Document ConventionsSourceReferenceDeadLetterQueueDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS CloudFormationUser GuideSyntaxPropertiesReturn valuesExamplesAWS::Lambda::FunctionThe AWS::Lambda::Function resource creates a Lambda function. To create a function, you need a
         deployment package and an
         execution role.
         The deployment package is a .zip file  archive or container image that contains your function code. 
         The execution role grants the function permission to use AWS services, such as Amazon CloudWatch Logs 
         for log streaming and AWS X-Ray for request tracing.You set the package type to Image if the deployment package is a 
         container image. For these functions, 
         include the URI of the container image in the Amazon ECR registry in the ImageUri property of the Code property. You do not need to specify the handler and
         runtime properties. You set the package type to Zip if the deployment package is a .zip file archive. 
         For these functions, specify the Amazon S3 location of your .zip file in the Code property.
         Alternatively, for Node.js and Python functions, you can define your function inline in the ZipFile property of the Code property. In both cases, you must also specify the
         handler and runtime properties.You can use code signing 
         if your deployment package is a .zip file archive. To enable code signing for this function, 
         specify the ARN of a code-signing configuration. When a user
         attempts to deploy a code package with UpdateFunctionCode, Lambda checks that the code
         package has a valid signature from a trusted publisher. The code-signing configuration
         includes a set of signing profiles, which define the trusted publishers for this function.When you update a AWS::Lambda::Function resource, CloudFormation calls the
         UpdateFunctionConfiguration
         and UpdateFunctionCodeLambda APIs under the hood. Because these calls happen sequentially, and invocations can happen
         between these calls, your function may encounter errors in the time between the calls. For example, if you remove an
         environment variable, and the code that references that environment variable in the same CloudFormation
         update, you may see invocation errors related to a missing environment variable. To work around this, you can invoke
         your function against a version or alias by default, rather than the $LATEST version.Note that you configure 
         provisioned concurrency on a AWS::Lambda::Version or a AWS::Lambda::Alias.For a complete introduction to Lambda functions, see 
      What is Lambda?
     in the Lambda developer guide.SyntaxTo declare this entity in your AWS CloudFormation template, use the following syntax:JSON{
  "Type" : "AWS::Lambda::Function",
  "Properties" : {
      "Architectures" : [ String, ... ],
      "Code" : Code,
      "CodeSigningConfigArn" : String,
      "DeadLetterConfig" : DeadLetterConfig,
      "Description" : String,
      "Environment" : Environment,
      "EphemeralStorage" : EphemeralStorage,
      "FileSystemConfigs" : [ FileSystemConfig, ... ],
      "FunctionName" : String,
      "Handler" : String,
      "ImageConfig" : ImageConfig,
      "KmsKeyArn" : String,
      "Layers" : [ String, ... ],
      "LoggingConfig" : LoggingConfig,
      "MemorySize" : Integer,
      "PackageType" : String,
      "RecursiveLoop" : String,
      "ReservedConcurrentExecutions" : Integer,
      "Role" : String,
      "Runtime" : String,
      "RuntimeManagementConfig" : RuntimeManagementConfig,
      "SnapStart" : SnapStart,
      "Tags" : [ Tag, ... ],
      "Timeout" : Integer,
      "TracingConfig" : TracingConfig,
      "VpcConfig" : VpcConfig
    }
}
YAMLType: AWS::Lambda::Function
Properties:
  Architectures: 
    - String
  Code: 
    Code
  CodeSigningConfigArn: String
  DeadLetterConfig: 
    DeadLetterConfig
  Description: String
  Environment: 
    Environment
  EphemeralStorage: 
    EphemeralStorage
  FileSystemConfigs: 
    - FileSystemConfig
  FunctionName: String
  Handler: String
  ImageConfig: 
    ImageConfig
  KmsKeyArn: String
  Layers: 
    - String
  LoggingConfig: 
    LoggingConfig
  MemorySize: Integer
  PackageType: String
  RecursiveLoop: String
  ReservedConcurrentExecutions: Integer
  Role: String
  Runtime: String
  RuntimeManagementConfig: 
    RuntimeManagementConfig
  SnapStart: 
    SnapStart
  Tags: 
    - Tag
  Timeout: Integer
  TracingConfig: 
    TracingConfig
  VpcConfig: 
    VpcConfig
PropertiesArchitectures
                    The instruction set architecture that the function supports. Enter a string array with one of the valid values (arm64 or x86_64).
     The default value is x86_64.
                Required: NoType: Array of StringAllowed values: x86_64 | arm64Minimum: 1Maximum: 1Update requires: No interruptionCode
                    The code for the function. You can define your function code in multiple ways:
                    
                         
                         
                         
                    
                            For .zip deployment packages, you can specify the Amazon S3 location of the .zip file
               in the S3Bucket, S3Key, and S3ObjectVersion properties.
                        
                            For .zip deployment packages, you can alternatively define the function code inline in the
               ZipFile property. This method works only for Node.js and Python functions.
                        
                            For container images, specify the URI of your container image in the Amazon ECR registry
               in the ImageUri property.
                        
                Required: YesType: CodeUpdate requires: No interruptionCodeSigningConfigArn
                    To enable code signing for this function, specify the ARN of a code-signing configuration. A code-signing configuration
includes a set of signing profiles, which define the trusted publishers for this function.
                Required: NoType: StringPattern: arn:(aws[a-zA-Z-]*)?:lambda:[a-z]{2}((-gov)|(-iso([a-z]?)))?-[a-z]+-\d{1}:\d{12}:code-signing-config:csc-[a-z0-9]{17}Update requires: No interruptionDeadLetterConfig
                    A dead-letter queue configuration that specifies the queue or topic where Lambda sends asynchronous events
      when they fail processing. For more information, see Dead-letter queues.
                Required: NoType: DeadLetterConfigUpdate requires: No interruptionDescription
                    A description of the function.
                Required: NoType: StringMaximum: 256Update requires: No interruptionEnvironment
                    Environment variables that are accessible from function code during execution.
                Required: NoType: EnvironmentUpdate requires: No interruptionEphemeralStorage
                    The size of the function's /tmp directory in MB. The default value is 512,
          but it can be any whole number between 512 and 10,240 MB.
                Required: NoType: EphemeralStorageUpdate requires: No interruptionFileSystemConfigs
                    
                    Connection settings for an Amazon EFS file system. To connect a function to a file system, a mount target must be available 
      in every Availability Zone that your function connects to. If your template contains an 
      AWS::EFS::MountTarget resource, 
      you must also specify a DependsOn attribute to ensure that the mount target is created or updated before the function.
                    For more information about using the DependsOn attribute, see DependsOn Attribute.
    
                Required: NoType: Array of FileSystemConfigMaximum: 1Update requires: No interruptionFunctionName
                    The name of the Lambda function, up to 64 characters in length. If you don't specify a name, AWS CloudFormation 
        generates one.
                    If you specify a name, you cannot perform updates that require replacement of this resource. You can perform
      updates that require no or some interruption. If you must replace the resource, specify a new name.
                Required: NoType: StringMinimum: 1Update requires: ReplacementHandler
                    The name of the method within your code that Lambda calls to run your function. 
Handler is required if the deployment package is a .zip file archive. The format includes the
      file name. It can also include namespaces and other qualifiers, depending on the runtime. For more information,
      see Lambda programming model.
                Required: NoType: StringPattern: ^[^ ]+$Maximum: 128Update requires: No interruptionImageConfig
                    Configuration values that override the container image Dockerfile settings. For more information, see Container image
      settings.
                Required: NoType: ImageConfigUpdate requires: No interruptionKmsKeyArn
                    The ARN of the AWS Key Management Service (AWS KMS) customer managed key that's used to encrypt the following resources:
                    
                         
                         
                         
                         
                    
                            The function's environment variables.
                        
                            The function's Lambda SnapStart snapshots.
                        
                            When used with SourceKMSKeyArn, the unzipped version of the .zip deployment package that's used for function invocations. For more information, see 
               Specifying a customer managed key for Lambda.
                        
                            The optimized version of the container image that's used for function invocations. Note that this is not the same key that's used to protect your container image in the Amazon Elastic Container Registry (Amazon ECR). For more information, see Function lifecycle.
                        
                    If you don't provide a customer managed key, Lambda uses an AWS owned key or an AWS managed key.
                Required: NoType: StringPattern: ^(arn:(aws[a-zA-Z-]*)?:[a-z0-9-.]+:.*)|()$Update requires: No interruptionLayers
                    A list of function layers
      to add to the function's execution environment. Specify each layer by its ARN, including the version.
                Required: NoType: Array of StringUpdate requires: No interruptionLoggingConfig
                    The function's Amazon CloudWatch Logs configuration settings.
                Required: NoType: LoggingConfigUpdate requires: No interruptionMemorySize
                    The amount of memory available to the function at runtime.
           Increasing the function memory also increases its CPU allocation. The default value is 128 MB. The value can be any multiple of 1 MB. Note 
           that new AWS accounts have reduced concurrency and memory quotas. AWS raises these quotas automatically based on your 
           usage. You can also request a quota increase.
                Required: NoType: IntegerMinimum: 128Maximum: 10240Update requires: No interruptionPackageType
                    The type of deployment package. Set to Image for container image and set Zip for .zip file archive.
                Required: NoType: StringAllowed values: Image | ZipUpdate requires: ReplacementRecursiveLoop
                    The status of your function's recursive loop detection configuration.
                    When this value is set to Allowand Lambda detects your function being invoked as part of a recursive 
      loop, it doesn't take any action.
                    When this value is set to Terminate and Lambda detects your function being invoked as part of a recursive 
      loop, it stops your function being invoked and notifies you.
    
                Required: NoType: StringAllowed values: Allow | TerminateUpdate requires: No interruptionReservedConcurrentExecutions
                    The number of simultaneous executions to reserve for the function.
                Required: NoType: IntegerMinimum: 0Update requires: No interruptionRole
                    The Amazon Resource Name (ARN) of the function's execution role.
                Required: YesType: StringPattern: ^arn:(aws[a-zA-Z-]*)?:iam::\d{12}:role/?[a-zA-Z_0-9+=,.@\-_/]+$Update requires: No interruptionRuntime
                    The identifier of the function's 
          runtime. Runtime is required if the deployment package is a .zip file archive. Specifying a runtime results in
          an error if you're deploying a function using a container image.
                    The following list includes deprecated runtimes. Lambda blocks creating new functions and updating existing
          functions shortly after each runtime is deprecated. For more information, see
          Runtime use after deprecation.
                    For a list of all currently supported runtimes, see
          Supported runtimes.
                Required: NoType: StringAllowed values: nodejs | nodejs4.3 | nodejs6.10 | nodejs8.10 | nodejs10.x | nodejs12.x | nodejs14.x | nodejs16.x | java8 | java8.al2 | java11 | python2.7 | python3.6 | python3.7 | python3.8 | python3.9 | dotnetcore1.0 | dotnetcore2.0 | dotnetcore2.1 | dotnetcore3.1 | dotnet6 | dotnet8 | nodejs4.3-edge | go1.x | ruby2.5 | ruby2.7 | provided | provided.al2 | nodejs18.x | python3.10 | java17 | ruby3.2 | ruby3.3 | ruby3.4 | python3.11 | nodejs20.x | provided.al2023 | python3.12 | java21 | python3.13 | nodejs22.xUpdate requires: No interruptionRuntimeManagementConfig
                    Sets the runtime management configuration for a function's version. For more information, 
      see Runtime updates.
                Required: NoType: RuntimeManagementConfigUpdate requires: No interruptionSnapStart
                    The function's AWS Lambda SnapStart setting.
                Required: NoType: SnapStartUpdate requires: No interruptionTags
                    A list of tags to apply to the
      function.
                    NoteYou must have the lambda:TagResource, lambda:UntagResource,
            and lambda:ListTags permissions for your IAM principal to manage the AWS CloudFormation stack. If you
            don't have these permissions, there might be unexpected behavior with stack-level tags
            propagating to the resource during resource creation and update.
                Required: NoType: Array of TagUpdate requires: No interruptionTimeout
                    The amount of time (in seconds) that Lambda allows a function to run before stopping it. The default is 3 seconds. The
      maximum allowed value is 900 seconds. For more information, see Lambda execution environment.
                Required: NoType: IntegerMinimum: 1Update requires: No interruptionTracingConfig
                    Set Mode to Active to sample and trace a subset of incoming requests with
X-Ray.
                Required: NoType: TracingConfigUpdate requires: No interruptionVpcConfig
                    For network connectivity to AWS resources in a VPC, specify a list of security groups and subnets in the VPC.
      When you connect a function to a VPC, it can access resources and the internet only through that VPC. For more
      information, see Configuring a Lambda function to access resources in a VPC.
                Required: NoType: VpcConfigUpdate requires: No interruptionReturn valuesRefWhen you pass the logical ID of this resource to the intrinsic Ref function, Ref returns the resource name.For more information about using the Ref function, see Ref.Fn::GetAttThe Fn::GetAtt intrinsic function returns a value for a specified attribute of this type. The following are the available attributes and sample return values.
For more information about using the Fn::GetAtt intrinsic function, see Fn::GetAtt.Arn
                            The Amazon Resource Name (ARN) of the function.
                        SnapStartResponse.ApplyOnProperty description not available.SnapStartResponse.OptimizationStatusProperty description not available.Examples FunctionInline FunctionVPC Function
            
            FunctionCreate a Node.js function.JSON"AMIIDLookup": {
    "Type": "AWS::Lambda::Function",
    "Properties": {
        "Handler": "index.handler",
        "Role": {
            "Fn::GetAtt": [
                "LambdaExecutionRole",
                "Arn"
            ]
        },
        "Code": {
            "S3Bucket": "amzn-s3-demo-bucket",
            "S3Key": "amilookup.zip"
        },
        "Runtime": "nodejs20.x",
        "Timeout": 25,
        "TracingConfig": {
            "Mode": "Active"
        }
    }
}
            Inline FunctionInline Node.js function that lists Amazon S3 buckets in 
                            us-east-1
                        . Before using this example, make sure that your execution role has Amazon S3 read permissions.YAMLAWSTemplateFormatVersion: '2010-09-09'
Description: Lambda function ListBucketsCommand.
Resources:
  primer:
    Type: AWS::Lambda::Function
    Properties:
      Runtime: nodejs20.x
      Role: arn:aws:iam::111122223333:role/lambda-role
      Handler: index.handler
      Code:
        ZipFile: |
          const { S3Client, ListBucketsCommand } = require("@aws-sdk/client-s3");
          const s3 = new S3Client({ region: "us-east-1" }); // replace "us-east-1" with your AWS Region

          exports.handler = async function(event) {
            const command = new ListBucketsCommand({});
            const response = await s3.send(command);
            return response.Buckets;
          };
      Description: List Amazon S3 buckets in us-east-1.
      TracingConfig:
        Mode: Active
            VPC FunctionFunction connected to a VPC.YAMLAWSTemplateFormatVersion: '2010-09-09'
Description: VPC function.
Resources:
  Function:
    Type: AWS::Lambda::Function
    Properties:
      Handler: index.handler
      Role: arn:aws:iam::111122223333:role/lambda-role
      Code:
        S3Bucket: amzn-s3-demo-bucket
        S3Key: function.zip
      Runtime: nodejs20.x
      Timeout: 5
      TracingConfig:
        Mode: Active
      VpcConfig:
        SecurityGroupIds:
          - sg-085912345678492fb
        SubnetIds:
          - subnet-071f712345678e7c8
          - subnet-07fd123456788a036
        Document ConventionsTagCodeDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideAWS base images for Node.jsUsing an AWS base imageUsing a non-AWS base imageDeploy Node.js Lambda functions with container imagesThere are three ways to build a container image for a Node.js Lambda function:
     
	 
     
  
      Using an AWS base image for Node.js
      The AWS base images are preloaded with a language runtime, a runtime interface client to manage the interaction between Lambda and your function code, and a runtime interface emulator for local testing.
    
      Using an AWS OS-only base image
      AWS OS-only base images contain an Amazon Linux distribution and the runtime interface emulator. These images are commonly used to create container images for compiled languages, such as Go and Rust, and for a language or language version that Lambda doesn't provide a base image for, such as Node.js 19. You can also use OS-only base images to implement a custom runtime. To make the image compatible with Lambda, you must include the runtime interface client for Node.js in the image.
    
      Using a non-AWS base image
      You can use an alternative base image from another container registry, such as Alpine Linux or Debian. You can also use a custom image created by your organization. To make the image compatible with Lambda, you must include the runtime interface client for Node.js in the image.
    TipTo reduce the time it takes for Lambda container functions to become active, see Use multi-stage builds in the Docker documentation. To build efficient container images, follow the Best practices for writing Dockerfiles.This page explains how to build, test, and deploy container images for Lambda.TopicsAWS base images for Node.jsUsing an AWS base image for Node.jsUsing an alternative base image with the runtime interface client
    AWS base images for Node.js
    AWS provides the following base images for Node.js:
      
    
    
          
            Tags
            Runtime
            Operating system
            Dockerfile
            Deprecation
          
        
      
            22
            Node.js 22
            Amazon Linux 2023
            Dockerfile
                for Node.js 22 on GitHub
            
                          Apr 30, 2027
            
              
          
      
            20
            Node.js 20
            Amazon Linux 2023
            Dockerfile
                for Node.js 20 on GitHub
            
                          Apr 30, 2026
            
              
          
      
            18
            Node.js 18
            Amazon Linux 2
            Dockerfile
                for Node.js 18 on GitHub
            
                          Sep 1, 2025
            
              
          
    

    Amazon ECR repository: gallery.ecr.aws/lambda/nodejs
    The Node.js 20 and later base images are based on the Amazon Linux 2023 minimal container image. Earlier base
      images use Amazon Linux 2. AL2023 provides several advantages over Amazon Linux 2, including a smaller deployment footprint
      and updated versions of libraries such as glibc.
    AL2023-based images use microdnf (symlinked as dnf) as the package manager instead of yum, which is the default package manager in Amazon Linux 2. microdnf is a standalone implementation of dnf. For a list of packages that are included in AL2023-based images, refer to the Minimal Container columns in Comparing packages installed on Amazon Linux 2023 Container Images. For more information about the differences between AL2023 and Amazon Linux 2, see Introducing the Amazon Linux 2023 runtime for AWS Lambda on the AWS
      Compute Blog.    
    NoteTo run AL2023-based images locally, including with AWS Serverless Application Model (AWS SAM), you must use Docker version 20.10.10 or later.  
   
    Using an AWS base image for Node.js
    To complete the steps in this section, you must have the following:
           
           
           
           
        
            AWS CLI version 2
          
            Docker (minimum version 25.0.0)
          
            The Docker buildx plugin.
          
              Node.js
          To create a container image from an AWS base image for Node.js
        Create a directory for the project, and then switch to that directory.
        mkdir example
cd example
      
        Create a new Node.js project with npm. To accept the default options provided in the interactive experience, press Enter.
        npm init
      
        Create a new file called index.js. You can add the following sample function code to the file for testing, or use your own.
        Example  CommonJS handlerexports.handler = async (event) => {
    const response = {
        statusCode: 200,
        body: JSON.stringify('Hello from Lambda!'),
    };
    return response;
};
      
        If your function depends on libraries other than the AWS SDK for JavaScript, use npm to add them to your package.
      
        Create a new Dockerfile with the following configuration:
        
           
           
           
        
            Set the FROM property to the URI of the base image.
          
            Use the COPY command to copy the function code and runtime dependencies to {LAMBDA_TASK_ROOT}, a Lambda-defined environment variable.
          
            Set the CMD argument to the Lambda function handler.
          
        Note that the example Dockerfile does not include a USER instruction. When you deploy a container image to Lambda, Lambda automatically defines a default Linux user with least-privileged permissions. This is different from standard Docker behavior which defaults to the root user when no USER instruction is provided.
        Example  DockerfileFROM public.ecr.aws/lambda/nodejs:22

# Copy function code
COPY index.js ${LAMBDA_TASK_ROOT}
  
# Set the CMD to your handler (could also be done as a parameter override outside of the Dockerfile)
CMD [ "index.handler" ]
      
        Build the Docker image with the docker build command. The
          following example names the image docker-image and gives it the test tag. To make your 
          image compatible with Lambda, you must use the --provenance=false option.
        docker buildx build --platform linux/amd64 --provenance=false -t docker-image:test .
        NoteThe command specifies the --platform linux/amd64 option to ensure that your container is compatible with the Lambda execution environment regardless of the  
       architecture of your build machine. If you intend to create a Lambda function using the ARM64 instruction set architecture, be sure to change the command to use the --platform linux/arm64 
       option instead.
      
          Start the Docker image with the docker run command. In this example,
              docker-image is the image name and test is the tag.
          docker run --platform linux/amd64 -p 9000:8080 docker-image:test
          This command runs the image as a container and creates a local endpoint at
            localhost:9000/2015-03-31/functions/function/invocations.
          NoteIf you built the Docker image for the ARM64 instruction set architecture, be sure to use the --platform linux/arm64 option instead of --platform linux/amd64. 
        
          From a new terminal window, post an event to the local endpoint.
          
            Linux/macOS
      		      In Linux and macOS, run the following curl command:
                curl "http://localhost:9000/2015-03-31/functions/function/invocations" -d '{}'
                This command invokes the function with an empty event and returns a response. If you're using your own function code rather than the sample function code, you might want to invoke the function with a JSON payload. Example:
                curl "http://localhost:9000/2015-03-31/functions/function/invocations" -d '{"payload":"hello world!"}'
      		
            PowerShell
                In PowerShell, run the following Invoke-WebRequest command:
                Invoke-WebRequest -Uri "http://localhost:9000/2015-03-31/functions/function/invocations" -Method Post -Body '{}' -ContentType "application/json"
                This command invokes the function with an empty event and returns a response. If you're using your own function code rather than the sample function code, you might want to invoke the function with a JSON payload. Example:
                Invoke-WebRequest -Uri "http://localhost:9000/2015-03-31/functions/function/invocations" -Method Post -Body '{"payload":"hello world!"}' -ContentType "application/json"
              
          
        
          Get the container ID.
          docker ps
        
          Use the docker kill command to stop the container. In this command, replace 3766c4ab331c with the container ID from the previous step.
          docker kill 3766c4ab331c
        To upload the image to Amazon ECR and create the Lambda function
          Run the get-login-password command to authenticate the Docker CLI to your Amazon ECR registry.
        
         
         
        
          Set the --region value to the AWS Region where you want to create the Amazon ECR repository.
        
          Replace 111122223333 with your AWS account ID.
        
          aws ecr get-login-password --region us-east-1 | docker login --username AWS --password-stdin 111122223333.dkr.ecr.us-east-1.amazonaws.com
          
        
        Create a repository in Amazon ECR using the create-repository command.
        aws ecr create-repository --repository-name hello-world --region us-east-1 --image-scanning-configuration scanOnPush=true --image-tag-mutability MUTABLE
        
        NoteThe Amazon ECR repository must be in the same AWS Region as the Lambda function.
        If successful, you see a response like this:
        {
    "repository": {
        "repositoryArn": "arn:aws:ecr:us-east-1:111122223333:repository/hello-world",
        "registryId": "111122223333",
        "repositoryName": "hello-world",
        "repositoryUri": "111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world",
        "createdAt": "2023-03-09T10:39:01+00:00",
        "imageTagMutability": "MUTABLE",
        "imageScanningConfiguration": {
            "scanOnPush": true
        },
        "encryptionConfiguration": {
            "encryptionType": "AES256"
        }
    }
}
        
      
        Copy the repositoryUri from the output in the previous step.
      
        Run the docker tag command to tag your local image into your Amazon ECR repository as the latest version. In this command: 
        
         
         
        
          docker-image:test is the name and tag of your Docker image. This is the image name and tag that you specified in the docker build command.
        
          Replace <ECRrepositoryUri> with the repositoryUri that you copied. Make sure to include :latest at the end of the URI.
        
        docker tag docker-image:test <ECRrepositoryUri>:latest
      Example:
      docker tag docker-image:test 111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest
      
      
      Run the docker push command to deploy your local image to the Amazon ECR repository. Make sure to include :latest at the end of the repository URI.
docker push 111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest

      
      Create an execution role for the function, if you don't already have one. You need the Amazon Resource Name (ARN) of the role in the next step.
      
        Create the Lambda function. For ImageUri, specify the repository URI from earlier. Make sure to include :latest at the end of the URI.
		aws lambda create-function \
  --function-name hello-world \
  --package-type Image \
  --code ImageUri=111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest \
  --role arn:aws:iam::111122223333:role/lambda-ex
  		
      NoteYou can create a function using an image in a different AWS account, as long as the image is in the same Region as the Lambda function. For more information, see  Amazon ECR cross-account permissions.  
      
      Invoke the function.
      aws lambda invoke --function-name hello-world response.json
      You should see a response like this:
{
  "ExecutedVersion": "$LATEST", 
  "StatusCode": 200
}
    
    To see the output of the function, check the response.json file.
    To update the function code, you must build the image again, upload the new image to the Amazon ECR repository, and then use the update-function-code command to deploy the image to the Lambda function.Lambda resolves the image tag to a specific image digest. This means that if you point the image tag that was used to deploy the function to a new image in Amazon ECR, Lambda doesn't automatically update the function to use the new image.To deploy the new image to the same Lambda function, you must use the update-function-code command, even if the image tag in Amazon ECR remains the same. In the following example, the --publish option creates a new version of the function using the updated container image.aws lambda update-function-code \
  --function-name hello-world \
  --image-uri 111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest \
  --publish
 
    Using an alternative base image with the runtime interface client
    If you use an OS-only base image or an alternative base image, you must include the runtime interface client in your image. The runtime interface client extends the Runtime API, which manages the interaction between Lambda and your function code.
    Install the Node.js runtime interface client using the npm package manager:
    npm install aws-lambda-ric
    You can also download the Node.js runtime interface client from GitHub. 
    The following example demonstrates how to build a container image for Node.js using a non-AWS base image. The example Dockerfile uses a buster base image. The Dockerfile includes the runtime interface client.
        To complete the steps in this section, you must have the following:
           
           
           
           
        
            AWS CLI version 2
          
            Docker (minimum version 25.0.0)
          
            The Docker buildx plugin.
          
              Node.js
          To create a container image from a non-AWS base image
        Create a directory for the project, and then switch to that directory.
        mkdir example
cd example
      
        Create a new Node.js project with npm. To accept the default options provided in the interactive experience, press Enter.
        npm init
      
        Create a new file called index.js. You can add the following sample function code to the file for testing, or use your own.
        Example  CommonJS handlerexports.handler = async (event) => {
    const response = {
        statusCode: 200,
        body: JSON.stringify('Hello from Lambda!'),
    };
    return response;
};
      
        Create a new Dockerfile. The following Dockerfile uses a buster base image instead of an AWS base image. The Dockerfile includes the runtime interface client, which makes the image compatible with Lambda. The Dockerfile uses a multi-stage build. The first stage creates a build image, which is a standard Node.js environment where the function's dependencies are installed. The second stage creates a slimmer image which includes the function code and its dependencies. This reduces the final image size.
        
           
           
          
           
        
            Set the FROM property to the base image identifier.
          
            Use the COPY command to copy the function code and runtime dependencies.
          
            Set the ENTRYPOINT to the module that you want the Docker container to run when it starts. In this case, the module is the runtime interface client.
          
            Set the CMD argument to the Lambda function handler.
          
        Note that the example Dockerfile does not include a USER instruction. When you deploy a container image to Lambda, Lambda automatically defines a default Linux user with least-privileged permissions. This is different from standard Docker behavior which defaults to the root user when no USER instruction is provided.
        Example  Dockerfile# Define custom function directory
ARG FUNCTION_DIR="/function"

FROM node:20-buster as build-image

# Include global arg in this stage of the build
ARG FUNCTION_DIR

# Install build dependencies
RUN apt-get update && \
    apt-get install -y \
    g++ \
    make \
    cmake \
    unzip \
    libcurl4-openssl-dev

# Copy function code
RUN mkdir -p ${FUNCTION_DIR}
COPY . ${FUNCTION_DIR}

WORKDIR ${FUNCTION_DIR}

# Install Node.js dependencies
RUN npm install

# Install the runtime interface client
RUN npm install aws-lambda-ric

# Grab a fresh slim copy of the image to reduce the final size
FROM node:20-buster-slim

# Required for Node runtimes which use npm@8.6.0+ because
# by default npm writes logs under /home/.npm and Lambda fs is read-only
ENV NPM_CONFIG_CACHE=/tmp/.npm

# Include global arg in this stage of the build
ARG FUNCTION_DIR

# Set working directory to function root directory
WORKDIR ${FUNCTION_DIR}

# Copy in the built dependencies
COPY --from=build-image ${FUNCTION_DIR} ${FUNCTION_DIR}

# Set runtime interface client as default command for the container runtime
ENTRYPOINT ["/usr/local/bin/npx", "aws-lambda-ric"]
# Pass the name of the function handler as an argument to the runtime
CMD ["index.handler"]
      
        Build the Docker image with the docker build command. The
          following example names the image docker-image and gives it the test tag. To make your 
          image compatible with Lambda, you must use the --provenance=false option.
        docker buildx build --platform linux/amd64 --provenance=false -t docker-image:test .
        NoteThe command specifies the --platform linux/amd64 option to ensure that your container is compatible with the Lambda execution environment regardless of the  
       architecture of your build machine. If you intend to create a Lambda function using the ARM64 instruction set architecture, be sure to change the command to use the --platform linux/arm64 
       option instead.
      Use the runtime interface emulator to locally test the image. You can build the emulator into your image or use the following procedure to install it on your local machine.To install and run the runtime interface emulator on your local machine
          From your project directory, run the following command to download the runtime interface emulator (x86-64 architecture) from GitHub and install it on your local machine.
          
            Linux/macOS
          mkdir -p ~/.aws-lambda-rie && \
    curl -Lo ~/.aws-lambda-rie/aws-lambda-rie https://github.com/aws/aws-lambda-runtime-interface-emulator/releases/latest/download/aws-lambda-rie && \
    chmod +x ~/.aws-lambda-rie/aws-lambda-rie
      			  To install the arm64 emulator, replace the GitHub repository URL in the previous command with the following:
      			https://github.com/aws/aws-lambda-runtime-interface-emulator/releases/latest/download/aws-lambda-rie-arm64
      		
            PowerShell
      				  $dirPath = "$HOME\.aws-lambda-rie"
if (-not (Test-Path $dirPath)) {
    New-Item -Path $dirPath -ItemType Directory
}
      
$downloadLink = "https://github.com/aws/aws-lambda-runtime-interface-emulator/releases/latest/download/aws-lambda-rie"
$destinationPath = "$HOME\.aws-lambda-rie\aws-lambda-rie"
Invoke-WebRequest -Uri $downloadLink -OutFile $destinationPath
      				  To install the arm64 emulator, replace the $downloadLink with the following:
      				https://github.com/aws/aws-lambda-runtime-interface-emulator/releases/latest/download/aws-lambda-rie-arm64
              
          
        
          Start the Docker image with the docker run command. Note the following:
          
             
             
          
            docker-image is the image name and test is the tag.
            
            /usr/local/bin/npx aws-lambda-ric index.handler is the ENTRYPOINT followed by the CMD from your Dockerfile.
            
          
            Linux/macOS
				    docker run --platform linux/amd64 -d -v ~/.aws-lambda-rie:/aws-lambda -p 9000:8080 \
    --entrypoint /aws-lambda/aws-lambda-rie \
    docker-image:test \
        /usr/local/bin/npx aws-lambda-ric index.handler
      		
            PowerShell
				        docker run --platform linux/amd64 -d -v "$HOME\.aws-lambda-rie:/aws-lambda" -p 9000:8080 `
--entrypoint /aws-lambda/aws-lambda-rie `
docker-image:test `
    /usr/local/bin/npx aws-lambda-ric index.handler
				    
          
          This command runs the image as a container and creates a local endpoint at
            localhost:9000/2015-03-31/functions/function/invocations.
         NoteIf you built the Docker image for the ARM64 instruction set architecture, be sure to use the --platform linux/arm64 option instead of --platform linux/amd64.   
        
          Post an event to the local endpoint.
          
            Linux/macOS
      		      In Linux and macOS, run the following curl command:
                curl "http://localhost:9000/2015-03-31/functions/function/invocations" -d '{}'
                This command invokes the function with an empty event and returns a response. If you're using your own function code rather than the sample function code, you might want to invoke the function with a JSON payload. Example:
                curl "http://localhost:9000/2015-03-31/functions/function/invocations" -d '{"payload":"hello world!"}'
      		
            PowerShell
                In PowerShell, run the following Invoke-WebRequest command:
                Invoke-WebRequest -Uri "http://localhost:9000/2015-03-31/functions/function/invocations" -Method Post -Body '{}' -ContentType "application/json"
                This command invokes the function with an empty event and returns a response. If you're using your own function code rather than the sample function code, you might want to invoke the function with a JSON payload. Example:
                Invoke-WebRequest -Uri "http://localhost:9000/2015-03-31/functions/function/invocations" -Method Post -Body '{"payload":"hello world!"}' -ContentType "application/json"
              
          
        
          Get the container ID.
          docker ps
        
          Use the docker kill command to stop the container. In this command, replace 3766c4ab331c with the container ID from the previous step.
          docker kill 3766c4ab331c
        To upload the image to Amazon ECR and create the Lambda function
          Run the get-login-password command to authenticate the Docker CLI to your Amazon ECR registry.
        
         
         
        
          Set the --region value to the AWS Region where you want to create the Amazon ECR repository.
        
          Replace 111122223333 with your AWS account ID.
        
          aws ecr get-login-password --region us-east-1 | docker login --username AWS --password-stdin 111122223333.dkr.ecr.us-east-1.amazonaws.com
          
        
        Create a repository in Amazon ECR using the create-repository command.
        aws ecr create-repository --repository-name hello-world --region us-east-1 --image-scanning-configuration scanOnPush=true --image-tag-mutability MUTABLE
        
        NoteThe Amazon ECR repository must be in the same AWS Region as the Lambda function.
        If successful, you see a response like this:
        {
    "repository": {
        "repositoryArn": "arn:aws:ecr:us-east-1:111122223333:repository/hello-world",
        "registryId": "111122223333",
        "repositoryName": "hello-world",
        "repositoryUri": "111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world",
        "createdAt": "2023-03-09T10:39:01+00:00",
        "imageTagMutability": "MUTABLE",
        "imageScanningConfiguration": {
            "scanOnPush": true
        },
        "encryptionConfiguration": {
            "encryptionType": "AES256"
        }
    }
}
        
      
        Copy the repositoryUri from the output in the previous step.
      
        Run the docker tag command to tag your local image into your Amazon ECR repository as the latest version. In this command: 
        
         
         
        
          docker-image:test is the name and tag of your Docker image. This is the image name and tag that you specified in the docker build command.
        
          Replace <ECRrepositoryUri> with the repositoryUri that you copied. Make sure to include :latest at the end of the URI.
        
        docker tag docker-image:test <ECRrepositoryUri>:latest
      Example:
      docker tag docker-image:test 111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest
      
      
      Run the docker push command to deploy your local image to the Amazon ECR repository. Make sure to include :latest at the end of the repository URI.
docker push 111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest

      
      Create an execution role for the function, if you don't already have one. You need the Amazon Resource Name (ARN) of the role in the next step.
      
        Create the Lambda function. For ImageUri, specify the repository URI from earlier. Make sure to include :latest at the end of the URI.
		aws lambda create-function \
  --function-name hello-world \
  --package-type Image \
  --code ImageUri=111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest \
  --role arn:aws:iam::111122223333:role/lambda-ex
  		
      NoteYou can create a function using an image in a different AWS account, as long as the image is in the same Region as the Lambda function. For more information, see  Amazon ECR cross-account permissions.  
      
      Invoke the function.
      aws lambda invoke --function-name hello-world response.json
      You should see a response like this:
{
  "ExecutedVersion": "$LATEST", 
  "StatusCode": 200
}
    
    To see the output of the function, check the response.json file.
    To update the function code, you must build the image again, upload the new image to the Amazon ECR repository, and then use the update-function-code command to deploy the image to the Lambda function.Lambda resolves the image tag to a specific image digest. This means that if you point the image tag that was used to deploy the function to a new image in Amazon ECR, Lambda doesn't automatically update the function to use the new image.To deploy the new image to the same Lambda function, you must use the update-function-code command, even if the image tag in Amazon ECR remains the same. In the following example, the --publish option creates a new version of the function using the updated container image.aws lambda update-function-code \
  --function-name hello-world \
  --image-uri 111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest \
  --publish
  Document ConventionsDeploy .zip file archivesLayersDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideAWS base images for Node.jsUsing an AWS base imageUsing a non-AWS base imageDeploy Node.js Lambda functions with container imagesThere are three ways to build a container image for a Node.js Lambda function:
     
	 
     
  
      Using an AWS base image for Node.js
      The AWS base images are preloaded with a language runtime, a runtime interface client to manage the interaction between Lambda and your function code, and a runtime interface emulator for local testing.
    
      Using an AWS OS-only base image
      AWS OS-only base images contain an Amazon Linux distribution and the runtime interface emulator. These images are commonly used to create container images for compiled languages, such as Go and Rust, and for a language or language version that Lambda doesn't provide a base image for, such as Node.js 19. You can also use OS-only base images to implement a custom runtime. To make the image compatible with Lambda, you must include the runtime interface client for Node.js in the image.
    
      Using a non-AWS base image
      You can use an alternative base image from another container registry, such as Alpine Linux or Debian. You can also use a custom image created by your organization. To make the image compatible with Lambda, you must include the runtime interface client for Node.js in the image.
    TipTo reduce the time it takes for Lambda container functions to become active, see Use multi-stage builds in the Docker documentation. To build efficient container images, follow the Best practices for writing Dockerfiles.This page explains how to build, test, and deploy container images for Lambda.TopicsAWS base images for Node.jsUsing an AWS base image for Node.jsUsing an alternative base image with the runtime interface client
    AWS base images for Node.js
    AWS provides the following base images for Node.js:
      
    
    
          
            Tags
            Runtime
            Operating system
            Dockerfile
            Deprecation
          
        
      
            22
            Node.js 22
            Amazon Linux 2023
            Dockerfile
                for Node.js 22 on GitHub
            
                          Apr 30, 2027
            
              
          
      
            20
            Node.js 20
            Amazon Linux 2023
            Dockerfile
                for Node.js 20 on GitHub
            
                          Apr 30, 2026
            
              
          
      
            18
            Node.js 18
            Amazon Linux 2
            Dockerfile
                for Node.js 18 on GitHub
            
                          Sep 1, 2025
            
              
          
    

    Amazon ECR repository: gallery.ecr.aws/lambda/nodejs
    The Node.js 20 and later base images are based on the Amazon Linux 2023 minimal container image. Earlier base
      images use Amazon Linux 2. AL2023 provides several advantages over Amazon Linux 2, including a smaller deployment footprint
      and updated versions of libraries such as glibc.
    AL2023-based images use microdnf (symlinked as dnf) as the package manager instead of yum, which is the default package manager in Amazon Linux 2. microdnf is a standalone implementation of dnf. For a list of packages that are included in AL2023-based images, refer to the Minimal Container columns in Comparing packages installed on Amazon Linux 2023 Container Images. For more information about the differences between AL2023 and Amazon Linux 2, see Introducing the Amazon Linux 2023 runtime for AWS Lambda on the AWS
      Compute Blog.    
    NoteTo run AL2023-based images locally, including with AWS Serverless Application Model (AWS SAM), you must use Docker version 20.10.10 or later.  
   
    Using an AWS base image for Node.js
    To complete the steps in this section, you must have the following:
           
           
           
           
        
            AWS CLI version 2
          
            Docker (minimum version 25.0.0)
          
            The Docker buildx plugin.
          
              Node.js
          To create a container image from an AWS base image for Node.js
        Create a directory for the project, and then switch to that directory.
        mkdir example
cd example
      
        Create a new Node.js project with npm. To accept the default options provided in the interactive experience, press Enter.
        npm init
      
        Create a new file called index.js. You can add the following sample function code to the file for testing, or use your own.
        Example  CommonJS handlerexports.handler = async (event) => {
    const response = {
        statusCode: 200,
        body: JSON.stringify('Hello from Lambda!'),
    };
    return response;
};
      
        If your function depends on libraries other than the AWS SDK for JavaScript, use npm to add them to your package.
      
        Create a new Dockerfile with the following configuration:
        
           
           
           
        
            Set the FROM property to the URI of the base image.
          
            Use the COPY command to copy the function code and runtime dependencies to {LAMBDA_TASK_ROOT}, a Lambda-defined environment variable.
          
            Set the CMD argument to the Lambda function handler.
          
        Note that the example Dockerfile does not include a USER instruction. When you deploy a container image to Lambda, Lambda automatically defines a default Linux user with least-privileged permissions. This is different from standard Docker behavior which defaults to the root user when no USER instruction is provided.
        Example  DockerfileFROM public.ecr.aws/lambda/nodejs:22

# Copy function code
COPY index.js ${LAMBDA_TASK_ROOT}
  
# Set the CMD to your handler (could also be done as a parameter override outside of the Dockerfile)
CMD [ "index.handler" ]
      
        Build the Docker image with the docker build command. The
          following example names the image docker-image and gives it the test tag. To make your 
          image compatible with Lambda, you must use the --provenance=false option.
        docker buildx build --platform linux/amd64 --provenance=false -t docker-image:test .
        NoteThe command specifies the --platform linux/amd64 option to ensure that your container is compatible with the Lambda execution environment regardless of the  
       architecture of your build machine. If you intend to create a Lambda function using the ARM64 instruction set architecture, be sure to change the command to use the --platform linux/arm64 
       option instead.
      
          Start the Docker image with the docker run command. In this example,
              docker-image is the image name and test is the tag.
          docker run --platform linux/amd64 -p 9000:8080 docker-image:test
          This command runs the image as a container and creates a local endpoint at
            localhost:9000/2015-03-31/functions/function/invocations.
          NoteIf you built the Docker image for the ARM64 instruction set architecture, be sure to use the --platform linux/arm64 option instead of --platform linux/amd64. 
        
          From a new terminal window, post an event to the local endpoint.
          
            Linux/macOS
      		      In Linux and macOS, run the following curl command:
                curl "http://localhost:9000/2015-03-31/functions/function/invocations" -d '{}'
                This command invokes the function with an empty event and returns a response. If you're using your own function code rather than the sample function code, you might want to invoke the function with a JSON payload. Example:
                curl "http://localhost:9000/2015-03-31/functions/function/invocations" -d '{"payload":"hello world!"}'
      		
            PowerShell
                In PowerShell, run the following Invoke-WebRequest command:
                Invoke-WebRequest -Uri "http://localhost:9000/2015-03-31/functions/function/invocations" -Method Post -Body '{}' -ContentType "application/json"
                This command invokes the function with an empty event and returns a response. If you're using your own function code rather than the sample function code, you might want to invoke the function with a JSON payload. Example:
                Invoke-WebRequest -Uri "http://localhost:9000/2015-03-31/functions/function/invocations" -Method Post -Body '{"payload":"hello world!"}' -ContentType "application/json"
              
          
        
          Get the container ID.
          docker ps
        
          Use the docker kill command to stop the container. In this command, replace 3766c4ab331c with the container ID from the previous step.
          docker kill 3766c4ab331c
        To upload the image to Amazon ECR and create the Lambda function
          Run the get-login-password command to authenticate the Docker CLI to your Amazon ECR registry.
        
         
         
        
          Set the --region value to the AWS Region where you want to create the Amazon ECR repository.
        
          Replace 111122223333 with your AWS account ID.
        
          aws ecr get-login-password --region us-east-1 | docker login --username AWS --password-stdin 111122223333.dkr.ecr.us-east-1.amazonaws.com
          
        
        Create a repository in Amazon ECR using the create-repository command.
        aws ecr create-repository --repository-name hello-world --region us-east-1 --image-scanning-configuration scanOnPush=true --image-tag-mutability MUTABLE
        
        NoteThe Amazon ECR repository must be in the same AWS Region as the Lambda function.
        If successful, you see a response like this:
        {
    "repository": {
        "repositoryArn": "arn:aws:ecr:us-east-1:111122223333:repository/hello-world",
        "registryId": "111122223333",
        "repositoryName": "hello-world",
        "repositoryUri": "111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world",
        "createdAt": "2023-03-09T10:39:01+00:00",
        "imageTagMutability": "MUTABLE",
        "imageScanningConfiguration": {
            "scanOnPush": true
        },
        "encryptionConfiguration": {
            "encryptionType": "AES256"
        }
    }
}
        
      
        Copy the repositoryUri from the output in the previous step.
      
        Run the docker tag command to tag your local image into your Amazon ECR repository as the latest version. In this command: 
        
         
         
        
          docker-image:test is the name and tag of your Docker image. This is the image name and tag that you specified in the docker build command.
        
          Replace <ECRrepositoryUri> with the repositoryUri that you copied. Make sure to include :latest at the end of the URI.
        
        docker tag docker-image:test <ECRrepositoryUri>:latest
      Example:
      docker tag docker-image:test 111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest
      
      
      Run the docker push command to deploy your local image to the Amazon ECR repository. Make sure to include :latest at the end of the repository URI.
docker push 111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest

      
      Create an execution role for the function, if you don't already have one. You need the Amazon Resource Name (ARN) of the role in the next step.
      
        Create the Lambda function. For ImageUri, specify the repository URI from earlier. Make sure to include :latest at the end of the URI.
		aws lambda create-function \
  --function-name hello-world \
  --package-type Image \
  --code ImageUri=111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest \
  --role arn:aws:iam::111122223333:role/lambda-ex
  		
      NoteYou can create a function using an image in a different AWS account, as long as the image is in the same Region as the Lambda function. For more information, see  Amazon ECR cross-account permissions.  
      
      Invoke the function.
      aws lambda invoke --function-name hello-world response.json
      You should see a response like this:
{
  "ExecutedVersion": "$LATEST", 
  "StatusCode": 200
}
    
    To see the output of the function, check the response.json file.
    To update the function code, you must build the image again, upload the new image to the Amazon ECR repository, and then use the update-function-code command to deploy the image to the Lambda function.Lambda resolves the image tag to a specific image digest. This means that if you point the image tag that was used to deploy the function to a new image in Amazon ECR, Lambda doesn't automatically update the function to use the new image.To deploy the new image to the same Lambda function, you must use the update-function-code command, even if the image tag in Amazon ECR remains the same. In the following example, the --publish option creates a new version of the function using the updated container image.aws lambda update-function-code \
  --function-name hello-world \
  --image-uri 111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest \
  --publish
 
    Using an alternative base image with the runtime interface client
    If you use an OS-only base image or an alternative base image, you must include the runtime interface client in your image. The runtime interface client extends the Runtime API, which manages the interaction between Lambda and your function code.
    Install the Node.js runtime interface client using the npm package manager:
    npm install aws-lambda-ric
    You can also download the Node.js runtime interface client from GitHub. 
    The following example demonstrates how to build a container image for Node.js using a non-AWS base image. The example Dockerfile uses a buster base image. The Dockerfile includes the runtime interface client.
        To complete the steps in this section, you must have the following:
           
           
           
           
        
            AWS CLI version 2
          
            Docker (minimum version 25.0.0)
          
            The Docker buildx plugin.
          
              Node.js
          To create a container image from a non-AWS base image
        Create a directory for the project, and then switch to that directory.
        mkdir example
cd example
      
        Create a new Node.js project with npm. To accept the default options provided in the interactive experience, press Enter.
        npm init
      
        Create a new file called index.js. You can add the following sample function code to the file for testing, or use your own.
        Example  CommonJS handlerexports.handler = async (event) => {
    const response = {
        statusCode: 200,
        body: JSON.stringify('Hello from Lambda!'),
    };
    return response;
};
      
        Create a new Dockerfile. The following Dockerfile uses a buster base image instead of an AWS base image. The Dockerfile includes the runtime interface client, which makes the image compatible with Lambda. The Dockerfile uses a multi-stage build. The first stage creates a build image, which is a standard Node.js environment where the function's dependencies are installed. The second stage creates a slimmer image which includes the function code and its dependencies. This reduces the final image size.
        
           
           
          
           
        
            Set the FROM property to the base image identifier.
          
            Use the COPY command to copy the function code and runtime dependencies.
          
            Set the ENTRYPOINT to the module that you want the Docker container to run when it starts. In this case, the module is the runtime interface client.
          
            Set the CMD argument to the Lambda function handler.
          
        Note that the example Dockerfile does not include a USER instruction. When you deploy a container image to Lambda, Lambda automatically defines a default Linux user with least-privileged permissions. This is different from standard Docker behavior which defaults to the root user when no USER instruction is provided.
        Example  Dockerfile# Define custom function directory
ARG FUNCTION_DIR="/function"

FROM node:20-buster as build-image

# Include global arg in this stage of the build
ARG FUNCTION_DIR

# Install build dependencies
RUN apt-get update && \
    apt-get install -y \
    g++ \
    make \
    cmake \
    unzip \
    libcurl4-openssl-dev

# Copy function code
RUN mkdir -p ${FUNCTION_DIR}
COPY . ${FUNCTION_DIR}

WORKDIR ${FUNCTION_DIR}

# Install Node.js dependencies
RUN npm install

# Install the runtime interface client
RUN npm install aws-lambda-ric

# Grab a fresh slim copy of the image to reduce the final size
FROM node:20-buster-slim

# Required for Node runtimes which use npm@8.6.0+ because
# by default npm writes logs under /home/.npm and Lambda fs is read-only
ENV NPM_CONFIG_CACHE=/tmp/.npm

# Include global arg in this stage of the build
ARG FUNCTION_DIR

# Set working directory to function root directory
WORKDIR ${FUNCTION_DIR}

# Copy in the built dependencies
COPY --from=build-image ${FUNCTION_DIR} ${FUNCTION_DIR}

# Set runtime interface client as default command for the container runtime
ENTRYPOINT ["/usr/local/bin/npx", "aws-lambda-ric"]
# Pass the name of the function handler as an argument to the runtime
CMD ["index.handler"]
      
        Build the Docker image with the docker build command. The
          following example names the image docker-image and gives it the test tag. To make your 
          image compatible with Lambda, you must use the --provenance=false option.
        docker buildx build --platform linux/amd64 --provenance=false -t docker-image:test .
        NoteThe command specifies the --platform linux/amd64 option to ensure that your container is compatible with the Lambda execution environment regardless of the  
       architecture of your build machine. If you intend to create a Lambda function using the ARM64 instruction set architecture, be sure to change the command to use the --platform linux/arm64 
       option instead.
      Use the runtime interface emulator to locally test the image. You can build the emulator into your image or use the following procedure to install it on your local machine.To install and run the runtime interface emulator on your local machine
          From your project directory, run the following command to download the runtime interface emulator (x86-64 architecture) from GitHub and install it on your local machine.
          
            Linux/macOS
          mkdir -p ~/.aws-lambda-rie && \
    curl -Lo ~/.aws-lambda-rie/aws-lambda-rie https://github.com/aws/aws-lambda-runtime-interface-emulator/releases/latest/download/aws-lambda-rie && \
    chmod +x ~/.aws-lambda-rie/aws-lambda-rie
      			  To install the arm64 emulator, replace the GitHub repository URL in the previous command with the following:
      			https://github.com/aws/aws-lambda-runtime-interface-emulator/releases/latest/download/aws-lambda-rie-arm64
      		
            PowerShell
      				  $dirPath = "$HOME\.aws-lambda-rie"
if (-not (Test-Path $dirPath)) {
    New-Item -Path $dirPath -ItemType Directory
}
      
$downloadLink = "https://github.com/aws/aws-lambda-runtime-interface-emulator/releases/latest/download/aws-lambda-rie"
$destinationPath = "$HOME\.aws-lambda-rie\aws-lambda-rie"
Invoke-WebRequest -Uri $downloadLink -OutFile $destinationPath
      				  To install the arm64 emulator, replace the $downloadLink with the following:
      				https://github.com/aws/aws-lambda-runtime-interface-emulator/releases/latest/download/aws-lambda-rie-arm64
              
          
        
          Start the Docker image with the docker run command. Note the following:
          
             
             
          
            docker-image is the image name and test is the tag.
            
            /usr/local/bin/npx aws-lambda-ric index.handler is the ENTRYPOINT followed by the CMD from your Dockerfile.
            
          
            Linux/macOS
				    docker run --platform linux/amd64 -d -v ~/.aws-lambda-rie:/aws-lambda -p 9000:8080 \
    --entrypoint /aws-lambda/aws-lambda-rie \
    docker-image:test \
        /usr/local/bin/npx aws-lambda-ric index.handler
      		
            PowerShell
				        docker run --platform linux/amd64 -d -v "$HOME\.aws-lambda-rie:/aws-lambda" -p 9000:8080 `
--entrypoint /aws-lambda/aws-lambda-rie `
docker-image:test `
    /usr/local/bin/npx aws-lambda-ric index.handler
				    
          
          This command runs the image as a container and creates a local endpoint at
            localhost:9000/2015-03-31/functions/function/invocations.
         NoteIf you built the Docker image for the ARM64 instruction set architecture, be sure to use the --platform linux/arm64 option instead of --platform linux/amd64.   
        
          Post an event to the local endpoint.
          
            Linux/macOS
      		      In Linux and macOS, run the following curl command:
                curl "http://localhost:9000/2015-03-31/functions/function/invocations" -d '{}'
                This command invokes the function with an empty event and returns a response. If you're using your own function code rather than the sample function code, you might want to invoke the function with a JSON payload. Example:
                curl "http://localhost:9000/2015-03-31/functions/function/invocations" -d '{"payload":"hello world!"}'
      		
            PowerShell
                In PowerShell, run the following Invoke-WebRequest command:
                Invoke-WebRequest -Uri "http://localhost:9000/2015-03-31/functions/function/invocations" -Method Post -Body '{}' -ContentType "application/json"
                This command invokes the function with an empty event and returns a response. If you're using your own function code rather than the sample function code, you might want to invoke the function with a JSON payload. Example:
                Invoke-WebRequest -Uri "http://localhost:9000/2015-03-31/functions/function/invocations" -Method Post -Body '{"payload":"hello world!"}' -ContentType "application/json"
              
          
        
          Get the container ID.
          docker ps
        
          Use the docker kill command to stop the container. In this command, replace 3766c4ab331c with the container ID from the previous step.
          docker kill 3766c4ab331c
        To upload the image to Amazon ECR and create the Lambda function
          Run the get-login-password command to authenticate the Docker CLI to your Amazon ECR registry.
        
         
         
        
          Set the --region value to the AWS Region where you want to create the Amazon ECR repository.
        
          Replace 111122223333 with your AWS account ID.
        
          aws ecr get-login-password --region us-east-1 | docker login --username AWS --password-stdin 111122223333.dkr.ecr.us-east-1.amazonaws.com
          
        
        Create a repository in Amazon ECR using the create-repository command.
        aws ecr create-repository --repository-name hello-world --region us-east-1 --image-scanning-configuration scanOnPush=true --image-tag-mutability MUTABLE
        
        NoteThe Amazon ECR repository must be in the same AWS Region as the Lambda function.
        If successful, you see a response like this:
        {
    "repository": {
        "repositoryArn": "arn:aws:ecr:us-east-1:111122223333:repository/hello-world",
        "registryId": "111122223333",
        "repositoryName": "hello-world",
        "repositoryUri": "111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world",
        "createdAt": "2023-03-09T10:39:01+00:00",
        "imageTagMutability": "MUTABLE",
        "imageScanningConfiguration": {
            "scanOnPush": true
        },
        "encryptionConfiguration": {
            "encryptionType": "AES256"
        }
    }
}
        
      
        Copy the repositoryUri from the output in the previous step.
      
        Run the docker tag command to tag your local image into your Amazon ECR repository as the latest version. In this command: 
        
         
         
        
          docker-image:test is the name and tag of your Docker image. This is the image name and tag that you specified in the docker build command.
        
          Replace <ECRrepositoryUri> with the repositoryUri that you copied. Make sure to include :latest at the end of the URI.
        
        docker tag docker-image:test <ECRrepositoryUri>:latest
      Example:
      docker tag docker-image:test 111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest
      
      
      Run the docker push command to deploy your local image to the Amazon ECR repository. Make sure to include :latest at the end of the repository URI.
docker push 111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest

      
      Create an execution role for the function, if you don't already have one. You need the Amazon Resource Name (ARN) of the role in the next step.
      
        Create the Lambda function. For ImageUri, specify the repository URI from earlier. Make sure to include :latest at the end of the URI.
		aws lambda create-function \
  --function-name hello-world \
  --package-type Image \
  --code ImageUri=111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest \
  --role arn:aws:iam::111122223333:role/lambda-ex
  		
      NoteYou can create a function using an image in a different AWS account, as long as the image is in the same Region as the Lambda function. For more information, see  Amazon ECR cross-account permissions.  
      
      Invoke the function.
      aws lambda invoke --function-name hello-world response.json
      You should see a response like this:
{
  "ExecutedVersion": "$LATEST", 
  "StatusCode": 200
}
    
    To see the output of the function, check the response.json file.
    To update the function code, you must build the image again, upload the new image to the Amazon ECR repository, and then use the update-function-code command to deploy the image to the Lambda function.Lambda resolves the image tag to a specific image digest. This means that if you point the image tag that was used to deploy the function to a new image in Amazon ECR, Lambda doesn't automatically update the function to use the new image.To deploy the new image to the same Lambda function, you must use the update-function-code command, even if the image tag in Amazon ECR remains the same. In the following example, the --publish option creates a new version of the function using the updated container image.aws lambda update-function-code \
  --function-name hello-world \
  --image-uri 111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest \
  --publish
  Document ConventionsDeploy .zip file archivesLayersDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideAWS base images for Node.jsUsing an AWS base imageUsing a non-AWS base imageDeploy Node.js Lambda functions with container imagesThere are three ways to build a container image for a Node.js Lambda function:
     
	 
     
  
      Using an AWS base image for Node.js
      The AWS base images are preloaded with a language runtime, a runtime interface client to manage the interaction between Lambda and your function code, and a runtime interface emulator for local testing.
    
      Using an AWS OS-only base image
      AWS OS-only base images contain an Amazon Linux distribution and the runtime interface emulator. These images are commonly used to create container images for compiled languages, such as Go and Rust, and for a language or language version that Lambda doesn't provide a base image for, such as Node.js 19. You can also use OS-only base images to implement a custom runtime. To make the image compatible with Lambda, you must include the runtime interface client for Node.js in the image.
    
      Using a non-AWS base image
      You can use an alternative base image from another container registry, such as Alpine Linux or Debian. You can also use a custom image created by your organization. To make the image compatible with Lambda, you must include the runtime interface client for Node.js in the image.
    TipTo reduce the time it takes for Lambda container functions to become active, see Use multi-stage builds in the Docker documentation. To build efficient container images, follow the Best practices for writing Dockerfiles.This page explains how to build, test, and deploy container images for Lambda.TopicsAWS base images for Node.jsUsing an AWS base image for Node.jsUsing an alternative base image with the runtime interface client
    AWS base images for Node.js
    AWS provides the following base images for Node.js:
      
    
    
          
            Tags
            Runtime
            Operating system
            Dockerfile
            Deprecation
          
        
      
            22
            Node.js 22
            Amazon Linux 2023
            Dockerfile
                for Node.js 22 on GitHub
            
                          Apr 30, 2027
            
              
          
      
            20
            Node.js 20
            Amazon Linux 2023
            Dockerfile
                for Node.js 20 on GitHub
            
                          Apr 30, 2026
            
              
          
      
            18
            Node.js 18
            Amazon Linux 2
            Dockerfile
                for Node.js 18 on GitHub
            
                          Sep 1, 2025
            
              
          
    

    Amazon ECR repository: gallery.ecr.aws/lambda/nodejs
    The Node.js 20 and later base images are based on the Amazon Linux 2023 minimal container image. Earlier base
      images use Amazon Linux 2. AL2023 provides several advantages over Amazon Linux 2, including a smaller deployment footprint
      and updated versions of libraries such as glibc.
    AL2023-based images use microdnf (symlinked as dnf) as the package manager instead of yum, which is the default package manager in Amazon Linux 2. microdnf is a standalone implementation of dnf. For a list of packages that are included in AL2023-based images, refer to the Minimal Container columns in Comparing packages installed on Amazon Linux 2023 Container Images. For more information about the differences between AL2023 and Amazon Linux 2, see Introducing the Amazon Linux 2023 runtime for AWS Lambda on the AWS
      Compute Blog.    
    NoteTo run AL2023-based images locally, including with AWS Serverless Application Model (AWS SAM), you must use Docker version 20.10.10 or later.  
   
    Using an AWS base image for Node.js
    To complete the steps in this section, you must have the following:
           
           
           
           
        
            AWS CLI version 2
          
            Docker (minimum version 25.0.0)
          
            The Docker buildx plugin.
          
              Node.js
          To create a container image from an AWS base image for Node.js
        Create a directory for the project, and then switch to that directory.
        mkdir example
cd example
      
        Create a new Node.js project with npm. To accept the default options provided in the interactive experience, press Enter.
        npm init
      
        Create a new file called index.js. You can add the following sample function code to the file for testing, or use your own.
        Example  CommonJS handlerexports.handler = async (event) => {
    const response = {
        statusCode: 200,
        body: JSON.stringify('Hello from Lambda!'),
    };
    return response;
};
      
        If your function depends on libraries other than the AWS SDK for JavaScript, use npm to add them to your package.
      
        Create a new Dockerfile with the following configuration:
        
           
           
           
        
            Set the FROM property to the URI of the base image.
          
            Use the COPY command to copy the function code and runtime dependencies to {LAMBDA_TASK_ROOT}, a Lambda-defined environment variable.
          
            Set the CMD argument to the Lambda function handler.
          
        Note that the example Dockerfile does not include a USER instruction. When you deploy a container image to Lambda, Lambda automatically defines a default Linux user with least-privileged permissions. This is different from standard Docker behavior which defaults to the root user when no USER instruction is provided.
        Example  DockerfileFROM public.ecr.aws/lambda/nodejs:22

# Copy function code
COPY index.js ${LAMBDA_TASK_ROOT}
  
# Set the CMD to your handler (could also be done as a parameter override outside of the Dockerfile)
CMD [ "index.handler" ]
      
        Build the Docker image with the docker build command. The
          following example names the image docker-image and gives it the test tag. To make your 
          image compatible with Lambda, you must use the --provenance=false option.
        docker buildx build --platform linux/amd64 --provenance=false -t docker-image:test .
        NoteThe command specifies the --platform linux/amd64 option to ensure that your container is compatible with the Lambda execution environment regardless of the  
       architecture of your build machine. If you intend to create a Lambda function using the ARM64 instruction set architecture, be sure to change the command to use the --platform linux/arm64 
       option instead.
      
          Start the Docker image with the docker run command. In this example,
              docker-image is the image name and test is the tag.
          docker run --platform linux/amd64 -p 9000:8080 docker-image:test
          This command runs the image as a container and creates a local endpoint at
            localhost:9000/2015-03-31/functions/function/invocations.
          NoteIf you built the Docker image for the ARM64 instruction set architecture, be sure to use the --platform linux/arm64 option instead of --platform linux/amd64. 
        
          From a new terminal window, post an event to the local endpoint.
          
            Linux/macOS
      		      In Linux and macOS, run the following curl command:
                curl "http://localhost:9000/2015-03-31/functions/function/invocations" -d '{}'
                This command invokes the function with an empty event and returns a response. If you're using your own function code rather than the sample function code, you might want to invoke the function with a JSON payload. Example:
                curl "http://localhost:9000/2015-03-31/functions/function/invocations" -d '{"payload":"hello world!"}'
      		
            PowerShell
                In PowerShell, run the following Invoke-WebRequest command:
                Invoke-WebRequest -Uri "http://localhost:9000/2015-03-31/functions/function/invocations" -Method Post -Body '{}' -ContentType "application/json"
                This command invokes the function with an empty event and returns a response. If you're using your own function code rather than the sample function code, you might want to invoke the function with a JSON payload. Example:
                Invoke-WebRequest -Uri "http://localhost:9000/2015-03-31/functions/function/invocations" -Method Post -Body '{"payload":"hello world!"}' -ContentType "application/json"
              
          
        
          Get the container ID.
          docker ps
        
          Use the docker kill command to stop the container. In this command, replace 3766c4ab331c with the container ID from the previous step.
          docker kill 3766c4ab331c
        To upload the image to Amazon ECR and create the Lambda function
          Run the get-login-password command to authenticate the Docker CLI to your Amazon ECR registry.
        
         
         
        
          Set the --region value to the AWS Region where you want to create the Amazon ECR repository.
        
          Replace 111122223333 with your AWS account ID.
        
          aws ecr get-login-password --region us-east-1 | docker login --username AWS --password-stdin 111122223333.dkr.ecr.us-east-1.amazonaws.com
          
        
        Create a repository in Amazon ECR using the create-repository command.
        aws ecr create-repository --repository-name hello-world --region us-east-1 --image-scanning-configuration scanOnPush=true --image-tag-mutability MUTABLE
        
        NoteThe Amazon ECR repository must be in the same AWS Region as the Lambda function.
        If successful, you see a response like this:
        {
    "repository": {
        "repositoryArn": "arn:aws:ecr:us-east-1:111122223333:repository/hello-world",
        "registryId": "111122223333",
        "repositoryName": "hello-world",
        "repositoryUri": "111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world",
        "createdAt": "2023-03-09T10:39:01+00:00",
        "imageTagMutability": "MUTABLE",
        "imageScanningConfiguration": {
            "scanOnPush": true
        },
        "encryptionConfiguration": {
            "encryptionType": "AES256"
        }
    }
}
        
      
        Copy the repositoryUri from the output in the previous step.
      
        Run the docker tag command to tag your local image into your Amazon ECR repository as the latest version. In this command: 
        
         
         
        
          docker-image:test is the name and tag of your Docker image. This is the image name and tag that you specified in the docker build command.
        
          Replace <ECRrepositoryUri> with the repositoryUri that you copied. Make sure to include :latest at the end of the URI.
        
        docker tag docker-image:test <ECRrepositoryUri>:latest
      Example:
      docker tag docker-image:test 111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest
      
      
      Run the docker push command to deploy your local image to the Amazon ECR repository. Make sure to include :latest at the end of the repository URI.
docker push 111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest

      
      Create an execution role for the function, if you don't already have one. You need the Amazon Resource Name (ARN) of the role in the next step.
      
        Create the Lambda function. For ImageUri, specify the repository URI from earlier. Make sure to include :latest at the end of the URI.
		aws lambda create-function \
  --function-name hello-world \
  --package-type Image \
  --code ImageUri=111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest \
  --role arn:aws:iam::111122223333:role/lambda-ex
  		
      NoteYou can create a function using an image in a different AWS account, as long as the image is in the same Region as the Lambda function. For more information, see  Amazon ECR cross-account permissions.  
      
      Invoke the function.
      aws lambda invoke --function-name hello-world response.json
      You should see a response like this:
{
  "ExecutedVersion": "$LATEST", 
  "StatusCode": 200
}
    
    To see the output of the function, check the response.json file.
    To update the function code, you must build the image again, upload the new image to the Amazon ECR repository, and then use the update-function-code command to deploy the image to the Lambda function.Lambda resolves the image tag to a specific image digest. This means that if you point the image tag that was used to deploy the function to a new image in Amazon ECR, Lambda doesn't automatically update the function to use the new image.To deploy the new image to the same Lambda function, you must use the update-function-code command, even if the image tag in Amazon ECR remains the same. In the following example, the --publish option creates a new version of the function using the updated container image.aws lambda update-function-code \
  --function-name hello-world \
  --image-uri 111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest \
  --publish
 
    Using an alternative base image with the runtime interface client
    If you use an OS-only base image or an alternative base image, you must include the runtime interface client in your image. The runtime interface client extends the Runtime API, which manages the interaction between Lambda and your function code.
    Install the Node.js runtime interface client using the npm package manager:
    npm install aws-lambda-ric
    You can also download the Node.js runtime interface client from GitHub. 
    The following example demonstrates how to build a container image for Node.js using a non-AWS base image. The example Dockerfile uses a buster base image. The Dockerfile includes the runtime interface client.
        To complete the steps in this section, you must have the following:
           
           
           
           
        
            AWS CLI version 2
          
            Docker (minimum version 25.0.0)
          
            The Docker buildx plugin.
          
              Node.js
          To create a container image from a non-AWS base image
        Create a directory for the project, and then switch to that directory.
        mkdir example
cd example
      
        Create a new Node.js project with npm. To accept the default options provided in the interactive experience, press Enter.
        npm init
      
        Create a new file called index.js. You can add the following sample function code to the file for testing, or use your own.
        Example  CommonJS handlerexports.handler = async (event) => {
    const response = {
        statusCode: 200,
        body: JSON.stringify('Hello from Lambda!'),
    };
    return response;
};
      
        Create a new Dockerfile. The following Dockerfile uses a buster base image instead of an AWS base image. The Dockerfile includes the runtime interface client, which makes the image compatible with Lambda. The Dockerfile uses a multi-stage build. The first stage creates a build image, which is a standard Node.js environment where the function's dependencies are installed. The second stage creates a slimmer image which includes the function code and its dependencies. This reduces the final image size.
        
           
           
          
           
        
            Set the FROM property to the base image identifier.
          
            Use the COPY command to copy the function code and runtime dependencies.
          
            Set the ENTRYPOINT to the module that you want the Docker container to run when it starts. In this case, the module is the runtime interface client.
          
            Set the CMD argument to the Lambda function handler.
          
        Note that the example Dockerfile does not include a USER instruction. When you deploy a container image to Lambda, Lambda automatically defines a default Linux user with least-privileged permissions. This is different from standard Docker behavior which defaults to the root user when no USER instruction is provided.
        Example  Dockerfile# Define custom function directory
ARG FUNCTION_DIR="/function"

FROM node:20-buster as build-image

# Include global arg in this stage of the build
ARG FUNCTION_DIR

# Install build dependencies
RUN apt-get update && \
    apt-get install -y \
    g++ \
    make \
    cmake \
    unzip \
    libcurl4-openssl-dev

# Copy function code
RUN mkdir -p ${FUNCTION_DIR}
COPY . ${FUNCTION_DIR}

WORKDIR ${FUNCTION_DIR}

# Install Node.js dependencies
RUN npm install

# Install the runtime interface client
RUN npm install aws-lambda-ric

# Grab a fresh slim copy of the image to reduce the final size
FROM node:20-buster-slim

# Required for Node runtimes which use npm@8.6.0+ because
# by default npm writes logs under /home/.npm and Lambda fs is read-only
ENV NPM_CONFIG_CACHE=/tmp/.npm

# Include global arg in this stage of the build
ARG FUNCTION_DIR

# Set working directory to function root directory
WORKDIR ${FUNCTION_DIR}

# Copy in the built dependencies
COPY --from=build-image ${FUNCTION_DIR} ${FUNCTION_DIR}

# Set runtime interface client as default command for the container runtime
ENTRYPOINT ["/usr/local/bin/npx", "aws-lambda-ric"]
# Pass the name of the function handler as an argument to the runtime
CMD ["index.handler"]
      
        Build the Docker image with the docker build command. The
          following example names the image docker-image and gives it the test tag. To make your 
          image compatible with Lambda, you must use the --provenance=false option.
        docker buildx build --platform linux/amd64 --provenance=false -t docker-image:test .
        NoteThe command specifies the --platform linux/amd64 option to ensure that your container is compatible with the Lambda execution environment regardless of the  
       architecture of your build machine. If you intend to create a Lambda function using the ARM64 instruction set architecture, be sure to change the command to use the --platform linux/arm64 
       option instead.
      Use the runtime interface emulator to locally test the image. You can build the emulator into your image or use the following procedure to install it on your local machine.To install and run the runtime interface emulator on your local machine
          From your project directory, run the following command to download the runtime interface emulator (x86-64 architecture) from GitHub and install it on your local machine.
          
            Linux/macOS
          mkdir -p ~/.aws-lambda-rie && \
    curl -Lo ~/.aws-lambda-rie/aws-lambda-rie https://github.com/aws/aws-lambda-runtime-interface-emulator/releases/latest/download/aws-lambda-rie && \
    chmod +x ~/.aws-lambda-rie/aws-lambda-rie
      			  To install the arm64 emulator, replace the GitHub repository URL in the previous command with the following:
      			https://github.com/aws/aws-lambda-runtime-interface-emulator/releases/latest/download/aws-lambda-rie-arm64
      		
            PowerShell
      				  $dirPath = "$HOME\.aws-lambda-rie"
if (-not (Test-Path $dirPath)) {
    New-Item -Path $dirPath -ItemType Directory
}
      
$downloadLink = "https://github.com/aws/aws-lambda-runtime-interface-emulator/releases/latest/download/aws-lambda-rie"
$destinationPath = "$HOME\.aws-lambda-rie\aws-lambda-rie"
Invoke-WebRequest -Uri $downloadLink -OutFile $destinationPath
      				  To install the arm64 emulator, replace the $downloadLink with the following:
      				https://github.com/aws/aws-lambda-runtime-interface-emulator/releases/latest/download/aws-lambda-rie-arm64
              
          
        
          Start the Docker image with the docker run command. Note the following:
          
             
             
          
            docker-image is the image name and test is the tag.
            
            /usr/local/bin/npx aws-lambda-ric index.handler is the ENTRYPOINT followed by the CMD from your Dockerfile.
            
          
            Linux/macOS
				    docker run --platform linux/amd64 -d -v ~/.aws-lambda-rie:/aws-lambda -p 9000:8080 \
    --entrypoint /aws-lambda/aws-lambda-rie \
    docker-image:test \
        /usr/local/bin/npx aws-lambda-ric index.handler
      		
            PowerShell
				        docker run --platform linux/amd64 -d -v "$HOME\.aws-lambda-rie:/aws-lambda" -p 9000:8080 `
--entrypoint /aws-lambda/aws-lambda-rie `
docker-image:test `
    /usr/local/bin/npx aws-lambda-ric index.handler
				    
          
          This command runs the image as a container and creates a local endpoint at
            localhost:9000/2015-03-31/functions/function/invocations.
         NoteIf you built the Docker image for the ARM64 instruction set architecture, be sure to use the --platform linux/arm64 option instead of --platform linux/amd64.   
        
          Post an event to the local endpoint.
          
            Linux/macOS
      		      In Linux and macOS, run the following curl command:
                curl "http://localhost:9000/2015-03-31/functions/function/invocations" -d '{}'
                This command invokes the function with an empty event and returns a response. If you're using your own function code rather than the sample function code, you might want to invoke the function with a JSON payload. Example:
                curl "http://localhost:9000/2015-03-31/functions/function/invocations" -d '{"payload":"hello world!"}'
      		
            PowerShell
                In PowerShell, run the following Invoke-WebRequest command:
                Invoke-WebRequest -Uri "http://localhost:9000/2015-03-31/functions/function/invocations" -Method Post -Body '{}' -ContentType "application/json"
                This command invokes the function with an empty event and returns a response. If you're using your own function code rather than the sample function code, you might want to invoke the function with a JSON payload. Example:
                Invoke-WebRequest -Uri "http://localhost:9000/2015-03-31/functions/function/invocations" -Method Post -Body '{"payload":"hello world!"}' -ContentType "application/json"
              
          
        
          Get the container ID.
          docker ps
        
          Use the docker kill command to stop the container. In this command, replace 3766c4ab331c with the container ID from the previous step.
          docker kill 3766c4ab331c
        To upload the image to Amazon ECR and create the Lambda function
          Run the get-login-password command to authenticate the Docker CLI to your Amazon ECR registry.
        
         
         
        
          Set the --region value to the AWS Region where you want to create the Amazon ECR repository.
        
          Replace 111122223333 with your AWS account ID.
        
          aws ecr get-login-password --region us-east-1 | docker login --username AWS --password-stdin 111122223333.dkr.ecr.us-east-1.amazonaws.com
          
        
        Create a repository in Amazon ECR using the create-repository command.
        aws ecr create-repository --repository-name hello-world --region us-east-1 --image-scanning-configuration scanOnPush=true --image-tag-mutability MUTABLE
        
        NoteThe Amazon ECR repository must be in the same AWS Region as the Lambda function.
        If successful, you see a response like this:
        {
    "repository": {
        "repositoryArn": "arn:aws:ecr:us-east-1:111122223333:repository/hello-world",
        "registryId": "111122223333",
        "repositoryName": "hello-world",
        "repositoryUri": "111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world",
        "createdAt": "2023-03-09T10:39:01+00:00",
        "imageTagMutability": "MUTABLE",
        "imageScanningConfiguration": {
            "scanOnPush": true
        },
        "encryptionConfiguration": {
            "encryptionType": "AES256"
        }
    }
}
        
      
        Copy the repositoryUri from the output in the previous step.
      
        Run the docker tag command to tag your local image into your Amazon ECR repository as the latest version. In this command: 
        
         
         
        
          docker-image:test is the name and tag of your Docker image. This is the image name and tag that you specified in the docker build command.
        
          Replace <ECRrepositoryUri> with the repositoryUri that you copied. Make sure to include :latest at the end of the URI.
        
        docker tag docker-image:test <ECRrepositoryUri>:latest
      Example:
      docker tag docker-image:test 111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest
      
      
      Run the docker push command to deploy your local image to the Amazon ECR repository. Make sure to include :latest at the end of the repository URI.
docker push 111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest

      
      Create an execution role for the function, if you don't already have one. You need the Amazon Resource Name (ARN) of the role in the next step.
      
        Create the Lambda function. For ImageUri, specify the repository URI from earlier. Make sure to include :latest at the end of the URI.
		aws lambda create-function \
  --function-name hello-world \
  --package-type Image \
  --code ImageUri=111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest \
  --role arn:aws:iam::111122223333:role/lambda-ex
  		
      NoteYou can create a function using an image in a different AWS account, as long as the image is in the same Region as the Lambda function. For more information, see  Amazon ECR cross-account permissions.  
      
      Invoke the function.
      aws lambda invoke --function-name hello-world response.json
      You should see a response like this:
{
  "ExecutedVersion": "$LATEST", 
  "StatusCode": 200
}
    
    To see the output of the function, check the response.json file.
    To update the function code, you must build the image again, upload the new image to the Amazon ECR repository, and then use the update-function-code command to deploy the image to the Lambda function.Lambda resolves the image tag to a specific image digest. This means that if you point the image tag that was used to deploy the function to a new image in Amazon ECR, Lambda doesn't automatically update the function to use the new image.To deploy the new image to the same Lambda function, you must use the update-function-code command, even if the image tag in Amazon ECR remains the same. In the following example, the --publish option creates a new version of the function using the updated container image.aws lambda update-function-code \
  --function-name hello-world \
  --image-uri 111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest \
  --publish
  Document ConventionsDeploy .zip file archivesLayersDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideRequirementsUsing an AWS base imageUsing an AWS OS-only base imageUsing a non-AWS base imageRuntime interface clientsAmazon ECR permissionsFunction lifecycleCreate a Lambda function using a container imageYour AWS Lambda function's code consists of scripts or compiled programs and their dependencies. 
You use a deployment package to deploy your function code to Lambda. Lambda supports two types of deployment packages: 
container images and .zip file archives. There are three ways to build a container image for a Lambda function:
     
	 
     
  
      Using an AWS base image for Lambda
      The AWS base images are preloaded with a language runtime, a runtime interface client to manage the interaction between Lambda and your function code, and a runtime interface emulator for local testing.
    
      Using an AWS OS-only base image
      AWS OS-only base images contain an Amazon Linux distribution and the runtime interface emulator. These images are commonly used to create container images for compiled languages, such as Go and Rust, and for a language or language version that Lambda doesn't provide a base image for, such as Node.js 19. You can also use OS-only base images to implement a custom runtime. To make the image compatible with Lambda, you must include a runtime interface client for your language in the image.
    
      Using a non-AWS base image
      You can use an alternative base image from another container registry, such as Alpine Linux or Debian. You can also use a custom image created by your organization. To make the image compatible with Lambda, you must include a runtime interface client for your language in the image.
    TipTo reduce the time it takes for Lambda container functions to become active, see Use multi-stage builds in the Docker documentation. To build efficient container images, follow the Best practices for writing Dockerfiles.To create a Lambda function from a container image, build your image locally and upload it to an Amazon Elastic Container Registry
    (Amazon ECR) repository. If you're using a container image provided by an AWS Marketplace seller, you need to clone the
    image to your private Amazon ECR repository first. Then, specify the repository URI when you create the function.
    The Amazon ECR repository must be in the same AWS Region as the Lambda function. You can create a function using an image in a different AWS account, as long as the image is in the same Region as the Lambda function. For more information, see  Amazon ECR cross-account permissions.NoteLambda does not support Amazon ECR FIPS endpoints for container images. If your repository URI includes
      ecr-fips, you are using a FIPS endpoint. Example: 111122223333.dkr.ecr-fips.us-east-1.amazonaws.com.This page explains the base image types and requirements for creating Lambda-compatible container images.NoteYou cannot change the deployment package type (.zip or container image) for an existing function. For example, you cannot convert a container image function to use a .zip file archive. You must create a new function.TopicsRequirementsUsing an AWS base image for LambdaUsing an AWS OS-only base imageUsing a non-AWS base imageRuntime interface clientsAmazon ECR permissionsFunction lifecycle
    Requirements
    Install the AWS CLI version 2 and the Docker CLI. 
      Additionally, note the following requirements:
    
       
       
       
       
       
    
        The container image must implement the Using the Lambda runtime API for custom runtimes. The AWS
          open-source runtime interface clients implement the API. You can
          add a runtime interface client to your preferred base image to make it compatible with Lambda.
      
        The container image must be able to run on a read-only file system. Your function code can access a
          writable /tmp directory with between 512 MB and 10,240 MB, in 1-MB increments, of storage.  
      
        The default Lambda user must be able to read all the files required to run your function code. Lambda
          follows security best practices by defining a default Linux user with least-privileged permissions. This means that you don't need to specify a USER  in your Dockerfile. Verify
          that your application code does not rely on files that other Linux users are restricted from running.
      
        Lambda supports only Linux-based container images.
      
        Lambda provides multi-architecture base images. However, the image you build for your function must target
          only one of the architectures. Lambda does not support functions that use multi-architecture container
          images.
      
   
    Using an AWS base image for Lambda
    You can use one of the AWS base images for Lambda to build the container image for your
      function code. The base images are preloaded with a language runtime and other components
      required to run a container image on Lambda. You add your function code and dependencies to the
      base image and then package it as a container image.
    AWS periodically provides updates to the AWS base images for Lambda. If your Dockerfile includes the
      image name in the FROM property, your Docker client pulls the latest version of the image from the Amazon ECR repository. To
      use the updated base image, you must rebuild your container image and update the function code.
      The Node.js 20, Python 3.12, Java 21, .NET 8, Ruby 3.3, and later base images are based on the Amazon Linux 2023 minimal container image. Earlier base images use Amazon Linux 2. AL2023 provides several advantages over Amazon Linux 2, including a smaller deployment footprint and updated versions of libraries such as glibc.
    AL2023-based images use microdnf (symlinked as dnf) as the package manager instead of yum, which is the default package manager in Amazon Linux 2. microdnf is a standalone implementation of dnf. For a list of packages that are included in AL2023-based images, refer to the Minimal Container columns in Comparing packages installed on Amazon Linux 2023 Container Images. For more information about the differences between AL2023 and Amazon Linux 2, see Introducing the Amazon Linux 2023 runtime for AWS Lambda on the AWS
      Compute Blog.    
    NoteTo run AL2023-based images locally, including with AWS Serverless Application Model (AWS SAM), you must use Docker version 20.10.10 or later.  
    To build a container image using an AWS base image, choose the instructions for your preferred language:
    
       
       
       
       
       
       
       
    
        Node.js
      
        TypeScript (uses a Node.js base image) 
      
        Python
      
        Java 
      
        Go
      
        .NET
      
        Ruby
      
   
    Using an AWS OS-only base image
    AWS OS-only base images contain an Amazon Linux distribution and the runtime interface emulator. These images are commonly used to create container images for compiled languages, such as Go and Rust, and for a language or language version that Lambda doesn't provide a base image for, such as Node.js 19. You can also use OS-only base images to implement a custom runtime. To make the image compatible with Lambda, you must include a runtime interface client for your language in the image.
    
          
            Tags
            Runtime
            Operating system
            Dockerfile
            Deprecation
          
        
      
            al2023
            OS-only Runtime
            Amazon Linux 2023
            Dockerfile
                for OS-only Runtime on GitHub
            
                          Jun 30, 2029
            
              
          
      
            al2
            OS-only Runtime
            Amazon Linux 2
            Dockerfile
                for OS-only Runtime on GitHub
            
                          Jun 30, 2026
            
              
          
    
    Amazon Elastic Container Registry Public Gallery: gallery.ecr.aws/lambda/provided
     
    Using a non-AWS base image
    Lambda
      supports any image that conforms to one of the following image manifest formats:
    
       
       
    Docker image manifest V2, schema 2 (used with Docker version 1.10 and newer)Open Container Initiative (OCI) Specifications (v1.0.0 and up)
    Lambda supports a maximum uncompressed image size of 10 GB, including all layers.
    NoteTo make the image compatible with Lambda, you must include a runtime interface client for your language in the image.
   
    Runtime interface clients
    If you use an OS-only base image or an alternative base image, you must include a runtime interface client in your image. The runtime interface client must extend the Using the Lambda runtime API for custom runtimes, which manages the interaction between Lambda and your function code. AWS provides open-source runtime interface clients for the following languages:
    
  
   
  
   
  
   
  
   
  
   
  
   
  
     

    
      Node.js
    
  
    
      Python
    
  
    
      Java
    
  
    
      .NET
    
  
    
      Go
    
  
    
      Ruby
    
  
    
      Rust – The Rust runtime client is an experimental package. It is subject to change and intended only for evaluation purposes.
    
  
    If you're using a language that doesn't have an AWS-provided runtime interface client, you must create your own.
   
    Amazon ECR permissions
    Before you create a Lambda function from a container image, you must build the image locally and upload it to an Amazon ECR repository. When you create the function, specify the Amazon ECR repository URI.
    Make sure that the permissions for the user or role that creates the function includes GetRepositoryPolicy and SetRepositoryPolicy.
    For example, use the IAM console to create a role with the following policy:
    {
  "Version": "2012-10-17",
  "Statement": [
    {
      "Sid": "VisualEditor0",
      "Effect": "Allow",
      "Action": [
        "ecr:SetRepositoryPolicy",
        "ecr:GetRepositoryPolicy"
      ],
      "Resource": "arn:aws:ecr:us-east-1:111122223333:repository/hello-world"
    }
  ]
}
     
      Amazon ECR repository policies
      For a function in the same account as the container image in Amazon ECR, you can add ecr:BatchGetImage
        and ecr:GetDownloadUrlForLayer permissions to your Amazon ECR repository policy. The following example shows the
        minimum policy:
      {
        "Sid": "LambdaECRImageRetrievalPolicy",
        "Effect": "Allow",
        "Principal": {
          "Service": "lambda.amazonaws.com"
        },
        "Action": [
          "ecr:BatchGetImage",
          "ecr:GetDownloadUrlForLayer"
        ]
    }   
      For more information about Amazon ECR
        repository permissions, see Private repository policies in the
        Amazon Elastic Container Registry User Guide.
      If the Amazon ECR repository does not include these permissions, Lambda attempts to add them automatically. Lambda can add
        permissions only if the principal calling Lambda has ecr:getRepositoryPolicy and
          ecr:setRepositoryPolicy permissions. 
      To view or edit your Amazon ECR repository permissions, follow the directions in Setting a private repository policy statement in the
          Amazon Elastic Container Registry User Guide.
       
         Amazon ECR cross-account permissions
        A different account in the same region can create a function that uses a container image owned by your
          account. In the following example, your Amazon ECR repository permissions policy needs the following statements to
          grant access to account number 123456789012.
        
           
           
        CrossAccountPermission – Allows account 123456789012 to create and update Lambda
              functions that use images from this ECR repository.LambdaECRImageCrossAccountRetrievalPolicy – Lambda will eventually set a
              function's state to inactive if it is not invoked for an extended period. This statement is required so that
              Lambda can retrieve the container image for optimization and caching on behalf of the function owned by
              123456789012.  
        Example — Add cross-account permission to your repository{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Sid": "CrossAccountPermission",
      "Effect": "Allow",
      "Action": [
        "ecr:BatchGetImage",
        "ecr:GetDownloadUrlForLayer"
      ],
      "Principal": {
        "AWS": "arn:aws:iam::123456789012:root"
      }
    },
    {
      "Sid": "LambdaECRImageCrossAccountRetrievalPolicy",
      "Effect": "Allow",
      "Action": [
        "ecr:BatchGetImage",
        "ecr:GetDownloadUrlForLayer"
      ],
      "Principal": {
        "Service": "lambda.amazonaws.com"
      },
      "Condition": {
        "StringLike": {
          "aws:sourceARN": "arn:aws:lambda:us-east-1:123456789012:function:*"
        }
      }
    }
  ]
}
        To give access to multiple accounts, you add the account IDs to the Principal list in the
            CrossAccountPermission policy and to the Condition evaluation list in the
            LambdaECRImageCrossAccountRetrievalPolicy.
        If you are working with multiple accounts in an AWS Organization, we recommend that you enumerate each
          account ID in the ECR permissions policy. This approach aligns with the AWS security best practice of setting
          narrow permissions in IAM policies.
        In addition to Lambda permissions, the user or role that creates the function must also have BatchGetImage and GetDownloadUrlForLayer permissions.
       
     
   
    Function lifecycle
    After you upload a new or updated container image, Lambda optimizes the image before the function can process invocations. The
      optimization process can take a few seconds. The function remains in the Pending state until the
      process completes, when the state transitions to Active. You can't invoke the function until it reaches the Active state. 
    If a function is not invoked for multiple weeks, Lambda reclaims its optimized version, and the function
      transitions to the Inactive state. To reactivate the function, you must invoke it. Lambda rejects the
      first invocation and the function enters the Pending state until Lambda re-optimizes the image. The
      function then returns to the Active state.
    Lambda periodically fetches the associated container image from the Amazon ECR repository. If the
      corresponding container image no longer exists on Amazon ECR or permissions are revoked, the function enters the Failed state, and
      Lambda returns a failure for any function invocations.
    You can use the Lambda API to get information about a function's state. For more information, see Lambda function states.
  Document ConventionsEncryptionMemoryDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideRequirementsUsing an AWS base imageUsing an AWS OS-only base imageUsing a non-AWS base imageRuntime interface clientsAmazon ECR permissionsFunction lifecycleCreate a Lambda function using a container imageYour AWS Lambda function's code consists of scripts or compiled programs and their dependencies. 
You use a deployment package to deploy your function code to Lambda. Lambda supports two types of deployment packages: 
container images and .zip file archives. There are three ways to build a container image for a Lambda function:
     
	 
     
  
      Using an AWS base image for Lambda
      The AWS base images are preloaded with a language runtime, a runtime interface client to manage the interaction between Lambda and your function code, and a runtime interface emulator for local testing.
    
      Using an AWS OS-only base image
      AWS OS-only base images contain an Amazon Linux distribution and the runtime interface emulator. These images are commonly used to create container images for compiled languages, such as Go and Rust, and for a language or language version that Lambda doesn't provide a base image for, such as Node.js 19. You can also use OS-only base images to implement a custom runtime. To make the image compatible with Lambda, you must include a runtime interface client for your language in the image.
    
      Using a non-AWS base image
      You can use an alternative base image from another container registry, such as Alpine Linux or Debian. You can also use a custom image created by your organization. To make the image compatible with Lambda, you must include a runtime interface client for your language in the image.
    TipTo reduce the time it takes for Lambda container functions to become active, see Use multi-stage builds in the Docker documentation. To build efficient container images, follow the Best practices for writing Dockerfiles.To create a Lambda function from a container image, build your image locally and upload it to an Amazon Elastic Container Registry
    (Amazon ECR) repository. If you're using a container image provided by an AWS Marketplace seller, you need to clone the
    image to your private Amazon ECR repository first. Then, specify the repository URI when you create the function.
    The Amazon ECR repository must be in the same AWS Region as the Lambda function. You can create a function using an image in a different AWS account, as long as the image is in the same Region as the Lambda function. For more information, see  Amazon ECR cross-account permissions.NoteLambda does not support Amazon ECR FIPS endpoints for container images. If your repository URI includes
      ecr-fips, you are using a FIPS endpoint. Example: 111122223333.dkr.ecr-fips.us-east-1.amazonaws.com.This page explains the base image types and requirements for creating Lambda-compatible container images.NoteYou cannot change the deployment package type (.zip or container image) for an existing function. For example, you cannot convert a container image function to use a .zip file archive. You must create a new function.TopicsRequirementsUsing an AWS base image for LambdaUsing an AWS OS-only base imageUsing a non-AWS base imageRuntime interface clientsAmazon ECR permissionsFunction lifecycle
    Requirements
    Install the AWS CLI version 2 and the Docker CLI. 
      Additionally, note the following requirements:
    
       
       
       
       
       
    
        The container image must implement the Using the Lambda runtime API for custom runtimes. The AWS
          open-source runtime interface clients implement the API. You can
          add a runtime interface client to your preferred base image to make it compatible with Lambda.
      
        The container image must be able to run on a read-only file system. Your function code can access a
          writable /tmp directory with between 512 MB and 10,240 MB, in 1-MB increments, of storage.  
      
        The default Lambda user must be able to read all the files required to run your function code. Lambda
          follows security best practices by defining a default Linux user with least-privileged permissions. This means that you don't need to specify a USER  in your Dockerfile. Verify
          that your application code does not rely on files that other Linux users are restricted from running.
      
        Lambda supports only Linux-based container images.
      
        Lambda provides multi-architecture base images. However, the image you build for your function must target
          only one of the architectures. Lambda does not support functions that use multi-architecture container
          images.
      
   
    Using an AWS base image for Lambda
    You can use one of the AWS base images for Lambda to build the container image for your
      function code. The base images are preloaded with a language runtime and other components
      required to run a container image on Lambda. You add your function code and dependencies to the
      base image and then package it as a container image.
    AWS periodically provides updates to the AWS base images for Lambda. If your Dockerfile includes the
      image name in the FROM property, your Docker client pulls the latest version of the image from the Amazon ECR repository. To
      use the updated base image, you must rebuild your container image and update the function code.
      The Node.js 20, Python 3.12, Java 21, .NET 8, Ruby 3.3, and later base images are based on the Amazon Linux 2023 minimal container image. Earlier base images use Amazon Linux 2. AL2023 provides several advantages over Amazon Linux 2, including a smaller deployment footprint and updated versions of libraries such as glibc.
    AL2023-based images use microdnf (symlinked as dnf) as the package manager instead of yum, which is the default package manager in Amazon Linux 2. microdnf is a standalone implementation of dnf. For a list of packages that are included in AL2023-based images, refer to the Minimal Container columns in Comparing packages installed on Amazon Linux 2023 Container Images. For more information about the differences between AL2023 and Amazon Linux 2, see Introducing the Amazon Linux 2023 runtime for AWS Lambda on the AWS
      Compute Blog.    
    NoteTo run AL2023-based images locally, including with AWS Serverless Application Model (AWS SAM), you must use Docker version 20.10.10 or later.  
    To build a container image using an AWS base image, choose the instructions for your preferred language:
    
       
       
       
       
       
       
       
    
        Node.js
      
        TypeScript (uses a Node.js base image) 
      
        Python
      
        Java 
      
        Go
      
        .NET
      
        Ruby
      
   
    Using an AWS OS-only base image
    AWS OS-only base images contain an Amazon Linux distribution and the runtime interface emulator. These images are commonly used to create container images for compiled languages, such as Go and Rust, and for a language or language version that Lambda doesn't provide a base image for, such as Node.js 19. You can also use OS-only base images to implement a custom runtime. To make the image compatible with Lambda, you must include a runtime interface client for your language in the image.
    
          
            Tags
            Runtime
            Operating system
            Dockerfile
            Deprecation
          
        
      
            al2023
            OS-only Runtime
            Amazon Linux 2023
            Dockerfile
                for OS-only Runtime on GitHub
            
                          Jun 30, 2029
            
              
          
      
            al2
            OS-only Runtime
            Amazon Linux 2
            Dockerfile
                for OS-only Runtime on GitHub
            
                          Jun 30, 2026
            
              
          
    
    Amazon Elastic Container Registry Public Gallery: gallery.ecr.aws/lambda/provided
     
    Using a non-AWS base image
    Lambda
      supports any image that conforms to one of the following image manifest formats:
    
       
       
    Docker image manifest V2, schema 2 (used with Docker version 1.10 and newer)Open Container Initiative (OCI) Specifications (v1.0.0 and up)
    Lambda supports a maximum uncompressed image size of 10 GB, including all layers.
    NoteTo make the image compatible with Lambda, you must include a runtime interface client for your language in the image.
   
    Runtime interface clients
    If you use an OS-only base image or an alternative base image, you must include a runtime interface client in your image. The runtime interface client must extend the Using the Lambda runtime API for custom runtimes, which manages the interaction between Lambda and your function code. AWS provides open-source runtime interface clients for the following languages:
    
  
   
  
   
  
   
  
   
  
   
  
   
  
     

    
      Node.js
    
  
    
      Python
    
  
    
      Java
    
  
    
      .NET
    
  
    
      Go
    
  
    
      Ruby
    
  
    
      Rust – The Rust runtime client is an experimental package. It is subject to change and intended only for evaluation purposes.
    
  
    If you're using a language that doesn't have an AWS-provided runtime interface client, you must create your own.
   
    Amazon ECR permissions
    Before you create a Lambda function from a container image, you must build the image locally and upload it to an Amazon ECR repository. When you create the function, specify the Amazon ECR repository URI.
    Make sure that the permissions for the user or role that creates the function includes GetRepositoryPolicy and SetRepositoryPolicy.
    For example, use the IAM console to create a role with the following policy:
    {
  "Version": "2012-10-17",
  "Statement": [
    {
      "Sid": "VisualEditor0",
      "Effect": "Allow",
      "Action": [
        "ecr:SetRepositoryPolicy",
        "ecr:GetRepositoryPolicy"
      ],
      "Resource": "arn:aws:ecr:us-east-1:111122223333:repository/hello-world"
    }
  ]
}
     
      Amazon ECR repository policies
      For a function in the same account as the container image in Amazon ECR, you can add ecr:BatchGetImage
        and ecr:GetDownloadUrlForLayer permissions to your Amazon ECR repository policy. The following example shows the
        minimum policy:
      {
        "Sid": "LambdaECRImageRetrievalPolicy",
        "Effect": "Allow",
        "Principal": {
          "Service": "lambda.amazonaws.com"
        },
        "Action": [
          "ecr:BatchGetImage",
          "ecr:GetDownloadUrlForLayer"
        ]
    }   
      For more information about Amazon ECR
        repository permissions, see Private repository policies in the
        Amazon Elastic Container Registry User Guide.
      If the Amazon ECR repository does not include these permissions, Lambda attempts to add them automatically. Lambda can add
        permissions only if the principal calling Lambda has ecr:getRepositoryPolicy and
          ecr:setRepositoryPolicy permissions. 
      To view or edit your Amazon ECR repository permissions, follow the directions in Setting a private repository policy statement in the
          Amazon Elastic Container Registry User Guide.
       
         Amazon ECR cross-account permissions
        A different account in the same region can create a function that uses a container image owned by your
          account. In the following example, your Amazon ECR repository permissions policy needs the following statements to
          grant access to account number 123456789012.
        
           
           
        CrossAccountPermission – Allows account 123456789012 to create and update Lambda
              functions that use images from this ECR repository.LambdaECRImageCrossAccountRetrievalPolicy – Lambda will eventually set a
              function's state to inactive if it is not invoked for an extended period. This statement is required so that
              Lambda can retrieve the container image for optimization and caching on behalf of the function owned by
              123456789012.  
        Example — Add cross-account permission to your repository{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Sid": "CrossAccountPermission",
      "Effect": "Allow",
      "Action": [
        "ecr:BatchGetImage",
        "ecr:GetDownloadUrlForLayer"
      ],
      "Principal": {
        "AWS": "arn:aws:iam::123456789012:root"
      }
    },
    {
      "Sid": "LambdaECRImageCrossAccountRetrievalPolicy",
      "Effect": "Allow",
      "Action": [
        "ecr:BatchGetImage",
        "ecr:GetDownloadUrlForLayer"
      ],
      "Principal": {
        "Service": "lambda.amazonaws.com"
      },
      "Condition": {
        "StringLike": {
          "aws:sourceARN": "arn:aws:lambda:us-east-1:123456789012:function:*"
        }
      }
    }
  ]
}
        To give access to multiple accounts, you add the account IDs to the Principal list in the
            CrossAccountPermission policy and to the Condition evaluation list in the
            LambdaECRImageCrossAccountRetrievalPolicy.
        If you are working with multiple accounts in an AWS Organization, we recommend that you enumerate each
          account ID in the ECR permissions policy. This approach aligns with the AWS security best practice of setting
          narrow permissions in IAM policies.
        In addition to Lambda permissions, the user or role that creates the function must also have BatchGetImage and GetDownloadUrlForLayer permissions.
       
     
   
    Function lifecycle
    After you upload a new or updated container image, Lambda optimizes the image before the function can process invocations. The
      optimization process can take a few seconds. The function remains in the Pending state until the
      process completes, when the state transitions to Active. You can't invoke the function until it reaches the Active state. 
    If a function is not invoked for multiple weeks, Lambda reclaims its optimized version, and the function
      transitions to the Inactive state. To reactivate the function, you must invoke it. Lambda rejects the
      first invocation and the function enters the Pending state until Lambda re-optimizes the image. The
      function then returns to the Active state.
    Lambda periodically fetches the associated container image from the Amazon ECR repository. If the
      corresponding container image no longer exists on Amazon ECR or permissions are revoked, the function enters the Failed state, and
      Lambda returns a failure for any function invocations.
    You can use the Lambda API to get information about a function's state. For more information, see Lambda function states.
  Document ConventionsEncryptionMemoryDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideAWS base images for deploying Go functionsGo runtime interface clientUsing an AWS OS-only base imageUsing a non-AWS base imageDeploy Go Lambda functions with container imagesThere are two ways to build a container image for a Go Lambda function:
	 
     
  
      Using an AWS OS-only base image
      Go is implemented differently than other managed runtimes. Because Go compiles natively to an executable binary, it doesn't require a dedicated language runtime. Use an OS-only base image to build Go images for Lambda. To make the image compatible with Lambda, you must include the aws-lambda-go/lambda package in the image.
    
      Using a non-AWS base image
      You can use an alternative base image from another container registry, such as Alpine Linux or Debian. You can also use a custom image created by your organization. To make the image compatible with Lambda, you must include the aws-lambda-go/lambda package in the image.
    TipTo reduce the time it takes for Lambda container functions to become active, see Use multi-stage builds in the Docker documentation. To build efficient container images, follow the Best practices for writing Dockerfiles.This page explains how to build, test, and deploy container images for Lambda.
    AWS base images for deploying Go functions
    Go is implemented differently than other managed runtimes. Because Go compiles natively to an executable binary, it doesn't require a dedicated language runtime. Use an OS-only base image to deploy Go functions to Lambda.
    
      
        Name
        Identifier
        Operating system
        Deprecation date
        Block function create
        Block function update
      
    
      
        
          OS-only Runtime
        
        
          provided.al2023
        
        
          Amazon Linux 2023
        

        
                      Jun 30, 2029
            
        
        
                      Jul 31, 2029
            
        
        
                      Aug 31, 2029
            
        

      
      
        
          OS-only Runtime
        
        
          provided.al2
        
        
          Amazon Linux 2
        

        
                      Jun 30, 2026
            
        
        
                      Jul 31, 2026
            
        
        
                      Aug 31, 2026
            
        

      
    
    Amazon Elastic Container Registry Public Gallery: gallery.ecr.aws/lambda/provided
   
    Go runtime interface client
    The aws-lambda-go/lambda
      package includes an implementation of the runtime interface. For examples of how to use aws-lambda-go/lambda in your image, see Using an AWS OS-only base image or Using a non-AWS base image.
   
    Using an AWS OS-only base image
    Go is implemented differently than other managed runtimes. Because Go compiles natively to an executable binary, it doesn't require a dedicated language runtime. Use an OS-only base image to
      build container images for Go functions.
    
          
            Tags
            Runtime
            Operating system
            Dockerfile
            Deprecation
          
        
      
            al2023
            OS-only Runtime
            Amazon Linux 2023
            Dockerfile
                for OS-only Runtime on GitHub
            
                          Jun 30, 2029
            
              
          
      
            al2
            OS-only Runtime
            Amazon Linux 2
            Dockerfile
                for OS-only Runtime on GitHub
            
                          Jun 30, 2026
            
              
          
    
    For more information
      about these base images, see provided in the Amazon ECR
      public gallery.
      You must include the aws-lambda-go/lambda package with your Go handler. This package implements the
      programming model for Go, including the runtime interface.
    
      To complete the steps in this section, you must have the following:
	     
           
           
       
    
            AWS CLI version 2
          
            Docker (minimum version 25.0.0)
          
            The Docker buildx plugin.
          
        Go
      To build and deploy a Go function with the provided.al2023 base image
          Create a directory for the project, and then switch to that directory.
          mkdir hello
cd hello
        
          Initialize a new Go module.
          go mod init example.com/hello-world
        
          Add the lambda library as a dependency of your new module.
          go get github.com/aws/aws-lambda-go/lambda
        
            Create a file named main.go and then open it in a text editor. This is the code for the Lambda function. You can use the following sample code for testing, or replace it with your own.
          package main

import (
	"context"
	"github.com/aws/aws-lambda-go/events"
	"github.com/aws/aws-lambda-go/lambda"
)

func handler(ctx context.Context, event events.APIGatewayProxyRequest) (events.APIGatewayProxyResponse, error) {
	response := events.APIGatewayProxyResponse{
		StatusCode: 200,
		Body:       "\"Hello from Lambda!\"",
	}
	return response, nil
}

func main() {
	lambda.Start(handler)
}
          
        Use a text editor to create a Dockerfile in your project directory.
        
           
           
           
        
            The following example Dockerfile uses a multi-stage build. This allows you to use a different base image in each step. You can use one image, such as a Go base image, to compile your code and build the executable binary. You can then use a different image, such as provided.al2023, in the final FROM statement to define the image that you deploy to Lambda. The build process is separated from the final deployment image, so the final image only contains the files needed to run the application.
          
            You can use the optional lambda.norpc tag to exclude the Remote Procedure Call (RPC) component of the lambda 
      library. The RPC component is only required if you are using the deprecated Go 1.x runtime. Excluding the RPC reduces the size of the deployment package.
          
            Note that the example Dockerfile does not include a USER instruction. When you deploy a container image to Lambda, Lambda automatically defines a default Linux user with least-privileged permissions. This is different from standard Docker behavior which defaults to the root user when no USER instruction is provided.
          
        Example — Multi-stage build DockerfileNoteMake sure that the version of Go that you specify in your Dockerfile (for example, golang:1.20) is the same version of Go that you used to create your application.
        FROM golang:1.20 as build
WORKDIR /helloworld
# Copy dependencies list
COPY go.mod go.sum ./
# Build with optional lambda.norpc tag
COPY main.go .
RUN go build -tags lambda.norpc -o main main.go
# Copy artifacts to a clean image
FROM public.ecr.aws/lambda/provided:al2023
COPY --from=build /helloworld/main ./main
ENTRYPOINT [ "./main" ]
      
        Build the Docker image with the docker build command. The
          following example names the image docker-image and gives it the test tag. To make your 
          image compatible with Lambda, you must use the --provenance=false option.
        docker buildx build --platform linux/amd64 --provenance=false -t docker-image:test .
        NoteThe command specifies the --platform linux/amd64 option to ensure that your container is compatible with the Lambda execution environment regardless of the  
       architecture of your build machine. If you intend to create a Lambda function using the ARM64 instruction set architecture, be sure to change the command to use the --platform linux/arm64 
       option instead.
      Use the runtime interface emulator to locally test your image. The runtime interface emulator is included in the provided.al2023 base image.To run the runtime interface emulator on your local machine
      Start the Docker image with the docker run command. Note the following:
      
         
         
      
        docker-image is the image name and test is the tag.
        
        ./main is the ENTRYPOINT from your Dockerfile.
        
      docker run -d -p 9000:8080 \
--entrypoint /usr/local/bin/aws-lambda-rie \
docker-image:test ./main
      This command runs the image as a container and creates a local endpoint at
        localhost:9000/2015-03-31/functions/function/invocations.
    
      From a new terminal window, post an event to the following endpoint using a curl
        command:
      curl "http://localhost:9000/2015-03-31/functions/function/invocations" -d '{}'
      This command invokes the function with an empty event and returns a response. Some functions might require a JSON payload. Example:
      curl "http://localhost:9000/2015-03-31/functions/function/invocations" -d '{"payload":"hello world!"}'
    
      Get the container ID.
      docker ps
    
      Use the docker kill command to stop the container. In this command, replace 3766c4ab331c with the container ID from the previous step.
      docker kill 3766c4ab331c
    To upload the image to Amazon ECR and create the Lambda function
          Run the get-login-password command to authenticate the Docker CLI to your Amazon ECR registry.
        
         
         
        
          Set the --region value to the AWS Region where you want to create the Amazon ECR repository.
        
          Replace 111122223333 with your AWS account ID.
        
          aws ecr get-login-password --region us-east-1 | docker login --username AWS --password-stdin 111122223333.dkr.ecr.us-east-1.amazonaws.com
          
        
        Create a repository in Amazon ECR using the create-repository command.
        aws ecr create-repository --repository-name hello-world --region us-east-1 --image-scanning-configuration scanOnPush=true --image-tag-mutability MUTABLE
        
        NoteThe Amazon ECR repository must be in the same AWS Region as the Lambda function.
        If successful, you see a response like this:
        {
    "repository": {
        "repositoryArn": "arn:aws:ecr:us-east-1:111122223333:repository/hello-world",
        "registryId": "111122223333",
        "repositoryName": "hello-world",
        "repositoryUri": "111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world",
        "createdAt": "2023-03-09T10:39:01+00:00",
        "imageTagMutability": "MUTABLE",
        "imageScanningConfiguration": {
            "scanOnPush": true
        },
        "encryptionConfiguration": {
            "encryptionType": "AES256"
        }
    }
}
        
      
        Copy the repositoryUri from the output in the previous step.
      
        Run the docker tag command to tag your local image into your Amazon ECR repository as the latest version. In this command: 
        
         
         
        
          docker-image:test is the name and tag of your Docker image. This is the image name and tag that you specified in the docker build command.
        
          Replace <ECRrepositoryUri> with the repositoryUri that you copied. Make sure to include :latest at the end of the URI.
        
        docker tag docker-image:test <ECRrepositoryUri>:latest
      Example:
      docker tag docker-image:test 111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest
      
      
      Run the docker push command to deploy your local image to the Amazon ECR repository. Make sure to include :latest at the end of the repository URI.
docker push 111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest

      
      Create an execution role for the function, if you don't already have one. You need the Amazon Resource Name (ARN) of the role in the next step.
      
        Create the Lambda function. For ImageUri, specify the repository URI from earlier. Make sure to include :latest at the end of the URI.
		aws lambda create-function \
  --function-name hello-world \
  --package-type Image \
  --code ImageUri=111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest \
  --role arn:aws:iam::111122223333:role/lambda-ex
  		
      NoteYou can create a function using an image in a different AWS account, as long as the image is in the same Region as the Lambda function. For more information, see  Amazon ECR cross-account permissions.  
      
      Invoke the function.
      aws lambda invoke --function-name hello-world response.json
      You should see a response like this:
{
  "ExecutedVersion": "$LATEST", 
  "StatusCode": 200
}
    
    To see the output of the function, check the response.json file.
    To update the function code, you must build the image again, upload the new image to the Amazon ECR repository, and then use the update-function-code command to deploy the image to the Lambda function.Lambda resolves the image tag to a specific image digest. This means that if you point the image tag that was used to deploy the function to a new image in Amazon ECR, Lambda doesn't automatically update the function to use the new image.To deploy the new image to the same Lambda function, you must use the update-function-code command, even if the image tag in Amazon ECR remains the same. In the following example, the --publish option creates a new version of the function using the updated container image.aws lambda update-function-code \
  --function-name hello-world \
  --image-uri 111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest \
  --publish
   
    Using a non-AWS base image
    You can build a container image for Go from a non-AWS base image. The example Dockerfile in the following steps uses an
      Alpine base image.
    You must include the aws-lambda-go/lambda package with your Go handler. This package implements the
      programming model for Go, including the runtime interface.
   
      To complete the steps in this section, you must have the following:
	     
           
           
       
    
            AWS CLI version 2
          
            Docker (minimum version 25.0.0)
          
            The Docker buildx plugin.
          
        Go
      To build and deploy a Go function with an Alpine base image
          Create a directory for the project, and then switch to that directory.
          mkdir hello
cd hello
        
          Initialize a new Go module.
          go mod init example.com/hello-world
        
          Add the lambda library as a dependency of your new module.
          go get github.com/aws/aws-lambda-go/lambda
        
            Create a file named main.go and then open it in a text editor. This is the code for the Lambda function. You can use the following sample code for testing, or replace it with your own.
          package main

import (
	"context"
	"github.com/aws/aws-lambda-go/events"
	"github.com/aws/aws-lambda-go/lambda"
)

func handler(ctx context.Context, event events.APIGatewayProxyRequest) (events.APIGatewayProxyResponse, error) {
	response := events.APIGatewayProxyResponse{
		StatusCode: 200,
		Body:       "\"Hello from Lambda!\"",
	}
	return response, nil
}

func main() {
	lambda.Start(handler)
}
          
        Use a text editor to create a Dockerfile in your project directory. The following example Dockerfile uses an
          Alpine base image. Note that the example Dockerfile does not include a USER instruction. When you deploy a container image to Lambda, Lambda automatically defines a default Linux user with least-privileged permissions. This is different from standard Docker behavior which defaults to the root user when no USER instruction is provided.
        Example DockerfileNoteMake sure that the version of Go that you specify in your Dockerfile (for example, golang:1.20) is the same version of Go that you used to create your application.
        FROM golang:1.20.2-alpine3.16 as build
WORKDIR /helloworld
# Copy dependencies list
COPY go.mod go.sum ./
# Build
COPY main.go .
RUN go build -o main main.go
# Copy artifacts to a clean image
FROM alpine:3.16
COPY --from=build /helloworld/main /main
ENTRYPOINT [ "/main" ]
      
        Build the Docker image with the docker build command. The
          following example names the image docker-image and gives it the test tag. To make your 
          image compatible with Lambda, you must use the --provenance=false option.
        docker buildx build --platform linux/amd64 --provenance=false -t docker-image:test .
        NoteThe command specifies the --platform linux/amd64 option to ensure that your container is compatible with the Lambda execution environment regardless of the  
       architecture of your build machine. If you intend to create a Lambda function using the ARM64 instruction set architecture, be sure to change the command to use the --platform linux/arm64 
       option instead.
      Use the runtime interface emulator to locally test the image. You can build the emulator into your image or use the following procedure to install it on your local machine.To install and run the runtime interface emulator on your local machine
          From your project directory, run the following command to download the runtime interface emulator (x86-64 architecture) from GitHub and install it on your local machine.
          
            Linux/macOS
          mkdir -p ~/.aws-lambda-rie && \
    curl -Lo ~/.aws-lambda-rie/aws-lambda-rie https://github.com/aws/aws-lambda-runtime-interface-emulator/releases/latest/download/aws-lambda-rie && \
    chmod +x ~/.aws-lambda-rie/aws-lambda-rie
      			  To install the arm64 emulator, replace the GitHub repository URL in the previous command with the following:
      			https://github.com/aws/aws-lambda-runtime-interface-emulator/releases/latest/download/aws-lambda-rie-arm64
      		
            PowerShell
      				  $dirPath = "$HOME\.aws-lambda-rie"
if (-not (Test-Path $dirPath)) {
    New-Item -Path $dirPath -ItemType Directory
}
      
$downloadLink = "https://github.com/aws/aws-lambda-runtime-interface-emulator/releases/latest/download/aws-lambda-rie"
$destinationPath = "$HOME\.aws-lambda-rie\aws-lambda-rie"
Invoke-WebRequest -Uri $downloadLink -OutFile $destinationPath
      				  To install the arm64 emulator, replace the $downloadLink with the following:
      				https://github.com/aws/aws-lambda-runtime-interface-emulator/releases/latest/download/aws-lambda-rie-arm64
              
          
        
          Start the Docker image with the docker run command. Note the following:
          
             
             
          
            docker-image is the image name and test is the tag.
            
            /main is the ENTRYPOINT from your Dockerfile.
            
          
            Linux/macOS
				    docker run --platform linux/amd64 -d -v ~/.aws-lambda-rie:/aws-lambda -p 9000:8080 \
    --entrypoint /aws-lambda/aws-lambda-rie \
    docker-image:test \
        /main
      		
            PowerShell
				        docker run --platform linux/amd64 -d -v "$HOME\.aws-lambda-rie:/aws-lambda" -p 9000:8080 `
--entrypoint /aws-lambda/aws-lambda-rie `
docker-image:test `
    /main
				    
          
          This command runs the image as a container and creates a local endpoint at
            localhost:9000/2015-03-31/functions/function/invocations.
         NoteIf you built the Docker image for the ARM64 instruction set architecture, be sure to use the --platform linux/arm64 option instead of --platform linux/amd64.   
        
          Post an event to the local endpoint.
          
            Linux/macOS
      		      In Linux and macOS, run the following curl command:
                curl "http://localhost:9000/2015-03-31/functions/function/invocations" -d '{}'
                This command invokes the function with an empty event and returns a response. If you're using your own function code rather than the sample function code, you might want to invoke the function with a JSON payload. Example:
                curl "http://localhost:9000/2015-03-31/functions/function/invocations" -d '{"payload":"hello world!"}'
      		
            PowerShell
                In PowerShell, run the following Invoke-WebRequest command:
                Invoke-WebRequest -Uri "http://localhost:9000/2015-03-31/functions/function/invocations" -Method Post -Body '{}' -ContentType "application/json"
                This command invokes the function with an empty event and returns a response. If you're using your own function code rather than the sample function code, you might want to invoke the function with a JSON payload. Example:
                Invoke-WebRequest -Uri "http://localhost:9000/2015-03-31/functions/function/invocations" -Method Post -Body '{"payload":"hello world!"}' -ContentType "application/json"
              
          
        
          Get the container ID.
          docker ps
        
          Use the docker kill command to stop the container. In this command, replace 3766c4ab331c with the container ID from the previous step.
          docker kill 3766c4ab331c
        To upload the image to Amazon ECR and create the Lambda function
          Run the get-login-password command to authenticate the Docker CLI to your Amazon ECR registry.
        
         
         
        
          Set the --region value to the AWS Region where you want to create the Amazon ECR repository.
        
          Replace 111122223333 with your AWS account ID.
        
          aws ecr get-login-password --region us-east-1 | docker login --username AWS --password-stdin 111122223333.dkr.ecr.us-east-1.amazonaws.com
          
        
        Create a repository in Amazon ECR using the create-repository command.
        aws ecr create-repository --repository-name hello-world --region us-east-1 --image-scanning-configuration scanOnPush=true --image-tag-mutability MUTABLE
        
        NoteThe Amazon ECR repository must be in the same AWS Region as the Lambda function.
        If successful, you see a response like this:
        {
    "repository": {
        "repositoryArn": "arn:aws:ecr:us-east-1:111122223333:repository/hello-world",
        "registryId": "111122223333",
        "repositoryName": "hello-world",
        "repositoryUri": "111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world",
        "createdAt": "2023-03-09T10:39:01+00:00",
        "imageTagMutability": "MUTABLE",
        "imageScanningConfiguration": {
            "scanOnPush": true
        },
        "encryptionConfiguration": {
            "encryptionType": "AES256"
        }
    }
}
        
      
        Copy the repositoryUri from the output in the previous step.
      
        Run the docker tag command to tag your local image into your Amazon ECR repository as the latest version. In this command: 
        
         
         
        
          docker-image:test is the name and tag of your Docker image. This is the image name and tag that you specified in the docker build command.
        
          Replace <ECRrepositoryUri> with the repositoryUri that you copied. Make sure to include :latest at the end of the URI.
        
        docker tag docker-image:test <ECRrepositoryUri>:latest
      Example:
      docker tag docker-image:test 111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest
      
      
      Run the docker push command to deploy your local image to the Amazon ECR repository. Make sure to include :latest at the end of the repository URI.
docker push 111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest

      
      Create an execution role for the function, if you don't already have one. You need the Amazon Resource Name (ARN) of the role in the next step.
      
        Create the Lambda function. For ImageUri, specify the repository URI from earlier. Make sure to include :latest at the end of the URI.
		aws lambda create-function \
  --function-name hello-world \
  --package-type Image \
  --code ImageUri=111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest \
  --role arn:aws:iam::111122223333:role/lambda-ex
  		
      NoteYou can create a function using an image in a different AWS account, as long as the image is in the same Region as the Lambda function. For more information, see  Amazon ECR cross-account permissions.  
      
      Invoke the function.
      aws lambda invoke --function-name hello-world response.json
      You should see a response like this:
{
  "ExecutedVersion": "$LATEST", 
  "StatusCode": 200
}
    
    To see the output of the function, check the response.json file.
    To update the function code, you must build the image again, upload the new image to the Amazon ECR repository, and then use the update-function-code command to deploy the image to the Lambda function.Lambda resolves the image tag to a specific image digest. This means that if you point the image tag that was used to deploy the function to a new image in Amazon ECR, Lambda doesn't automatically update the function to use the new image.To deploy the new image to the same Lambda function, you must use the update-function-code command, even if the image tag in Amazon ECR remains the same. In the following example, the --publish option creates a new version of the function using the updated container image.aws lambda update-function-code \
  --function-name hello-world \
  --image-uri 111122223333.dkr.ecr.us-east-1.amazonaws.com/hello-world:latest \
  --publish
  Document ConventionsDeploy .zip file archivesLayersDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideBuilding Lambda functions with RustBecause Rust compiles to native code, you don't need a dedicated runtime to run Rust code on Lambda. Instead, use the Rust runtime client to build your project locally, and then deploy it to Lambda using the provided.al2023 or provided.al2 runtime. When you use provided.al2023 or provided.al2, Lambda automatically keeps the operating system up to date with the latest patches.NoteThe Rust runtime client is an experimental package. It is subject to change and intended only for evaluation purposes.
    Tools and libraries for Rust
     
     
     
     
     
     
  
      AWS SDK for Rust: The AWS SDK for Rust
        provides Rust APIs to interact with Amazon Web Services infrastructure services.
    
      
        Rust runtime client for Lambda: The Rust runtime client is an experimental package. It is subject to breaking changes and not recommended for production.
    
      Cargo
        Lambda: This library provides a command line application to work with Lambda
        functions built with Rust.
    
      Lambda
        HTTP: This library provides a wrapper to work with HTTP events.
    
      
        Lambda
        Extension: This library provides support to write Lambda Extensions with Rust.
      
    
      AWS Lambda Events:
        This library provides type definitions for common event source integrations.
    
    Sample Lambda applications for Rust
     
     
     
     
     
     
     
     
     
  
      Basic
        Lambda function: A Rust function that shows how to process basic events.
    
      Lambda
        function with error handling: A Rust function that shows how to handle custom Rust
        errors in Lambda.
    
      Lambda
        function with shared resources: A Rust project that initializes shared resources
        before creating the Lambda function.
    
      Lambda
        HTTP events: A Rust function that handles HTTP events.
    
      Lambda
        HTTP events with CORS headers: A Rust function that uses Tower to inject CORS headers.
    
      Lambda REST API: A REST API that uses Axum and Diesel to connect to a PostgreSQL database.
    
      Serverless Rust
        demo: A Rust project that shows the use of Lambda's Rust libraries, logging,
        environment variables, and the AWS SDK.
    
      Basic
        Lambda Extension: A Rust extension that shows how to process basic extension events.
    
      Lambda
        Logs Amazon Data Firehose Extension: A Rust extension that shows how to send Lambda logs
        to Firehose.
    TopicsDefine Lambda function handlers in RustUsing the Lambda context object to retrieve Rust function informationProcessing HTTP events with RustDeploy Rust Lambda functions with .zip file archivesWorking with layers for Rust Lambda functionsLog and monitor Rust Lambda functionsDocument ConventionsLoggingHandlerDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideRequirementsImplementing response streaming in a custom
        runtimeBuilding a custom runtime for AWS LambdaYou can implement an AWS Lambda runtime in any programming language. A runtime is a program
    that runs a Lambda function's handler method when the function is invoked. You can include the
    runtime in your function's deployment package or distribute it in a layer. When you create the Lambda function, choose an OS-only runtime (the provided runtime family).NoteCreating a custom runtime is an advanced use case. If you're looking for information about compiling to a native binary or using a third-party off-the-shelf runtime, see When to use Lambda's OS-only runtimes.For a walkthrough of the custom runtime deployment process, see Tutorial: Building a custom runtime.TopicsRequirementsImplementing response streaming in a custom
        runtime
    Requirements
    Custom runtimes must complete certain initialization and processing tasks. A runtime runs the function's setup code, reads the handler name from an environment
      variable, and reads invocation events from the Lambda runtime API. The runtime passes the event
      data to the function handler, and posts the response from the handler back to Lambda.
    
     
      Initialization tasks
    The initialization tasks run once
        per instance of the function to prepare
      the environment to handle invocations.
    
       
       
       
    
        Retrieve settings – Read environment variables to get details
          about the function and environment.
        
           
           
           
        
            _HANDLER – The location to the handler, from the function's configuration. The
              standard format is file.method, where
                file is the name of the file without an extension, and method is the name of a
              method or function that's defined in the file.
          
            LAMBDA_TASK_ROOT – The directory that contains the function code.
          
            AWS_LAMBDA_RUNTIME_API – The host and port of the runtime API.
          
        For a full list of available variables, see Defined runtime environment variables.
      
        Initialize the function – Load the handler file and run any global
          or static code that it contains. Functions should create static resources like SDK clients and database
          connections once, and reuse them for multiple invocations.
      
        Handle errors – If an error occurs, call the initialization error API and exit immediately.
      
    
    Initialization counts towards billed execution time and timeout. When an execution triggers the initialization
      of a new instance of your function, you can see the initialization time in the logs and AWS X-Ray trace.
    Example logREPORT RequestId: f8ac1208... Init Duration: 48.26 ms   Duration: 237.17 ms   Billed Duration: 300 ms   Memory Size: 128 MB   Max Memory Used: 26 MB
     
   
    Processing tasks
    
    While it runs, a runtime uses the Lambda runtime interface to manage
      incoming events and report errors. After completing initialization tasks, the runtime processes incoming events in
      a loop. In your runtime code, perform the following steps in order.
    
       
       
       
       
       
       
       
    
        Get an event – Call the next
            invocation API to get the next event. The response body contains the event data. Response headers
          contain the request ID and other information.
      
        Propagate the tracing header – Get the X-Ray tracing header from
          the Lambda-Runtime-Trace-Id header in the API response. Set the _X_AMZN_TRACE_ID
          environment variable locally with the same value. The X-Ray SDK uses this value to connect trace data between
          services.
      
        Create a context object – Create an object with context
          information from environment variables and headers in the API response.
      
        Invoke the function handler – Pass the event and context object to
          the handler.
      
        Handle the response – Call the invocation response API to post the response from the handler.
      
        Handle errors – If an error occurs, call the invocation error API.
      
        Cleanup – Release unused resources, send data to other services,
          or perform additional tasks before getting the next event.
      
     
     
      Entrypoint
          A custom runtime's entry point is an executable file named bootstrap. The bootstrap file
          can be the runtime, or it can invoke another file that creates the runtime. If the root of your deployment package doesn't contain a file named bootstrap, Lambda looks for the file in the function's layers. If the bootstrap file doesn't exist or isn't executable, your function returns a Runtime.InvalidEntrypoint error upon invocation.
          Here's an example bootstrap file that uses a bundled
          version of Node.js to run a JavaScript runtime in a separate file named
          runtime.js.
        Example bootstrap#!/bin/sh
    cd $LAMBDA_TASK_ROOT
    ./node-v11.1.0-linux-x64/bin/node runtime.js
       
   
    Implementing response streaming in a custom
        runtime
    For response streaming functions, the response and error
      endpoints have slightly modified behavior that lets the runtime stream partial responses to
      the client and return payloads in chunks. For more information about the specific behavior,
      see the following:
    
       
       
       
    
        /runtime/invocation/AwsRequestId/response – Propagates the
            Content-Type header from the runtime to send to the client. Lambda returns
          the response payload in chunks via HTTP/1.1 chunked transfer encoding. The response stream can be a maximum 
          size of 20 MiB. To stream the response to Lambda, the runtime must:
        
           
           
           
           
        
            Set the Lambda-Runtime-Function-Response-Mode HTTP header to
                streaming.
          
            Set the Transfer-Encoding header to chunked.
          
            Write the response conforming to the HTTP/1.1 chunked transfer encoding
              specification.
          
            Close the underlying connection after it has successfully written the
              response.
          
      
        /runtime/invocation/AwsRequestId/error – The runtime can use this
          endpoint to report function or runtime errors to Lambda, which also accepts the
            Transfer-Encoding header. This endpoint can only be called before the
          runtime begins sending an invocation response.
      
        Report midstream errors using error trailers in
            /runtime/invocation/AwsRequestId/response – To report errors that
          occur after the runtime starts writing the invocation response, the runtime can optionally
          attach HTTP trailing headers named Lambda-Runtime-Function-Error-Type and
            Lambda-Runtime-Function-Error-Body. Lambda treats this as a successful
          response and forwards the error metadata that the runtime provides to the client. 
        NoteTo attach trailing headers, the runtime must set the Trailer header
            value at the beginning of the HTTP request. This is a requirement of the HTTP/1.1
            chunked transfer encoding specification.
        
           
           
        
            Lambda-Runtime-Function-Error-Type – The error type that the
              runtime encountered. This header consists of a string value. Lambda accepts any string,
              but we recommend a format of <category.reason>. For
              example, Runtime.APIKeyNotFound.
          
            Lambda-Runtime-Function-Error-Body – Base64-encoded
              information about the error.
          
      
  Document ConventionsOS-only runtimesCustom runtime tutorialDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAmazon LinuxUser GuideMinimal Container image sizeUsing the AL2023 Minimal Container imageAL2023 Minimal container imageNote
       The standard AL2023 container images are suitable for most use cases,
       and adapting to the minimal container image is likely to be more work
       than adapting to the AL2023 base container image.
      The AL2023 minimal container image, introduced in AL2023.2, differs from the base container image because it contains only the bare
     minimum  packages needed to install other packages. The minimal container image is designed to be a minimal set of packages, not a convenient set of packages .  The AL2023 minimal container image is built from software components already available
    in AL2023. The key difference in the minimal container image is using microdnf to
    provide the dnf package manager rather than the fully featured
      Python based dnf. This enables the minimal container image to be
    smaller with the trade-off of not having the full feature set of the dnf package
    manager which is included in the AL2023 AMIs and base container image. 
     The AL2023 minimal container image forms the base of the
     provided.al2023 AWS Lambda runtime environment.
   
     For a detailed list of packages included in the minimal container image, see Comparing packages installed on Amazon Linux 2023 Container Images.
   
     Minimal Container image size
      Because the AL2023 minimal container image contains fewer packages than the AL2023
      base container image, it is also significantly smaller. The following table compares the
      container image options of current and past releases of Amazon Linux. 
     Note
	 Image Size is as-shown on
	 
	   Amazon Linux on Amazon ECR Public Gallery.
       
     
	   
	     Image
	     Version
	     Image Size
	     Note
	   
	 
	   
	     Amazon Linux 1 (AL1)
	     2018.03.0.20230918.0
	     62.3MB
	     x86-64 only
	   
	   
	     Amazon Linux 2
	     2.0.20230926.0
	     64.2MB
	     aarch64 is 1.6MB larger than x86-64
	   
	   
	     Amazon Linux 2023 base container image
	     2023.2.20231002.0
	     52.4MB
	     
	   
	   
	     Amazon Linux 2023 minimal container image
	     2023.2.20231002.0-minimal
	     35.2MB
	     
	   
	 
    
     Using the AL2023 Minimal Container image
      The AL2023 minimal container image is available on ECR and the
        2023-minimal tag will always point to the latest AL2023 based minimal
      container image, while the minimal tag may be updated to a newer version of Amazon Linux
      than AL2023. 
      You can pull these tags using docker with the following example: 
       $ docker pull public.ecr.aws/amazonlinux/amazonlinux:minimal
       $ docker pull public.ecr.aws/amazonlinux/amazonlinux:2023-minimal
    
     The following example shows a Dockerfile that takes the minimal container
      image and installs GCC on top of it :
	
FROM public.ecr.aws/amazonlinux/amazonlinux:2023-minimal
RUN dnf install -y gcc && dnf clean all
	
     
   Document ConventionsAL2023 Base Container ImageBuilding bare-bones AL2023 container imagesDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAmazon LinuxUser GuideComparing packages installed on Amazon Linux 2023 Container ImagesA comparison of the RPMs present on the AL2023 base container image compared with the RPMs present on the AL2023 minimal container image.
            
               Package
               Container
               Minimal Container
            
         
            
               
                  alternatives
               
               1.15
               1.15
            
            
               
                  amazon-linux-repo-cdn
               
               2023.6.20241031
               2023.6.20241031
            
            
               
                  audit-libs
               
               3.0.6
               3.0.6
            
            
               
                  basesystem
               
               11
               11
            
            
               
                  bash
               
               5.2.15
               5.2.15
            
            
               
                  bzip2-libs
               
               1.0.8
               1.0.8
            
            
               
                  ca-certificates
               
               2023.2.68
               2023.2.68
            
            
               
                  coreutils-single
               
               8.32
               8.32
            
            
               
                  crypto-policies
               
               20220428
               20220428
            
            
               
                  curl-minimal
               
               8.5.0
               8.5.0
            
            
               
                  dnf
               
               4.14.0
               
            
            
               
                  dnf-data
               
               4.14.0
               4.14.0
            
            
               
                  elfutils-default-yama-scope
               
               0.188
               
            
            
               
                  elfutils-libelf
               
               0.188
               
            
            
               
                  elfutils-libs
               
               0.188
               
            
            
               
                  expat
               
               2.5.0
               
            
            
               
                  file-libs
               
               5.39
               5.39
            
            
               
                  filesystem
               
               3.14
               3.14
            
            
               
                  gawk
               
               5.1.0
               5.1.0
            
            
               
                  gdbm-libs
               
               1.19
               
            
            
               
                  glib2
               
               2.74.7
               2.74.7
            
            
               
                  glibc
               
               2.34
               2.34
            
            
               
                  glibc-common
               
               2.34
               2.34
            
            
               
                  glibc-minimal-langpack
               
               2.34
               2.34
            
            
               
                  gmp
               
               6.2.1
               6.2.1
            
            
               
                  gnupg2-minimal
               
               2.3.7
               2.3.7
            
            
               
                  gobject-introspection
               
               
               1.73.0
            
            
               
                  gpgme
               
               1.15.1
               1.15.1
            
            
               
                  grep
               
               3.8
               3.8
            
            
               
                  json-c
               
               0.14
               0.14
            
            
               
                  keyutils-libs
               
               1.6.3
               1.6.3
            
            
               
                  krb5-libs
               
               1.21.3
               1.21.3
            
            
               
                  libacl
               
               2.3.1
               2.3.1
            
            
               
                  libarchive
               
               3.7.4
               3.7.4
            
            
               
                  libassuan
               
               2.5.5
               2.5.5
            
            
               
                  libattr
               
               2.5.1
               2.5.1
            
            
               
                  libblkid
               
               2.37.4
               2.37.4
            
            
               
                  libcap
               
               2.48
               2.48
            
            
               
                  libcap-ng
               
               0.8.2
               0.8.2
            
            
               
                  libcom_err
               
               1.46.5
               1.46.5
            
            
               
                  libcomps
               
               0.1.20
               
            
            
               
                  libcurl-minimal
               
               8.5.0
               8.5.0
            
            
               
                  libdnf
               
               0.69.0
               0.69.0
            
            
               
                  libffi
               
               3.4.4
               3.4.4
            
            
               
                  libgcc
               
               11.4.1
               11.4.1
            
            
               
                  libgcrypt
               
               1.10.2
               1.10.2
            
            
               
                  libgomp
               
               11.4.1
               
            
            
               
                  libgpg-error
               
               1.42
               1.42
            
            
               
                  libidn2
               
               2.3.2
               2.3.2
            
            
               
                  libmodulemd
               
               2.13.0
               2.13.0
            
            
               
                  libmount
               
               2.37.4
               2.37.4
            
            
               
                  libnghttp2
               
               1.59.0
               1.59.0
            
            
               
                  libpeas
               
               
               1.32.0
            
            
               
                  libpsl
               
               0.21.1
               0.21.1
            
            
               
                  librepo
               
               1.14.5
               1.14.5
            
            
               
                  libreport-filesystem
               
               2.15.2
               2.15.2
            
            
               
                  libselinux
               
               3.4
               3.4
            
            
               
                  libsepol
               
               3.4
               3.4
            
            
               
                  libsigsegv
               
               2.13
               2.13
            
            
               
                  libsmartcols
               
               2.37.4
               2.37.4
            
            
               
                  libsolv
               
               0.7.22
               0.7.22
            
            
               
                  libstdc++
               
               11.4.1
               11.4.1
            
            
               
                  libtasn1
               
               4.19.0
               4.19.0
            
            
               
                  libunistring
               
               0.9.10
               0.9.10
            
            
               
                  libuuid
               
               2.37.4
               2.37.4
            
            
               
                  libverto
               
               0.3.2
               0.3.2
            
            
               
                  libxcrypt
               
               4.4.33
               
            
            
               
                  libxml2
               
               2.10.4
               2.10.4
            
            
               
                  libyaml
               
               0.2.5
               0.2.5
            
            
               
                  libzstd
               
               1.5.5
               1.5.5
            
            
               
                  lua-libs
               
               5.4.4
               5.4.4
            
            
               
                  lz4-libs
               
               1.9.4
               1.9.4
            
            
               
                  microdnf
               
               
               3.10.0
            
            
               
                  microdnf-dnf
               
               
               3.10.0
            
            
               
                  mpfr
               
               4.1.0
               4.1.0
            
            
               
                  ncurses-base
               
               6.2
               6.2
            
            
               
                  ncurses-libs
               
               6.2
               6.2
            
            
               
                  npth
               
               1.6
               1.6
            
            
               
                  openssl-libs
               
               3.0.8
               3.0.8
            
            
               
                  p11-kit
               
               0.24.1
               0.24.1
            
            
               
                  p11-kit-trust
               
               0.24.1
               0.24.1
            
            
               
                  pcre2
               
               10.40
               10.40
            
            
               
                  pcre2-syntax
               
               10.40
               10.40
            
            
               
                  popt
               
               1.18
               1.18
            
            
               
                  publicsuffix-list-dafsa
               
               20240212
               20240212
            
            
               
                  python3
               
               3.9.16
               
            
            
               
                  python3-dnf
               
               4.14.0
               
            
            
               
                  python3-gpg
               
               1.15.1
               
            
            
               
                  python3-hawkey
               
               0.69.0
               
            
            
               
                  python3-libcomps
               
               0.1.20
               
            
            
               
                  python3-libdnf
               
               0.69.0
               
            
            
               
                  python3-libs
               
               3.9.16
               
            
            
               
                  python3-pip-wheel
               
               21.3.1
               
            
            
               
                  python3-rpm
               
               4.16.1.3
               
            
            
               
                  python3-setuptools-wheel
               
               59.6.0
               
            
            
               
                  readline
               
               8.1
               8.1
            
            
               
                  rpm
               
               4.16.1.3
               4.16.1.3
            
            
               
                  rpm-build-libs
               
               4.16.1.3
               
            
            
               
                  rpm-libs
               
               4.16.1.3
               4.16.1.3
            
            
               
                  rpm-sign-libs
               
               4.16.1.3
               
            
            
               
                  sed
               
               4.8
               4.8
            
            
               
                  setup
               
               2.13.7
               2.13.7
            
            
               
                  sqlite-libs
               
               3.40.0
               3.40.0
            
            
               
                  system-release
               
               2023.6.20241031
               2023.6.20241031
            
            
               
                  tzdata
               
               2024a
               
            
            
               
                  xz-libs
               
               5.2.5
               5.2.5
            
            
               
                  yum
               
               4.14.0
               
            
            
               
                  zlib
               
               1.2.11
               1.2.11
            
         Document ConventionsBuilding bare-bones AL2023 container imagesAL2023 Minimal AMI compared to container imagesDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideCreate environment variablesExample scenario for environment variablesRetrieve environment variablesDefined runtime environment variablesWorking with Lambda environment variablesYou can use environment variables to adjust your function's behavior without updating code. An environment
    variable is a pair of strings that is stored in a function's version-specific configuration. The Lambda runtime makes
    environment variables available to your code and sets additional environment variables that contain information
    about the function and invocation request.NoteTo increase security, we recommend that you use AWS Secrets Manager instead of environment variables to store
      database credentials and other sensitive information like API keys or authorization tokens. For more information, see Use Secrets Manager secrets in Lambda functions.Environment variables are not evaluated before the function invocation. Any value you define is considered a
    literal string and not expanded. Perform the variable evaluation in your function code.
    Creating Lambda environment variables
  You can configure environment variables in Lambda using the Lambda console, the AWS Command Line Interface (AWS CLI), AWS Serverless Application Model (AWS SAM), or using an AWS SDK.
 
   Console
       You define environment variables on the unpublished version of your function. When you publish a version, the
         environment variables are locked for that version along with other version-specific configuration settings.
       You create an environment variable for your function by defining a key and a value. Your function uses the
         name of the key to retrieve the value of the environment variable.
       To set environment variables in the Lambda consoleOpen the Functions page of the Lambda console.
           Choose a function.
         
           Choose the Configuration tab, then choose Environment variables.
         
           Under Environment variables, choose Edit.
         
           Choose Add environment variable.
         
           Enter a key and value.
           
             Requirements
              
              
              
              
           
               Keys start with a letter and are at least two characters.
             
               Keys only contain letters, numbers, and the underscore character (_).
             
               Keys aren't reserved by Lambda.
             
               The total size of all environment variables doesn't exceed 4 KB.
             
         
           Choose Save.
         
       To generate a list of environment variables in the console code editorYou can generate a list of environment variables in the Lambda code editor. This is a quick way to reference
           your environment variables while you code.
           Choose the Code tab.
         
           Scroll down to the ENVIRONMENT VARIABLES section of the code editor. Existing environment variables are listed here:
           
              
               
              
              
           
         
           To create new environment variables, choose the choose the plus sign (
                
                 
                
                
             ):
           
              
               
              
              
           
         
       Environment variables remain encrypted when listed in the console code editor. If you enabled encryption helpers for encryption in transit, then those settings remain unchanged. For more information, see Securing Lambda environment variables.
The environment variables list is read-only and is available only on the Lambda console. This file is not included when you download the function's .zip file archive, and you can't add environment variables by uploading this file.
     
   AWS CLI
       The following example sets two environment variables on a function named my-function.
       aws lambda update-function-configuration \
  --function-name my-function \
  --environment "Variables={BUCKET=amzn-s3-demo-bucket,KEY=file.txt}"
       When you apply environment variables with the update-function-configuration command, the entire
         contents of the Variables structure is replaced. To retain existing environment variables when you
         add a new one, include all existing values in your request.
       To get the current configuration, use the get-function-configuration command.
       aws lambda get-function-configuration \
  --function-name my-function
       You should see the following output:
       {
    "FunctionName": "my-function",
    "FunctionArn": "arn:aws:lambda:us-east-2:111122223333:function:my-function",
    "Runtime": "nodejs22.x",
    "Role": "arn:aws:iam::111122223333:role/lambda-role",
    "Environment": {
        "Variables": {
            "BUCKET": "amzn-s3-demo-bucket",
            "KEY": "file.txt"
        }
    },
    "RevisionId": "0894d3c1-2a3d-4d48-bf7f-abade99f3c15",
    ...
}
       You can pass the revision ID from the output of get-function-configuration as a parameter to
         update-function-configuration. This ensures that the values don't change between when you read the
         configuration and when you update it.
       
       To configure a function's encryption key, set the KMSKeyARN option.
       aws lambda update-function-configuration \
  --function-name my-function \
  --kms-key-arn arn:aws:kms:us-east-2:111122223333:key/055efbb4-xmpl-4336-ba9c-538c7d31f599
     
   AWS SAM
       You can use the  AWS Serverless Application Model to configure environment variables for your function. Update the Environment and Variables properties in your template.yaml file and then run sam deploy.
       Example template.yamlAWSTemplateFormatVersion: '2010-09-09'
Transform: AWS::Serverless-2016-10-31
Description: An AWS Serverless Application Model template describing your function.
Resources:
  my-function:
    Type: AWS::Serverless::Function
    Properties:
      CodeUri: .
      Description: ''
      MemorySize: 128
      Timeout: 120
      Handler: index.handler
      Runtime: nodejs22.x
      Architectures:
        - x86_64
      EphemeralStorage:
        Size: 10240
      Environment:
        Variables:
          BUCKET: amzn-s3-demo-bucket
          KEY: file.txt
      # Other function properties...   
     
   AWS SDKs
       To manage environment variables using an AWS SDK, use the following API operations.
         
         
       
       
       
    UpdateFunctionConfigurationGetFunctionConfigurationCreateFunction
       To learn more, refer to the AWS SDK documentation for your preferred programming language.
     
 
   
    Example scenario for environment variables
    
    You can use environment variables to customize function behavior in your test environment and production
      environment. For example, you can create two functions with the same code but different configurations. One
      function connects to a test database, and the other connects to a production database. In this situation, you use
      environment variables to pass the hostname and other connection details for the database to the function. 
    The following example shows how to define the database host and database name as environment variables.
    
       
        
       
       
    
    If you want your test environment to generate more debug information than the production environment, you
      could set an environment variable to configure your test environment to use more verbose logging or more detailed
      tracing.
    For example, in your test environment, you could set an environment variable with the key LOG_LEVEL and a value indicating a log level of 
      debug or trace. In your Lambda function's code, you can then use this environment variable to set the log level.
    The following code examples in Python and Node.js illustrate how you can achieve this. These examples assume your environment variable has a 
      value of DEBUG in Python or debug in Node.js.
    
      Python
          Example Python code to set log levelimport os
import logging

# Initialize the logger
logger = logging.getLogger()

# Get the log level from the environment variable and default to INFO if not set
log_level = os.environ.get('LOG_LEVEL', 'INFO')

# Set the log level
logger.setLevel(log_level)

def lambda_handler(event, context):
    # Produce some example log outputs
    logger.debug('This is a log with detailed debug information - shown only in test environment')
    logger.info('This is a log with standard information - shown in production and test environments')
    

        
      Node.js (ES module format)
          Example Node.js code to set log levelThis example uses the winston logging library. Use npm to add this library to your function's deployment package. For more information, see
              Creating a .zip deployment package with dependencies.import winston from 'winston';

// Initialize the logger using the log level from environment variables, defaulting to INFO if not set
const logger = winston.createLogger({
   level: process.env.LOG_LEVEL || 'info',
   format: winston.format.json(),
   transports: [new winston.transports.Console()]
});

export const handler = async (event) => {
   // Produce some example log outputs
   logger.debug('This is a log with detailed debug information - shown only in test environment');
   logger.info('This is a log with standard information - shown in production and test environment');
   
};
        
    
   
    Retrieving Lambda environment variables
    To retrieve environment variables in your function code, use the standard method for your programming
      language.
    
      Node.js
          let region = process.env.AWS_REGION
        
      Python
          import os
  region = os.environ['AWS_REGION']
          NoteIn some cases, you may need to use the following format:region = os.environ.get('AWS_REGION')
        
      Ruby
          region = ENV["AWS_REGION"]
        
      Java
          String region = System.getenv("AWS_REGION");
        
      Go
          var region = os.Getenv("AWS_REGION")
        
      C#
          string region = Environment.GetEnvironmentVariable("AWS_REGION");
        
      PowerShell
          $region = $env:AWS_REGION
        
    
    
    Lambda stores environment variables securely by encrypting them at rest. You can configure Lambda to use a different encryption key, encrypt
      environment variable values on the client side, or set environment variables in an AWS CloudFormation template with
      AWS Secrets Manager.
   
    Defined runtime environment variables
    Lambda runtimes set several environment variables during initialization.
      Most of the environment variables provide information about the function or runtime. The keys for these
      environment variables are reserved and cannot be set in your function configuration.
    
      Reserved environment variables
       
       
       
       
       
       
       
       
       
       
       
       
       
       
    
        _HANDLER – The handler location configured on the function.
      
        _X_AMZN_TRACE_ID – The X-Ray tracing
          header. This environment variable changes with each invocation.
        
           
           
        
            This environment variable is not defined for OS-only runtimes (the provided runtime family).
              You can set _X_AMZN_TRACE_ID for custom runtimes using the
              Lambda-Runtime-Trace-Id response header from the
              Next invocation.
          
            For Java runtime versions 17 and later, this environment variable is not used.
              Instead, Lambda stores tracing information in the com.amazonaws.xray.traceHeader
              system property.
          
      
        AWS_DEFAULT_REGION – The default AWS Region where the Lambda function is executed.
      
        AWS_REGION – The AWS Region where the Lambda function is executed. If defined, this value overrides the AWS_DEFAULT_REGION.
        
           
        
            For more information about using the AWS Region environment variables with AWS SDKs, see AWS Region 
              in the AWS SDKs and Tools Reference Guide.
          
      
        AWS_EXECUTION_ENV – The runtime identifier,
          prefixed by AWS_Lambda_ (for example, AWS_Lambda_java8). This environment variable is not defined for OS-only runtimes (the provided runtime family).
      
        AWS_LAMBDA_FUNCTION_NAME – The name of the function.
      
        AWS_LAMBDA_FUNCTION_MEMORY_SIZE – The amount of memory available to the function in
          MB.
      
        AWS_LAMBDA_FUNCTION_VERSION – The version of the function being
          executed.
      
        AWS_LAMBDA_INITIALIZATION_TYPE – The initialization type of the function, which is on-demand, provisioned-concurrency, or snap-start. For information, see  Configuring provisioned concurrency or Improving startup performance with Lambda SnapStart.
      
        AWS_LAMBDA_LOG_GROUP_NAME, AWS_LAMBDA_LOG_STREAM_NAME – The name of the
          Amazon CloudWatch Logs group and stream for the function. The AWS_LAMBDA_LOG_GROUP_NAME and AWS_LAMBDA_LOG_STREAM_NAME environment variables are not available in Lambda SnapStart functions.
      
        AWS_ACCESS_KEY, AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY, AWS_SESSION_TOKEN
          – The access keys obtained from the function's execution
            role.
      
        AWS_LAMBDA_RUNTIME_API – (Custom runtime) The
          host and port of the runtime API.
      
        LAMBDA_TASK_ROOT – The path to your Lambda function code.
      
        LAMBDA_RUNTIME_DIR – The path to runtime libraries.
      
    The following additional environment variables aren't reserved and can be extended in your function
      configuration.
    
      Unreserved environment variables
       
       
       
       
       
       
       
       
       
       
    
        LANG – The locale of the runtime (en_US.UTF-8).
      
        PATH – The execution path
          (/usr/local/bin:/usr/bin/:/bin:/opt/bin).
      
        LD_LIBRARY_PATH – The system library path
          (/var/lang/lib:/lib64:/usr/lib64:$LAMBDA_RUNTIME_DIR:$LAMBDA_RUNTIME_DIR/lib:$LAMBDA_TASK_ROOT:$LAMBDA_TASK_ROOT/lib:/opt/lib).
      
        NODE_PATH – (Node.js) The Node.js library path
          (/opt/nodejs/node12/node_modules/:/opt/nodejs/node_modules:$LAMBDA_RUNTIME_DIR/node_modules).
      
        PYTHONPATH – (Python) The Python
          library path ($LAMBDA_RUNTIME_DIR).
      
        GEM_PATH – (Ruby) The Ruby library path
          ($LAMBDA_TASK_ROOT/vendor/bundle/ruby/3.3.0:/opt/ruby/gems/3.3.0).
      
        AWS_XRAY_CONTEXT_MISSING – For X-Ray tracing, Lambda sets this to
          LOG_ERROR to avoid throwing runtime errors from the X-Ray SDK.
      
        AWS_XRAY_DAEMON_ADDRESS – For X-Ray tracing, the IP address and port of the X-Ray
          daemon.
      
        AWS_LAMBDA_DOTNET_PREJIT – (.NET) Set this variable to enable or
          disable .NET specific runtime optimizations. Values include always, never, and
          provisioned-concurrency. For more information, see Configuring provisioned concurrency for a function.
      
        TZ – The environment's time zone (:UTC). The execution environment uses
          NTP to synchronize the system clock.
      
    The sample values shown reflect the latest runtimes. The presence of specific variables or their values can
      vary on earlier runtimes.
  Document ConventionsTimeoutSecuring environment variablesDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideCreating an execution role in the IAM consoleCreating and managing roles with the AWS CLIGrant least privilege access to your Lambda execution roleDefining Lambda function permissions with an execution roleA Lambda function's execution role is an AWS Identity and Access Management (IAM) role that grants the function permission to access
    AWS services and resources. For example, you might create an execution role that has permission to send logs to
    Amazon CloudWatch and upload trace data to AWS X-Ray. This page provides information on how to create, view, and manage a
    Lambda function's execution role.Lambda automatically assumes your execution role when you invoke your function. You should avoid manually
    calling sts:AssumeRole to assume the execution role in your function code. If your use case requires
    that the role assumes itself, you must include the role itself as a trusted principal in your role's trust policy.
    For more information on how to modify a role trust policy, see 
    Modifying a role trust policy (console) in the IAM User Guide.In order for Lambda to properly assume your execution role, the role's
    trust policy must specify the Lambda service principal
    (lambda.amazonaws.com) as a trusted service.TopicsCreating an execution role in the IAM consoleCreating and managing roles with the AWS CLIGrant least privilege access to your Lambda execution roleViewing and updating permissions in the execution roleWorking with AWS managed policies in the execution roleUsing source function ARN to control function access behavior
    Creating an execution role in the IAM console
    
    By default, Lambda creates an execution role with minimal permissions when you create a function in the Lambda console. Specifically,
      this execution role includes the AWSLambdaBasicExecutionRole managed policy, which gives your function
      basic permissions to log events to Amazon CloudWatch Logs.
    Your functions typically need additional permissions to perform more meaningful
      tasks. For example, you might have a Lambda function that responds to an event by updating
      entries in an Amazon DynamoDB database. You can create an execution role with the necessary
      permissions using the IAM console.
    To create an execution role in the IAM console
        Open the Roles page in the IAM console.
      
        Choose Create role.
      
        Under Trusted entity type, choose AWS service.
      
        Under Use case, choose Lambda.
      
        Choose Next.
      
        Select the AWS managed policies that you want to attach to your role.
          For example, if your function needs to access DynamoDB, select the
          AWSLambdaDynamoDBExecutionRole managed policy.
      
        Choose Next.
      
        Enter a Role name and then choose Create role.
      
    For detailed instructions, see Creating a role
      for an AWS service (console) in the IAM User Guide.
    After you create your execution role, attach it to your function. When you
      create a function in the Lambda console,
      you can attach any execution role that you previously created to the function. If you want
      to attach a new execution role to an existing function, follow the steps in Updating a function's execution role.
   
    Creating and managing roles with the AWS CLI
    To create an execution role with the AWS Command Line Interface (AWS CLI), use the create-role
      command. When using this command, you can specify the trust policy inline.
      A role's trust policy gives the specified principals permission to assume the role. In the
      following example, you grant the Lambda service principal permission to assume your role. Note that
      requirements for escaping quotes in the JSON string may vary depending on your shell.
    aws iam create-role \
  --role-name lambda-ex \
  --assume-role-policy-document '{"Version": "2012-10-17","Statement": [{ "Effect": "Allow", "Principal": {"Service": "lambda.amazonaws.com"}, "Action": "sts:AssumeRole"}]}'
    You can also define the trust policy for the role using a separate JSON file. In the following example,
      trust-policy.json is a file in the current directory.
    Example trust-policy.json{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Principal": {
        "Service": "lambda.amazonaws.com"
      },
      "Action": "sts:AssumeRole"
    }
  ]
}aws iam create-role \
  --role-name lambda-ex \
  --assume-role-policy-document file://trust-policy.json
    You should see the following output:
    {
    "Role": {
        "Path": "/",
        "RoleName": "lambda-ex",
        "RoleId": "AROAQFOXMPL6TZ6ITKWND",
        "Arn": "arn:aws:iam::123456789012:role/lambda-ex",
        "CreateDate": "2020-01-17T23:19:12Z",
        "AssumeRolePolicyDocument": {
            "Version": "2012-10-17",
            "Statement": [
                {
                    "Effect": "Allow",
                    "Principal": {
                        "Service": "lambda.amazonaws.com"
                    },
                    "Action": "sts:AssumeRole"
                }
            ]
        }
    }
}
    To add permissions to the role, use the attach-policy-to-role command. The following
      command adds the AWSLambdaBasicExecutionRole managed policy to the lambda-ex
      execution role.
    aws iam attach-role-policy --role-name lambda-ex --policy-arn arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
    After you create your execution role, attach it to your function. When you
      create a function in the Lambda console,
      you can attach any execution role that you previously created to the function. If you want
      to attach a new execution role to an existing function, follow the steps in Updating a function's execution role.
   
    Grant least privilege access to your Lambda execution role
    When you first create an IAM role for your Lambda function during the development phase, you might sometimes
      grant permissions beyond what is required. Before publishing your function in the production environment, as a
      best practice, adjust the policy to include only the required permissions. For more information, see Apply least-privilege
        permissions in the IAM User Guide.
    Use IAM Access Analyzer to help identify the required permissions for the IAM execution role policy. IAM Access Analyzer
      reviews your AWS CloudTrail logs over the date range that you specify and generates a policy template with only the
      permissions that the function used during that time. You can use the template to create a managed policy with
      fine-grained permissions, and then attach it to the IAM role. That way, you grant only the permissions that the
      role needs to interact with AWS resources for your specific use case.
    For more information, see Generate policies based on access
      activity in the IAM User Guide.
  Document ConventionsLambda permissionsUpdate execution roleDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideRequirementsUsing an AWS base imageUsing an AWS OS-only base imageUsing a non-AWS base imageRuntime interface clientsAmazon ECR permissionsFunction lifecycleCreate a Lambda function using a container imageYour AWS Lambda function's code consists of scripts or compiled programs and their dependencies. 
You use a deployment package to deploy your function code to Lambda. Lambda supports two types of deployment packages: 
container images and .zip file archives. There are three ways to build a container image for a Lambda function:
     
	 
     
  
      Using an AWS base image for Lambda
      The AWS base images are preloaded with a language runtime, a runtime interface client to manage the interaction between Lambda and your function code, and a runtime interface emulator for local testing.
    
      Using an AWS OS-only base image
      AWS OS-only base images contain an Amazon Linux distribution and the runtime interface emulator. These images are commonly used to create container images for compiled languages, such as Go and Rust, and for a language or language version that Lambda doesn't provide a base image for, such as Node.js 19. You can also use OS-only base images to implement a custom runtime. To make the image compatible with Lambda, you must include a runtime interface client for your language in the image.
    
      Using a non-AWS base image
      You can use an alternative base image from another container registry, such as Alpine Linux or Debian. You can also use a custom image created by your organization. To make the image compatible with Lambda, you must include a runtime interface client for your language in the image.
    TipTo reduce the time it takes for Lambda container functions to become active, see Use multi-stage builds in the Docker documentation. To build efficient container images, follow the Best practices for writing Dockerfiles.To create a Lambda function from a container image, build your image locally and upload it to an Amazon Elastic Container Registry
    (Amazon ECR) repository. If you're using a container image provided by an AWS Marketplace seller, you need to clone the
    image to your private Amazon ECR repository first. Then, specify the repository URI when you create the function.
    The Amazon ECR repository must be in the same AWS Region as the Lambda function. You can create a function using an image in a different AWS account, as long as the image is in the same Region as the Lambda function. For more information, see  Amazon ECR cross-account permissions.NoteLambda does not support Amazon ECR FIPS endpoints for container images. If your repository URI includes
      ecr-fips, you are using a FIPS endpoint. Example: 111122223333.dkr.ecr-fips.us-east-1.amazonaws.com.This page explains the base image types and requirements for creating Lambda-compatible container images.NoteYou cannot change the deployment package type (.zip or container image) for an existing function. For example, you cannot convert a container image function to use a .zip file archive. You must create a new function.TopicsRequirementsUsing an AWS base image for LambdaUsing an AWS OS-only base imageUsing a non-AWS base imageRuntime interface clientsAmazon ECR permissionsFunction lifecycle
    Requirements
    Install the AWS CLI version 2 and the Docker CLI. 
      Additionally, note the following requirements:
    
       
       
       
       
       
    
        The container image must implement the Using the Lambda runtime API for custom runtimes. The AWS
          open-source runtime interface clients implement the API. You can
          add a runtime interface client to your preferred base image to make it compatible with Lambda.
      
        The container image must be able to run on a read-only file system. Your function code can access a
          writable /tmp directory with between 512 MB and 10,240 MB, in 1-MB increments, of storage.  
      
        The default Lambda user must be able to read all the files required to run your function code. Lambda
          follows security best practices by defining a default Linux user with least-privileged permissions. This means that you don't need to specify a USER  in your Dockerfile. Verify
          that your application code does not rely on files that other Linux users are restricted from running.
      
        Lambda supports only Linux-based container images.
      
        Lambda provides multi-architecture base images. However, the image you build for your function must target
          only one of the architectures. Lambda does not support functions that use multi-architecture container
          images.
      
   
    Using an AWS base image for Lambda
    You can use one of the AWS base images for Lambda to build the container image for your
      function code. The base images are preloaded with a language runtime and other components
      required to run a container image on Lambda. You add your function code and dependencies to the
      base image and then package it as a container image.
    AWS periodically provides updates to the AWS base images for Lambda. If your Dockerfile includes the
      image name in the FROM property, your Docker client pulls the latest version of the image from the Amazon ECR repository. To
      use the updated base image, you must rebuild your container image and update the function code.
      The Node.js 20, Python 3.12, Java 21, .NET 8, Ruby 3.3, and later base images are based on the Amazon Linux 2023 minimal container image. Earlier base images use Amazon Linux 2. AL2023 provides several advantages over Amazon Linux 2, including a smaller deployment footprint and updated versions of libraries such as glibc.
    AL2023-based images use microdnf (symlinked as dnf) as the package manager instead of yum, which is the default package manager in Amazon Linux 2. microdnf is a standalone implementation of dnf. For a list of packages that are included in AL2023-based images, refer to the Minimal Container columns in Comparing packages installed on Amazon Linux 2023 Container Images. For more information about the differences between AL2023 and Amazon Linux 2, see Introducing the Amazon Linux 2023 runtime for AWS Lambda on the AWS
      Compute Blog.    
    NoteTo run AL2023-based images locally, including with AWS Serverless Application Model (AWS SAM), you must use Docker version 20.10.10 or later.  
    To build a container image using an AWS base image, choose the instructions for your preferred language:
    
       
       
       
       
       
       
       
    
        Node.js
      
        TypeScript (uses a Node.js base image) 
      
        Python
      
        Java 
      
        Go
      
        .NET
      
        Ruby
      
   
    Using an AWS OS-only base image
    AWS OS-only base images contain an Amazon Linux distribution and the runtime interface emulator. These images are commonly used to create container images for compiled languages, such as Go and Rust, and for a language or language version that Lambda doesn't provide a base image for, such as Node.js 19. You can also use OS-only base images to implement a custom runtime. To make the image compatible with Lambda, you must include a runtime interface client for your language in the image.
    
          
            Tags
            Runtime
            Operating system
            Dockerfile
            Deprecation
          
        
      
            al2023
            OS-only Runtime
            Amazon Linux 2023
            Dockerfile
                for OS-only Runtime on GitHub
            
                          Jun 30, 2029
            
              
          
      
            al2
            OS-only Runtime
            Amazon Linux 2
            Dockerfile
                for OS-only Runtime on GitHub
            
                          Jun 30, 2026
            
              
          
    
    Amazon Elastic Container Registry Public Gallery: gallery.ecr.aws/lambda/provided
     
    Using a non-AWS base image
    Lambda
      supports any image that conforms to one of the following image manifest formats:
    
       
       
    Docker image manifest V2, schema 2 (used with Docker version 1.10 and newer)Open Container Initiative (OCI) Specifications (v1.0.0 and up)
    Lambda supports a maximum uncompressed image size of 10 GB, including all layers.
    NoteTo make the image compatible with Lambda, you must include a runtime interface client for your language in the image.
   
    Runtime interface clients
    If you use an OS-only base image or an alternative base image, you must include a runtime interface client in your image. The runtime interface client must extend the Using the Lambda runtime API for custom runtimes, which manages the interaction between Lambda and your function code. AWS provides open-source runtime interface clients for the following languages:
    
  
   
  
   
  
   
  
   
  
   
  
   
  
     

    
      Node.js
    
  
    
      Python
    
  
    
      Java
    
  
    
      .NET
    
  
    
      Go
    
  
    
      Ruby
    
  
    
      Rust – The Rust runtime client is an experimental package. It is subject to change and intended only for evaluation purposes.
    
  
    If you're using a language that doesn't have an AWS-provided runtime interface client, you must create your own.
   
    Amazon ECR permissions
    Before you create a Lambda function from a container image, you must build the image locally and upload it to an Amazon ECR repository. When you create the function, specify the Amazon ECR repository URI.
    Make sure that the permissions for the user or role that creates the function includes GetRepositoryPolicy and SetRepositoryPolicy.
    For example, use the IAM console to create a role with the following policy:
    {
  "Version": "2012-10-17",
  "Statement": [
    {
      "Sid": "VisualEditor0",
      "Effect": "Allow",
      "Action": [
        "ecr:SetRepositoryPolicy",
        "ecr:GetRepositoryPolicy"
      ],
      "Resource": "arn:aws:ecr:us-east-1:111122223333:repository/hello-world"
    }
  ]
}
     
      Amazon ECR repository policies
      For a function in the same account as the container image in Amazon ECR, you can add ecr:BatchGetImage
        and ecr:GetDownloadUrlForLayer permissions to your Amazon ECR repository policy. The following example shows the
        minimum policy:
      {
        "Sid": "LambdaECRImageRetrievalPolicy",
        "Effect": "Allow",
        "Principal": {
          "Service": "lambda.amazonaws.com"
        },
        "Action": [
          "ecr:BatchGetImage",
          "ecr:GetDownloadUrlForLayer"
        ]
    }   
      For more information about Amazon ECR
        repository permissions, see Private repository policies in the
        Amazon Elastic Container Registry User Guide.
      If the Amazon ECR repository does not include these permissions, Lambda attempts to add them automatically. Lambda can add
        permissions only if the principal calling Lambda has ecr:getRepositoryPolicy and
          ecr:setRepositoryPolicy permissions. 
      To view or edit your Amazon ECR repository permissions, follow the directions in Setting a private repository policy statement in the
          Amazon Elastic Container Registry User Guide.
       
         Amazon ECR cross-account permissions
        A different account in the same region can create a function that uses a container image owned by your
          account. In the following example, your Amazon ECR repository permissions policy needs the following statements to
          grant access to account number 123456789012.
        
           
           
        CrossAccountPermission – Allows account 123456789012 to create and update Lambda
              functions that use images from this ECR repository.LambdaECRImageCrossAccountRetrievalPolicy – Lambda will eventually set a
              function's state to inactive if it is not invoked for an extended period. This statement is required so that
              Lambda can retrieve the container image for optimization and caching on behalf of the function owned by
              123456789012.  
        Example — Add cross-account permission to your repository{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Sid": "CrossAccountPermission",
      "Effect": "Allow",
      "Action": [
        "ecr:BatchGetImage",
        "ecr:GetDownloadUrlForLayer"
      ],
      "Principal": {
        "AWS": "arn:aws:iam::123456789012:root"
      }
    },
    {
      "Sid": "LambdaECRImageCrossAccountRetrievalPolicy",
      "Effect": "Allow",
      "Action": [
        "ecr:BatchGetImage",
        "ecr:GetDownloadUrlForLayer"
      ],
      "Principal": {
        "Service": "lambda.amazonaws.com"
      },
      "Condition": {
        "StringLike": {
          "aws:sourceARN": "arn:aws:lambda:us-east-1:123456789012:function:*"
        }
      }
    }
  ]
}
        To give access to multiple accounts, you add the account IDs to the Principal list in the
            CrossAccountPermission policy and to the Condition evaluation list in the
            LambdaECRImageCrossAccountRetrievalPolicy.
        If you are working with multiple accounts in an AWS Organization, we recommend that you enumerate each
          account ID in the ECR permissions policy. This approach aligns with the AWS security best practice of setting
          narrow permissions in IAM policies.
        In addition to Lambda permissions, the user or role that creates the function must also have BatchGetImage and GetDownloadUrlForLayer permissions.
       
     
   
    Function lifecycle
    After you upload a new or updated container image, Lambda optimizes the image before the function can process invocations. The
      optimization process can take a few seconds. The function remains in the Pending state until the
      process completes, when the state transitions to Active. You can't invoke the function until it reaches the Active state. 
    If a function is not invoked for multiple weeks, Lambda reclaims its optimized version, and the function
      transitions to the Inactive state. To reactivate the function, you must invoke it. Lambda rejects the
      first invocation and the function enters the Pending state until Lambda re-optimizes the image. The
      function then returns to the Active state.
    Lambda periodically fetches the associated container image from the Amazon ECR repository. If the
      corresponding container image no longer exists on Amazon ECR or permissions are revoked, the function enters the Failed state, and
      Lambda returns a failure for any function invocations.
    You can use the Lambda API to get information about a function's state. For more information, see Lambda function states.
  Document ConventionsEncryptionMemoryDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideNext invocationInvocation responseInitialization errorInvocation errorUsing the Lambda runtime API for custom runtimesAWS Lambda provides an HTTP API for custom runtimes to receive invocation
    events from Lambda and send response data back within the Lambda execution
      environment. This section contains the API reference for the Lambda runtime API.
     
      
     
     
  The OpenAPI specification for the runtime API version 2018-06-01 is available
    in runtime-api.zipTo create an API request URL, runtimes get the API endpoint from the AWS_LAMBDA_RUNTIME_API environment variable, add the API version,
    and add the desired resource path.Example Requestcurl "http://${AWS_LAMBDA_RUNTIME_API}/2018-06-01/runtime/invocation/next"API methodsNext invocationInvocation responseInitialization errorInvocation error
    Next invocation
    Path – /runtime/invocation/next
    Method – GET
    The runtime sends this message to Lambda to request an invocation event. The response body contains the payload
      from the invocation, which is a JSON document that contains event data from the function trigger. The response
      headers contain additional data about the invocation.
    
      Response headers
       
       
       
       
       
       
    
        Lambda-Runtime-Aws-Request-Id – The request ID, which identifies the request that
          triggered the function invocation.
        For example, 8476a536-e9f4-11e8-9739-2dfe598c3fcd.
      
        Lambda-Runtime-Deadline-Ms – The date that the function times out in Unix time
          milliseconds. 
        For example, 1542409706888.
      
        Lambda-Runtime-Invoked-Function-Arn – The ARN of the Lambda function, version, or alias
          that's specified in the invocation. 
        For example, arn:aws:lambda:us-east-2:123456789012:function:custom-runtime.
      
        Lambda-Runtime-Trace-Id – The AWS X-Ray tracing header. 
        For example,
          Root=1-5bef4de7-ad49b0e87f6ef6c87fc2e700;Parent=9a9197af755a6419;Sampled=1.
      
        Lambda-Runtime-Client-Context – For invocations from the AWS Mobile SDK, data about
          the client application and device.
      
        Lambda-Runtime-Cognito-Identity – For invocations from the AWS Mobile SDK, data about
          the Amazon Cognito identity provider.
      
    
    Do not set a timeout on the GET request as the response may be delayed. Between when Lambda bootstraps the runtime and
      when the runtime has an event to return, the runtime process may be frozen for several seconds.
    
    The request ID tracks the invocation within Lambda. Use it to specify the invocation when you send the
      response.
    
    The tracing header contains the trace ID, parent ID, and sampling decision. If the request is sampled, the
      request was sampled by Lambda or an upstream service. The runtime should set the _X_AMZN_TRACE_ID with
      the value of the header. The X-Ray SDK reads this to get the IDs and determine whether to trace the
      request.
   
    Invocation response
    Path –
          /runtime/invocation/AwsRequestId/response
    Method – POST
    After the function has run to completion, the runtime sends an invocation response to Lambda.  For synchronous
      invocations, Lambda sends the response to the client.
    Example success requestREQUEST_ID=156cb537-e2d4-11e8-9b34-d36013741fb9
curl "http://${AWS_LAMBDA_RUNTIME_API}/2018-06-01/runtime/invocation/$REQUEST_ID/response"  -d "SUCCESS"
   
    Initialization error
    If the function returns an error or the runtime encounters an error during initialization, the runtime uses
      this method to report the error to Lambda.
    Path – /runtime/init/error
    Method – POST
    Headers
    Lambda-Runtime-Function-Error-Type – Error type that the runtime encountered. Required:
      no. 
    
  This header consists of a string value. Lambda accepts any string, but we recommend a format of
    <category.reason>. For example:
    
       
       
       
       
    Runtime.NoSuchHandlerRuntime.APIKeyNotFoundRuntime.ConfigInvalidRuntime.UnknownReason   

    Body parameters
    ErrorRequest – Information about the error.
      Required: no. 
    
    This field is a JSON object with the following structure:
    {
      errorMessage: string (text description of the error),
      errorType: string,
      stackTrace: array of strings
}    
Note that Lambda accepts any value for errorType.  
 The following example shows a Lambda function error message in which the function could not parse the event data
    provided in the invocation.
    Example Function error{
      "errorMessage" : "Error parsing event data.",
      "errorType" : "InvalidEventDataException",
      "stackTrace": [ ]
}      

    
        Response body parameters
         
         
    StatusResponse – String. Status information, sent with 202 response codes. ErrorResponse – Additional error information, sent with the error response codes.
          ErrorResponse contains an error type and an error message.
    
      Response codes
       
       
       
    
        202 – Accepted
      
        403 – Forbidden
      
        500 – Container error. Non-recoverable state. Runtime should exit promptly.
      
    Example initialization error requestERROR="{\"errorMessage\" : \"Failed to load function.\", \"errorType\" : \"InvalidFunctionException\"}"
curl "http://${AWS_LAMBDA_RUNTIME_API}/2018-06-01/runtime/init/error" -d "$ERROR" --header "Lambda-Runtime-Function-Error-Type: Unhandled"
   
    Invocation error
    If the function returns an error or the runtime encounters an error, the runtime uses this method to report
      the error to Lambda.
    Path –
      /runtime/invocation/AwsRequestId/error
    Method – POST
    Headers
    Lambda-Runtime-Function-Error-Type – Error type that the runtime encountered. Required:
      no. 
    
  This header consists of a string value. Lambda accepts any string, but we recommend a format of
    <category.reason>. For example:
    
       
       
       
       
    Runtime.NoSuchHandlerRuntime.APIKeyNotFoundRuntime.ConfigInvalidRuntime.UnknownReason   

    Body parameters
    ErrorRequest – Information about the error.
      Required: no. 
    
    This field is a JSON object with the following structure:
    {
      errorMessage: string (text description of the error),
      errorType: string,
      stackTrace: array of strings
}    
Note that Lambda accepts any value for errorType.  
 The following example shows a Lambda function error message in which the function could not parse the event data
    provided in the invocation.
    Example Function error{
      "errorMessage" : "Error parsing event data.",
      "errorType" : "InvalidEventDataException",
      "stackTrace": [ ]
}      

    
      Response body parameters
       
       
    StatusResponse – String. Status information, sent with 202 response codes. ErrorResponse – Additional error information, sent with the error response codes.
       ErrorResponse contains an error type and an error message.
    
      Response codes
       
       
       
       
    
        202 – Accepted
      
        400 – Bad Request
      
        403 – Forbidden
      
        500 – Container error. Non-recoverable state. Runtime should exit promptly.
      
    Example error requestREQUEST_ID=156cb537-e2d4-11e8-9b34-d36013741fb9
ERROR="{\"errorMessage\" : \"Error parsing event data.\", \"errorType\" : \"InvalidEventDataException\"}"
curl "http://${AWS_LAMBDA_RUNTIME_API}/2018-06-01/runtime/invocation/$REQUEST_ID/error" -d "$ERROR" --header "Lambda-Runtime-Function-Error-Type: Unhandled"
  Document ConventionsRuntime modificationsOS-only runtimesDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS Serverless Application ModelDeveloper GuideKey featuresRelated informationWhat is the AWS Serverless Application Model (AWS SAM)?AWS Serverless Application Model (AWS SAM) is an open-source framework for building serverless applications using infrastructure as code (IaC). 
		With AWS SAM’s shorthand syntax, developers declare AWS CloudFormation resources and specialized serverless resources that are transformed to 
		infrastructure during deployment. This framework includes two main components: the AWS SAM CLI and the AWS SAM project. The AWS SAM project is the 
		application project directory that is created when you run sam init. The AWS SAM project includes files like the AWS SAM template, which includes the template specification
		(the shorthand syntax you use to declare resources).
		Key features
	AWS SAM offers a variety of benefits that improve the developer experience by allowing you to: 
	
	
		
		 
		
		 
		
		 
		
		 
		
		 
	
			Define your application infrastructure code quickly, using less code
			
				Author AWS SAM templates to define your serverless application infrastructure code.
					Deploy your templates directly to AWS CloudFormation to provision your resources.
			
		
			Manage your serverless applications through their entire development lifecycle
			
				Use the AWS SAM CLI to manage your serverless application through the authoring,
					building, deploying, testing, and monitoring phases of your development lifecycle. For
					more information, see The AWS SAM CLI.
			
		
			Quickly provision permissions between resources with AWS SAM connectors
			
				Use AWS SAM connectors in your AWS SAM templates to define permissions between your
					AWS resources. AWS SAM transforms your code into the IAM permissions required to
					facilitate your intent. For more information, see Managing resource permissions with AWS SAM
      connectors.
			
		
			Continuously sync local changes to the cloud as you develop
			
				Use the AWS SAM CLI sam sync command to automatically sync local
					changes to the cloud, speeding up your development and cloud testing workflows. For more
					information, see Introduction to using sam sync to sync to AWS Cloud.
			
		
			Manage your Terraform serverless applications
			
				Use the AWS SAM CLI to perform local debugging and testing of your Lambda functions and
					layers. For more information, see AWS SAM CLI Terraform support.
			
		
	 
		Related information
		
			 
			 
			 
		For information on how AWS SAM works, see How AWS SAM works.To start using AWS SAM, see Getting started with AWS SAM. For an overview on how you can use AWS SAM to create a serverless application, see How to use AWS SAM.
	Document ConventionsHow it worksDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS Serverless Application ModelDeveloper GuideInitialize a new serverless applicationOptions for sam initTroubleshootingExamplesLearn moreNext stepsCreate your application in AWS SAMAfter completing Getting started
		and reading How to use AWS Serverless Application Model (AWS SAM), you will be ready to create an 
		AWS SAM project in your developer environment. Your AWS SAM project will serve as the 
		starting point for writing your serverless application. For a list of AWS SAM CLI sam init command options, see sam init.The AWS Serverless Application Model Command Line Interface (AWS SAM CLI) sam init command provides options to initialize a new 
		serverless application that consists of:
		 
		 
		 
	
			An AWS SAM template to define your infrastructure code.
		
			A folder structure that organizes your application.
		
			Configuration for your AWS Lambda functions.
		To create an AWS SAM project, refer to the topics in this sections.TopicsInitialize a new serverless applicationOptions for sam initTroubleshootingExamplesLearn moreNext steps
		Initialize a new serverless application
		To initialize a new serverless application using the AWS SAM CLI
				cd to a starting directory.
			
				Run the following at the command line:
				$ sam init
			
				The AWS SAM CLI will guide you through an interactive flow to create a new serverless application.
				NoteAs detailed in Tutorial: Deploy a Hello World application with AWS SAM, this command 
					initializes your serverless application, creating your project directory. This directory will contain several files and folders. The most important 
					file is template.yaml. This is your AWS SAM template. Your version of python must match the version of python listed in the 
					template.yaml file that the sam init command created.
			
		
		 
			Choose a starting template
			A template consists of the following:
			
				 
				 
			
					An AWS SAM template for your infrastructure code.
				
					A starting project directory that organizes your project files. For example, this may include:
					
						 
						 
						 
						 
						 
					
							A structure for your Lambda function code and their dependencies.
						
							An events folder that contains test events for local testing.
						
							A tests folder to support unit testing.
						
							A samconfig.toml file to configure project settings.
						
							A ReadMe file and other basic starting project files.
						
					The following is an example of a starting project directory:
					sam-app
├── README.md
├── __init__.py
├── events
│   └── event.json
├── hello_world
│   ├── __init__.py
│   ├── app.py
│   └── requirements.txt
├── samconfig.toml
├── template.yaml
└── tests
    ├── __init__.py
    ├── integration
    │   ├── __init__.py
    │   └── test_api_gateway.py
    ├── requirements.txt
    └── unit
        ├── __init__.py
        └── test_handler.py
				
			You can select from a list of available AWS Quick Start Templates or provide your own 
				Custom Template Location.
			To choose an AWS Quick Start Template
					When prompted, select AWS Quick Start Templates.
				
					Select an AWS Quick Start template to begin with. The following is an example:
					Which template source would you like to use?
    1 - AWS Quick Start Templates
    2 - Custom Template Location
Choice: 1

Choose an AWS Quick Start application template
    1 - Hello World Example
    2 - Multi-step workflow
    3 - Serverless API
    4 - Scheduled task
    5 - Standalone function
    6 - Data processing
    7 - Hello World Example With Powertools
    8 - Infrastructure event management
    9 - Serverless Connector Hello World Example
    10 - Multi-step workflow with Connectors
    11 - Lambda EFS example
    12 - DynamoDB Example
    13 - Machine Learning
Template: 4
				
			To choose your own custom template location
					When prompted, select the Custom Template Location.
					Which template source would you like to use?
    1 - AWS Quick Start Templates
    2 - Custom Template Location
Choice: 2
				
					The AWS SAM CLI will prompt you to provide a template location.
					Template location (git, mercurial, http(s), zip, path):
					Provide any of the following locations to your template .zip file archive:
					
						 
						 
						 
					
							GitHub repository – The path to the 
								.zip file in your GitHub repository. The file must be in the root of your 
								repository.
						
							Mercurial repository – The path to the 
								.zip file in your Mercurial repository. The file must be in the root of your repository.
						
							.zip path – An HTTPS or local path to your .zip file.
						
				
					The AWS SAM CLI will initialize your serverless application using your custom template.
				
		 
		
		 
			Choose a runtime
			When you choose an AWS Quick Start Template, the AWS SAM CLI prompts you to select a runtime 
				for your Lambda functions. The list of options displayed by the AWS SAM CLI are the runtimes supported natively by 
				Lambda.
			
				 
				 
			
					The runtime provides a 
						language-specific environment that runs in an execution environment.
				
					When deployed to the AWS Cloud, the Lambda service invokes your function in an execution environment.
				
			You can use any other programming language with a custom runtime. To do this, you need to manually create your
				starting application structure. You can then use sam init to quickly initialize your application by
				configuring a custom template location.
			From your selection, the AWS SAM CLI creates the starting directory for your Lambda function code and 
				dependencies.
			If Lambda supports multiple dependency managers for your runtime, you will be prompted to choose your preferred 
				dependency manager.
		 
		
		 
			Choose a package type
			When you choose an AWS Quick Start Template and a runtime, the 
				AWS SAM CLI prompts you to select a package type. The package type determines how your Lambda 
				functions are deployed to use with the Lambda service. The two supported package types are:
			
				 
				 
			
					Container image – Contains the base operating system, the runtime, 
						Lambda extensions, your application code, and its dependencies.
				
					.zip file archive – Contains your application code and its 
						dependencies.
				
			To learn more about deployment package types, see Lambda deployment packages in the 
				AWS Lambda Developer Guide.
			The following is an example directory structure of an application with a Lambda function packaged as a container 
				image. The AWS SAM CLI downloads the image and creates a Dockerfile in the function's directory to
				specify the image.
			sam-app
├── README.md
├── __init__.py
├── events
│   └── event.json
├── hello_world
│   ├── Dockerfile
│   ├── __init__.py
│   ├── app.py
│   └── requirements.txt
├── samconfig.toml
├── template.yaml
└── tests
    ├── __init__.py
    └── unit
        ├── __init__.py
        └── test_handler.py
			The following is an example directory structure of an application with a function packaged as a .zip file 
				archive.
			sam-app
├── README.md
├── __init__.py
├── events
│   └── event.json
├── hello_world
│   ├── __init__.py
│   ├── app.py
│   └── requirements.txt
├── samconfig.toml
├── template.yaml
└── tests
    ├── __init__.py
    ├── integration
    │   ├── __init__.py
    │   └── test_api_gateway.py
    ├── requirements.txt
    └── unit
        ├── __init__.py
        └── test_handler.py
		 
		
		 
			Configure AWS X-Ray tracing
			You can choose to activate AWS X-Ray tracing. To learn more, see What is AWS X-Ray? in the 
				AWS X-Ray Developer Guide.
			If you activate, the AWS SAM CLI configures your AWS SAM template. The following is an example:
			Globals:
  Function:
    ...
    Tracing: Active
  Api:
    TracingEnabled: True
		 
		
		 
			Configure monitoring with Amazon CloudWatch Application Insights
			You can choose to activate monitoring using Amazon CloudWatch Application Insights. To learn more, see Amazon CloudWatch 
				Application Insights in the Amazon CloudWatch User Guide.
			If you activate, the AWS SAM CLI configures your AWS SAM template. The following is an example:
			Resources:
  ApplicationResourceGroup:
    Type: AWS::ResourceGroups::Group
    Properties:
      Name:
        Fn::Join:
        - ''
        - - ApplicationInsights-SAM-
          - Ref: AWS::StackName
      ResourceQuery:
        Type: CLOUDFORMATION_STACK_1_0
  ApplicationInsightsMonitoring:
    Type: AWS::ApplicationInsights::Application
    Properties:
      ResourceGroupName:
        Fn::Join:
        - ''
        - - ApplicationInsights-SAM-
          - Ref: AWS::StackName
      AutoConfigurationEnabled: 'true'
    DependsOn: ApplicationResourceGroup
		 
		
		 
			Name your application
			Provide a name for your application. The AWS SAM CLI creates a top-level folder for your application using this 
				name.
		 
	 
		Options for sam init
		The following are some of the main options you can use with the sam init command. For a list of all 
			options, see sam init.
		
		 
			Initialize an application using a custom template location
			Use the --location option and provide a supported custom template location. The following is an 
				example:
			$ sam init --location https://github.com/aws-samples/sessions-with-aws-sam/raw/master/starter-templates/web-app.zip
		 
		
		 
			Initialize an application without the interactive 
					flow
			Use the --no-interactive option and provide your configuration choices at the command line to skip 
				the interactive flow. The following is an example:
			$ sam init --no-interactive --runtime go1.x --name go-demo --dependency-manager mod --app-template hello-world
		 
	 
		Troubleshooting
		To troubleshoot the AWS SAM CLI, see AWS SAM CLI troubleshooting.
	 
		Examples
		
		 
			Initialize a new serverless application using the 
					Hello World AWS Starter Template
			For this example, see 
				Step 1: Initialize the sample Hello World application in Tutorial: Deploying a Hello World 
					application.
		 
		
		 
			Initialize a new serverless application with a custom 
					template location
			The following are examples of providing a GitHub location to your custom template:
			$ sam init --location gh:aws-samples/cookiecutter-aws-sam-python
$ sam init --location git+sh://git@github.com/aws-samples/cookiecutter-aws-sam-python.git
$ sam init --location hg+ssh://hg@bitbucket.org/repo/template-name
			The following is an example of a local file path:
			$ sam init --location /path/to/template.zip
			The following is an example of a path reachable by HTTPS:
			$ sam init --location https://github.com/aws-samples/sessions-with-aws-sam/raw/master/starter-templates/web-app.zip
		 
	 
		Learn more
		To learn more about using the sam init command, see the following:
		
			 
			 
		
				Learning AWS SAM: sam init
				 – Serverless Land "Learning AWS SAM" series on YouTube.
			
				Structuring serverless 
					applications for use with the AWS SAM CLI (Sessions with SAM S2E7) – Sessions with AWS SAM
					series on YouTube.
			
	 
		Next steps
		Now that you have created your AWS SAM project, you are ready to start authoring your application. 
			See Define your infrastructure with AWS SAM for detailed instructions on the tasks you need to complete to do this.
	Document ConventionsDevelop your applicationDefine your infrastructureDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS Serverless Application ModelDeveloper GuideInitialize a new serverless applicationOptions for sam initTroubleshootingExamplesLearn moreNext stepsCreate your application in AWS SAMAfter completing Getting started
		and reading How to use AWS Serverless Application Model (AWS SAM), you will be ready to create an 
		AWS SAM project in your developer environment. Your AWS SAM project will serve as the 
		starting point for writing your serverless application. For a list of AWS SAM CLI sam init command options, see sam init.The AWS Serverless Application Model Command Line Interface (AWS SAM CLI) sam init command provides options to initialize a new 
		serverless application that consists of:
		 
		 
		 
	
			An AWS SAM template to define your infrastructure code.
		
			A folder structure that organizes your application.
		
			Configuration for your AWS Lambda functions.
		To create an AWS SAM project, refer to the topics in this sections.TopicsInitialize a new serverless applicationOptions for sam initTroubleshootingExamplesLearn moreNext steps
		Initialize a new serverless application
		To initialize a new serverless application using the AWS SAM CLI
				cd to a starting directory.
			
				Run the following at the command line:
				$ sam init
			
				The AWS SAM CLI will guide you through an interactive flow to create a new serverless application.
				NoteAs detailed in Tutorial: Deploy a Hello World application with AWS SAM, this command 
					initializes your serverless application, creating your project directory. This directory will contain several files and folders. The most important 
					file is template.yaml. This is your AWS SAM template. Your version of python must match the version of python listed in the 
					template.yaml file that the sam init command created.
			
		
		 
			Choose a starting template
			A template consists of the following:
			
				 
				 
			
					An AWS SAM template for your infrastructure code.
				
					A starting project directory that organizes your project files. For example, this may include:
					
						 
						 
						 
						 
						 
					
							A structure for your Lambda function code and their dependencies.
						
							An events folder that contains test events for local testing.
						
							A tests folder to support unit testing.
						
							A samconfig.toml file to configure project settings.
						
							A ReadMe file and other basic starting project files.
						
					The following is an example of a starting project directory:
					sam-app
├── README.md
├── __init__.py
├── events
│   └── event.json
├── hello_world
│   ├── __init__.py
│   ├── app.py
│   └── requirements.txt
├── samconfig.toml
├── template.yaml
└── tests
    ├── __init__.py
    ├── integration
    │   ├── __init__.py
    │   └── test_api_gateway.py
    ├── requirements.txt
    └── unit
        ├── __init__.py
        └── test_handler.py
				
			You can select from a list of available AWS Quick Start Templates or provide your own 
				Custom Template Location.
			To choose an AWS Quick Start Template
					When prompted, select AWS Quick Start Templates.
				
					Select an AWS Quick Start template to begin with. The following is an example:
					Which template source would you like to use?
    1 - AWS Quick Start Templates
    2 - Custom Template Location
Choice: 1

Choose an AWS Quick Start application template
    1 - Hello World Example
    2 - Multi-step workflow
    3 - Serverless API
    4 - Scheduled task
    5 - Standalone function
    6 - Data processing
    7 - Hello World Example With Powertools
    8 - Infrastructure event management
    9 - Serverless Connector Hello World Example
    10 - Multi-step workflow with Connectors
    11 - Lambda EFS example
    12 - DynamoDB Example
    13 - Machine Learning
Template: 4
				
			To choose your own custom template location
					When prompted, select the Custom Template Location.
					Which template source would you like to use?
    1 - AWS Quick Start Templates
    2 - Custom Template Location
Choice: 2
				
					The AWS SAM CLI will prompt you to provide a template location.
					Template location (git, mercurial, http(s), zip, path):
					Provide any of the following locations to your template .zip file archive:
					
						 
						 
						 
					
							GitHub repository – The path to the 
								.zip file in your GitHub repository. The file must be in the root of your 
								repository.
						
							Mercurial repository – The path to the 
								.zip file in your Mercurial repository. The file must be in the root of your repository.
						
							.zip path – An HTTPS or local path to your .zip file.
						
				
					The AWS SAM CLI will initialize your serverless application using your custom template.
				
		 
		
		 
			Choose a runtime
			When you choose an AWS Quick Start Template, the AWS SAM CLI prompts you to select a runtime 
				for your Lambda functions. The list of options displayed by the AWS SAM CLI are the runtimes supported natively by 
				Lambda.
			
				 
				 
			
					The runtime provides a 
						language-specific environment that runs in an execution environment.
				
					When deployed to the AWS Cloud, the Lambda service invokes your function in an execution environment.
				
			You can use any other programming language with a custom runtime. To do this, you need to manually create your
				starting application structure. You can then use sam init to quickly initialize your application by
				configuring a custom template location.
			From your selection, the AWS SAM CLI creates the starting directory for your Lambda function code and 
				dependencies.
			If Lambda supports multiple dependency managers for your runtime, you will be prompted to choose your preferred 
				dependency manager.
		 
		
		 
			Choose a package type
			When you choose an AWS Quick Start Template and a runtime, the 
				AWS SAM CLI prompts you to select a package type. The package type determines how your Lambda 
				functions are deployed to use with the Lambda service. The two supported package types are:
			
				 
				 
			
					Container image – Contains the base operating system, the runtime, 
						Lambda extensions, your application code, and its dependencies.
				
					.zip file archive – Contains your application code and its 
						dependencies.
				
			To learn more about deployment package types, see Lambda deployment packages in the 
				AWS Lambda Developer Guide.
			The following is an example directory structure of an application with a Lambda function packaged as a container 
				image. The AWS SAM CLI downloads the image and creates a Dockerfile in the function's directory to
				specify the image.
			sam-app
├── README.md
├── __init__.py
├── events
│   └── event.json
├── hello_world
│   ├── Dockerfile
│   ├── __init__.py
│   ├── app.py
│   └── requirements.txt
├── samconfig.toml
├── template.yaml
└── tests
    ├── __init__.py
    └── unit
        ├── __init__.py
        └── test_handler.py
			The following is an example directory structure of an application with a function packaged as a .zip file 
				archive.
			sam-app
├── README.md
├── __init__.py
├── events
│   └── event.json
├── hello_world
│   ├── __init__.py
│   ├── app.py
│   └── requirements.txt
├── samconfig.toml
├── template.yaml
└── tests
    ├── __init__.py
    ├── integration
    │   ├── __init__.py
    │   └── test_api_gateway.py
    ├── requirements.txt
    └── unit
        ├── __init__.py
        └── test_handler.py
		 
		
		 
			Configure AWS X-Ray tracing
			You can choose to activate AWS X-Ray tracing. To learn more, see What is AWS X-Ray? in the 
				AWS X-Ray Developer Guide.
			If you activate, the AWS SAM CLI configures your AWS SAM template. The following is an example:
			Globals:
  Function:
    ...
    Tracing: Active
  Api:
    TracingEnabled: True
		 
		
		 
			Configure monitoring with Amazon CloudWatch Application Insights
			You can choose to activate monitoring using Amazon CloudWatch Application Insights. To learn more, see Amazon CloudWatch 
				Application Insights in the Amazon CloudWatch User Guide.
			If you activate, the AWS SAM CLI configures your AWS SAM template. The following is an example:
			Resources:
  ApplicationResourceGroup:
    Type: AWS::ResourceGroups::Group
    Properties:
      Name:
        Fn::Join:
        - ''
        - - ApplicationInsights-SAM-
          - Ref: AWS::StackName
      ResourceQuery:
        Type: CLOUDFORMATION_STACK_1_0
  ApplicationInsightsMonitoring:
    Type: AWS::ApplicationInsights::Application
    Properties:
      ResourceGroupName:
        Fn::Join:
        - ''
        - - ApplicationInsights-SAM-
          - Ref: AWS::StackName
      AutoConfigurationEnabled: 'true'
    DependsOn: ApplicationResourceGroup
		 
		
		 
			Name your application
			Provide a name for your application. The AWS SAM CLI creates a top-level folder for your application using this 
				name.
		 
	 
		Options for sam init
		The following are some of the main options you can use with the sam init command. For a list of all 
			options, see sam init.
		
		 
			Initialize an application using a custom template location
			Use the --location option and provide a supported custom template location. The following is an 
				example:
			$ sam init --location https://github.com/aws-samples/sessions-with-aws-sam/raw/master/starter-templates/web-app.zip
		 
		
		 
			Initialize an application without the interactive 
					flow
			Use the --no-interactive option and provide your configuration choices at the command line to skip 
				the interactive flow. The following is an example:
			$ sam init --no-interactive --runtime go1.x --name go-demo --dependency-manager mod --app-template hello-world
		 
	 
		Troubleshooting
		To troubleshoot the AWS SAM CLI, see AWS SAM CLI troubleshooting.
	 
		Examples
		
		 
			Initialize a new serverless application using the 
					Hello World AWS Starter Template
			For this example, see 
				Step 1: Initialize the sample Hello World application in Tutorial: Deploying a Hello World 
					application.
		 
		
		 
			Initialize a new serverless application with a custom 
					template location
			The following are examples of providing a GitHub location to your custom template:
			$ sam init --location gh:aws-samples/cookiecutter-aws-sam-python
$ sam init --location git+sh://git@github.com/aws-samples/cookiecutter-aws-sam-python.git
$ sam init --location hg+ssh://hg@bitbucket.org/repo/template-name
			The following is an example of a local file path:
			$ sam init --location /path/to/template.zip
			The following is an example of a path reachable by HTTPS:
			$ sam init --location https://github.com/aws-samples/sessions-with-aws-sam/raw/master/starter-templates/web-app.zip
		 
	 
		Learn more
		To learn more about using the sam init command, see the following:
		
			 
			 
		
				Learning AWS SAM: sam init
				 – Serverless Land "Learning AWS SAM" series on YouTube.
			
				Structuring serverless 
					applications for use with the AWS SAM CLI (Sessions with SAM S2E7) – Sessions with AWS SAM
					series on YouTube.
			
	 
		Next steps
		Now that you have created your AWS SAM project, you are ready to start authoring your application. 
			See Define your infrastructure with AWS SAM for detailed instructions on the tasks you need to complete to do this.
	Document ConventionsDevelop your applicationDefine your infrastructureDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS Serverless Application ModelDeveloper GuideInitialize a new serverless applicationOptions for sam initTroubleshootingExamplesLearn moreNext stepsCreate your application in AWS SAMAfter completing Getting started
		and reading How to use AWS Serverless Application Model (AWS SAM), you will be ready to create an 
		AWS SAM project in your developer environment. Your AWS SAM project will serve as the 
		starting point for writing your serverless application. For a list of AWS SAM CLI sam init command options, see sam init.The AWS Serverless Application Model Command Line Interface (AWS SAM CLI) sam init command provides options to initialize a new 
		serverless application that consists of:
		 
		 
		 
	
			An AWS SAM template to define your infrastructure code.
		
			A folder structure that organizes your application.
		
			Configuration for your AWS Lambda functions.
		To create an AWS SAM project, refer to the topics in this sections.TopicsInitialize a new serverless applicationOptions for sam initTroubleshootingExamplesLearn moreNext steps
		Initialize a new serverless application
		To initialize a new serverless application using the AWS SAM CLI
				cd to a starting directory.
			
				Run the following at the command line:
				$ sam init
			
				The AWS SAM CLI will guide you through an interactive flow to create a new serverless application.
				NoteAs detailed in Tutorial: Deploy a Hello World application with AWS SAM, this command 
					initializes your serverless application, creating your project directory. This directory will contain several files and folders. The most important 
					file is template.yaml. This is your AWS SAM template. Your version of python must match the version of python listed in the 
					template.yaml file that the sam init command created.
			
		
		 
			Choose a starting template
			A template consists of the following:
			
				 
				 
			
					An AWS SAM template for your infrastructure code.
				
					A starting project directory that organizes your project files. For example, this may include:
					
						 
						 
						 
						 
						 
					
							A structure for your Lambda function code and their dependencies.
						
							An events folder that contains test events for local testing.
						
							A tests folder to support unit testing.
						
							A samconfig.toml file to configure project settings.
						
							A ReadMe file and other basic starting project files.
						
					The following is an example of a starting project directory:
					sam-app
├── README.md
├── __init__.py
├── events
│   └── event.json
├── hello_world
│   ├── __init__.py
│   ├── app.py
│   └── requirements.txt
├── samconfig.toml
├── template.yaml
└── tests
    ├── __init__.py
    ├── integration
    │   ├── __init__.py
    │   └── test_api_gateway.py
    ├── requirements.txt
    └── unit
        ├── __init__.py
        └── test_handler.py
				
			You can select from a list of available AWS Quick Start Templates or provide your own 
				Custom Template Location.
			To choose an AWS Quick Start Template
					When prompted, select AWS Quick Start Templates.
				
					Select an AWS Quick Start template to begin with. The following is an example:
					Which template source would you like to use?
    1 - AWS Quick Start Templates
    2 - Custom Template Location
Choice: 1

Choose an AWS Quick Start application template
    1 - Hello World Example
    2 - Multi-step workflow
    3 - Serverless API
    4 - Scheduled task
    5 - Standalone function
    6 - Data processing
    7 - Hello World Example With Powertools
    8 - Infrastructure event management
    9 - Serverless Connector Hello World Example
    10 - Multi-step workflow with Connectors
    11 - Lambda EFS example
    12 - DynamoDB Example
    13 - Machine Learning
Template: 4
				
			To choose your own custom template location
					When prompted, select the Custom Template Location.
					Which template source would you like to use?
    1 - AWS Quick Start Templates
    2 - Custom Template Location
Choice: 2
				
					The AWS SAM CLI will prompt you to provide a template location.
					Template location (git, mercurial, http(s), zip, path):
					Provide any of the following locations to your template .zip file archive:
					
						 
						 
						 
					
							GitHub repository – The path to the 
								.zip file in your GitHub repository. The file must be in the root of your 
								repository.
						
							Mercurial repository – The path to the 
								.zip file in your Mercurial repository. The file must be in the root of your repository.
						
							.zip path – An HTTPS or local path to your .zip file.
						
				
					The AWS SAM CLI will initialize your serverless application using your custom template.
				
		 
		
		 
			Choose a runtime
			When you choose an AWS Quick Start Template, the AWS SAM CLI prompts you to select a runtime 
				for your Lambda functions. The list of options displayed by the AWS SAM CLI are the runtimes supported natively by 
				Lambda.
			
				 
				 
			
					The runtime provides a 
						language-specific environment that runs in an execution environment.
				
					When deployed to the AWS Cloud, the Lambda service invokes your function in an execution environment.
				
			You can use any other programming language with a custom runtime. To do this, you need to manually create your
				starting application structure. You can then use sam init to quickly initialize your application by
				configuring a custom template location.
			From your selection, the AWS SAM CLI creates the starting directory for your Lambda function code and 
				dependencies.
			If Lambda supports multiple dependency managers for your runtime, you will be prompted to choose your preferred 
				dependency manager.
		 
		
		 
			Choose a package type
			When you choose an AWS Quick Start Template and a runtime, the 
				AWS SAM CLI prompts you to select a package type. The package type determines how your Lambda 
				functions are deployed to use with the Lambda service. The two supported package types are:
			
				 
				 
			
					Container image – Contains the base operating system, the runtime, 
						Lambda extensions, your application code, and its dependencies.
				
					.zip file archive – Contains your application code and its 
						dependencies.
				
			To learn more about deployment package types, see Lambda deployment packages in the 
				AWS Lambda Developer Guide.
			The following is an example directory structure of an application with a Lambda function packaged as a container 
				image. The AWS SAM CLI downloads the image and creates a Dockerfile in the function's directory to
				specify the image.
			sam-app
├── README.md
├── __init__.py
├── events
│   └── event.json
├── hello_world
│   ├── Dockerfile
│   ├── __init__.py
│   ├── app.py
│   └── requirements.txt
├── samconfig.toml
├── template.yaml
└── tests
    ├── __init__.py
    └── unit
        ├── __init__.py
        └── test_handler.py
			The following is an example directory structure of an application with a function packaged as a .zip file 
				archive.
			sam-app
├── README.md
├── __init__.py
├── events
│   └── event.json
├── hello_world
│   ├── __init__.py
│   ├── app.py
│   └── requirements.txt
├── samconfig.toml
├── template.yaml
└── tests
    ├── __init__.py
    ├── integration
    │   ├── __init__.py
    │   └── test_api_gateway.py
    ├── requirements.txt
    └── unit
        ├── __init__.py
        └── test_handler.py
		 
		
		 
			Configure AWS X-Ray tracing
			You can choose to activate AWS X-Ray tracing. To learn more, see What is AWS X-Ray? in the 
				AWS X-Ray Developer Guide.
			If you activate, the AWS SAM CLI configures your AWS SAM template. The following is an example:
			Globals:
  Function:
    ...
    Tracing: Active
  Api:
    TracingEnabled: True
		 
		
		 
			Configure monitoring with Amazon CloudWatch Application Insights
			You can choose to activate monitoring using Amazon CloudWatch Application Insights. To learn more, see Amazon CloudWatch 
				Application Insights in the Amazon CloudWatch User Guide.
			If you activate, the AWS SAM CLI configures your AWS SAM template. The following is an example:
			Resources:
  ApplicationResourceGroup:
    Type: AWS::ResourceGroups::Group
    Properties:
      Name:
        Fn::Join:
        - ''
        - - ApplicationInsights-SAM-
          - Ref: AWS::StackName
      ResourceQuery:
        Type: CLOUDFORMATION_STACK_1_0
  ApplicationInsightsMonitoring:
    Type: AWS::ApplicationInsights::Application
    Properties:
      ResourceGroupName:
        Fn::Join:
        - ''
        - - ApplicationInsights-SAM-
          - Ref: AWS::StackName
      AutoConfigurationEnabled: 'true'
    DependsOn: ApplicationResourceGroup
		 
		
		 
			Name your application
			Provide a name for your application. The AWS SAM CLI creates a top-level folder for your application using this 
				name.
		 
	 
		Options for sam init
		The following are some of the main options you can use with the sam init command. For a list of all 
			options, see sam init.
		
		 
			Initialize an application using a custom template location
			Use the --location option and provide a supported custom template location. The following is an 
				example:
			$ sam init --location https://github.com/aws-samples/sessions-with-aws-sam/raw/master/starter-templates/web-app.zip
		 
		
		 
			Initialize an application without the interactive 
					flow
			Use the --no-interactive option and provide your configuration choices at the command line to skip 
				the interactive flow. The following is an example:
			$ sam init --no-interactive --runtime go1.x --name go-demo --dependency-manager mod --app-template hello-world
		 
	 
		Troubleshooting
		To troubleshoot the AWS SAM CLI, see AWS SAM CLI troubleshooting.
	 
		Examples
		
		 
			Initialize a new serverless application using the 
					Hello World AWS Starter Template
			For this example, see 
				Step 1: Initialize the sample Hello World application in Tutorial: Deploying a Hello World 
					application.
		 
		
		 
			Initialize a new serverless application with a custom 
					template location
			The following are examples of providing a GitHub location to your custom template:
			$ sam init --location gh:aws-samples/cookiecutter-aws-sam-python
$ sam init --location git+sh://git@github.com/aws-samples/cookiecutter-aws-sam-python.git
$ sam init --location hg+ssh://hg@bitbucket.org/repo/template-name
			The following is an example of a local file path:
			$ sam init --location /path/to/template.zip
			The following is an example of a path reachable by HTTPS:
			$ sam init --location https://github.com/aws-samples/sessions-with-aws-sam/raw/master/starter-templates/web-app.zip
		 
	 
		Learn more
		To learn more about using the sam init command, see the following:
		
			 
			 
		
				Learning AWS SAM: sam init
				 – Serverless Land "Learning AWS SAM" series on YouTube.
			
				Structuring serverless 
					applications for use with the AWS SAM CLI (Sessions with SAM S2E7) – Sessions with AWS SAM
					series on YouTube.
			
	 
		Next steps
		Now that you have created your AWS SAM project, you are ready to start authoring your application. 
			See Define your infrastructure with AWS SAM for detailed instructions on the tasks you need to complete to do this.
	Document ConventionsDevelop your applicationDefine your infrastructureDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS Serverless Application ModelDeveloper GuideInitialize a new serverless applicationOptions for sam initTroubleshootingExamplesLearn moreNext stepsCreate your application in AWS SAMAfter completing Getting started
		and reading How to use AWS Serverless Application Model (AWS SAM), you will be ready to create an 
		AWS SAM project in your developer environment. Your AWS SAM project will serve as the 
		starting point for writing your serverless application. For a list of AWS SAM CLI sam init command options, see sam init.The AWS Serverless Application Model Command Line Interface (AWS SAM CLI) sam init command provides options to initialize a new 
		serverless application that consists of:
		 
		 
		 
	
			An AWS SAM template to define your infrastructure code.
		
			A folder structure that organizes your application.
		
			Configuration for your AWS Lambda functions.
		To create an AWS SAM project, refer to the topics in this sections.TopicsInitialize a new serverless applicationOptions for sam initTroubleshootingExamplesLearn moreNext steps
		Initialize a new serverless application
		To initialize a new serverless application using the AWS SAM CLI
				cd to a starting directory.
			
				Run the following at the command line:
				$ sam init
			
				The AWS SAM CLI will guide you through an interactive flow to create a new serverless application.
				NoteAs detailed in Tutorial: Deploy a Hello World application with AWS SAM, this command 
					initializes your serverless application, creating your project directory. This directory will contain several files and folders. The most important 
					file is template.yaml. This is your AWS SAM template. Your version of python must match the version of python listed in the 
					template.yaml file that the sam init command created.
			
		
		 
			Choose a starting template
			A template consists of the following:
			
				 
				 
			
					An AWS SAM template for your infrastructure code.
				
					A starting project directory that organizes your project files. For example, this may include:
					
						 
						 
						 
						 
						 
					
							A structure for your Lambda function code and their dependencies.
						
							An events folder that contains test events for local testing.
						
							A tests folder to support unit testing.
						
							A samconfig.toml file to configure project settings.
						
							A ReadMe file and other basic starting project files.
						
					The following is an example of a starting project directory:
					sam-app
├── README.md
├── __init__.py
├── events
│   └── event.json
├── hello_world
│   ├── __init__.py
│   ├── app.py
│   └── requirements.txt
├── samconfig.toml
├── template.yaml
└── tests
    ├── __init__.py
    ├── integration
    │   ├── __init__.py
    │   └── test_api_gateway.py
    ├── requirements.txt
    └── unit
        ├── __init__.py
        └── test_handler.py
				
			You can select from a list of available AWS Quick Start Templates or provide your own 
				Custom Template Location.
			To choose an AWS Quick Start Template
					When prompted, select AWS Quick Start Templates.
				
					Select an AWS Quick Start template to begin with. The following is an example:
					Which template source would you like to use?
    1 - AWS Quick Start Templates
    2 - Custom Template Location
Choice: 1

Choose an AWS Quick Start application template
    1 - Hello World Example
    2 - Multi-step workflow
    3 - Serverless API
    4 - Scheduled task
    5 - Standalone function
    6 - Data processing
    7 - Hello World Example With Powertools
    8 - Infrastructure event management
    9 - Serverless Connector Hello World Example
    10 - Multi-step workflow with Connectors
    11 - Lambda EFS example
    12 - DynamoDB Example
    13 - Machine Learning
Template: 4
				
			To choose your own custom template location
					When prompted, select the Custom Template Location.
					Which template source would you like to use?
    1 - AWS Quick Start Templates
    2 - Custom Template Location
Choice: 2
				
					The AWS SAM CLI will prompt you to provide a template location.
					Template location (git, mercurial, http(s), zip, path):
					Provide any of the following locations to your template .zip file archive:
					
						 
						 
						 
					
							GitHub repository – The path to the 
								.zip file in your GitHub repository. The file must be in the root of your 
								repository.
						
							Mercurial repository – The path to the 
								.zip file in your Mercurial repository. The file must be in the root of your repository.
						
							.zip path – An HTTPS or local path to your .zip file.
						
				
					The AWS SAM CLI will initialize your serverless application using your custom template.
				
		 
		
		 
			Choose a runtime
			When you choose an AWS Quick Start Template, the AWS SAM CLI prompts you to select a runtime 
				for your Lambda functions. The list of options displayed by the AWS SAM CLI are the runtimes supported natively by 
				Lambda.
			
				 
				 
			
					The runtime provides a 
						language-specific environment that runs in an execution environment.
				
					When deployed to the AWS Cloud, the Lambda service invokes your function in an execution environment.
				
			You can use any other programming language with a custom runtime. To do this, you need to manually create your
				starting application structure. You can then use sam init to quickly initialize your application by
				configuring a custom template location.
			From your selection, the AWS SAM CLI creates the starting directory for your Lambda function code and 
				dependencies.
			If Lambda supports multiple dependency managers for your runtime, you will be prompted to choose your preferred 
				dependency manager.
		 
		
		 
			Choose a package type
			When you choose an AWS Quick Start Template and a runtime, the 
				AWS SAM CLI prompts you to select a package type. The package type determines how your Lambda 
				functions are deployed to use with the Lambda service. The two supported package types are:
			
				 
				 
			
					Container image – Contains the base operating system, the runtime, 
						Lambda extensions, your application code, and its dependencies.
				
					.zip file archive – Contains your application code and its 
						dependencies.
				
			To learn more about deployment package types, see Lambda deployment packages in the 
				AWS Lambda Developer Guide.
			The following is an example directory structure of an application with a Lambda function packaged as a container 
				image. The AWS SAM CLI downloads the image and creates a Dockerfile in the function's directory to
				specify the image.
			sam-app
├── README.md
├── __init__.py
├── events
│   └── event.json
├── hello_world
│   ├── Dockerfile
│   ├── __init__.py
│   ├── app.py
│   └── requirements.txt
├── samconfig.toml
├── template.yaml
└── tests
    ├── __init__.py
    └── unit
        ├── __init__.py
        └── test_handler.py
			The following is an example directory structure of an application with a function packaged as a .zip file 
				archive.
			sam-app
├── README.md
├── __init__.py
├── events
│   └── event.json
├── hello_world
│   ├── __init__.py
│   ├── app.py
│   └── requirements.txt
├── samconfig.toml
├── template.yaml
└── tests
    ├── __init__.py
    ├── integration
    │   ├── __init__.py
    │   └── test_api_gateway.py
    ├── requirements.txt
    └── unit
        ├── __init__.py
        └── test_handler.py
		 
		
		 
			Configure AWS X-Ray tracing
			You can choose to activate AWS X-Ray tracing. To learn more, see What is AWS X-Ray? in the 
				AWS X-Ray Developer Guide.
			If you activate, the AWS SAM CLI configures your AWS SAM template. The following is an example:
			Globals:
  Function:
    ...
    Tracing: Active
  Api:
    TracingEnabled: True
		 
		
		 
			Configure monitoring with Amazon CloudWatch Application Insights
			You can choose to activate monitoring using Amazon CloudWatch Application Insights. To learn more, see Amazon CloudWatch 
				Application Insights in the Amazon CloudWatch User Guide.
			If you activate, the AWS SAM CLI configures your AWS SAM template. The following is an example:
			Resources:
  ApplicationResourceGroup:
    Type: AWS::ResourceGroups::Group
    Properties:
      Name:
        Fn::Join:
        - ''
        - - ApplicationInsights-SAM-
          - Ref: AWS::StackName
      ResourceQuery:
        Type: CLOUDFORMATION_STACK_1_0
  ApplicationInsightsMonitoring:
    Type: AWS::ApplicationInsights::Application
    Properties:
      ResourceGroupName:
        Fn::Join:
        - ''
        - - ApplicationInsights-SAM-
          - Ref: AWS::StackName
      AutoConfigurationEnabled: 'true'
    DependsOn: ApplicationResourceGroup
		 
		
		 
			Name your application
			Provide a name for your application. The AWS SAM CLI creates a top-level folder for your application using this 
				name.
		 
	 
		Options for sam init
		The following are some of the main options you can use with the sam init command. For a list of all 
			options, see sam init.
		
		 
			Initialize an application using a custom template location
			Use the --location option and provide a supported custom template location. The following is an 
				example:
			$ sam init --location https://github.com/aws-samples/sessions-with-aws-sam/raw/master/starter-templates/web-app.zip
		 
		
		 
			Initialize an application without the interactive 
					flow
			Use the --no-interactive option and provide your configuration choices at the command line to skip 
				the interactive flow. The following is an example:
			$ sam init --no-interactive --runtime go1.x --name go-demo --dependency-manager mod --app-template hello-world
		 
	 
		Troubleshooting
		To troubleshoot the AWS SAM CLI, see AWS SAM CLI troubleshooting.
	 
		Examples
		
		 
			Initialize a new serverless application using the 
					Hello World AWS Starter Template
			For this example, see 
				Step 1: Initialize the sample Hello World application in Tutorial: Deploying a Hello World 
					application.
		 
		
		 
			Initialize a new serverless application with a custom 
					template location
			The following are examples of providing a GitHub location to your custom template:
			$ sam init --location gh:aws-samples/cookiecutter-aws-sam-python
$ sam init --location git+sh://git@github.com/aws-samples/cookiecutter-aws-sam-python.git
$ sam init --location hg+ssh://hg@bitbucket.org/repo/template-name
			The following is an example of a local file path:
			$ sam init --location /path/to/template.zip
			The following is an example of a path reachable by HTTPS:
			$ sam init --location https://github.com/aws-samples/sessions-with-aws-sam/raw/master/starter-templates/web-app.zip
		 
	 
		Learn more
		To learn more about using the sam init command, see the following:
		
			 
			 
		
				Learning AWS SAM: sam init
				 – Serverless Land "Learning AWS SAM" series on YouTube.
			
				Structuring serverless 
					applications for use with the AWS SAM CLI (Sessions with SAM S2E7) – Sessions with AWS SAM
					series on YouTube.
			
	 
		Next steps
		Now that you have created your AWS SAM project, you are ready to start authoring your application. 
			See Define your infrastructure with AWS SAM for detailed instructions on the tasks you need to complete to do this.
	Document ConventionsDevelop your applicationDefine your infrastructureDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS Serverless Application ModelDeveloper GuideInitialize a new serverless applicationOptions for sam initTroubleshootingExamplesLearn moreNext stepsCreate your application in AWS SAMAfter completing Getting started
		and reading How to use AWS Serverless Application Model (AWS SAM), you will be ready to create an 
		AWS SAM project in your developer environment. Your AWS SAM project will serve as the 
		starting point for writing your serverless application. For a list of AWS SAM CLI sam init command options, see sam init.The AWS Serverless Application Model Command Line Interface (AWS SAM CLI) sam init command provides options to initialize a new 
		serverless application that consists of:
		 
		 
		 
	
			An AWS SAM template to define your infrastructure code.
		
			A folder structure that organizes your application.
		
			Configuration for your AWS Lambda functions.
		To create an AWS SAM project, refer to the topics in this sections.TopicsInitialize a new serverless applicationOptions for sam initTroubleshootingExamplesLearn moreNext steps
		Initialize a new serverless application
		To initialize a new serverless application using the AWS SAM CLI
				cd to a starting directory.
			
				Run the following at the command line:
				$ sam init
			
				The AWS SAM CLI will guide you through an interactive flow to create a new serverless application.
				NoteAs detailed in Tutorial: Deploy a Hello World application with AWS SAM, this command 
					initializes your serverless application, creating your project directory. This directory will contain several files and folders. The most important 
					file is template.yaml. This is your AWS SAM template. Your version of python must match the version of python listed in the 
					template.yaml file that the sam init command created.
			
		
		 
			Choose a starting template
			A template consists of the following:
			
				 
				 
			
					An AWS SAM template for your infrastructure code.
				
					A starting project directory that organizes your project files. For example, this may include:
					
						 
						 
						 
						 
						 
					
							A structure for your Lambda function code and their dependencies.
						
							An events folder that contains test events for local testing.
						
							A tests folder to support unit testing.
						
							A samconfig.toml file to configure project settings.
						
							A ReadMe file and other basic starting project files.
						
					The following is an example of a starting project directory:
					sam-app
├── README.md
├── __init__.py
├── events
│   └── event.json
├── hello_world
│   ├── __init__.py
│   ├── app.py
│   └── requirements.txt
├── samconfig.toml
├── template.yaml
└── tests
    ├── __init__.py
    ├── integration
    │   ├── __init__.py
    │   └── test_api_gateway.py
    ├── requirements.txt
    └── unit
        ├── __init__.py
        └── test_handler.py
				
			You can select from a list of available AWS Quick Start Templates or provide your own 
				Custom Template Location.
			To choose an AWS Quick Start Template
					When prompted, select AWS Quick Start Templates.
				
					Select an AWS Quick Start template to begin with. The following is an example:
					Which template source would you like to use?
    1 - AWS Quick Start Templates
    2 - Custom Template Location
Choice: 1

Choose an AWS Quick Start application template
    1 - Hello World Example
    2 - Multi-step workflow
    3 - Serverless API
    4 - Scheduled task
    5 - Standalone function
    6 - Data processing
    7 - Hello World Example With Powertools
    8 - Infrastructure event management
    9 - Serverless Connector Hello World Example
    10 - Multi-step workflow with Connectors
    11 - Lambda EFS example
    12 - DynamoDB Example
    13 - Machine Learning
Template: 4
				
			To choose your own custom template location
					When prompted, select the Custom Template Location.
					Which template source would you like to use?
    1 - AWS Quick Start Templates
    2 - Custom Template Location
Choice: 2
				
					The AWS SAM CLI will prompt you to provide a template location.
					Template location (git, mercurial, http(s), zip, path):
					Provide any of the following locations to your template .zip file archive:
					
						 
						 
						 
					
							GitHub repository – The path to the 
								.zip file in your GitHub repository. The file must be in the root of your 
								repository.
						
							Mercurial repository – The path to the 
								.zip file in your Mercurial repository. The file must be in the root of your repository.
						
							.zip path – An HTTPS or local path to your .zip file.
						
				
					The AWS SAM CLI will initialize your serverless application using your custom template.
				
		 
		
		 
			Choose a runtime
			When you choose an AWS Quick Start Template, the AWS SAM CLI prompts you to select a runtime 
				for your Lambda functions. The list of options displayed by the AWS SAM CLI are the runtimes supported natively by 
				Lambda.
			
				 
				 
			
					The runtime provides a 
						language-specific environment that runs in an execution environment.
				
					When deployed to the AWS Cloud, the Lambda service invokes your function in an execution environment.
				
			You can use any other programming language with a custom runtime. To do this, you need to manually create your
				starting application structure. You can then use sam init to quickly initialize your application by
				configuring a custom template location.
			From your selection, the AWS SAM CLI creates the starting directory for your Lambda function code and 
				dependencies.
			If Lambda supports multiple dependency managers for your runtime, you will be prompted to choose your preferred 
				dependency manager.
		 
		
		 
			Choose a package type
			When you choose an AWS Quick Start Template and a runtime, the 
				AWS SAM CLI prompts you to select a package type. The package type determines how your Lambda 
				functions are deployed to use with the Lambda service. The two supported package types are:
			
				 
				 
			
					Container image – Contains the base operating system, the runtime, 
						Lambda extensions, your application code, and its dependencies.
				
					.zip file archive – Contains your application code and its 
						dependencies.
				
			To learn more about deployment package types, see Lambda deployment packages in the 
				AWS Lambda Developer Guide.
			The following is an example directory structure of an application with a Lambda function packaged as a container 
				image. The AWS SAM CLI downloads the image and creates a Dockerfile in the function's directory to
				specify the image.
			sam-app
├── README.md
├── __init__.py
├── events
│   └── event.json
├── hello_world
│   ├── Dockerfile
│   ├── __init__.py
│   ├── app.py
│   └── requirements.txt
├── samconfig.toml
├── template.yaml
└── tests
    ├── __init__.py
    └── unit
        ├── __init__.py
        └── test_handler.py
			The following is an example directory structure of an application with a function packaged as a .zip file 
				archive.
			sam-app
├── README.md
├── __init__.py
├── events
│   └── event.json
├── hello_world
│   ├── __init__.py
│   ├── app.py
│   └── requirements.txt
├── samconfig.toml
├── template.yaml
└── tests
    ├── __init__.py
    ├── integration
    │   ├── __init__.py
    │   └── test_api_gateway.py
    ├── requirements.txt
    └── unit
        ├── __init__.py
        └── test_handler.py
		 
		
		 
			Configure AWS X-Ray tracing
			You can choose to activate AWS X-Ray tracing. To learn more, see What is AWS X-Ray? in the 
				AWS X-Ray Developer Guide.
			If you activate, the AWS SAM CLI configures your AWS SAM template. The following is an example:
			Globals:
  Function:
    ...
    Tracing: Active
  Api:
    TracingEnabled: True
		 
		
		 
			Configure monitoring with Amazon CloudWatch Application Insights
			You can choose to activate monitoring using Amazon CloudWatch Application Insights. To learn more, see Amazon CloudWatch 
				Application Insights in the Amazon CloudWatch User Guide.
			If you activate, the AWS SAM CLI configures your AWS SAM template. The following is an example:
			Resources:
  ApplicationResourceGroup:
    Type: AWS::ResourceGroups::Group
    Properties:
      Name:
        Fn::Join:
        - ''
        - - ApplicationInsights-SAM-
          - Ref: AWS::StackName
      ResourceQuery:
        Type: CLOUDFORMATION_STACK_1_0
  ApplicationInsightsMonitoring:
    Type: AWS::ApplicationInsights::Application
    Properties:
      ResourceGroupName:
        Fn::Join:
        - ''
        - - ApplicationInsights-SAM-
          - Ref: AWS::StackName
      AutoConfigurationEnabled: 'true'
    DependsOn: ApplicationResourceGroup
		 
		
		 
			Name your application
			Provide a name for your application. The AWS SAM CLI creates a top-level folder for your application using this 
				name.
		 
	 
		Options for sam init
		The following are some of the main options you can use with the sam init command. For a list of all 
			options, see sam init.
		
		 
			Initialize an application using a custom template location
			Use the --location option and provide a supported custom template location. The following is an 
				example:
			$ sam init --location https://github.com/aws-samples/sessions-with-aws-sam/raw/master/starter-templates/web-app.zip
		 
		
		 
			Initialize an application without the interactive 
					flow
			Use the --no-interactive option and provide your configuration choices at the command line to skip 
				the interactive flow. The following is an example:
			$ sam init --no-interactive --runtime go1.x --name go-demo --dependency-manager mod --app-template hello-world
		 
	 
		Troubleshooting
		To troubleshoot the AWS SAM CLI, see AWS SAM CLI troubleshooting.
	 
		Examples
		
		 
			Initialize a new serverless application using the 
					Hello World AWS Starter Template
			For this example, see 
				Step 1: Initialize the sample Hello World application in Tutorial: Deploying a Hello World 
					application.
		 
		
		 
			Initialize a new serverless application with a custom 
					template location
			The following are examples of providing a GitHub location to your custom template:
			$ sam init --location gh:aws-samples/cookiecutter-aws-sam-python
$ sam init --location git+sh://git@github.com/aws-samples/cookiecutter-aws-sam-python.git
$ sam init --location hg+ssh://hg@bitbucket.org/repo/template-name
			The following is an example of a local file path:
			$ sam init --location /path/to/template.zip
			The following is an example of a path reachable by HTTPS:
			$ sam init --location https://github.com/aws-samples/sessions-with-aws-sam/raw/master/starter-templates/web-app.zip
		 
	 
		Learn more
		To learn more about using the sam init command, see the following:
		
			 
			 
		
				Learning AWS SAM: sam init
				 – Serverless Land "Learning AWS SAM" series on YouTube.
			
				Structuring serverless 
					applications for use with the AWS SAM CLI (Sessions with SAM S2E7) – Sessions with AWS SAM
					series on YouTube.
			
	 
		Next steps
		Now that you have created your AWS SAM project, you are ready to start authoring your application. 
			See Define your infrastructure with AWS SAM for detailed instructions on the tasks you need to complete to do this.
	Document ConventionsDevelop your applicationDefine your infrastructureDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS Serverless Application ModelDeveloper GuideHow to use AWS Serverless Application Model (AWS SAM)The primary tools you use to develop your application are the AWS SAM CLI and the AWS SAM template and AWS SAM project 
		(which is your application project directory).
		You use these tools to:Develop your application (this includes initializing your application, defining your resources, and building your application).Test your application.Debug your application.Deploy your application and resources.Monitor your application.AWS SAM creates your AWS SAM project after you run the sam init command and complete its subsequent workflow. 
		You define your serverless application by adding code to your AWS SAM project. While your AWS SAM project consists of a set of files and folders, 
		the most important file in it is your AWS SAM template (named template.yaml). In this template, you write your code to express resources, 
		event source mappings, and other properties that define the your serverless application.The AWS SAM CLI contains a repository of commands you use on your AWS SAM project. 
		More specifically, the AWS SAM CLI is what you use to build, transform, deploy, debug, package, initialize, and sync your AWS SAM project. 
		In other words, it’s what you use to turn your AWS SAM project into your serverless application. TopicsThe AWS SAM CLIThe AWS SAM project and AWS SAM templateDocument ConventionsHello World TutorialThe AWS SAM CLIDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS Serverless Application ModelDeveloper GuideUsageOptionsExamplesam initThis page provides reference information for the AWS Serverless Application Model Command Line Interface (AWS SAM CLI) 
		sam init command.
		 
		 
	
			For an introduction to the AWS SAM CLI, see What is the AWS SAM CLI?
		
			For documentation on using the AWS SAM CLI sam init command, see Create your application in AWS SAM.
		The sam init command provides options to initialize a new serverless application.
		Usage
		$ sam init <options>
	 
		Options
		
			
			
			 
			
			
			 
			
			
			 
			
			
			 
			
			
			 
			
			
			 
			
			
			 
			
			
			 
			
			
			 
			
			
			 
			
			
			 
			
			
			 
			
			
			 
			
			
			 
			
			
			 
			
			
			 
			
			
			 
			
			
			 
			
			
			 
			
		
				--app-template TEXT
				
					The identifier of the managed application template that you want to use. If you're
						not sure, call sam init without options for an interactive
						workflow.
					This parameter is required if --no-interactive is specified and
						--location is not provided.
					This parameter is available only in AWS SAM CLI version 0.30.0 and later. Specifying
						this parameter with an earlier version results in an error.
				
			 
				--application-insights | --no-application-insights
				
					
						Activate Amazon CloudWatch Application Insights monitoring for your application. To learn more, see
						Using CloudWatch Application Insights to monitor your AWS SAM serverless applications.
					
					
						The default option is --no-application-insights.
					
				
			 
				--architecture, -a [ x86_64 | arm64 ]
				
					The instruction set architecture for your application's Lambda functions. Specify
						one of x86_64 or arm64.
				
			 
				--base-image [ amazon/dotnet8-base | amazon/dotnet6-base |
							amazon/java21-base | amazon/java17-base | amazon/java11-base |
							amazon/nodejs22.x-base | amazon/nodejs20.x-base | amazon/nodejs18.x-base
							| amazon/nodejs16.x-base | amazon/python3.13-base |
							amazon/python3.12-base | amazon/python3.11-base | amazon/python3.10-base
							| amazon/python3.9-base | amazon/python3.8-base | amazon/ruby3.4-base |
							amazon/ruby3.3-base | amazon/ruby3.2-base ]
				
					The base image of your application. This option applies only when the package type
						is Image.
					This parameter is required if --no-interactive is specified,
						--package-type is specified as Image, and
						--location is not specified.
				
			 
				--config-env TEXT
				
					The environment name specifying the default parameter values in the configuration
						file to use. The default value is "default". For more information about configuration
						files, see AWS SAM CLI configuration file.
				
			 
				--config-file PATH
				
					The path and file name of the configuration file containing default parameter
						values to use. The default value is "samconfig.toml" in the root of the project
						directory. For more information about configuration files, see AWS SAM CLI configuration file.
				
			 
				--debug
				
					Turns on debug logging to print debug messages that the AWS SAM CLI generates, and to
						display timestamps.
				
			 
				--dependency-manager, -d [ gradle | mod | maven | bundler | npm | cli-package
					| pip ]
				
					The dependency manager of your Lambda runtime.
				
			 
				--extra-content
				
					Override any custom parameters in the template's cookiecutter.json
						configuration, for example, {"customParam1": "customValue1",
							"customParam2":"customValue2"}.
				
			 
				--help, -h
				
					Shows this message and exits.
				
			 
				--location, -l TEXT
				
					The template or application location (Git, Mercurial, HTTP/HTTPS, .zip file,
						path).
					This parameter is required if --no-interactive is specified and
						--runtime, --name, and --app-template are not
						provided.
					For Git repositories, you must use the location of the root of the
						repository.
					For local paths, the template must be in either .zip file or Cookiecutter
						format.
				
			 
				--name, -n TEXT
				
					The name of your project to be generated as a directory.
					This parameter is required if --no-interactive is specified and
						--location is not provided.
				
			 
				--no-input
				
					Disables Cookiecutter prompting and accepts the vcfdefault values that are defined
						in the template configuration.
				
			 
				--no-interactive
				
					Disable interactive prompting for init parameters, and fail if any required values
						are missing.
				
			 
				--output-dir, -o PATH
				
					The location where the initialized application is output.
				
			 
				--package-type [ Zip | Image ]
				
					The package type of the example application. Zip creates a .zip file
						archive, and Image creates a container image.
				
			 
				--runtime, -r [ dotnet8 | dotnet6 | java21 | java17 | java11 |
							nodejs22.x | nodejs20.x | nodejs18.x | nodejs16.x | python3.13 |
							python3.12 | python3.11 | python3.10 | python3.9 | python3.8 | ruby3.4 |
							ruby3.3 | ruby3.2 ]
				
					The Lambda runtime of your application. This option applies only when the package
						type is Zip.
					This parameter is required if --no-interactive is specified,
						--package-type is specified as Zip, and
						--location is not specified.
				
			 
				--save-params
				
					Save the parameters that you provide at the command line to the AWS SAM configuration file.
				
			 
				--tracing | --no-tracing
				
					Activate AWS X-Ray tracing for your Lambda functions.
				
			
		
	 
		Example
		
		For a detailed example and in-depth walkthrough on using the sam init subcommand, refer to Create your application in AWS SAM.
	Document Conventionssam deploysam listDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS Serverless Application ModelDeveloper GuidePrerequisites
				Step 1: Initialize the sample Hello World applicationStep 2: Build your applicationStep 3: Deploy your application to the AWS CloudStep 4: Run your applicationStep 5: Interact with your function in the AWS CloudStep 6: Modify and sync your application to the AWS CloudStep 7: (Optional) Test your application locallyStep 8: Delete your application from the AWS CloudTroubleshootingLearn moreTutorial: Deploy a Hello World application with AWS SAMIn this tutorial, you use the AWS Serverless Application Model Command Line Interface (AWS SAM CLI) to complete the following:
		 
		 
        
		 
		 
	
			Initialize, build, and deploy a sample Hello World application.
		
			Make local changes and sync to AWS CloudFormation.
		
			Perform local testing on your development host.
		
			Delete the sample application from the AWS Cloud.
		The sample Hello World application implements a basic API backend. It consists of the 
		following resources:
		 
		 
		 
	
			Amazon API Gateway – API endpoint that you will use to invoke your function.
		
			AWS Lambda – Function that processes the HTTP API GET request and returns a 
				hello world message.
		
			AWS Identity and Access Management (IAM) role – Provisions permissions for the services to 
				securely interact.
		The following diagram shows the components of this application:
		 
			
		 
		 
	TopicsPrerequisites
				Step 1: Initialize the sample Hello World applicationStep 2: Build your applicationStep 3: Deploy your application to the AWS CloudStep 4: Run your applicationStep 5: Interact with your function in the AWS CloudStep 6: Modify and sync your application to the AWS CloudStep 7: (Optional) Test your application locallyStep 8: Delete your application from the AWS CloudTroubleshootingLearn more
		Prerequisites
		Verify that you have completed the following:
		
			 
			 
		
				AWS SAM prerequisites
			
				Install the AWS SAM CLI
			
	 
		
				Step 1: Initialize the sample Hello World application
		In this step, you will use the AWS SAM CLI to create a sample Hello World 
			application project on your local machine.
		To initialize the sample Hello World application
				In your command line, run the following from a starting directory of your choice:
				$ sam init
				NoteThis command initializes your serverless application, creating your project directory. 
					This directory will contain several files and folders. The most important file is template.yaml. This is your AWS SAM template.
					Your version of python must match the version of python listed in the template.yaml file that the sam init command created.
			
				The AWS SAM CLI will guide you through initializing a new application. Configure the following:
				
					 
					 
					 
					 
					 
					 
					 
				
						Select AWS Quick Start Templates to choose a starting template.
					
						Choose the Hello World Example template and download it.
					
						Use the Python runtime and zip package type.
					
						For this tutorial, opt out of AWS X-Ray tracing. To learn more, see What is AWS X-Ray? in the 
							AWS X-Ray Developer Guide.
					
						For this tutorial, opt out of monitoring with Amazon CloudWatch Application Insights. To learn more, see 
							
								Amazon CloudWatch Application Insights in the Amazon CloudWatch User Guide.
					
						For this tutorial, opt out of setting Structured Logging in JSON format on your Lambda functions.
					
						Name your application as sam-app.
					
				To use the AWS SAM CLI interactive flow:
				
					 
					 
				
						Brackets ([ ]) indicate default values. Leave your answer blank to select the default 
							value.
					
						Enter y for yes, and 
							n for no.
					
				The following is an example of the sam init interactive flow:
				$ sam init
...
Which template source would you like to use?
    1 - AWS Quick Start Templates
    2 - Custom Template Location
Choice: 1

Choose an AWS Quick Start application template
    1 - Hello World Example
    2 - Data processing
    3 - Hello World Example with Powertools for AWS Lambda
    4 - Multi-step workflow
    5 - Scheduled task
    6 - Standalone function
    7 - Serverless API
    8 - Infrastructure event management 
    9 - Lambda Response Streaming
   10 - GraphQLApi Hello World Example
   11 - Full Stack
   12 - Lambda EFS example
   13 - Serverless Connector Hello World Example
   14 - Multi-step workflow with Connectors
   15 - DynamoDB Example
   16 - Machine Learning
Template: 1

Use the most popular runtime and package type? (Python and zip) [y/N]: y

Would you like to enable X-Ray tracing on the function(s) in your application?  [y/N]: ENTER

Would you like to enable monitoring using CloudWatch Application Insights?
For more info, please view https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/cloudwatch-application-insights.html [y/N]: ENTER
					
Would you like to set Structured Logging in JSON format on your Lambda functions?  [y/N]: ENTER

Project name [sam-app]: ENTER
			
				The AWS SAM CLI downloads your starting template and creates the application project directory structure on your 
					local machine. The following is an example of the AWS SAM CLI output:
				Cloning from https://github.com/aws/aws-sam-cli-app-templates (process may take a moment)

    -----------------------
    Generating application:
    -----------------------
    Name: sam-app
    Runtime: python3.9
    Architectures: x86_64
    Dependency Manager: pip
    Application Template: hello-world
    Output Directory: .
    Configuration file: sam-app/samconfig.toml

    Next steps can be found in the README file at sam-app/README.md


Commands you can use next
=========================
[*] Create pipeline: cd sam-app && sam pipeline init --bootstrap
[*] Validate SAM template: cd sam-app && sam validate
[*] Test Function in the Cloud: cd sam-app && sam sync --stack-name {stack-name} --watch
			
				From your command line, move to the newly created sam-app directory. The following is an 
					example of what the AWS SAM CLI has created:
				NoteIf tree command is not auto installed run this command:
					brew install tree
				$ cd sam-app

$ tree

├── README.md
├── __init__.py
├── events
│   └── event.json
├── hello_world
│   ├── __init__.py
│   ├── app.py
│   └── requirements.txt
├── samconfig.toml
├── template.yaml
└── tests
    ├── __init__.py
    ├── integration
    │   ├── __init__.py
    │   └── test_api_gateway.py
    ├── requirements.txt
    └── unit
        ├── __init__.py
        └── test_handler.py
        
6 directories, 14 files
				Some important files to highlight:
				
					 
					 
					 
					 
				
						hello_world/app.py – Contains your Lambda function code.
					
						hello_world/requirements.txt – Contains any Python dependencies 
							that your Lambda function requires.
					
						samconfig.toml – Configuration file for your application that 
							stores default parameters used by the AWS SAM CLI.
					
						template.yaml – The AWS SAM template that contains your application infrastructure 
							code.
					
			
		You now have a completely authored serverless application on your local machine!
	 
		Step 2: Build your application
		In this step, you use the AWS SAM CLI to build your application and prepare for deployment. When you build, the 
			AWS SAM CLI creates a .aws-sam directory and organizes your function dependencies, project code, and 
			project files there.
		To build your application
				In your command line, from the sam-app project directory, run the following:
				$ sam build
				Note If you don't have Python on your local machine, use the sam build --use-container
					 command instead. The AWS SAM CLI will create a Docker container that includes your function's 
						runtime and dependencies. This command requires Docker on your local machine. To install 
						Docker, see Installing Docker.
				The following is an example of the AWS SAM CLI output:
				$ sam build
Starting Build use cache
Manifest file is changed (new hash: 3298f1304...d4d421) or dependency folder (.aws-sam/deps/4d3dfad6-a267-47a6-a6cd-e07d6fae318c) is missing for (HelloWorldFunction), downloading dependencies and copying/building source
Building codeuri: /Users/.../Demo/sam-tutorial1/sam-app/hello_world runtime: python3.9 metadata: {} architecture: x86_64 functions: HelloWorldFunction
Running PythonPipBuilder:CleanUp
Running PythonPipBuilder:ResolveDependencies
Running PythonPipBuilder:CopySource
Running PythonPipBuilder:CopySource

Build Succeeded

Built Artifacts  : .aws-sam/build
Built Template   : .aws-sam/build/template.yaml

Commands you can use next
=========================
[*] Validate SAM template: sam validate
[*] Invoke Function: sam local invoke
[*] Test Function in the Cloud: sam sync --stack-name {{stack-name}} --watch
[*] Deploy: sam deploy --guided
				The following is a shortened example of the .aws-sam directory created by the AWS SAM 
					CLI:
				.aws-sam
├── build
│   ├── HelloWorldFunction
│   │   ├── __init__.py
│   │   ├── app.py
│   │   └── requirements.txt
│   └── template.yaml
└── build.toml
			
		Some important files to highlight:
		
			 
			 
			 
		
				build/HelloWorldFunction – Contains your Lambda function code and dependencies. The 
					AWS SAM CLI creates a directory for each function in your application.
			
				build/template.yaml – Contains a copy of your AWS SAM template that is referenced by 
					AWS CloudFormation at deployment.
			
				build.toml – Configuration file that stores default parameter values referenced by 
					the AWS SAM CLI when building and deploying your application.
			
		You are now ready to deploy your application to the AWS Cloud.
	 
		Step 3: Deploy your application to the AWS Cloud
		NoteThis step requires AWS credentials configuration. For more information, see Step 5: Use the AWS CLI to configure AWS credentials in AWS SAM prerequisites.
		In this step, you use the AWS SAM CLI to deploy your application to the AWS Cloud. The AWS SAM CLI will do the 
			following:
		
			 
			 
			 
		
				Guide you through configuring your application settings for deployment.
			
				Upload your application files to Amazon Simple Storage Service (Amazon S3).
			
				Transform your AWS SAM template into an AWS CloudFormation template. It then uploads your template to the AWS CloudFormation service to 
					provision your AWS resources.
			
		To deploy your application
				In your command line, from the sam-app project directory, run the following:
				$ sam deploy --guided
			
				Follow the AWS SAM CLI interactive flow to configure your application settings. Configure the following:
				
					 
					 
					 
					 
					 
					 
					 
					 
					 
				
						The AWS CloudFormation stack name – A stack is a collection of AWS resources 
							that you can manage as a single unit. To learn more, see Working with stacks in the 
							AWS CloudFormation User Guide.
					
						The AWS Region to deploy your AWS CloudFormation stack to. For more information, see 
							AWS CloudFormation 
								endpoints in the AWS CloudFormation User Guide.
					
						For this tutorial, opt out of confirming changes before deploy.
					
						Allow IAM role creation – This lets AWS SAM create the IAM role 
							necessary for your API Gateway resource and Lambda function resource to interact.
					
						For this tutorial, opt out of disabling rollback.
					
						Allow HelloWorldFunction without authorization defined – This message 
							displays because your API Gateway endpoint is configured to be publicly accessible, without authorization. Since this 
							is the intended configuration for your Hello World application, allow the AWS SAM CLI to continue. For more
							information about configuring authorization, see Control API access with your AWS SAM template.
					
						Save arguments to configuration file – This will update your 
							application’s samconfig.toml file with your deployment preferences.
					
						Select the default configuration file name.
					
						Select the default configuration environment.
					
				The following is an example output of the sam deploy --guided interactive flow:
				$ sam deploy --guided

Configuring SAM deploy
======================

    Looking for config file [samconfig.toml] :  Found
    Reading default arguments  :  Success

    Setting default arguments for 'sam deploy'
    =========================================
    Stack Name [sam-app]: ENTER
    AWS Region [us-west-2]: ENTER
    #Shows you resources changes to be deployed and require a 'Y' to initiate deploy
    Confirm changes before deploy [Y/n]: n
    #SAM needs permission to be able to create roles to connect to the resources in your template
    Allow SAM CLI IAM role creation [Y/n]: ENTER
    #Preserves the state of previously provisioned resources when an operation fails
    Disable rollback [y/N]: ENTER
    HelloWorldFunction may not have authorization defined, Is this okay? [y/N]: y
    Save arguments to configuration file [Y/n]: ENTER
    SAM configuration file [samconfig.toml]: ENTER
    SAM configuration environment [default]: ENTER
			
				The AWS SAM CLI deploys your application by doing the following:
				
					 
					 
					 
				
						The AWS SAM CLI creates an Amazon S3 bucket and uploads your .aws-sam directory.
					
						The AWS SAM CLI transforms your AWS SAM template into AWS CloudFormation and uploads it to the AWS CloudFormation service.
					
						AWS CloudFormation provisions your resources.
					
				During deployment, the AWS SAM CLI displays your progress. The following is an example output:
				Looking for resources needed for deployment:

    Managed S3 bucket: aws-sam-cli-managed-default-samclisam-s3-demo-bucket-1a4x26zbcdkqr
    A different default S3 bucket can be set in samconfig.toml

    Parameter "stack_name=sam-app" in [default.deploy.parameters] is defined as a global parameter [default.global.parameters].
    This parameter will be only saved under [default.global.parameters] in /Users/.../Demo/sam-tutorial1/sam-app/samconfig.toml.

    Saved arguments to config file
    Running 'sam deploy' for future deployments will use the parameters saved above.
    The above parameters can be changed by modifying samconfig.toml
    Learn more about samconfig.toml syntax at
    https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/serverless-sam-cli-config.html

File with same data already exists at sam-app/da3c598813f1c2151579b73ad788cac8, skipping upload

    Deploying with following values
    ===============================
    Stack name                   : sam-app
    Region                       : us-west-2
    Confirm changeset            : False
    Disable rollback             : False
    Deployment s3 bucket         : aws-sam-cli-managed-default-samclisam-s3-demo-bucket-1a4x26zbcdkqr
    Capabilities                 : ["CAPABILITY_IAM"]
    Parameter overrides          : {}
    Signing Profiles             : {}

Initiating deployment
=====================

File with same data already exists at sam-app/2bebf67c79f6a743cc5312f6dfc1efee.template, skipping upload


Waiting for changeset to be created..

CloudFormation stack changeset
---------------------------------------------------------------------------------------------------------------------------------------------
Operation                           LogicalResourceId                   ResourceType                        Replacement
---------------------------------------------------------------------------------------------------------------------------------------------
* Modify                            HelloWorldFunction                  AWS::Lambda::Function               False
* Modify                            ServerlessRestApi                   AWS::ApiGateway::RestApi            False
- Delete                            AwsSamAutoDependencyLayerNestedSt   AWS::CloudFormation::Stack          N/A
                                    ack
---------------------------------------------------------------------------------------------------------------------------------------------


Changeset created successfully. arn:aws:cloudformation:us-west-2:012345678910:changeSet/samcli-deploy1678917603/22e05525-08f9-4c52-a2c4-f7f1fd055072


2023-03-15 12:00:16 - Waiting for stack create/update to complete

CloudFormation events from stack operations (refresh every 0.5 seconds)
---------------------------------------------------------------------------------------------------------------------------------------------
ResourceStatus                      ResourceType                        LogicalResourceId                   ResourceStatusReason
---------------------------------------------------------------------------------------------------------------------------------------------
UPDATE_IN_PROGRESS                  AWS::Lambda::Function               HelloWorldFunction                  -
UPDATE_COMPLETE                     AWS::Lambda::Function               HelloWorldFunction                  -
UPDATE_COMPLETE_CLEANUP_IN_PROGRE   AWS::CloudFormation::Stack          sam-app                             -
SS
DELETE_IN_PROGRESS                  AWS::CloudFormation::Stack          AwsSamAutoDependencyLayerNestedSt   -
                                                                        ack
DELETE_COMPLETE                     AWS::CloudFormation::Stack          AwsSamAutoDependencyLayerNestedSt   -
                                                                        ack
UPDATE_COMPLETE                     AWS::CloudFormation::Stack          sam-app                             -
---------------------------------------------------------------------------------------------------------------------------------------------

CloudFormation outputs from deployed stack
----------------------------------------------------------------------------------------------------------------------------------------------
Outputs
----------------------------------------------------------------------------------------------------------------------------------------------
Key                 HelloWorldFunctionIamRole
Description         Implicit IAM Role created for Hello World function
Value               arn:aws:iam::012345678910:role/sam-app-HelloWorldFunctionRole-15GLOUR9LMT1W

Key                 HelloWorldApi
Description         API Gateway endpoint URL for Prod stage for Hello World function
Value               https://<restapiid>.execute-api.us-west-2.amazonaws.com/Prod/hello/

Key                 HelloWorldFunction
Description         Hello World Lambda Function ARN
Value               arn:aws:lambda:us-west-2:012345678910:function:sam-app-HelloWorldFunction-yQDNe17r9maD
----------------------------------------------------------------------------------------------------------------------------------------------


Successfully created/updated stack - sam-app in us-west-2
			
		Your application is now deployed and running in the AWS Cloud!
	 
		Step 4: Run your application
		In this step, you will send a GET request to your API endpoint and see your Lambda function output.
		To get your API endpoint value
				From the information displayed by the AWS SAM CLI in the previous step, locate the Outputs section. 
					In this section, locate your HelloWorldApi resource to find your HTTP endpoint value. The following is an 
					example output:
				----------------------------------------------------------------------------------------------------------------------------------------------
Outputs
----------------------------------------------------------------------------------------------------------------------------------------------
...
Key                 HelloWorldApi
Description         API Gateway endpoint URL for Prod stage for Hello World function
Value               https://ets1gv8lxi.execute-api.us-west-2.amazonaws.com/Prod/hello/
...
----------------------------------------------------------------------------------------------------------------------------------------------
			
				Alternatively, you can use the sam list endpoints --output json command to get this 
					information. The following is an example output:
				$ sam list endpoints --output json
2023-03-15 12:39:19 Loading policies from IAM...
2023-03-15 12:39:25 Finished loading policies from IAM.
[
  {
    "LogicalResourceId": "HelloWorldFunction",
    "PhysicalResourceId": "sam-app-HelloWorldFunction-yQDNe17r9maD",
    "CloudEndpoint": "-",
    "Methods": "-"
  },
  {
    "LogicalResourceId": "ServerlessRestApi",
    "PhysicalResourceId": "ets1gv8lxi",
    "CloudEndpoint": [
      "https://ets1gv8lxi.execute-api.us-west-2.amazonaws.com/Prod",
      "https://ets1gv8lxi.execute-api.us-west-2.amazonaws.com/Stage"
    ],
    "Methods": [
      "/hello['get']"
    ]
  }
]
			
		To invoke your function
				Using your browser or the command line, send a GET request to your API endpoint. The following is an example 
					using the curl command:
				$ curl https://ets1gv8lxi.execute-api.us-west-2.amazonaws.com/Prod/hello/
{"message": "hello world"}
			
	 
		Step 5: Interact with your function in the AWS Cloud
		In this step, you use the AWS SAM CLI to invoke your Lambda function in the AWS Cloud.
		To invoke your Lambda function in the cloud
				Take note of your function’s LogicalResourceId from the previous step. It should be HelloWorldFunction.
			
				In your command line, from the sam-app project directory, run the following:
				$ sam remote invoke HelloWorldFunction --stack-name sam-app
			
				The AWS SAM CLI invokes your function in the cloud and returns a response. The following is an example output:
				$ sam remote invoke HelloWorldFunction --stack-name sam-app

Invoking Lambda Function HelloWorldFunction                                       
START RequestId: d5ef494b-5f45-4086-86fd-d7322fa1a1f9 Version: $LATEST
END RequestId: d5ef494b-5f45-4086-86fd-d7322fa1a1f9
REPORT RequestId: d5ef494b-5f45-4086-86fd-d7322fa1a1f9  Duration: 6.62 ms       Billed Duration: 7 ms     Memory Size: 128 MB     Max Memory Used: 67 MB  Init Duration: 164.06 ms
{"statusCode":200,"body":"{\"message\":\"hello world\"}"}% 
			
		
	 
		Step 6: Modify and sync your application to the AWS Cloud
		In this step, you use the AWS SAM CLI sam sync --watch command to sync local changes to the 
			AWS Cloud.
		To use sam sync
				In your command line, from the sam-app project directory, run the following:
				$ sam sync --watch
			
				The AWS SAM CLI prompts you to confirm that you are syncing a development stack. Since the 
					sam sync --watch command automatically deploys local changes to the AWS Cloud in real time, we 
					recommend it for development environments only.
				The AWS SAM CLI performs an initial deployment before it begins monitoring for local changes. The following is an 
					example output:
				$ sam sync --watch
The SAM CLI will use the AWS Lambda, Amazon API Gateway, and AWS StepFunctions APIs to upload your code without
performing a CloudFormation deployment. This will cause drift in your CloudFormation stack.
**The sync command should only be used against a development stack**.

Confirm that you are synchronizing a development stack.

Enter Y to proceed with the command, or enter N to cancel:
 [Y/n]: y
Queued infra sync. Waiting for in progress code syncs to complete...
Starting infra sync.
Manifest is not changed for (HelloWorldFunction), running incremental build
Building codeuri: /Users/.../Demo/sam-tutorial1/sam-app/hello_world runtime: python3.9 metadata: {} architecture: x86_64 functions: HelloWorldFunction
Running PythonPipBuilder:CopySource

Build Succeeded

Successfully packaged artifacts and wrote output template to file /var/folders/45/5ct135bx3fn2551_ptl5g6_80000gr/T/tmpq3x9vh63.
Execute the following command to deploy the packaged template
sam deploy --template-file /var/folders/45/5ct135bx3fn2551_ptl5g6_80000gr/T/tmpq3x9vh63 --stack-name <YOUR STACK NAME>


    Deploying with following values
    ===============================
    Stack name                   : sam-app
    Region                       : us-west-2
    Disable rollback             : False
    Deployment s3 bucket         : aws-sam-cli-managed-default-samclisam-s3-demo-bucket-1a4x26zbcdkqr
    Capabilities                 : ["CAPABILITY_NAMED_IAM", "CAPABILITY_AUTO_EXPAND"]
    Parameter overrides          : {}
    Signing Profiles             : null

Initiating deployment
=====================


2023-03-15 13:10:05 - Waiting for stack create/update to complete

CloudFormation events from stack operations (refresh every 0.5 seconds)
---------------------------------------------------------------------------------------------------------------------------------------------
ResourceStatus                      ResourceType                        LogicalResourceId                   ResourceStatusReason
---------------------------------------------------------------------------------------------------------------------------------------------
UPDATE_IN_PROGRESS                  AWS::CloudFormation::Stack          sam-app                             Transformation succeeded
CREATE_IN_PROGRESS                  AWS::CloudFormation::Stack          AwsSamAutoDependencyLayerNestedSt   -
                                                                        ack
CREATE_IN_PROGRESS                  AWS::CloudFormation::Stack          AwsSamAutoDependencyLayerNestedSt   Resource creation Initiated
                                                                        ack
CREATE_COMPLETE                     AWS::CloudFormation::Stack          AwsSamAutoDependencyLayerNestedSt   -
                                                                        ack
UPDATE_IN_PROGRESS                  AWS::Lambda::Function               HelloWorldFunction                  -
UPDATE_COMPLETE                     AWS::Lambda::Function               HelloWorldFunction                  -
UPDATE_COMPLETE_CLEANUP_IN_PROGRE   AWS::CloudFormation::Stack          sam-app                             -
SS
UPDATE_COMPLETE                     AWS::CloudFormation::Stack          sam-app                             -
---------------------------------------------------------------------------------------------------------------------------------------------

CloudFormation outputs from deployed stack
----------------------------------------------------------------------------------------------------------------------------------------------
Outputs
----------------------------------------------------------------------------------------------------------------------------------------------
Key                 HelloWorldFunctionIamRole
Description         Implicit IAM Role created for Hello World function
Value               arn:aws:iam::012345678910:role/sam-app-HelloWorldFunctionRole-15GLOUR9LMT1W

Key                 HelloWorldApi
Description         API Gateway endpoint URL for Prod stage for Hello World function
Value               https://ets1gv8lxi.execute-api.us-west-2.amazonaws.com/Prod/hello/

Key                 HelloWorldFunction
Description         Hello World Lambda Function ARN
Value               arn:aws:lambda:us-west-2:012345678910:function:sam-app-HelloWorldFunction-yQDNe17r9maD
----------------------------------------------------------------------------------------------------------------------------------------------


Stack update succeeded. Sync infra completed.

Infra sync completed.
CodeTrigger not created as CodeUri or DefinitionUri is missing for ServerlessRestApi.
			
		Next, you will modify your Lambda function code. The AWS SAM CLI will automatically detect this change and sync your 
			application to the AWS Cloud.
		To modify and sync your application
				In your IDE of choice, open the sam-app/hello_world/app.py file.
			
				Change the message and save your file. The following is an example:
				import json
...
def lambda_handler(event, context):
    ...
    return {
        "statusCode": 200,
        "body": json.dumps({
            "message": "hello everyone!",
            ...
        }),
    }
			
				The AWS SAM CLI detects your change and syncs your application to the AWS Cloud. The following is an example 
					output:
				Syncing Lambda Function HelloWorldFunction...
Manifest is not changed for (HelloWorldFunction), running incremental build
Building codeuri: /Users/.../Demo/sam-tutorial1/sam-app/hello_world runtime: python3.9 metadata: {} architecture: x86_64 functions: HelloWorldFunction
Running PythonPipBuilder:CopySource
Finished syncing Lambda Function HelloWorldFunction.
			
				To verify your change, send a GET request to your API endpoint again.
				$ curl https://ets1gv8lxi.execute-api.us-west-2.amazonaws.com/Prod/hello/
{"message": "hello everyone!"}
			
	 
		Step 7: (Optional) Test your application locally
		NoteThis step is optional.
		ImportantThis step requires Docker on your local machine. You must have Docker installed and configured to use the AWS SAM CLI for local testing. For more 
				information, see Installing Docker.
		In this step, you use the AWS SAM CLI sam local command to test your application locally. To 
			accomplish this, the AWS SAM CLI creates a local environment using Docker. This local environment emulates 
			the cloud-based execution environment of your Lambda function.
		You will do the following:
		
			 
			 
		
				Create a local environment for your Lambda function and invoke it.
			
				Host your HTTP API endpoint locally and use it to invoke your Lambda function.
			
		To invoke your Lambda function locally
				In your command line, from the sam-app project directory, run the following:
				$ sam local invoke
			
				The AWS SAM CLI creates a local Docker container and invokes your function. The following is an 
					example output:
				$ sam local invoke
Invoking app.lambda_handler (python3.9)
Local image was not found.
Removing rapid images for repo public.ecr.aws/sam/emulation-python3.9
Building image.....................
Using local image: public.ecr.aws/lambda/python:3.9-rapid-x86_64.

Mounting /Users/.../Demo/sam-tutorial1/sam-app/.aws-sam/build/HelloWorldFunction as /var/task:ro,delegated inside runtime container
START RequestId: b046db01-2a00-415d-af97-35f3a02e9eb6 Version: $LATEST
END RequestId: b046db01-2a00-415d-af97-35f3a02e9eb6
REPORT RequestId: b046db01-2a00-415d-af97-35f3a02e9eb6    Init Duration: 1.01 ms    Duration: 633.45 ms    Billed Duration: 634 ms    Memory Size: 128 MB    Max Memory Used: 128 MB
{"statusCode": 200, "body": "{\"message\": \"hello world\"}"}
			
		To host your API locally
				In your command line, from the sam-app project directory, run the following:
				$ sam local start-api
			
				The AWS SAM CLI creates a local Docker container for your Lambda function and creates a local 
					HTTP server to simulate your API endpoint. The following is an example output:
				$ sam local start-api
Initializing the lambda functions containers.
Local image is up-to-date
Using local image: public.ecr.aws/lambda/python:3.9-rapid-x86_64.

Mounting /Users/.../Demo/sam-tutorial1/sam-app/.aws-sam/build/HelloWorldFunction as /var/task:ro,delegated inside runtime container
Containers Initialization is done.
Mounting HelloWorldFunction at http://127.0.0.1:3000/hello [GET]
You can now browse to the above endpoints to invoke your functions. You do not need to restart/reload SAM CLI while working on your functions, changes will be reflected instantly/automatically. If you used sam build before running local commands, you will need to re-run sam build for the changes to be picked up. You only need to restart SAM CLI if you update your AWS SAM template
2023-03-15 14:25:21 WARNING: This is a development server. Do not use it in a production deployment. Use a production WSGI server instead.
 * Running on http://127.0.0.1:3000
2023-03-15 14:25:21 Press CTRL+C to quit
			
				Using your browser or the command line, send a GET request to your local API endpoint. The following is an 
					example using the curl command:
				$ curl http://127.0.0.1:3000/hello
{"message": "hello world"}
			
	 
		Step 8: Delete your application from the AWS Cloud
		In this step, you use the AWS SAM CLI sam delete command to delete your application from the 
			AWS Cloud.
		To delete your application from the AWS Cloud
				In your command line, from the sam-app project directory, run the following:
				$ sam delete
			
				The AWS SAM CLI will ask you to confirm. Then, it will delete your application’s Amazon S3 bucket and AWS CloudFormation stack. 
					The following is an example output:
				$ sam delete
    Are you sure you want to delete the stack sam-app in the region us-west-2 ? [y/N]: y
    Are you sure you want to delete the folder sam-app in S3 which contains the artifacts? [y/N]: y
    - Deleting S3 object with key c6ce8fa8b5a97dd022ecd006536eb5a4
    - Deleting S3 object with key 5d513a459d062d644f3b7dd0c8b56a2a.template
    - Deleting S3 object with key sam-app/2bebf67c79f6a743cc5312f6dfc1efee.template
    - Deleting S3 object with key sam-app/6b208d0e42ad15d1cee77d967834784b.template
    - Deleting S3 object with key sam-app/da3c598813f1c2151579b73ad788cac8
    - Deleting S3 object with key sam-app/f798cdd93cee188a71d120f14a035b11
    - Deleting Cloudformation stack sam-app

Deleted successfully
			
	 
		Troubleshooting
		To troubleshoot the AWS SAM CLI, see AWS SAM CLI troubleshooting.
	 
		Learn more
		To continue learning about AWS SAM, see the following resources:
		
		
			 
			
			 
			
			 
		
				The Complete AWS SAM 
					Workshop – A workshop designed to teach you many of the major features that AWS SAM 
					provides.
			
				
					Sessions with SAM – Video series created by our AWS Serverless Developer
					Advocate team on using AWS SAM.
			
				Serverless Land – 
					Site that brings together the latest information, blogs, videos, code, and learning resources for AWS 
					serverless.
			
	Document ConventionsOptional: Verify the AWS SAM CLI installerHow to use AWS SAMDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideKey Lambda conceptsThis chapter describes key concepts in Lambda:
     
     
     
     
     
     
  
      Basic Lambda concepts explains basics such as functions,
        triggers, events, runtimes, and deployment packages.
    
      Programming model explains how Lambda interacts with your code.
    
      Execution environment explains the environment
        Lambda uses to run your code.
    
      Event-driven architectures describes the most
        commonly used design paradigm for serverless applications built using Lambda functions.
    
      Application design explains various design best
        practices for Lambda-based applications.
    
      Frequently asked questions is a curated list of common FAQs about Lambda.
    Document ConventionsCreate your first functionBasic conceptsDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS LambdaDeveloper GuideCreating the functionUsing the console code editorUpdating function codeChanging the runtimeChanging the architectureUsing the Lambda APIDownloading your function codeAWS CloudFormationDeploying Lambda functions as .zip file archivesWhen you create a Lambda function, you package your function code into a deployment package. Lambda supports two
    types of deployment packages: container images and .zip file archives. The workflow 
    to create a function depends on the
    deployment package type. To configure a function defined as a container image, see Create a Lambda function using a container image.You can use the Lambda console and the Lambda API to create a function defined with a .zip file archive. You can
    also upload an updated .zip file to change the function code.
  NoteYou cannot change the deployment package type (.zip or container image) for an existing function. For example, you cannot convert a container image function to use a .zip file archive. You must create a new function.TopicsCreating the functionUsing the console code editorUpdating function codeChanging the runtimeChanging the architectureUsing the Lambda APIDownloading your function codeAWS CloudFormationEncrypting Lambda .zip deployment packages
    Creating the function
    When you create a function defined with a .zip file archive, you choose a code template, the language version,
      and the execution role for the function. You add your function code after Lambda creates the function.
    To create the functionOpen the Functions page of the Lambda console.
        Choose Create function.
      
        Choose Author from scratch or Use a blueprint to create your
          function.  
      
        Under Basic information, do the following:
        
            For Function name, enter the function name. Function names are limited to 64 characters in length.
          
            For Runtime, choose the language version to use for your function.
          
            (Optional) For Architecture, choose the instruction set architecture to use for
              your function. The default architecture is x86_64. When you build the deployment package for your
              function, make sure that it is compatible with this instruction set
                architecture.
          
      
        (Optional) Under Permissions, expand Change default execution
            role. You can create a new Execution role or use an existing role.
      
        (Optional) Expand Advanced settings. You can choose a Code signing
            configuration for the function. You can also configure an (Amazon VPC) for the function to
          access.
      
        Choose Create function.
      
    Lambda creates the new function. You can now use the console to add the function code and configure other function parameters and features. 
      For code deployment instructions, see the handler page for the runtime your function uses.
    
    
  Node.js
      Deploy Node.js Lambda functions with .zip file archives 
    
  
  Python
    
      Working with .zip file archives for Python Lambda functions
    
  
  Ruby
    
      Deploy Ruby Lambda functions with .zip file archives
    
    
  
  Java
    
      Deploy Java Lambda functions with .zip or JAR file archives
    
    
  
  Go
    
      Deploy Go Lambda functions with .zip file archives
    
    
  
  C#
    
      Build and deploy C# Lambda functions with .zip file archives
    
    
  
  PowerShell
    
      Deploy PowerShell Lambda functions with .zip file archives
    
    

   
    Using the console code editor
    The console creates a Lambda function with a single source file. For scripting languages, you can edit
      this file and add more files using the built-in code editor.
      To save your changes, choose Save.
      Then, to run your code, choose Test.
    
     When you save your function code, the Lambda console creates a .zip file archive deployment package. 
   When you develop your function code outside of the console (using an IDE) you need to create a
      deployment package to upload your code to the Lambda function.
   
    Updating function code
    For scripting languages (Node.js, Python, and Ruby), you can edit your function code in the embedded code
        editor. If the code is larger than 3MB, or if you need to add libraries, or
      for languages that the editor doesn't support (Java, Go, C#), you must upload your function code as a .zip
      archive. If the .zip file archive is smaller than 50 MB, you can upload the .zip file archive from your local
      machine. If the file is larger than 50 MB, upload the file to the function from an Amazon S3 bucket.
    To upload function code as a .zip archive Open the Functions page of the Lambda console.
        Choose the function to update and choose the  Code tab.
      
        Under Code source, choose Upload from.
      
        Choose .zip file, and then choose Upload. 
        In the file chooser, select the new image version, choose Open, and then choose
                Save.
      
        (Alternative to step 4) Choose Amazon S3 location.
        
            In the text box, enter the S3 link URL of the .zip file archive, then choose Save.
          
      
   
    Changing the runtime
    If you update the function configuration to use a new runtime, you may need to update the function
      code to be compatible with the new runtime. If you update the function configuration to use a different runtime,
      you must provide new function code that is compatible with the runtime and
      architecture. For instructions on how to create a deployment package for the function code, see the handler page
      for the runtime that the function uses.
    The Node.js 20, Python 3.12, Java 21, .NET 8, Ruby 3.3, and later base images are based on the Amazon Linux 2023 minimal container image. Earlier base images use Amazon Linux 2. AL2023 provides several advantages over Amazon Linux 2, including a smaller deployment footprint and updated versions of libraries such as glibc. For more information, see Introducing the Amazon Linux 2023 runtime for AWS Lambda on the AWS
      Compute Blog.
    To change the runtimeOpen the Functions page of the Lambda console.
        Choose the function to update and choose the Code tab.
      
        Scroll down to the Runtime settings section, which is under the code editor.
      
        Choose Edit.
        
            For Runtime, select the runtime identifier.
          
            For Handler, specify file name and handler for your function.
          
            For Architecture, choose the instruction set architecture to use for your
              function.
          
      
        Choose Save.
      
   
    Changing the architecture
    Before you can change the instruction set architecture, you need to ensure that your function's code is
      compatible with the target architecture. 
    If you use Node.js, Python, or Ruby and you edit your function code in the embedded editor, the existing code may run without modification.
    However, if you provide your function code using a .zip file archive deployment package, you must prepare a
      new .zip file archive that is compiled and built correctly for the target runtime and instruction-set
      architecture. For instructions, see the handler page for your function runtime.
    To change the instruction set architectureOpen the Functions page of the Lambda console.
        Choose the function to update and choose the Code tab.
      
        Under Runtime settings, choose Edit.
      
        For Architecture, choose the instruction set architecture to use for your
          function.
      
        Choose Save.
      
   
    Using the Lambda API
    To create and configure a function that uses a .zip file archive, use the following API operations: 
    
       
       
       
    
        CreateFunction
      
        UpdateFunctionCode
      
        UpdateFunctionConfiguration
      
   
    Downloading your function code
    You can download the current unpublished ($LATEST) version of your function code .zip
      via the Lambda console. To do this, first ensure that you have the following IAM permissions:
    
       
       
       
       
       
       
       
    
        iam:GetPolicy
      
        iam:GetPolicyVersion
      
        iam:GetRole
      
        iam:GetRolePolicy
      
        iam:ListAttachedRolePolicies
      
        iam:ListRolePolicies
      
        iam:ListRoles
      
    To download the function code .zip
        Open the Functions page of the Lambda console.
      
        Choose the function you want to download the function code .zip for.
      
        In the Function overview, choose the Download
          button, then choose Download function code .zip.
        
            Alternatively, choose Download AWS SAM file to generate and
              download a SAM template based on your function's configuration. You can also choose
              Download both to download both the .zip and the SAM template.
          
      
   
    AWS CloudFormation
    
    You can use AWS CloudFormation to create a Lambda function that uses a .zip file archive. In your AWS CloudFormation template, the
      AWS::Lambda::Function resource specifies the Lambda function. For descriptions of the properties in
      the AWS::Lambda::Function resource, see AWS::Lambda::Function in the
      AWS CloudFormation User Guide.
    In the AWS::Lambda::Function resource, set the following properties to create a function defined
      as a .zip file archive:
    
       
    
        AWS::Lambda::Function
        
           
           
           
           
        PackageType – Set to Zip.Code – Enter the Amazon S3 bucket name and .zip file name in the S3Bucket and
              S3Keyfields. For Node.js or Python, you can provide inline source code of your Lambda
              function. 
            Runtime – Set the runtime value.
          
            Architecture – Set the architecture value to arm64 to use the AWS Graviton2
              processor. By default, the architecture value is x86_64.
          
      
  Document ConventionsConfiguring functionsEncryptionDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS X-RayDeveloper GuideWhat is AWS X-Ray?AWS X-Ray is a service that collects data about requests that your application serves, and provides tools that
    you can use to view, filter, and gain insights into that data to identify issues and opportunities for optimization.
    For any traced request to your application, you can see detailed information not only about the request and
    response, but also about calls that your application makes to downstream AWS resources, microservices, databases,
    and web APIs.
     
     
      
     
  AWS X-Ray receives traces from your application, in addition to AWS services your application uses that are
    already integrated with X-Ray. Instrumenting your application involves sending trace data for incoming and outbound
    requests and other events within your application, along with metadata about each request. Many instrumentation
    scenarios require only configuration changes. For example, you can instrument all incoming HTTP requests and
    downstream calls to AWS services that your Java application makes. There are several SDKs, agents, and tools that
    can be used to instrument your application for X-Ray tracing.
    See Instrumenting your application for more information. AWS services that are integrated with X-Ray can add tracing headers to
    incoming requests, send trace data to X-Ray, or run the X-Ray daemon. For example, AWS Lambda can send trace data
    about requests to your Lambda functions, and run the X-Ray daemon on workers to make it simpler to use the X-Ray
    SDK.
     
     
      
     
  Instead of sending trace data directly to X-Ray, each client SDK sends JSON segment documents to a
    daemon process listening for UDP traffic. The X-Ray daemon buffers segments in a queue and uploads them to X-Ray in
    batches. The daemon is available for Linux, Windows, and macOS, and is included on AWS Elastic Beanstalk and
    AWS Lambda platforms.X-Ray uses trace data from the AWS resources that power your cloud applications to generate
    a detailed trace map. The trace map shows the client,
    your front-end service, and backend services that your front-end service calls to process
    requests and persist data. Use the trace map to identify bottlenecks, latency spikes, and
    other issues to solve to improve the performance of your applications.
     
     
      
     
  Document ConventionsGetting startedDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAmazon CloudWatchUser GuideDetect common application problems with CloudWatch Application InsightsYou can use Amazon CloudWatch Application Insights to detect problems with your applications. CloudWatch Application Insights facilitates observability for your applications and underlying AWS resources.
        It helps you set up the best monitors for your application resources to continuously analyze
        data for signs of problems with your applications. Application Insights, which is powered by SageMaker and other AWS
        technologies, provides automated dashboards that show potential problems with monitored
        applications, which help you to quickly isolate ongoing issues with your applications and
        infrastructure. The enhanced visibility into the health of your applications that Application Insights
        provides helps reduce mean time to repair (MTTR) to troubleshoot your application
        issues.When you add your applications to Amazon CloudWatch Application Insights, it scans the resources in the applications and
        recommends and configures metrics and logs on CloudWatch for application components. Example application components include SQL
        Server backend databases and Microsoft IIS/Web tiers. Application Insights analyzes metric patterns
        using historical data to detect anomalies, and continuously detects errors and exceptions
        from your application, operating system, and infrastructure logs. It correlates these
        observations using a combination of classification algorithms and built-in rules. Then, it
        automatically creates dashboards that show the relevant observations and problem severity
        information to help you prioritize your actions. For common problems in .NET and SQL
        application stacks, such as application latency, SQL Server failed backups, memory leaks,
        large HTTP requests, and canceled I/O operations, it provides additional insights that point
        to a possible root cause and steps for resolution. Built-in integration with AWS SSM
            OpsCenter allows you to resolve issues by running the relevant Systems Manager
        Automation document. SectionsWhat is
                Amazon CloudWatch Application Insights?How Application Insights
                worksPrerequisites, IAM policies, and permissionsSet up application for monitoringApplication Insights cross-account observabilityWork with component
                configurationsUse CloudFormation
                templatesTutorial: Set up monitoring for SAP
                ASETutorial: Set up
                monitoring for SAP HANATutorial: Set up monitoring for SAP NetWeaverView and troubleshoot
                Application InsightsSupported logs and
                metricsDocument ConventionsUsing Contributor Insights built-in rules in CloudWatchWhat is
                Amazon CloudWatch Application Insights?Did this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS Serverless Application ModelDeveloper GuideTroubleshootingError messagesWarning messagesAWS SAM CLI troubleshootingThis section provides details on how to troubleshoot error messages when using, installing, and managing the AWS Serverless Application Model Command Line
		Interface (AWS SAM CLI).TopicsTroubleshootingError messagesWarning messages
		Troubleshooting
		For troubleshooting guidance related to AWS SAM CLI, see Troubleshooting installation errors.
	 
		Error messages
		
		 
			Curl error: "curl: (6) Could not
					resolve: ..."
			When trying to invoke the API Gateway endpoint, you see the following error:
			curl: (6) Could not resolve: endpointdomain (Domain name not found)
			This means that you've attempted to send a request to a domain that's not valid. This
				can happen if your serverless application failed to deploy successfully, or if you have a
				typo in your curl command. Verify that the application deployed
				successfully by using the AWS CloudFormation console or the AWS CLI, and verify that your
					curl command is correct.
		 

		
		 
			Error: Can’t find exact
					resource information with given stack name
			When running the sam remote invoke command on an application that contains
				a single Lambda function resource, you see the following error:
			Error: Can't find exact resource information with given <stack-name>. Please provide full resource ARN or --stack-name to resolve the ambiguity.
			
				 
				 
			
					Possible cause: You didn’t provide the --stack-name option.
					
						If a function ARN is not provided as an argument, the sam remote
								invoke command requires that the --stack-name option is
							provided.
					
				
					Solution: Provide the --stack-name option.
					
						The following is an example:
						$ sam remote invoke --stack-name sam-app

Invoking Lambda Function HelloWorldFunction                                                                                                                                                                                                                     
START RequestId: 40593abb-e1ad-4d99-87bd-ac032e364e82 Version: $LATEST
END RequestId: 40593abb-e1ad-4d99-87bd-ac032e364e82
REPORT RequestId: 40593abb-e1ad-4d99-87bd-ac032e364e82  Duration: 11.31 ms      Billed Duration: 12 ms  Memory Size: 128 MB     Max Memory Used: 67 MB  Init Duration: 171.71 ms
{"statusCode":200,"body":"{\"message\":\"hello world\"}"}% 
					
				
		 

		
		 
			Error: Can’t find resource
					information from stack name
			When running the sam remote invoke command and passing a Lambda function ARN
				as an argument, you see the following error:
			Error: Can't find resource information from stack name (<stack-name>) and resource id (<function-id>)
			
				 
				 
				 
			
					Possible cause: You have the stack name value defined in your
							samconfig.toml file.
					
						The AWS SAM CLI first checks your samconfig.toml file for a
							stack name. If specified, the argument is passed as a logical ID value.
					
				
					Solution: Pass the function’s logical ID instead.
					
						You can pass the function’s logical ID as an argument instead of the function’s
							ARN.
					
				
					Solution: Remove the stack name value from your configuration file.
					
						You can remove the stack name value from your configuration file. This prevents
							the AWS SAM CLI from passing your function ARN as a logical ID value.
						Run sam build after modifying your configuration file.
					
				

		 
		
		 
			Error: Failed to create managed
					resources: Unable to locate credentials
			When running the sam deploy command, you see the following
				error:
			Error: Failed to create managed resources: Unable to locate credentials
			This means that you have not set up AWS credentials to enable the AWS SAM CLI to make
				AWS service calls. To fix this, you must set up AWS credentials. For more information,
				see Setting up AWS
            credentials.
		 
		
		
		 
			Error: FileNotFoundError in Windows
			When running commands in AWS SAM CLI on Windows, you may see the following error:
			Error: FileNotFoundError
			Possible cause: The AWS SAM CLI might interact with filepaths that exceed the Windows max path limitation.
			Solution: To resolve this issue, the new long paths behavior must enabled. To do this, see Enable Long Paths in Windows 10, Version 1607, and Later in the
				Microsoft Windows App Development Documentation.
		 
		
		
		 
			Error: pip's dependency resolver
					...
			Example error text:
			ERROR: pip's dependency resolver does not currently take into account all the packages that are installed. This behaviour is the source of the following dependency conflicts. 
aws-sam-cli 1.58.0 requires aws-sam-translator==1.51.0, but you have aws-sam-translator 1.58.0 which is incompatible. 
aws-sam-cli 1.58.0 requires typing-extensions==3.10.0.0, but you have typing-extensions 4.4.0 which is incompatible.
			
				 
			
					Possible cause: If you use pip to install packages, dependencies
						between packages may conflict.
					
						Each version of the aws-sam-cli package depends on a version of the
								aws-sam-translator package. For example, aws-sam-cli
							v1.58.0 may depend on aws-sam-translator v1.51.0.
						If you install the AWS SAM CLI using pip, then install another
							package which depends on a newer version of aws-sam-translator, the
							following will occur:
						
							 
							 
							 
						
								The newer version of aws-sam-translator will install.
							
								The current version of aws-sam-cli and the newer version of
										aws-sam-translator may not be compatible.
							
								When you use the AWS SAM CLI, the dependency resolver error will occur.
							
						Solutions:
								Use the AWS SAM CLI native package installer.
								
										Uninstall the AWS SAM CLI using pip. For instructions, see Uninstalling the AWS SAM CLI.
									
										Install the AWS SAM CLI using the native package installer. For
											instructions, see Install the AWS SAM CLI.
									
										When necessary, upgrade the AWS SAM CLI using the native package installer.
											For instructions, see Upgrading the AWS SAM CLI.
									
							
								If you must use pip, we recommend that you install the AWS SAM
									CLI into a virtual environment. This ensures a clean installation environment and
									an isolated environment if errors occur. For instructions, see Installing the AWS SAM CLI into a virtual environment using 
				pip.
							
					
				
		 

		
		 
			Error: No such command
					‘remote’
			When running the sam remote invoke command, you see the following
				error:
			$ sam remote invoke ...
2023-06-20 08:15:07 Command remote not available
Usage: sam [OPTIONS] COMMAND [ARGS]...
Try 'sam -h' for help.

Error: No such command 'remote'.
			
				 
				 
			
					Possible cause: Your version of the AWS SAM CLI is out of date.
					
						The AWS SAM CLI sam remote invoke command was released with AWS SAM CLI
							version 1.88.0. You can check your version by running the sam --version
							command.
					
				
					Solution: Upgrade your AWS SAM CLI to the latest version.
					
						For instructions, see Upgrading the AWS SAM CLI.
					
				
		 

		
		 
			Error: Running AWS SAM projects
					locally requires Docker. Have you got it installed?
			When running the sam local start-api command, you see the following
				error:
			Error: Running AWS SAM projects locally requires Docker. Have you got it installed?
			This means that you do not have Docker properly installed.
					Docker is required to test your application locally. To fix this, follow
				the instructions for installing Docker for your development host. For more information, see
					Installing Docker.
		 
		
		 
			Error: Security
					Constraints Not Satisfied
			When running sam deploy --guided, you're prompted with the question
						Function may not have authorization defined, Is this
					okay? [y/N]. If you respond to this prompt with N (the
				default response), you see the following error:
			Error: Security Constraints Not Satisfied
			The prompt is informing you that the application you're about to deploy might have a
				publicly accessible Amazon API Gateway API configured without authorization. By responding
					N to this prompt, you're saying that this is not OK.
			To fix this, you have the following options:
			
				 
				 
			
					Configure your application with authorization. For information about configuring
						authorization, see Control API access with your AWS SAM template.
				
					If your intention is to have a publicly accessible API endpoint without
						authorization, restart your deployment and respond to this question with
							Y to indicate that you're OK with deploying.
				
		 
		
		 
			message: Missing Authentication
					Token
			When trying to invoke the API Gateway endpoint, you see the following error:
			{"message":"Missing Authentication Token"}
			This means that you've attempted to send a request to the correct domain, but the URI
				isn't recognizable. To fix this, verify the full URL, and update the curl
				command with the correct URL.
		 
	 
		Warning messages
		
		
		 
			Warning: ... AWS will no longer maintain the 
					Homebrew installer for AWS SAM ...
			When installing the AWS SAM CLI using Homebrew, you see the following warning message:
			Warning: ... AWS will no longer maintain the Homebrew installer for AWS SAM (aws/tap/aws-sam-cli). 
				For AWS supported installations, use the first party installers ...
			
				 
			
					Potential cause: AWS no longer maintaining Homebrew support.
					
						Starting September 2023, AWS will no longer maintain the Homebrew installer for the 
							AWS SAM CLI.
						Solution: Use an AWS supported installation method.
								You can find AWS supported installation methods at Install the AWS SAM CLI.
							
						Solution: To continue using Homebrew, use the community managed installer.
								You can use the community managed Homebrew installer at your discretion. For 
									instructions, see Managing the AWS SAM CLI with Homebrew.
							
					
				
		 
		
	Document ConventionsAWS SAM CLI telemetryConnector referenceDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\nThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Thanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\nDocumentationAWS Serverless Application ModelDeveloper GuidePrerequisites
				Step 1: Initialize the sample Hello World applicationStep 2: Build your applicationStep 3: Deploy your application to the AWS CloudStep 4: Run your applicationStep 5: Interact with your function in the AWS CloudStep 6: Modify and sync your application to the AWS CloudStep 7: (Optional) Test your application locallyStep 8: Delete your application from the AWS CloudTroubleshootingLearn moreTutorial: Deploy a Hello World application with AWS SAMIn this tutorial, you use the AWS Serverless Application Model Command Line Interface (AWS SAM CLI) to complete the following:
		 
		 
        
		 
		 
	
			Initialize, build, and deploy a sample Hello World application.
		
			Make local changes and sync to AWS CloudFormation.
		
			Perform local testing on your development host.
		
			Delete the sample application from the AWS Cloud.
		The sample Hello World application implements a basic API backend. It consists of the 
		following resources:
		 
		 
		 
	
			Amazon API Gateway – API endpoint that you will use to invoke your function.
		
			AWS Lambda – Function that processes the HTTP API GET request and returns a 
				hello world message.
		
			AWS Identity and Access Management (IAM) role – Provisions permissions for the services to 
				securely interact.
		The following diagram shows the components of this application:
		 
			
		 
		 
	TopicsPrerequisites
				Step 1: Initialize the sample Hello World applicationStep 2: Build your applicationStep 3: Deploy your application to the AWS CloudStep 4: Run your applicationStep 5: Interact with your function in the AWS CloudStep 6: Modify and sync your application to the AWS CloudStep 7: (Optional) Test your application locallyStep 8: Delete your application from the AWS CloudTroubleshootingLearn more
		Prerequisites
		Verify that you have completed the following:
		
			 
			 
		
				AWS SAM prerequisites
			
				Install the AWS SAM CLI
			
	 
		
				Step 1: Initialize the sample Hello World application
		In this step, you will use the AWS SAM CLI to create a sample Hello World 
			application project on your local machine.
		To initialize the sample Hello World application
				In your command line, run the following from a starting directory of your choice:
				$ sam init
				NoteThis command initializes your serverless application, creating your project directory. 
					This directory will contain several files and folders. The most important file is template.yaml. This is your AWS SAM template.
					Your version of python must match the version of python listed in the template.yaml file that the sam init command created.
			
				The AWS SAM CLI will guide you through initializing a new application. Configure the following:
				
					 
					 
					 
					 
					 
					 
					 
				
						Select AWS Quick Start Templates to choose a starting template.
					
						Choose the Hello World Example template and download it.
					
						Use the Python runtime and zip package type.
					
						For this tutorial, opt out of AWS X-Ray tracing. To learn more, see What is AWS X-Ray? in the 
							AWS X-Ray Developer Guide.
					
						For this tutorial, opt out of monitoring with Amazon CloudWatch Application Insights. To learn more, see 
							
								Amazon CloudWatch Application Insights in the Amazon CloudWatch User Guide.
					
						For this tutorial, opt out of setting Structured Logging in JSON format on your Lambda functions.
					
						Name your application as sam-app.
					
				To use the AWS SAM CLI interactive flow:
				
					 
					 
				
						Brackets ([ ]) indicate default values. Leave your answer blank to select the default 
							value.
					
						Enter y for yes, and 
							n for no.
					
				The following is an example of the sam init interactive flow:
				$ sam init
...
Which template source would you like to use?
    1 - AWS Quick Start Templates
    2 - Custom Template Location
Choice: 1

Choose an AWS Quick Start application template
    1 - Hello World Example
    2 - Data processing
    3 - Hello World Example with Powertools for AWS Lambda
    4 - Multi-step workflow
    5 - Scheduled task
    6 - Standalone function
    7 - Serverless API
    8 - Infrastructure event management 
    9 - Lambda Response Streaming
   10 - GraphQLApi Hello World Example
   11 - Full Stack
   12 - Lambda EFS example
   13 - Serverless Connector Hello World Example
   14 - Multi-step workflow with Connectors
   15 - DynamoDB Example
   16 - Machine Learning
Template: 1

Use the most popular runtime and package type? (Python and zip) [y/N]: y

Would you like to enable X-Ray tracing on the function(s) in your application?  [y/N]: ENTER

Would you like to enable monitoring using CloudWatch Application Insights?
For more info, please view https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/cloudwatch-application-insights.html [y/N]: ENTER
					
Would you like to set Structured Logging in JSON format on your Lambda functions?  [y/N]: ENTER

Project name [sam-app]: ENTER
			
				The AWS SAM CLI downloads your starting template and creates the application project directory structure on your 
					local machine. The following is an example of the AWS SAM CLI output:
				Cloning from https://github.com/aws/aws-sam-cli-app-templates (process may take a moment)

    -----------------------
    Generating application:
    -----------------------
    Name: sam-app
    Runtime: python3.9
    Architectures: x86_64
    Dependency Manager: pip
    Application Template: hello-world
    Output Directory: .
    Configuration file: sam-app/samconfig.toml

    Next steps can be found in the README file at sam-app/README.md


Commands you can use next
=========================
[*] Create pipeline: cd sam-app && sam pipeline init --bootstrap
[*] Validate SAM template: cd sam-app && sam validate
[*] Test Function in the Cloud: cd sam-app && sam sync --stack-name {stack-name} --watch
			
				From your command line, move to the newly created sam-app directory. The following is an 
					example of what the AWS SAM CLI has created:
				NoteIf tree command is not auto installed run this command:
					brew install tree
				$ cd sam-app

$ tree

├── README.md
├── __init__.py
├── events
│   └── event.json
├── hello_world
│   ├── __init__.py
│   ├── app.py
│   └── requirements.txt
├── samconfig.toml
├── template.yaml
└── tests
    ├── __init__.py
    ├── integration
    │   ├── __init__.py
    │   └── test_api_gateway.py
    ├── requirements.txt
    └── unit
        ├── __init__.py
        └── test_handler.py
        
6 directories, 14 files
				Some important files to highlight:
				
					 
					 
					 
					 
				
						hello_world/app.py – Contains your Lambda function code.
					
						hello_world/requirements.txt – Contains any Python dependencies 
							that your Lambda function requires.
					
						samconfig.toml – Configuration file for your application that 
							stores default parameters used by the AWS SAM CLI.
					
						template.yaml – The AWS SAM template that contains your application infrastructure 
							code.
					
			
		You now have a completely authored serverless application on your local machine!
	 
		Step 2: Build your application
		In this step, you use the AWS SAM CLI to build your application and prepare for deployment. When you build, the 
			AWS SAM CLI creates a .aws-sam directory and organizes your function dependencies, project code, and 
			project files there.
		To build your application
				In your command line, from the sam-app project directory, run the following:
				$ sam build
				Note If you don't have Python on your local machine, use the sam build --use-container
					 command instead. The AWS SAM CLI will create a Docker container that includes your function's 
						runtime and dependencies. This command requires Docker on your local machine. To install 
						Docker, see Installing Docker.
				The following is an example of the AWS SAM CLI output:
				$ sam build
Starting Build use cache
Manifest file is changed (new hash: 3298f1304...d4d421) or dependency folder (.aws-sam/deps/4d3dfad6-a267-47a6-a6cd-e07d6fae318c) is missing for (HelloWorldFunction), downloading dependencies and copying/building source
Building codeuri: /Users/.../Demo/sam-tutorial1/sam-app/hello_world runtime: python3.9 metadata: {} architecture: x86_64 functions: HelloWorldFunction
Running PythonPipBuilder:CleanUp
Running PythonPipBuilder:ResolveDependencies
Running PythonPipBuilder:CopySource
Running PythonPipBuilder:CopySource

Build Succeeded

Built Artifacts  : .aws-sam/build
Built Template   : .aws-sam/build/template.yaml

Commands you can use next
=========================
[*] Validate SAM template: sam validate
[*] Invoke Function: sam local invoke
[*] Test Function in the Cloud: sam sync --stack-name {{stack-name}} --watch
[*] Deploy: sam deploy --guided
				The following is a shortened example of the .aws-sam directory created by the AWS SAM 
					CLI:
				.aws-sam
├── build
│   ├── HelloWorldFunction
│   │   ├── __init__.py
│   │   ├── app.py
│   │   └── requirements.txt
│   └── template.yaml
└── build.toml
			
		Some important files to highlight:
		
			 
			 
			 
		
				build/HelloWorldFunction – Contains your Lambda function code and dependencies. The 
					AWS SAM CLI creates a directory for each function in your application.
			
				build/template.yaml – Contains a copy of your AWS SAM template that is referenced by 
					AWS CloudFormation at deployment.
			
				build.toml – Configuration file that stores default parameter values referenced by 
					the AWS SAM CLI when building and deploying your application.
			
		You are now ready to deploy your application to the AWS Cloud.
	 
		Step 3: Deploy your application to the AWS Cloud
		NoteThis step requires AWS credentials configuration. For more information, see Step 5: Use the AWS CLI to configure AWS credentials in AWS SAM prerequisites.
		In this step, you use the AWS SAM CLI to deploy your application to the AWS Cloud. The AWS SAM CLI will do the 
			following:
		
			 
			 
			 
		
				Guide you through configuring your application settings for deployment.
			
				Upload your application files to Amazon Simple Storage Service (Amazon S3).
			
				Transform your AWS SAM template into an AWS CloudFormation template. It then uploads your template to the AWS CloudFormation service to 
					provision your AWS resources.
			
		To deploy your application
				In your command line, from the sam-app project directory, run the following:
				$ sam deploy --guided
			
				Follow the AWS SAM CLI interactive flow to configure your application settings. Configure the following:
				
					 
					 
					 
					 
					 
					 
					 
					 
					 
				
						The AWS CloudFormation stack name – A stack is a collection of AWS resources 
							that you can manage as a single unit. To learn more, see Working with stacks in the 
							AWS CloudFormation User Guide.
					
						The AWS Region to deploy your AWS CloudFormation stack to. For more information, see 
							AWS CloudFormation 
								endpoints in the AWS CloudFormation User Guide.
					
						For this tutorial, opt out of confirming changes before deploy.
					
						Allow IAM role creation – This lets AWS SAM create the IAM role 
							necessary for your API Gateway resource and Lambda function resource to interact.
					
						For this tutorial, opt out of disabling rollback.
					
						Allow HelloWorldFunction without authorization defined – This message 
							displays because your API Gateway endpoint is configured to be publicly accessible, without authorization. Since this 
							is the intended configuration for your Hello World application, allow the AWS SAM CLI to continue. For more
							information about configuring authorization, see Control API access with your AWS SAM template.
					
						Save arguments to configuration file – This will update your 
							application’s samconfig.toml file with your deployment preferences.
					
						Select the default configuration file name.
					
						Select the default configuration environment.
					
				The following is an example output of the sam deploy --guided interactive flow:
				$ sam deploy --guided

Configuring SAM deploy
======================

    Looking for config file [samconfig.toml] :  Found
    Reading default arguments  :  Success

    Setting default arguments for 'sam deploy'
    =========================================
    Stack Name [sam-app]: ENTER
    AWS Region [us-west-2]: ENTER
    #Shows you resources changes to be deployed and require a 'Y' to initiate deploy
    Confirm changes before deploy [Y/n]: n
    #SAM needs permission to be able to create roles to connect to the resources in your template
    Allow SAM CLI IAM role creation [Y/n]: ENTER
    #Preserves the state of previously provisioned resources when an operation fails
    Disable rollback [y/N]: ENTER
    HelloWorldFunction may not have authorization defined, Is this okay? [y/N]: y
    Save arguments to configuration file [Y/n]: ENTER
    SAM configuration file [samconfig.toml]: ENTER
    SAM configuration environment [default]: ENTER
			
				The AWS SAM CLI deploys your application by doing the following:
				
					 
					 
					 
				
						The AWS SAM CLI creates an Amazon S3 bucket and uploads your .aws-sam directory.
					
						The AWS SAM CLI transforms your AWS SAM template into AWS CloudFormation and uploads it to the AWS CloudFormation service.
					
						AWS CloudFormation provisions your resources.
					
				During deployment, the AWS SAM CLI displays your progress. The following is an example output:
				Looking for resources needed for deployment:

    Managed S3 bucket: aws-sam-cli-managed-default-samclisam-s3-demo-bucket-1a4x26zbcdkqr
    A different default S3 bucket can be set in samconfig.toml

    Parameter "stack_name=sam-app" in [default.deploy.parameters] is defined as a global parameter [default.global.parameters].
    This parameter will be only saved under [default.global.parameters] in /Users/.../Demo/sam-tutorial1/sam-app/samconfig.toml.

    Saved arguments to config file
    Running 'sam deploy' for future deployments will use the parameters saved above.
    The above parameters can be changed by modifying samconfig.toml
    Learn more about samconfig.toml syntax at
    https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/serverless-sam-cli-config.html

File with same data already exists at sam-app/da3c598813f1c2151579b73ad788cac8, skipping upload

    Deploying with following values
    ===============================
    Stack name                   : sam-app
    Region                       : us-west-2
    Confirm changeset            : False
    Disable rollback             : False
    Deployment s3 bucket         : aws-sam-cli-managed-default-samclisam-s3-demo-bucket-1a4x26zbcdkqr
    Capabilities                 : ["CAPABILITY_IAM"]
    Parameter overrides          : {}
    Signing Profiles             : {}

Initiating deployment
=====================

File with same data already exists at sam-app/2bebf67c79f6a743cc5312f6dfc1efee.template, skipping upload


Waiting for changeset to be created..

CloudFormation stack changeset
---------------------------------------------------------------------------------------------------------------------------------------------
Operation                           LogicalResourceId                   ResourceType                        Replacement
---------------------------------------------------------------------------------------------------------------------------------------------
* Modify                            HelloWorldFunction                  AWS::Lambda::Function               False
* Modify                            ServerlessRestApi                   AWS::ApiGateway::RestApi            False
- Delete                            AwsSamAutoDependencyLayerNestedSt   AWS::CloudFormation::Stack          N/A
                                    ack
---------------------------------------------------------------------------------------------------------------------------------------------


Changeset created successfully. arn:aws:cloudformation:us-west-2:012345678910:changeSet/samcli-deploy1678917603/22e05525-08f9-4c52-a2c4-f7f1fd055072


2023-03-15 12:00:16 - Waiting for stack create/update to complete

CloudFormation events from stack operations (refresh every 0.5 seconds)
---------------------------------------------------------------------------------------------------------------------------------------------
ResourceStatus                      ResourceType                        LogicalResourceId                   ResourceStatusReason
---------------------------------------------------------------------------------------------------------------------------------------------
UPDATE_IN_PROGRESS                  AWS::Lambda::Function               HelloWorldFunction                  -
UPDATE_COMPLETE                     AWS::Lambda::Function               HelloWorldFunction                  -
UPDATE_COMPLETE_CLEANUP_IN_PROGRE   AWS::CloudFormation::Stack          sam-app                             -
SS
DELETE_IN_PROGRESS                  AWS::CloudFormation::Stack          AwsSamAutoDependencyLayerNestedSt   -
                                                                        ack
DELETE_COMPLETE                     AWS::CloudFormation::Stack          AwsSamAutoDependencyLayerNestedSt   -
                                                                        ack
UPDATE_COMPLETE                     AWS::CloudFormation::Stack          sam-app                             -
---------------------------------------------------------------------------------------------------------------------------------------------

CloudFormation outputs from deployed stack
----------------------------------------------------------------------------------------------------------------------------------------------
Outputs
----------------------------------------------------------------------------------------------------------------------------------------------
Key                 HelloWorldFunctionIamRole
Description         Implicit IAM Role created for Hello World function
Value               arn:aws:iam::012345678910:role/sam-app-HelloWorldFunctionRole-15GLOUR9LMT1W

Key                 HelloWorldApi
Description         API Gateway endpoint URL for Prod stage for Hello World function
Value               https://<restapiid>.execute-api.us-west-2.amazonaws.com/Prod/hello/

Key                 HelloWorldFunction
Description         Hello World Lambda Function ARN
Value               arn:aws:lambda:us-west-2:012345678910:function:sam-app-HelloWorldFunction-yQDNe17r9maD
----------------------------------------------------------------------------------------------------------------------------------------------


Successfully created/updated stack - sam-app in us-west-2
			
		Your application is now deployed and running in the AWS Cloud!
	 
		Step 4: Run your application
		In this step, you will send a GET request to your API endpoint and see your Lambda function output.
		To get your API endpoint value
				From the information displayed by the AWS SAM CLI in the previous step, locate the Outputs section. 
					In this section, locate your HelloWorldApi resource to find your HTTP endpoint value. The following is an 
					example output:
				----------------------------------------------------------------------------------------------------------------------------------------------
Outputs
----------------------------------------------------------------------------------------------------------------------------------------------
...
Key                 HelloWorldApi
Description         API Gateway endpoint URL for Prod stage for Hello World function
Value               https://ets1gv8lxi.execute-api.us-west-2.amazonaws.com/Prod/hello/
...
----------------------------------------------------------------------------------------------------------------------------------------------
			
				Alternatively, you can use the sam list endpoints --output json command to get this 
					information. The following is an example output:
				$ sam list endpoints --output json
2023-03-15 12:39:19 Loading policies from IAM...
2023-03-15 12:39:25 Finished loading policies from IAM.
[
  {
    "LogicalResourceId": "HelloWorldFunction",
    "PhysicalResourceId": "sam-app-HelloWorldFunction-yQDNe17r9maD",
    "CloudEndpoint": "-",
    "Methods": "-"
  },
  {
    "LogicalResourceId": "ServerlessRestApi",
    "PhysicalResourceId": "ets1gv8lxi",
    "CloudEndpoint": [
      "https://ets1gv8lxi.execute-api.us-west-2.amazonaws.com/Prod",
      "https://ets1gv8lxi.execute-api.us-west-2.amazonaws.com/Stage"
    ],
    "Methods": [
      "/hello['get']"
    ]
  }
]
			
		To invoke your function
				Using your browser or the command line, send a GET request to your API endpoint. The following is an example 
					using the curl command:
				$ curl https://ets1gv8lxi.execute-api.us-west-2.amazonaws.com/Prod/hello/
{"message": "hello world"}
			
	 
		Step 5: Interact with your function in the AWS Cloud
		In this step, you use the AWS SAM CLI to invoke your Lambda function in the AWS Cloud.
		To invoke your Lambda function in the cloud
				Take note of your function’s LogicalResourceId from the previous step. It should be HelloWorldFunction.
			
				In your command line, from the sam-app project directory, run the following:
				$ sam remote invoke HelloWorldFunction --stack-name sam-app
			
				The AWS SAM CLI invokes your function in the cloud and returns a response. The following is an example output:
				$ sam remote invoke HelloWorldFunction --stack-name sam-app

Invoking Lambda Function HelloWorldFunction                                       
START RequestId: d5ef494b-5f45-4086-86fd-d7322fa1a1f9 Version: $LATEST
END RequestId: d5ef494b-5f45-4086-86fd-d7322fa1a1f9
REPORT RequestId: d5ef494b-5f45-4086-86fd-d7322fa1a1f9  Duration: 6.62 ms       Billed Duration: 7 ms     Memory Size: 128 MB     Max Memory Used: 67 MB  Init Duration: 164.06 ms
{"statusCode":200,"body":"{\"message\":\"hello world\"}"}% 
			
		
	 
		Step 6: Modify and sync your application to the AWS Cloud
		In this step, you use the AWS SAM CLI sam sync --watch command to sync local changes to the 
			AWS Cloud.
		To use sam sync
				In your command line, from the sam-app project directory, run the following:
				$ sam sync --watch
			
				The AWS SAM CLI prompts you to confirm that you are syncing a development stack. Since the 
					sam sync --watch command automatically deploys local changes to the AWS Cloud in real time, we 
					recommend it for development environments only.
				The AWS SAM CLI performs an initial deployment before it begins monitoring for local changes. The following is an 
					example output:
				$ sam sync --watch
The SAM CLI will use the AWS Lambda, Amazon API Gateway, and AWS StepFunctions APIs to upload your code without
performing a CloudFormation deployment. This will cause drift in your CloudFormation stack.
**The sync command should only be used against a development stack**.

Confirm that you are synchronizing a development stack.

Enter Y to proceed with the command, or enter N to cancel:
 [Y/n]: y
Queued infra sync. Waiting for in progress code syncs to complete...
Starting infra sync.
Manifest is not changed for (HelloWorldFunction), running incremental build
Building codeuri: /Users/.../Demo/sam-tutorial1/sam-app/hello_world runtime: python3.9 metadata: {} architecture: x86_64 functions: HelloWorldFunction
Running PythonPipBuilder:CopySource

Build Succeeded

Successfully packaged artifacts and wrote output template to file /var/folders/45/5ct135bx3fn2551_ptl5g6_80000gr/T/tmpq3x9vh63.
Execute the following command to deploy the packaged template
sam deploy --template-file /var/folders/45/5ct135bx3fn2551_ptl5g6_80000gr/T/tmpq3x9vh63 --stack-name <YOUR STACK NAME>


    Deploying with following values
    ===============================
    Stack name                   : sam-app
    Region                       : us-west-2
    Disable rollback             : False
    Deployment s3 bucket         : aws-sam-cli-managed-default-samclisam-s3-demo-bucket-1a4x26zbcdkqr
    Capabilities                 : ["CAPABILITY_NAMED_IAM", "CAPABILITY_AUTO_EXPAND"]
    Parameter overrides          : {}
    Signing Profiles             : null

Initiating deployment
=====================


2023-03-15 13:10:05 - Waiting for stack create/update to complete

CloudFormation events from stack operations (refresh every 0.5 seconds)
---------------------------------------------------------------------------------------------------------------------------------------------
ResourceStatus                      ResourceType                        LogicalResourceId                   ResourceStatusReason
---------------------------------------------------------------------------------------------------------------------------------------------
UPDATE_IN_PROGRESS                  AWS::CloudFormation::Stack          sam-app                             Transformation succeeded
CREATE_IN_PROGRESS                  AWS::CloudFormation::Stack          AwsSamAutoDependencyLayerNestedSt   -
                                                                        ack
CREATE_IN_PROGRESS                  AWS::CloudFormation::Stack          AwsSamAutoDependencyLayerNestedSt   Resource creation Initiated
                                                                        ack
CREATE_COMPLETE                     AWS::CloudFormation::Stack          AwsSamAutoDependencyLayerNestedSt   -
                                                                        ack
UPDATE_IN_PROGRESS                  AWS::Lambda::Function               HelloWorldFunction                  -
UPDATE_COMPLETE                     AWS::Lambda::Function               HelloWorldFunction                  -
UPDATE_COMPLETE_CLEANUP_IN_PROGRE   AWS::CloudFormation::Stack          sam-app                             -
SS
UPDATE_COMPLETE                     AWS::CloudFormation::Stack          sam-app                             -
---------------------------------------------------------------------------------------------------------------------------------------------

CloudFormation outputs from deployed stack
----------------------------------------------------------------------------------------------------------------------------------------------
Outputs
----------------------------------------------------------------------------------------------------------------------------------------------
Key                 HelloWorldFunctionIamRole
Description         Implicit IAM Role created for Hello World function
Value               arn:aws:iam::012345678910:role/sam-app-HelloWorldFunctionRole-15GLOUR9LMT1W

Key                 HelloWorldApi
Description         API Gateway endpoint URL for Prod stage for Hello World function
Value               https://ets1gv8lxi.execute-api.us-west-2.amazonaws.com/Prod/hello/

Key                 HelloWorldFunction
Description         Hello World Lambda Function ARN
Value               arn:aws:lambda:us-west-2:012345678910:function:sam-app-HelloWorldFunction-yQDNe17r9maD
----------------------------------------------------------------------------------------------------------------------------------------------


Stack update succeeded. Sync infra completed.

Infra sync completed.
CodeTrigger not created as CodeUri or DefinitionUri is missing for ServerlessRestApi.
			
		Next, you will modify your Lambda function code. The AWS SAM CLI will automatically detect this change and sync your 
			application to the AWS Cloud.
		To modify and sync your application
				In your IDE of choice, open the sam-app/hello_world/app.py file.
			
				Change the message and save your file. The following is an example:
				import json
...
def lambda_handler(event, context):
    ...
    return {
        "statusCode": 200,
        "body": json.dumps({
            "message": "hello everyone!",
            ...
        }),
    }
			
				The AWS SAM CLI detects your change and syncs your application to the AWS Cloud. The following is an example 
					output:
				Syncing Lambda Function HelloWorldFunction...
Manifest is not changed for (HelloWorldFunction), running incremental build
Building codeuri: /Users/.../Demo/sam-tutorial1/sam-app/hello_world runtime: python3.9 metadata: {} architecture: x86_64 functions: HelloWorldFunction
Running PythonPipBuilder:CopySource
Finished syncing Lambda Function HelloWorldFunction.
			
				To verify your change, send a GET request to your API endpoint again.
				$ curl https://ets1gv8lxi.execute-api.us-west-2.amazonaws.com/Prod/hello/
{"message": "hello everyone!"}
			
	 
		Step 7: (Optional) Test your application locally
		NoteThis step is optional.
		ImportantThis step requires Docker on your local machine. You must have Docker installed and configured to use the AWS SAM CLI for local testing. For more 
				information, see Installing Docker.
		In this step, you use the AWS SAM CLI sam local command to test your application locally. To 
			accomplish this, the AWS SAM CLI creates a local environment using Docker. This local environment emulates 
			the cloud-based execution environment of your Lambda function.
		You will do the following:
		
			 
			 
		
				Create a local environment for your Lambda function and invoke it.
			
				Host your HTTP API endpoint locally and use it to invoke your Lambda function.
			
		To invoke your Lambda function locally
				In your command line, from the sam-app project directory, run the following:
				$ sam local invoke
			
				The AWS SAM CLI creates a local Docker container and invokes your function. The following is an 
					example output:
				$ sam local invoke
Invoking app.lambda_handler (python3.9)
Local image was not found.
Removing rapid images for repo public.ecr.aws/sam/emulation-python3.9
Building image.....................
Using local image: public.ecr.aws/lambda/python:3.9-rapid-x86_64.

Mounting /Users/.../Demo/sam-tutorial1/sam-app/.aws-sam/build/HelloWorldFunction as /var/task:ro,delegated inside runtime container
START RequestId: b046db01-2a00-415d-af97-35f3a02e9eb6 Version: $LATEST
END RequestId: b046db01-2a00-415d-af97-35f3a02e9eb6
REPORT RequestId: b046db01-2a00-415d-af97-35f3a02e9eb6    Init Duration: 1.01 ms    Duration: 633.45 ms    Billed Duration: 634 ms    Memory Size: 128 MB    Max Memory Used: 128 MB
{"statusCode": 200, "body": "{\"message\": \"hello world\"}"}
			
		To host your API locally
				In your command line, from the sam-app project directory, run the following:
				$ sam local start-api
			
				The AWS SAM CLI creates a local Docker container for your Lambda function and creates a local 
					HTTP server to simulate your API endpoint. The following is an example output:
				$ sam local start-api
Initializing the lambda functions containers.
Local image is up-to-date
Using local image: public.ecr.aws/lambda/python:3.9-rapid-x86_64.

Mounting /Users/.../Demo/sam-tutorial1/sam-app/.aws-sam/build/HelloWorldFunction as /var/task:ro,delegated inside runtime container
Containers Initialization is done.
Mounting HelloWorldFunction at http://127.0.0.1:3000/hello [GET]
You can now browse to the above endpoints to invoke your functions. You do not need to restart/reload SAM CLI while working on your functions, changes will be reflected instantly/automatically. If you used sam build before running local commands, you will need to re-run sam build for the changes to be picked up. You only need to restart SAM CLI if you update your AWS SAM template
2023-03-15 14:25:21 WARNING: This is a development server. Do not use it in a production deployment. Use a production WSGI server instead.
 * Running on http://127.0.0.1:3000
2023-03-15 14:25:21 Press CTRL+C to quit
			
				Using your browser or the command line, send a GET request to your local API endpoint. The following is an 
					example using the curl command:
				$ curl http://127.0.0.1:3000/hello
{"message": "hello world"}
			
	 
		Step 8: Delete your application from the AWS Cloud
		In this step, you use the AWS SAM CLI sam delete command to delete your application from the 
			AWS Cloud.
		To delete your application from the AWS Cloud
				In your command line, from the sam-app project directory, run the following:
				$ sam delete
			
				The AWS SAM CLI will ask you to confirm. Then, it will delete your application’s Amazon S3 bucket and AWS CloudFormation stack. 
					The following is an example output:
				$ sam delete
    Are you sure you want to delete the stack sam-app in the region us-west-2 ? [y/N]: y
    Are you sure you want to delete the folder sam-app in S3 which contains the artifacts? [y/N]: y
    - Deleting S3 object with key c6ce8fa8b5a97dd022ecd006536eb5a4
    - Deleting S3 object with key 5d513a459d062d644f3b7dd0c8b56a2a.template
    - Deleting S3 object with key sam-app/2bebf67c79f6a743cc5312f6dfc1efee.template
    - Deleting S3 object with key sam-app/6b208d0e42ad15d1cee77d967834784b.template
    - Deleting S3 object with key sam-app/da3c598813f1c2151579b73ad788cac8
    - Deleting S3 object with key sam-app/f798cdd93cee188a71d120f14a035b11
    - Deleting Cloudformation stack sam-app

Deleted successfully
			
	 
		Troubleshooting
		To troubleshoot the AWS SAM CLI, see AWS SAM CLI troubleshooting.
	 
		Learn more
		To continue learning about AWS SAM, see the following resources:
		
		
			 
			
			 
			
			 
		
				The Complete AWS SAM 
					Workshop – A workshop designed to teach you many of the major features that AWS SAM 
					provides.
			
				
					Sessions with SAM – Video series created by our AWS Serverless Developer
					Advocate team on using AWS SAM.
			
				Serverless Land – 
					Site that brings together the latest information, blogs, videos, code, and learning resources for AWS 
					serverless.
			
	Document ConventionsOptional: Verify the AWS SAM CLI installerHow to use AWS SAMDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.\n\n\n\n